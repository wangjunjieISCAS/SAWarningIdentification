GitDiffStart: 400c39bac773f6ecde70eb7808625084730fa9f1 | Wed Apr 15 13:09:20 2015 +0000
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/Bounds.java b/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/Bounds.java
index ea9f6b4..9837d43 100755
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/Bounds.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/Bounds.java
@@ -268,6 +268,18 @@ public class Bounds
         }
         return this;
     }
+
+    public Bounds addPoint(double latitude, double longitude) {
+        if (!noLongitudeBound) {
+            // Get a longitude value
+            addLongitudeBound(longitude);
+        }
+        if (!noTopLatitudeBound || !noBottomLatitudeBound) {
+            // Compute a latitude value
+            addLatitudeBound(latitude);
+        }
+        return this;
+    }
     
     public Bounds noLongitudeBound() {
         noLongitudeBound = true;
@@ -287,4 +299,4 @@ public class Bounds
         minLatitude = null;
         return this;
     }
-}
\ No newline at end of file
+}
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoBBoxFactory.java b/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoBBoxFactory.java
index 58e3321..72fab1b 100755
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoBBoxFactory.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoBBoxFactory.java
@@ -41,18 +41,35 @@ public class GeoBBoxFactory
         if (leftLon == -Math.PI && rightLon == Math.PI) {
             if (topLat == Math.PI * 0.5 && bottomLat == -Math.PI * 0.5)
                 return new GeoWorld();
+            if (topLat == bottomLat)
+                return new GeoDegenerateLatitudeZone(topLat);
             return new GeoLatitudeZone(topLat, bottomLat);
         }
         double extent = rightLon - leftLon;
         if (extent < 0.0)
           extent += Math.PI * 2.0;
         if (topLat == Math.PI * 0.5 && bottomLat == -Math.PI * 0.5) {
+          if (leftLon == rightLon)
+            return new GeoDegenerateLongitudeSlice(leftLon);
+
           if (extent >= Math.PI)
             return new GeoWideLongitudeSlice(leftLon, rightLon);
+          
           return new GeoLongitudeSlice(leftLon, rightLon);
         }
-        if (extent >= Math.PI)
+        if (leftLon == rightLon) {
+          if (topLat == bottomLat)
+            return new GeoDegeneratePoint(topLat, leftLon);
+          return new GeoDegenerateVerticalLine(topLat, bottomLat, leftLon);
+        }
+        if (extent >= Math.PI) {
+          if (topLat == bottomLat) {
+            return new GeoWideDegenerateHorizontalLine(topLat, leftLon, rightLon);
+          }
           return new GeoWideRectangle(topLat, bottomLat, leftLon, rightLon);
+        }
+        if (topLat == bottomLat)
+          return new GeoDegenerateHorizontalLine(topLat, leftLon, rightLon);
         return new GeoRectangle(topLat, bottomLat, leftLon, rightLon);
     }
 
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoDegenerateHorizontalLine.java b/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoDegenerateHorizontalLine.java
new file mode 100644
index 0000000..233a077
--- /dev/null
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoDegenerateHorizontalLine.java
@@ -0,0 +1,181 @@
+package org.apache.lucene.spatial.spatial4j.geo3d;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/** Degenerate bounding box limited on two sides (left lon, right lon).
+* The left-right maximum extent for this shape is PI; for anything larger, use
+* GeoWideDegenerateHorizontalLine.
+*/
+public class GeoDegenerateHorizontalLine implements GeoBBox
+{
+    public final double latitude;
+    public final double leftLon;
+    public final double rightLon;
+      
+    public final GeoPoint LHC;
+    public final GeoPoint RHC;
+    
+    public final Plane plane;
+    public final SidedPlane leftPlane;
+    public final SidedPlane rightPlane;
+      
+    public final GeoPoint centerPoint;
+
+    /** Accepts only values in the following ranges: lat: {@code -PI/2 -> PI/2}, lon: {@code -PI -> PI} */
+    public GeoDegenerateHorizontalLine(double latitude, double leftLon, double rightLon)
+    {
+        // Argument checking
+        if (latitude > Math.PI * 0.5 || latitude < -Math.PI * 0.5)
+            throw new IllegalArgumentException("Latitude out of range");
+        if (leftLon < -Math.PI || leftLon > Math.PI)
+            throw new IllegalArgumentException("Left longitude out of range");
+        if (rightLon < -Math.PI || rightLon > Math.PI)
+            throw new IllegalArgumentException("Right longitude out of range");
+        double extent = rightLon - leftLon;
+        if (extent < 0.0) {
+            extent += 2.0 * Math.PI;
+        }
+        if (extent > Math.PI)
+            throw new IllegalArgumentException("Width of rectangle too great");
+
+        this.latitude = latitude;
+        this.leftLon = leftLon;
+        this.rightLon = rightLon;
+          
+        double sinLatitude = Math.sin(latitude);
+        double cosLatitude = Math.cos(latitude);
+        double sinLeftLon = Math.sin(leftLon);
+        double cosLeftLon = Math.cos(leftLon);
+        double sinRightLon = Math.sin(rightLon);
+        double cosRightLon = Math.cos(rightLon);
+        
+        // Now build the two points
+        this.LHC = new GeoPoint(sinLatitude,sinLeftLon,cosLatitude,cosLeftLon);
+        this.RHC = new GeoPoint(sinLatitude,sinRightLon,cosLatitude,cosRightLon);
+        
+        this.plane = new Plane(sinLatitude);
+          
+        double middleLon = (leftLon + rightLon) * 0.5;
+        double sinMiddleLon = Math.sin(middleLon);
+        double cosMiddleLon = Math.cos(middleLon);
+          
+        centerPoint = new GeoPoint(sinLatitude,sinMiddleLon,cosLatitude,cosMiddleLon);
+        this.leftPlane = new SidedPlane(centerPoint,cosLeftLon,sinLeftLon);
+        this.rightPlane = new SidedPlane(centerPoint,cosRightLon,sinRightLon);
+
+    }
+
+    @Override
+    public GeoBBox expand(double angle)
+    {
+        double newTopLat = latitude + angle;
+        double newBottomLat = latitude - angle;
+        // Figuring out when we escalate to a special case requires some prefiguring
+        double currentLonSpan = rightLon - leftLon;
+        if (currentLonSpan < 0.0)
+            currentLonSpan += Math.PI * 2.0;
+        double newLeftLon = leftLon - angle;
+        double newRightLon = rightLon + angle;
+        if (currentLonSpan + 2.0 * angle >= Math.PI * 2.0) {
+            newLeftLon = -Math.PI;
+            newRightLon = Math.PI;
+        }
+        return GeoBBoxFactory.makeGeoBBox(newTopLat,newBottomLat,newLeftLon,newRightLon);
+    }
+
+    @Override
+    public boolean isWithin(Vector point)
+    {
+        return plane.evaluate(point) == 0.0 &&
+          leftPlane.isWithin(point) &&
+          rightPlane.isWithin(point);
+    }
+
+    @Override
+    public boolean isWithin(double x, double y, double z)
+    {
+        return plane.evaluate(x,y,z) == 0.0 &&
+          leftPlane.isWithin(x,y,z) &&
+          rightPlane.isWithin(x,y,z);
+    }
+
+    @Override
+    public double getRadius()
+    {
+        double topAngle = centerPoint.arcDistance(RHC);
+        double bottomAngle = centerPoint.arcDistance(LHC);
+        return Math.max(topAngle,bottomAngle);
+    }
+      
+    @Override
+    public GeoPoint getInteriorPoint()
+    {
+        return centerPoint;
+    }
+      
+    @Override
+    public boolean intersects(Plane p, Membership... bounds)
+    {
+        return p.intersects(plane,bounds,leftPlane,rightPlane);
+    }
+
+    /** Compute longitude/latitude bounds for the shape.
+    *@param bounds is the optional input bounds object.  If this is null,
+    * a bounds object will be created.  Otherwise, the input object will be modified.
+    *@return a Bounds object describing the shape's bounds.  If the bounds cannot
+    * be computed, then return a Bounds object with noLongitudeBound,
+    * noTopLatitudeBound, and noBottomLatitudeBound.
+    */
+    @Override
+    public Bounds getBounds(Bounds bounds)
+    {
+        if (bounds == null)
+            bounds = new Bounds();
+        bounds.addLatitudeZone(latitude).addLongitudeSlice(leftLon,rightLon);
+        return bounds;
+    }
+
+    @Override
+    public int getRelationship(GeoShape path) {
+        if (path.intersects(plane,leftPlane,rightPlane))
+            return OVERLAPS;
+
+        if (path.isWithin(centerPoint))
+            return CONTAINS;
+
+        return DISJOINT;
+    }
+
+    @Override
+    public boolean equals(Object o)
+    {
+        if (!(o instanceof GeoDegenerateHorizontalLine))
+            return false;
+        GeoDegenerateHorizontalLine other = (GeoDegenerateHorizontalLine)o;
+        return other.LHC.equals(LHC) && other.RHC.equals(RHC);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = LHC.hashCode();
+        result = 31 * result + RHC.hashCode();
+        return result;
+    }
+}
+  
+
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoDegenerateLatitudeZone.java b/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoDegenerateLatitudeZone.java
new file mode 100644
index 0000000..3d69275
--- /dev/null
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoDegenerateLatitudeZone.java
@@ -0,0 +1,130 @@
+package org.apache.lucene.spatial.spatial4j.geo3d;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/** This GeoBBox represents an area rectangle of one specific latitude with
+* no longitude bounds.
+*/
+public class GeoDegenerateLatitudeZone implements GeoBBox
+{
+    public final double latitude;
+    
+    public final double sinLatitude;
+    public final Plane plane;
+    public final GeoPoint interiorPoint;
+
+    public GeoDegenerateLatitudeZone(double latitude)
+    {
+        this.latitude = latitude;
+          
+        this.sinLatitude = Math.sin(latitude);
+        double cosLatitude = Math.cos(latitude);
+        this.plane = new Plane(sinLatitude);
+
+        // Compute an interior point.  
+        interiorPoint = new GeoPoint(cosLatitude,0.0,sinLatitude);
+    }
+
+    @Override
+    public GeoBBox expand(double angle)
+    {
+        double newTopLat = latitude + angle;
+        double newBottomLat = latitude - angle;
+        return GeoBBoxFactory.makeGeoBBox(newTopLat, newBottomLat, -Math.PI, Math.PI);
+    }
+
+    @Override
+    public boolean isWithin(Vector point)
+    {
+        return point.z == this.sinLatitude;
+    }
+
+    @Override
+    public boolean isWithin(double x, double y, double z)
+    {
+        return z == this.sinLatitude;
+    }
+
+    @Override
+    public double getRadius()
+    {
+        return Math.PI;
+    }
+
+    @Override
+    public GeoPoint getInteriorPoint()
+    {
+        return interiorPoint;
+    }
+      
+    @Override
+    public boolean intersects(Plane p, Membership... bounds)
+    {
+        return p.intersects(plane,bounds);
+    }
+
+    /** Compute longitude/latitude bounds for the shape.
+    *@param bounds is the optional input bounds object.  If this is null,
+    * a bounds object will be created.  Otherwise, the input object will be modified.
+    *@return a Bounds object describing the shape's bounds.  If the bounds cannot
+    * be computed, then return a Bounds object with noLongitudeBound,
+    * noTopLatitudeBound, and noBottomLatitudeBound.
+    */
+    @Override
+    public Bounds getBounds(Bounds bounds)
+    {
+        if (bounds == null)
+            bounds = new Bounds();
+        bounds.noLongitudeBound().addLatitudeZone(latitude);
+        return bounds;
+    }
+
+    @Override
+    public int getRelationship(GeoShape path) {
+        // Second, the shortcut of seeing whether endpoints are in/out is not going to 
+        // work with no area endpoints.  So we rely entirely on intersections.
+        //System.out.println("Got here! latitude="+latitude+" path="+path);
+        
+        if (path.intersects(plane)) {
+            return OVERLAPS;
+        }
+
+        if (path.isWithin(interiorPoint)) {
+            return CONTAINS;
+        }
+        
+        return DISJOINT;
+    }
+
+    @Override
+    public boolean equals(Object o)
+    {
+        if (!(o instanceof GeoDegenerateLatitudeZone))
+            return false;
+        GeoDegenerateLatitudeZone other = (GeoDegenerateLatitudeZone)o;
+        return other.latitude == latitude;
+    }
+
+    @Override
+    public int hashCode() {
+        long temp = Double.doubleToLongBits(latitude);
+        int result = (int) (temp ^ (temp >>> 32));
+        return result;
+    }
+}
+
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoDegenerateLongitudeSlice.java b/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoDegenerateLongitudeSlice.java
new file mode 100644
index 0000000..4a5a560
--- /dev/null
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoDegenerateLongitudeSlice.java
@@ -0,0 +1,143 @@
+package org.apache.lucene.spatial.spatial4j.geo3d;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/** Degenerate longitude slice.
+*/
+public class GeoDegenerateLongitudeSlice implements GeoBBox
+{
+    public final double longitude;
+    
+    public final double sinLongitude;
+    public final double cosLongitude;
+    public final SidedPlane boundingPlane;
+    public final Plane plane;
+    public final GeoPoint interiorPoint;
+
+    /** Accepts only values in the following ranges: lon: {@code -PI -> PI} */
+    public GeoDegenerateLongitudeSlice(double longitude)
+    {
+        // Argument checking
+        if (longitude < -Math.PI || longitude > Math.PI)
+            throw new IllegalArgumentException("Longitude out of range");
+        this.longitude = longitude;
+          
+        this.sinLongitude = Math.sin(longitude);
+        this.cosLongitude = Math.cos(longitude);
+
+        this.plane = new Plane(cosLongitude, sinLongitude);
+        // We need a bounding plane too, which is perpendicular to the longitude plane and sided so that the point (0.0, longitude) is inside.
+        this.interiorPoint = new GeoPoint(cosLongitude, sinLongitude, 0.0);
+        this.boundingPlane = new SidedPlane(interiorPoint, -sinLongitude, cosLongitude);
+    }
+
+    @Override
+    public GeoBBox expand(double angle)
+    {
+        // Figuring out when we escalate to a special case requires some prefiguring
+        double newLeftLon = longitude - angle;
+        double newRightLon = longitude + angle;
+        double currentLonSpan = 2.0 * angle;
+        if (currentLonSpan + 2.0 * angle >= Math.PI * 2.0) {
+            newLeftLon = -Math.PI;
+            newRightLon = Math.PI;
+        }
+        return GeoBBoxFactory.makeGeoBBox(Math.PI * 0.5,-Math.PI * 0.5,newLeftLon,newRightLon);
+    }
+
+    @Override
+    public boolean isWithin(Vector point)
+    {
+        return plane.evaluate(point) == 0.0 &&
+            boundingPlane.isWithin(point);
+    }
+
+    @Override
+    public boolean isWithin(double x, double y, double z)
+    {
+        return plane.evaluate(x,y,z) == 0.0 &&
+            boundingPlane.isWithin(x,y,z);
+    }
+
+    @Override
+    public double getRadius()
+    {
+        return Math.PI * 0.5;
+    }
+      
+    @Override
+    public GeoPoint getInteriorPoint()
+    {
+        return interiorPoint;
+    }
+      
+    @Override
+    public boolean intersects(Plane p, Membership... bounds)
+    {
+        return p.intersects(plane,bounds,boundingPlane);
+    }
+
+    /** Compute longitude/latitude bounds for the shape.
+    *@param bounds is the optional input bounds object.  If this is null,
+    * a bounds object will be created.  Otherwise, the input object will be modified.
+    *@return a Bounds object describing the shape's bounds.  If the bounds cannot
+    * be computed, then return a Bounds object with noLongitudeBound,
+    * noTopLatitudeBound, and noBottomLatitudeBound.
+    */
+    @Override
+    public Bounds getBounds(Bounds bounds)
+    {
+        if (bounds == null)
+            bounds = new Bounds();
+        bounds.noTopLatitudeBound().noBottomLatitudeBound();
+        bounds.addLongitudeSlice(longitude,longitude);
+        return bounds;
+    }
+
+    @Override
+    public int getRelationship(GeoShape path) {
+        // Look for intersections.
+        if (path.intersects(plane,boundingPlane))
+            return OVERLAPS;
+
+        if (path.isWithin(interiorPoint))
+            return CONTAINS;
+
+        return DISJOINT;
+    }
+
+    @Override
+    public boolean equals(Object o)
+    {
+        if (!(o instanceof GeoDegenerateLongitudeSlice))
+            return false;
+        GeoDegenerateLongitudeSlice other = (GeoDegenerateLongitudeSlice)o;
+        return other.longitude == longitude;
+    }
+
+    @Override
+    public int hashCode() {
+        int result;
+        long temp;
+        temp = Double.doubleToLongBits(longitude);
+        result = (int) (temp ^ (temp >>> 32));
+        return result;
+    }
+}
+  
+
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoDegeneratePoint.java b/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoDegeneratePoint.java
new file mode 100644
index 0000000..6299f72
--- /dev/null
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoDegeneratePoint.java
@@ -0,0 +1,157 @@
+package org.apache.lucene.spatial.spatial4j.geo3d;
+    
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/** This class represents a degenerate point bounding box.
+* It is not a simple GeoPoint because we must have the latitude and longitude.
+*/
+public class GeoDegeneratePoint extends GeoPoint implements GeoBBox
+{
+    public final double latitude;
+    public final double longitude;
+    
+    public GeoDegeneratePoint(double lat, double lon)
+    {
+        super(lat,lon);
+        this.latitude = lat;
+        this.longitude = lon;
+    }
+
+    /** Expand box by specified angle.
+     *@param angle is the angle amount to expand the GeoBBox by.
+     *@return a new GeoBBox.
+     */
+    @Override
+    public GeoBBox expand(double angle) {
+        double newTopLat = latitude + angle;
+        double newBottomLat = latitude - angle;
+        double newLeftLon = longitude - angle;
+        double newRightLon = longitude + angle;
+        return GeoBBoxFactory.makeGeoBBox(newTopLat, newBottomLat, newLeftLon, newRightLon);
+    }
+
+    /** Return a sample point that is inside the shape.
+     *@return an interior point.
+     */
+    @Override
+    public GeoPoint getInteriorPoint() {
+        return this;
+    }
+    
+    /** Assess whether a plane, within the provided bounds, intersects
+     * with the shape.
+     *@param plane is the plane to assess for intersection with the shape's edges or
+     *  bounding curves.
+     *@param bounds are a set of bounds that define an area that an
+     *  intersection must be within in order to qualify (provided by a GeoArea).
+     *@return true if there's such an intersection, false if not.
+     */
+    @Override
+    public boolean intersects(Plane plane, Membership... bounds) {
+        if (plane.evaluate(this) == 0.0)
+            return false;
+        
+        for (Membership m : bounds) {
+            if (!m.isWithin(this))
+                return false;
+        }
+        return true;
+    }
+
+    /** Compute longitude/latitude bounds for the shape.
+    *@param bounds is the optional input bounds object.  If this is null,
+    * a bounds object will be created.  Otherwise, the input object will be modified.
+    *@return a Bounds object describing the shape's bounds.  If the bounds cannot
+    * be computed, then return a Bounds object with noLongitudeBound,
+    * noTopLatitudeBound, and noBottomLatitudeBound.
+    */
+    @Override
+    public Bounds getBounds(Bounds bounds) {
+        if (bounds == null)
+            bounds = new Bounds();
+        bounds.addPoint(latitude,longitude);
+        return bounds;
+    }
+
+    /** Equals */
+    @Override
+    public boolean equals(Object o) {
+        if (!(o instanceof GeoDegeneratePoint))
+            return false;
+        GeoDegeneratePoint other = (GeoDegeneratePoint)o;
+        return other.latitude == latitude && other.longitude == longitude;
+    }
+
+    @Override
+    public int hashCode() {
+        int result;
+        long temp;
+        temp = Double.doubleToLongBits(latitude);
+        result = (int) (temp ^ (temp >>> 32));
+        temp = Double.doubleToLongBits(longitude);
+        result = 31 * result + (int) (temp ^ (temp >>> 32));
+        return result;
+    }
+    
+    /** Check if a point is within this shape.
+     *@param point is the point to check.
+     *@return true if the point is within this shape
+     */
+    @Override
+    public boolean isWithin(Vector point) {
+        return isWithin(point.x,point.y,point.z);
+    }
+
+    /** Check if a point is within this shape.
+     *@param x is x coordinate of point to check.
+     *@param y is y coordinate of point to check.
+     *@param z is z coordinate of point to check.
+     *@return true if the point is within this shape
+     */
+    @Override
+    public boolean isWithin(double x, double y, double z) {
+        return x == this.x && y == this.y && z == this.z;
+    }
+
+    /** Returns the radius of a circle into which the GeoSizeable area can
+     * be inscribed.
+     *@return the radius.
+     */
+    @Override
+    public double getRadius() {
+        return 0.0;
+    }
+
+    /** Find the spatial relationship between a shape and the current geo area.
+     * Note: return value is how the GeoShape relates to the GeoArea, not the
+     * other way around. For example, if this GeoArea is entirely within the
+     * shape, then CONTAINS should be returned.  If the shape is entirely enclosed
+     * by this GeoArea, then WITHIN should be returned.
+     *@param shape is the shape to consider.
+     *@return the relationship, from the perspective of the shape.
+     */
+    @Override
+    public int getRelationship(GeoShape shape) {
+        if (shape.isWithin(this))
+            return CONTAINS;
+
+        return DISJOINT;
+    }
+
+}
+
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoDegenerateVerticalLine.java b/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoDegenerateVerticalLine.java
new file mode 100644
index 0000000..f3ddb2c
--- /dev/null
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoDegenerateVerticalLine.java
@@ -0,0 +1,182 @@
+package org.apache.lucene.spatial.spatial4j.geo3d;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/** Degenerate bounding box limited on two sides (top lat, bottom lat).
+*/
+public class GeoDegenerateVerticalLine implements GeoBBox
+{
+    public final double topLat;
+    public final double bottomLat;
+    public final double longitude;
+      
+    public final GeoPoint UHC;
+    public final GeoPoint LHC;
+    
+    public final SidedPlane topPlane;
+    public final SidedPlane bottomPlane;
+    public final SidedPlane boundingPlane;
+    public final Plane plane;
+      
+    public final GeoPoint centerPoint;
+
+    /** Accepts only values in the following ranges: lat: {@code -PI/2 -> PI/2}, longitude: {@code -PI -> PI} */
+    public GeoDegenerateVerticalLine(double topLat, double bottomLat, double longitude)
+    {
+        // Argument checking
+        if (topLat > Math.PI * 0.5 || topLat < -Math.PI * 0.5)
+            throw new IllegalArgumentException("Top latitude out of range");
+        if (bottomLat > Math.PI * 0.5 || bottomLat < -Math.PI * 0.5)
+            throw new IllegalArgumentException("Bottom latitude out of range");
+        if (topLat < bottomLat)
+            throw new IllegalArgumentException("Top latitude less than bottom latitude");
+        if (longitude < -Math.PI || longitude > Math.PI)
+            throw new IllegalArgumentException("Longitude out of range");
+
+        this.topLat = topLat;
+        this.bottomLat = bottomLat;
+        this.longitude = longitude;
+          
+        double sinTopLat = Math.sin(topLat);
+        double cosTopLat = Math.cos(topLat);
+        double sinBottomLat = Math.sin(bottomLat);
+        double cosBottomLat = Math.cos(bottomLat);
+        double sinLongitude = Math.sin(longitude);
+        double cosLongitude = Math.cos(longitude);
+        
+        // Now build the two points
+        this.UHC = new GeoPoint(sinTopLat,sinLongitude,cosTopLat,cosLongitude);
+        this.LHC = new GeoPoint(sinBottomLat,sinLongitude,cosBottomLat,cosLongitude);
+        
+        this.plane = new Plane(cosLongitude,sinLongitude);
+          
+        double middleLat = (topLat + bottomLat) * 0.5;
+        double sinMiddleLat = Math.sin(middleLat);
+        double cosMiddleLat = Math.cos(middleLat);
+          
+        centerPoint = new GeoPoint(sinMiddleLat,sinLongitude,cosMiddleLat,cosLongitude);
+
+        this.topPlane = new SidedPlane(centerPoint,sinTopLat);
+        this.bottomPlane = new SidedPlane(centerPoint,sinBottomLat);
+
+        this.boundingPlane = new SidedPlane(centerPoint,-sinLongitude,cosLongitude);
+
+    }
+
+    @Override
+    public GeoBBox expand(double angle)
+    {
+        double newTopLat = topLat + angle;
+        double newBottomLat = bottomLat - angle;
+        double newLeftLon = longitude - angle;
+        double newRightLon = longitude + angle;
+        double currentLonSpan = 2.0 * angle;
+        if (currentLonSpan + 2.0 * angle >= Math.PI * 2.0) {
+            newLeftLon = -Math.PI;
+            newRightLon = Math.PI;
+        }
+        return GeoBBoxFactory.makeGeoBBox(newTopLat,newBottomLat,newLeftLon,newRightLon);
+    }
+
+    @Override
+    public boolean isWithin(Vector point)
+    {
+        return plane.evaluate(point) == 0.0 &&
+          boundingPlane.isWithin(point) &&
+          topPlane.isWithin(point) &&
+          bottomPlane.isWithin(point);
+    }
+
+    @Override
+    public boolean isWithin(double x, double y, double z)
+    {
+        return plane.evaluate(x,y,z) == 0.0 &&
+          boundingPlane.isWithin(x,y,z) &&
+          topPlane.isWithin(x,y,z) &&
+          bottomPlane.isWithin(x,y,z);
+    }
+
+    @Override
+    public double getRadius()
+    {
+        // Here we compute the distance from the middle point to one of the corners.  However, we need to be careful
+        // to use the longest of three distances: the distance to a corner on the top; the distnace to a corner on the bottom, and
+        // the distance to the right or left edge from the center.
+        double topAngle = centerPoint.arcDistance(UHC);
+        double bottomAngle = centerPoint.arcDistance(LHC);
+        return Math.max(topAngle,bottomAngle);
+    }
+      
+    @Override
+    public GeoPoint getInteriorPoint()
+    {
+        return centerPoint;
+    }
+      
+    @Override
+    public boolean intersects(Plane p, Membership... bounds)
+    {
+        return p.intersects(plane,bounds,boundingPlane,topPlane,bottomPlane);
+    }
+
+    /** Compute longitude/latitude bounds for the shape.
+    *@param bounds is the optional input bounds object.  If this is null,
+    * a bounds object will be created.  Otherwise, the input object will be modified.
+    *@return a Bounds object describing the shape's bounds.  If the bounds cannot
+    * be computed, then return a Bounds object with noLongitudeBound,
+    * noTopLatitudeBound, and noBottomLatitudeBound.
+    */
+    @Override
+    public Bounds getBounds(Bounds bounds)
+    {
+        if (bounds == null)
+            bounds = new Bounds();
+        bounds.addLatitudeZone(topLat).addLatitudeZone(bottomLat)
+            .addLongitudeSlice(longitude,longitude);
+        return bounds;
+    }
+
+    @Override
+    public int getRelationship(GeoShape path) {
+        if (path.intersects(plane,boundingPlane,topPlane,bottomPlane))
+            return OVERLAPS;
+
+        if (path.isWithin(centerPoint))
+            return CONTAINS;
+
+        return DISJOINT;
+    }
+
+    @Override
+    public boolean equals(Object o)
+    {
+        if (!(o instanceof GeoDegenerateVerticalLine))
+            return false;
+        GeoDegenerateVerticalLine other = (GeoDegenerateVerticalLine)o;
+        return other.UHC.equals(UHC) && other.LHC.equals(LHC);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = UHC.hashCode();
+        result = 31 * result + LHC.hashCode();
+        return result;
+    }
+}
+  
+
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoRectangle.java b/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoRectangle.java
index 007beee..9faad9a 100755
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoRectangle.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoRectangle.java
@@ -83,11 +83,6 @@ public class GeoRectangle implements GeoBBox
         this.LRHC = new GeoPoint(sinBottomLat,sinRightLon,cosBottomLat,cosRightLon);
         this.LLHC = new GeoPoint(sinBottomLat,sinLeftLon,cosBottomLat,cosLeftLon);
         
-        this.topPlane = new SidedPlane(LRHC,sinTopLat);
-        this.bottomPlane = new SidedPlane(ULHC,sinBottomLat);
-        this.leftPlane = new SidedPlane(LRHC,cosLeftLon,sinLeftLon);
-        this.rightPlane = new SidedPlane(LLHC,cosRightLon,sinRightLon);
-          
         double middleLat = (topLat + bottomLat) * 0.5;
         double sinMiddleLat = Math.sin(middleLat);
         cosMiddleLat = Math.cos(middleLat);
@@ -95,7 +90,13 @@ public class GeoRectangle implements GeoBBox
         double sinMiddleLon = Math.sin(middleLon);
         double cosMiddleLon = Math.cos(middleLon);
           
-        centerPoint = new GeoPoint(sinMiddleLat,sinMiddleLon,cosMiddleLat,cosMiddleLon);      
+        centerPoint = new GeoPoint(sinMiddleLat,sinMiddleLon,cosMiddleLat,cosMiddleLon);
+
+        this.topPlane = new SidedPlane(centerPoint,sinTopLat);
+        this.bottomPlane = new SidedPlane(centerPoint,sinBottomLat);
+        this.leftPlane = new SidedPlane(centerPoint,cosLeftLon,sinLeftLon);
+        this.rightPlane = new SidedPlane(centerPoint,cosRightLon,sinRightLon);
+
     }
 
     @Override
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoWideDegenerateHorizontalLine.java b/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoWideDegenerateHorizontalLine.java
new file mode 100644
index 0000000..301463f
--- /dev/null
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoWideDegenerateHorizontalLine.java
@@ -0,0 +1,209 @@
+package org.apache.lucene.spatial.spatial4j.geo3d;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/** Degenerate bounding box wider than PI and limited on two sides (left lon, right lon).
+*/
+public class GeoWideDegenerateHorizontalLine implements GeoBBox
+{
+    public final double latitude;
+    public final double leftLon;
+    public final double rightLon;
+      
+    public final GeoPoint LHC;
+    public final GeoPoint RHC;
+    
+    public final Plane plane;
+    public final SidedPlane leftPlane;
+    public final SidedPlane rightPlane;
+      
+    public final GeoPoint centerPoint;
+
+    public final EitherBound eitherBound;
+    
+    /** Accepts only values in the following ranges: lat: {@code -PI/2 -> PI/2}, lon: {@code -PI -> PI}.
+     * Horizontal angle must be greater than or equal to PI.
+     */
+    public GeoWideDegenerateHorizontalLine(double latitude, double leftLon, double rightLon)
+    {
+        // Argument checking
+        if (latitude > Math.PI * 0.5 || latitude < -Math.PI * 0.5)
+            throw new IllegalArgumentException("Latitude out of range");
+        if (leftLon < -Math.PI || leftLon > Math.PI)
+            throw new IllegalArgumentException("Left longitude out of range");
+        if (rightLon < -Math.PI || rightLon > Math.PI)
+            throw new IllegalArgumentException("Right longitude out of range");
+        double extent = rightLon - leftLon;
+        if (extent < 0.0) {
+            extent += 2.0 * Math.PI;
+        }
+        if (extent < Math.PI)
+            throw new IllegalArgumentException("Width of rectangle too small");
+
+        this.latitude = latitude;
+        this.leftLon = leftLon;
+        this.rightLon = rightLon;
+          
+        double sinLatitude = Math.sin(latitude);
+        double cosLatitude = Math.cos(latitude);
+        double sinLeftLon = Math.sin(leftLon);
+        double cosLeftLon = Math.cos(leftLon);
+        double sinRightLon = Math.sin(rightLon);
+        double cosRightLon = Math.cos(rightLon);
+        
+        // Now build the two points
+        this.LHC = new GeoPoint(sinLatitude,sinLeftLon,cosLatitude,cosLeftLon);
+        this.RHC = new GeoPoint(sinLatitude,sinRightLon,cosLatitude,cosRightLon);
+        
+        this.plane = new Plane(sinLatitude);
+          
+        double middleLon = (leftLon + rightLon) * 0.5;
+        double sinMiddleLon = Math.sin(middleLon);
+        double cosMiddleLon = Math.cos(middleLon);
+          
+        centerPoint = new GeoPoint(sinLatitude,sinMiddleLon,cosLatitude,cosMiddleLon);
+
+        this.leftPlane = new SidedPlane(centerPoint,cosLeftLon,sinLeftLon);
+        this.rightPlane = new SidedPlane(centerPoint,cosRightLon,sinRightLon);
+
+        this.eitherBound = new EitherBound();
+    }
+
+    @Override
+    public GeoBBox expand(double angle)
+    {
+        double newTopLat = latitude + angle;
+        double newBottomLat = latitude - angle;
+        // Figuring out when we escalate to a special case requires some prefiguring
+        double currentLonSpan = rightLon - leftLon;
+        if (currentLonSpan < 0.0)
+            currentLonSpan += Math.PI * 2.0;
+        double newLeftLon = leftLon - angle;
+        double newRightLon = rightLon + angle;
+        if (currentLonSpan + 2.0 * angle >= Math.PI * 2.0) {
+            newLeftLon = -Math.PI;
+            newRightLon = Math.PI;
+        }
+        return GeoBBoxFactory.makeGeoBBox(newTopLat,newBottomLat,newLeftLon,newRightLon);
+    }
+
+    @Override
+    public boolean isWithin(Vector point)
+    {
+        return plane.evaluate(point) == 0.0 &&
+          (leftPlane.isWithin(point) ||
+          rightPlane.isWithin(point));
+    }
+
+    @Override
+    public boolean isWithin(double x, double y, double z)
+    {
+        return plane.evaluate(x,y,z) == 0.0 &&
+          (leftPlane.isWithin(x,y,z) ||
+          rightPlane.isWithin(x,y,z));
+    }
+
+    @Override
+    public double getRadius()
+    {
+        // Here we compute the distance from the middle point to one of the corners.  However, we need to be careful
+        // to use the longest of three distances: the distance to a corner on the top; the distnace to a corner on the bottom, and
+        // the distance to the right or left edge from the center.
+        double topAngle = centerPoint.arcDistance(RHC);
+        double bottomAngle = centerPoint.arcDistance(LHC);
+        return Math.max(topAngle,bottomAngle);
+    }
+      
+    @Override
+    public GeoPoint getInteriorPoint()
+    {
+        return centerPoint;
+    }
+      
+    @Override
+    public boolean intersects(Plane p, Membership... bounds)
+    {
+        // Right and left bounds are essentially independent hemispheres; crossing into the wrong part of one
+        // requires crossing into the right part of the other.  So intersection can ignore the left/right bounds.
+        return p.intersects(plane,bounds,eitherBound);
+    }
+
+    /** Compute longitude/latitude bounds for the shape.
+    *@param bounds is the optional input bounds object.  If this is null,
+    * a bounds object will be created.  Otherwise, the input object will be modified.
+    *@return a Bounds object describing the shape's bounds.  If the bounds cannot
+    * be computed, then return a Bounds object with noLongitudeBound,
+    * noTopLatitudeBound, and noBottomLatitudeBound.
+    */
+    @Override
+    public Bounds getBounds(Bounds bounds)
+    {
+        if (bounds == null)
+            bounds = new Bounds();
+        bounds.addLatitudeZone(latitude)
+            .addLongitudeSlice(leftLon,rightLon);
+        return bounds;
+    }
+
+    @Override
+    public int getRelationship(GeoShape path) {
+
+        if (path.intersects(plane,eitherBound)) {
+            return OVERLAPS;
+        }
+
+        if (path.isWithin(centerPoint)) {
+            return CONTAINS;
+        }
+
+        return DISJOINT;
+    }
+
+    @Override
+    public boolean equals(Object o)
+    {
+        if (!(o instanceof GeoWideDegenerateHorizontalLine))
+            return false;
+        GeoWideDegenerateHorizontalLine other = (GeoWideDegenerateHorizontalLine)o;
+        return other.LHC.equals(LHC) && other.RHC.equals(RHC);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = LHC.hashCode();
+        result = 31 * result + RHC.hashCode();
+        return result;
+    }
+
+    protected class EitherBound implements Membership {
+        public EitherBound() {
+        }
+        
+        @Override
+        public boolean isWithin(Vector v) {
+            return leftPlane.isWithin(v) || rightPlane.isWithin(v);
+        }
+        
+        @Override
+        public boolean isWithin(double x, double y, double z) {
+            return leftPlane.isWithin(x,y,z) || rightPlane.isWithin(x,y,z);
+        }
+    }
+}
+  
+
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoWideRectangle.java b/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoWideRectangle.java
index 1c01dcd..42b87e0 100755
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoWideRectangle.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoWideRectangle.java
@@ -86,11 +86,6 @@ public class GeoWideRectangle implements GeoBBox
         this.LRHC = new GeoPoint(sinBottomLat,sinRightLon,cosBottomLat,cosRightLon);
         this.LLHC = new GeoPoint(sinBottomLat,sinLeftLon,cosBottomLat,cosLeftLon);
         
-        this.topPlane = new SidedPlane(LRHC,sinTopLat);
-        this.bottomPlane = new SidedPlane(ULHC,sinBottomLat);
-        this.leftPlane = new SidedPlane(LRHC,cosLeftLon,sinLeftLon);
-        this.rightPlane = new SidedPlane(LLHC,cosRightLon,sinRightLon);
-          
         double middleLat = (topLat + bottomLat) * 0.5;
         double sinMiddleLat = Math.sin(middleLat);
         cosMiddleLat = Math.cos(middleLat);
@@ -99,7 +94,12 @@ public class GeoWideRectangle implements GeoBBox
         double cosMiddleLon = Math.cos(middleLon);
           
         centerPoint = new GeoPoint(sinMiddleLat,sinMiddleLon,cosMiddleLat,cosMiddleLon);
-        
+
+        this.topPlane = new SidedPlane(centerPoint,sinTopLat);
+        this.bottomPlane = new SidedPlane(centerPoint,sinBottomLat);
+        this.leftPlane = new SidedPlane(centerPoint,cosLeftLon,sinLeftLon);
+        this.rightPlane = new SidedPlane(centerPoint,cosRightLon,sinRightLon);
+          
         this.eitherBound = new EitherBound();
     }
 
@@ -162,8 +162,8 @@ public class GeoWideRectangle implements GeoBBox
     {
         // Right and left bounds are essentially independent hemispheres; crossing into the wrong part of one
         // requires crossing into the right part of the other.  So intersection can ignore the left/right bounds.
-        return p.intersects(topPlane,bounds,bottomPlane,leftPlane,rightPlane) ||
-          p.intersects(bottomPlane,bounds,topPlane,leftPlane,rightPlane) ||
+        return p.intersects(topPlane,bounds,bottomPlane,eitherBound) ||
+          p.intersects(bottomPlane,bounds,topPlane,eitherBound) ||
           p.intersects(leftPlane,bounds,topPlane,bottomPlane) ||
           p.intersects(rightPlane,bounds,topPlane,bottomPlane);
     }
diff --git a/lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/Geo3dRptTest.java b/lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/Geo3dRptTest.java
index 450f40b..3ea16f1 100644
--- a/lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/Geo3dRptTest.java
+++ b/lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/Geo3dRptTest.java
@@ -34,6 +34,8 @@ import org.apache.lucene.spatial.prefix.RandomSpatialOpStrategyTestCase;
 import org.apache.lucene.spatial.prefix.RecursivePrefixTreeStrategy;
 import org.apache.lucene.spatial.prefix.tree.GeohashPrefixTree;
 import org.apache.lucene.spatial.prefix.tree.SpatialPrefixTree;
+import org.apache.lucene.spatial.prefix.tree.Cell;
+import org.apache.lucene.spatial.prefix.tree.CellIterator;
 import org.apache.lucene.spatial.query.SpatialOperation;
 import org.apache.lucene.spatial.serialized.SerializedDVStrategy;
 import org.apache.lucene.spatial.spatial4j.Geo3dShape;
@@ -88,11 +90,7 @@ public class Geo3dRptTest extends RandomSpatialOpStrategyTestCase {
   }
 
   @Test
-  public void testTriangleDisjointRect2() throws IOException {
-    final Rectangle rect = ctx.makeRectangle(-176, -176, -37, -34);
-    final Shape triangle = makeTriangle(116, 45, 169, 7, 92, -63);
-    //these shouldn't intersect
-    assertEquals(SpatialRelation.DISJOINT, triangle.relate(rect));
+  public void testTriangleDisjointRect() throws IOException {
   }
 
   private Shape makeTriangle(double x1, double y1, double x2, double y2, double x3, double y3) {
diff --git a/lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/geo3d/GeoBBoxTest.java b/lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/geo3d/GeoBBoxTest.java
index ddd39de..c1801f5 100755
--- a/lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/geo3d/GeoBBoxTest.java
+++ b/lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/geo3d/GeoBBoxTest.java
@@ -19,11 +19,33 @@ package org.apache.lucene.spatial.spatial4j.geo3d;
 
 import static org.junit.Assert.*;
 
+import java.util.List;
+import java.util.ArrayList;
+
 import org.junit.Test;
 
 public class GeoBBoxTest {
 
-
+    protected final double DEGREES_TO_RADIANS = Math.PI/180.0;
+    @Test
+    public void testBBoxDegenerate() {
+        GeoBBox box;
+        GeoConvexPolygon cp;
+        int relationship;
+        List<GeoPoint> points = new ArrayList<GeoPoint>();
+        points.add(new GeoPoint(24*DEGREES_TO_RADIANS,-30*DEGREES_TO_RADIANS));
+        points.add(new GeoPoint(-11*DEGREES_TO_RADIANS,101*DEGREES_TO_RADIANS));
+        points.add(new GeoPoint(-49*DEGREES_TO_RADIANS,-176*DEGREES_TO_RADIANS));
+        GeoMembershipShape shape = GeoPolygonFactory.makeGeoPolygon(points,0);
+        box = GeoBBoxFactory.makeGeoBBox(-64*DEGREES_TO_RADIANS,-64*DEGREES_TO_RADIANS,-180*DEGREES_TO_RADIANS,180*DEGREES_TO_RADIANS);
+        relationship = box.getRelationship(shape);
+        assertEquals(GeoArea.CONTAINS,relationship);
+        box = GeoBBoxFactory.makeGeoBBox(-61.85*DEGREES_TO_RADIANS,-67.5*DEGREES_TO_RADIANS,-180*DEGREES_TO_RADIANS,-168.75*DEGREES_TO_RADIANS);
+        System.out.println("Shape = "+shape+" Rect = "+box);
+        relationship = box.getRelationship(shape);
+        assertEquals(GeoArea.CONTAINS,relationship);
+    }
+    
     @Test
     public void testBBoxPointWithin() {
         GeoBBox box;

