GitDiffStart: a944ab17a712f58e8417639763a0c7267fa11e61 | Mon Sep 14 22:03:35 2015 +0000
diff --git a/lucene/CHANGES.txt b/lucene/CHANGES.txt
index a7f656d..443046b 100644
--- a/lucene/CHANGES.txt
+++ b/lucene/CHANGES.txt
@@ -59,6 +59,11 @@ API Changes
 * LUCENE-6706: PayloadTermQuery and PayloadNearQuery have been removed.
   Instead, use PayloadScoreQuery to wrap any SpanQuery. (Alan Woodward)
 
+Changes in Runtime Behavior
+
+* LUCENE-6789: IndexSearcher's default Similarity is changed to BM25Similarity.
+  Use ClassicSimilarity to get the old vector space DefaultSimilarity. (Robert Muir)
+
 ======================= Lucene 5.4.0 =======================
 
 New Features
diff --git a/lucene/benchmark/src/test/org/apache/lucene/benchmark/quality/TestQualityRun.java b/lucene/benchmark/src/test/org/apache/lucene/benchmark/quality/TestQualityRun.java
index 487478b..b3eb8e9 100644
--- a/lucene/benchmark/src/test/org/apache/lucene/benchmark/quality/TestQualityRun.java
+++ b/lucene/benchmark/src/test/org/apache/lucene/benchmark/quality/TestQualityRun.java
@@ -25,6 +25,7 @@ import org.apache.lucene.benchmark.quality.utils.SubmissionReport;
 import org.apache.lucene.index.DirectoryReader;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.store.Directory;
 
 import java.io.BufferedReader;
@@ -74,6 +75,8 @@ public class TestQualityRun extends BenchmarkTestCase {
     Directory dir = newFSDirectory(getWorkDir().resolve("index"));
     IndexReader reader = DirectoryReader.open(dir);
     IndexSearcher searcher = new IndexSearcher(reader);
+    // TODO: adapt this test data to bm25
+    searcher.setSimilarity(new ClassicSimilarity());
 
     QualityQueryParser qqParser = new SimpleQQParser("title","body");
     QualityBenchmark qrun = new QualityBenchmark(qqs, qqParser, searcher, docNameField);
diff --git a/lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier.java b/lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier.java
index 2edc5af..d088787 100644
--- a/lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier.java
+++ b/lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier.java
@@ -36,7 +36,7 @@ import org.apache.lucene.search.Query;
 import org.apache.lucene.search.ScoreDoc;
 import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.search.WildcardQuery;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.util.BytesRef;
 
@@ -61,7 +61,7 @@ public class KNearestNeighborClassifier implements Classifier<BytesRef> {
    * @param leafReader     the reader on the index to be used for classification
    * @param analyzer       an {@link Analyzer} used to analyze unseen text
    * @param similarity     the {@link Similarity} to be used by the underlying {@link IndexSearcher} or {@code null}
-   *                       (defaults to {@link org.apache.lucene.search.similarities.DefaultSimilarity})
+   *                       (defaults to {@link org.apache.lucene.search.similarities.ClassicSimilarity})
    * @param query          a {@link Query} to eventually filter the docs used for training the classifier, or {@code null}
    *                       if all the indexed docs should be used
    * @param k              the no. of docs to select in the MLT results to find the nearest neighbor
@@ -81,7 +81,7 @@ public class KNearestNeighborClassifier implements Classifier<BytesRef> {
     if (similarity != null) {
       this.indexSearcher.setSimilarity(similarity);
     } else {
-      this.indexSearcher.setSimilarity(new DefaultSimilarity());
+      this.indexSearcher.setSimilarity(new ClassicSimilarity());
     }
     if (minDocsFreq > 0) {
       mlt.setMinDocFreq(minDocsFreq);
diff --git a/lucene/core/src/java/org/apache/lucene/index/IndexableField.java b/lucene/core/src/java/org/apache/lucene/index/IndexableField.java
index f13ac3c..4d6735e 100644
--- a/lucene/core/src/java/org/apache/lucene/index/IndexableField.java
+++ b/lucene/core/src/java/org/apache/lucene/index/IndexableField.java
@@ -21,7 +21,7 @@ import java.io.IOException;
 
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.search.similarities.DefaultSimilarity; // javadocs
+import org.apache.lucene.search.similarities.ClassicSimilarity; // javadocs
 import org.apache.lucene.search.similarities.Similarity; // javadocs
 
 // TODO: how to handle versioning here...?
@@ -59,7 +59,7 @@ public interface IndexableField extends GeneralField {
    * <p>The boost is used to compute the norm factor for the field.  By
    * default, in the {@link Similarity#computeNorm(FieldInvertState)} method, 
    * the boost value is multiplied by the length normalization factor and then
-   * rounded by {@link DefaultSimilarity#encodeNormValue(float)} before it is stored in the
+   * rounded by {@link ClassicSimilarity#encodeNormValue(float)} before it is stored in the
    * index.  One should attempt to ensure that this product does not overflow
    * the range of that encoding.
    * <p>
@@ -68,7 +68,7 @@ public interface IndexableField extends GeneralField {
    * omits normalization values ({@link IndexableFieldType#omitNorms()} returns true).
    *
    * @see Similarity#computeNorm(FieldInvertState)
-   * @see DefaultSimilarity#encodeNormValue(float)
+   * @see ClassicSimilarity#encodeNormValue(float)
    */
   public float boost();
 }
diff --git a/lucene/core/src/java/org/apache/lucene/search/DisjunctionScorer.java b/lucene/core/src/java/org/apache/lucene/search/DisjunctionScorer.java
index 7dbb733..c32a520 100644
--- a/lucene/core/src/java/org/apache/lucene/search/DisjunctionScorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/DisjunctionScorer.java
@@ -28,7 +28,7 @@ import java.util.List;
 abstract class DisjunctionScorer extends Scorer {
 
   private final boolean needsScores;
-  private final DisiPriorityQueue<Scorer> subScorers;
+  final DisiPriorityQueue<Scorer> subScorers;
   private final long cost;
 
   /** Linked list of scorers which are on the current doc */
diff --git a/lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java b/lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java
index b9589df..7c84f9f 100644
--- a/lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java
+++ b/lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java
@@ -43,7 +43,7 @@ import org.apache.lucene.index.StoredFieldVisitor;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
 import org.apache.lucene.index.Terms;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.BM25Similarity;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.store.NIOFSDirectory;    // javadoc
 import org.apache.lucene.util.Bits;
@@ -147,7 +147,7 @@ public class IndexSearcher {
   private final ExecutorService executor;
 
   // the default Similarity
-  private static final Similarity defaultSimilarity = new DefaultSimilarity();
+  private static final Similarity defaultSimilarity = new BM25Similarity();
 
   private QueryCache queryCache = DEFAULT_QUERY_CACHE;
   private QueryCachingPolicy queryCachingPolicy = DEFAULT_CACHING_POLICY;
@@ -335,7 +335,7 @@ public class IndexSearcher {
    *  When {@code needsScores} is {@code true}, this returns the
    *  {@link Similarity} that has been set through {@link #setSimilarity(Similarity)}
    *  or the {@link #getDefaultSimilarity()} default {@link Similarity} if none
-   *  has been set explicitely. */
+   *  has been set explicitly. */
   public Similarity getSimilarity(boolean needsScores) {
     return needsScores ? similarity : NON_SCORING_SIMILARITY;
   }
diff --git a/lucene/core/src/java/org/apache/lucene/search/SynonymQuery.java b/lucene/core/src/java/org/apache/lucene/search/SynonymQuery.java
new file mode 100644
index 0000000..9e2187c
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/SynonymQuery.java
@@ -0,0 +1,245 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Objects;
+import java.util.Set;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.PostingsEnum;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
+import org.apache.lucene.index.TermState;
+import org.apache.lucene.index.TermsEnum;
+import org.apache.lucene.search.similarities.Similarity;
+import org.apache.lucene.search.similarities.Similarity.SimScorer;
+
+/**
+ * A query that treats multiple terms as synonyms.
+ * <p>
+ * For scoring purposes, this query tries to score the terms as if you
+ * had indexed them as one term: it will match any of the terms but
+ * only invoke the similarity a single time, scoring the sum of all
+ * term frequencies for the document.
+ */
+public final class SynonymQuery extends Query {
+  private final Term terms[];
+  
+  /**
+   * Creates a new SynonymQuery, matching any of the supplied terms.
+   * <p>
+   * The terms must all have the same field.
+   */
+  public SynonymQuery(Term... terms) {
+    this.terms = Objects.requireNonNull(terms).clone();
+    // check that all terms are the same field
+    String field = null;
+    for (Term term : terms) {
+      if (field == null) {
+        field = term.field();
+      } else if (!term.field().equals(field)) {
+        throw new IllegalArgumentException("Synonyms must be across the same field");
+      }
+    }
+    if (terms.length > BooleanQuery.getMaxClauseCount()) {
+      throw new BooleanQuery.TooManyClauses();
+    }
+    Arrays.sort(this.terms);
+  }
+
+  @Override
+  public String toString(String field) {
+    StringBuilder builder = new StringBuilder("Synonym(");
+    for (int i = 0; i < terms.length; i++) {
+      if (i != 0) {
+        builder.append(" ");
+      }
+      Query termQuery = new TermQuery(terms[i]);
+      builder.append(termQuery.toString(field));
+    }
+    builder.append(")");
+    return builder.toString();
+  }
+
+  @Override
+  public int hashCode() {
+    final int prime = 31;
+    int result = super.hashCode();
+    result = prime * result + Arrays.hashCode(terms);
+    return result;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) return true;
+    if (!super.equals(obj)) return false;
+    if (getClass() != obj.getClass()) return false;
+    SynonymQuery other = (SynonymQuery) obj;
+    if (!Arrays.equals(terms, other.terms)) return false;
+    return true;
+  }
+
+  @Override
+  public Query rewrite(IndexReader reader) throws IOException {
+    // optimize zero and single term cases
+    if (terms.length == 0) {
+      return new BooleanQuery.Builder().build();
+    }
+    if (terms.length == 1) {
+      return new TermQuery(terms[0]);
+    }
+    return this;
+  }
+
+  @Override
+  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    if (needsScores) {
+      return new SynonymWeight(this, searcher);
+    } else {
+      // if scores are not needed, let BooleanWeight deal with optimizing that case.
+      BooleanQuery.Builder bq = new BooleanQuery.Builder();
+      for (Term term : terms) {
+        bq.add(new TermQuery(term), BooleanClause.Occur.SHOULD);
+      }
+      return searcher.rewrite(bq.build()).createWeight(searcher, needsScores);
+    }
+  }
+  
+  class SynonymWeight extends Weight {
+    private final TermContext termContexts[];
+    private final Similarity similarity;
+    private final Similarity.SimWeight simWeight;
+
+    SynonymWeight(Query query, IndexSearcher searcher) throws IOException {
+      super(query);
+      CollectionStatistics collectionStats = searcher.collectionStatistics(terms[0].field());
+      long docFreq = 0;
+      long totalTermFreq = 0;
+      termContexts = new TermContext[terms.length];
+      for (int i = 0; i < termContexts.length; i++) {
+        termContexts[i] = TermContext.build(searcher.getTopReaderContext(), terms[i]);
+        TermStatistics termStats = searcher.termStatistics(terms[i], termContexts[i]);
+        docFreq = Math.max(termStats.docFreq(), docFreq);
+        if (termStats.totalTermFreq() == -1) {
+          totalTermFreq = -1;
+        } else if (totalTermFreq != -1) {
+          totalTermFreq += termStats.totalTermFreq();
+        }
+      }
+      TermStatistics pseudoStats = new TermStatistics(null, docFreq, totalTermFreq);
+      this.similarity = searcher.getSimilarity(true);
+      this.simWeight = similarity.computeWeight(collectionStats, pseudoStats);
+    }
+
+    @Override
+    public void extractTerms(Set<Term> terms) {
+      for (Term term : SynonymQuery.this.terms) {
+        terms.add(term);
+      }
+    }
+
+    @Override
+    public Explanation explain(LeafReaderContext context, int doc) throws IOException {
+      Scorer scorer = scorer(context);
+      if (scorer != null) {
+        int newDoc = scorer.advance(doc);
+        if (newDoc == doc) {
+          final float freq;
+          if (scorer instanceof SynonymScorer) {
+            SynonymScorer synScorer = (SynonymScorer) scorer;
+            freq = synScorer.tf(synScorer.subScorers.topList());
+          } else {
+            assert scorer instanceof TermScorer;
+            freq = scorer.freq();
+          }
+          SimScorer docScorer = similarity.simScorer(simWeight, context);
+          Explanation freqExplanation = Explanation.match(freq, "termFreq=" + freq);
+          Explanation scoreExplanation = docScorer.explain(doc, freqExplanation);
+          return Explanation.match(
+              scoreExplanation.getValue(),
+              "weight(" + getQuery() + " in " + doc + ") ["
+                  + similarity.getClass().getSimpleName() + "], result of:",
+              scoreExplanation);
+        }
+      }
+      return Explanation.noMatch("no matching term");
+    }
+
+    @Override
+    public float getValueForNormalization() throws IOException {
+      return simWeight.getValueForNormalization();
+    }
+
+    @Override
+    public void normalize(float norm, float boost) {
+      simWeight.normalize(norm, boost);
+    }
+
+    @Override
+    public Scorer scorer(LeafReaderContext context) throws IOException {
+      Similarity.SimScorer simScorer = similarity.simScorer(simWeight, context);
+      // we use termscorers + disjunction as an impl detail
+      List<Scorer> subScorers = new ArrayList<>();
+      for (int i = 0; i < terms.length; i++) {
+        TermState state = termContexts[i].get(context.ord);
+        if (state != null) {
+          TermsEnum termsEnum = context.reader().terms(terms[i].field()).iterator();
+          termsEnum.seekExact(terms[i].bytes(), state);
+          PostingsEnum postings = termsEnum.postings(null, PostingsEnum.FREQS);
+          subScorers.add(new TermScorer(this, postings, simScorer));
+        }
+      }
+      if (subScorers.isEmpty()) {
+        return null;
+      } else if (subScorers.size() == 1) {
+        // we must optimize this case (term not in segment), disjunctionscorer requires >= 2 subs
+        return subScorers.get(0);
+      } else {
+        return new SynonymScorer(simScorer, this, subScorers);
+      }
+    }
+  }
+  
+  static class SynonymScorer extends DisjunctionScorer {
+    private final Similarity.SimScorer similarity;
+    
+    SynonymScorer(Similarity.SimScorer similarity, Weight weight, List<Scorer> subScorers) {
+      super(weight, subScorers, true);
+      this.similarity = similarity;
+    }
+
+    @Override
+    protected float score(DisiWrapper<Scorer> topList) throws IOException {
+      return similarity.score(topList.doc, tf(topList));
+    }
+    
+    /** combines TF of all subs. */
+    final int tf(DisiWrapper<Scorer> topList) throws IOException {
+      int tf = 0;
+      for (DisiWrapper<Scorer> w = topList; w != null; w = w.next) {
+        tf += w.iterator.freq();
+      }
+      return tf;
+    }
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadScoreQuery.java b/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadScoreQuery.java
index b743c31..7f54b8c 100644
--- a/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadScoreQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadScoreQuery.java
@@ -28,7 +28,7 @@ import org.apache.lucene.index.TermContext;
 import org.apache.lucene.search.Explanation;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Scorer;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.search.spans.SpanCollector;
 import org.apache.lucene.search.spans.SpanQuery;
@@ -42,7 +42,7 @@ import org.apache.lucene.util.BytesRef;
  * wrapped SpanQuery
  *
  * NOTE: In order to take advantage of this with the default scoring implementation
- * ({@link DefaultSimilarity}), you must override {@link DefaultSimilarity#scorePayload(int, int, int, BytesRef)},
+ * ({@link ClassicSimilarity}), you must override {@link ClassicSimilarity#scorePayload(int, int, int, BytesRef)},
  * which returns 1 by default.
  *
  * @see org.apache.lucene.search.similarities.Similarity.SimScorer#computePayloadFactor(int, int, int, BytesRef)
diff --git a/lucene/core/src/java/org/apache/lucene/search/similarities/BM25Similarity.java b/lucene/core/src/java/org/apache/lucene/search/similarities/BM25Similarity.java
index 058aceb..222c5a8 100644
--- a/lucene/core/src/java/org/apache/lucene/search/similarities/BM25Similarity.java
+++ b/lucene/core/src/java/org/apache/lucene/search/similarities/BM25Similarity.java
@@ -35,12 +35,10 @@ import org.apache.lucene.util.SmallFloat;
  * Susan Jones, Micheline Hancock-Beaulieu, and Mike Gatford. Okapi at TREC-3.
  * In Proceedings of the Third <b>T</b>ext <b>RE</b>trieval <b>C</b>onference (TREC 1994).
  * Gaithersburg, USA, November 1994.
- * @lucene.experimental
  */
 public class BM25Similarity extends Similarity {
   private final float k1;
   private final float b;
-  // TODO: should we add a delta like sifaka.cs.uiuc.edu/~ylv2/pub/sigir11-bm25l.pdf ?
 
   /**
    * BM25 with the supplied parameter values.
@@ -54,8 +52,8 @@ public class BM25Similarity extends Similarity {
   
   /** BM25 with these default values:
    * <ul>
-   *   <li>{@code k1 = 1.2},
-   *   <li>{@code b = 0.75}.</li>
+   *   <li>{@code k1 = 1.2}</li>
+   *   <li>{@code b = 0.75}</li>
    * </ul>
    */
   public BM25Similarity() {
@@ -333,7 +331,7 @@ public class BM25Similarity extends Similarity {
    * Returns the <code>k1</code> parameter
    * @see #BM25Similarity(float, float) 
    */
-  public float getK1() {
+  public final float getK1() {
     return k1;
   }
   
@@ -341,7 +339,7 @@ public class BM25Similarity extends Similarity {
    * Returns the <code>b</code> parameter 
    * @see #BM25Similarity(float, float) 
    */
-  public float getB() {
+  public final float getB() {
     return b;
   }
 }
diff --git a/lucene/core/src/java/org/apache/lucene/search/similarities/ClassicSimilarity.java b/lucene/core/src/java/org/apache/lucene/search/similarities/ClassicSimilarity.java
new file mode 100644
index 0000000..93ebf81
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/similarities/ClassicSimilarity.java
@@ -0,0 +1,173 @@
+package org.apache.lucene.search.similarities;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.index.FieldInvertState;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.SmallFloat;
+
+/**
+ * Expert: Default scoring implementation which {@link #encodeNormValue(float)
+ * encodes} norm values as a single byte before being stored. At search time,
+ * the norm byte value is read from the index
+ * {@link org.apache.lucene.store.Directory directory} and
+ * {@link #decodeNormValue(long) decoded} back to a float <i>norm</i> value.
+ * This encoding/decoding, while reducing index size, comes with the price of
+ * precision loss - it is not guaranteed that <i>decode(encode(x)) = x</i>. For
+ * instance, <i>decode(encode(0.89)) = 0.875</i>.
+ * <p>
+ * Compression of norm values to a single byte saves memory at search time,
+ * because once a field is referenced at search time, its norms - for all
+ * documents - are maintained in memory.
+ * <p>
+ * The rationale supporting such lossy compression of norm values is that given
+ * the difficulty (and inaccuracy) of users to express their true information
+ * need by a query, only big differences matter. <br>
+ * &nbsp;<br>
+ * Last, note that search time is too late to modify this <i>norm</i> part of
+ * scoring, e.g. by using a different {@link Similarity} for search.
+ */
+public class ClassicSimilarity extends TFIDFSimilarity {
+  
+  /** Cache of decoded bytes. */
+  private static final float[] NORM_TABLE = new float[256];
+
+  static {
+    for (int i = 0; i < 256; i++) {
+      NORM_TABLE[i] = SmallFloat.byte315ToFloat((byte)i);
+    }
+  }
+
+  /** Sole constructor: parameter-free */
+  public ClassicSimilarity() {}
+  
+  /** Implemented as <code>overlap / maxOverlap</code>. */
+  @Override
+  public float coord(int overlap, int maxOverlap) {
+    return overlap / (float)maxOverlap;
+  }
+
+  /** Implemented as <code>1/sqrt(sumOfSquaredWeights)</code>. */
+  @Override
+  public float queryNorm(float sumOfSquaredWeights) {
+    return (float)(1.0 / Math.sqrt(sumOfSquaredWeights));
+  }
+  
+  /**
+   * Encodes a normalization factor for storage in an index.
+   * <p>
+   * The encoding uses a three-bit mantissa, a five-bit exponent, and the
+   * zero-exponent point at 15, thus representing values from around 7x10^9 to
+   * 2x10^-9 with about one significant decimal digit of accuracy. Zero is also
+   * represented. Negative numbers are rounded up to zero. Values too large to
+   * represent are rounded down to the largest representable value. Positive
+   * values too small to represent are rounded up to the smallest positive
+   * representable value.
+   * 
+   * @see org.apache.lucene.document.Field#setBoost(float)
+   * @see org.apache.lucene.util.SmallFloat
+   */
+  @Override
+  public final long encodeNormValue(float f) {
+    return SmallFloat.floatToByte315(f);
+  }
+
+  /**
+   * Decodes the norm value, assuming it is a single byte.
+   * 
+   * @see #encodeNormValue(float)
+   */
+  @Override
+  public final float decodeNormValue(long norm) {
+    return NORM_TABLE[(int) (norm & 0xFF)];  // & 0xFF maps negative bytes to positive above 127
+  }
+
+  /** Implemented as
+   *  <code>state.getBoost()*lengthNorm(numTerms)</code>, where
+   *  <code>numTerms</code> is {@link FieldInvertState#getLength()} if {@link
+   *  #setDiscountOverlaps} is false, else it's {@link
+   *  FieldInvertState#getLength()} - {@link
+   *  FieldInvertState#getNumOverlap()}.
+   *
+   *  @lucene.experimental */
+  @Override
+  public float lengthNorm(FieldInvertState state) {
+    final int numTerms;
+    if (discountOverlaps)
+      numTerms = state.getLength() - state.getNumOverlap();
+    else
+      numTerms = state.getLength();
+    return state.getBoost() * ((float) (1.0 / Math.sqrt(numTerms)));
+  }
+
+  /** Implemented as <code>sqrt(freq)</code>. */
+  @Override
+  public float tf(float freq) {
+    return (float)Math.sqrt(freq);
+  }
+    
+  /** Implemented as <code>1 / (distance + 1)</code>. */
+  @Override
+  public float sloppyFreq(int distance) {
+    return 1.0f / (distance + 1);
+  }
+  
+  /** The default implementation returns <code>1</code> */
+  @Override
+  public float scorePayload(int doc, int start, int end, BytesRef payload) {
+    return 1;
+  }
+
+  /** Implemented as <code>log((docCount+1)/(docFreq+1)) + 1</code>. */
+  @Override
+  public float idf(long docFreq, long docCount) {
+    return (float)(Math.log((docCount+1)/(double)(docFreq+1)) + 1.0);
+  }
+    
+  /** 
+   * True if overlap tokens (tokens with a position of increment of zero) are
+   * discounted from the document's length.
+   */
+  protected boolean discountOverlaps = true;
+
+  /** Determines whether overlap tokens (Tokens with
+   *  0 position increment) are ignored when computing
+   *  norm.  By default this is true, meaning overlap
+   *  tokens do not count when computing norms.
+   *
+   *  @lucene.experimental
+   *
+   *  @see #computeNorm
+   */
+  public void setDiscountOverlaps(boolean v) {
+    discountOverlaps = v;
+  }
+
+  /**
+   * Returns true if overlap tokens are discounted from the document's length. 
+   * @see #setDiscountOverlaps 
+   */
+  public boolean getDiscountOverlaps() {
+    return discountOverlaps;
+  }
+
+  @Override
+  public String toString() {
+    return "ClassicSimilarity";
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/similarities/DefaultSimilarity.java b/lucene/core/src/java/org/apache/lucene/search/similarities/DefaultSimilarity.java
deleted file mode 100644
index 7a95db3..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/similarities/DefaultSimilarity.java
+++ /dev/null
@@ -1,173 +0,0 @@
-package org.apache.lucene.search.similarities;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.index.FieldInvertState;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.SmallFloat;
-
-/**
- * Expert: Default scoring implementation which {@link #encodeNormValue(float)
- * encodes} norm values as a single byte before being stored. At search time,
- * the norm byte value is read from the index
- * {@link org.apache.lucene.store.Directory directory} and
- * {@link #decodeNormValue(long) decoded} back to a float <i>norm</i> value.
- * This encoding/decoding, while reducing index size, comes with the price of
- * precision loss - it is not guaranteed that <i>decode(encode(x)) = x</i>. For
- * instance, <i>decode(encode(0.89)) = 0.875</i>.
- * <p>
- * Compression of norm values to a single byte saves memory at search time,
- * because once a field is referenced at search time, its norms - for all
- * documents - are maintained in memory.
- * <p>
- * The rationale supporting such lossy compression of norm values is that given
- * the difficulty (and inaccuracy) of users to express their true information
- * need by a query, only big differences matter. <br>
- * &nbsp;<br>
- * Last, note that search time is too late to modify this <i>norm</i> part of
- * scoring, e.g. by using a different {@link Similarity} for search.
- */
-public class DefaultSimilarity extends TFIDFSimilarity {
-  
-  /** Cache of decoded bytes. */
-  private static final float[] NORM_TABLE = new float[256];
-
-  static {
-    for (int i = 0; i < 256; i++) {
-      NORM_TABLE[i] = SmallFloat.byte315ToFloat((byte)i);
-    }
-  }
-
-  /** Sole constructor: parameter-free */
-  public DefaultSimilarity() {}
-  
-  /** Implemented as <code>overlap / maxOverlap</code>. */
-  @Override
-  public float coord(int overlap, int maxOverlap) {
-    return overlap / (float)maxOverlap;
-  }
-
-  /** Implemented as <code>1/sqrt(sumOfSquaredWeights)</code>. */
-  @Override
-  public float queryNorm(float sumOfSquaredWeights) {
-    return (float)(1.0 / Math.sqrt(sumOfSquaredWeights));
-  }
-  
-  /**
-   * Encodes a normalization factor for storage in an index.
-   * <p>
-   * The encoding uses a three-bit mantissa, a five-bit exponent, and the
-   * zero-exponent point at 15, thus representing values from around 7x10^9 to
-   * 2x10^-9 with about one significant decimal digit of accuracy. Zero is also
-   * represented. Negative numbers are rounded up to zero. Values too large to
-   * represent are rounded down to the largest representable value. Positive
-   * values too small to represent are rounded up to the smallest positive
-   * representable value.
-   * 
-   * @see org.apache.lucene.document.Field#setBoost(float)
-   * @see org.apache.lucene.util.SmallFloat
-   */
-  @Override
-  public final long encodeNormValue(float f) {
-    return SmallFloat.floatToByte315(f);
-  }
-
-  /**
-   * Decodes the norm value, assuming it is a single byte.
-   * 
-   * @see #encodeNormValue(float)
-   */
-  @Override
-  public final float decodeNormValue(long norm) {
-    return NORM_TABLE[(int) (norm & 0xFF)];  // & 0xFF maps negative bytes to positive above 127
-  }
-
-  /** Implemented as
-   *  <code>state.getBoost()*lengthNorm(numTerms)</code>, where
-   *  <code>numTerms</code> is {@link FieldInvertState#getLength()} if {@link
-   *  #setDiscountOverlaps} is false, else it's {@link
-   *  FieldInvertState#getLength()} - {@link
-   *  FieldInvertState#getNumOverlap()}.
-   *
-   *  @lucene.experimental */
-  @Override
-  public float lengthNorm(FieldInvertState state) {
-    final int numTerms;
-    if (discountOverlaps)
-      numTerms = state.getLength() - state.getNumOverlap();
-    else
-      numTerms = state.getLength();
-    return state.getBoost() * ((float) (1.0 / Math.sqrt(numTerms)));
-  }
-
-  /** Implemented as <code>sqrt(freq)</code>. */
-  @Override
-  public float tf(float freq) {
-    return (float)Math.sqrt(freq);
-  }
-    
-  /** Implemented as <code>1 / (distance + 1)</code>. */
-  @Override
-  public float sloppyFreq(int distance) {
-    return 1.0f / (distance + 1);
-  }
-  
-  /** The default implementation returns <code>1</code> */
-  @Override
-  public float scorePayload(int doc, int start, int end, BytesRef payload) {
-    return 1;
-  }
-
-  /** Implemented as <code>log((docCount+1)/(docFreq+1)) + 1</code>. */
-  @Override
-  public float idf(long docFreq, long docCount) {
-    return (float)(Math.log((docCount+1)/(double)(docFreq+1)) + 1.0);
-  }
-    
-  /** 
-   * True if overlap tokens (tokens with a position of increment of zero) are
-   * discounted from the document's length.
-   */
-  protected boolean discountOverlaps = true;
-
-  /** Determines whether overlap tokens (Tokens with
-   *  0 position increment) are ignored when computing
-   *  norm.  By default this is true, meaning overlap
-   *  tokens do not count when computing norms.
-   *
-   *  @lucene.experimental
-   *
-   *  @see #computeNorm
-   */
-  public void setDiscountOverlaps(boolean v) {
-    discountOverlaps = v;
-  }
-
-  /**
-   * Returns true if overlap tokens are discounted from the document's length. 
-   * @see #setDiscountOverlaps 
-   */
-  public boolean getDiscountOverlaps() {
-    return discountOverlaps;
-  }
-
-  @Override
-  public String toString() {
-    return "DefaultSimilarity";
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/search/similarities/Similarity.java b/lucene/core/src/java/org/apache/lucene/search/similarities/Similarity.java
index 33764f9..9deaf47 100644
--- a/lucene/core/src/java/org/apache/lucene/search/similarities/Similarity.java
+++ b/lucene/core/src/java/org/apache/lucene/search/similarities/Similarity.java
@@ -42,7 +42,7 @@ import java.util.Collections;
  * an information retrieval <i>model</i>.  If you are instead looking for a convenient way 
  * to alter Lucene's scoring, consider extending a higher-level implementation
  * such as {@link TFIDFSimilarity}, which implements the vector space model with this API, or 
- * just tweaking the default implementation: {@link DefaultSimilarity}.
+ * just tweaking the default implementation: {@link BM25Similarity}.
  * <p>
  * Similarity determines how Lucene weights terms, and Lucene interacts with
  * this class at both <a href="#indextime">index-time</a> and 
@@ -56,7 +56,7 @@ import java.util.Collections;
  * information.
  * <p>
  * Implementations should carefully consider how the normalization is encoded: while
- * Lucene's classical {@link TFIDFSimilarity} encodes a combination of index-time boost
+ * Lucene's {@link BM25Similarity} encodes a combination of index-time boost
  * and length normalization information with {@link SmallFloat} into a single byte, this 
  * might not be suitable for all purposes.
  * <p>
diff --git a/lucene/core/src/java/org/apache/lucene/search/similarities/TFIDFSimilarity.java b/lucene/core/src/java/org/apache/lucene/search/similarities/TFIDFSimilarity.java
index 40e341f..8ec82d5 100644
--- a/lucene/core/src/java/org/apache/lucene/search/similarities/TFIDFSimilarity.java
+++ b/lucene/core/src/java/org/apache/lucene/search/similarities/TFIDFSimilarity.java
@@ -308,13 +308,13 @@ import org.apache.lucene.util.BytesRef;
  *      two term-queries with that same term and hence the computation would still be correct (although
  *      not very efficient).
  *      The default computation for <i>tf(t in d)</i> in
- *      {@link org.apache.lucene.search.similarities.DefaultSimilarity#tf(float) DefaultSimilarity} is:
+ *      {@link org.apache.lucene.search.similarities.ClassicSimilarity#tf(float) ClassicSimilarity} is:
  *
  *      <br>&nbsp;<br>
  *      <table cellpadding="2" cellspacing="2" border="0" style="width:auto; margin-left:auto; margin-right:auto" summary="term frequency computation">
  *        <tr>
  *          <td valign="middle" align="right" rowspan="1">
- *            {@link org.apache.lucene.search.similarities.DefaultSimilarity#tf(float) tf(t in d)} &nbsp; = &nbsp;
+ *            {@link org.apache.lucene.search.similarities.ClassicSimilarity#tf(float) tf(t in d)} &nbsp; = &nbsp;
  *          </td>
  *          <td valign="top" align="center" rowspan="1">
  *               frequency<sup><big>&frac12;</big></sup>
@@ -333,13 +333,13 @@ import org.apache.lucene.util.BytesRef;
  *      <i>idf(t)</i> appears for <i>t</i> in both the query and the document,
  *      hence it is squared in the equation.
  *      The default computation for <i>idf(t)</i> in
- *      {@link org.apache.lucene.search.similarities.DefaultSimilarity#idf(long, long) DefaultSimilarity} is:
+ *      {@link org.apache.lucene.search.similarities.ClassicSimilarity#idf(long, long) ClassicSimilarity} is:
  *
  *      <br>&nbsp;<br>
  *      <table cellpadding="2" cellspacing="2" border="0" style="width:auto; margin-left:auto; margin-right:auto" summary="inverse document frequency computation">
  *        <tr>
  *          <td valign="middle" align="right">
- *            {@link org.apache.lucene.search.similarities.DefaultSimilarity#idf(long, long) idf(t)}&nbsp; = &nbsp;
+ *            {@link org.apache.lucene.search.similarities.ClassicSimilarity#idf(long, long) idf(t)}&nbsp; = &nbsp;
  *          </td>
  *          <td valign="middle" align="center">
  *            1 + log <big>(</big>
@@ -381,14 +381,14 @@ import org.apache.lucene.util.BytesRef;
  *      This is a search time factor computed by the Similarity in effect at search time.
  *
  *      The default computation in
- *      {@link org.apache.lucene.search.similarities.DefaultSimilarity#queryNorm(float) DefaultSimilarity}
+ *      {@link org.apache.lucene.search.similarities.ClassicSimilarity#queryNorm(float) ClassicSimilarity}
  *      produces a <a href="http://en.wikipedia.org/wiki/Euclidean_norm#Euclidean_norm">Euclidean norm</a>:
  *      <br>&nbsp;<br>
  *      <table cellpadding="1" cellspacing="0" border="0" style="width:auto; margin-left:auto; margin-right:auto" summary="query normalization computation">
  *        <tr>
  *          <td valign="middle" align="right" rowspan="1">
  *            queryNorm(q)  &nbsp; = &nbsp;
- *            {@link org.apache.lucene.search.similarities.DefaultSimilarity#queryNorm(float) queryNorm(sumOfSquaredWeights)}
+ *            {@link org.apache.lucene.search.similarities.ClassicSimilarity#queryNorm(float) queryNorm(sumOfSquaredWeights)}
  *            &nbsp; = &nbsp;
  *          </td>
  *          <td valign="middle" align="center" rowspan="1">
diff --git a/lucene/core/src/java/org/apache/lucene/search/similarities/package-info.java b/lucene/core/src/java/org/apache/lucene/search/similarities/package-info.java
index 086c82a..d6dcdb7 100644
--- a/lucene/core/src/java/org/apache/lucene/search/similarities/package-info.java
+++ b/lucene/core/src/java/org/apache/lucene/search/similarities/package-info.java
@@ -32,7 +32,7 @@
  * <a name="sims"></a>
  * <h2>Summary of the Ranking Methods</h2>
  * 
- * <p>{@link org.apache.lucene.search.similarities.DefaultSimilarity} is the original Lucene
+ * <p>{@link org.apache.lucene.search.similarities.ClassicSimilarity} is the original Lucene
  * scoring function. It is based on a highly optimized 
  * <a href="http://en.wikipedia.org/wiki/Vector_Space_Model">Vector Space Model</a>. For more
  * information, see {@link org.apache.lucene.search.similarities.TFIDFSimilarity}.
@@ -57,7 +57,7 @@
  * 
  * Since {@link org.apache.lucene.search.similarities.SimilarityBase} is not
  * optimized to the same extent as
- * {@link org.apache.lucene.search.similarities.DefaultSimilarity} and
+ * {@link org.apache.lucene.search.similarities.ClassicSimilarity} and
  * {@link org.apache.lucene.search.similarities.BM25Similarity}, a difference in
  * performance is to be expected when using the methods listed above. However,
  * optimizations can always be implemented in subclasses; see
@@ -81,7 +81,7 @@
  * 
  * <p>To make this change, implement your own {@link org.apache.lucene.search.similarities.Similarity} (likely
  *     you'll want to simply subclass an existing method, be it
- *     {@link org.apache.lucene.search.similarities.DefaultSimilarity} or a descendant of
+ *     {@link org.apache.lucene.search.similarities.ClassicSimilarity} or a descendant of
  *     {@link org.apache.lucene.search.similarities.SimilarityBase}), and
  *     then register the new class by calling
  *     {@link org.apache.lucene.index.IndexWriterConfig#setSimilarity(Similarity)}
@@ -109,7 +109,7 @@
  * subclassing the Similarity, one can simply introduce a new basic model and tell
  * {@link org.apache.lucene.search.similarities.DFRSimilarity} to use it.
  * 
- * <h3>Changing {@linkplain org.apache.lucene.search.similarities.DefaultSimilarity}</h3>
+ * <h3>Changing {@linkplain org.apache.lucene.search.similarities.ClassicSimilarity}</h3>
  * <p>
  *     If you are interested in use cases for changing your similarity, see the Lucene users's mailing list at <a
  *         href="http://www.gossamer-threads.com/lists/lucene/java-user/39125">Overriding Similarity</a>.
@@ -126,7 +126,7 @@
  *         <li><p>Changing Length Normalization &mdash; By overriding
  *             {@link org.apache.lucene.search.similarities.Similarity#computeNorm(org.apache.lucene.index.FieldInvertState state)},
  *             it is possible to discount how the length of a field contributes
- *             to a score. In {@link org.apache.lucene.search.similarities.DefaultSimilarity},
+ *             to a score. In {@link org.apache.lucene.search.similarities.ClassicSimilarity},
  *             lengthNorm = 1 / (numTerms in field)^0.5, but if one changes this to be
  *             1 / (numTerms in field), all fields will be treated
  *             <a href="http://www.gossamer-threads.com/lists/lucene/java-user/38967#38967">"fairly"</a>.</li>
diff --git a/lucene/core/src/java/org/apache/lucene/util/QueryBuilder.java b/lucene/core/src/java/org/apache/lucene/util/QueryBuilder.java
index 7faeb0a..1f7041d 100644
--- a/lucene/core/src/java/org/apache/lucene/util/QueryBuilder.java
+++ b/lucene/core/src/java/org/apache/lucene/util/QueryBuilder.java
@@ -32,6 +32,7 @@ import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.MultiPhraseQuery;
 import org.apache.lucene.search.PhraseQuery;
 import org.apache.lucene.search.Query;
+import org.apache.lucene.search.SynonymQuery;
 import org.apache.lucene.search.TermQuery;
 
 /**
@@ -280,28 +281,25 @@ public class QueryBuilder {
    * Creates simple boolean query from the cached tokenstream contents 
    */
   private Query analyzeBoolean(String field, TokenStream stream) throws IOException {
-    BooleanQuery.Builder q = new BooleanQuery.Builder();
-    q.setDisableCoord(true);
-
     TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);
     
     stream.reset();
+    List<Term> terms = new ArrayList<>();
     while (stream.incrementToken()) {
-      Query currentQuery = newTermQuery(new Term(field, BytesRef.deepCopyOf(termAtt.getBytesRef())));
-      q.add(currentQuery, BooleanClause.Occur.SHOULD);
+      terms.add(new Term(field, BytesRef.deepCopyOf(termAtt.getBytesRef())));
     }
     
-    return q.build();
+    return newSynonymQuery(terms.toArray(new Term[terms.size()]));
   }
 
-  private void add(BooleanQuery.Builder q, BooleanQuery current, BooleanClause.Occur operator) {
-    if (current.clauses().isEmpty()) {
+  private void add(BooleanQuery.Builder q, List<Term> current, BooleanClause.Occur operator) {
+    if (current.isEmpty()) {
       return;
     }
-    if (current.clauses().size() == 1) {
-      q.add(current.clauses().iterator().next().getQuery(), operator);
+    if (current.size() == 1) {
+      q.add(newTermQuery(current.get(0)), operator);
     } else {
-      q.add(current, operator);
+      q.add(newSynonymQuery(current.toArray(new Term[current.size()])), operator);
     }
   }
 
@@ -309,8 +307,8 @@ public class QueryBuilder {
    * Creates complex boolean query from the cached tokenstream contents 
    */
   private Query analyzeMultiBoolean(String field, TokenStream stream, BooleanClause.Occur operator) throws IOException {
-    BooleanQuery.Builder q = newBooleanQuery(false);
-    BooleanQuery.Builder currentQuery = newBooleanQuery(true);
+    BooleanQuery.Builder q = newBooleanQuery();
+    List<Term> currentQuery = new ArrayList<>();
     
     TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);
     PositionIncrementAttribute posIncrAtt = stream.getAttribute(PositionIncrementAttribute.class);
@@ -318,12 +316,12 @@ public class QueryBuilder {
     stream.reset();
     while (stream.incrementToken()) {
       if (posIncrAtt.getPositionIncrement() != 0) {
-        add(q, currentQuery.build(), operator);
-        currentQuery = newBooleanQuery(true);
+        add(q, currentQuery, operator);
+        currentQuery.clear();
       }
-      currentQuery.add(newTermQuery(new Term(field, BytesRef.deepCopyOf(termAtt.getBytesRef()))), BooleanClause.Occur.SHOULD);
+      currentQuery.add(new Term(field, BytesRef.deepCopyOf(termAtt.getBytesRef())));
     }
-    add(q, currentQuery.build(), operator);
+    add(q, currentQuery, operator);
     
     return q.build();
   }
@@ -393,13 +391,20 @@ public class QueryBuilder {
    * Builds a new BooleanQuery instance.
    * <p>
    * This is intended for subclasses that wish to customize the generated queries.
-   * @param disableCoord disable coord
    * @return new BooleanQuery instance
    */
-  protected BooleanQuery.Builder newBooleanQuery(boolean disableCoord) {
-    BooleanQuery.Builder builder = new BooleanQuery.Builder();
-    builder.setDisableCoord(disableCoord);
-    return builder;
+  protected BooleanQuery.Builder newBooleanQuery() {
+    return new BooleanQuery.Builder();
+  }
+  
+  /**
+   * Builds a new SynonymQuery instance.
+   * <p>
+   * This is intended for subclasses that wish to customize the generated queries.
+   * @return new Query instance
+   */
+  protected Query newSynonymQuery(Term terms[]) {
+    return new SynonymQuery(terms);
   }
   
   /**
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestCustomNorms.java b/lucene/core/src/test/org/apache/lucene/index/TestCustomNorms.java
index f1ce650..fc5c8f8 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestCustomNorms.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestCustomNorms.java
@@ -24,7 +24,7 @@ import org.apache.lucene.document.Field;
 import org.apache.lucene.document.TextField;
 import org.apache.lucene.search.CollectionStatistics;
 import org.apache.lucene.search.TermStatistics;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.search.similarities.PerFieldSimilarityWrapper;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.store.Directory;
@@ -80,7 +80,7 @@ public class TestCustomNorms extends LuceneTestCase {
   }
 
   public class MySimProvider extends PerFieldSimilarityWrapper {
-    Similarity delegate = new DefaultSimilarity();
+    Similarity delegate = new ClassicSimilarity();
 
     @Override
     public float queryNorm(float sumOfSquaredWeights) {
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterConfig.java b/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterConfig.java
index cf56631..89342e5 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterConfig.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterConfig.java
@@ -30,7 +30,7 @@ import org.apache.lucene.document.Field.Store;
 import org.apache.lucene.index.DocumentsWriterPerThread.IndexingChain;
 import org.apache.lucene.index.IndexWriterConfig.OpenMode;
 import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.InfoStream;
 import org.apache.lucene.util.LuceneTestCase;
@@ -39,7 +39,7 @@ import org.junit.Test;
 
 public class TestIndexWriterConfig extends LuceneTestCase {
 
-  private static final class MySimilarity extends DefaultSimilarity {
+  private static final class MySimilarity extends ClassicSimilarity {
     // Does not implement anything - used only for type checking on IndexWriterConfig.
   }
 
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestNorms.java b/lucene/core/src/test/org/apache/lucene/index/TestNorms.java
index 564284a..d0f64fb 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestNorms.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestNorms.java
@@ -26,7 +26,7 @@ import org.apache.lucene.document.Field;
 import org.apache.lucene.document.TextField;
 import org.apache.lucene.search.CollectionStatistics;
 import org.apache.lucene.search.TermStatistics;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.search.similarities.PerFieldSimilarityWrapper;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.search.similarities.TFIDFSimilarity;
@@ -154,7 +154,7 @@ public class TestNorms extends LuceneTestCase {
 
 
   public class MySimProvider extends PerFieldSimilarityWrapper {
-    Similarity delegate = new DefaultSimilarity();
+    Similarity delegate = new ClassicSimilarity();
 
     @Override
     public float queryNorm(float sumOfSquaredWeights) {
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestBoolean2.java b/lucene/core/src/test/org/apache/lucene/search/TestBoolean2.java
index d1204ad..5bb606c 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestBoolean2.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestBoolean2.java
@@ -27,7 +27,7 @@ import org.apache.lucene.index.DirectoryReader;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.MockDirectoryWrapper;
@@ -65,7 +65,7 @@ public class TestBoolean2 extends LuceneTestCase {
     littleReader = DirectoryReader.open(directory);
     searcher = newSearcher(littleReader);
     // this is intentionally using the baseline sim, because it compares against bigSearcher (which uses a random one)
-    searcher.setSimilarity(new DefaultSimilarity());
+    searcher.setSimilarity(new ClassicSimilarity());
 
     // Make big index
     dir2 = new MockDirectoryWrapper(random(), TestUtil.ramCopyOf(directory));
@@ -242,7 +242,7 @@ public class TestBoolean2 extends LuceneTestCase {
     int[] expDocNrs = {2, 3};
     Similarity oldSimilarity = searcher.getSimilarity(true);
     try {
-      searcher.setSimilarity(new DefaultSimilarity(){
+      searcher.setSimilarity(new ClassicSimilarity(){
         @Override
         public float coord(int overlap, int maxOverlap) {
           return overlap / ((float)maxOverlap - 1);
@@ -279,7 +279,7 @@ public class TestBoolean2 extends LuceneTestCase {
           searcher.setSimilarity(bigSearcher.getSimilarity(true)); // random sim
           QueryUtils.check(random(), q1, searcher);
         } finally {
-          searcher.setSimilarity(new DefaultSimilarity()); // restore
+          searcher.setSimilarity(new ClassicSimilarity()); // restore
         }
 
         TopFieldCollector collector = TopFieldCollector.create(sort, 1000,
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestBooleanMinShouldMatch.java b/lucene/core/src/test/org/apache/lucene/search/TestBooleanMinShouldMatch.java
index db507e5..bdc2930 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestBooleanMinShouldMatch.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestBooleanMinShouldMatch.java
@@ -24,7 +24,7 @@ import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.StoredDocument;
 import org.apache.lucene.index.Term;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.store.Directory;
 import org.junit.AfterClass;
@@ -398,7 +398,7 @@ public class TestBooleanMinShouldMatch extends LuceneTestCase {
     public void testRewriteCoord1() throws Exception {
       final Similarity oldSimilarity = s.getSimilarity(true);
       try {
-        s.setSimilarity(new DefaultSimilarity() {
+        s.setSimilarity(new ClassicSimilarity() {
           @Override
           public float coord(int overlap, int maxOverlap) {
             return overlap / ((float)maxOverlap + 1);
@@ -420,7 +420,7 @@ public class TestBooleanMinShouldMatch extends LuceneTestCase {
     public void testRewriteNegate() throws Exception {
       final Similarity oldSimilarity = s.getSimilarity(true);
       try {
-        s.setSimilarity(new DefaultSimilarity() {
+        s.setSimilarity(new ClassicSimilarity() {
           @Override
           public float coord(int overlap, int maxOverlap) {
             return overlap / ((float)maxOverlap + 1);
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestBooleanQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestBooleanQuery.java
index 25c8337..b8e6a8d 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestBooleanQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestBooleanQuery.java
@@ -44,7 +44,7 @@ import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.search.BooleanTopLevelScorers.BoostedScorer;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.search.spans.SpanQuery;
 import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.store.Directory;
@@ -95,7 +95,7 @@ public class TestBooleanQuery extends LuceneTestCase {
     IndexSearcher s = newSearcher(r);
     // this test relies upon coord being the default implementation,
     // otherwise scores are different!
-    s.setSimilarity(new DefaultSimilarity());
+    s.setSimilarity(new ClassicSimilarity());
 
     BooleanQuery.Builder q = new BooleanQuery.Builder();
     q.add(new TermQuery(new Term("field", "a")), BooleanClause.Occur.SHOULD);
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestBooleanQueryVisitSubscorers.java b/lucene/core/src/test/org/apache/lucene/search/TestBooleanQueryVisitSubscorers.java
index 405cad6..7a7dc2f 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestBooleanQueryVisitSubscorers.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestBooleanQueryVisitSubscorers.java
@@ -37,6 +37,7 @@ import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.search.Scorer.ChildScorer;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
 
@@ -68,8 +69,11 @@ public class TestBooleanQueryVisitSubscorers extends LuceneTestCase {
     writer.close();
     // we do not use newSearcher because the assertingXXX layers break
     // the toString representations we are relying on
+    // TODO: clean that up
     searcher = new IndexSearcher(reader);
+    searcher.setSimilarity(new ClassicSimilarity());
     scorerSearcher = new ScorerIndexSearcher(reader);
+    scorerSearcher.setSimilarity(new ClassicSimilarity());
   }
   
   @Override
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestComplexExplanations.java b/lucene/core/src/test/org/apache/lucene/search/TestComplexExplanations.java
index f278d2d..8031c69 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestComplexExplanations.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestComplexExplanations.java
@@ -19,7 +19,7 @@ package org.apache.lucene.search;
 
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.BooleanClause.Occur;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.search.spans.*;
 
 /**
@@ -46,8 +46,8 @@ public class TestComplexExplanations extends BaseExplanationTestCase {
   }
 
   // must be static for weight serialization tests 
-  private static DefaultSimilarity createQnorm1Similarity() {
-    return new DefaultSimilarity() {
+  private static ClassicSimilarity createQnorm1Similarity() {
+    return new ClassicSimilarity() {
         @Override
         public float queryNorm(float sumOfSquaredWeights) {
           return 1.0f; // / (float) Math.sqrt(1.0f + sumOfSquaredWeights);
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery.java
index 47f9faa..ff5820a 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery.java
@@ -31,7 +31,7 @@ import org.apache.lucene.index.MultiReader;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.BooleanClause.Occur;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.IOUtils;
@@ -103,7 +103,7 @@ public class TestConstantScoreQuery extends LuceneTestCase {
       searcher.setQueryCache(null); // to assert on scorer impl
       
       // set a similarity that does not normalize our boost away
-      searcher.setSimilarity(new DefaultSimilarity() {
+      searcher.setSimilarity(new ClassicSimilarity() {
         @Override
         public float queryNorm(float sumOfSquaredWeights) {
           return 1.0f;
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestDisjunctionMaxQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestDisjunctionMaxQuery.java
index a5d05de..6b6683e 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestDisjunctionMaxQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestDisjunctionMaxQuery.java
@@ -38,7 +38,7 @@ import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.SlowCompositeReaderWrapper;
 import org.apache.lucene.index.StoredDocument;
 import org.apache.lucene.index.Term;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.search.spans.SpanQuery;
 import org.apache.lucene.search.spans.SpanTermQuery;
@@ -63,7 +63,7 @@ public class TestDisjunctionMaxQuery extends LuceneTestCase {
    * http://issues.apache.org/jira/browse/LUCENE-323
    * </p>
    */
-  private static class TestSimilarity extends DefaultSimilarity {
+  private static class TestSimilarity extends ClassicSimilarity {
     
     public TestSimilarity() {}
     
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestElevationComparator.java b/lucene/core/src/test/org/apache/lucene/search/TestElevationComparator.java
index d0c6daf..ca0811e9 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestElevationComparator.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestElevationComparator.java
@@ -23,7 +23,7 @@ import org.apache.lucene.document.Field;
 import org.apache.lucene.document.SortedDocValuesField;
 import org.apache.lucene.index.*;
 import org.apache.lucene.search.FieldValueHitQueue.Entry;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.store.*;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.BytesRef;
@@ -44,7 +44,7 @@ public class TestElevationComparator extends LuceneTestCase {
         newIndexWriterConfig(new MockAnalyzer(random())).
             setMaxBufferedDocs(2).
             setMergePolicy(newLogMergePolicy(1000)).
-            setSimilarity(new DefaultSimilarity())
+            setSimilarity(new ClassicSimilarity())
     );
     writer.addDocument(adoc(new String[] {"id", "a", "title", "ipod", "str_s", "a"}));
     writer.addDocument(adoc(new String[] {"id", "b", "title", "ipod ipod", "str_s", "b"}));
@@ -57,7 +57,7 @@ public class TestElevationComparator extends LuceneTestCase {
     writer.close();
 
     IndexSearcher searcher = newSearcher(r);
-    searcher.setSimilarity(new DefaultSimilarity());
+    searcher.setSimilarity(new ClassicSimilarity());
 
     runTest(searcher, true);
     runTest(searcher, false);
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery.java
index 9c11b85..d6a1b08 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery.java
@@ -31,7 +31,7 @@ import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.StoredDocument;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.BooleanClause.Occur;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.automaton.LevenshteinAutomata;
@@ -259,7 +259,7 @@ public class TestFuzzyQuery extends LuceneTestCase {
 
     IndexReader reader = writer.getReader();
     IndexSearcher searcher = newSearcher(reader);
-    searcher.setSimilarity(new DefaultSimilarity()); //avoid randomisation of similarity algo by test framework
+    searcher.setSimilarity(new ClassicSimilarity()); //avoid randomisation of similarity algo by test framework
     writer.close();
     String searchTerms[] = { "smith", "smythe", "smdssasd" };
     for (String searchTerm : searchTerms) {
@@ -296,7 +296,7 @@ public class TestFuzzyQuery extends LuceneTestCase {
 
     IndexReader reader = writer.getReader();
     IndexSearcher searcher = newSearcher(reader);
-    searcher.setSimilarity(new DefaultSimilarity()); //avoid randomisation of similarity algo by test framework
+    searcher.setSimilarity(new ClassicSimilarity()); //avoid randomisation of similarity algo by test framework
 
     writer.close();
 
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestMinShouldMatch2.java b/lucene/core/src/test/org/apache/lucene/search/TestMinShouldMatch2.java
index 9749581..40b1912 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestMinShouldMatch2.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestMinShouldMatch2.java
@@ -35,7 +35,7 @@ import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.SortedSetDocValues;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.search.similarities.Similarity.SimScorer;
 import org.apache.lucene.search.similarities.Similarity.SimWeight;
 import org.apache.lucene.store.Directory;
@@ -89,7 +89,7 @@ public class TestMinShouldMatch2 extends LuceneTestCase {
     r = DirectoryReader.open(dir);
     reader = getOnlySegmentReader(r);
     searcher = new IndexSearcher(reader);
-    searcher.setSimilarity(new DefaultSimilarity() {
+    searcher.setSimilarity(new ClassicSimilarity() {
       @Override
       public float queryNorm(float sumOfSquaredWeights) {
         return 1; // we disable queryNorm, both for debugging and ease of impl
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestMultiPhraseQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestMultiPhraseQuery.java
index 46c8ab8..cbc7962 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestMultiPhraseQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestMultiPhraseQuery.java
@@ -33,7 +33,7 @@ import org.apache.lucene.index.MultiFields;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermsEnum;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.RAMDirectory;
 import org.apache.lucene.util.BytesRef;
@@ -334,7 +334,7 @@ public class TestMultiPhraseQuery extends LuceneTestCase {
     
     IndexReader reader = writer.getReader();
     IndexSearcher searcher = newSearcher(reader);
-    searcher.setSimilarity(new DefaultSimilarity() { 
+    searcher.setSimilarity(new ClassicSimilarity() { 
       @Override
       public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats[]) {
         return Explanation.match(10f, "just a test");
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestMultiTermConstantScore.java b/lucene/core/src/test/org/apache/lucene/search/TestMultiTermConstantScore.java
index 7a807a6..4e4a810 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestMultiTermConstantScore.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestMultiTermConstantScore.java
@@ -27,7 +27,7 @@ import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.store.Directory;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
@@ -223,7 +223,7 @@ public class TestMultiTermConstantScore extends BaseTestRangeFilter {
     // test for correct application of query normalization
     // must use a non score normalizing method for this.
     
-    search.setSimilarity(new DefaultSimilarity());
+    search.setSimilarity(new ClassicSimilarity());
     Query q = csrq("data", "1", "6", T, T);
     search.search(new BoostQuery(q, 100), new SimpleCollector() {
       private int base = 0;
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestPhraseQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestPhraseQuery.java
index f5a30ef..a5848fa 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestPhraseQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestPhraseQuery.java
@@ -34,7 +34,7 @@ import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexWriterConfig.OpenMode;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.TestUtil;
@@ -306,7 +306,7 @@ public class TestPhraseQuery extends LuceneTestCase {
     RandomIndexWriter writer = new RandomIndexWriter(random(), directory, 
         newIndexWriterConfig(new MockAnalyzer(random()))
           .setMergePolicy(newLogMergePolicy())
-          .setSimilarity(new DefaultSimilarity()));
+          .setSimilarity(new ClassicSimilarity()));
 
     Document doc = new Document();
     doc.add(newTextField("field", "foo firstname lastname foo", Field.Store.YES));
@@ -324,7 +324,7 @@ public class TestPhraseQuery extends LuceneTestCase {
     writer.close();
 
     IndexSearcher searcher = newSearcher(reader);
-    searcher.setSimilarity(new DefaultSimilarity());
+    searcher.setSimilarity(new ClassicSimilarity());
     PhraseQuery query = new PhraseQuery(Integer.MAX_VALUE, "field", "firstname", "lastname");
     ScoreDoc[] hits = searcher.search(query, 1000).scoreDocs;
     assertEquals(3, hits.length);
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestQueryRescorer.java b/lucene/core/src/test/org/apache/lucene/search/TestQueryRescorer.java
index 9e704f8..5a03ec1 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestQueryRescorer.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestQueryRescorer.java
@@ -30,7 +30,7 @@ import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.BooleanClause.Occur;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanQuery;
 import org.apache.lucene.search.spans.SpanTermQuery;
@@ -44,7 +44,7 @@ public class TestQueryRescorer extends LuceneTestCase {
     IndexSearcher searcher = newSearcher(r);
 
     // We rely on more tokens = lower score:
-    searcher.setSimilarity(new DefaultSimilarity());
+    searcher.setSimilarity(new ClassicSimilarity());
 
     return searcher;
   }
@@ -70,7 +70,7 @@ public class TestQueryRescorer extends LuceneTestCase {
     bq.add(new TermQuery(new Term("field", "wizard")), Occur.SHOULD);
     bq.add(new TermQuery(new Term("field", "oz")), Occur.SHOULD);
     IndexSearcher searcher = getSearcher(r);
-    searcher.setSimilarity(new DefaultSimilarity());
+    searcher.setSimilarity(new ClassicSimilarity());
 
     TopDocs hits = searcher.search(bq.build(), 10);
     assertEquals(2, hits.totalHits);
@@ -125,7 +125,7 @@ public class TestQueryRescorer extends LuceneTestCase {
     bq.add(new TermQuery(new Term("field", "wizard")), Occur.SHOULD);
     bq.add(new TermQuery(new Term("field", "oz")), Occur.SHOULD);
     IndexSearcher searcher = getSearcher(r);
-    searcher.setSimilarity(new DefaultSimilarity());
+    searcher.setSimilarity(new ClassicSimilarity());
 
     TopDocs hits = searcher.search(bq.build(), 10);
     assertEquals(2, hits.totalHits);
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSimilarity.java b/lucene/core/src/test/org/apache/lucene/search/TestSimilarity.java
index 7f90639..f045f58 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestSimilarity.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSimilarity.java
@@ -27,7 +27,7 @@ import org.apache.lucene.index.FieldInvertState;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
@@ -38,7 +38,7 @@ import org.apache.lucene.document.Document;
  */
 public class TestSimilarity extends LuceneTestCase {
   
-  public static class SimpleSimilarity extends DefaultSimilarity {
+  public static class SimpleSimilarity extends ClassicSimilarity {
     @Override
     public float queryNorm(float sumOfSquaredWeights) { return 1.0f; }
     @Override
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSimpleExplanations.java b/lucene/core/src/test/org/apache/lucene/search/TestSimpleExplanations.java
index c77329f..92702aa 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestSimpleExplanations.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSimpleExplanations.java
@@ -678,5 +678,10 @@ public class TestSimpleExplanations extends BaseExplanationTestCase {
 
     qtest(query.build(), new int[] { 0,1,2,3 });
   }
+  
+  public void testSynonymQuery() throws Exception {
+    SynonymQuery query = new SynonymQuery(new Term(FIELD, "w1"), new Term(FIELD, "w2"));
+    qtest(query, new int[] { 0,1,2,3 });
+  }
 
 }
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSimpleSearchEquivalence.java b/lucene/core/src/test/org/apache/lucene/search/TestSimpleSearchEquivalence.java
index 1321900..978949e 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestSimpleSearchEquivalence.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSimpleSearchEquivalence.java
@@ -230,4 +230,15 @@ public class TestSimpleSearchEquivalence extends SearchEquivalenceTestBase {
 
     assertSameScores(q1, q2);
   }
+  
+  public void testBooleanOrVsSynonym() throws Exception {
+    Term t1 = randomTerm();
+    Term t2 = randomTerm();
+    assertEquals(t1.field(), t2.field());
+    SynonymQuery q1 = new SynonymQuery(t1, t2);
+    BooleanQuery.Builder q2 = new BooleanQuery.Builder();
+    q2.add(new TermQuery(t1), Occur.SHOULD);
+    q2.add(new TermQuery(t2), Occur.SHOULD);
+    assertSameSet(q1, q2.build());
+  }
 }
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSortRescorer.java b/lucene/core/src/test/org/apache/lucene/search/TestSortRescorer.java
index 0c15958..cea0484 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestSortRescorer.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSortRescorer.java
@@ -28,6 +28,7 @@ import org.apache.lucene.index.DirectoryReader;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.TestUtil;
@@ -63,6 +64,8 @@ public class TestSortRescorer extends LuceneTestCase {
     
     reader = iw.getReader();
     searcher = new IndexSearcher(reader);
+    // TODO: fix this test to not be so flaky and use newSearcher
+    searcher.setSimilarity(new ClassicSimilarity());
     iw.close();
   }
   
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSynonymQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestSynonymQuery.java
new file mode 100644
index 0000000..38e6181
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSynonymQuery.java
@@ -0,0 +1,87 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field.Store;
+import org.apache.lucene.document.StringField;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+
+public class TestSynonymQuery extends LuceneTestCase {
+
+  public void testEquals() {
+    QueryUtils.checkEqual(new SynonymQuery(), new SynonymQuery());
+    QueryUtils.checkEqual(new SynonymQuery(new Term("foo", "bar")), 
+                          new SynonymQuery(new Term("foo", "bar")));
+    
+    QueryUtils.checkEqual(new SynonymQuery(new Term("a", "a"), new Term("a", "b")), 
+                          new SynonymQuery(new Term("a", "b"), new Term("a", "a")));
+  }
+  
+  public void testBogusParams() {
+    try {
+      new SynonymQuery(new Term("field1", "a"), new Term("field2", "b"));
+      fail();
+    } catch (IllegalArgumentException expected) {}
+  }
+
+  public void testToString() {
+    assertEquals("Synonym()", new SynonymQuery().toString());
+    Term t1 = new Term("foo", "bar");
+    assertEquals("Synonym(foo:bar)", new SynonymQuery(t1).toString());
+    Term t2 = new Term("foo", "baz");
+    assertEquals("Synonym(foo:bar foo:baz)", new SynonymQuery(t1, t2).toString());
+  }
+
+  public void testScores() throws IOException {
+    Directory dir = newDirectory();
+    RandomIndexWriter w = new RandomIndexWriter(random(), dir);
+
+    Document doc = new Document();
+    doc.add(new StringField("f", "a", Store.NO));
+    w.addDocument(doc);
+
+    doc = new Document();
+    doc.add(new StringField("f", "b", Store.NO));
+    for (int i = 0; i < 10; ++i) {
+      w.addDocument(doc);
+    }
+
+    IndexReader reader = w.getReader();
+    IndexSearcher searcher = newSearcher(reader);
+    SynonymQuery query = new SynonymQuery(new Term("f", "a"), new Term("f", "b"));
+
+    TopDocs topDocs = searcher.search(query, 20);
+    assertEquals(11, topDocs.totalHits);
+    // All docs must have the same score
+    for (int i = 0; i < topDocs.scoreDocs.length; ++i) {
+      assertEquals(topDocs.scoreDocs[0].score, topDocs.scoreDocs[i].score, 0.0f);
+    }
+
+    reader.close();
+    w.close();
+    dir.close();
+  }
+
+}
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestTermScorer.java b/lucene/core/src/test/org/apache/lucene/search/TestTermScorer.java
index c85c346..b6bb54c 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestTermScorer.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestTermScorer.java
@@ -31,7 +31,7 @@ import org.apache.lucene.index.NumericDocValues;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.SlowCompositeReaderWrapper;
 import org.apache.lucene.index.Term;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
 
@@ -52,7 +52,7 @@ public class TestTermScorer extends LuceneTestCase {
     RandomIndexWriter writer = new RandomIndexWriter(random(), directory, 
         newIndexWriterConfig(new MockAnalyzer(random()))
         .setMergePolicy(newLogMergePolicy())
-        .setSimilarity(new DefaultSimilarity()));
+        .setSimilarity(new ClassicSimilarity()));
     for (int i = 0; i < values.length; i++) {
       Document doc = new Document();
       doc
@@ -62,7 +62,7 @@ public class TestTermScorer extends LuceneTestCase {
     indexReader = SlowCompositeReaderWrapper.wrap(writer.getReader());
     writer.close();
     indexSearcher = newSearcher(indexReader);
-    indexSearcher.setSimilarity(new DefaultSimilarity());
+    indexSearcher.setSimilarity(new ClassicSimilarity());
   }
   
   @Override
diff --git a/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadExplanations.java b/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadExplanations.java
index b6dc7d0..c08e560 100644
--- a/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadExplanations.java
+++ b/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadExplanations.java
@@ -19,7 +19,7 @@ package org.apache.lucene.search.payloads;
 
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.BaseExplanationTestCase;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.search.spans.SpanBoostQuery;
 import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanOrQuery;
@@ -41,7 +41,7 @@ public class TestPayloadExplanations extends BaseExplanationTestCase {
   @Override
   public void setUp() throws Exception {
     super.setUp();
-    searcher.setSimilarity(new DefaultSimilarity() {
+    searcher.setSimilarity(new ClassicSimilarity() {
       @Override
       public float scorePayload(int doc, int start, int end, BytesRef payload) {
         return 1 + (payload.hashCode() % 10);
diff --git a/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadScoreQuery.java b/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadScoreQuery.java
index 6ec5092..22242fd 100644
--- a/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadScoreQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadScoreQuery.java
@@ -37,7 +37,7 @@ import org.apache.lucene.search.Explanation;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.TermStatistics;
 import org.apache.lucene.search.TopDocs;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.search.spans.SpanContainingQuery;
 import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanOrQuery;
@@ -234,7 +234,7 @@ public class TestPayloadScoreQuery extends LuceneTestCase {
     directory = null;
   }
 
-  static class BoostingSimilarity extends DefaultSimilarity {
+  static class BoostingSimilarity extends ClassicSimilarity {
 
     @Override
     public float queryNorm(float sumOfSquaredWeights) {
diff --git a/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadSpans.java b/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadSpans.java
index c1c5f1d..e817ad4 100644
--- a/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadSpans.java
+++ b/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadSpans.java
@@ -34,7 +34,7 @@ import org.apache.lucene.index.Term;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TopDocs;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.search.spans.MultiSpansWrapper;
 import org.apache.lucene.search.spans.SpanFirstQuery;
@@ -57,7 +57,7 @@ import java.util.Set;
 
 public class TestPayloadSpans extends LuceneTestCase {
   private IndexSearcher searcher;
-  private Similarity similarity = new DefaultSimilarity();
+  private Similarity similarity = new ClassicSimilarity();
   protected IndexReader indexReader;
   private IndexReader closeIndexReader;
   private Directory directory;
diff --git a/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadTermQuery.java b/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadTermQuery.java
index 0dd0ad0..5cc0927 100644
--- a/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadTermQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadTermQuery.java
@@ -37,7 +37,7 @@ import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.QueryUtils;
 import org.apache.lucene.search.ScoreDoc;
 import org.apache.lucene.search.TopDocs;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.search.spans.MultiSpansWrapper;
 import org.apache.lucene.search.spans.SpanQuery;
@@ -255,7 +255,7 @@ public class TestPayloadTermQuery extends LuceneTestCase {
     CheckHits.checkHitCollector(random(), query.build(), PayloadHelper.NO_PAYLOAD_FIELD, searcher, results);
   }
 
-  static class BoostingSimilarity extends DefaultSimilarity {
+  static class BoostingSimilarity extends ClassicSimilarity {
 
     @Override
     public float queryNorm(float sumOfSquaredWeights) {
@@ -298,7 +298,7 @@ public class TestPayloadTermQuery extends LuceneTestCase {
     }
   }
 
-  static class FullSimilarity extends DefaultSimilarity{
+  static class FullSimilarity extends ClassicSimilarity{
     public float scorePayload(int docId, String fieldName, byte[] payload, int offset, int length) {
       //we know it is size 4 here, so ignore the offset/length
       return payload[offset];
diff --git a/lucene/core/src/test/org/apache/lucene/search/similarities/TestClassicSimilarity.java b/lucene/core/src/test/org/apache/lucene/search/similarities/TestClassicSimilarity.java
new file mode 100644
index 0000000..a8ef2ee
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/similarities/TestClassicSimilarity.java
@@ -0,0 +1,161 @@
+package org.apache.lucene.search.similarities;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Arrays;
+
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.StringField;
+import org.apache.lucene.document.Field.Store;
+import org.apache.lucene.index.DirectoryReader;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.DisjunctionMaxQuery;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.TopDocs;
+import org.apache.lucene.search.BooleanClause.Occur;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.IOUtils;
+import org.apache.lucene.util.LuceneTestCase;
+
+public class TestClassicSimilarity extends LuceneTestCase {
+  private Directory directory;
+  private IndexReader indexReader;
+  private IndexSearcher indexSearcher;
+
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    directory = newDirectory();
+    try (IndexWriter indexWriter = new IndexWriter(directory, newIndexWriterConfig())) {
+      Document document = new Document();
+      document.add(new StringField("test", "hit", Store.NO));
+      indexWriter.addDocument(document);
+      indexWriter.commit();
+    }
+    indexReader = DirectoryReader.open(directory);
+    indexSearcher = newSearcher(indexReader);
+    indexSearcher.setSimilarity(new ClassicSimilarity());
+  }
+
+  @Override
+  public void tearDown() throws Exception {
+    IOUtils.close(indexReader, directory);
+    super.tearDown();
+  }
+  
+  // Javadocs give this as an example so we test to make sure it's correct:
+  public void testPrecisionLoss() throws Exception {
+    ClassicSimilarity sim = new ClassicSimilarity();
+    float v = sim.decodeNormValue(sim.encodeNormValue(.89f));
+    assertEquals(0.875f, v, 0.0001f);
+  }
+
+
+  public void testHit() throws IOException {
+    Query query = new TermQuery(new Term("test", "hit"));
+    TopDocs topDocs = indexSearcher.search(query, 1);
+    assertEquals(1, topDocs.totalHits);
+    assertEquals(1, topDocs.scoreDocs.length);
+    assertTrue(topDocs.scoreDocs[0].score != 0);
+  }
+
+  public void testMiss() throws IOException {
+    Query query = new TermQuery(new Term("test", "miss"));
+    TopDocs topDocs = indexSearcher.search(query, 1);
+    assertEquals(0, topDocs.totalHits);
+  }
+
+  public void testEmpty() throws IOException {
+    Query query = new TermQuery(new Term("empty", "miss"));
+    TopDocs topDocs = indexSearcher.search(query, 1);
+    assertEquals(0, topDocs.totalHits);
+  }
+
+  public void testBQHit() throws IOException {
+    Query query = new BooleanQuery.Builder()
+      .add(new TermQuery(new Term("test", "hit")), Occur.SHOULD)
+      .build();
+    TopDocs topDocs = indexSearcher.search(query, 1);
+    assertEquals(1, topDocs.totalHits);
+    assertEquals(1, topDocs.scoreDocs.length);
+    assertTrue(topDocs.scoreDocs[0].score != 0);
+  }
+
+  public void testBQHitOrMiss() throws IOException {
+    Query query = new BooleanQuery.Builder()
+      .add(new TermQuery(new Term("test", "hit")), Occur.SHOULD)
+      .add(new TermQuery(new Term("test", "miss")), Occur.SHOULD)
+      .build();
+    TopDocs topDocs = indexSearcher.search(query, 1);
+    assertEquals(1, topDocs.totalHits);
+    assertEquals(1, topDocs.scoreDocs.length);
+    assertTrue(topDocs.scoreDocs[0].score != 0);
+  }
+
+  public void testBQHitOrEmpty() throws IOException {
+    Query query = new BooleanQuery.Builder()
+      .add(new TermQuery(new Term("test", "hit")), Occur.SHOULD)
+      .add(new TermQuery(new Term("empty", "miss")), Occur.SHOULD)
+      .build();
+    TopDocs topDocs = indexSearcher.search(query, 1);
+    assertEquals(1, topDocs.totalHits);
+    assertEquals(1, topDocs.scoreDocs.length);
+    assertTrue(topDocs.scoreDocs[0].score != 0);
+  }
+
+  public void testDMQHit() throws IOException {
+    Query query = new DisjunctionMaxQuery(
+      Arrays.asList(
+        new TermQuery(new Term("test", "hit"))),
+      0);
+    TopDocs topDocs = indexSearcher.search(query, 1);
+    assertEquals(1, topDocs.totalHits);
+    assertEquals(1, topDocs.scoreDocs.length);
+    assertTrue(topDocs.scoreDocs[0].score != 0);
+  }
+
+  public void testDMQHitOrMiss() throws IOException {
+    Query query = new DisjunctionMaxQuery(
+      Arrays.asList(
+        new TermQuery(new Term("test", "hit")),
+        new TermQuery(new Term("test", "miss"))),
+      0);
+    TopDocs topDocs = indexSearcher.search(query, 1);
+    assertEquals(1, topDocs.totalHits);
+    assertEquals(1, topDocs.scoreDocs.length);
+    assertTrue(topDocs.scoreDocs[0].score != 0);
+  }
+
+  public void testDMQHitOrEmpty() throws IOException {
+    Query query = new DisjunctionMaxQuery(
+      Arrays.asList(
+        new TermQuery(new Term("test", "hit")),
+        new TermQuery(new Term("empty", "miss"))),
+      0);
+    TopDocs topDocs = indexSearcher.search(query, 1);
+    assertEquals(1, topDocs.totalHits);
+    assertEquals(1, topDocs.scoreDocs.length);
+    assertTrue(topDocs.scoreDocs[0].score != 0);
+  }
+}
diff --git a/lucene/core/src/test/org/apache/lucene/search/similarities/TestDefaultSimilarity.java b/lucene/core/src/test/org/apache/lucene/search/similarities/TestDefaultSimilarity.java
deleted file mode 100644
index f5f45be..0000000
--- a/lucene/core/src/test/org/apache/lucene/search/similarities/TestDefaultSimilarity.java
+++ /dev/null
@@ -1,161 +0,0 @@
-package org.apache.lucene.search.similarities;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.util.Arrays;
-
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.StringField;
-import org.apache.lucene.document.Field.Store;
-import org.apache.lucene.index.DirectoryReader;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.DisjunctionMaxQuery;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.TopDocs;
-import org.apache.lucene.search.BooleanClause.Occur;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.IOUtils;
-import org.apache.lucene.util.LuceneTestCase;
-
-public class TestDefaultSimilarity extends LuceneTestCase {
-  private Directory directory;
-  private IndexReader indexReader;
-  private IndexSearcher indexSearcher;
-
-  @Override
-  public void setUp() throws Exception {
-    super.setUp();
-    directory = newDirectory();
-    try (IndexWriter indexWriter = new IndexWriter(directory, newIndexWriterConfig())) {
-      Document document = new Document();
-      document.add(new StringField("test", "hit", Store.NO));
-      indexWriter.addDocument(document);
-      indexWriter.commit();
-    }
-    indexReader = DirectoryReader.open(directory);
-    indexSearcher = newSearcher(indexReader);
-    indexSearcher.setSimilarity(new DefaultSimilarity());
-  }
-
-  @Override
-  public void tearDown() throws Exception {
-    IOUtils.close(indexReader, directory);
-    super.tearDown();
-  }
-  
-  // Javadocs give this as an example so we test to make sure it's correct:
-  public void testPrecisionLoss() throws Exception {
-    DefaultSimilarity sim = new DefaultSimilarity();
-    float v = sim.decodeNormValue(sim.encodeNormValue(.89f));
-    assertEquals(0.875f, v, 0.0001f);
-  }
-
-
-  public void testHit() throws IOException {
-    Query query = new TermQuery(new Term("test", "hit"));
-    TopDocs topDocs = indexSearcher.search(query, 1);
-    assertEquals(1, topDocs.totalHits);
-    assertEquals(1, topDocs.scoreDocs.length);
-    assertTrue(topDocs.scoreDocs[0].score != 0);
-  }
-
-  public void testMiss() throws IOException {
-    Query query = new TermQuery(new Term("test", "miss"));
-    TopDocs topDocs = indexSearcher.search(query, 1);
-    assertEquals(0, topDocs.totalHits);
-  }
-
-  public void testEmpty() throws IOException {
-    Query query = new TermQuery(new Term("empty", "miss"));
-    TopDocs topDocs = indexSearcher.search(query, 1);
-    assertEquals(0, topDocs.totalHits);
-  }
-
-  public void testBQHit() throws IOException {
-    Query query = new BooleanQuery.Builder()
-      .add(new TermQuery(new Term("test", "hit")), Occur.SHOULD)
-      .build();
-    TopDocs topDocs = indexSearcher.search(query, 1);
-    assertEquals(1, topDocs.totalHits);
-    assertEquals(1, topDocs.scoreDocs.length);
-    assertTrue(topDocs.scoreDocs[0].score != 0);
-  }
-
-  public void testBQHitOrMiss() throws IOException {
-    Query query = new BooleanQuery.Builder()
-      .add(new TermQuery(new Term("test", "hit")), Occur.SHOULD)
-      .add(new TermQuery(new Term("test", "miss")), Occur.SHOULD)
-      .build();
-    TopDocs topDocs = indexSearcher.search(query, 1);
-    assertEquals(1, topDocs.totalHits);
-    assertEquals(1, topDocs.scoreDocs.length);
-    assertTrue(topDocs.scoreDocs[0].score != 0);
-  }
-
-  public void testBQHitOrEmpty() throws IOException {
-    Query query = new BooleanQuery.Builder()
-      .add(new TermQuery(new Term("test", "hit")), Occur.SHOULD)
-      .add(new TermQuery(new Term("empty", "miss")), Occur.SHOULD)
-      .build();
-    TopDocs topDocs = indexSearcher.search(query, 1);
-    assertEquals(1, topDocs.totalHits);
-    assertEquals(1, topDocs.scoreDocs.length);
-    assertTrue(topDocs.scoreDocs[0].score != 0);
-  }
-
-  public void testDMQHit() throws IOException {
-    Query query = new DisjunctionMaxQuery(
-      Arrays.asList(
-        new TermQuery(new Term("test", "hit"))),
-      0);
-    TopDocs topDocs = indexSearcher.search(query, 1);
-    assertEquals(1, topDocs.totalHits);
-    assertEquals(1, topDocs.scoreDocs.length);
-    assertTrue(topDocs.scoreDocs[0].score != 0);
-  }
-
-  public void testDMQHitOrMiss() throws IOException {
-    Query query = new DisjunctionMaxQuery(
-      Arrays.asList(
-        new TermQuery(new Term("test", "hit")),
-        new TermQuery(new Term("test", "miss"))),
-      0);
-    TopDocs topDocs = indexSearcher.search(query, 1);
-    assertEquals(1, topDocs.totalHits);
-    assertEquals(1, topDocs.scoreDocs.length);
-    assertTrue(topDocs.scoreDocs[0].score != 0);
-  }
-
-  public void testDMQHitOrEmpty() throws IOException {
-    Query query = new DisjunctionMaxQuery(
-      Arrays.asList(
-        new TermQuery(new Term("test", "hit")),
-        new TermQuery(new Term("empty", "miss"))),
-      0);
-    TopDocs topDocs = indexSearcher.search(query, 1);
-    assertEquals(1, topDocs.totalHits);
-    assertEquals(1, topDocs.scoreDocs.length);
-    assertTrue(topDocs.scoreDocs[0].score != 0);
-  }
-}
diff --git a/lucene/core/src/test/org/apache/lucene/search/similarities/TestSimilarity2.java b/lucene/core/src/test/org/apache/lucene/search/similarities/TestSimilarity2.java
index 4e49308..db93cd2 100644
--- a/lucene/core/src/test/org/apache/lucene/search/similarities/TestSimilarity2.java
+++ b/lucene/core/src/test/org/apache/lucene/search/similarities/TestSimilarity2.java
@@ -52,7 +52,7 @@ public class TestSimilarity2 extends LuceneTestCase {
   public void setUp() throws Exception {
     super.setUp();
     sims = new ArrayList<>();
-    sims.add(new DefaultSimilarity());
+    sims.add(new ClassicSimilarity());
     sims.add(new BM25Similarity());
     // TODO: not great that we dup this all with TestSimilarityBase
     for (BasicModel basicModel : TestSimilarityBase.BASIC_MODELS) {
diff --git a/lucene/core/src/test/org/apache/lucene/search/similarities/TestSimilarityBase.java b/lucene/core/src/test/org/apache/lucene/search/similarities/TestSimilarityBase.java
index ee53565..3a4f431 100644
--- a/lucene/core/src/test/org/apache/lucene/search/similarities/TestSimilarityBase.java
+++ b/lucene/core/src/test/org/apache/lucene/search/similarities/TestSimilarityBase.java
@@ -579,7 +579,7 @@ public class TestSimilarityBase extends LuceneTestCase {
   
   // LUCENE-5221
   public void testDiscountOverlapsBoost() throws IOException {
-    DefaultSimilarity expected = new DefaultSimilarity();
+    ClassicSimilarity expected = new ClassicSimilarity();
     SimilarityBase actual = new DFRSimilarity(new BasicModelIne(), new AfterEffectB(), new NormalizationH2());
     expected.setDiscountOverlaps(false);
     actual.setDiscountOverlaps(false);
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java
index 9529a45..200fdec 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java
@@ -35,7 +35,7 @@ import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.Scorer;
 import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
@@ -286,7 +286,7 @@ public class TestSpans extends LuceneTestCase {
     for (int i = 0, c = leaves.size(); i < c; i++) {
       final LeafReaderContext ctx = leaves.get(i);
      
-      final Similarity sim = new DefaultSimilarity() {
+      final Similarity sim = new ClassicSimilarity() {
         @Override
         public float sloppyFreq(int distance) {
           return 0.0f;
diff --git a/lucene/core/src/test/org/apache/lucene/util/TestQueryBuilder.java b/lucene/core/src/test/org/apache/lucene/util/TestQueryBuilder.java
index 23f2b6a..1ce1663 100644
--- a/lucene/core/src/test/org/apache/lucene/util/TestQueryBuilder.java
+++ b/lucene/core/src/test/org/apache/lucene/util/TestQueryBuilder.java
@@ -33,6 +33,7 @@ import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.MultiPhraseQuery;
 import org.apache.lucene.search.PhraseQuery;
 import org.apache.lucene.search.Query;
+import org.apache.lucene.search.SynonymQuery;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.util.automaton.CharacterRunAutomaton;
 import org.apache.lucene.util.automaton.RegExp;
@@ -162,11 +163,7 @@ public class TestQueryBuilder extends LuceneTestCase {
   
   /** simple synonyms test */
   public void testSynonyms() throws Exception {
-    BooleanQuery.Builder expectedB = new BooleanQuery.Builder();
-    expectedB.setDisableCoord(true);
-    expectedB.add(new TermQuery(new Term("field", "dogs")), BooleanClause.Occur.SHOULD);
-    expectedB.add(new TermQuery(new Term("field", "dog")), BooleanClause.Occur.SHOULD);
-    Query expected = expectedB.build();
+    SynonymQuery expected = new SynonymQuery(new Term("field", "dogs"), new Term("field", "dog"));
     QueryBuilder builder = new QueryBuilder(new MockSynonymAnalyzer());
     assertEquals(expected, builder.createBooleanQuery("field", "dogs"));
     assertEquals(expected, builder.createPhraseQuery("field", "dogs"));
@@ -281,25 +278,19 @@ public class TestQueryBuilder extends LuceneTestCase {
   
   /** simple CJK synonym test */
   public void testCJKSynonym() throws Exception {
-    BooleanQuery.Builder expected = new BooleanQuery.Builder();
-    expected.setDisableCoord(true);
-    expected.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
-    expected.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
+    SynonymQuery expected = new SynonymQuery(new Term("field", "??"), new Term("field", "??"));
     QueryBuilder builder = new QueryBuilder(new MockCJKSynonymAnalyzer());
-    assertEquals(expected.build(), builder.createBooleanQuery("field", "??"));
-    assertEquals(expected.build(), builder.createPhraseQuery("field", "??"));
-    assertEquals(expected.build(), builder.createBooleanQuery("field", "??", BooleanClause.Occur.MUST));
+    assertEquals(expected, builder.createBooleanQuery("field", "??"));
+    assertEquals(expected, builder.createPhraseQuery("field", "??"));
+    assertEquals(expected, builder.createBooleanQuery("field", "??", BooleanClause.Occur.MUST));
   }
   
   /** synonyms with default OR operator */
   public void testCJKSynonymsOR() throws Exception {
     BooleanQuery.Builder expected = new BooleanQuery.Builder();
     expected.add(new TermQuery(new Term("field", "?")), BooleanClause.Occur.SHOULD);
-    BooleanQuery.Builder inner = new BooleanQuery.Builder();
-    inner.setDisableCoord(true);
-    inner.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
-    inner.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
-    expected.add(inner.build(), BooleanClause.Occur.SHOULD);
+    SynonymQuery inner = new SynonymQuery(new Term("field", "??"), new Term("field", "??"));
+    expected.add(inner, BooleanClause.Occur.SHOULD);
     QueryBuilder builder = new QueryBuilder(new MockCJKSynonymAnalyzer());
     assertEquals(expected.build(), builder.createBooleanQuery("field", "??"));
   }
@@ -308,16 +299,10 @@ public class TestQueryBuilder extends LuceneTestCase {
   public void testCJKSynonymsOR2() throws Exception {
     BooleanQuery.Builder expected = new BooleanQuery.Builder();
     expected.add(new TermQuery(new Term("field", "?")), BooleanClause.Occur.SHOULD);
-    BooleanQuery.Builder inner = new BooleanQuery.Builder();
-    inner.setDisableCoord(true);
-    inner.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
-    inner.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
-    expected.add(inner.build(), BooleanClause.Occur.SHOULD);
-    BooleanQuery.Builder inner2 = new BooleanQuery.Builder();
-    inner2.setDisableCoord(true);
-    inner2.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
-    inner2.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
-    expected.add(inner2.build(), BooleanClause.Occur.SHOULD);
+    SynonymQuery inner = new SynonymQuery(new Term("field", "??"), new Term("field", "??"));
+    expected.add(inner, BooleanClause.Occur.SHOULD);
+    SynonymQuery inner2 = new SynonymQuery(new Term("field", "??"), new Term("field", "??"));
+    expected.add(inner2, BooleanClause.Occur.SHOULD);
     QueryBuilder builder = new QueryBuilder(new MockCJKSynonymAnalyzer());
     assertEquals(expected.build(), builder.createBooleanQuery("field", "????"));
   }
@@ -326,11 +311,8 @@ public class TestQueryBuilder extends LuceneTestCase {
   public void testCJKSynonymsAND() throws Exception {
     BooleanQuery.Builder expected = new BooleanQuery.Builder();
     expected.add(new TermQuery(new Term("field", "?")), BooleanClause.Occur.MUST);
-    BooleanQuery.Builder inner = new BooleanQuery.Builder();
-    inner.setDisableCoord(true);
-    inner.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
-    inner.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
-    expected.add(inner.build(), BooleanClause.Occur.MUST);
+    SynonymQuery inner = new SynonymQuery(new Term("field", "??"), new Term("field", "??"));
+    expected.add(inner, BooleanClause.Occur.MUST);
     QueryBuilder builder = new QueryBuilder(new MockCJKSynonymAnalyzer());
     assertEquals(expected.build(), builder.createBooleanQuery("field", "??", BooleanClause.Occur.MUST));
   }
@@ -339,16 +321,10 @@ public class TestQueryBuilder extends LuceneTestCase {
   public void testCJKSynonymsAND2() throws Exception {
     BooleanQuery.Builder expected = new BooleanQuery.Builder();
     expected.add(new TermQuery(new Term("field", "?")), BooleanClause.Occur.MUST);
-    BooleanQuery.Builder inner = new BooleanQuery.Builder();
-    inner.setDisableCoord(true);
-    inner.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
-    inner.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
-    expected.add(inner.build(), BooleanClause.Occur.MUST);
-    BooleanQuery.Builder inner2 = new BooleanQuery.Builder();
-    inner2.setDisableCoord(true);
-    inner2.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
-    inner2.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
-    expected.add(inner2.build(), BooleanClause.Occur.MUST);
+    SynonymQuery inner = new SynonymQuery(new Term("field", "??"), new Term("field", "??"));
+    expected.add(inner, BooleanClause.Occur.MUST);
+    SynonymQuery inner2 = new SynonymQuery(new Term("field", "??"), new Term("field", "??"));
+    expected.add(inner2, BooleanClause.Occur.MUST);
     QueryBuilder builder = new QueryBuilder(new MockCJKSynonymAnalyzer());
     assertEquals(expected.build(), builder.createBooleanQuery("field", "????", BooleanClause.Occur.MUST));
   }
diff --git a/lucene/expressions/src/test/org/apache/lucene/expressions/TestExpressionRescorer.java b/lucene/expressions/src/test/org/apache/lucene/expressions/TestExpressionRescorer.java
index 828f60f..cb4656b 100644
--- a/lucene/expressions/src/test/org/apache/lucene/expressions/TestExpressionRescorer.java
+++ b/lucene/expressions/src/test/org/apache/lucene/expressions/TestExpressionRescorer.java
@@ -31,6 +31,7 @@ import org.apache.lucene.search.Rescorer;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TopDocs;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
 
@@ -65,6 +66,8 @@ public class TestExpressionRescorer extends LuceneTestCase {
     
     reader = iw.getReader();
     searcher = new IndexSearcher(reader);
+    // TODO: fix this test to not be so flaky and use newSearcher
+    searcher.setSimilarity(new ClassicSimilarity());
     iw.close();
   }
   
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetCounts.java b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetCounts.java
index d04cfb1..cb0eeb2 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetCounts.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetCounts.java
@@ -50,7 +50,7 @@ import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.MatchAllDocsQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.search.similarities.PerFieldSimilarityWrapper;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.store.Directory;
@@ -267,7 +267,7 @@ public class TestTaxonomyFacetCounts extends FacetTestCase {
     Directory taxoDir = newDirectory();
     IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));
     iwc.setSimilarity(new PerFieldSimilarityWrapper() {
-        final Similarity sim = new DefaultSimilarity();
+        final Similarity sim = new ClassicSimilarity();
 
         @Override
         public Similarity get(String name) {
diff --git a/lucene/highlighter/src/java/org/apache/lucene/search/highlight/QueryTermExtractor.java b/lucene/highlighter/src/java/org/apache/lucene/search/highlight/QueryTermExtractor.java
index 7ccf04a..6b471be 100644
--- a/lucene/highlighter/src/java/org/apache/lucene/search/highlight/QueryTermExtractor.java
+++ b/lucene/highlighter/src/java/org/apache/lucene/search/highlight/QueryTermExtractor.java
@@ -80,7 +80,7 @@ public final class QueryTermExtractor
           try
             {
                 int docFreq=reader.docFreq(new Term(fieldName,terms[i].term));
-                //IDF algorithm taken from DefaultSimilarity class
+                //IDF algorithm taken from ClassicSimilarity class
                 float idf=(float)(Math.log(totalNumDocs/(double)(docFreq+1)) + 1.0);
                 terms[i].weight*=idf;
             } 
diff --git a/lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java b/lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java
index da57233..4cd4566 100644
--- a/lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java
+++ b/lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java
@@ -545,7 +545,7 @@ public class WeightedSpanTermExtractor {
       while (it.hasNext()) {
         WeightedSpanTerm weightedSpanTerm = terms.get(it.next());
         int docFreq = reader.docFreq(new Term(fieldName, weightedSpanTerm.term));
-        // IDF algorithm taken from DefaultSimilarity class
+        // IDF algorithm taken from ClassicSimilarity class
         float idf = (float) (Math.log(totalNumDocs / (double) (docFreq + 1)) + 1.0);
         weightedSpanTerm.weight *= idf;
       }
diff --git a/lucene/memory/src/test/org/apache/lucene/index/memory/TestMemoryIndex.java b/lucene/memory/src/test/org/apache/lucene/index/memory/TestMemoryIndex.java
index f1c5c7b..9011231 100644
--- a/lucene/memory/src/test/org/apache/lucene/index/memory/TestMemoryIndex.java
+++ b/lucene/memory/src/test/org/apache/lucene/index/memory/TestMemoryIndex.java
@@ -30,7 +30,7 @@ import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.MatchAllDocsQuery;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.similarities.BM25Similarity;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.TestUtil;
 import org.junit.Before;
@@ -90,7 +90,7 @@ public class TestMemoryIndex extends LuceneTestCase {
     assertThat(mi.search(new TermQuery(new Term("f1", "wibble"))), not(is(0.0f)));
 
     // check we can set the Similarity again
-    mi.setSimilarity(new DefaultSimilarity());
+    mi.setSimilarity(new ClassicSimilarity());
 
   }
 
@@ -144,7 +144,7 @@ public class TestMemoryIndex extends LuceneTestCase {
     float n1 = reader.getNormValues("f1").get(0);
 
     // Norms are re-computed when we change the Similarity
-    mi.setSimilarity(new DefaultSimilarity() {
+    mi.setSimilarity(new ClassicSimilarity() {
       @Override
       public float lengthNorm(FieldInvertState state) {
         return 74;
diff --git a/lucene/misc/src/java/org/apache/lucene/misc/SweetSpotSimilarity.java b/lucene/misc/src/java/org/apache/lucene/misc/SweetSpotSimilarity.java
index 5ebff53..5c9e8b6 100644
--- a/lucene/misc/src/java/org/apache/lucene/misc/SweetSpotSimilarity.java
+++ b/lucene/misc/src/java/org/apache/lucene/misc/SweetSpotSimilarity.java
@@ -17,7 +17,7 @@
 
 package org.apache.lucene.misc;
 
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.index.FieldInvertState;
 
 /**
@@ -38,7 +38,7 @@ import org.apache.lucene.index.FieldInvertState;
  *
  * @see <a href="doc-files/ss.gnuplot">A Gnuplot file used to generate some of the visualizations refrenced from each function.</a> 
  */
-public class SweetSpotSimilarity extends DefaultSimilarity {
+public class SweetSpotSimilarity extends ClassicSimilarity {
 
   private int ln_min = 1;
   private int ln_max = 1;
diff --git a/lucene/misc/src/test/org/apache/lucene/misc/SweetSpotSimilarityTest.java b/lucene/misc/src/test/org/apache/lucene/misc/SweetSpotSimilarityTest.java
index f5e35f2..d42e63f 100644
--- a/lucene/misc/src/test/org/apache/lucene/misc/SweetSpotSimilarityTest.java
+++ b/lucene/misc/src/test/org/apache/lucene/misc/SweetSpotSimilarityTest.java
@@ -18,7 +18,7 @@
 
 package org.apache.lucene.misc;
 
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.search.similarities.PerFieldSimilarityWrapper;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.search.similarities.TFIDFSimilarity;
@@ -44,7 +44,7 @@ public class SweetSpotSimilarityTest extends LuceneTestCase {
     final SweetSpotSimilarity ss = new SweetSpotSimilarity();
     ss.setLengthNormFactors(1,1,0.5f,true);
 
-    Similarity d = new DefaultSimilarity();
+    Similarity d = new ClassicSimilarity();
     Similarity s = ss;
 
 
@@ -200,7 +200,7 @@ public class SweetSpotSimilarityTest extends LuceneTestCase {
   
     SweetSpotSimilarity ss = new SweetSpotSimilarity();
 
-    TFIDFSimilarity d = new DefaultSimilarity();
+    TFIDFSimilarity d = new ClassicSimilarity();
     TFIDFSimilarity s = ss;
     
     // tf equal
diff --git a/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/IDFValueSource.java b/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/IDFValueSource.java
index ec74af3..ae1d39d 100644
--- a/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/IDFValueSource.java
+++ b/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/IDFValueSource.java
@@ -50,7 +50,7 @@ public class IDFValueSource extends DocFreqValueSource {
     IndexSearcher searcher = (IndexSearcher)context.get("searcher");
     TFIDFSimilarity sim = asTFIDF(searcher.getSimilarity(true), field);
     if (sim == null) {
-      throw new UnsupportedOperationException("requires a TFIDFSimilarity (such as DefaultSimilarity)");
+      throw new UnsupportedOperationException("requires a TFIDFSimilarity (such as ClassicSimilarity)");
     }
     int docfreq = searcher.getIndexReader().docFreq(new Term(indexedField, indexedBytes));
     float idf = sim.idf(docfreq, searcher.getIndexReader().maxDoc());
diff --git a/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/NormValueSource.java b/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/NormValueSource.java
index c1ed382..bb9e641 100644
--- a/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/NormValueSource.java
+++ b/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/NormValueSource.java
@@ -60,7 +60,7 @@ public class NormValueSource extends ValueSource {
     IndexSearcher searcher = (IndexSearcher)context.get("searcher");
     final TFIDFSimilarity similarity = IDFValueSource.asTFIDF(searcher.getSimilarity(true), field);
     if (similarity == null) {
-      throw new UnsupportedOperationException("requires a TFIDFSimilarity (such as DefaultSimilarity)");
+      throw new UnsupportedOperationException("requires a TFIDFSimilarity (such as ClassicSimilarity)");
     }
     final NumericDocValues norms = readerContext.reader().getNormValues(field);
 
diff --git a/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/TFValueSource.java b/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/TFValueSource.java
index bbae30b..9165cb2 100644
--- a/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/TFValueSource.java
+++ b/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/TFValueSource.java
@@ -56,7 +56,7 @@ public class TFValueSource extends TermFreqValueSource {
     IndexSearcher searcher = (IndexSearcher)context.get("searcher");
     final TFIDFSimilarity similarity = IDFValueSource.asTFIDF(searcher.getSimilarity(true), indexedField);
     if (similarity == null) {
-      throw new UnsupportedOperationException("requires a TFIDFSimilarity (such as DefaultSimilarity)");
+      throw new UnsupportedOperationException("requires a TFIDFSimilarity (such as ClassicSimilarity)");
     }
 
     return new FloatDocValues(this) {
diff --git a/lucene/queries/src/java/org/apache/lucene/queries/mlt/MoreLikeThis.java b/lucene/queries/src/java/org/apache/lucene/queries/mlt/MoreLikeThis.java
index 69a35b6..f1a2ed2 100644
--- a/lucene/queries/src/java/org/apache/lucene/queries/mlt/MoreLikeThis.java
+++ b/lucene/queries/src/java/org/apache/lucene/queries/mlt/MoreLikeThis.java
@@ -32,7 +32,7 @@ import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.BoostQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.search.similarities.TFIDFSimilarity;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.CharsRefBuilder;
@@ -313,7 +313,7 @@ public final class MoreLikeThis {
    * Constructor requiring an IndexReader.
    */
   public MoreLikeThis(IndexReader ir) {
-    this(ir, new DefaultSimilarity());
+    this(ir, new ClassicSimilarity());
   }
 
   public MoreLikeThis(IndexReader ir, TFIDFSimilarity sim) {
diff --git a/lucene/queries/src/test/org/apache/lucene/queries/function/TestLongNormValueSource.java b/lucene/queries/src/test/org/apache/lucene/queries/function/TestLongNormValueSource.java
index 90b02f3..c2c1dff 100644
--- a/lucene/queries/src/test/org/apache/lucene/queries/function/TestLongNormValueSource.java
+++ b/lucene/queries/src/test/org/apache/lucene/queries/function/TestLongNormValueSource.java
@@ -49,7 +49,7 @@ public class TestLongNormValueSource extends LuceneTestCase {
   static IndexSearcher searcher;
   static Analyzer analyzer;
   
-  private static Similarity sim = new PreciseDefaultSimilarity();
+  private static Similarity sim = new PreciseClassicSimilarity();
 
   @BeforeClass
   public static void beforeClass() throws Exception {
@@ -120,10 +120,10 @@ public class TestLongNormValueSource extends LuceneTestCase {
 
 
 /** Encodes norm as 4-byte float. */
-class PreciseDefaultSimilarity extends TFIDFSimilarity {
+class PreciseClassicSimilarity extends TFIDFSimilarity {
 
   /** Sole constructor: parameter-free */
-  public PreciseDefaultSimilarity() {}
+  public PreciseClassicSimilarity() {}
 
   /** Implemented as <code>overlap / maxOverlap</code>. */
   @Override
diff --git a/lucene/queries/src/test/org/apache/lucene/queries/function/TestValueSources.java b/lucene/queries/src/test/org/apache/lucene/queries/function/TestValueSources.java
index 5acfc54..c689f57 100644
--- a/lucene/queries/src/test/org/apache/lucene/queries/function/TestValueSources.java
+++ b/lucene/queries/src/test/org/apache/lucene/queries/function/TestValueSources.java
@@ -80,7 +80,7 @@ import org.apache.lucene.search.Sort;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
@@ -224,7 +224,7 @@ public class TestValueSources extends LuceneTestCase {
   public void testIDF() throws Exception {
     Similarity saved = searcher.getSimilarity(true);
     try {
-      searcher.setSimilarity(new DefaultSimilarity());
+      searcher.setSimilarity(new ClassicSimilarity());
       ValueSource vs = new IDFValueSource("bogus", "bogus", "text", new BytesRef("test"));
       assertHits(new FunctionQuery(vs), new float[] { 1.0f, 1.0f });
       assertAllExist(vs);
@@ -343,7 +343,7 @@ public class TestValueSources extends LuceneTestCase {
     Similarity saved = searcher.getSimilarity(true);
     try {
       // no norm field (so agnostic to indexed similarity)
-      searcher.setSimilarity(new DefaultSimilarity());
+      searcher.setSimilarity(new ClassicSimilarity());
       ValueSource vs = new NormValueSource("byte");
       assertHits(new FunctionQuery(vs), new float[] { 0f, 0f });
 
@@ -395,7 +395,7 @@ public class TestValueSources extends LuceneTestCase {
     Similarity saved = searcher.getSimilarity(true);
 
     try {
-      searcher.setSimilarity(new DefaultSimilarity());
+      searcher.setSimilarity(new ClassicSimilarity());
       
       ValueSource vs = new QueryValueSource(new TermQuery(new Term("string","bar")), 42F);
       assertHits(new FunctionQuery(vs), new float[] { 42F, 1.4054651F });
@@ -502,7 +502,7 @@ public class TestValueSources extends LuceneTestCase {
     Similarity saved = searcher.getSimilarity(true);
     try {
       // no norm field (so agnostic to indexed similarity)
-      searcher.setSimilarity(new DefaultSimilarity());
+      searcher.setSimilarity(new ClassicSimilarity());
 
       ValueSource vs = new TFValueSource("bogus", "bogus", "text", new BytesRef("test"));
       assertHits(new FunctionQuery(vs), 
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/MultiFieldQueryParser.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/MultiFieldQueryParser.java
index b39279c..ade904a 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/MultiFieldQueryParser.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/MultiFieldQueryParser.java
@@ -98,7 +98,7 @@ public class MultiFieldQueryParser extends QueryParser
   @Override
   protected Query getFieldQuery(String field, String queryText, int slop) throws ParseException {
     if (field == null) {
-      List<BooleanClause> clauses = new ArrayList<>();
+      List<Query> clauses = new ArrayList<>();
       for (int i = 0; i < fields.length; i++) {
         Query q = super.getFieldQuery(fields[i], queryText, true);
         if (q != null) {
@@ -111,12 +111,12 @@ public class MultiFieldQueryParser extends QueryParser
             }
           }
           q = applySlop(q,slop);
-          clauses.add(new BooleanClause(q, BooleanClause.Occur.SHOULD));
+          clauses.add(q);
         }
       }
       if (clauses.size() == 0)  // happens for stopwords
         return null;
-      return getBooleanQuery(clauses, true);
+      return getMultiFieldQuery(clauses);
     }
     Query q = super.getFieldQuery(field, queryText, true);
     q = applySlop(q,slop);
@@ -144,7 +144,7 @@ public class MultiFieldQueryParser extends QueryParser
   @Override
   protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {
     if (field == null) {
-      List<BooleanClause> clauses = new ArrayList<>();
+      List<Query> clauses = new ArrayList<>();
       for (int i = 0; i < fields.length; i++) {
         Query q = super.getFieldQuery(fields[i], queryText, quoted);
         if (q != null) {
@@ -156,12 +156,12 @@ public class MultiFieldQueryParser extends QueryParser
               q = new BoostQuery(q, boost.floatValue());
             }
           }
-          clauses.add(new BooleanClause(q, BooleanClause.Occur.SHOULD));
+          clauses.add(q);
         }
       }
       if (clauses.size() == 0)  // happens for stopwords
         return null;
-      return getBooleanQuery(clauses, true);
+      return getMultiFieldQuery(clauses);
     }
     Query q = super.getFieldQuery(field, queryText, quoted);
     return q;
@@ -172,12 +172,11 @@ public class MultiFieldQueryParser extends QueryParser
   protected Query getFuzzyQuery(String field, String termStr, float minSimilarity) throws ParseException
   {
     if (field == null) {
-      List<BooleanClause> clauses = new ArrayList<>();
+      List<Query> clauses = new ArrayList<>();
       for (int i = 0; i < fields.length; i++) {
-        clauses.add(new BooleanClause(getFuzzyQuery(fields[i], termStr, minSimilarity),
-            BooleanClause.Occur.SHOULD));
+        clauses.add(getFuzzyQuery(fields[i], termStr, minSimilarity));
       }
-      return getBooleanQuery(clauses, true);
+      return getMultiFieldQuery(clauses);
     }
     return super.getFuzzyQuery(field, termStr, minSimilarity);
   }
@@ -186,12 +185,11 @@ public class MultiFieldQueryParser extends QueryParser
   protected Query getPrefixQuery(String field, String termStr) throws ParseException
   {
     if (field == null) {
-      List<BooleanClause> clauses = new ArrayList<>();
+      List<Query> clauses = new ArrayList<>();
       for (int i = 0; i < fields.length; i++) {
-        clauses.add(new BooleanClause(getPrefixQuery(fields[i], termStr),
-            BooleanClause.Occur.SHOULD));
+        clauses.add(getPrefixQuery(fields[i], termStr));
       }
-      return getBooleanQuery(clauses, true);
+      return getMultiFieldQuery(clauses);
     }
     return super.getPrefixQuery(field, termStr);
   }
@@ -199,12 +197,11 @@ public class MultiFieldQueryParser extends QueryParser
   @Override
   protected Query getWildcardQuery(String field, String termStr) throws ParseException {
     if (field == null) {
-      List<BooleanClause> clauses = new ArrayList<>();
+      List<Query> clauses = new ArrayList<>();
       for (int i = 0; i < fields.length; i++) {
-        clauses.add(new BooleanClause(getWildcardQuery(fields[i], termStr),
-            BooleanClause.Occur.SHOULD));
+        clauses.add(getWildcardQuery(fields[i], termStr));
       }
-      return getBooleanQuery(clauses, true);
+      return getMultiFieldQuery(clauses);
     }
     return super.getWildcardQuery(field, termStr);
   }
@@ -213,12 +210,11 @@ public class MultiFieldQueryParser extends QueryParser
   @Override
   protected Query getRangeQuery(String field, String part1, String part2, boolean startInclusive, boolean endInclusive) throws ParseException {
     if (field == null) {
-      List<BooleanClause> clauses = new ArrayList<>();
+      List<Query> clauses = new ArrayList<>();
       for (int i = 0; i < fields.length; i++) {
-        clauses.add(new BooleanClause(getRangeQuery(fields[i], part1, part2, startInclusive, endInclusive),
-            BooleanClause.Occur.SHOULD));
+        clauses.add(getRangeQuery(fields[i], part1, part2, startInclusive, endInclusive));
       }
-      return getBooleanQuery(clauses, true);
+      return getMultiFieldQuery(clauses);
     }
     return super.getRangeQuery(field, part1, part2, startInclusive, endInclusive);
   }
@@ -229,15 +225,28 @@ public class MultiFieldQueryParser extends QueryParser
   protected Query getRegexpQuery(String field, String termStr)
       throws ParseException {
     if (field == null) {
-      List<BooleanClause> clauses = new ArrayList<>();
+      List<Query> clauses = new ArrayList<>();
       for (int i = 0; i < fields.length; i++) {
-        clauses.add(new BooleanClause(getRegexpQuery(fields[i], termStr),
-            BooleanClause.Occur.SHOULD));
+        clauses.add(getRegexpQuery(fields[i], termStr));
       }
-      return getBooleanQuery(clauses, true);
+      return getMultiFieldQuery(clauses);
     }
     return super.getRegexpQuery(field, termStr);
   }
+  
+  /** Creates a multifield query */
+  // TODO: investigate more general approach by default, e.g. DisjunctionMaxQuery?
+  protected Query getMultiFieldQuery(List<Query> queries) throws ParseException {
+    if (queries.isEmpty()) {
+      return null; // all clause words were filtered away by the analyzer.
+    }
+    BooleanQuery.Builder query = newBooleanQuery();
+    query.setDisableCoord(true);
+    for (Query sub : queries) {
+      query.add(sub, BooleanClause.Occur.SHOULD);
+    }
+    return query.build();
+  }
 
   /**
    * Parses a query which searches on the fields specified.
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserBase.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserBase.java
index 5d4f966..8e17905 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserBase.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserBase.java
@@ -116,7 +116,7 @@ public abstract class QueryParserBase extends QueryBuilder implements CommonQuer
     try {
       // TopLevelQuery is a Query followed by the end-of-input (EOF)
       Query res = TopLevelQuery(field);
-      return res!=null ? res : newBooleanQuery(false).build();
+      return res!=null ? res : newBooleanQuery().build();
     }
     catch (ParseException | TokenMgrError tme) {
       // rethrow to include the original query:
@@ -688,30 +688,10 @@ public abstract class QueryParserBase extends QueryBuilder implements CommonQuer
    * @exception org.apache.lucene.queryparser.classic.ParseException throw in overridden method to disallow
    */
   protected Query getBooleanQuery(List<BooleanClause> clauses) throws ParseException {
-    return getBooleanQuery(clauses, false);
-  }
-
-  /**
-   * Factory method for generating query, given a set of clauses.
-   * By default creates a boolean query composed of clauses passed in.
-   *
-   * Can be overridden by extending classes, to modify query being
-   * returned.
-   *
-   * @param clauses List that contains {@link org.apache.lucene.search.BooleanClause} instances
-   *    to join.
-   * @param disableCoord true if coord scoring should be disabled.
-   *
-   * @return Resulting {@link org.apache.lucene.search.Query} object.
-   * @exception org.apache.lucene.queryparser.classic.ParseException throw in overridden method to disallow
-   */
-  protected Query getBooleanQuery(List<BooleanClause> clauses, boolean disableCoord)
-    throws ParseException
-  {
     if (clauses.size()==0) {
       return null; // all clause words were filtered away by the analyzer.
     }
-    BooleanQuery.Builder query = newBooleanQuery(disableCoord);
+    BooleanQuery.Builder query = newBooleanQuery();
     for(final BooleanClause clause: clauses) {
       query.add(clause);
     }
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/classic/TestMultiAnalyzer.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/classic/TestMultiAnalyzer.java
index 67bdde4..00c6232 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/classic/TestMultiAnalyzer.java
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/classic/TestMultiAnalyzer.java
@@ -50,12 +50,12 @@ public class TestMultiAnalyzer extends BaseTokenStreamTestCase {
     assertEquals("\"foo foobar blah\"", qp.parse("\"foo foobar blah\"").toString());
 
     // two tokens at the same position:
-    assertEquals("(multi multi2) foo", qp.parse("multi foo").toString());
-    assertEquals("foo (multi multi2)", qp.parse("foo multi").toString());
-    assertEquals("(multi multi2) (multi multi2)", qp.parse("multi multi").toString());
-    assertEquals("+(foo (multi multi2)) +(bar (multi multi2))",
+    assertEquals("Synonym(multi multi2) foo", qp.parse("multi foo").toString());
+    assertEquals("foo Synonym(multi multi2)", qp.parse("foo multi").toString());
+    assertEquals("Synonym(multi multi2) Synonym(multi multi2)", qp.parse("multi multi").toString());
+    assertEquals("+(foo Synonym(multi multi2)) +(bar Synonym(multi multi2))",
         qp.parse("+(foo multi) +(bar multi)").toString());
-    assertEquals("+(foo (multi multi2)) field:\"bar (multi multi2)\"",
+    assertEquals("+(foo Synonym(multi multi2)) field:\"bar (multi multi2)\"",
         qp.parse("+(foo multi) field:\"bar multi\"").toString());
 
     // phrases:
@@ -65,12 +65,12 @@ public class TestMultiAnalyzer extends BaseTokenStreamTestCase {
         qp.parse("\"foo multi foobar multi\"").toString());
 
     // fields:
-    assertEquals("(field:multi field:multi2) field:foo", qp.parse("field:multi field:foo").toString());
+    assertEquals("Synonym(field:multi field:multi2) field:foo", qp.parse("field:multi field:foo").toString());
     assertEquals("field:\"(multi multi2) foo\"", qp.parse("field:\"multi foo\"").toString());
 
     // three tokens at one position:
-    assertEquals("triplemulti multi3 multi2", qp.parse("triplemulti").toString());
-    assertEquals("foo (triplemulti multi3 multi2) foobar",
+    assertEquals("Synonym(multi2 multi3 triplemulti)", qp.parse("triplemulti").toString());
+    assertEquals("foo Synonym(multi2 multi3 triplemulti) foobar",
         qp.parse("foo triplemulti foobar").toString());
 
     // phrase with non-default slop:
@@ -89,7 +89,7 @@ public class TestMultiAnalyzer extends BaseTokenStreamTestCase {
 
     // non-default operator:
     qp.setDefaultOperator(QueryParserBase.AND_OPERATOR);
-    assertEquals("+(multi multi2) +foo", qp.parse("multi foo").toString());
+    assertEquals("+Synonym(multi multi2) +foo", qp.parse("multi foo").toString());
 
   }
     
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/classic/TestQueryParser.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/classic/TestQueryParser.java
index 0bc5410..da1b574 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/classic/TestQueryParser.java
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/classic/TestQueryParser.java
@@ -35,6 +35,7 @@ import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.BoostQuery;
 import org.apache.lucene.search.MultiPhraseQuery;
 import org.apache.lucene.search.Query;
+import org.apache.lucene.search.SynonymQuery;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.util.automaton.TooComplexToDeterminizeException;
 
@@ -300,21 +301,16 @@ public class TestQueryParser extends QueryParserTestBase {
     /** ordinary behavior, synonyms form uncoordinated boolean query */
     QueryParser dumb = new QueryParser("field",
         new Analyzer1());
-    BooleanQuery.Builder expanded = new BooleanQuery.Builder();
-    expanded.setDisableCoord(true);
-    expanded.add(new TermQuery(new Term("field", "dogs")),
-        BooleanClause.Occur.SHOULD);
-    expanded.add(new TermQuery(new Term("field", "dog")),
-        BooleanClause.Occur.SHOULD);
-    assertEquals(expanded.build(), dumb.parse("\"dogs\""));
+    Query expanded = new SynonymQuery(new Term("field", "dogs"), new Term("field", "dog"));
+    assertEquals(expanded, dumb.parse("\"dogs\""));
     /** even with the phrase operator the behavior is the same */
-    assertEquals(expanded.build(), dumb.parse("dogs"));
+    assertEquals(expanded, dumb.parse("dogs"));
     
     /**
      * custom behavior, the synonyms are expanded, unless you use quote operator
      */
     QueryParser smart = new SmartQueryParser();
-    assertEquals(expanded.build(), smart.parse("dogs"));
+    assertEquals(expanded, smart.parse("dogs"));
     
     Query unexpanded = new TermQuery(new Term("field", "dogs"));
     assertEquals(unexpanded, smart.parse("\"dogs\""));
@@ -333,11 +329,7 @@ public class TestQueryParser extends QueryParserTestBase {
   
   /** simple synonyms test */
   public void testSynonyms() throws Exception {
-    BooleanQuery.Builder expectedB = new BooleanQuery.Builder();
-    expectedB.setDisableCoord(true);
-    expectedB.add(new TermQuery(new Term("field", "dogs")), BooleanClause.Occur.SHOULD);
-    expectedB.add(new TermQuery(new Term("field", "dog")), BooleanClause.Occur.SHOULD);
-    Query expected = expectedB.build();
+    Query expected = new SynonymQuery(new Term("field", "dogs"), new Term("field", "dog"));
     QueryParser qp = new QueryParser("field", new MockSynonymAnalyzer());
     assertEquals(expected, qp.parse("dogs"));
     assertEquals(expected, qp.parse("\"dogs\""));
@@ -405,11 +397,7 @@ public class TestQueryParser extends QueryParserTestBase {
   
   /** simple CJK synonym test */
   public void testCJKSynonym() throws Exception {
-    BooleanQuery.Builder expectedB = new BooleanQuery.Builder();
-    expectedB.setDisableCoord(true);
-    expectedB.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
-    expectedB.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
-    Query expected = expectedB.build();
+    Query expected = new SynonymQuery(new Term("field", "??"), new Term("field", "??"));
     QueryParser qp = new QueryParser("field", new MockCJKSynonymAnalyzer());
     assertEquals(expected, qp.parse("??"));
     qp.setDefaultOperator(Operator.AND);
@@ -422,11 +410,8 @@ public class TestQueryParser extends QueryParserTestBase {
   public void testCJKSynonymsOR() throws Exception {
     BooleanQuery.Builder expectedB = new BooleanQuery.Builder();
     expectedB.add(new TermQuery(new Term("field", "?")), BooleanClause.Occur.SHOULD);
-    BooleanQuery.Builder inner = new BooleanQuery.Builder();
-    inner.setDisableCoord(true);
-    inner.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
-    inner.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
-    expectedB.add(inner.build(), BooleanClause.Occur.SHOULD);
+    Query inner = new SynonymQuery(new Term("field", "??"), new Term("field", "??"));
+    expectedB.add(inner, BooleanClause.Occur.SHOULD);
     Query expected = expectedB.build();
     QueryParser qp = new QueryParser("field", new MockCJKSynonymAnalyzer());
     assertEquals(expected, qp.parse("??"));
@@ -438,16 +423,10 @@ public class TestQueryParser extends QueryParserTestBase {
   public void testCJKSynonymsOR2() throws Exception {
     BooleanQuery.Builder expectedB = new BooleanQuery.Builder();
     expectedB.add(new TermQuery(new Term("field", "?")), BooleanClause.Occur.SHOULD);
-    BooleanQuery.Builder inner = new BooleanQuery.Builder();
-    inner.setDisableCoord(true);
-    inner.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
-    inner.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
-    expectedB.add(inner.build(), BooleanClause.Occur.SHOULD);
-    BooleanQuery.Builder inner2 = new BooleanQuery.Builder();
-    inner2.setDisableCoord(true);
-    inner2.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
-    inner2.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
-    expectedB.add(inner2.build(), BooleanClause.Occur.SHOULD);
+    SynonymQuery inner = new SynonymQuery(new Term("field", "??"), new Term("field", "??"));
+    expectedB.add(inner, BooleanClause.Occur.SHOULD);
+    SynonymQuery inner2 = new SynonymQuery(new Term("field", "??"), new Term("field", "??"));
+    expectedB.add(inner2, BooleanClause.Occur.SHOULD);
     Query expected = expectedB.build();
     QueryParser qp = new QueryParser("field", new MockCJKSynonymAnalyzer());
     assertEquals(expected, qp.parse("????"));
@@ -459,11 +438,8 @@ public class TestQueryParser extends QueryParserTestBase {
   public void testCJKSynonymsAND() throws Exception {
     BooleanQuery.Builder expectedB = new BooleanQuery.Builder();
     expectedB.add(new TermQuery(new Term("field", "?")), BooleanClause.Occur.MUST);
-    BooleanQuery.Builder inner = new BooleanQuery.Builder();
-    inner.setDisableCoord(true);
-    inner.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
-    inner.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
-    expectedB.add(inner.build(), BooleanClause.Occur.MUST);
+    Query inner = new SynonymQuery(new Term("field", "??"), new Term("field", "??"));
+    expectedB.add(inner, BooleanClause.Occur.MUST);
     Query expected = expectedB.build();
     QueryParser qp = new QueryParser("field", new MockCJKSynonymAnalyzer());
     qp.setDefaultOperator(Operator.AND);
@@ -476,16 +452,10 @@ public class TestQueryParser extends QueryParserTestBase {
   public void testCJKSynonymsAND2() throws Exception {
     BooleanQuery.Builder expectedB = new BooleanQuery.Builder();
     expectedB.add(new TermQuery(new Term("field", "?")), BooleanClause.Occur.MUST);
-    BooleanQuery.Builder inner = new BooleanQuery.Builder();
-    inner.setDisableCoord(true);
-    inner.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
-    inner.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
-    expectedB.add(inner.build(), BooleanClause.Occur.MUST);
-    BooleanQuery.Builder inner2 = new BooleanQuery.Builder();
-    inner2.setDisableCoord(true);
-    inner2.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
-    inner2.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
-    expectedB.add(inner2.build(), BooleanClause.Occur.MUST);
+    Query inner = new SynonymQuery(new Term("field", "??"), new Term("field", "??"));
+    expectedB.add(inner, BooleanClause.Occur.MUST);
+    Query inner2 = new SynonymQuery(new Term("field", "??"), new Term("field", "??"));
+    expectedB.add(inner2, BooleanClause.Occur.MUST);
     Query expected = expectedB.build();
     QueryParser qp = new QueryParser("field", new MockCJKSynonymAnalyzer());
     qp.setDefaultOperator(Operator.AND);
diff --git a/lucene/sandbox/src/java/org/apache/lucene/sandbox/queries/FuzzyLikeThisQuery.java b/lucene/sandbox/src/java/org/apache/lucene/sandbox/queries/FuzzyLikeThisQuery.java
index 434bfd7..a920537 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/sandbox/queries/FuzzyLikeThisQuery.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/sandbox/queries/FuzzyLikeThisQuery.java
@@ -41,7 +41,7 @@ import org.apache.lucene.search.ConstantScoreQuery;
 import org.apache.lucene.search.MaxNonCompetitiveBoostAttribute;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.search.similarities.TFIDFSimilarity;
 import org.apache.lucene.util.AttributeSource;
 import org.apache.lucene.util.BytesRef;
@@ -68,7 +68,7 @@ public class FuzzyLikeThisQuery extends Query
     // a better way might be to convert this into multitermquery rewrite methods.
     // the rewrite method can 'average' the TermContext's term statistics (docfreq,totalTermFreq) 
     // provided to TermQuery, so that the general idea is agnostic to any scoring system...
-    static TFIDFSimilarity sim=new DefaultSimilarity();
+    static TFIDFSimilarity sim=new ClassicSimilarity();
     ArrayList<FieldVals> fieldVals=new ArrayList<>();
     Analyzer analyzer;
 
diff --git a/lucene/sandbox/src/test/org/apache/lucene/sandbox/queries/TestSlowFuzzyQuery2.java b/lucene/sandbox/src/test/org/apache/lucene/sandbox/queries/TestSlowFuzzyQuery2.java
index 01b9bfb..637b8ae 100644
--- a/lucene/sandbox/src/test/org/apache/lucene/sandbox/queries/TestSlowFuzzyQuery2.java
+++ b/lucene/sandbox/src/test/org/apache/lucene/sandbox/queries/TestSlowFuzzyQuery2.java
@@ -33,7 +33,7 @@ import org.apache.lucene.index.Term;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.MultiTermQuery;
 import org.apache.lucene.search.TopDocs;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.LuceneTestCase;
@@ -111,7 +111,7 @@ public class TestSlowFuzzyQuery2 extends LuceneTestCase {
     }
     // even though this uses a boost-only rewrite, this test relies upon queryNorm being the default implementation,
     // otherwise scores are different!
-    searcher.setSimilarity(new DefaultSimilarity());
+    searcher.setSimilarity(new ClassicSimilarity());
     
     writer.close();
     String line;
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/RandomSimilarityProvider.java b/lucene/test-framework/src/java/org/apache/lucene/search/RandomSimilarityProvider.java
index 5f68765..e0b0ab3 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/search/RandomSimilarityProvider.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/RandomSimilarityProvider.java
@@ -37,7 +37,7 @@ import org.apache.lucene.search.similarities.BasicModelIn;
 import org.apache.lucene.search.similarities.BasicModelIne;
 import org.apache.lucene.search.similarities.BasicModelP;
 import org.apache.lucene.search.similarities.DFRSimilarity;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.search.similarities.Distribution;
 import org.apache.lucene.search.similarities.DistributionLL;
 import org.apache.lucene.search.similarities.DistributionSPL;
@@ -63,7 +63,7 @@ import org.apache.lucene.search.similarities.Similarity;
  * for the same field.
  */
 public class RandomSimilarityProvider extends PerFieldSimilarityWrapper {
-  final DefaultSimilarity defaultSim = new DefaultSimilarity();
+  final ClassicSimilarity defaultSim = new ClassicSimilarity();
   final List<Similarity> knownSims;
   Map<String,Similarity> previousMappings = new HashMap<>();
   final int perFieldSeed;
@@ -139,7 +139,7 @@ public class RandomSimilarityProvider extends PerFieldSimilarityWrapper {
   static List<Similarity> allSims;
   static {
     allSims = new ArrayList<>();
-    allSims.add(new DefaultSimilarity());
+    allSims.add(new ClassicSimilarity());
     allSims.add(new BM25Similarity());
     for (BasicModel basicModel : BASIC_MODELS) {
       for (AfterEffect afterEffect : AFTER_EFFECTS) {
diff --git a/lucene/test-framework/src/java/org/apache/lucene/util/TestRuleSetupAndRestoreClassEnv.java b/lucene/test-framework/src/java/org/apache/lucene/util/TestRuleSetupAndRestoreClassEnv.java
index 7b9a9bc..ef88a0e 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/util/TestRuleSetupAndRestoreClassEnv.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/util/TestRuleSetupAndRestoreClassEnv.java
@@ -38,7 +38,7 @@ import org.apache.lucene.codecs.mockrandom.MockRandomPostingsFormat;
 import org.apache.lucene.codecs.simpletext.SimpleTextCodec;
 import org.apache.lucene.index.RandomCodec;
 import org.apache.lucene.search.RandomSimilarityProvider;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.util.LuceneTestCase.SuppressCodecs;
 import org.junit.internal.AssumptionViolatedException;
@@ -207,7 +207,7 @@ final class TestRuleSetupAndRestoreClassEnv extends AbstractBeforeAfterRule {
     TimeZone randomTimeZone = randomTimeZone(random());
     timeZone = testTimeZone.equals("random") ? randomTimeZone : TimeZone.getTimeZone(testTimeZone);
     TimeZone.setDefault(timeZone);
-    similarity = random().nextBoolean() ? new DefaultSimilarity() : new RandomSimilarityProvider(random());
+    similarity = random().nextBoolean() ? new ClassicSimilarity() : new RandomSimilarityProvider(random());
 
     // Check codec restrictions once at class level.
     try {
diff --git a/solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase.java b/solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase.java
index 2ddcabe..4eddd97 100644
--- a/solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase.java
+++ b/solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase.java
@@ -152,7 +152,7 @@ public abstract class SolrQueryParserBase extends QueryBuilder {
     try {
       // TopLevelQuery is a Query followed by the end-of-input (EOF)
       Query res = TopLevelQuery(null);  // pass null so we can tell later if an explicit field was provided or not
-      return res!=null ? res : newBooleanQuery(false).build();
+      return res!=null ? res : newBooleanQuery().build();
     }
     catch (ParseException | TokenMgrError tme) {
       throw new SyntaxError("Cannot parse '" +query+ "': " + tme.getMessage(), tme);
@@ -488,30 +488,12 @@ public abstract class SolrQueryParserBase extends QueryBuilder {
    *
    * @return Resulting {@link org.apache.lucene.search.Query} object.
    */
-  protected Query getBooleanQuery(List<BooleanClause> clauses) throws SyntaxError {
-    return getBooleanQuery(clauses, false);
-  }
-
-  /**
-   * Factory method for generating query, given a set of clauses.
-   * By default creates a boolean query composed of clauses passed in.
-   *
-   * Can be overridden by extending classes, to modify query being
-   * returned.
-   *
-   * @param clauses List that contains {@link org.apache.lucene.search.BooleanClause} instances
-   *    to join.
-   * @param disableCoord true if coord scoring should be disabled.
-   *
-   * @return Resulting {@link org.apache.lucene.search.Query} object.
-   */
-  protected Query getBooleanQuery(List<BooleanClause> clauses, boolean disableCoord)
-    throws SyntaxError
+  protected Query getBooleanQuery(List<BooleanClause> clauses) throws SyntaxError
   {
     if (clauses.size()==0) {
       return null; // all clause words were filtered away by the analyzer.
     }
-    BooleanQuery.Builder query = newBooleanQuery(disableCoord);
+    BooleanQuery.Builder query = newBooleanQuery();
     for(final BooleanClause clause: clauses) {
       query.add(clause);
     }
diff --git a/solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.java b/solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.java
index 0d7851f..c678728 100644
--- a/solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.java
+++ b/solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.java
@@ -1010,8 +1010,8 @@ public class ExtendedDismaxQParser extends QParser {
     }
     
     @Override
-    protected Query getBooleanQuery(List<BooleanClause> clauses, boolean disableCoord) throws SyntaxError {
-      Query q = super.getBooleanQuery(clauses, disableCoord);
+    protected Query getBooleanQuery(List<BooleanClause> clauses) throws SyntaxError {
+      Query q = super.getBooleanQuery(clauses);
       if (q != null) {
         q = QueryUtils.makeQueryable(q);
       }
diff --git a/solr/core/src/java/org/apache/solr/search/similarities/DefaultSimilarityFactory.java b/solr/core/src/java/org/apache/solr/search/similarities/DefaultSimilarityFactory.java
index 1f1b911..4b3cc38 100644
--- a/solr/core/src/java/org/apache/solr/search/similarities/DefaultSimilarityFactory.java
+++ b/solr/core/src/java/org/apache/solr/search/similarities/DefaultSimilarityFactory.java
@@ -17,22 +17,22 @@ package org.apache.solr.search.similarities;
  * limitations under the License.
  */
 
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.search.similarities.TFIDFSimilarity; // javadoc
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.schema.SimilarityFactory;
 
 /**
- * Factory for {@link DefaultSimilarity}
+ * Factory for {@link ClassicSimilarity}
  * <p>
- * DefaultSimilarity is Lucene's default scoring implementation, based
+ * ClassicSimilarity is Lucene's original scoring implementation, based
  * upon the Vector Space Model.
  * <p>
  * Optional settings:
  * <ul>
  *   <li>discountOverlaps (bool): Sets
- *       {@link DefaultSimilarity#setDiscountOverlaps(boolean)}</li>
+ *       {@link ClassicSimilarity#setDiscountOverlaps(boolean)}</li>
  * </ul>
  * @see TFIDFSimilarity
  * @lucene.experimental
@@ -40,13 +40,13 @@ import org.apache.solr.schema.SimilarityFactory;
 public class DefaultSimilarityFactory extends SimilarityFactory {
 
   /** Init param name for specifying the value to use in 
-   * {@link DefaultSimilarity#setDiscountOverlaps(boolean)} 
+   * {@link ClassicSimilarity#setDiscountOverlaps(boolean)} 
    */
   public static final String DISCOUNT_OVERLAPS = "discountOverlaps";
 
   /** 
-   * Controls the value of {@link DefaultSimilarity#setDiscountOverlaps(boolean)} 
-   * on newly constructed instances of {@link DefaultSimilarity}
+   * Controls the value of {@link ClassicSimilarity#setDiscountOverlaps(boolean)} 
+   * on newly constructed instances of {@link ClassicSimilarity}
    */
   protected boolean discountOverlaps = true;
 
@@ -58,7 +58,7 @@ public class DefaultSimilarityFactory extends SimilarityFactory {
 
   @Override
   public Similarity getSimilarity() {
-    DefaultSimilarity sim = new DefaultSimilarity();
+    ClassicSimilarity sim = new ClassicSimilarity();
     sim.setDiscountOverlaps(discountOverlaps);
     return sim;
   }
diff --git a/solr/core/src/java/org/apache/solr/search/similarities/SchemaSimilarityFactory.java b/solr/core/src/java/org/apache/solr/search/similarities/SchemaSimilarityFactory.java
index ea1f810..2e377a1 100644
--- a/solr/core/src/java/org/apache/solr/search/similarities/SchemaSimilarityFactory.java
+++ b/solr/core/src/java/org/apache/solr/search/similarities/SchemaSimilarityFactory.java
@@ -17,7 +17,7 @@ package org.apache.solr.search.similarities;
  * limitations under the License.
  */
 
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.search.similarities.PerFieldSimilarityWrapper;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.solr.common.params.SolrParams;
@@ -29,7 +29,7 @@ import org.apache.solr.util.plugin.SolrCoreAware;
 /**
  * SimilarityFactory that returns a {@link PerFieldSimilarityWrapper}
  * that delegates to the field type, if it's configured, otherwise
- * {@link DefaultSimilarity}.
+ * {@link ClassicSimilarity}.
  *
  * <p>
  * <b>NOTE:</b> Users should be aware that in addition to supporting 
@@ -45,7 +45,7 @@ import org.apache.solr.util.plugin.SolrCoreAware;
  */
 public class SchemaSimilarityFactory extends SimilarityFactory implements SolrCoreAware {
   private Similarity similarity;
-  private Similarity defaultSimilarity = new DefaultSimilarity();
+  private Similarity defaultSimilarity = new ClassicSimilarity();
   private volatile SolrCore core;
 
   @Override
diff --git a/solr/core/src/java/org/apache/solr/search/similarities/SweetSpotSimilarityFactory.java b/solr/core/src/java/org/apache/solr/search/similarities/SweetSpotSimilarityFactory.java
index 398eea1..42ac4e9 100644
--- a/solr/core/src/java/org/apache/solr/search/similarities/SweetSpotSimilarityFactory.java
+++ b/solr/core/src/java/org/apache/solr/search/similarities/SweetSpotSimilarityFactory.java
@@ -18,7 +18,7 @@ package org.apache.solr.search.similarities;
  */
 
 import org.apache.lucene.misc.SweetSpotSimilarity;
-import org.apache.lucene.search.similarities.DefaultSimilarity; // jdoc
+import org.apache.lucene.search.similarities.ClassicSimilarity; // jdoc
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.schema.SimilarityFactory;
@@ -28,7 +28,7 @@ import static org.apache.solr.common.SolrException.ErrorCode.*;
  * <p>Factory for {@link SweetSpotSimilarity}.</p>
  * <p>
  * <code>SweetSpotSimilarity</code> is an extension of 
- * {@link DefaultSimilarity} that provides additional tuning options for 
+ * {@link ClassicSimilarity} that provides additional tuning options for 
  * specifying the "sweetspot" of optimal <code>tf</code> and 
  * <code>lengthNorm</code> values in the source data.
  * </p>
diff --git a/solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery.java b/solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery.java
index b4d46f7..ba47835 100644
--- a/solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery.java
+++ b/solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery.java
@@ -27,7 +27,7 @@ import java.util.List;
 import java.util.Random;
 
 import org.apache.lucene.index.FieldInvertState;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.search.similarities.TFIDFSimilarity;
 import org.apache.solr.SolrTestCaseJ4;
 import org.junit.BeforeClass;
@@ -326,7 +326,7 @@ public class TestFunctionQuery extends SolrTestCaseJ4 {
     assertQ(req("fl","*,score","q", "{!func}docfreq($field,$value)", "fq","id:6", "field","a_t", "value","cow"), "//float[@name='score']='3.0'");
     assertQ(req("fl","*,score","q", "{!func}termfreq(a_t,cow)", "fq","id:6"), "//float[@name='score']='5.0'");
 
-    TFIDFSimilarity similarity = new DefaultSimilarity();
+    TFIDFSimilarity similarity = new ClassicSimilarity();
 
     // make sure it doesn't get a NPE if no terms are present in a field.
     assertQ(req("fl","*,score","q", "{!func}termfreq(nofield_t,cow)", "fq","id:6"), "//float[@name='score']='0.0'");
diff --git a/solr/core/src/test/org/apache/solr/search/similarities/MockConfigurableSimilarity.java b/solr/core/src/test/org/apache/solr/search/similarities/MockConfigurableSimilarity.java
index ac90657..d9d22eb 100644
--- a/solr/core/src/test/org/apache/solr/search/similarities/MockConfigurableSimilarity.java
+++ b/solr/core/src/test/org/apache/solr/search/similarities/MockConfigurableSimilarity.java
@@ -16,9 +16,9 @@
  */
 package org.apache.solr.search.similarities;
 
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 
-public class MockConfigurableSimilarity extends DefaultSimilarity {
+public class MockConfigurableSimilarity extends ClassicSimilarity {
   private String passthrough;
 
   public MockConfigurableSimilarity(String passthrough) {
diff --git a/solr/core/src/test/org/apache/solr/search/similarities/TestDefaultSimilarityFactory.java b/solr/core/src/test/org/apache/solr/search/similarities/TestDefaultSimilarityFactory.java
index cd09027..254cb3b 100644
--- a/solr/core/src/test/org/apache/solr/search/similarities/TestDefaultSimilarityFactory.java
+++ b/solr/core/src/test/org/apache/solr/search/similarities/TestDefaultSimilarityFactory.java
@@ -17,7 +17,7 @@ package org.apache.solr.search.similarities;
  * limitations under the License.
  */
 
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
 import org.junit.BeforeClass;
 
@@ -33,14 +33,14 @@ public class TestDefaultSimilarityFactory extends BaseSimilarityTestCase {
   /** default parameters */
   public void testDefaults() throws Exception {
     Similarity sim = getSimilarity("text");
-    assertEquals(DefaultSimilarity.class, sim.getClass());
-    assertEquals(true, ((DefaultSimilarity)sim).getDiscountOverlaps());
+    assertEquals(ClassicSimilarity.class, sim.getClass());
+    assertEquals(true, ((ClassicSimilarity)sim).getDiscountOverlaps());
   }
   /** explicit params */
   public void testParams() throws Exception {
     Similarity sim = getSimilarity("text_overlap");
-    assertEquals(DefaultSimilarity.class, sim.getClass());
-    assertEquals(false, ((DefaultSimilarity)sim).getDiscountOverlaps());
+    assertEquals(ClassicSimilarity.class, sim.getClass());
+    assertEquals(false, ((ClassicSimilarity)sim).getDiscountOverlaps());
   }
 
 }
diff --git a/solr/core/src/test/org/apache/solr/search/similarities/TestNonDefinedSimilarityFactory.java b/solr/core/src/test/org/apache/solr/search/similarities/TestNonDefinedSimilarityFactory.java
index 4dec59c..6e46fa7 100644
--- a/solr/core/src/test/org/apache/solr/search/similarities/TestNonDefinedSimilarityFactory.java
+++ b/solr/core/src/test/org/apache/solr/search/similarities/TestNonDefinedSimilarityFactory.java
@@ -17,7 +17,7 @@ package org.apache.solr.search.similarities;
  * limitations under the License.
  */
 
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.util.Version;
 import org.junit.After;
 
@@ -37,7 +37,7 @@ public class TestNonDefinedSimilarityFactory extends BaseSimilarityTestCase {
   public void testCurrent() throws Exception {
     // no sys prop set, rely on LATEST
     initCore("solrconfig-basic.xml","schema-tiny.xml");
-    DefaultSimilarity sim = getSimilarity("text", DefaultSimilarity.class);
+    ClassicSimilarity sim = getSimilarity("text", ClassicSimilarity.class);
     assertEquals(true, sim.getDiscountOverlaps());
   }
 }
diff --git a/solr/core/src/test/org/apache/solr/search/similarities/TestPerFieldSimilarity.java b/solr/core/src/test/org/apache/solr/search/similarities/TestPerFieldSimilarity.java
index b4edee5..ba20638 100644
--- a/solr/core/src/test/org/apache/solr/search/similarities/TestPerFieldSimilarity.java
+++ b/solr/core/src/test/org/apache/solr/search/similarities/TestPerFieldSimilarity.java
@@ -18,7 +18,7 @@ package org.apache.solr.search.similarities;
  */
 
 import org.apache.lucene.misc.SweetSpotSimilarity;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
 import org.junit.BeforeClass;
 
@@ -59,18 +59,18 @@ public class TestPerFieldSimilarity extends BaseSimilarityTestCase {
   /** test a field where no similarity is specified */
   public void testDefaults() throws Exception {
     Similarity sim = getSimilarity("sim3text");
-    assertEquals(DefaultSimilarity.class, sim.getClass());;
+    assertEquals(ClassicSimilarity.class, sim.getClass());;
   }
   
   /** ... and for a dynamic field */
   public void testDefaultsDynamic() throws Exception {
     Similarity sim = getSimilarity("text_sim3");
-    assertEquals(DefaultSimilarity.class, sim.getClass());
+    assertEquals(ClassicSimilarity.class, sim.getClass());
   }
   
   /** test a field that does not exist */
   public void testNonexistent() throws Exception {
     Similarity sim = getSimilarity("sdfdsfdsfdswr5fsdfdsfdsfs");
-    assertEquals(DefaultSimilarity.class, sim.getClass());
+    assertEquals(ClassicSimilarity.class, sim.getClass());
   }
 }
diff --git a/solr/core/src/test/org/apache/solr/search/similarities/TestSweetSpotSimilarityFactory.java b/solr/core/src/test/org/apache/solr/search/similarities/TestSweetSpotSimilarityFactory.java
index 00bfe4e..cd07d1a 100644
--- a/solr/core/src/test/org/apache/solr/search/similarities/TestSweetSpotSimilarityFactory.java
+++ b/solr/core/src/test/org/apache/solr/search/similarities/TestSweetSpotSimilarityFactory.java
@@ -18,7 +18,7 @@ package org.apache.solr.search.similarities;
  */
 
 import org.apache.lucene.misc.SweetSpotSimilarity;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
 import org.junit.BeforeClass;
 
@@ -36,7 +36,7 @@ public class TestSweetSpotSimilarityFactory extends BaseSimilarityTestCase {
     SweetSpotSimilarity sim = getSimilarity("text", SweetSpotSimilarity.class);
 
     // SSS tf w/defaults should behave just like DS
-    DefaultSimilarity d = new DefaultSimilarity();
+    ClassicSimilarity d = new ClassicSimilarity();
     for (int i = 0; i <=1000; i++) {
       assertEquals("tf: i="+i, d.tf(i), sim.tf(i), 0.0F);
     }
@@ -52,7 +52,7 @@ public class TestSweetSpotSimilarityFactory extends BaseSimilarityTestCase {
     SweetSpotSimilarity sim = getSimilarity("text_baseline", 
                                             SweetSpotSimilarity.class);
     
-    DefaultSimilarity d = new DefaultSimilarity();
+    ClassicSimilarity d = new ClassicSimilarity();
 
     // constant up to 6
     for (int i = 1; i <=6; i++) {
diff --git a/solr/core/src/test/org/apache/solr/update/DocumentBuilderTest.java b/solr/core/src/test/org/apache/solr/update/DocumentBuilderTest.java
index 0ef7c8b..f51930f 100644
--- a/solr/core/src/test/org/apache/solr/update/DocumentBuilderTest.java
+++ b/solr/core/src/test/org/apache/solr/update/DocumentBuilderTest.java
@@ -24,7 +24,7 @@ import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.index.LeafReader;
 import org.apache.lucene.index.NumericDocValues;
 import org.apache.lucene.index.SlowCompositeReaderWrapper;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.util.TestUtil;
 import org.apache.solr.SolrTestCaseJ4;
 import org.apache.solr.common.SolrDocument;
@@ -352,11 +352,11 @@ public class DocumentBuilderTest extends SolrTestCaseJ4 {
       SolrIndexSearcher searcher = req.getSearcher();
       LeafReader reader = SlowCompositeReaderWrapper.wrap(searcher.getTopReaderContext().reader());
 
-      assertTrue("similarity doesn't extend DefaultSimilarity, " + 
+      assertTrue("similarity doesn't extend ClassicSimilarity, " + 
                  "config or defaults have changed since test was written",
-                 searcher.getSimilarity(true) instanceof DefaultSimilarity);
+                 searcher.getSimilarity(true) instanceof ClassicSimilarity);
 
-      DefaultSimilarity sim = (DefaultSimilarity) searcher.getSimilarity(true);
+      ClassicSimilarity sim = (ClassicSimilarity) searcher.getSimilarity(true);
       
       NumericDocValues titleNorms = reader.getNormValues("title");
       NumericDocValues fooNorms = reader.getNormValues("foo_t");
@@ -380,7 +380,7 @@ public class DocumentBuilderTest extends SolrTestCaseJ4 {
   /**
    * Given a length, and boost returns the expected encoded norm 
    */
-  private static byte expectedNorm(final DefaultSimilarity sim,
+  private static byte expectedNorm(final ClassicSimilarity sim,
                                    final int length, final float boost) {
     return (byte) sim.encodeNormValue(boost / ((float) Math.sqrt(length)));
   }

