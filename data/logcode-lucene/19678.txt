GitDiffStart: 565a6d22b5f0f6be56bc1542796ac7c831f838e4 | Wed Aug 19 00:09:41 2009 +0000
diff --git a/contrib/CHANGES.txt b/contrib/CHANGES.txt
index c4e104c..c58b817 100644
--- a/contrib/CHANGES.txt
+++ b/contrib/CHANGES.txt
@@ -75,6 +75,9 @@ Bug fixes
     that the regexp must match the entire string, not just a prefix.
     (Trejkaz via Mike McCandless)
 
+10. LUCENE-1792: Fix new query parser to set rewrite method for
+    multi-term queries. (Luis Alves, Mike McCandless via Michael Busch)
+
 
 New features
 
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/QueryParserHelper.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/QueryParserHelper.java
index b7d05b0..626d8a5 100644
--- a/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/QueryParserHelper.java
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/QueryParserHelper.java
@@ -122,7 +122,7 @@ public class QueryParserHelper {
    * @param syntaxParser
    *          the text parser that will be used to parse the query string
    * 
-   * @see #getTextParser()
+   * @see #getSyntaxParser()
    * @see SyntaxParser
    */
   public void setSyntaxParser(SyntaxParser syntaxParser) {
@@ -193,7 +193,7 @@ public class QueryParserHelper {
    * @see SyntaxParser
    * @see #setSyntaxParser(SyntaxParser)
    */
-  public SyntaxParser getTextParser() {
+  public SyntaxParser getSyntaxParser() {
     return this.syntaxParser;
   }
 
@@ -225,7 +225,7 @@ public class QueryParserHelper {
    * In this method the three phases are executed: <br/>
    * <br/>
    * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1st - the query string is parsed using the
-   * text parser returned by {@link #getTextParser()}, the result is a query
+   * text parser returned by {@link #getSyntaxParser()}, the result is a query
    * node tree <br/>
    * <br/>
    * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2nd - the query node tree is processed by the
@@ -246,7 +246,7 @@ public class QueryParserHelper {
    */
   public Object parse(String query, String defaultField)
       throws QueryNodeException {
-    QueryNode queryTree = getTextParser().parse(query, defaultField);
+    QueryNode queryTree = getSyntaxParser().parse(query, defaultField);
 
     QueryNodeProcessor processor = getQueryNodeProcessor();
 
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/FieldQueryNode.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/FieldQueryNode.java
index 82b38b1..e5abe5c 100644
--- a/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/FieldQueryNode.java
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/FieldQueryNode.java
@@ -75,11 +75,11 @@ public class FieldQueryNode extends QueryNodeImpl implements TextableQueryNode,
 
   }
 
-  CharSequence getTermEscaped(EscapeQuerySyntax escaper) {
+  protected CharSequence getTermEscaped(EscapeQuerySyntax escaper) {
     return escaper.escape(this.text, Locale.getDefault(), Type.NORMAL);
   }
 
-  CharSequence getTermEscapeQuoted(EscapeQuerySyntax escaper) {
+  protected CharSequence getTermEscapeQuoted(EscapeQuerySyntax escaper) {
     return escaper.escape(this.text, Locale.getDefault(), Type.STRING);
   }
 
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/PrefixWildcardQueryNode.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/PrefixWildcardQueryNode.java
index d905e46..e69de29 100644
--- a/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/PrefixWildcardQueryNode.java
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/PrefixWildcardQueryNode.java
@@ -1,57 +0,0 @@
-package org.apache.lucene.queryParser.core.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * A {@link PrefixWildcardQueryNode} represents wildcardquery that matches abc*
- * or *. This does not apply to phrases, this is a special case on the original
- * lucene parser. TODO: refactor the code to remove this special case from the
- * parser. and probably do it on a Processor
- */
-public class PrefixWildcardQueryNode extends WildcardQueryNode {
-
-  private static final long serialVersionUID = 6851557641826407515L;
-
-  /**
-   * @param field
-   *          - field name
-   * @param text
-   *          - value including the wildcard
-   * @param begin
-   *          - position in the query string
-   * @param end
-   *          - position in the query string
-   */
-  public PrefixWildcardQueryNode(CharSequence field, CharSequence text,
-      int begin, int end) {
-    super(field, text, begin, end);
-  }
-
-  public String toString() {
-    return "<prefixWildcard field='" + this.field + "' term='" + this.text
-        + "'/>";
-  }
-
-  public PrefixWildcardQueryNode cloneTree() throws CloneNotSupportedException {
-    PrefixWildcardQueryNode clone = (PrefixWildcardQueryNode) super.cloneTree();
-
-    // nothing to do here
-
-    return clone;
-  }
-}
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/WildcardQueryNode.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/WildcardQueryNode.java
index 0a9ac36..e69de29 100644
--- a/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/WildcardQueryNode.java
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/WildcardQueryNode.java
@@ -1,76 +0,0 @@
-package org.apache.lucene.queryParser.core.nodes;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax;
-import org.apache.lucene.search.MultiTermQuery;
-
-/**
- * A {@link WildcardQueryNode} represents wildcard query This does not apply to
- * phrases. Examples: a*b*c Fl?w? m?ke*g
- */
-public class WildcardQueryNode extends FieldQueryNode {
-  private static final long serialVersionUID = 0L;
-  private MultiTermQuery.RewriteMethod multiTermRewriteMethod;
-
-  /**
-   * @param field
-   *          - field name
-   * @param text
-   *          - value that contains one or more wild card characters (? or *)
-   * @param begin
-   *          - position in the query string
-   * @param end
-   *          - position in the query string
-   */
-  public WildcardQueryNode(CharSequence field, CharSequence text, int begin,
-      int end) {
-    super(field, text, begin, end);
-  }
-
-  public CharSequence toQueryString(EscapeQuerySyntax escaper) {
-    if (isDefaultField(this.field)) {
-      return getTermEscaped(escaper);
-    } else {
-      return this.field + ":" + getTermEscaped(escaper);
-    }
-  }
-
-  public String toString() {
-    return "<wildcard field='" + this.field + "' term='" + this.text + "'/>";
-  }
-
-  public WildcardQueryNode cloneTree() throws CloneNotSupportedException {
-    WildcardQueryNode clone = (WildcardQueryNode) super.cloneTree();
-
-    // nothing to do here
-
-    return clone;
-  }
-
-  /**
-   * @return the rewrite method
-   */
-  public MultiTermQuery.RewriteMethod getMultiTermRewriteMethod() {
-    return multiTermRewriteMethod;
-  }
-
-  public void setMultiTermRewriteMethod(MultiTermQuery.RewriteMethod method) {
-    multiTermRewriteMethod = method;
-  }
-}
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/util/UnescapedCharSequence.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/util/UnescapedCharSequence.java
index c00904e..bbc74cd 100644
--- a/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/util/UnescapedCharSequence.java
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/util/UnescapedCharSequence.java
@@ -85,10 +85,6 @@ public final class UnescapedCharSequence implements CharSequence {
         newLength);
   }
 
-  public boolean wasEscaped(int index) {
-    return this.wasEscaped[index];
-  }
-
   public String toString() {
     return new String(this.chars);
   }
@@ -138,4 +134,23 @@ public final class UnescapedCharSequence implements CharSequence {
     }
     return result.toString();
   }
+
+  public boolean wasEscaped(int index) {
+    return this.wasEscaped[index];
+  }
+  
+  static final public boolean wasEscaped(CharSequence text, int index) {
+    if (text instanceof UnescapedCharSequence)
+      return ((UnescapedCharSequence)text).wasEscaped[index];
+    else return false;
+  }
+  
+  public static CharSequence toLowerCase(CharSequence text) {
+    if (text instanceof UnescapedCharSequence) {
+      char[] chars = text.toString().toLowerCase().toCharArray();
+      boolean[] wasEscaped = ((UnescapedCharSequence)text).wasEscaped;
+      return new UnescapedCharSequence(chars, wasEscaped, 0, chars.length);
+    } else 
+      return new UnescapedCharSequence(text.toString().toLowerCase());
+  }
 }
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/QueryParserWrapper.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/QueryParserWrapper.java
index b2bd053..dcdc6d0 100644
--- a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/QueryParserWrapper.java
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/QueryParserWrapper.java
@@ -38,15 +38,15 @@ import org.apache.lucene.queryParser.standard.builders.StandardQueryBuilder;
 import org.apache.lucene.queryParser.standard.builders.StandardQueryTreeBuilder;
 import org.apache.lucene.queryParser.standard.config.AllowLeadingWildcardAttribute;
 import org.apache.lucene.queryParser.standard.config.AnalyzerAttribute;
-import org.apache.lucene.queryParser.standard.config.MultiTermRewriteMethodAttribute;
 import org.apache.lucene.queryParser.standard.config.DateResolutionAttribute;
 import org.apache.lucene.queryParser.standard.config.DefaultOperatorAttribute;
 import org.apache.lucene.queryParser.standard.config.DefaultPhraseSlopAttribute;
 import org.apache.lucene.queryParser.standard.config.LocaleAttribute;
 import org.apache.lucene.queryParser.standard.config.LowercaseExpandedTermsAttribute;
-import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler;
+import org.apache.lucene.queryParser.standard.config.MultiTermRewriteMethodAttribute;
 import org.apache.lucene.queryParser.standard.config.PositionIncrementsAttribute;
 import org.apache.lucene.queryParser.standard.config.RangeCollatorAttribute;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler;
 import org.apache.lucene.queryParser.standard.parser.StandardSyntaxParser;
 import org.apache.lucene.queryParser.standard.processors.StandardQueryNodeProcessorPipeline;
 import org.apache.lucene.search.FuzzyQuery;
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/StandardQueryParser.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/StandardQueryParser.java
index 74f7738..3640548 100644
--- a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/StandardQueryParser.java
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/StandardQueryParser.java
@@ -31,18 +31,18 @@ import org.apache.lucene.queryParser.standard.builders.StandardQueryTreeBuilder;
 import org.apache.lucene.queryParser.standard.config.AllowLeadingWildcardAttribute;
 import org.apache.lucene.queryParser.standard.config.AnalyzerAttribute;
 import org.apache.lucene.queryParser.standard.config.DateResolutionAttribute;
-import org.apache.lucene.queryParser.standard.config.FieldDateResolutionMapAttribute;
 import org.apache.lucene.queryParser.standard.config.DefaultOperatorAttribute;
 import org.apache.lucene.queryParser.standard.config.DefaultPhraseSlopAttribute;
 import org.apache.lucene.queryParser.standard.config.FieldBoostMapAttribute;
+import org.apache.lucene.queryParser.standard.config.FieldDateResolutionMapAttribute;
 import org.apache.lucene.queryParser.standard.config.FuzzyAttribute;
 import org.apache.lucene.queryParser.standard.config.LocaleAttribute;
 import org.apache.lucene.queryParser.standard.config.LowercaseExpandedTermsAttribute;
 import org.apache.lucene.queryParser.standard.config.MultiFieldAttribute;
 import org.apache.lucene.queryParser.standard.config.MultiTermRewriteMethodAttribute;
-import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler;
 import org.apache.lucene.queryParser.standard.config.PositionIncrementsAttribute;
 import org.apache.lucene.queryParser.standard.config.RangeCollatorAttribute;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler;
 import org.apache.lucene.queryParser.standard.config.DefaultOperatorAttribute.Operator;
 import org.apache.lucene.queryParser.standard.nodes.RangeQueryNode;
 import org.apache.lucene.queryParser.standard.parser.StandardSyntaxParser;
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/PrefixWildcardQueryNodeBuilder.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/PrefixWildcardQueryNodeBuilder.java
index e68ad99..943e20c 100644
--- a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/PrefixWildcardQueryNodeBuilder.java
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/PrefixWildcardQueryNodeBuilder.java
@@ -19,8 +19,10 @@ package org.apache.lucene.queryParser.standard.builders;
 
 import org.apache.lucene.index.Term;
 import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.nodes.PrefixWildcardQueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
+import org.apache.lucene.queryParser.standard.config.MultiTermRewriteMethodAttribute;
+import org.apache.lucene.queryParser.standard.nodes.PrefixWildcardQueryNode;
+import org.apache.lucene.search.MultiTermQuery;
 import org.apache.lucene.search.PrefixQuery;
 
 /**
@@ -33,12 +35,18 @@ public class PrefixWildcardQueryNodeBuilder implements StandardQueryBuilder {
     // empty constructor
   }
 
-  public PrefixQuery build(QueryNode queryNode) throws QueryNodeException {
+  public PrefixQuery build(QueryNode queryNode) throws QueryNodeException {    
+
     PrefixWildcardQueryNode wildcardNode = (PrefixWildcardQueryNode) queryNode;
 
-    PrefixQuery q = new PrefixQuery(new Term(wildcardNode.getFieldAsString(),
-                                             wildcardNode.getTextAsString()));
-    q.setRewriteMethod(wildcardNode.getMultiTermRewriteMethod());
+    String text = wildcardNode.getText().subSequence(0, wildcardNode.getText().length() - 1).toString();
+    PrefixQuery q = new PrefixQuery(new Term(wildcardNode.getFieldAsString(), text));
+    
+    MultiTermQuery.RewriteMethod method = (MultiTermQuery.RewriteMethod)queryNode.getTag(MultiTermRewriteMethodAttribute.TAG_ID);
+    if (method != null) {
+      q.setRewriteMethod(method);
+    }
+    
     return q;
   }
 
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/RangeQueryNodeBuilder.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/RangeQueryNodeBuilder.java
index 0b48f63..1b90cb5 100644
--- a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/RangeQueryNodeBuilder.java
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/RangeQueryNodeBuilder.java
@@ -21,7 +21,9 @@ import org.apache.lucene.queryParser.core.QueryNodeException;
 import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
 import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode.CompareOperator;
+import org.apache.lucene.queryParser.standard.config.MultiTermRewriteMethodAttribute;
 import org.apache.lucene.queryParser.standard.nodes.RangeQueryNode;
+import org.apache.lucene.search.MultiTermQuery;
 import org.apache.lucene.search.TermRangeQuery;
 
 /**
@@ -54,7 +56,11 @@ public class RangeQueryNodeBuilder implements StandardQueryBuilder {
     TermRangeQuery rangeQuery = new TermRangeQuery(field, lower
         .getTextAsString(), upper.getTextAsString(), lowerInclusive,
         upperInclusive, rangeNode.getCollator());
-    rangeQuery.setRewriteMethod(rangeNode.getMultiTermRewriteMethod());
+    
+    MultiTermQuery.RewriteMethod method = (MultiTermQuery.RewriteMethod)queryNode.getTag(MultiTermRewriteMethodAttribute.TAG_ID);
+    if (method != null) {
+      rangeQuery.setRewriteMethod(method);
+    }
 
     return rangeQuery;
 
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/StandardQueryTreeBuilder.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/StandardQueryTreeBuilder.java
index bb9dbaa..ba1dfc4 100644
--- a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/StandardQueryTreeBuilder.java
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/StandardQueryTreeBuilder.java
@@ -27,14 +27,14 @@ import org.apache.lucene.queryParser.core.nodes.GroupQueryNode;
 import org.apache.lucene.queryParser.core.nodes.MatchAllDocsQueryNode;
 import org.apache.lucene.queryParser.core.nodes.MatchNoDocsQueryNode;
 import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode;
-import org.apache.lucene.queryParser.core.nodes.PrefixWildcardQueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
 import org.apache.lucene.queryParser.core.nodes.SlopQueryNode;
 import org.apache.lucene.queryParser.core.nodes.TokenizedPhraseQueryNode;
-import org.apache.lucene.queryParser.core.nodes.WildcardQueryNode;
-import org.apache.lucene.queryParser.standard.nodes.StandardBooleanQueryNode;
 import org.apache.lucene.queryParser.standard.nodes.MultiPhraseQueryNode;
+import org.apache.lucene.queryParser.standard.nodes.PrefixWildcardQueryNode;
 import org.apache.lucene.queryParser.standard.nodes.RangeQueryNode;
+import org.apache.lucene.queryParser.standard.nodes.StandardBooleanQueryNode;
+import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
 import org.apache.lucene.queryParser.standard.processors.StandardQueryNodeProcessorPipeline;
 import org.apache.lucene.search.Query;
 
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/WildcardQueryNodeBuilder.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/WildcardQueryNodeBuilder.java
index ca8c4b2..5ff59ea 100644
--- a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/WildcardQueryNodeBuilder.java
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/WildcardQueryNodeBuilder.java
@@ -20,7 +20,9 @@ package org.apache.lucene.queryParser.standard.builders;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.queryParser.core.QueryNodeException;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.WildcardQueryNode;
+import org.apache.lucene.queryParser.standard.config.MultiTermRewriteMethodAttribute;
+import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
+import org.apache.lucene.search.MultiTermQuery;
 import org.apache.lucene.search.WildcardQuery;
 
 /**
@@ -38,7 +40,12 @@ public class WildcardQueryNodeBuilder implements StandardQueryBuilder {
 
     WildcardQuery q = new WildcardQuery(new Term(wildcardNode.getFieldAsString(),
                                                  wildcardNode.getTextAsString()));
-    q.setRewriteMethod(wildcardNode.getMultiTermRewriteMethod());
+    
+    MultiTermQuery.RewriteMethod method = (MultiTermQuery.RewriteMethod)queryNode.getTag(MultiTermRewriteMethodAttribute.TAG_ID);
+    if (method != null) {
+      q.setRewriteMethod(method);
+    }
+    
     return q;
   }
 
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/MultiTermRewriteMethodAttribute.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/MultiTermRewriteMethodAttribute.java
index 7fc2d27..84924e3 100644
--- a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/MultiTermRewriteMethodAttribute.java
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/MultiTermRewriteMethodAttribute.java
@@ -31,6 +31,9 @@ import org.apache.lucene.util.Attribute;
  * 
  */
 public interface MultiTermRewriteMethodAttribute extends Attribute {
+  
+  public static final CharSequence TAG_ID = "MultiTermRewriteMethodAttribute";
+  
   public void setMultiTermRewriteMethod(MultiTermQuery.RewriteMethod method);
 
   public MultiTermQuery.RewriteMethod getMultiTermRewriteMethod();
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/MultiTermRewriteMethodAttributeImpl.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/MultiTermRewriteMethodAttributeImpl.java
index 1302e8d..cf79efd 100644
--- a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/MultiTermRewriteMethodAttributeImpl.java
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/MultiTermRewriteMethodAttributeImpl.java
@@ -35,7 +35,7 @@ public class MultiTermRewriteMethodAttributeImpl extends AttributeImpl
     implements MultiTermRewriteMethodAttribute {
 
   private static final long serialVersionUID = -2104763012723049527L;
-
+  
   private MultiTermQuery.RewriteMethod multiTermRewriteMethod = MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT;
 
   public MultiTermRewriteMethodAttributeImpl() {
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/StandardQueryConfigHandler.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/StandardQueryConfigHandler.java
index a2ad0bf..a219aa5 100644
--- a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/StandardQueryConfigHandler.java
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/StandardQueryConfigHandler.java
@@ -48,7 +48,7 @@ public class StandardQueryConfigHandler extends QueryConfigHandler {
     addAttribute(PositionIncrementsAttribute.class);
     addAttribute(LocaleAttribute.class);
     addAttribute(DefaultPhraseSlopAttribute.class);
-    //addAttribute(DateResolutionAttribute.class);
+    addAttribute(MultiTermRewriteMethodAttribute.class);   
     
   }
 
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/PrefixWildcardQueryNode.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/PrefixWildcardQueryNode.java
new file mode 100644
index 0000000..17ce946
--- /dev/null
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/PrefixWildcardQueryNode.java
@@ -0,0 +1,63 @@
+package org.apache.lucene.queryParser.standard.nodes;
+
+import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * A {@link PrefixWildcardQueryNode} represents wildcardquery that matches abc*
+ * or *. This does not apply to phrases, this is a special case on the original
+ * lucene parser. TODO: refactor the code to remove this special case from the
+ * parser. and probably do it on a Processor
+ */
+public class PrefixWildcardQueryNode extends WildcardQueryNode {
+
+  private static final long serialVersionUID = 6851557641826407515L;
+
+  /**
+   * @param field
+   *          - field name
+   * @param text
+   *          - value including the wildcard
+   * @param begin
+   *          - position in the query string
+   * @param end
+   *          - position in the query string
+   */
+  public PrefixWildcardQueryNode(CharSequence field, CharSequence text,
+      int begin, int end) {
+    super(field, text, begin, end);
+  }
+
+  public PrefixWildcardQueryNode(FieldQueryNode fqn) {
+    this(fqn.getField(), fqn.getText(), fqn.getBegin(), fqn.getEnd());
+  }
+
+  public String toString() {
+    return "<prefixWildcard field='" + this.field + "' term='" + this.text
+        + "'/>";
+  }
+
+  public PrefixWildcardQueryNode cloneTree() throws CloneNotSupportedException {
+    PrefixWildcardQueryNode clone = (PrefixWildcardQueryNode) super.cloneTree();
+
+    // nothing to do here
+
+    return clone;
+  }
+}
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/RangeQueryNode.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/RangeQueryNode.java
index 3b9ebfd..aa9a177 100644
--- a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/RangeQueryNode.java
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/RangeQueryNode.java
@@ -23,7 +23,6 @@ import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode;
 import org.apache.lucene.queryParser.core.nodes.ParametricRangeQueryNode;
 import org.apache.lucene.queryParser.standard.config.RangeCollatorAttribute;
 import org.apache.lucene.queryParser.standard.processors.ParametricRangeQueryNodeProcessor;
-import org.apache.lucene.search.MultiTermQuery;
 
 /**
  * This query node represents a range query. It also holds which collator will
@@ -39,17 +38,13 @@ public class RangeQueryNode extends ParametricRangeQueryNode {
 
   private Collator collator;
 
-  private MultiTermQuery.RewriteMethod multiTermRewriteMethod;
-
   /**
    * @param lower
    * @param upper
    */
-  public RangeQueryNode(ParametricQueryNode lower, ParametricQueryNode upper,
-      Collator collator, MultiTermQuery.RewriteMethod multiTermRewriteMethod) {
+  public RangeQueryNode(ParametricQueryNode lower, ParametricQueryNode upper, Collator collator) {
     super(lower, upper);
 
-    this.multiTermRewriteMethod = multiTermRewriteMethod;
     this.collator = collator;
 
   }
@@ -71,10 +66,4 @@ public class RangeQueryNode extends ParametricRangeQueryNode {
     return this.collator;
   }
 
-  /**
-   * @return the rewrite method
-   */
-  public MultiTermQuery.RewriteMethod getMultiTermRewriteMethod() {
-    return multiTermRewriteMethod;
-  }
 }
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/WildcardQueryNode.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/WildcardQueryNode.java
new file mode 100644
index 0000000..c73eb9b
--- /dev/null
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/nodes/WildcardQueryNode.java
@@ -0,0 +1,69 @@
+package org.apache.lucene.queryParser.standard.nodes;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
+import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax;
+
+/**
+ * A {@link WildcardQueryNode} represents wildcard query This does not apply to
+ * phrases. Examples: a*b*c Fl?w? m?ke*g
+ */
+public class WildcardQueryNode extends FieldQueryNode {
+  private static final long serialVersionUID = 0L;
+
+  /**
+   * @param field
+   *          - field name
+   * @param text
+   *          - value that contains one or more wild card characters (? or *)
+   * @param begin
+   *          - position in the query string
+   * @param end
+   *          - position in the query string
+   */
+  public WildcardQueryNode(CharSequence field, CharSequence text, int begin,
+      int end) {
+    super(field, text, begin, end);
+  }
+
+  public WildcardQueryNode(FieldQueryNode fqn) {
+    this(fqn.getField(), fqn.getText(), fqn.getBegin(), fqn.getEnd());
+  }
+
+  public CharSequence toQueryString(EscapeQuerySyntax escaper) {
+    if (isDefaultField(this.field)) {
+      return getTermEscaped(escaper);
+    } else {
+      return this.field + ":" + getTermEscaped(escaper);
+    }
+  }
+
+  public String toString() {
+    return "<wildcard field='" + this.field + "' term='" + this.text + "'/>";
+  }
+
+  public WildcardQueryNode cloneTree() throws CloneNotSupportedException {
+    WildcardQueryNode clone = (WildcardQueryNode) super.cloneTree();
+
+    // nothing to do here
+
+    return clone;
+  }
+
+}
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/JavaCharStream.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/JavaCharStream.java
index 178d2ab..c022d5a 100644
--- a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/JavaCharStream.java
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/JavaCharStream.java
@@ -614,4 +614,4 @@ class JavaCharStream
   }
 
 }
-/* JavaCC - StandardChecksum=065d79d49fcd02f542903038e37bd9d9 (do not edit this line) */
+/* JavaCC - OriginalChecksum=d665eff1df49d9f82f07f7dc863fcd22 (do not edit this line) */
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.java
index 0975d24..fd6640c 100644
--- a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.java
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.java
@@ -19,14 +19,10 @@ package org.apache.lucene.queryParser.standard.parser;
  */
 
 import java.io.StringReader;
-import java.util.ArrayList;
-import java.util.List;
 import java.util.Vector;
 
 import org.apache.lucene.messages.Message;
 import org.apache.lucene.messages.MessageImpl;
-import org.apache.lucene.queryParser.core.QueryNodeError;
-import org.apache.lucene.queryParser.core.QueryNodeException;
 import org.apache.lucene.queryParser.core.QueryNodeParseException;
 import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
 import org.apache.lucene.queryParser.core.nodes.AndQueryNode;
@@ -34,19 +30,14 @@ import org.apache.lucene.queryParser.core.nodes.BooleanQueryNode;
 import org.apache.lucene.queryParser.core.nodes.BoostQueryNode;
 import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
 import org.apache.lucene.queryParser.core.nodes.FuzzyQueryNode;
-import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode;
 import org.apache.lucene.queryParser.core.nodes.GroupQueryNode;
-import org.apache.lucene.queryParser.core.nodes.OpaqueQueryNode;
+import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode;
 import org.apache.lucene.queryParser.core.nodes.OrQueryNode;
 import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode;
 import org.apache.lucene.queryParser.core.nodes.ParametricRangeQueryNode;
-import org.apache.lucene.queryParser.core.nodes.PrefixWildcardQueryNode;
-import org.apache.lucene.queryParser.core.nodes.SlopQueryNode;
-import org.apache.lucene.queryParser.core.nodes.ProximityQueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNodeImpl;
 import org.apache.lucene.queryParser.core.nodes.QuotedFieldQueryNode;
-import org.apache.lucene.queryParser.core.nodes.WildcardQueryNode;
+import org.apache.lucene.queryParser.core.nodes.SlopQueryNode;
 import org.apache.lucene.queryParser.core.parser.SyntaxParser;
 
 @SuppressWarnings("all")
@@ -178,11 +169,8 @@ public class StandardSyntaxParser implements SyntaxParser, StandardSyntaxParserC
       case PLUS:
       case MINUS:
       case LPAREN:
-      case STAR:
       case QUOTED:
       case TERM:
-      case PREFIXTERM:
-      case WILDTERM:
       case RANGEIN_START:
       case RANGEEX_START:
       case NUMBER:
@@ -322,31 +310,15 @@ public class StandardSyntaxParser implements SyntaxParser, StandardSyntaxParserC
   Token fieldToken=null, boost=null;
   boolean group = false;
     if (jj_2_1(2)) {
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case TERM:
-        fieldToken = jj_consume_token(TERM);
-        jj_consume_token(COLON);
+      fieldToken = jj_consume_token(TERM);
+      jj_consume_token(COLON);
                                field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);
-        break;
-      case STAR:
-        jj_consume_token(STAR);
-        jj_consume_token(COLON);
-                      field="*";
-        break;
-      default:
-        jj_la1[7] = jj_gen;
-        jj_consume_token(-1);
-        throw new ParseException();
-      }
     } else {
       ;
     }
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case STAR:
     case QUOTED:
     case TERM:
-    case PREFIXTERM:
-    case WILDTERM:
     case RANGEIN_START:
     case RANGEEX_START:
     case NUMBER:
@@ -362,13 +334,13 @@ public class StandardSyntaxParser implements SyntaxParser, StandardSyntaxParserC
         boost = jj_consume_token(NUMBER);
         break;
       default:
-        jj_la1[8] = jj_gen;
+        jj_la1[7] = jj_gen;
         ;
       }
                                                                  group=true;
       break;
     default:
-      jj_la1[9] = jj_gen;
+      jj_la1[8] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -393,40 +365,23 @@ public class StandardSyntaxParser implements SyntaxParser, StandardSyntaxParserC
 
   final public QueryNode Term(CharSequence field) throws ParseException {
   Token term, boost=null, fuzzySlop=null, goop1, goop2;
-  boolean prefix = false;
-  boolean wildcard = false;
   boolean fuzzy = false;
   QueryNode q =null;
   ParametricQueryNode qLower, qUpper;
   float defaultMinSimilarity = 0.5f;
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case STAR:
     case TERM:
-    case PREFIXTERM:
-    case WILDTERM:
     case NUMBER:
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case TERM:
         term = jj_consume_token(TERM);
                          q = new FieldQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);
         break;
-      case STAR:
-        term = jj_consume_token(STAR);
-                           wildcard=true; q = new WildcardQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);
-        break;
-      case PREFIXTERM:
-        term = jj_consume_token(PREFIXTERM);
-                                 prefix=true; q = new PrefixWildcardQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);
-        break;
-      case WILDTERM:
-        term = jj_consume_token(WILDTERM);
-                               wildcard=true; q = new WildcardQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);
-        break;
       case NUMBER:
         term = jj_consume_token(NUMBER);
         break;
       default:
-        jj_la1[10] = jj_gen;
+        jj_la1[9] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
@@ -436,7 +391,7 @@ public class StandardSyntaxParser implements SyntaxParser, StandardSyntaxParserC
                                 fuzzy=true;
         break;
       default:
-        jj_la1[11] = jj_gen;
+        jj_la1[10] = jj_gen;
         ;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
@@ -449,15 +404,15 @@ public class StandardSyntaxParser implements SyntaxParser, StandardSyntaxParserC
                                                          fuzzy=true;
           break;
         default:
-          jj_la1[12] = jj_gen;
+          jj_la1[11] = jj_gen;
           ;
         }
         break;
       default:
-        jj_la1[13] = jj_gen;
+        jj_la1[12] = jj_gen;
         ;
       }
-       if (!wildcard && !prefix && fuzzy) {
+       if (fuzzy) {
           float fms = defaultMinSimilarity;
           try {
             fms = Float.valueOf(fuzzySlop.image.substring(1)).floatValue();
@@ -478,7 +433,7 @@ public class StandardSyntaxParser implements SyntaxParser, StandardSyntaxParserC
         goop1 = jj_consume_token(RANGEIN_QUOTED);
         break;
       default:
-        jj_la1[14] = jj_gen;
+        jj_la1[13] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
@@ -487,7 +442,7 @@ public class StandardSyntaxParser implements SyntaxParser, StandardSyntaxParserC
         jj_consume_token(RANGEIN_TO);
         break;
       default:
-        jj_la1[15] = jj_gen;
+        jj_la1[14] = jj_gen;
         ;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
@@ -498,7 +453,7 @@ public class StandardSyntaxParser implements SyntaxParser, StandardSyntaxParserC
         goop2 = jj_consume_token(RANGEIN_QUOTED);
         break;
       default:
-        jj_la1[16] = jj_gen;
+        jj_la1[15] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
@@ -509,7 +464,7 @@ public class StandardSyntaxParser implements SyntaxParser, StandardSyntaxParserC
         boost = jj_consume_token(NUMBER);
         break;
       default:
-        jj_la1[17] = jj_gen;
+        jj_la1[16] = jj_gen;
         ;
       }
           if (goop1.kind == RANGEIN_QUOTED) {
@@ -535,7 +490,7 @@ public class StandardSyntaxParser implements SyntaxParser, StandardSyntaxParserC
         goop1 = jj_consume_token(RANGEEX_QUOTED);
         break;
       default:
-        jj_la1[18] = jj_gen;
+        jj_la1[17] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
@@ -544,7 +499,7 @@ public class StandardSyntaxParser implements SyntaxParser, StandardSyntaxParserC
         jj_consume_token(RANGEEX_TO);
         break;
       default:
-        jj_la1[19] = jj_gen;
+        jj_la1[18] = jj_gen;
         ;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
@@ -555,7 +510,7 @@ public class StandardSyntaxParser implements SyntaxParser, StandardSyntaxParserC
         goop2 = jj_consume_token(RANGEEX_QUOTED);
         break;
       default:
-        jj_la1[20] = jj_gen;
+        jj_la1[19] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
@@ -566,7 +521,7 @@ public class StandardSyntaxParser implements SyntaxParser, StandardSyntaxParserC
         boost = jj_consume_token(NUMBER);
         break;
       default:
-        jj_la1[21] = jj_gen;
+        jj_la1[20] = jj_gen;
         ;
       }
           if (goop1.kind == RANGEEX_QUOTED) {
@@ -589,7 +544,7 @@ public class StandardSyntaxParser implements SyntaxParser, StandardSyntaxParserC
         fuzzySlop = jj_consume_token(FUZZY_SLOP);
         break;
       default:
-        jj_la1[22] = jj_gen;
+        jj_la1[21] = jj_gen;
         ;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
@@ -598,7 +553,7 @@ public class StandardSyntaxParser implements SyntaxParser, StandardSyntaxParserC
         boost = jj_consume_token(NUMBER);
         break;
       default:
-        jj_la1[23] = jj_gen;
+        jj_la1[22] = jj_gen;
         ;
       }
          int phraseSlop = 0;
@@ -616,7 +571,7 @@ public class StandardSyntaxParser implements SyntaxParser, StandardSyntaxParserC
          }
       break;
     default:
-      jj_la1[24] = jj_gen;
+      jj_la1[23] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -645,28 +600,12 @@ public class StandardSyntaxParser implements SyntaxParser, StandardSyntaxParserC
     finally { jj_save(0, xla); }
   }
 
-  private boolean jj_3R_5() {
-    if (jj_scan_token(STAR)) return true;
-    if (jj_scan_token(COLON)) return true;
-    return false;
-  }
-
-  private boolean jj_3R_4() {
+  private boolean jj_3_1() {
     if (jj_scan_token(TERM)) return true;
     if (jj_scan_token(COLON)) return true;
     return false;
   }
 
-  private boolean jj_3_1() {
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_3R_4()) {
-    jj_scanpos = xsp;
-    if (jj_3R_5()) return true;
-    }
-    return false;
-  }
-
   /** Generated Token Manager. */
   public StandardSyntaxParserTokenManager token_source;
   JavaCharStream jj_input_stream;
@@ -678,18 +617,13 @@ public class StandardSyntaxParser implements SyntaxParser, StandardSyntaxParserC
   private Token jj_scanpos, jj_lastpos;
   private int jj_la;
   private int jj_gen;
-  final private int[] jj_la1 = new int[25];
+  final private int[] jj_la1 = new int[24];
   static private int[] jj_la1_0;
-  static private int[] jj_la1_1;
   static {
       jj_la1_init_0();
-      jj_la1_init_1();
    }
    private static void jj_la1_init_0() {
-      jj_la1_0 = new int[] {0x300,0x300,0x1c00,0x1c00,0x3ed3c00,0x200,0x100,0x90000,0x20000,0x3ed2000,0x2690000,0x100000,0x100000,0x20000,0x30000000,0x4000000,0x30000000,0x20000,0x0,0x40000000,0x0,0x20000,0x100000,0x20000,0x3ed0000,};
-   }
-   private static void jj_la1_init_1() {
-      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x3,0x0,0x0,0x0,0x0,};
+      jj_la1_0 = new int[] {0x300,0x300,0x1c00,0x1c00,0x763c00,0x200,0x100,0x10000,0x762000,0x440000,0x80000,0x80000,0x10000,0x6000000,0x800000,0x6000000,0x10000,0x60000000,0x8000000,0x60000000,0x10000,0x80000,0x10000,0x760000,};
    }
   final private JJCalls[] jj_2_rtns = new JJCalls[1];
   private boolean jj_rescan = false;
@@ -706,7 +640,7 @@ public class StandardSyntaxParser implements SyntaxParser, StandardSyntaxParserC
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
-    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
@@ -721,7 +655,7 @@ public class StandardSyntaxParser implements SyntaxParser, StandardSyntaxParserC
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
-    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
@@ -732,7 +666,7 @@ public class StandardSyntaxParser implements SyntaxParser, StandardSyntaxParserC
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
-    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
@@ -743,7 +677,7 @@ public class StandardSyntaxParser implements SyntaxParser, StandardSyntaxParserC
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
-    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
@@ -753,7 +687,7 @@ public class StandardSyntaxParser implements SyntaxParser, StandardSyntaxParserC
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
-    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
@@ -763,7 +697,7 @@ public class StandardSyntaxParser implements SyntaxParser, StandardSyntaxParserC
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
-    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
@@ -875,24 +809,21 @@ public class StandardSyntaxParser implements SyntaxParser, StandardSyntaxParserC
   /** Generate ParseException. */
   public ParseException generateParseException() {
     jj_expentries.clear();
-    boolean[] la1tokens = new boolean[34];
+    boolean[] la1tokens = new boolean[31];
     if (jj_kind >= 0) {
       la1tokens[jj_kind] = true;
       jj_kind = -1;
     }
-    for (int i = 0; i < 25; i++) {
+    for (int i = 0; i < 24; i++) {
       if (jj_la1[i] == jj_gen) {
         for (int j = 0; j < 32; j++) {
           if ((jj_la1_0[i] & (1<<j)) != 0) {
             la1tokens[j] = true;
           }
-          if ((jj_la1_1[i] & (1<<j)) != 0) {
-            la1tokens[32+j] = true;
-          }
         }
       }
     }
-    for (int i = 0; i < 34; i++) {
+    for (int i = 0; i < 31; i++) {
       if (la1tokens[i]) {
         jj_expentry = new int[1];
         jj_expentry[0] = i;
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.jj b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.jj
index 797ed48..47129fa 100644
--- a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.jj
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.jj
@@ -52,13 +52,11 @@ import org.apache.lucene.queryParser.core.nodes.OpaqueQueryNode;
 import org.apache.lucene.queryParser.core.nodes.OrQueryNode;
 import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode;
 import org.apache.lucene.queryParser.core.nodes.ParametricRangeQueryNode;
-import org.apache.lucene.queryParser.core.nodes.PrefixWildcardQueryNode;
 import org.apache.lucene.queryParser.core.nodes.SlopQueryNode;
 import org.apache.lucene.queryParser.core.nodes.ProximityQueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNodeImpl;
 import org.apache.lucene.queryParser.core.nodes.QuotedFieldQueryNode;
-import org.apache.lucene.queryParser.core.nodes.WildcardQueryNode;
 import org.apache.lucene.queryParser.core.parser.SyntaxParser;
 
 @SuppressWarnings("all")
@@ -110,7 +108,7 @@ PARSER_END(StandardSyntaxParser)
 // every character that follows a backslash is considered as an escaped character
 | <#_ESCAPED_CHAR: "\\" ~[] >
 | <#_TERM_START_CHAR: ( ~[ " ", "\t", "\n", "\r", "\u3000", "+", "-", "!", "(", ")", ":", "^",
-                           "[", "]", "\"", "{", "}", "~", "*", "?", "\\" ]
+                           "[", "]", "\"", "{", "}", "~", "\\" ]
                        | <_ESCAPED_CHAR> ) >
 | <#_TERM_CHAR: ( <_TERM_START_CHAR> | <_ESCAPED_CHAR> | "-" | "+" ) >
 | <#_WHITESPACE: ( " " | "\t" | "\n" | "\r" | "\u3000") >
@@ -130,13 +128,10 @@ PARSER_END(StandardSyntaxParser)
 | <LPAREN:    "(" >
 | <RPAREN:    ")" >
 | <COLON:     ":" >
-| <STAR:      "*" >
 | <CARAT:     "^" > : Boost
 | <QUOTED:     "\"" (<_QUOTED_CHAR>)* "\"">
 | <TERM:      <_TERM_START_CHAR> (<_TERM_CHAR>)*  >
 | <FUZZY_SLOP:     "~" ( (<_NUM_CHAR>)+ ( "." (<_NUM_CHAR>)+ )? )? >
-| <PREFIXTERM:  ("*") | ( <_TERM_START_CHAR> (<_TERM_CHAR>)* "*" ) >
-| <WILDTERM:  (<_TERM_START_CHAR> | [ "*", "?" ]) (<_TERM_CHAR> | ( [ "*", "?" ] ))* >
 | <RANGEIN_START: "[" > : RangeIn
 | <RANGEEX_START: "{" > : RangeEx
 }
@@ -346,8 +341,7 @@ QueryNode Clause(CharSequence field) : {
   [
     LOOKAHEAD(2)
     (
-    fieldToken=<TERM> <COLON> {field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);}
-    | <STAR> <COLON> {field="*";}
+    fieldToken=<TERM> <COLON> {field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);}    
     )
   ]
 
@@ -379,8 +373,6 @@ QueryNode Clause(CharSequence field) : {
 
 QueryNode Term(CharSequence field) : {
   Token term, boost=null, fuzzySlop=null, goop1, goop2;
-  boolean prefix = false;
-  boolean wildcard = false;
   boolean fuzzy = false;
   QueryNode q =null; 
   ParametricQueryNode qLower, qUpper;
@@ -390,15 +382,12 @@ QueryNode Term(CharSequence field) : {
   (
      (
  	   term=<TERM> { q = new FieldQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn); }
-	   | term=<STAR> { wildcard=true; q = new WildcardQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn); }
-	   | term=<PREFIXTERM> { prefix=true; q = new PrefixWildcardQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn); }
-	   | term=<WILDTERM> { wildcard=true; q = new WildcardQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn); }
        | term=<NUMBER>
      )
      [ fuzzySlop=<FUZZY_SLOP> { fuzzy=true; } ]
      [ <CARAT> boost=<NUMBER> [ fuzzySlop=<FUZZY_SLOP> { fuzzy=true; } ] ]
      {
-       if (!wildcard && !prefix && fuzzy) {
+       if (fuzzy) {
        	  float fms = defaultMinSimilarity;
        	  try {
             fms = Float.valueOf(fuzzySlop.image.substring(1)).floatValue();
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParserConstants.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParserConstants.java
index 1474adf..147a2d8 100644
--- a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParserConstants.java
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParserConstants.java
@@ -39,41 +39,35 @@ public interface StandardSyntaxParserConstants {
   /** RegularExpression Id. */
   int COLON = 15;
   /** RegularExpression Id. */
-  int STAR = 16;
+  int CARAT = 16;
   /** RegularExpression Id. */
-  int CARAT = 17;
+  int QUOTED = 17;
   /** RegularExpression Id. */
-  int QUOTED = 18;
+  int TERM = 18;
   /** RegularExpression Id. */
-  int TERM = 19;
+  int FUZZY_SLOP = 19;
   /** RegularExpression Id. */
-  int FUZZY_SLOP = 20;
+  int RANGEIN_START = 20;
   /** RegularExpression Id. */
-  int PREFIXTERM = 21;
+  int RANGEEX_START = 21;
   /** RegularExpression Id. */
-  int WILDTERM = 22;
+  int NUMBER = 22;
   /** RegularExpression Id. */
-  int RANGEIN_START = 23;
+  int RANGEIN_TO = 23;
   /** RegularExpression Id. */
-  int RANGEEX_START = 24;
+  int RANGEIN_END = 24;
   /** RegularExpression Id. */
-  int NUMBER = 25;
+  int RANGEIN_QUOTED = 25;
   /** RegularExpression Id. */
-  int RANGEIN_TO = 26;
+  int RANGEIN_GOOP = 26;
   /** RegularExpression Id. */
-  int RANGEIN_END = 27;
+  int RANGEEX_TO = 27;
   /** RegularExpression Id. */
-  int RANGEIN_QUOTED = 28;
+  int RANGEEX_END = 28;
   /** RegularExpression Id. */
-  int RANGEIN_GOOP = 29;
+  int RANGEEX_QUOTED = 29;
   /** RegularExpression Id. */
-  int RANGEEX_TO = 30;
-  /** RegularExpression Id. */
-  int RANGEEX_END = 31;
-  /** RegularExpression Id. */
-  int RANGEEX_QUOTED = 32;
-  /** RegularExpression Id. */
-  int RANGEEX_GOOP = 33;
+  int RANGEEX_GOOP = 30;
 
   /** Lexical state. */
   int Boost = 0;
@@ -102,13 +96,10 @@ public interface StandardSyntaxParserConstants {
     "\"(\"",
     "\")\"",
     "\":\"",
-    "\"*\"",
     "\"^\"",
     "<QUOTED>",
     "<TERM>",
     "<FUZZY_SLOP>",
-    "<PREFIXTERM>",
-    "<WILDTERM>",
     "\"[\"",
     "\"{\"",
     "<NUMBER>",
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParserTokenManager.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParserTokenManager.java
index 931e2c8..56623fb 100644
--- a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParserTokenManager.java
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParserTokenManager.java
@@ -17,35 +17,6 @@ package org.apache.lucene.queryParser.standard.parser;
  * limitations under the License.
  */
 
-import java.io.StringReader;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Vector;
-import org.apache.lucene.messages.Message;
-import org.apache.lucene.messages.MessageImpl;
-import org.apache.lucene.queryParser.core.QueryNodeError;
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.QueryNodeParseException;
-import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
-import org.apache.lucene.queryParser.core.nodes.AndQueryNode;
-import org.apache.lucene.queryParser.core.nodes.BooleanQueryNode;
-import org.apache.lucene.queryParser.core.nodes.BoostQueryNode;
-import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
-import org.apache.lucene.queryParser.core.nodes.FuzzyQueryNode;
-import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode;
-import org.apache.lucene.queryParser.core.nodes.GroupQueryNode;
-import org.apache.lucene.queryParser.core.nodes.OpaqueQueryNode;
-import org.apache.lucene.queryParser.core.nodes.OrQueryNode;
-import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode;
-import org.apache.lucene.queryParser.core.nodes.ParametricRangeQueryNode;
-import org.apache.lucene.queryParser.core.nodes.PrefixWildcardQueryNode;
-import org.apache.lucene.queryParser.core.nodes.SlopQueryNode;
-import org.apache.lucene.queryParser.core.nodes.ProximityQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNodeImpl;
-import org.apache.lucene.queryParser.core.nodes.QuotedFieldQueryNode;
-import org.apache.lucene.queryParser.core.nodes.WildcardQueryNode;
-import org.apache.lucene.queryParser.core.parser.SyntaxParser;
 
 /** Token Manager. */
 public class StandardSyntaxParserTokenManager implements StandardSyntaxParserConstants
@@ -81,8 +52,6 @@ private int jjMoveStringLiteralDfa0_3()
          return jjStopAtPos(0, 13);
       case 41:
          return jjStopAtPos(0, 14);
-      case 42:
-         return jjStartNfaWithStates_3(0, 16, 36);
       case 43:
          return jjStopAtPos(0, 11);
       case 45:
@@ -90,23 +59,15 @@ private int jjMoveStringLiteralDfa0_3()
       case 58:
          return jjStopAtPos(0, 15);
       case 91:
-         return jjStopAtPos(0, 23);
+         return jjStopAtPos(0, 20);
       case 94:
-         return jjStopAtPos(0, 17);
+         return jjStopAtPos(0, 16);
       case 123:
-         return jjStopAtPos(0, 24);
+         return jjStopAtPos(0, 21);
       default :
          return jjMoveNfa_3(0, 0);
    }
 }
-private int jjStartNfaWithStates_3(int pos, int kind, int state)
-{
-   jjmatchedKind = kind;
-   jjmatchedPos = pos;
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) { return pos + 1; }
-   return jjMoveNfa_3(state, pos + 1);
-}
 static final long[] jjbitVec0 = {
    0x1L, 0x0L, 0x0L, 0x0L
 };
@@ -122,7 +83,7 @@ static final long[] jjbitVec4 = {
 private int jjMoveNfa_3(int startState, int curPos)
 {
    int startsAt = 0;
-   jjnewStateCnt = 36;
+   jjnewStateCnt = 28;
    int i = 1;
    jjstateSet[0] = startState;
    int kind = 0x7fffffff;
@@ -137,20 +98,12 @@ private int jjMoveNfa_3(int startState, int curPos)
          {
             switch(jjstateSet[--i])
             {
-               case 36:
-               case 25:
-                  if ((0xfbfffcf8ffffd9ffL & l) == 0L)
-                     break;
-                  if (kind > 22)
-                     kind = 22;
-                  jjCheckNAddTwoStates(25, 26);
-                  break;
                case 0:
                   if ((0xfbffd4f8ffffd9ffL & l) != 0L)
                   {
-                     if (kind > 22)
-                        kind = 22;
-                     jjCheckNAddTwoStates(25, 26);
+                     if (kind > 18)
+                        kind = 18;
+                     jjCheckNAddTwoStates(20, 21);
                   }
                   else if ((0x100002600L & l) != 0L)
                   {
@@ -164,17 +117,6 @@ private int jjMoveNfa_3(int startState, int curPos)
                      if (kind > 10)
                         kind = 10;
                   }
-                  if ((0x7bffd0f8ffffd9ffL & l) != 0L)
-                  {
-                     if (kind > 19)
-                        kind = 19;
-                     jjCheckNAddStates(3, 7);
-                  }
-                  else if (curChar == 42)
-                  {
-                     if (kind > 21)
-                        kind = 21;
-                  }
                   if (curChar == 38)
                      jjstateSet[jjnewStateCnt++] = 4;
                   break;
@@ -202,68 +144,45 @@ private int jjMoveNfa_3(int startState, int curPos)
                   jjCheckNAddStates(0, 2);
                   break;
                case 18:
-                  if (curChar == 34 && kind > 18)
+                  if (curChar == 34 && kind > 17)
+                     kind = 17;
+                  break;
+               case 19:
+                  if ((0xfbffd4f8ffffd9ffL & l) == 0L)
+                     break;
+                  if (kind > 18)
                      kind = 18;
+                  jjCheckNAddTwoStates(20, 21);
                   break;
                case 20:
-                  if ((0x3ff000000000000L & l) == 0L)
+                  if ((0xfbfffcf8ffffd9ffL & l) == 0L)
                      break;
-                  if (kind > 20)
-                     kind = 20;
-                  jjAddStates(8, 9);
-                  break;
-               case 21:
-                  if (curChar == 46)
-                     jjCheckNAdd(22);
+                  if (kind > 18)
+                     kind = 18;
+                  jjCheckNAddTwoStates(20, 21);
                   break;
                case 22:
-                  if ((0x3ff000000000000L & l) == 0L)
-                     break;
-                  if (kind > 20)
-                     kind = 20;
-                  jjCheckNAdd(22);
-                  break;
-               case 23:
-                  if (curChar == 42 && kind > 21)
-                     kind = 21;
-                  break;
-               case 24:
-                  if ((0xfbffd4f8ffffd9ffL & l) == 0L)
-                     break;
-                  if (kind > 22)
-                     kind = 22;
-                  jjCheckNAddTwoStates(25, 26);
-                  break;
-               case 27:
-                  if (kind > 22)
-                     kind = 22;
-                  jjCheckNAddTwoStates(25, 26);
+                  if (kind > 18)
+                     kind = 18;
+                  jjCheckNAddTwoStates(20, 21);
                   break;
-               case 28:
-                  if ((0x7bffd0f8ffffd9ffL & l) == 0L)
+               case 25:
+                  if ((0x3ff000000000000L & l) == 0L)
                      break;
                   if (kind > 19)
                      kind = 19;
-                  jjCheckNAddStates(3, 7);
+                  jjAddStates(3, 4);
                   break;
-               case 29:
-                  if ((0x7bfff8f8ffffd9ffL & l) == 0L)
-                     break;
-                  if (kind > 19)
-                     kind = 19;
-                  jjCheckNAddTwoStates(29, 30);
+               case 26:
+                  if (curChar == 46)
+                     jjCheckNAdd(27);
                   break;
-               case 31:
+               case 27:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
                   if (kind > 19)
                      kind = 19;
-                  jjCheckNAddTwoStates(29, 30);
-                  break;
-               case 32:
-                  if ((0x7bfff8f8ffffd9ffL & l) != 0L)
-                     jjCheckNAddStates(10, 12);
-                  break;
-               case 34:
-                  jjCheckNAddStates(10, 12);
+                  jjCheckNAdd(27);
                   break;
                default : break;
             }
@@ -276,37 +195,21 @@ private int jjMoveNfa_3(int startState, int curPos)
          {
             switch(jjstateSet[--i])
             {
-               case 36:
+               case 0:
                   if ((0x97ffffff87ffffffL & l) != 0L)
                   {
-                     if (kind > 22)
-                        kind = 22;
-                     jjCheckNAddTwoStates(25, 26);
+                     if (kind > 18)
+                        kind = 18;
+                     jjCheckNAddTwoStates(20, 21);
                   }
-                  else if (curChar == 92)
-                     jjCheckNAddTwoStates(27, 27);
-                  break;
-               case 0:
-                  if ((0x97ffffff87ffffffL & l) != 0L)
+                  else if (curChar == 126)
                   {
                      if (kind > 19)
                         kind = 19;
-                     jjCheckNAddStates(3, 7);
+                     jjstateSet[jjnewStateCnt++] = 25;
                   }
                   else if (curChar == 92)
-                     jjCheckNAddStates(13, 15);
-                  else if (curChar == 126)
-                  {
-                     if (kind > 20)
-                        kind = 20;
-                     jjstateSet[jjnewStateCnt++] = 20;
-                  }
-                  if ((0x97ffffff87ffffffL & l) != 0L)
-                  {
-                     if (kind > 22)
-                        kind = 22;
-                     jjCheckNAddTwoStates(25, 26);
-                  }
+                     jjCheckNAdd(22);
                   if (curChar == 78)
                      jjstateSet[jjnewStateCnt++] = 11;
                   else if (curChar == 124)
@@ -368,72 +271,32 @@ private int jjMoveNfa_3(int startState, int curPos)
                   jjCheckNAddStates(0, 2);
                   break;
                case 19:
-                  if (curChar != 126)
-                     break;
-                  if (kind > 20)
-                     kind = 20;
-                  jjstateSet[jjnewStateCnt++] = 20;
-                  break;
-               case 24:
-                  if ((0x97ffffff87ffffffL & l) == 0L)
-                     break;
-                  if (kind > 22)
-                     kind = 22;
-                  jjCheckNAddTwoStates(25, 26);
-                  break;
-               case 25:
+               case 20:
                   if ((0x97ffffff87ffffffL & l) == 0L)
                      break;
-                  if (kind > 22)
-                     kind = 22;
-                  jjCheckNAddTwoStates(25, 26);
+                  if (kind > 18)
+                     kind = 18;
+                  jjCheckNAddTwoStates(20, 21);
                   break;
-               case 26:
+               case 21:
                   if (curChar == 92)
-                     jjCheckNAddTwoStates(27, 27);
+                     jjCheckNAddTwoStates(22, 22);
                   break;
-               case 27:
-                  if (kind > 22)
-                     kind = 22;
-                  jjCheckNAddTwoStates(25, 26);
-                  break;
-               case 28:
-                  if ((0x97ffffff87ffffffL & l) == 0L)
-                     break;
-                  if (kind > 19)
-                     kind = 19;
-                  jjCheckNAddStates(3, 7);
-                  break;
-               case 29:
-                  if ((0x97ffffff87ffffffL & l) == 0L)
-                     break;
-                  if (kind > 19)
-                     kind = 19;
-                  jjCheckNAddTwoStates(29, 30);
+               case 22:
+                  if (kind > 18)
+                     kind = 18;
+                  jjCheckNAddTwoStates(20, 21);
                   break;
-               case 30:
+               case 23:
                   if (curChar == 92)
-                     jjCheckNAddTwoStates(31, 31);
+                     jjCheckNAdd(22);
                   break;
-               case 31:
+               case 24:
+                  if (curChar != 126)
+                     break;
                   if (kind > 19)
                      kind = 19;
-                  jjCheckNAddTwoStates(29, 30);
-                  break;
-               case 32:
-                  if ((0x97ffffff87ffffffL & l) != 0L)
-                     jjCheckNAddStates(10, 12);
-                  break;
-               case 33:
-                  if (curChar == 92)
-                     jjCheckNAddTwoStates(34, 34);
-                  break;
-               case 34:
-                  jjCheckNAddStates(10, 12);
-                  break;
-               case 35:
-                  if (curChar == 92)
-                     jjCheckNAddStates(13, 15);
+                  jjstateSet[jjnewStateCnt++] = 25;
                   break;
                default : break;
             }
@@ -450,14 +313,6 @@ private int jjMoveNfa_3(int startState, int curPos)
          {
             switch(jjstateSet[--i])
             {
-               case 36:
-               case 25:
-                  if (!jjCanMove_2(hiByte, i1, i2, l1, l2))
-                     break;
-                  if (kind > 22)
-                     kind = 22;
-                  jjCheckNAddTwoStates(25, 26);
-                  break;
                case 0:
                   if (jjCanMove_0(hiByte, i1, i2, l1, l2))
                   {
@@ -466,15 +321,9 @@ private int jjMoveNfa_3(int startState, int curPos)
                   }
                   if (jjCanMove_2(hiByte, i1, i2, l1, l2))
                   {
-                     if (kind > 22)
-                        kind = 22;
-                     jjCheckNAddTwoStates(25, 26);
-                  }
-                  if (jjCanMove_2(hiByte, i1, i2, l1, l2))
-                  {
-                     if (kind > 19)
-                        kind = 19;
-                     jjCheckNAddStates(3, 7);
+                     if (kind > 18)
+                        kind = 18;
+                     jjCheckNAddTwoStates(20, 21);
                   }
                   break;
                case 15:
@@ -482,48 +331,20 @@ private int jjMoveNfa_3(int startState, int curPos)
                   if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                      jjCheckNAddStates(0, 2);
                   break;
-               case 24:
-                  if (!jjCanMove_2(hiByte, i1, i2, l1, l2))
-                     break;
-                  if (kind > 22)
-                     kind = 22;
-                  jjCheckNAddTwoStates(25, 26);
-                  break;
-               case 27:
-                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
-                     break;
-                  if (kind > 22)
-                     kind = 22;
-                  jjCheckNAddTwoStates(25, 26);
-                  break;
-               case 28:
-                  if (!jjCanMove_2(hiByte, i1, i2, l1, l2))
-                     break;
-                  if (kind > 19)
-                     kind = 19;
-                  jjCheckNAddStates(3, 7);
-                  break;
-               case 29:
+               case 19:
+               case 20:
                   if (!jjCanMove_2(hiByte, i1, i2, l1, l2))
                      break;
-                  if (kind > 19)
-                     kind = 19;
-                  jjCheckNAddTwoStates(29, 30);
+                  if (kind > 18)
+                     kind = 18;
+                  jjCheckNAddTwoStates(20, 21);
                   break;
-               case 31:
+               case 22:
                   if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
                      break;
-                  if (kind > 19)
-                     kind = 19;
-                  jjCheckNAddTwoStates(29, 30);
-                  break;
-               case 32:
-                  if (jjCanMove_2(hiByte, i1, i2, l1, l2))
-                     jjCheckNAddStates(10, 12);
-                  break;
-               case 34:
-                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
-                     jjCheckNAddStates(10, 12);
+                  if (kind > 18)
+                     kind = 18;
+                  jjCheckNAddTwoStates(20, 21);
                   break;
                default : break;
             }
@@ -536,7 +357,7 @@ private int jjMoveNfa_3(int startState, int curPos)
          kind = 0x7fffffff;
       }
       ++curPos;
-      if ((i = jjnewStateCnt) == (startsAt = 36 - (jjnewStateCnt = startsAt)))
+      if ((i = jjnewStateCnt) == (startsAt = 28 - (jjnewStateCnt = startsAt)))
          return curPos;
       try { curChar = input_stream.readChar(); }
       catch(java.io.IOException e) { return curPos; }
@@ -547,9 +368,9 @@ private final int jjStopStringLiteralDfa_1(int pos, long active0)
    switch (pos)
    {
       case 0:
-         if ((active0 & 0x40000000L) != 0L)
+         if ((active0 & 0x8000000L) != 0L)
          {
-            jjmatchedKind = 33;
+            jjmatchedKind = 30;
             return 6;
          }
          return -1;
@@ -566,9 +387,9 @@ private int jjMoveStringLiteralDfa0_1()
    switch(curChar)
    {
       case 84:
-         return jjMoveStringLiteralDfa1_1(0x40000000L);
+         return jjMoveStringLiteralDfa1_1(0x8000000L);
       case 125:
-         return jjStopAtPos(0, 31);
+         return jjStopAtPos(0, 28);
       default :
          return jjMoveNfa_1(0, 0);
    }
@@ -583,8 +404,8 @@ private int jjMoveStringLiteralDfa1_1(long active0)
    switch(curChar)
    {
       case 79:
-         if ((active0 & 0x40000000L) != 0L)
-            return jjStartNfaWithStates_1(1, 30, 6);
+         if ((active0 & 0x8000000L) != 0L)
+            return jjStartNfaWithStates_1(1, 27, 6);
          break;
       default :
          break;
@@ -620,8 +441,8 @@ private int jjMoveNfa_1(int startState, int curPos)
                case 0:
                   if ((0xfffffffeffffffffL & l) != 0L)
                   {
-                     if (kind > 33)
-                        kind = 33;
+                     if (kind > 30)
+                        kind = 30;
                      jjCheckNAdd(6);
                   }
                   if ((0x100002600L & l) != 0L)
@@ -638,21 +459,21 @@ private int jjMoveNfa_1(int startState, int curPos)
                   break;
                case 2:
                   if ((0xfffffffbffffffffL & l) != 0L)
-                     jjCheckNAddStates(16, 18);
+                     jjCheckNAddStates(5, 7);
                   break;
                case 3:
                   if (curChar == 34)
-                     jjCheckNAddStates(16, 18);
+                     jjCheckNAddStates(5, 7);
                   break;
                case 5:
-                  if (curChar == 34 && kind > 32)
-                     kind = 32;
+                  if (curChar == 34 && kind > 29)
+                     kind = 29;
                   break;
                case 6:
                   if ((0xfffffffeffffffffL & l) == 0L)
                      break;
-                  if (kind > 33)
-                     kind = 33;
+                  if (kind > 30)
+                     kind = 30;
                   jjCheckNAdd(6);
                   break;
                default : break;
@@ -670,12 +491,12 @@ private int jjMoveNfa_1(int startState, int curPos)
                case 6:
                   if ((0xdfffffffffffffffL & l) == 0L)
                      break;
-                  if (kind > 33)
-                     kind = 33;
+                  if (kind > 30)
+                     kind = 30;
                   jjCheckNAdd(6);
                   break;
                case 2:
-                  jjAddStates(16, 18);
+                  jjAddStates(5, 7);
                   break;
                case 4:
                   if (curChar == 92)
@@ -704,20 +525,20 @@ private int jjMoveNfa_1(int startState, int curPos)
                   }
                   if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                   {
-                     if (kind > 33)
-                        kind = 33;
+                     if (kind > 30)
+                        kind = 30;
                      jjCheckNAdd(6);
                   }
                   break;
                case 2:
                   if (jjCanMove_1(hiByte, i1, i2, l1, l2))
-                     jjAddStates(16, 18);
+                     jjAddStates(5, 7);
                   break;
                case 6:
                   if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
                      break;
-                  if (kind > 33)
-                     kind = 33;
+                  if (kind > 30)
+                     kind = 30;
                   jjCheckNAdd(6);
                   break;
                default : break;
@@ -762,9 +583,9 @@ private int jjMoveNfa_0(int startState, int curPos)
                case 0:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 25)
-                     kind = 25;
-                  jjAddStates(19, 20);
+                  if (kind > 22)
+                     kind = 22;
+                  jjAddStates(8, 9);
                   break;
                case 1:
                   if (curChar == 46)
@@ -773,8 +594,8 @@ private int jjMoveNfa_0(int startState, int curPos)
                case 2:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 25)
-                     kind = 25;
+                  if (kind > 22)
+                     kind = 22;
                   jjCheckNAdd(2);
                   break;
                default : break;
@@ -825,9 +646,9 @@ private final int jjStopStringLiteralDfa_2(int pos, long active0)
    switch (pos)
    {
       case 0:
-         if ((active0 & 0x4000000L) != 0L)
+         if ((active0 & 0x800000L) != 0L)
          {
-            jjmatchedKind = 29;
+            jjmatchedKind = 26;
             return 6;
          }
          return -1;
@@ -844,9 +665,9 @@ private int jjMoveStringLiteralDfa0_2()
    switch(curChar)
    {
       case 84:
-         return jjMoveStringLiteralDfa1_2(0x4000000L);
+         return jjMoveStringLiteralDfa1_2(0x800000L);
       case 93:
-         return jjStopAtPos(0, 27);
+         return jjStopAtPos(0, 24);
       default :
          return jjMoveNfa_2(0, 0);
    }
@@ -861,8 +682,8 @@ private int jjMoveStringLiteralDfa1_2(long active0)
    switch(curChar)
    {
       case 79:
-         if ((active0 & 0x4000000L) != 0L)
-            return jjStartNfaWithStates_2(1, 26, 6);
+         if ((active0 & 0x800000L) != 0L)
+            return jjStartNfaWithStates_2(1, 23, 6);
          break;
       default :
          break;
@@ -898,8 +719,8 @@ private int jjMoveNfa_2(int startState, int curPos)
                case 0:
                   if ((0xfffffffeffffffffL & l) != 0L)
                   {
-                     if (kind > 29)
-                        kind = 29;
+                     if (kind > 26)
+                        kind = 26;
                      jjCheckNAdd(6);
                   }
                   if ((0x100002600L & l) != 0L)
@@ -916,21 +737,21 @@ private int jjMoveNfa_2(int startState, int curPos)
                   break;
                case 2:
                   if ((0xfffffffbffffffffL & l) != 0L)
-                     jjCheckNAddStates(16, 18);
+                     jjCheckNAddStates(5, 7);
                   break;
                case 3:
                   if (curChar == 34)
-                     jjCheckNAddStates(16, 18);
+                     jjCheckNAddStates(5, 7);
                   break;
                case 5:
-                  if (curChar == 34 && kind > 28)
-                     kind = 28;
+                  if (curChar == 34 && kind > 25)
+                     kind = 25;
                   break;
                case 6:
                   if ((0xfffffffeffffffffL & l) == 0L)
                      break;
-                  if (kind > 29)
-                     kind = 29;
+                  if (kind > 26)
+                     kind = 26;
                   jjCheckNAdd(6);
                   break;
                default : break;
@@ -948,12 +769,12 @@ private int jjMoveNfa_2(int startState, int curPos)
                case 6:
                   if ((0xffffffffdfffffffL & l) == 0L)
                      break;
-                  if (kind > 29)
-                     kind = 29;
+                  if (kind > 26)
+                     kind = 26;
                   jjCheckNAdd(6);
                   break;
                case 2:
-                  jjAddStates(16, 18);
+                  jjAddStates(5, 7);
                   break;
                case 4:
                   if (curChar == 92)
@@ -982,20 +803,20 @@ private int jjMoveNfa_2(int startState, int curPos)
                   }
                   if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                   {
-                     if (kind > 29)
-                        kind = 29;
+                     if (kind > 26)
+                        kind = 26;
                      jjCheckNAdd(6);
                   }
                   break;
                case 2:
                   if (jjCanMove_1(hiByte, i1, i2, l1, l2))
-                     jjAddStates(16, 18);
+                     jjAddStates(5, 7);
                   break;
                case 6:
                   if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
                      break;
-                  if (kind > 29)
-                     kind = 29;
+                  if (kind > 26)
+                     kind = 26;
                   jjCheckNAdd(6);
                   break;
                default : break;
@@ -1016,8 +837,7 @@ private int jjMoveNfa_2(int startState, int curPos)
    }
 }
 static final int[] jjnextStates = {
-   15, 16, 18, 29, 32, 23, 33, 30, 20, 21, 32, 23, 33, 31, 34, 27, 
-   2, 4, 5, 0, 1, 
+   15, 16, 18, 25, 26, 2, 4, 5, 0, 1, 
 };
 private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)
 {
@@ -1059,8 +879,8 @@ private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, lo
 /** Token literal values. */
 public static final String[] jjstrLiteralImages = {
 "", null, null, null, null, null, null, null, null, null, null, "\53", "\55", 
-"\50", "\51", "\72", "\52", "\136", null, null, null, null, null, "\133", "\173", 
-null, "\124\117", "\135", null, null, "\124\117", "\175", null, null, };
+"\50", "\51", "\72", "\136", null, null, null, "\133", "\173", null, "\124\117", 
+"\135", null, null, "\124\117", "\175", null, null, };
 
 /** Lexer state names. */
 public static final String[] lexStateNames = {
@@ -1072,18 +892,18 @@ public static final String[] lexStateNames = {
 
 /** Lex State array. */
 public static final int[] jjnewLexState = {
-   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, 2, 1, 
-   3, -1, 3, -1, -1, -1, 3, -1, -1, 
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, 2, 1, 3, -1, 3, 
+   -1, -1, -1, 3, -1, -1, 
 };
 static final long[] jjtoToken = {
-   0x3ffffff01L, 
+   0x7fffff01L, 
 };
 static final long[] jjtoSkip = {
    0x80L, 
 };
 protected JavaCharStream input_stream;
-private final int[] jjrounds = new int[36];
-private final int[] jjstateSet = new int[72];
+private final int[] jjrounds = new int[28];
+private final int[] jjstateSet = new int[56];
 protected char curChar;
 /** Constructor. */
 public StandardSyntaxParserTokenManager(JavaCharStream stream){
@@ -1110,7 +930,7 @@ private void ReInitRounds()
 {
    int i;
    jjround = 0x80000001;
-   for (i = 36; i-- > 0;)
+   for (i = 28; i-- > 0;)
       jjrounds[i] = 0x80000000;
 }
 
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/Token.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/Token.java
index 60a8825..1fdd269 100644
--- a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/Token.java
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/Token.java
@@ -128,4 +128,4 @@ public class Token implements java.io.Serializable {
   }
 
 }
-/* JavaCC - StandardChecksum=f9eb36a076cde62bf39ccbf828bc2117 (do not edit this line) */
+/* JavaCC - OriginalChecksum=75998e81abbed08b0922a65bec11680d (do not edit this line) */
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/TokenMgrError.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/TokenMgrError.java
index 9279700..4b72f0c 100644
--- a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/TokenMgrError.java
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/TokenMgrError.java
@@ -144,4 +144,4 @@ public class TokenMgrError extends Error
     this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
   }
 }
-/* JavaCC - StandardChecksum=91ba9c9f5e0e552a815530d639ce15ed (do not edit this line) */
+/* JavaCC - OriginalChecksum=9672a6de7ecf4f5789a473d7dd40f6fb (do not edit this line) */
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/AllowLeadingWildcardProcessor.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/AllowLeadingWildcardProcessor.java
index eccc9ff..92c724b 100644
--- a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/AllowLeadingWildcardProcessor.java
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/AllowLeadingWildcardProcessor.java
@@ -24,9 +24,10 @@ import org.apache.lucene.queryParser.core.QueryNodeException;
 import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
 import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.WildcardQueryNode;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
+import org.apache.lucene.queryParser.core.util.UnescapedCharSequence;
 import org.apache.lucene.queryParser.standard.config.AllowLeadingWildcardAttribute;
+import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
 import org.apache.lucene.queryParser.standard.parser.EscapeQuerySyntaxImpl;
 
 /**
@@ -46,19 +47,16 @@ public class AllowLeadingWildcardProcessor extends QueryNodeProcessorImpl {
 
   public QueryNode process(QueryNode queryTree) throws QueryNodeException {
 
-    if (getQueryConfigHandler().hasAttribute(
-        AllowLeadingWildcardAttribute.class)) {
+    if (getQueryConfigHandler().hasAttribute(AllowLeadingWildcardAttribute.class)) {
 
-      if (!((AllowLeadingWildcardAttribute) getQueryConfigHandler()
-          .getAttribute(AllowLeadingWildcardAttribute.class))
-          .isAllowLeadingWildcard()) {
+      AllowLeadingWildcardAttribute alwAttr= (AllowLeadingWildcardAttribute) getQueryConfigHandler().getAttribute(AllowLeadingWildcardAttribute.class);
+      if (!alwAttr.isAllowLeadingWildcard()) {
         return super.process(queryTree);
       }
 
     }
 
     return queryTree;
-
   }
 
   protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
@@ -66,14 +64,19 @@ public class AllowLeadingWildcardProcessor extends QueryNodeProcessorImpl {
     if (node instanceof WildcardQueryNode) {
       WildcardQueryNode wildcardNode = (WildcardQueryNode) node;
 
-      switch (wildcardNode.getText().charAt(0)) {
-
-      case '*':
-      case '?':
-        throw new QueryNodeException(new MessageImpl(
-            QueryParserMessages.LEADING_WILDCARD_NOT_ALLOWED, node
-                .toQueryString(new EscapeQuerySyntaxImpl())));
-
+      if (wildcardNode.getText().length() > 0) {
+        
+        // Validate if the wildcard was escaped
+        if (UnescapedCharSequence.wasEscaped(wildcardNode.getText(), 0))
+          return node;
+        
+        switch (wildcardNode.getText().charAt(0)) {    
+          case '*':
+          case '?':
+            throw new QueryNodeException(new MessageImpl(
+                QueryParserMessages.LEADING_WILDCARD_NOT_ALLOWED, node
+                    .toQueryString(new EscapeQuerySyntaxImpl())));    
+        }
       }
 
     }
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/AnalyzerQueryNodeProcessor.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/AnalyzerQueryNodeProcessor.java
index 9bd6e4a..63a8ebe 100644
--- a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/AnalyzerQueryNodeProcessor.java
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/AnalyzerQueryNodeProcessor.java
@@ -38,12 +38,12 @@ import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
 import org.apache.lucene.queryParser.core.nodes.TextableQueryNode;
 import org.apache.lucene.queryParser.core.nodes.TokenizedPhraseQueryNode;
-import org.apache.lucene.queryParser.core.nodes.WildcardQueryNode;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
 import org.apache.lucene.queryParser.standard.config.AnalyzerAttribute;
 import org.apache.lucene.queryParser.standard.config.PositionIncrementsAttribute;
-import org.apache.lucene.queryParser.standard.nodes.StandardBooleanQueryNode;
 import org.apache.lucene.queryParser.standard.nodes.MultiPhraseQueryNode;
+import org.apache.lucene.queryParser.standard.nodes.StandardBooleanQueryNode;
+import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
 
 /**
  * This processor verifies if the attribute {@link AnalyzerQueryNodeProcessor}
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/LowercaseExpandedTermsQueryNodeProcessor.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/LowercaseExpandedTermsQueryNodeProcessor.java
index 67f6dda..c81532a 100644
--- a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/LowercaseExpandedTermsQueryNodeProcessor.java
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/LowercaseExpandedTermsQueryNodeProcessor.java
@@ -25,9 +25,10 @@ import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
 import org.apache.lucene.queryParser.core.nodes.FuzzyQueryNode;
 import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.WildcardQueryNode;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
+import org.apache.lucene.queryParser.core.util.UnescapedCharSequence;
 import org.apache.lucene.queryParser.standard.config.LowercaseExpandedTermsAttribute;
+import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
 
 /**
  * This processor verifies if the attribute
@@ -68,9 +69,8 @@ public class LowercaseExpandedTermsQueryNodeProcessor extends
     if (node instanceof WildcardQueryNode || node instanceof FuzzyQueryNode
         || node instanceof ParametricQueryNode) {
 
-      FieldQueryNode fieldNode = (FieldQueryNode) node;
-      fieldNode.setText(fieldNode.getText().toString().toLowerCase());
-
+      FieldQueryNode fieldNode = (FieldQueryNode) node;      
+      fieldNode.setText(UnescapedCharSequence.toLowerCase(fieldNode.getText()));
     }
 
     return node;
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MatchAllDocsQueryNodeProcessor.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MatchAllDocsQueryNodeProcessor.java
index 96b6768..a418ac0 100644
--- a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MatchAllDocsQueryNodeProcessor.java
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MatchAllDocsQueryNodeProcessor.java
@@ -20,10 +20,11 @@ package org.apache.lucene.queryParser.standard.processors;
 import java.util.List;
 
 import org.apache.lucene.queryParser.core.QueryNodeException;
+import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
 import org.apache.lucene.queryParser.core.nodes.MatchAllDocsQueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.WildcardQueryNode;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
+import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
 import org.apache.lucene.search.MatchAllDocsQuery;
 
 /**
@@ -41,11 +42,11 @@ public class MatchAllDocsQueryNodeProcessor extends QueryNodeProcessorImpl {
 
   protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
 
-    if (node instanceof WildcardQueryNode) {
-      WildcardQueryNode wildcardNode = (WildcardQueryNode) node;
+    if (node instanceof FieldQueryNode) {
+      FieldQueryNode fqn = (FieldQueryNode) node;
 
-      if (wildcardNode.getField().toString().equals("*")
-          && wildcardNode.getText().toString().equals("*")) {
+      if (fqn.getField().toString().equals("*")
+          && fqn.getText().toString().equals("*")) {
 
         return new MatchAllDocsQueryNode();
 
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MultiTermRewriteDefaultProcessor.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MultiTermRewriteDefaultProcessor.java
index 562ec01..e69de29 100644
--- a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MultiTermRewriteDefaultProcessor.java
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MultiTermRewriteDefaultProcessor.java
@@ -1,53 +0,0 @@
-package org.apache.lucene.queryParser.standard.processors;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.WildcardQueryNode;
-import org.apache.lucene.queryParser.core.nodes.PrefixWildcardQueryNode;
-import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-import org.apache.lucene.search.MultiTermQuery;
-
-/**
- * This processor instates the default {@link
- * MultiTermQuery.RewriteMethod}, {@link
- * MultiTermQuery#CONSTANT_SCORE_AUTO_REWRITE_DEFAULT}, for
- * multi-term query nodes.
- */
-public class MultiTermRewriteDefaultProcessor extends QueryNodeProcessorImpl {
-
-  protected QueryNode postProcessNode(QueryNode node) {
-    if (node instanceof WildcardQueryNode) {
-      ((WildcardQueryNode) node).setMultiTermRewriteMethod(MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT);
-    } else if (node instanceof PrefixWildcardQueryNode) {
-      ((PrefixWildcardQueryNode) node).setMultiTermRewriteMethod(MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT);
-    }
-
-    return node;
-  }
-
-  protected QueryNode preProcessNode(QueryNode node) {
-    return node;
-  }
-
-  protected List<QueryNode> setChildrenOrder(List<QueryNode> children) {
-    return children;
-  }
-}
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MultiTermRewriteMethodProcessor.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MultiTermRewriteMethodProcessor.java
new file mode 100644
index 0000000..57f4b85
--- /dev/null
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MultiTermRewriteMethodProcessor.java
@@ -0,0 +1,66 @@
+package org.apache.lucene.queryParser.standard.processors;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+
+import org.apache.lucene.queryParser.core.nodes.ParametricRangeQueryNode;
+import org.apache.lucene.queryParser.core.nodes.QueryNode;
+import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
+import org.apache.lucene.queryParser.standard.config.MultiTermRewriteMethodAttribute;
+import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
+import org.apache.lucene.search.MultiTermQuery;
+
+/**
+ * This processor instates the default {@link
+ * MultiTermQuery.RewriteMethod}, {@link
+ * MultiTermQuery#CONSTANT_SCORE_AUTO_REWRITE_DEFAULT}, for
+ * multi-term query nodes.
+ */
+public class MultiTermRewriteMethodProcessor extends QueryNodeProcessorImpl {  
+
+  protected QueryNode postProcessNode(QueryNode node) {
+    
+    // set setMultiTermRewriteMethod for WildcardQueryNode and PrefixWildcardQueryNode
+    if (node instanceof WildcardQueryNode || node instanceof  ParametricRangeQueryNode
+        || node instanceof ParametricRangeQueryNode) {
+      
+      if (!getQueryConfigHandler().hasAttribute(MultiTermRewriteMethodAttribute.class)) {
+        // This should not happen, this attribute is created in the StandardQueryConfigHandler
+        throw new IllegalArgumentException("MultiTermRewriteMethodAttribute should be set on the QueryConfigHandler");
+      }
+
+      //read the attribute value and use a TAG to take the value to the Builder
+      MultiTermQuery.RewriteMethod rewriteMethod = ((MultiTermRewriteMethodAttribute) getQueryConfigHandler()
+          .getAttribute(MultiTermRewriteMethodAttribute.class))
+          .getMultiTermRewriteMethod();
+
+      node.setTag(MultiTermRewriteMethodAttribute.TAG_ID, rewriteMethod);
+    }
+    
+    return node;
+  }
+
+  protected QueryNode preProcessNode(QueryNode node) {
+    return node;
+  }
+
+  protected List<QueryNode> setChildrenOrder(List<QueryNode> children) {
+    return children;
+  }
+}
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/ParametricRangeQueryNodeProcessor.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/ParametricRangeQueryNodeProcessor.java
index e5c6779..a2f6832 100644
--- a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/ParametricRangeQueryNodeProcessor.java
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/ParametricRangeQueryNodeProcessor.java
@@ -35,12 +35,10 @@ import org.apache.lucene.queryParser.core.nodes.ParametricRangeQueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
 import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode.CompareOperator;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-import org.apache.lucene.queryParser.standard.config.MultiTermRewriteMethodAttribute;
 import org.apache.lucene.queryParser.standard.config.DateResolutionAttribute;
 import org.apache.lucene.queryParser.standard.config.LocaleAttribute;
 import org.apache.lucene.queryParser.standard.config.RangeCollatorAttribute;
 import org.apache.lucene.queryParser.standard.nodes.RangeQueryNode;
-import org.apache.lucene.search.MultiTermQuery;
 
 /**
  * This processor converts {@link ParametricRangeQueryNode} objects to
@@ -85,16 +83,6 @@ public class ParametricRangeQueryNodeProcessor extends QueryNodeProcessorImpl {
       DateTools.Resolution dateRes = null;
       boolean inclusive = false;
 
-      if (!getQueryConfigHandler().hasAttribute(
-          MultiTermRewriteMethodAttribute.class)) {
-        throw new IllegalArgumentException(
-            "MultiTermRewriteMethodAttribute should be set on the QueryConfigHandler");
-      }
-
-      MultiTermQuery.RewriteMethod rewriteMethod = ((MultiTermRewriteMethodAttribute) getQueryConfigHandler()
-          .getAttribute(MultiTermRewriteMethodAttribute.class))
-          .getMultiTermRewriteMethod();
-
       if (getQueryConfigHandler().hasAttribute(RangeCollatorAttribute.class)) {
         collator = ((RangeCollatorAttribute) getQueryConfigHandler()
             .getAttribute(RangeCollatorAttribute.class)).getRangeCollator();
@@ -164,7 +152,7 @@ public class ParametricRangeQueryNodeProcessor extends QueryNodeProcessorImpl {
       lower.setText(part1);
       upper.setText(part2);
 
-      return new RangeQueryNode(lower, upper, collator, rewriteMethod);
+      return new RangeQueryNode(lower, upper, collator);
 
     }
 
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/PrefixWildcardQueryNodeProcessor.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/PrefixWildcardQueryNodeProcessor.java
index 53fa2d9..e69de29 100644
--- a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/PrefixWildcardQueryNodeProcessor.java
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/PrefixWildcardQueryNodeProcessor.java
@@ -1,72 +0,0 @@
-package org.apache.lucene.queryParser.standard.processors;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-
-import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.core.nodes.PrefixWildcardQueryNode;
-import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-import org.apache.lucene.queryParser.standard.parser.StandardSyntaxParser;
-import org.apache.lucene.search.PrefixQuery;
-
-/**
- * The {@link StandardSyntaxParser} creates {@link PrefixWildcardQueryNode} nodes which
- * have values containing the prefixed wildcard. However, Lucene
- * {@link PrefixQuery} cannot contain the prefixed wildcard. So, this processor
- * basically removed the prefixed wildcard from the
- * {@link PrefixWildcardQueryNode} value. <br/>
- * 
- * @see PrefixQuery
- * @see PrefixWildcardQueryNode
- */
-public class PrefixWildcardQueryNodeProcessor extends QueryNodeProcessorImpl {
-
-  public PrefixWildcardQueryNodeProcessor() {
-    // empty constructor
-  }
-
-  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
-
-    if (node instanceof PrefixWildcardQueryNode) {
-      PrefixWildcardQueryNode prefixWildcardNode = (PrefixWildcardQueryNode) node;
-      CharSequence text = prefixWildcardNode.getText();
-
-      prefixWildcardNode.setText(text.subSequence(0, text.length() - 1));
-
-    }
-
-    return node;
-
-  }
-
-  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
-
-    return node;
-
-  }
-
-  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
-      throws QueryNodeException {
-
-    return children;
-
-  }
-
-}
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/StandardQueryNodeProcessorPipeline.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/StandardQueryNodeProcessorPipeline.java
index b47eafc..9ad5451 100644
--- a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/StandardQueryNodeProcessorPipeline.java
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/StandardQueryNodeProcessorPipeline.java
@@ -48,13 +48,13 @@ public class StandardQueryNodeProcessorPipeline extends
   public StandardQueryNodeProcessorPipeline(QueryConfigHandler queryConfig) {
     super(queryConfig);
 
+    addProcessor(new WildcardQueryNodeProcessor());    
     addProcessor(new MultiFieldQueryNodeProcessor());
     addProcessor(new FuzzyQueryNodeProcessor());
     addProcessor(new MatchAllDocsQueryNodeProcessor());
     addProcessor(new LowercaseExpandedTermsQueryNodeProcessor());
     addProcessor(new ParametricRangeQueryNodeProcessor());
-    addProcessor(new AllowLeadingWildcardProcessor());
-    addProcessor(new PrefixWildcardQueryNodeProcessor());
+    addProcessor(new AllowLeadingWildcardProcessor());    
     addProcessor(new AnalyzerQueryNodeProcessor());
     addProcessor(new PhraseSlopQueryNodeProcessor());
     addProcessor(new GroupQueryNodeProcessor());
@@ -63,9 +63,8 @@ public class StandardQueryNodeProcessorPipeline extends
     addProcessor(new RemoveEmptyNonLeafQueryNodeProcessor());
     addProcessor(new BooleanSingleChildOptimizationQueryNodeProcessor());
     addProcessor(new DefaultPhraseSlopQueryNodeProcessor());
-    addProcessor(new BoostQueryNodeProcessor());
-    addProcessor(new MultiTermRewriteDefaultProcessor());
-
+    addProcessor(new BoostQueryNodeProcessor());    
+    addProcessor(new MultiTermRewriteMethodProcessor());
   }
 
 }
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/WildcardQueryNodeProcessor.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/WildcardQueryNodeProcessor.java
new file mode 100644
index 0000000..2bef4bd
--- /dev/null
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/WildcardQueryNodeProcessor.java
@@ -0,0 +1,136 @@
+package org.apache.lucene.queryParser.standard.processors;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+
+import org.apache.lucene.queryParser.core.QueryNodeException;
+import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
+import org.apache.lucene.queryParser.core.nodes.FuzzyQueryNode;
+import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode;
+import org.apache.lucene.queryParser.core.nodes.QueryNode;
+import org.apache.lucene.queryParser.core.nodes.QuotedFieldQueryNode;
+import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
+import org.apache.lucene.queryParser.core.util.UnescapedCharSequence;
+import org.apache.lucene.queryParser.standard.nodes.PrefixWildcardQueryNode;
+import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
+import org.apache.lucene.queryParser.standard.parser.StandardSyntaxParser;
+import org.apache.lucene.search.PrefixQuery;
+
+/**
+ * The {@link StandardSyntaxParser} creates {@link PrefixWildcardQueryNode} nodes which
+ * have values containing the prefixed wildcard. However, Lucene
+ * {@link PrefixQuery} cannot contain the prefixed wildcard. So, this processor
+ * basically removed the prefixed wildcard from the
+ * {@link PrefixWildcardQueryNode} value. <br/>
+ * 
+ * @see PrefixQuery
+ * @see PrefixWildcardQueryNode
+ */
+public class WildcardQueryNodeProcessor extends QueryNodeProcessorImpl {
+
+  public WildcardQueryNodeProcessor() {
+    // empty constructor
+  }
+
+  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
+
+    // the old Lucene Parser ignores FuzzyQueryNode that are also PrefixWildcardQueryNode or WildcardQueryNode
+    // we do the same here, also ignore empty terms
+    if (node instanceof FieldQueryNode || node instanceof FuzzyQueryNode) {      
+      FieldQueryNode fqn = (FieldQueryNode) node;      
+      CharSequence text = fqn.getText(); 
+      
+      // do not process wildcards for ParametricQueryNode and 
+      // QuotedFieldQueryNode to reproduce the old parser behavior
+      if (fqn instanceof ParametricQueryNode 
+          || fqn instanceof QuotedFieldQueryNode 
+          || text.length() <= 0){
+        // Ignore empty terms
+        return node;
+      }
+      
+      // Code below simulates the old lucene parser behavior for wildcards
+      
+      if (isPrefixWildcard(text)) {        
+        PrefixWildcardQueryNode prefixWildcardQN = new PrefixWildcardQueryNode(fqn);
+        return prefixWildcardQN;
+        
+      } else if (isWildcard(text)){
+        WildcardQueryNode wildcardQN = new WildcardQueryNode(fqn);
+        return wildcardQN;
+      }
+             
+    }
+
+    return node;
+
+  }
+
+  private boolean isWildcard(CharSequence text) {
+    if (text ==null || text.length() <= 0) return false;
+    
+    // If a un-escaped '*' or '?' if found return true
+    // start at the end since it's more common to put wildcards at the end
+    for(int i=text.length()-1; i>=0; i--){
+      if ((text.charAt(i) == '*' || text.charAt(i) == '?') && !UnescapedCharSequence.wasEscaped(text, i)){
+        return true;
+      }
+    }
+    
+    return false;
+  }
+
+  private boolean isPrefixWildcard(CharSequence text) {
+    if (text == null || text.length() <= 0 || !isWildcard(text)) return false;
+    
+    // Validate last character is a '*' and was not escaped
+    // If single '*' is is a wildcard not prefix to simulate old queryparser
+    if (text.charAt(text.length()-1) != '*') return false;
+    if (UnescapedCharSequence.wasEscaped(text, text.length()-1)) return false;
+    if (text.length() == 1) return false;
+      
+    // Only make a prefix if there is only one single star at the end and no '?' or '*' characters
+    // If single wildcard return false to mimic old queryparser
+    for(int i=0; i<text.length(); i++){
+      if (text.charAt(i) == '?') return false;
+      if (text.charAt(i) == '*' && !UnescapedCharSequence.wasEscaped(text, i)){        
+        if (i == text.length()-1) 
+          return true;
+        else 
+          return false;
+      }
+    }
+    
+    return false;
+  }
+
+  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
+
+    return node;
+
+  }
+
+  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
+      throws QueryNodeException {
+
+    return children;
+
+  }
+
+}
diff --git a/contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/TestSpanQueryParser.java b/contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/TestSpanQueryParser.java
index 954e48f..36628c2 100644
--- a/contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/TestSpanQueryParser.java
+++ b/contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/TestSpanQueryParser.java
@@ -27,6 +27,7 @@ import org.apache.lucene.queryParser.core.nodes.QueryNode;
 import org.apache.lucene.queryParser.core.parser.SyntaxParser;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorPipeline;
 import org.apache.lucene.queryParser.standard.parser.StandardSyntaxParser;
+import org.apache.lucene.queryParser.standard.processors.WildcardQueryNodeProcessor;
 import org.apache.lucene.search.spans.SpanOrQuery;
 import org.apache.lucene.search.spans.SpanQuery;
 import org.apache.lucene.search.spans.SpanTermQuery;
@@ -115,13 +116,11 @@ public class TestSpanQueryParser extends TestCase {
     this.spansQueryTreeBuilder = new SpansQueryTreeBuilder();
 
     // set up the processor pipeline
-    this.spanProcessorPipeline
-        .setQueryConfigHandler(this.spanQueryConfigHandler);
+    this.spanProcessorPipeline.setQueryConfigHandler(this.spanQueryConfigHandler);
 
-    this.spanProcessorPipeline
-        .addProcessor(new SpansValidatorQueryNodeProcessor());
-    this.spanProcessorPipeline
-        .addProcessor(new UniqueFieldQueryNodeProcessor());
+    this.spanProcessorPipeline.addProcessor(new WildcardQueryNodeProcessor());
+    this.spanProcessorPipeline.addProcessor(new SpansValidatorQueryNodeProcessor());
+    this.spanProcessorPipeline.addProcessor(new UniqueFieldQueryNodeProcessor());
 
   }
 
diff --git a/contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQPHelper.java b/contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQPHelper.java
index e106ebb..4c4569e 100644
--- a/contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQPHelper.java
+++ b/contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQPHelper.java
@@ -54,10 +54,10 @@ import org.apache.lucene.queryParser.core.QueryNodeException;
 import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
 import org.apache.lucene.queryParser.core.nodes.FuzzyQueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.WildcardQueryNode;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorPipeline;
 import org.apache.lucene.queryParser.standard.config.DefaultOperatorAttribute.Operator;
+import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.FuzzyQuery;
 import org.apache.lucene.search.IndexSearcher;
@@ -759,6 +759,8 @@ public class TestQPHelper extends LuceneTestCase {
      * "foo \\AND bar");
      */
 
+    assertQueryEquals("\\*", a, "*");
+    
     assertQueryEquals("\\a", a, "a");
 
     assertQueryEquals("a\\-b:c", a, "a-b:c");
@@ -938,13 +940,13 @@ public class TestQPHelper extends LuceneTestCase {
   }
 
   public void testException() throws Exception {
+    assertQueryNodeException("*leadingWildcard"); // disallowed by default
     assertQueryNodeException("\"some phrase");
     assertQueryNodeException("(foo bar");
     assertQueryNodeException("foo bar))");
     assertQueryNodeException("field:term:with:colon some more terms");
     assertQueryNodeException("(sub query)^5.0^2.0 plus more");
-    assertQueryNodeException("secret AND illegal) AND access:confidential");
-    assertQueryNodeException("*leadingWildcard"); // disallowed by default
+    assertQueryNodeException("secret AND illegal) AND access:confidential");    
   }
 
   public void testCustomQueryParserWildcard() {
diff --git a/contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQueryParserWrapper.java b/contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQueryParserWrapper.java
index d172059..0f044a4 100644
--- a/contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQueryParserWrapper.java
+++ b/contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQueryParserWrapper.java
@@ -51,9 +51,10 @@ import org.apache.lucene.queryParser.core.QueryNodeException;
 import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
 import org.apache.lucene.queryParser.core.nodes.FuzzyQueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.core.nodes.WildcardQueryNode;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorPipeline;
+import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
+import org.apache.lucene.queryParser.standard.processors.WildcardQueryNodeProcessor;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.FuzzyQuery;
 import org.apache.lucene.search.IndexSearcher;
@@ -159,6 +160,7 @@ public class TestQueryParserWrapper extends LuceneTestCase {
 
       QueryNodeProcessorPipeline newProcessorPipeline = new QueryNodeProcessorPipeline(
           getQueryProcessor().getQueryConfigHandler());
+      newProcessorPipeline.addProcessor(new WildcardQueryNodeProcessor());
       newProcessorPipeline.addProcessor(new QPTestParserQueryNodeProcessor());
       newProcessorPipeline.addProcessor(getQueryProcessor());
 

