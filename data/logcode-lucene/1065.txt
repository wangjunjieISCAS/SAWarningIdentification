GitDiffStart: 5341918a0c626afb29343c42d651911f19b084a2 | Tue May 10 06:54:11 2016 -0700
diff --git a/solr/CHANGES.txt b/solr/CHANGES.txt
index 39b029a..ab3af2c 100644
--- a/solr/CHANGES.txt
+++ b/solr/CHANGES.txt
@@ -276,6 +276,9 @@ Other Changes
 * SOLR-8467: CloudSolrStream and FacetStream should take a SolrParams object rather than a 
   Map<String, String> to allow more complex Solr queries to be specified. (Erick Erickson)
 
+* SOLR-9083: Remove all <types> and <fields> from schemas. NOTE: as in the JIRA I left a few in to insure the (no cost)
+  back compat. (Erick Erickson)
+
 ==================  6.0.0 ==================
 
 Consult the LUCENE_CHANGES.txt file for additional, low level, changes in this release
diff --git a/solr/contrib/analysis-extras/src/test-files/analysis-extras/solr/collection1/conf/schema-folding-extra.xml b/solr/contrib/analysis-extras/src/test-files/analysis-extras/solr/collection1/conf/schema-folding-extra.xml
index ccc0e06..8e13cf6 100644
--- a/solr/contrib/analysis-extras/src/test-files/analysis-extras/solr/collection1/conf/schema-folding-extra.xml
+++ b/solr/contrib/analysis-extras/src/test-files/analysis-extras/solr/collection1/conf/schema-folding-extra.xml
@@ -16,40 +16,36 @@
   -->
 
 <schema name="test" version="1.0">
-  <types>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true" multiValued="false"/>
-
-
-    <fieldType name="text_icufolding" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.ICUFoldingFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="text_icunormalizer2" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.ICUNormalizer2FilterFactory" name="nfkc_cf" mode="compose"/>
-      </analyzer>
-    </fieldType>
-    
-    <fieldType name="text_icutransform" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.ICUTransformFilterFactory" id="Cyrillic-Latin"/>
-      </analyzer>
-    </fieldType>
-
-   </types>
-
-  <fields>
-    <field name="id" type="string" indexed="true" stored="true" required="true"/>
-    <field name="content_icufolding" type="text_icufolding" indexed="true" stored="true"/>
-    <field name="content_icunormalizer2" type="text_icunormalizer2" indexed="true" stored="true"/>
-    <field name="content_icutransform" type="text_icutransform" indexed="true" stored="true"/>
-
-  </fields>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true" multiValued="false"/>
+
+
+  <fieldType name="text_icufolding" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.ICUFoldingFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="text_icunormalizer2" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.ICUNormalizer2FilterFactory" name="nfkc_cf" mode="compose"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="text_icutransform" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.ICUTransformFilterFactory" id="Cyrillic-Latin"/>
+    </analyzer>
+  </fieldType>
+
+
+  <field name="id" type="string" indexed="true" stored="true" required="true"/>
+  <field name="content_icufolding" type="text_icufolding" indexed="true" stored="true"/>
+  <field name="content_icunormalizer2" type="text_icunormalizer2" indexed="true" stored="true"/>
+  <field name="content_icutransform" type="text_icutransform" indexed="true" stored="true"/>
+
 
   <defaultSearchField>id</defaultSearchField>
   <uniqueKey>id</uniqueKey>
diff --git a/solr/contrib/analysis-extras/src/test-files/analysis-extras/solr/collection1/conf/schema-icucollate-dv.xml b/solr/contrib/analysis-extras/src/test-files/analysis-extras/solr/collection1/conf/schema-icucollate-dv.xml
index c6b8e6b..3631077 100644
--- a/solr/contrib/analysis-extras/src/test-files/analysis-extras/solr/collection1/conf/schema-icucollate-dv.xml
+++ b/solr/contrib/analysis-extras/src/test-files/analysis-extras/solr/collection1/conf/schema-icucollate-dv.xml
@@ -19,33 +19,32 @@
 <!-- Test schema file for CollationField (docvalues) -->
 
 <schema name="test" version="1.0">
-  <types>
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-
-    <!-- basic text field -->
-    <fieldType name="text" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    
-    <fieldType name="sort_ar_t"       class="solr.ICUCollationField" locale="ar"/>
-    <fieldType name="sort_de_t"       class="solr.ICUCollationField" locale="de" strength="primary"/>
-    <fieldType name="sort_tr_canon_t" class="solr.ICUCollationField" locale="tr" strength="primary"   decomposition="canonical"/>
-    <fieldType name="sort_da_t"       class="solr.ICUCollationField" locale="da" strength="primary"/>
-    <fieldType name="sort_custom_t"   class="solr.ICUCollationField" custom="customrules.dat" strength="primary"/>
-  </types>
-
-  <fields>
-    <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
-    <field name="text" type="text" indexed="true" stored="false"/>
-    <field name="sort_ar"       type="sort_ar_t"       indexed="false" stored="false" multiValued="false" docValues="true"/>
-    <field name="sort_de"       type="sort_de_t"       indexed="false" stored="false" multiValued="false" docValues="true"/>
-    <field name="sort_tr_canon" type="sort_tr_canon_t" indexed="false" stored="false" multiValued="true" docValues="true"/>
-    <field name="sort_da"       type="sort_da_t"       indexed="false" stored="false" multiValued="false" docValues="true"/>
-    <field name="sort_custom"   type="sort_custom_t"   indexed="false" stored="false" multiValued="true" docValues="true"/>
-  </fields>
+
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+
+  <!-- basic text field -->
+  <fieldType name="text" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="sort_ar_t" class="solr.ICUCollationField" locale="ar"/>
+  <fieldType name="sort_de_t" class="solr.ICUCollationField" locale="de" strength="primary"/>
+  <fieldType name="sort_tr_canon_t" class="solr.ICUCollationField" locale="tr" strength="primary"
+             decomposition="canonical"/>
+  <fieldType name="sort_da_t" class="solr.ICUCollationField" locale="da" strength="primary"/>
+  <fieldType name="sort_custom_t" class="solr.ICUCollationField" custom="customrules.dat" strength="primary"/>
+
+  <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="text" type="text" indexed="true" stored="false"/>
+  <field name="sort_ar" type="sort_ar_t" indexed="false" stored="false" multiValued="false" docValues="true"/>
+  <field name="sort_de" type="sort_de_t" indexed="false" stored="false" multiValued="false" docValues="true"/>
+  <field name="sort_tr_canon" type="sort_tr_canon_t" indexed="false" stored="false" multiValued="true"
+         docValues="true"/>
+  <field name="sort_da" type="sort_da_t" indexed="false" stored="false" multiValued="false" docValues="true"/>
+  <field name="sort_custom" type="sort_custom_t" indexed="false" stored="false" multiValued="true" docValues="true"/>
 
   <defaultSearchField>text</defaultSearchField>
   <uniqueKey>id</uniqueKey>
diff --git a/solr/contrib/analysis-extras/src/test-files/analysis-extras/solr/collection1/conf/schema-icucollate.xml b/solr/contrib/analysis-extras/src/test-files/analysis-extras/solr/collection1/conf/schema-icucollate.xml
index b8bbf7b..563669a 100644
--- a/solr/contrib/analysis-extras/src/test-files/analysis-extras/solr/collection1/conf/schema-icucollate.xml
+++ b/solr/contrib/analysis-extras/src/test-files/analysis-extras/solr/collection1/conf/schema-icucollate.xml
@@ -19,33 +19,32 @@
 <!-- Test schema file for CollationField -->
 
 <schema name="test" version="1.0">
-  <types>
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-
-    <!-- basic text field -->
-    <fieldType name="text" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    
-    <fieldType name="sort_ar_t"       class="solr.ICUCollationField" locale="ar"/>
-    <fieldType name="sort_de_t"       class="solr.ICUCollationField" locale="de" strength="primary"/>
-    <fieldType name="sort_tr_canon_t" class="solr.ICUCollationField" locale="tr" strength="primary"   decomposition="canonical"/>
-    <fieldType name="sort_da_t"       class="solr.ICUCollationField" locale="da" strength="primary"/>
-    <fieldType name="sort_custom_t"   class="solr.ICUCollationField" custom="customrules.dat" strength="primary"/>
-  </types>
-
-  <fields>
-    <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
-    <field name="text" type="text" indexed="true" stored="false"/>
-    <field name="sort_ar"       type="sort_ar_t"       indexed="true" stored="false" multiValued="false"/>
-    <field name="sort_de"       type="sort_de_t"       indexed="true" stored="false" multiValued="false"/>
-    <field name="sort_tr_canon" type="sort_tr_canon_t" indexed="true" stored="false" multiValued="false"/>
-    <field name="sort_da"       type="sort_da_t"       indexed="true" stored="false" multiValued="false"/>
-    <field name="sort_custom"   type="sort_custom_t"   indexed="true" stored="false" multiValued="false"/>
-  </fields>
+
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+
+  <!-- basic text field -->
+  <fieldType name="text" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="sort_ar_t" class="solr.ICUCollationField" locale="ar"/>
+  <fieldType name="sort_de_t" class="solr.ICUCollationField" locale="de" strength="primary"/>
+  <fieldType name="sort_tr_canon_t" class="solr.ICUCollationField" locale="tr" strength="primary"
+             decomposition="canonical"/>
+  <fieldType name="sort_da_t" class="solr.ICUCollationField" locale="da" strength="primary"/>
+  <fieldType name="sort_custom_t" class="solr.ICUCollationField" custom="customrules.dat" strength="primary"/>
+
+  <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="text" type="text" indexed="true" stored="false"/>
+  <field name="sort_ar" type="sort_ar_t" indexed="true" stored="false" multiValued="false"/>
+  <field name="sort_de" type="sort_de_t" indexed="true" stored="false" multiValued="false"/>
+  <field name="sort_tr_canon" type="sort_tr_canon_t" indexed="true" stored="false" multiValued="false"/>
+  <field name="sort_da" type="sort_da_t" indexed="true" stored="false" multiValued="false"/>
+  <field name="sort_custom" type="sort_custom_t" indexed="true" stored="false" multiValued="false"/>
+
 
   <defaultSearchField>text</defaultSearchField>
   <uniqueKey>id</uniqueKey>
diff --git a/solr/contrib/analysis-extras/src/test-files/analysis-extras/solr/collection1/conf/schema-icucollateoptions.xml b/solr/contrib/analysis-extras/src/test-files/analysis-extras/solr/collection1/conf/schema-icucollateoptions.xml
index c660479..525b73f 100644
--- a/solr/contrib/analysis-extras/src/test-files/analysis-extras/solr/collection1/conf/schema-icucollateoptions.xml
+++ b/solr/contrib/analysis-extras/src/test-files/analysis-extras/solr/collection1/conf/schema-icucollateoptions.xml
@@ -19,43 +19,43 @@
 <!-- Test schema file for CollationField options -->
 
 <schema name="test" version="1.0">
-  <types>
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
 
-    <!-- basic text field -->
-    <fieldType name="text" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- ignores punctuation and whitespace -->
-    <fieldType name="sort_ignore_punctuation_t" class="solr.ICUCollationField" 
-               locale="en" strength="primary" alternate="shifted"/>
-    <!-- ignores only whitespace -->
-    <fieldType name="sort_ignore_space_t" class="solr.ICUCollationField" 
-               locale="en" strength="primary" alternate="shifted" variableTop=" "/>
-    <!-- ignores only accents, but not case -->
-    <fieldType name="sort_ignore_accents_t" class="solr.ICUCollationField"
-               locale="en" strength="primary" caseLevel="true"/>
-    <!-- sorts numerics in numeric order -->
-    <fieldType name="sort_numerics_t" class="solr.ICUCollationField" 
-               locale="en" numeric="true"/>
-    <!-- sorts uppercase before lowercase -->
-    <fieldType name="sort_uppercase_first_t" class="solr.ICUCollationField" 
-               locale="en" strength="tertiary" caseFirst="upper"/>
-  </types>
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+
+  <!-- basic text field -->
+  <fieldType name="text" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- ignores punctuation and whitespace -->
+  <fieldType name="sort_ignore_punctuation_t" class="solr.ICUCollationField"
+             locale="en" strength="primary" alternate="shifted"/>
+  <!-- ignores only whitespace -->
+  <fieldType name="sort_ignore_space_t" class="solr.ICUCollationField"
+             locale="en" strength="primary" alternate="shifted" variableTop=" "/>
+  <!-- ignores only accents, but not case -->
+  <fieldType name="sort_ignore_accents_t" class="solr.ICUCollationField"
+             locale="en" strength="primary" caseLevel="true"/>
+  <!-- sorts numerics in numeric order -->
+  <fieldType name="sort_numerics_t" class="solr.ICUCollationField"
+             locale="en" numeric="true"/>
+  <!-- sorts uppercase before lowercase -->
+  <fieldType name="sort_uppercase_first_t" class="solr.ICUCollationField"
+             locale="en" strength="tertiary" caseFirst="upper"/>
+
+
+  <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="text" type="text" indexed="true" stored="false"/>
+  <field name="sort_ignore_punctuation" type="sort_ignore_punctuation_t" indexed="true" stored="false"
+         multiValued="false"/>
+  <field name="sort_ignore_space" type="sort_ignore_space_t" indexed="true" stored="false" multiValued="false"/>
+  <field name="sort_ignore_accents" type="sort_ignore_accents_t" indexed="true" stored="false" multiValued="false"/>
+  <field name="sort_numerics" type="sort_numerics_t" indexed="true" stored="false" multiValued="false"/>
+  <field name="sort_uppercase_first" type="sort_uppercase_first_t" indexed="true" stored="false" multiValued="false"/>
 
-  <fields>
-    <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
-    <field name="text" type="text" indexed="true" stored="false"/>
-    <field name="sort_ignore_punctuation" type="sort_ignore_punctuation_t" indexed="true" stored="false" multiValued="false"/>
-    <field name="sort_ignore_space"       type="sort_ignore_space_t"       indexed="true" stored="false" multiValued="false"/>
-    <field name="sort_ignore_accents"     type="sort_ignore_accents_t"     indexed="true" stored="false" multiValued="false"/>
-    <field name="sort_numerics"           type="sort_numerics_t"           indexed="true" stored="false" multiValued="false"/>
-    <field name="sort_uppercase_first"    type="sort_uppercase_first_t"    indexed="true" stored="false" multiValued="false"/>
-  </fields>
 
   <defaultSearchField>text</defaultSearchField>
   <uniqueKey>id</uniqueKey>
diff --git a/solr/contrib/analytics/src/test-files/solr/collection1/conf/schema-analytics.xml b/solr/contrib/analytics/src/test-files/solr/collection1/conf/schema-analytics.xml
index 0387e09..2d90359 100644
--- a/solr/contrib/analytics/src/test-files/solr/collection1/conf/schema-analytics.xml
+++ b/solr/contrib/analytics/src/test-files/solr/collection1/conf/schema-analytics.xml
@@ -26,68 +26,65 @@
   -->
 
 <schema name="schema-docValues" version="1.6">
-  <types>
-
-    <!-- field type definitions... note that the "name" attribute is
-         just a label to be used by field definitions.  The "class"
-         attribute and any other attributes determine the real type and
-         behavior of the fieldType.
-      -->
-
-    <!-- numeric field types that store and index the text
-         value verbatim (and hence don't sort correctly or support range queries.)
-         These are provided more for backward compatability, allowing one
-         to create a schema that matches an existing lucene index.
+
+
+  <!-- field type definitions... note that the "name" attribute is
+       just a label to be used by field definitions.  The "class"
+       attribute and any other attributes determine the real type and
+       behavior of the fieldType.
+    -->
+
+  <!-- numeric field types that store and index the text
+       value verbatim (and hence don't sort correctly or support range queries.)
+       These are provided more for backward compatability, allowing one
+       to create a schema that matches an existing lucene index.
+  -->
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
+       seconds part (.999) is optional.
     -->
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
-         seconds part (.999) is optional.
-      -->
-    <fieldType name="date" class="solr.TrieDateField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-
-    <fieldType name="boolean" class="solr.BoolField" />
-    <fieldType name="string" class="solr.StrField" />
-
-    <fieldType name="uuid" class="solr.UUIDField" />
-
-  </types>
-
-
-  <fields>
-
-    <field name="id" type="string" required="true" />
-
-    <field name="floatdv" type="float" indexed="false" stored="false" docValues="true" default="1" />
-    <field name="intdv" type="int" indexed="false" stored="false" docValues="true" default="2" />
-    <field name="doubledv" type="double" indexed="false" stored="false" docValues="true" default="3" />
-    <field name="longdv" type="long" indexed="false" stored="false" docValues="true" default="4" />
-    <field name="datedv" type="date" indexed="false" stored="false" docValues="true" default="1995-12-31T23:59:59.999Z" />
-
-    <field name="stringdv" type="string" indexed="false" stored="false" docValues="true" default="solr" />
-    <field name="stringdvm" type="string" indexed="false" stored="false" docValues="true" default="solr" multiValued="true" />
-    
-    <dynamicField name="*_i" type="int" indexed="true" stored="true" docValues="false" multiValued="false" />
-    <dynamicField name="*_id" type="int" indexed="true" stored="true" docValues="true" multiValued="false" />
-    <dynamicField name="*_idm" type="int" indexed="true" stored="true" docValues="true" multiValued="true" />
-    <dynamicField name="*_l" type="long" indexed="true" stored="true" docValues="false" multiValued="false" />
-    <dynamicField name="*_ld" type="long" indexed="true" stored="true" docValues="true" multiValued="false" />
-    <dynamicField name="*_ldm" type="long" indexed="true" stored="true" docValues="true" multiValued="true" />
-    <dynamicField name="*_f" type="float" indexed="true" stored="true" docValues="false" multiValued="false" />
-    <dynamicField name="*_fd" type="float" indexed="true" stored="true" docValues="true" multiValued="false" />
-    <dynamicField name="*_fdm" type="float" indexed="true" stored="true" docValues="true" multiValued="true" />
-    <dynamicField name="*_d" type="double" indexed="true" stored="true" docValues="false" multiValued="false" />
-    <dynamicField name="*_dd" type="double" indexed="true" stored="true" docValues="true" multiValued="false" />
-    <dynamicField name="*_ddm" type="double" indexed="true" stored="true" docValues="true" multiValued="true" />
-    <dynamicField name="*_dt" type="date" indexed="true" stored="true" docValues="false" multiValued="false" />
-    <dynamicField name="*_dtd" type="date" indexed="true" stored="true" docValues="true" multiValued="false" />
-    <dynamicField name="*_dtdm" type="date" indexed="true" stored="true" docValues="true" multiValued="true" />
-    <dynamicField name="*_s" type="string" indexed="true" stored="true" docValues="false" multiValued="false"/>
-    <dynamicField name="*_sd" type="string" indexed="true" stored="true" docValues="true" multiValued="false"/>
-    <dynamicField name="*_sdm" type="string" indexed="true" stored="true" docValues="true" multiValued="true" />
-  </fields>
+  <fieldType name="date" class="solr.TrieDateField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+
+  <fieldType name="boolean" class="solr.BoolField"/>
+  <fieldType name="string" class="solr.StrField"/>
+
+  <fieldType name="uuid" class="solr.UUIDField"/>
+
+
+  <field name="id" type="string" required="true"/>
+
+  <field name="floatdv" type="float" indexed="false" stored="false" docValues="true" default="1"/>
+  <field name="intdv" type="int" indexed="false" stored="false" docValues="true" default="2"/>
+  <field name="doubledv" type="double" indexed="false" stored="false" docValues="true" default="3"/>
+  <field name="longdv" type="long" indexed="false" stored="false" docValues="true" default="4"/>
+  <field name="datedv" type="date" indexed="false" stored="false" docValues="true" default="1995-12-31T23:59:59.999Z"/>
+
+  <field name="stringdv" type="string" indexed="false" stored="false" docValues="true" default="solr"/>
+  <field name="stringdvm" type="string" indexed="false" stored="false" docValues="true" default="solr"
+         multiValued="true"/>
+
+  <dynamicField name="*_i" type="int" indexed="true" stored="true" docValues="false" multiValued="false"/>
+  <dynamicField name="*_id" type="int" indexed="true" stored="true" docValues="true" multiValued="false"/>
+  <dynamicField name="*_idm" type="int" indexed="true" stored="true" docValues="true" multiValued="true"/>
+  <dynamicField name="*_l" type="long" indexed="true" stored="true" docValues="false" multiValued="false"/>
+  <dynamicField name="*_ld" type="long" indexed="true" stored="true" docValues="true" multiValued="false"/>
+  <dynamicField name="*_ldm" type="long" indexed="true" stored="true" docValues="true" multiValued="true"/>
+  <dynamicField name="*_f" type="float" indexed="true" stored="true" docValues="false" multiValued="false"/>
+  <dynamicField name="*_fd" type="float" indexed="true" stored="true" docValues="true" multiValued="false"/>
+  <dynamicField name="*_fdm" type="float" indexed="true" stored="true" docValues="true" multiValued="true"/>
+  <dynamicField name="*_d" type="double" indexed="true" stored="true" docValues="false" multiValued="false"/>
+  <dynamicField name="*_dd" type="double" indexed="true" stored="true" docValues="true" multiValued="false"/>
+  <dynamicField name="*_ddm" type="double" indexed="true" stored="true" docValues="true" multiValued="true"/>
+  <dynamicField name="*_dt" type="date" indexed="true" stored="true" docValues="false" multiValued="false"/>
+  <dynamicField name="*_dtd" type="date" indexed="true" stored="true" docValues="true" multiValued="false"/>
+  <dynamicField name="*_dtdm" type="date" indexed="true" stored="true" docValues="true" multiValued="true"/>
+  <dynamicField name="*_s" type="string" indexed="true" stored="true" docValues="false" multiValued="false"/>
+  <dynamicField name="*_sd" type="string" indexed="true" stored="true" docValues="true" multiValued="false"/>
+  <dynamicField name="*_sdm" type="string" indexed="true" stored="true" docValues="true" multiValued="true"/>
+
 
   <uniqueKey>id</uniqueKey>
 
diff --git a/solr/contrib/clustering/src/test-files/clustering/solr/collection1/conf/schema.xml b/solr/contrib/clustering/src/test-files/clustering/solr/collection1/conf/schema.xml
index d8ad793..af59a20 100644
--- a/solr/contrib/clustering/src/test-files/clustering/solr/collection1/conf/schema.xml
+++ b/solr/contrib/clustering/src/test-files/clustering/solr/collection1/conf/schema.xml
@@ -37,299 +37,298 @@
        1.0: multiValued attribute did not exist, all fields are multiValued by nature
        1.1: multiValued attribute introduced, false by default -->
 
-  <types>
-    <!-- field type definitions. The "name" attribute is
-       just a label to be used by field definitions.  The "class"
-       attribute and any other attributes determine the real
-       behavior of the fieldType.
-         Class names starting with "solr" refer to java classes in the
-       org.apache.solr.analysis package.
-    -->
 
-    <!-- The StrField type is not analyzed, but indexed/stored verbatim.  
-       - StrField and TextField support an optional compressThreshold which
-       limits compression (if enabled in the derived fields) to values which
-       exceed a certain size (in characters).
-    -->
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true" omitNorms="true"/>
-
-    <!-- boolean type: "true" or "false" -->
-    <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true" omitNorms="true"/>
-
-    <!-- The optional sortMissingLast and sortMissingFirst attributes are
-         currently supported on types that are sorted internally as strings.
-       - If sortMissingLast="true", then a sort on this field will cause documents
-         without the field to come after documents with the field,
-         regardless of the requested sort order (asc or desc).
-       - If sortMissingFirst="true", then a sort on this field will cause documents
-         without the field to come before documents with the field,
-         regardless of the requested sort order.
-       - If sortMissingLast="false" and sortMissingFirst="false" (the default),
-         then default lucene sorting will be used which places docs without the
-         field first in an ascending sort and last in a descending sort.
+  <!-- field type definitions. The "name" attribute is
+     just a label to be used by field definitions.  The "class"
+     attribute and any other attributes determine the real
+     behavior of the fieldType.
+       Class names starting with "solr" refer to java classes in the
+     org.apache.solr.analysis package.
+  -->
+
+  <!-- The StrField type is not analyzed, but indexed/stored verbatim.  
+     - StrField and TextField support an optional compressThreshold which
+     limits compression (if enabled in the derived fields) to values which
+     exceed a certain size (in characters).
+  -->
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true" omitNorms="true"/>
+
+  <!-- boolean type: "true" or "false" -->
+  <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true" omitNorms="true"/>
+
+  <!-- The optional sortMissingLast and sortMissingFirst attributes are
+       currently supported on types that are sorted internally as strings.
+     - If sortMissingLast="true", then a sort on this field will cause documents
+       without the field to come after documents with the field,
+       regardless of the requested sort order (asc or desc).
+     - If sortMissingFirst="true", then a sort on this field will cause documents
+       without the field to come before documents with the field,
+       regardless of the requested sort order.
+     - If sortMissingLast="false" and sortMissingFirst="false" (the default),
+       then default lucene sorting will be used which places docs without the
+       field first in an ascending sort and last in a descending sort.
+  -->
+
+  <!--
+    Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
+  -->
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
+
+  <!--
+   Numeric field types that index each value at various levels of precision
+   to accelerate range queries when the number of values between the range
+   endpoints is large. See the javadoc for LegacyNumericRangeQuery for internal
+   implementation details.
+  
+   Smaller precisionStep values (specified in bits) will lead to more tokens
+   indexed per value, slightly larger index size, and faster range queries.
+   A precisionStep of 0 disables indexing at different precision levels.
+  -->
+  <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
+
+
+  <!-- The format for this date field is of the form 1995-12-31T23:59:59Z, and
+       is a more restricted form of the canonical representation of dateTime
+       http://www.w3.org/TR/xmlschema-2/#dateTime    
+       The trailing "Z" designates UTC time and is mandatory.
+       Optional fractional seconds are allowed: 1995-12-31T23:59:59.999Z
+       All other components are mandatory.
+  
+       Expressions can also be used to denote calculations that should be
+       performed relative to "NOW" to determine the value, ie...
+  
+             NOW/HOUR
+                ... Round to the start of the current hour
+             NOW-1DAY
+                ... Exactly 1 day prior to now
+             NOW/DAY+6MONTHS+3DAYS
+                ... 6 months and 3 days in the future from the start of
+                    the current day
+                    
+       Consult the TrieDateField javadocs for more information.
     -->
+  <fieldType name="date" class="solr.TrieDateField" sortMissingLast="true" omitNorms="true"/>
+
+
+  <!-- The "RandomSortField" is not used to store or search any
+       data.  You can declare fields of this type it in your schema
+       to generate psuedo-random orderings of your docs for sorting 
+       purposes.  The ordering is generated based on the field name 
+       and the version of the index, As long as the index version
+       remains unchanged, and the same field name is reused,
+       the ordering of the docs will be consistent.  
+       If you want differend psuedo-random orderings of documents,
+       for the same version of the index, use a dynamicField and
+       change the name
+   -->
+  <fieldType name="random" class="solr.RandomSortField" indexed="true"/>
+
+  <!-- solr.TextField allows the specification of custom text analyzers
+       specified as a tokenizer and a list of token filters. Different
+       analyzers may be specified for indexing and querying.
+  
+       The optional positionIncrementGap puts space between multiple fields of
+       this type on the same document, with the purpose of preventing false phrase
+       matching across fields.
+  
+       For more info on customizing your analyzer chain, please see
+       http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters
+   -->
 
-    <!--
-      Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
-    -->
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
-
-    <!--
-     Numeric field types that index each value at various levels of precision
-     to accelerate range queries when the number of values between the range
-     endpoints is large. See the javadoc for LegacyNumericRangeQuery for internal
-     implementation details.
-
-     Smaller precisionStep values (specified in bits) will lead to more tokens
-     indexed per value, slightly larger index size, and faster range queries.
-     A precisionStep of 0 disables indexing at different precision levels.
-    -->
-    <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
-
-
-    <!-- The format for this date field is of the form 1995-12-31T23:59:59Z, and
-         is a more restricted form of the canonical representation of dateTime
-         http://www.w3.org/TR/xmlschema-2/#dateTime    
-         The trailing "Z" designates UTC time and is mandatory.
-         Optional fractional seconds are allowed: 1995-12-31T23:59:59.999Z
-         All other components are mandatory.
-
-         Expressions can also be used to denote calculations that should be
-         performed relative to "NOW" to determine the value, ie...
-
-               NOW/HOUR
-                  ... Round to the start of the current hour
-               NOW-1DAY
-                  ... Exactly 1 day prior to now
-               NOW/DAY+6MONTHS+3DAYS
-                  ... 6 months and 3 days in the future from the start of
-                      the current day
-                      
-         Consult the TrieDateField javadocs for more information.
+  <!-- One can also specify an existing Analyzer class that has a
+       default constructor via the class attribute on the analyzer element
+  <fieldType name="text_greek" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.el.GreekAnalyzer"/>
+  </fieldType>
+  -->
+
+  <!-- A text field that only splits on whitespace for exact matching of words -->
+  <fieldType name="text_ws" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- A text field that uses WordDelimiterFilter to enable splitting and matching of
+      words on case-change, alpha numeric boundaries, and non-alphanumeric chars,
+      so that a query of "wifi" or "wi fi" could match a document containing "Wi-Fi".
+      Synonyms and stopwords are customized by external files, and stemming is enabled.
+      Duplicate tokens at the same position (which may result from Stemmed Synonyms or
+      WordDelim parts) are removed.
+      -->
+  <fieldType name="text" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <!-- in this example, we will only use synonyms at query time
+      <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
       -->
-    <fieldType name="date" class="solr.TrieDateField" sortMissingLast="true" omitNorms="true"/>
-
-
-    <!-- The "RandomSortField" is not used to store or search any
-         data.  You can declare fields of this type it in your schema
-         to generate psuedo-random orderings of your docs for sorting 
-         purposes.  The ordering is generated based on the field name 
-         and the version of the index, As long as the index version
-         remains unchanged, and the same field name is reused,
-         the ordering of the docs will be consistent.  
-         If you want differend psuedo-random orderings of documents,
-         for the same version of the index, use a dynamicField and
-         change the name
-     -->
-    <fieldType name="random" class="solr.RandomSortField" indexed="true" />
-
-    <!-- solr.TextField allows the specification of custom text analyzers
-         specified as a tokenizer and a list of token filters. Different
-         analyzers may be specified for indexing and querying.
-
-         The optional positionIncrementGap puts space between multiple fields of
-         this type on the same document, with the purpose of preventing false phrase
-         matching across fields.
-
-         For more info on customizing your analyzer chain, please see
-         http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters
-     -->
-
-    <!-- One can also specify an existing Analyzer class that has a
-         default constructor via the class attribute on the analyzer element
-    <fieldType name="text_greek" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.el.GreekAnalyzer"/>
-    </fieldType>
+      <!-- Case insensitive stop word removal.
+      -->
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="stopwords.txt"
+      />
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <!--<filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>-->
+      <!--<filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>-->
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <!-- Less flexible matching, but less false matches.  Probably not ideal for product names,
+       but may be good for SKUs.  Can insert dashes in the wrong place and still match. -->
+  <fieldType name="textTight" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <!--<filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="false"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>-->
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.EnglishMinimalStemFilterFactory"/>
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!--
+   Setup simple analysis for spell checking
+   -->
+  <fieldType name="textSpell" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- This is an example of using the KeywordTokenizer along
+       With various TokenFilterFactories to produce a sortable field
+       that does not include some properties of the source text
     -->
-
-    <!-- A text field that only splits on whitespace for exact matching of words -->
-    <fieldType name="text_ws" class="solr.TextField" positionIncrementGap="100">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- A text field that uses WordDelimiterFilter to enable splitting and matching of
-        words on case-change, alpha numeric boundaries, and non-alphanumeric chars,
-        so that a query of "wifi" or "wi fi" could match a document containing "Wi-Fi".
-        Synonyms and stopwords are customized by external files, and stemming is enabled.
-        Duplicate tokens at the same position (which may result from Stemmed Synonyms or
-        WordDelim parts) are removed.
+  <fieldType name="alphaOnlySort" class="solr.TextField" sortMissingLast="true" omitNorms="true">
+    <analyzer>
+      <!-- KeywordTokenizer does no actual tokenizing, so the entire
+           input string is preserved as a single token
         -->
-    <fieldType name="text" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <!-- in this example, we will only use synonyms at query time
-        <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+      <!-- The LowerCase TokenFilter does what you expect, which can be
+           when you want your sorting to be case insensitive
         -->
-        <!-- Case insensitive stop word removal.
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <!-- The TrimFilter removes any leading or trailing whitespace -->
+      <filter class="solr.TrimFilterFactory"/>
+      <!-- The PatternReplaceFilter gives you the flexibility to use
+           Java Regular expression to replace any sequence of characters
+           matching a pattern with an arbitrary replacement string, 
+           which may include back refrences to portions of the orriginal
+           string matched by the pattern.
+           
+           See the Java Regular Expression documentation for more
+           infomation on pattern and replacement string syntax.
+           
+           http://docs.oracle.com/javase/8/docs/api/java/util/regex/package-summary.html
         -->
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="stopwords.txt"
-                />
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <!--<filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>-->
-        <!--<filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>-->
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <!-- Less flexible matching, but less false matches.  Probably not ideal for product names,
-         but may be good for SKUs.  Can insert dashes in the wrong place and still match. -->
-    <fieldType name="textTight" class="solr.TextField" positionIncrementGap="100" >
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <!--<filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="false"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>-->
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.EnglishMinimalStemFilterFactory"/>
-        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!--
-     Setup simple analysis for spell checking
-     -->
-    <fieldType name="textSpell" class="solr.TextField" positionIncrementGap="100" >
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- This is an example of using the KeywordTokenizer along
-         With various TokenFilterFactories to produce a sortable field
-         that does not include some properties of the source text
-      -->
-    <fieldType name="alphaOnlySort" class="solr.TextField" sortMissingLast="true" omitNorms="true">
-      <analyzer>
-        <!-- KeywordTokenizer does no actual tokenizing, so the entire
-             input string is preserved as a single token
-          -->
-        <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
-        <!-- The LowerCase TokenFilter does what you expect, which can be
-             when you want your sorting to be case insensitive
-          -->
-        <filter class="solr.LowerCaseFilterFactory" />
-        <!-- The TrimFilter removes any leading or trailing whitespace -->
-        <filter class="solr.TrimFilterFactory" />
-        <!-- The PatternReplaceFilter gives you the flexibility to use
-             Java Regular expression to replace any sequence of characters
-             matching a pattern with an arbitrary replacement string, 
-             which may include back refrences to portions of the orriginal
-             string matched by the pattern.
-             
-             See the Java Regular Expression documentation for more
-             infomation on pattern and replacement string syntax.
-             
-             http://docs.oracle.com/javase/8/docs/api/java/util/regex/package-summary.html
-          -->
-        <filter class="solr.PatternReplaceFilterFactory"
-                pattern="([^a-z])" replacement="" replace="all"
-        />
-      </analyzer>
-    </fieldType>
-
-    <!-- since fields of this type are by default not stored or indexed, any data added to 
-         them will be ignored outright 
-     --> 
-    <fieldType name="ignored" stored="false" indexed="false" class="solr.StrField" /> 
-
- </types>
-
-
- <fields>
-   <!-- Valid attributes for fields:
-     name: mandatory - the name for the field
-     type: mandatory - the name of a previously defined type from the <types> section
-     indexed: true if this field should be indexed (searchable or sortable)
-     stored: true if this field should be retrievable
-     multiValued: true if this field may contain multiple values per document
-     omitNorms: (expert) set to true to omit the norms associated with
-       this field (this disables length normalization and index-time
-       boosting for the field, and saves some memory).  Only full-text
-       fields or fields that need an index-time boost need norms.
-     termVectors: [false] set to true to store the term vector for a given field.
-       When using MoreLikeThis, fields used for similarity should be stored for 
-       best performance.
+      <filter class="solr.PatternReplaceFilterFactory"
+              pattern="([^a-z])" replacement="" replace="all"
+      />
+    </analyzer>
+  </fieldType>
+
+  <!-- since fields of this type are by default not stored or indexed, any data added to 
+       them will be ignored outright 
    -->
+  <fieldType name="ignored" stored="false" indexed="false" class="solr.StrField"/>
+
+
+  <!-- Valid attributes for fields:
+    name: mandatory - the name for the field
+    type: mandatory - the name of a previously defined type from the <fieldType>s
+    indexed: true if this field should be indexed (searchable or sortable)
+    stored: true if this field should be retrievable
+    multiValued: true if this field may contain multiple values per document
+    omitNorms: (expert) set to true to omit the norms associated with
+      this field (this disables length normalization and index-time
+      boosting for the field, and saves some memory).  Only full-text
+      fields or fields that need an index-time boost need norms.
+    termVectors: [false] set to true to store the term vector for a given field.
+      When using MoreLikeThis, fields used for similarity should be stored for 
+      best performance.
+  -->
+
+  <field name="id" type="string" indexed="true" stored="true" required="true"/>
+  <field name="url" type="string" indexed="true" stored="true" required="true"/>
+  <field name="lang" type="string" indexed="true" stored="true" required="false" multiValued="true"/>
+
+  <field name="title" type="text" indexed="true" stored="true" multiValued="true"/>
+  <field name="heading" type="text" indexed="true" stored="true" multiValued="true"/>
+  <field name="snippet" type="text" indexed="true" stored="true" multiValued="true"/>
+  <field name="body" type="text" indexed="true" stored="true" multiValued="true"/>
+  <!-- catchall field, containing all other searchable text fields (implemented
+       via copyField further on in this schema  -->
+  <field name="text" type="text" indexed="true" stored="false" multiValued="true"/>
+  <!-- Dynamic field definitions.  If a field name is not found, dynamicFields
+       will be used if the name matches any of the patterns.
+       RESTRICTION: the glob-like pattern in the name attribute must have
+       a "*" only at the start or the end.
+       EXAMPLE:  name="*_i" will match any field ending in _i (like myid_i, z_i)
+       Longer patterns will be matched first.  if equal size patterns
+       both match, the first appearing in the schema will be used.  -->
+  <dynamicField name="*_i" type="int" indexed="true" stored="true"/>
+  <dynamicField name="*_s" type="string" indexed="true" stored="true"/>
+  <dynamicField name="*_l" type="long" indexed="true" stored="true"/>
+  <dynamicField name="*_t" type="text" indexed="true" stored="true"/>
+  <dynamicField name="*_b" type="boolean" indexed="true" stored="true"/>
+  <dynamicField name="*_f" type="float" indexed="true" stored="true"/>
+  <dynamicField name="*_d" type="double" indexed="true" stored="true"/>
+  <dynamicField name="*_dt" type="date" indexed="true" stored="true"/>
+
+  <dynamicField name="random*" type="random"/>
+
+  <!-- uncomment the following to ignore any fields that don't already match an existing 
+       field name or dynamic field, rather than reporting them as an error. 
+       alternately, change the type="ignored" to some other type e.g. "text" if you want 
+       unknown fields indexed and/or stored by default -->
+  <!--dynamicField name="*" type="ignored" /-->
+
+
+  <!-- Field to use to determine and enforce document uniqueness. 
+       Unless this field is marked with required="false", it will be a required field
+    -->
+  <uniqueKey>id</uniqueKey>
 
-   <field name="id" type="string" indexed="true" stored="true" required="true" />
-   <field name="url" type="string" indexed="true" stored="true" required="true" />
-   <field name="lang" type="string" indexed="true" stored="true" required="false" multiValued="true" />
-
-   <field name="title" type="text" indexed="true" stored="true" multiValued="true"/>
-   <field name="heading" type="text" indexed="true" stored="true" multiValued="true"/>
-   <field name="snippet" type="text" indexed="true" stored="true" multiValued="true"/>
-   <field name="body" type="text" indexed="true" stored="true" multiValued="true"/>
-   <!-- catchall field, containing all other searchable text fields (implemented
-        via copyField further on in this schema  -->
-   <field name="text" type="text" indexed="true" stored="false" multiValued="true"/>
-   <!-- Dynamic field definitions.  If a field name is not found, dynamicFields
-        will be used if the name matches any of the patterns.
-        RESTRICTION: the glob-like pattern in the name attribute must have
-        a "*" only at the start or the end.
-        EXAMPLE:  name="*_i" will match any field ending in _i (like myid_i, z_i)
-        Longer patterns will be matched first.  if equal size patterns
-        both match, the first appearing in the schema will be used.  -->
-   <dynamicField name="*_i"  type="int"    indexed="true"  stored="true"/>
-   <dynamicField name="*_s"  type="string"  indexed="true"  stored="true"/>
-   <dynamicField name="*_l"  type="long"   indexed="true"  stored="true"/>
-   <dynamicField name="*_t"  type="text"    indexed="true"  stored="true"/>
-   <dynamicField name="*_b"  type="boolean" indexed="true"  stored="true"/>
-   <dynamicField name="*_f"  type="float"  indexed="true"  stored="true"/>
-   <dynamicField name="*_d"  type="double" indexed="true"  stored="true"/>
-   <dynamicField name="*_dt" type="date"    indexed="true"  stored="true"/>
-
-   <dynamicField name="random*" type="random" />
-
-   <!-- uncomment the following to ignore any fields that don't already match an existing 
-        field name or dynamic field, rather than reporting them as an error. 
-        alternately, change the type="ignored" to some other type e.g. "text" if you want 
-        unknown fields indexed and/or stored by default --> 
-   <!--dynamicField name="*" type="ignored" /-->
-   
- </fields>
-
- <!-- Field to use to determine and enforce document uniqueness. 
-      Unless this field is marked with required="false", it will be a required field
-   -->
- <uniqueKey>id</uniqueKey>
-
- <!-- field for the QueryParser to use when an explicit fieldname is absent -->
- <defaultSearchField>text</defaultSearchField>
+  <!-- field for the QueryParser to use when an explicit fieldname is absent -->
+  <defaultSearchField>text</defaultSearchField>
 
- <!-- SolrQueryParser configuration: defaultOperator="AND|OR" -->
- <solrQueryParser defaultOperator="OR"/>
+  <!-- SolrQueryParser configuration: defaultOperator="AND|OR" -->
+  <solrQueryParser defaultOperator="OR"/>
 
   <!-- copyField commands copy one field to another at the time a document
         is added to the index.  It's used either to index the same field differently,
         or to add multiple fields to the same field for easier/faster searching.  -->
   <copyField source="url" dest="text"/>
-   <copyField source="title" dest="text"/>
-   <copyField source="body" dest="text"/>
+  <copyField source="title" dest="text"/>
+  <copyField source="body" dest="text"/>
   <copyField source="snippet" dest="text"/>
 
 </schema>
diff --git a/solr/contrib/dataimporthandler-extras/src/test-files/dihextras/solr/collection1/conf/dataimport-schema-no-unique-key.xml b/solr/contrib/dataimporthandler-extras/src/test-files/dihextras/solr/collection1/conf/dataimport-schema-no-unique-key.xml
index 2d9fa64..068322e 100644
--- a/solr/contrib/dataimporthandler-extras/src/test-files/dihextras/solr/collection1/conf/dataimport-schema-no-unique-key.xml
+++ b/solr/contrib/dataimporthandler-extras/src/test-files/dihextras/solr/collection1/conf/dataimport-schema-no-unique-key.xml
@@ -37,177 +37,175 @@
        1.0: multiValued attribute did not exist, all fields are multiValued by nature
        1.1: multiValued attribute introduced, false by default -->
 
-  <types>
-    <!-- field type definitions. The "name" attribute is
-       just a label to be used by field definitions.  The "class"
-       attribute and any other attributes determine the real
-       behavior of the fieldType.
-         Class names starting with "solr" refer to java classes in the
-       org.apache.solr.analysis package.
-    -->
-
-    <!-- The StrField type is not analyzed, but indexed/stored verbatim.  
-       - StrField and TextField support an optional compressThreshold which
-       limits compression (if enabled in the derived fields) to values which
-       exceed a certain size (in characters).
-    -->
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true" omitNorms="true"/>
-
-    <!-- boolean type: "true" or "false" -->
-    <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true" omitNorms="true"/>
-
-    <!-- The optional sortMissingLast and sortMissingFirst attributes are
-         currently supported on types that are sorted internally as strings.
-       - If sortMissingLast="true", then a sort on this field will cause documents
-         without the field to come after documents with the field,
-         regardless of the requested sort order (asc or desc).
-       - If sortMissingFirst="true", then a sort on this field will cause documents
-         without the field to come before documents with the field,
-         regardless of the requested sort order.
-       - If sortMissingLast="false" and sortMissingFirst="false" (the default),
-         then default lucene sorting will be used which places docs without the
-         field first in an ascending sort and last in a descending sort.
-    -->
-
 
-    <!--
-      Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
+  <!-- field type definitions. The "name" attribute is
+     just a label to be used by field definitions.  The "class"
+     attribute and any other attributes determine the real
+     behavior of the fieldType.
+       Class names starting with "solr" refer to java classes in the
+     org.apache.solr.analysis package.
+  -->
+
+  <!-- The StrField type is not analyzed, but indexed/stored verbatim.  
+     - StrField and TextField support an optional compressThreshold which
+     limits compression (if enabled in the derived fields) to values which
+     exceed a certain size (in characters).
+  -->
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true" omitNorms="true"/>
+
+  <!-- boolean type: "true" or "false" -->
+  <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true" omitNorms="true"/>
+
+  <!-- The optional sortMissingLast and sortMissingFirst attributes are
+       currently supported on types that are sorted internally as strings.
+     - If sortMissingLast="true", then a sort on this field will cause documents
+       without the field to come after documents with the field,
+       regardless of the requested sort order (asc or desc).
+     - If sortMissingFirst="true", then a sort on this field will cause documents
+       without the field to come before documents with the field,
+       regardless of the requested sort order.
+     - If sortMissingLast="false" and sortMissingFirst="false" (the default),
+       then default lucene sorting will be used which places docs without the
+       field first in an ascending sort and last in a descending sort.
+  -->
+
+
+  <!--
+    Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
+  -->
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="latLon" class="solr.LatLonType" subFieldType="double"/>
+
+
+  <!--
+   Numeric field types that index each value at various levels of precision
+   to accelerate range queries when the number of values between the range
+   endpoints is large. See the javadoc for NumericRangeQuery for internal
+   implementation details.
+
+   Smaller precisionStep values (specified in bits) will lead to more tokens
+   indexed per value, slightly larger index size, and faster range queries.
+   A precisionStep of 0 disables indexing at different precision levels.
+  -->
+  <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
+
+
+  <!-- The format for this date field is of the form 1995-12-31T23:59:59Z, and
+       is a more restricted form of the canonical representation of dateTime
+       http://www.w3.org/TR/xmlschema-2/#dateTime    
+       The trailing "Z" designates UTC time and is mandatory.
+       Optional fractional seconds are allowed: 1995-12-31T23:59:59.999Z
+       All other components are mandatory.
+
+       Expressions can also be used to denote calculations that should be
+       performed relative to "NOW" to determine the value, ie...
+
+             NOW/HOUR
+                ... Round to the start of the current hour
+             NOW-1DAY
+                ... Exactly 1 day prior to now
+             NOW/DAY+6MONTHS+3DAYS
+                ... 6 months and 3 days in the future from the start of
+                    the current day
+                    
+       Consult the TrieDateField javadocs for more information.
     -->
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="latLon" class="solr.LatLonType" subFieldType="double"/>
-
-
-    <!--
-     Numeric field types that index each value at various levels of precision
-     to accelerate range queries when the number of values between the range
-     endpoints is large. See the javadoc for NumericRangeQuery for internal
-     implementation details.
-
-     Smaller precisionStep values (specified in bits) will lead to more tokens
-     indexed per value, slightly larger index size, and faster range queries.
-     A precisionStep of 0 disables indexing at different precision levels.
-    -->
-    <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
-
-
-    <!-- The format for this date field is of the form 1995-12-31T23:59:59Z, and
-         is a more restricted form of the canonical representation of dateTime
-         http://www.w3.org/TR/xmlschema-2/#dateTime    
-         The trailing "Z" designates UTC time and is mandatory.
-         Optional fractional seconds are allowed: 1995-12-31T23:59:59.999Z
-         All other components are mandatory.
-
-         Expressions can also be used to denote calculations that should be
-         performed relative to "NOW" to determine the value, ie...
-
-               NOW/HOUR
-                  ... Round to the start of the current hour
-               NOW-1DAY
-                  ... Exactly 1 day prior to now
-               NOW/DAY+6MONTHS+3DAYS
-                  ... 6 months and 3 days in the future from the start of
-                      the current day
-                      
-         Consult the TrieDateField javadocs for more information.
+  <fieldType name="date" class="solr.TrieDateField" sortMissingLast="true" omitNorms="true"/>
+
+
+  <!-- The "RandomSortField" is not used to store or search any
+       data.  You can declare fields of this type it in your schema
+       to generate psuedo-random orderings of your docs for sorting 
+       purposes.  The ordering is generated based on the field name 
+       and the version of the index, As long as the index version
+       remains unchanged, and the same field name is reused,
+       the ordering of the docs will be consistent.  
+       If you want differend psuedo-random orderings of documents,
+       for the same version of the index, use a dynamicField and
+       change the name
+   -->
+  <fieldType name="random" class="solr.RandomSortField" indexed="true"/>
+
+  <!-- solr.TextField allows the specification of custom text analyzers
+       specified as a tokenizer and a list of token filters. Different
+       analyzers may be specified for indexing and querying.
+
+       The optional positionIncrementGap puts space between multiple fields of
+       this type on the same document, with the purpose of preventing false phrase
+       matching across fields.
+
+       For more info on customizing your analyzer chain, please see
+       http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters
+   -->
+
+  <!-- One can also specify an existing Analyzer class that has a
+       default constructor via the class attribute on the analyzer element
+  <fieldType name="text_greek" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.el.GreekAnalyzer"/>
+  </fieldType>
+  -->
+
+  <!-- A text field that only splits on whitespace for exact matching of words -->
+  <fieldType name="text_ws" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- A text field that uses WordDelimiterFilter to enable splitting and matching of
+      words on case-change, alpha numeric boundaries, and non-alphanumeric chars,
+      so that a query of "wifi" or "wi fi" could match a document containing "Wi-Fi".
+      Synonyms and stopwords are customized by external files, and stemming is enabled.
+      Duplicate tokens at the same position (which may result from Stemmed Synonyms or
+      WordDelim parts) are removed.
       -->
-    <fieldType name="date" class="solr.TrieDateField" sortMissingLast="true" omitNorms="true"/>
-
-
-    <!-- The "RandomSortField" is not used to store or search any
-         data.  You can declare fields of this type it in your schema
-         to generate psuedo-random orderings of your docs for sorting 
-         purposes.  The ordering is generated based on the field name 
-         and the version of the index, As long as the index version
-         remains unchanged, and the same field name is reused,
-         the ordering of the docs will be consistent.  
-         If you want differend psuedo-random orderings of documents,
-         for the same version of the index, use a dynamicField and
-         change the name
-     -->
-    <fieldType name="random" class="solr.RandomSortField" indexed="true" />
-
-    <!-- solr.TextField allows the specification of custom text analyzers
-         specified as a tokenizer and a list of token filters. Different
-         analyzers may be specified for indexing and querying.
-
-         The optional positionIncrementGap puts space between multiple fields of
-         this type on the same document, with the purpose of preventing false phrase
-         matching across fields.
-
-         For more info on customizing your analyzer chain, please see
-         http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters
-     -->
-
-    <!-- One can also specify an existing Analyzer class that has a
-         default constructor via the class attribute on the analyzer element
-    <fieldType name="text_greek" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.el.GreekAnalyzer"/>
-    </fieldType>
-    -->
-
-    <!-- A text field that only splits on whitespace for exact matching of words -->
-    <fieldType name="text_ws" class="solr.TextField" positionIncrementGap="100">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- A text field that uses WordDelimiterFilter to enable splitting and matching of
-        words on case-change, alpha numeric boundaries, and non-alphanumeric chars,
-        so that a query of "wifi" or "wi fi" could match a document containing "Wi-Fi".
-        Synonyms and stopwords are customized by external files, and stemming is enabled.
-        Duplicate tokens at the same position (which may result from Stemmed Synonyms or
-        WordDelim parts) are removed.
-        -->
-    <fieldType name="text" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <!-- in this example, we will only use synonyms at query time
-        <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
-        -->
-        <!--<filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>-->
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <!--<filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>-->
-        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <!--<filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>-->
-        <!--<filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>-->
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <!--<filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>-->
-        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <!-- since fields of this type are by default not stored or indexed, any data added to 
-         them will be ignored outright 
-     --> 
-    <fieldType name="ignored" stored="false" indexed="false" class="solr.StrField" /> 
-
- </types>
-
-
- <fields>
-   <field name="title" type="string" indexed="true" stored="true"/>
-   <field name="author" type="string" indexed="true" stored="true" />
-   <field name="text" type="text" indexed="true" stored="true" />
-   <field name="foo_i" type="int" indexed="true" stored="false" />
-   <field name="home" type="latLon" indexed="true" stored="true" />
- </fields>
- <!-- field for the QueryParser to use when an explicit fieldname is absent -->
- <defaultSearchField>text</defaultSearchField>
-
- <!-- SolrQueryParser configuration: defaultOperator="AND|OR" -->
- <solrQueryParser defaultOperator="OR"/>
+  <fieldType name="text" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <!-- in this example, we will only use synonyms at query time
+      <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
+      -->
+      <!--<filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>-->
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <!--<filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>-->
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <!--<filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>-->
+      <!--<filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>-->
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <!--<filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>-->
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <!-- since fields of this type are by default not stored or indexed, any data added to 
+       them will be ignored outright 
+   -->
+  <fieldType name="ignored" stored="false" indexed="false" class="solr.StrField"/>
+
+  <field name="title" type="string" indexed="true" stored="true"/>
+  <field name="author" type="string" indexed="true" stored="true"/>
+  <field name="text" type="text" indexed="true" stored="true"/>
+  <field name="foo_i" type="int" indexed="true" stored="false"/>
+  <field name="home" type="latLon" indexed="true" stored="true"/>
+
+  <!-- field for the QueryParser to use when an explicit fieldname is absent -->
+  <defaultSearchField>text</defaultSearchField>
+
+  <!-- SolrQueryParser configuration: defaultOperator="AND|OR" -->
+  <solrQueryParser defaultOperator="OR"/>
 
 </schema>
diff --git a/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/dataimport-schema.xml b/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/dataimport-schema.xml
index 7b10481..8d62c84 100644
--- a/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/dataimport-schema.xml
+++ b/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/dataimport-schema.xml
@@ -1,60 +1,62 @@
 <schema name="dih_test" version="4.0">
-  <types>    
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true" omitNorms="true"/>
-    <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true" omitNorms="true"/>  
-    <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>  
-    <fieldType name="date" class="solr.TrieDateField" sortMissingLast="true" omitNorms="true"/>
-    <fieldType name="text" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="textTight" class="solr.TextField" positionIncrementGap="100" >
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="ignored" stored="false" indexed="false" class="solr.StrField" /> 
-  </types>
-  <fields>   
-    <field name="id" type="string" indexed="true" stored="true" required="true" />
-    <field name="desc" type="string" indexed="true" stored="true" multiValued="true" />   
-    <field name="date" type="date" indexed="true" stored="true" />
-    <field name="timestamp" type="date" indexed="true" stored="true" default="NOW" multiValued="false"/>
-    
-    <field name="NAME" type="text" indexed="true" stored="true" multiValued="false" />
-    <field name="COUNTRY_NAME" type="text" indexed="true" stored="true" multiValued="true" />
-    <field name="SPORT_NAME" type="text" indexed="true" stored="true" multiValued="true" />
-    <field name="DO_NOT_INDEX" type="ignored" />
 
-    <field name="_version_" type="tlong" indexed="true" stored="true" multiValued="false"/>
-    <field name="_root_" type="string" indexed="true" stored="true" multiValued="false"/>
-       
-    <dynamicField name="*_i"       type="tint"    indexed="true"  stored="true"/>
-    <dynamicField name="*_s"       type="string"  indexed="true"  stored="true"/>
-    <dynamicField name="*_mult_s"  type="string"  indexed="true"  stored="true"   multiValued="true"/>
-    <dynamicField name="*_l"       type="tlong"   indexed="true"  stored="true"/>
-    <dynamicField name="*_t"       type="text"    indexed="true"  stored="true"/>
-    <dynamicField name="*_b"       type="boolean" indexed="true"  stored="true"/>
-    <dynamicField name="*_f"       type="tfloat"  indexed="true"  stored="true"/>
-    <dynamicField name="*_d"       type="tdouble" indexed="true"  stored="true"/>
-    <dynamicField name="*_dt"      type="date"    indexed="true"  stored="true"/>   
-  </fields>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true" omitNorms="true"/>
+  <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true" omitNorms="true"/>
+  <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="date" class="solr.TrieDateField" sortMissingLast="true" omitNorms="true"/>
+  <fieldType name="text" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="textTight" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="ignored" stored="false" indexed="false" class="solr.StrField"/>
+
+  <field name="id" type="string" indexed="true" stored="true" required="true"/>
+  <field name="desc" type="string" indexed="true" stored="true" multiValued="true"/>
+  <field name="date" type="date" indexed="true" stored="true"/>
+  <field name="timestamp" type="date" indexed="true" stored="true" default="NOW" multiValued="false"/>
+
+  <field name="NAME" type="text" indexed="true" stored="true" multiValued="false"/>
+  <field name="COUNTRY_NAME" type="text" indexed="true" stored="true" multiValued="true"/>
+  <field name="SPORT_NAME" type="text" indexed="true" stored="true" multiValued="true"/>
+  <field name="DO_NOT_INDEX" type="ignored"/>
+
+  <field name="_version_" type="tlong" indexed="true" stored="true" multiValued="false"/>
+  <field name="_root_" type="string" indexed="true" stored="true" multiValued="false"/>
+
+  <dynamicField name="*_i" type="tint" indexed="true" stored="true"/>
+  <dynamicField name="*_s" type="string" indexed="true" stored="true"/>
+  <dynamicField name="*_mult_s" type="string" indexed="true" stored="true" multiValued="true"/>
+  <dynamicField name="*_l" type="tlong" indexed="true" stored="true"/>
+  <dynamicField name="*_t" type="text" indexed="true" stored="true"/>
+  <dynamicField name="*_b" type="boolean" indexed="true" stored="true"/>
+  <dynamicField name="*_f" type="tfloat" indexed="true" stored="true"/>
+  <dynamicField name="*_d" type="tdouble" indexed="true" stored="true"/>
+  <dynamicField name="*_dt" type="date" indexed="true" stored="true"/>
+
   <uniqueKey>id</uniqueKey>
   <defaultSearchField>desc</defaultSearchField>
   <solrQueryParser defaultOperator="OR"/>
diff --git a/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/dataimport-solr_id-schema.xml b/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/dataimport-solr_id-schema.xml
index d8cb73b..9a95797 100644
--- a/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/dataimport-solr_id-schema.xml
+++ b/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/dataimport-solr_id-schema.xml
@@ -37,273 +37,271 @@
        1.0: multiValued attribute did not exist, all fields are multiValued by nature
        1.1: multiValued attribute introduced, false by default -->
 
-  <types>
-    <!-- field type definitions. The "name" attribute is
-       just a label to be used by field definitions.  The "class"
-       attribute and any other attributes determine the real
-       behavior of the fieldType.
-         Class names starting with "solr" refer to java classes in the
-       org.apache.solr.analysis package.
-    -->
 
-    <!-- The StrField type is not analyzed, but indexed/stored verbatim.  
-       - StrField and TextField support an optional compressThreshold which
-       limits compression (if enabled in the derived fields) to values which
-       exceed a certain size (in characters).
-    -->
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true" omitNorms="true"/>
-
-    <!-- boolean type: "true" or "false" -->
-    <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true" omitNorms="true"/>
-
-    <!-- The optional sortMissingLast and sortMissingFirst attributes are
-         currently supported on types that are sorted internally as strings.
-       - If sortMissingLast="true", then a sort on this field will cause documents
-         without the field to come after documents with the field,
-         regardless of the requested sort order (asc or desc).
-       - If sortMissingFirst="true", then a sort on this field will cause documents
-         without the field to come before documents with the field,
-         regardless of the requested sort order.
-       - If sortMissingLast="false" and sortMissingFirst="false" (the default),
-         then default lucene sorting will be used which places docs without the
-         field first in an ascending sort and last in a descending sort.
+  <!-- field type definitions. The "name" attribute is
+     just a label to be used by field definitions.  The "class"
+     attribute and any other attributes determine the real
+     behavior of the fieldType.
+       Class names starting with "solr" refer to java classes in the
+     org.apache.solr.analysis package.
+  -->
+
+  <!-- The StrField type is not analyzed, but indexed/stored verbatim.  
+     - StrField and TextField support an optional compressThreshold which
+     limits compression (if enabled in the derived fields) to values which
+     exceed a certain size (in characters).
+  -->
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true" omitNorms="true"/>
+
+  <!-- boolean type: "true" or "false" -->
+  <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true" omitNorms="true"/>
+
+  <!-- The optional sortMissingLast and sortMissingFirst attributes are
+       currently supported on types that are sorted internally as strings.
+     - If sortMissingLast="true", then a sort on this field will cause documents
+       without the field to come after documents with the field,
+       regardless of the requested sort order (asc or desc).
+     - If sortMissingFirst="true", then a sort on this field will cause documents
+       without the field to come before documents with the field,
+       regardless of the requested sort order.
+     - If sortMissingLast="false" and sortMissingFirst="false" (the default),
+       then default lucene sorting will be used which places docs without the
+       field first in an ascending sort and last in a descending sort.
+  -->
+
+
+  <!--
+    Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
+  -->
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
+
+  <!--
+   Numeric field types that index each value at various levels of precision
+   to accelerate range queries when the number of values between the range
+   endpoints is large. See the javadoc for LegacyNumericRangeQuery for internal
+   implementation details.
+
+   Smaller precisionStep values (specified in bits) will lead to more tokens
+   indexed per value, slightly larger index size, and faster range queries.
+   A precisionStep of 0 disables indexing at different precision levels.
+  -->
+  <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
+
+
+  <!-- The format for this date field is of the form 1995-12-31T23:59:59Z, and
+       is a more restricted form of the canonical representation of dateTime
+       http://www.w3.org/TR/xmlschema-2/#dateTime    
+       The trailing "Z" designates UTC time and is mandatory.
+       Optional fractional seconds are allowed: 1995-12-31T23:59:59.999Z
+       All other components are mandatory.
+
+       Expressions can also be used to denote calculations that should be
+       performed relative to "NOW" to determine the value, ie...
+
+             NOW/HOUR
+                ... Round to the start of the current hour
+             NOW-1DAY
+                ... Exactly 1 day prior to now
+             NOW/DAY+6MONTHS+3DAYS
+                ... 6 months and 3 days in the future from the start of
+                    the current day
+                    
+       Consult the TrieDateField javadocs for more information.
     -->
+  <fieldType name="date" class="solr.TrieDateField" sortMissingLast="true" omitNorms="true"/>
+
+
+  <!-- The "RandomSortField" is not used to store or search any
+       data.  You can declare fields of this type it in your schema
+       to generate psuedo-random orderings of your docs for sorting 
+       purposes.  The ordering is generated based on the field name 
+       and the version of the index, As long as the index version
+       remains unchanged, and the same field name is reused,
+       the ordering of the docs will be consistent.  
+       If you want differend psuedo-random orderings of documents,
+       for the same version of the index, use a dynamicField and
+       change the name
+   -->
+  <fieldType name="random" class="solr.RandomSortField" indexed="true"/>
 
+  <!-- solr.TextField allows the specification of custom text analyzers
+       specified as a tokenizer and a list of token filters. Different
+       analyzers may be specified for indexing and querying.
 
-    <!--
-      Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
-    -->
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
-
-    <!--
-     Numeric field types that index each value at various levels of precision
-     to accelerate range queries when the number of values between the range
-     endpoints is large. See the javadoc for LegacyNumericRangeQuery for internal
-     implementation details.
-
-     Smaller precisionStep values (specified in bits) will lead to more tokens
-     indexed per value, slightly larger index size, and faster range queries.
-     A precisionStep of 0 disables indexing at different precision levels.
-    -->
-    <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
-
-
-    <!-- The format for this date field is of the form 1995-12-31T23:59:59Z, and
-         is a more restricted form of the canonical representation of dateTime
-         http://www.w3.org/TR/xmlschema-2/#dateTime    
-         The trailing "Z" designates UTC time and is mandatory.
-         Optional fractional seconds are allowed: 1995-12-31T23:59:59.999Z
-         All other components are mandatory.
-
-         Expressions can also be used to denote calculations that should be
-         performed relative to "NOW" to determine the value, ie...
-
-               NOW/HOUR
-                  ... Round to the start of the current hour
-               NOW-1DAY
-                  ... Exactly 1 day prior to now
-               NOW/DAY+6MONTHS+3DAYS
-                  ... 6 months and 3 days in the future from the start of
-                      the current day
-                      
-         Consult the TrieDateField javadocs for more information.
+       The optional positionIncrementGap puts space between multiple fields of
+       this type on the same document, with the purpose of preventing false phrase
+       matching across fields.
+
+       For more info on customizing your analyzer chain, please see
+       http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters
+   -->
+
+  <!-- One can also specify an existing Analyzer class that has a
+       default constructor via the class attribute on the analyzer element
+  <fieldType name="text_greek" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.el.GreekAnalyzer"/>
+  </fieldType>
+  -->
+
+  <!-- A text field that only splits on whitespace for exact matching of words -->
+  <fieldType name="text_ws" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- A text field that uses WordDelimiterFilter to enable splitting and matching of
+      words on case-change, alpha numeric boundaries, and non-alphanumeric chars,
+      so that a query of "wifi" or "wi fi" could match a document containing "Wi-Fi".
+      Synonyms and stopwords are customized by external files, and stemming is enabled.
+      Duplicate tokens at the same position (which may result from Stemmed Synonyms or
+      WordDelim parts) are removed.
       -->
-    <fieldType name="date" class="solr.TrieDateField" sortMissingLast="true" omitNorms="true"/>
-
-
-    <!-- The "RandomSortField" is not used to store or search any
-         data.  You can declare fields of this type it in your schema
-         to generate psuedo-random orderings of your docs for sorting 
-         purposes.  The ordering is generated based on the field name 
-         and the version of the index, As long as the index version
-         remains unchanged, and the same field name is reused,
-         the ordering of the docs will be consistent.  
-         If you want differend psuedo-random orderings of documents,
-         for the same version of the index, use a dynamicField and
-         change the name
-     -->
-    <fieldType name="random" class="solr.RandomSortField" indexed="true" />
-
-    <!-- solr.TextField allows the specification of custom text analyzers
-         specified as a tokenizer and a list of token filters. Different
-         analyzers may be specified for indexing and querying.
-
-         The optional positionIncrementGap puts space between multiple fields of
-         this type on the same document, with the purpose of preventing false phrase
-         matching across fields.
-
-         For more info on customizing your analyzer chain, please see
-         http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters
-     -->
-
-    <!-- One can also specify an existing Analyzer class that has a
-         default constructor via the class attribute on the analyzer element
-    <fieldType name="text_greek" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.el.GreekAnalyzer"/>
-    </fieldType>
+  <fieldType name="text" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <!-- in this example, we will only use synonyms at query time
+      <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
+      -->
+      <!--<filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>-->
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <!--<filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>-->
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <!--<filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>-->
+      <!--<filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>-->
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <!--<filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>-->
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <!-- Less flexible matching, but less false matches.  Probably not ideal for product names,
+       but may be good for SKUs.  Can insert dashes in the wrong place and still match. -->
+  <fieldType name="textTight" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <!--<filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="false"/>-->
+      <!--<filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>-->
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <!--<filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.EnglishMinimalStemFilterFactory"/>-->
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- This is an example of using the KeywordTokenizer along
+       With various TokenFilterFactories to produce a sortable field
+       that does not include some properties of the source text
     -->
-
-    <!-- A text field that only splits on whitespace for exact matching of words -->
-    <fieldType name="text_ws" class="solr.TextField" positionIncrementGap="100">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- A text field that uses WordDelimiterFilter to enable splitting and matching of
-        words on case-change, alpha numeric boundaries, and non-alphanumeric chars,
-        so that a query of "wifi" or "wi fi" could match a document containing "Wi-Fi".
-        Synonyms and stopwords are customized by external files, and stemming is enabled.
-        Duplicate tokens at the same position (which may result from Stemmed Synonyms or
-        WordDelim parts) are removed.
+  <fieldType name="alphaOnlySort" class="solr.TextField" sortMissingLast="true" omitNorms="true">
+    <analyzer>
+      <!-- KeywordTokenizer does no actual tokenizing, so the entire
+           input string is preserved as a single token
         -->
-    <fieldType name="text" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <!-- in this example, we will only use synonyms at query time
-        <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+      <!-- The LowerCase TokenFilter does what you expect, which can be
+           when you want your sorting to be case insensitive
         -->
-        <!--<filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>-->
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <!--<filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>-->
-        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <!--<filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>-->
-        <!--<filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>-->
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <!--<filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>-->
-        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <!-- Less flexible matching, but less false matches.  Probably not ideal for product names,
-         but may be good for SKUs.  Can insert dashes in the wrong place and still match. -->
-    <fieldType name="textTight" class="solr.TextField" positionIncrementGap="100" >
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <!--<filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="false"/>-->
-        <!--<filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>-->
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <!--<filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.EnglishMinimalStemFilterFactory"/>-->
-        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- This is an example of using the KeywordTokenizer along
-         With various TokenFilterFactories to produce a sortable field
-         that does not include some properties of the source text
-      -->
-    <fieldType name="alphaOnlySort" class="solr.TextField" sortMissingLast="true" omitNorms="true">
-      <analyzer>
-        <!-- KeywordTokenizer does no actual tokenizing, so the entire
-             input string is preserved as a single token
-          -->
-        <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
-        <!-- The LowerCase TokenFilter does what you expect, which can be
-             when you want your sorting to be case insensitive
-          -->
-        <filter class="solr.LowerCaseFilterFactory" />
-        <!-- The TrimFilter removes any leading or trailing whitespace -->
-        <filter class="solr.TrimFilterFactory" />
-        <!-- The PatternReplaceFilter gives you the flexibility to use
-             Java Regular expression to replace any sequence of characters
-             matching a pattern with an arbitrary replacement string, 
-             which may include back refrences to portions of the orriginal
-             string matched by the pattern.
-             
-             See the Java Regular Expression documentation for more
-             infomation on pattern and replacement string syntax.
-             
-             http://docs.oracle.com/javase/8/docs/api/java/util/regex/package-summary.html
-          -->
-        <filter class="solr.PatternReplaceFilterFactory"
-                pattern="([^a-z])" replacement="" replace="all"
-        />
-      </analyzer>
-    </fieldType>
-
-    <!-- since fields of this type are by default not stored or indexed, any data added to 
-         them will be ignored outright 
-     --> 
-    <fieldType name="ignored" stored="false" indexed="false" class="solr.StrField" /> 
-
- </types>
-
-
- <fields>
-   <!-- Valid attributes for fields:
-     name: mandatory - the name for the field
-     type: mandatory - the name of a previously defined type from the <types> section
-     indexed: true if this field should be indexed (searchable or sortable)
-     stored: true if this field should be retrievable
-     multiValued: true if this field may contain multiple values per document
-     omitNorms: (expert) set to true to omit the norms associated with
-       this field (this disables length normalization and index-time
-       boosting for the field, and saves some memory).  Only full-text
-       fields or fields that need an index-time boost need norms.
-     termVectors: [false] set to true to store the term vector for a given field.
-       When using MoreLikeThis, fields used for similarity should be stored for 
-       best performance.
-   -->
-
-   <field name="solr_id" type="string" indexed="true" stored="true" required="true" />
-   <field name="desc" type="string" indexed="true" stored="true" multiValued="true" />
-   
-   <field name="date" type="date" indexed="true" stored="true" />
-
-   <field name="timestamp" type="date" indexed="true" stored="true" default="NOW" multiValued="false"/>
-   
-
-   <!-- Dynamic field definitions.  If a field name is not found, dynamicFields
-        will be used if the name matches any of the patterns.
-        RESTRICTION: the glob-like pattern in the name attribute must have
-        a "*" only at the start or the end.
-        EXAMPLE:  name="*_i" will match any field ending in _i (like myid_i, z_i)
-        Longer patterns will be matched first.  if equal size patterns
-        both match, the first appearing in the schema will be used.  -->
-   <dynamicField name="*_i"  type="int"    indexed="true"  stored="true"/>
-   <dynamicField name="*_s"  type="string"  indexed="true"  stored="true"/>
-   <dynamicField name="*_l"  type="long"   indexed="true"  stored="true"/>
-   <dynamicField name="*_t"  type="text"    indexed="true"  stored="true"/>
-   <dynamicField name="*_b"  type="boolean" indexed="true"  stored="true"/>
-   <dynamicField name="*_f"  type="float"  indexed="true"  stored="true"/>
-   <dynamicField name="*_d"  type="double" indexed="true"  stored="true"/>
-   <dynamicField name="*_dt" type="date"    indexed="true"  stored="true"/>
-
-   <dynamicField name="random*" type="random" />
-
-   <!-- uncomment the following to ignore any fields that don't already match an existing 
-        field name or dynamic field, rather than reporting them as an error. 
-        alternately, change the type="ignored" to some other type e.g. "text" if you want 
-        unknown fields indexed and/or stored by default --> 
-   <!--dynamicField name="*" type="ignored" /-->
-   
- </fields>
-
- <!-- Field to use to determine and enforce document uniqueness. 
-      Unless this field is marked with required="false", it will be a required field
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <!-- The TrimFilter removes any leading or trailing whitespace -->
+      <filter class="solr.TrimFilterFactory"/>
+      <!-- The PatternReplaceFilter gives you the flexibility to use
+           Java Regular expression to replace any sequence of characters
+           matching a pattern with an arbitrary replacement string, 
+           which may include back refrences to portions of the orriginal
+           string matched by the pattern.
+           
+           See the Java Regular Expression documentation for more
+           infomation on pattern and replacement string syntax.
+           
+           http://docs.oracle.com/javase/8/docs/api/java/util/regex/package-summary.html
+        -->
+      <filter class="solr.PatternReplaceFilterFactory"
+              pattern="([^a-z])" replacement="" replace="all"
+      />
+    </analyzer>
+  </fieldType>
+
+  <!-- since fields of this type are by default not stored or indexed, any data added to 
+       them will be ignored outright 
    -->
- <uniqueKey>solr_id</uniqueKey>
+  <fieldType name="ignored" stored="false" indexed="false" class="solr.StrField"/>
+
+  <!-- Valid attributes for fields:
+    name: mandatory - the name for the field
+    type: mandatory - the name of a previously defined type from the <fieldType>s
+    indexed: true if this field should be indexed (searchable or sortable)
+    stored: true if this field should be retrievable
+    multiValued: true if this field may contain multiple values per document
+    omitNorms: (expert) set to true to omit the norms associated with
+      this field (this disables length normalization and index-time
+      boosting for the field, and saves some memory).  Only full-text
+      fields or fields that need an index-time boost need norms.
+    termVectors: [false] set to true to store the term vector for a given field.
+      When using MoreLikeThis, fields used for similarity should be stored for 
+      best performance.
+  -->
+
+  <field name="solr_id" type="string" indexed="true" stored="true" required="true"/>
+  <field name="desc" type="string" indexed="true" stored="true" multiValued="true"/>
+
+  <field name="date" type="date" indexed="true" stored="true"/>
+
+  <field name="timestamp" type="date" indexed="true" stored="true" default="NOW" multiValued="false"/>
+
+
+  <!-- Dynamic field definitions.  If a field name is not found, dynamicFields
+       will be used if the name matches any of the patterns.
+       RESTRICTION: the glob-like pattern in the name attribute must have
+       a "*" only at the start or the end.
+       EXAMPLE:  name="*_i" will match any field ending in _i (like myid_i, z_i)
+       Longer patterns will be matched first.  if equal size patterns
+       both match, the first appearing in the schema will be used.  -->
+  <dynamicField name="*_i" type="int" indexed="true" stored="true"/>
+  <dynamicField name="*_s" type="string" indexed="true" stored="true"/>
+  <dynamicField name="*_l" type="long" indexed="true" stored="true"/>
+  <dynamicField name="*_t" type="text" indexed="true" stored="true"/>
+  <dynamicField name="*_b" type="boolean" indexed="true" stored="true"/>
+  <dynamicField name="*_f" type="float" indexed="true" stored="true"/>
+  <dynamicField name="*_d" type="double" indexed="true" stored="true"/>
+  <dynamicField name="*_dt" type="date" indexed="true" stored="true"/>
+
+  <dynamicField name="random*" type="random"/>
+
+  <!-- uncomment the following to ignore any fields that don't already match an existing 
+       field name or dynamic field, rather than reporting them as an error. 
+       alternately, change the type="ignored" to some other type e.g. "text" if you want 
+       unknown fields indexed and/or stored by default -->
+  <!--dynamicField name="*" type="ignored" /-->
+
+
+  <!-- Field to use to determine and enforce document uniqueness. 
+       Unless this field is marked with required="false", it will be a required field
+    -->
+  <uniqueKey>solr_id</uniqueKey>
 
- <!-- field for the QueryParser to use when an explicit fieldname is absent -->
- <defaultSearchField>desc</defaultSearchField>
+  <!-- field for the QueryParser to use when an explicit fieldname is absent -->
+  <defaultSearchField>desc</defaultSearchField>
 
- <!-- SolrQueryParser configuration: defaultOperator="AND|OR" -->
- <solrQueryParser defaultOperator="OR"/>
+  <!-- SolrQueryParser configuration: defaultOperator="AND|OR" -->
+  <solrQueryParser defaultOperator="OR"/>
 
 </schema>
diff --git a/solr/contrib/extraction/src/test-files/extraction/solr/collection1/conf/schema.xml b/solr/contrib/extraction/src/test-files/extraction/solr/collection1/conf/schema.xml
index e3dc2a8..35d123f 100644
--- a/solr/contrib/extraction/src/test-files/extraction/solr/collection1/conf/schema.xml
+++ b/solr/contrib/extraction/src/test-files/extraction/solr/collection1/conf/schema.xml
@@ -26,427 +26,442 @@
   -->
 
 <schema name="test" version="1.0">
-  <types>
 
-    <!--
-      Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
+
+  <!--
+    Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
+  -->
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
+
+  <!--
+   Numeric field types that index each value at various levels of precision
+   to accelerate range queries when the number of values between the range
+   endpoints is large. See the javadoc for LegacyNumericRangeQuery for internal
+   implementation details.
+
+   Smaller precisionStep values (specified in bits) will lead to more tokens
+   indexed per value, slightly larger index size, and faster range queries.
+   A precisionStep of 0 disables indexing at different precision levels.
+  -->
+  <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
+
+  <!-- Field type demonstrating an Analyzer failure -->
+  <fieldType name="failtype1" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0"
+              catenateNumbers="0" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Demonstrating ignoreCaseChange -->
+  <fieldType name="wdf_nocase" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="wdf_preserve" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <!-- HighlitText optimizes storage for (long) columns which will be highlit -->
+  <fieldType name="highlittext" class="solr.TextField" compressThreshold="345"/>
+
+  <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+
+  <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
+       seconds part (.999) is optional.
     -->
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
-
-    <!--
-     Numeric field types that index each value at various levels of precision
-     to accelerate range queries when the number of values between the range
-     endpoints is large. See the javadoc for LegacyNumericRangeQuery for internal
-     implementation details.
-
-     Smaller precisionStep values (specified in bits) will lead to more tokens
-     indexed per value, slightly larger index size, and faster range queries.
-     A precisionStep of 0 disables indexing at different precision levels.
+  <fieldType name="date" class="solr.TrieDateField" sortMissingLast="true" omitNorms="true"/>
+
+  <!-- solr.TextField allows the specification of custom
+       text analyzers specified as a tokenizer and a list
+       of token filters.
     -->
-    <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
-
-    <!-- Field type demonstrating an Analyzer failure -->
-    <fieldType name="failtype1" class="solr.TextField">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- Demonstrating ignoreCaseChange -->
-    <fieldType name="wdf_nocase" class="solr.TextField">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    
-     <fieldType name="wdf_preserve" class="solr.TextField">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="1"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <!-- HighlitText optimizes storage for (long) columns which will be highlit -->
-    <fieldType name="highlittext" class="solr.TextField" compressThreshold="345" />
-
-    <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
-
-    <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
-         seconds part (.999) is optional.
-      -->
-    <fieldType name="date" class="solr.TrieDateField" sortMissingLast="true" omitNorms="true"/>
-
-    <!-- solr.TextField allows the specification of custom
-         text analyzers specified as a tokenizer and a list
-         of token filters.
-      -->
-    <fieldType name="text" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.ClassicTokenizerFactory"/>
-        <filter class="solr.ClassicFilterFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <fieldType name="nametext" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.core.WhitespaceAnalyzer"/>
-    </fieldType>
-
-    <fieldType name="teststop" class="solr.TextField">
-       <analyzer>
-        <tokenizer class="solr.LowerCaseTokenizerFactory"/>
-        <filter class="solr.ClassicFilterFactory"/>
-        <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- fieldTypes in this section isolate tokenizers and tokenfilters for testing -->
-    <fieldType name="lowertok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.LowerCaseTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="keywordtok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/></analyzer>
-    </fieldType>
-    <fieldType name="standardtok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.StandardTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="lettertok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.LetterTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="whitetok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.MockTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="HTMLstandardtok" class="solr.TextField">
-      <analyzer>
+  <fieldType name="text" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.ClassicTokenizerFactory"/>
+      <filter class="solr.ClassicFilterFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <fieldType name="nametext" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.core.WhitespaceAnalyzer"/>
+  </fieldType>
+
+  <fieldType name="teststop" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LowerCaseTokenizerFactory"/>
+      <filter class="solr.ClassicFilterFactory"/>
+      <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- fieldTypes in this section isolate tokenizers and tokenfilters for testing -->
+  <fieldType name="lowertok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LowerCaseTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="keywordtok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="standardtok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="lettertok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LetterTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="whitetok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="HTMLstandardtok" class="solr.TextField">
+    <analyzer>
       <charFilter class="solr.HTMLStripCharFilterFactory"/>
       <tokenizer class="solr.StandardTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="HTMLwhitetok" class="solr.TextField">
-      <analyzer>
+    </analyzer>
+  </fieldType>
+  <fieldType name="HTMLwhitetok" class="solr.TextField">
+    <analyzer>
       <charFilter class="solr.HTMLStripCharFilterFactory"/>
       <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="standardtokfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.ClassicTokenizerFactory"/>
-        <filter class="solr.ClassicFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="standardfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.ClassicFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="lowerfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="patternreplacefilt" class="solr.TextField">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
-        <filter class="solr.PatternReplaceFilterFactory"
-                pattern="([^a-zA-Z])" replacement="_" replace="all"
-        />
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="porterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <!-- fieldType name="snowballfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.SnowballPorterFilterFactory"/>
-      </analyzer>
-    </fieldType -->
-    <fieldType name="engporterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="custengporterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="stopfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="custstopfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="lengthfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LengthFilterFactory" min="2" max="5"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="subword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.StopFilterFactory"/>
-          <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.StopFilterFactory"/>
-          <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- more flexible in matching skus, but more chance of a false match -->
-    <fieldType name="skutype1" class="solr.TextField">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- less flexible in matching skus, but less chance of a false match -->
-    <fieldType name="skutype2" class="solr.TextField">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- less flexible in matching skus, but less chance of a false match -->
-    <fieldType name="syn" class="solr.TextField">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Demonstrates How RemoveDuplicatesTokenFilter makes stemmed
-         synonyms "better"
-      -->
-    <fieldType name="dedup" class="solr.TextField">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.SynonymFilterFactory"
-                  synonyms="synonyms.txt" expand="true" />
-          <filter class="solr.PorterStemFilterFactory"/>
-          <filter class="solr.RemoveDuplicatesTokenFilterFactory" />
-      </analyzer>
-    </fieldType>
-
-    <fieldType  name="unstored" class="solr.StrField" indexed="true" stored="false"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="standardtokfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.ClassicTokenizerFactory"/>
+      <filter class="solr.ClassicFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="standardfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.ClassicFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="lowerfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="patternreplacefilt" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+      <filter class="solr.PatternReplaceFilterFactory"
+              pattern="([^a-zA-Z])" replacement="_" replace="all"
+      />
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="porterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <!-- fieldType name="snowballfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SnowballPorterFilterFactory"/>
+    </analyzer>
+  </fieldType -->
+  <fieldType name="engporterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="custengporterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="stopfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="custstopfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="lengthfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LengthFilterFactory" min="2" max="5"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="subword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- more flexible in matching skus, but more chance of a false match -->
+  <fieldType name="skutype1" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- less flexible in matching skus, but less chance of a false match -->
+  <fieldType name="skutype2" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- less flexible in matching skus, but less chance of a false match -->
+  <fieldType name="syn" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Demonstrates How RemoveDuplicatesTokenFilter makes stemmed
+       synonyms "better"
+    -->
+  <fieldType name="dedup" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory"
+              synonyms="synonyms.txt" expand="true"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="unstored" class="solr.StrField" indexed="true" stored="false"/>
 
 
   <fieldType name="textgap" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
   </fieldType>
 
- </types>
-
-
- <fields>
-   <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="false"/>
-   <field name="name" type="nametext" indexed="true" stored="true"/>
-   <field name="text" type="text" indexed="true" stored="false"/>
-   <field name="subject" type="text" indexed="true" stored="true"/>
-   <field name="title" type="nametext" indexed="true" stored="true"/>
-   <field name="weight" type="float" indexed="true" stored="true"/>
-   <field name="bday" type="date" indexed="true" stored="true"/>
-
-   <field name="title_stemmed" type="text" indexed="true" stored="false"/>
-   <field name="title_lettertok" type="lettertok" indexed="true" stored="false"/>
-
-   <field name="syn" type="syn" indexed="true" stored="true"/>
-
-   <!-- to test property inheritance and overriding -->
-   <field name="shouldbeunstored" type="unstored" />
-   <field name="shouldbestored" type="unstored" stored="true"/>
-   <field name="shouldbeunindexed" type="unstored" indexed="false" stored="true"/>
-
-
-   <!-- test different combinations of indexed and stored -->
-   <field name="bind" type="boolean" indexed="true" stored="false"/>
-   <field name="bsto" type="boolean" indexed="false" stored="true"/>
-   <field name="bindsto" type="boolean" indexed="true" stored="true"/>
-   <field name="isto" type="int" indexed="false" stored="true"/>
-   <field name="iind" type="int" indexed="true" stored="false"/>
-   <field name="ssto" type="string" indexed="false" stored="true"/>
-   <field name="sind" type="string" indexed="true" stored="false"/>
-   <field name="sindsto" type="string" indexed="true" stored="true"/>
-
-   <!-- test combinations of term vector settings -->
-   <field name="test_basictv" type="text" termVectors="true"/>
-   <field name="test_notv" type="text" termVectors="false"/>
-   <field name="test_postv" type="text" termVectors="true" termPositions="true"/>
-   <field name="test_offtv" type="text" termVectors="true" termOffsets="true"/>
-   <field name="test_posofftv" type="text" termVectors="true" 
-     termPositions="true" termOffsets="true"/>
-
-   <!-- test highlit field settings -->
-   <field name="test_hlt" type="highlittext" indexed="true"/>
-   <field name="test_hlt_off" type="highlittext" indexed="true"/>
-
-   <!-- fields to test individual tokenizers and tokenfilters -->
-   <field name="teststop" type="teststop" indexed="true" stored="true"/>
-   <field name="lowertok" type="lowertok" indexed="true" stored="true"/>
-   <field name="keywordtok" type="keywordtok" indexed="true" stored="true"/>
-   <field name="standardtok" type="standardtok" indexed="true" stored="true"/>
-   <field name="HTMLstandardtok" type="HTMLstandardtok" indexed="true" stored="true"/>
-   <field name="lettertok" type="lettertok" indexed="true" stored="true"/>
-   <field name="whitetok" type="whitetok" indexed="true" stored="true"/>
-   <field name="HTMLwhitetok" type="HTMLwhitetok" indexed="true" stored="true"/>
-   <field name="standardtokfilt" type="standardtokfilt" indexed="true" stored="true"/>
-   <field name="standardfilt" type="standardfilt" indexed="true" stored="true"/>
-   <field name="lowerfilt" type="lowerfilt" indexed="true" stored="true"/>
-   <field name="patternreplacefilt" type="patternreplacefilt" indexed="true" stored="true"/>
-   <field name="porterfilt" type="porterfilt" indexed="true" stored="true"/>
-   <field name="engporterfilt" type="engporterfilt" indexed="true" stored="true"/>
-   <field name="custengporterfilt" type="custengporterfilt" indexed="true" stored="true"/>
-   <field name="stopfilt" type="stopfilt" indexed="true" stored="true"/>
-   <field name="custstopfilt" type="custstopfilt" indexed="true" stored="true"/>
-   <field name="lengthfilt" type="lengthfilt" indexed="true" stored="true"/>
-   <field name="dedup" type="dedup" indexed="true" stored="true"/>
-   <field name="wdf_nocase" type="wdf_nocase" indexed="true" stored="true"/>
-   <field name="wdf_preserve" type="wdf_preserve" indexed="true" stored="true"/>
-
-   <field name="numberpartfail" type="failtype1" indexed="true" stored="true"/>
-
-   <field name="nullfirst" type="string" indexed="true" stored="true" sortMissingFirst="true"/>
-
-   <field name="subword" type="subword" indexed="true" stored="true"/>
-   <field name="sku1" type="skutype1" indexed="true" stored="true"/>
-   <field name="sku2" type="skutype2" indexed="true" stored="true"/>
-
-   <field name="textgap" type="textgap" indexed="true" stored="true"/>
-   
-   <field name="timestamp" type="date" indexed="true" stored="true" default="NOW" multiValued="false"/>
-   <field name="multiDefault" type="string" indexed="true" stored="true" default="muLti-Default" multiValued="true"/>
-   <field name="intDefault" type="int" indexed="true" stored="true" default="42" multiValued="false"/>
-   
-   <field name="extractedDate" type="date" indexed="true" stored="true" multiValued="true"/>
-   <field name="extractedContent" type="text" indexed="true" stored="true" multiValued="true"/>
-   <field name="extractedProducer" type="text" indexed="true" stored="true" multiValued="true"/>
-   <field name="extractedCreator" type="text" indexed="true" stored="true" multiValued="true"/>
-   <field name="extractedKeywords" type="text" indexed="true" stored="true" multiValued="true"/>
-   <field name="extractedAuthor" type="text" indexed="true" stored="true" multiValued="true"/>
-   <field name="extractedLanguage" type="string" indexed="true" stored="true" multiValued="true"/>
-   <field name="resourceName" type="string" indexed="true" stored="true" multiValued="true"/>
-
-   <field name="extractionLiteralMV" type="string" indexed="true" stored="true" multiValued="true"/>
-   <field name="extractionLiteral" type="string" indexed="true" stored="true" multiValued="false"/>
-
-   <field name="defaultExtr" type="string" indexed="true" stored="false" />
-   
-   <!-- Dynamic field definitions.  If a field name is not found, dynamicFields
-        will be used if the name matches any of the patterns.
-        RESTRICTION: the glob-like pattern in the name attribute must have
-        a "*" only at the start or the end.
-        EXAMPLE:  name="*_i" will match any field ending in _i (like myid_i, z_i)
-        Longer patterns will be matched first.  if equal size patterns
-        both match, the first appearing in the schema will be used.
-   -->
-   <dynamicField name="*_i"  type="int"    indexed="true"  stored="true"/>
-   <dynamicField name="*_s"  type="string"  indexed="true"  stored="true"/>
-   <dynamicField name="*_s1"  type="string"  indexed="true"  stored="true" multiValued="false"/>
-   <dynamicField name="*_l"  type="long"   indexed="true"  stored="true"/>
-   <dynamicField name="*_t"  type="text"    indexed="true"  stored="true"/>
-   <dynamicField name="*_b"  type="boolean" indexed="true"  stored="true"/>
-   <dynamicField name="*_f"  type="float"  indexed="true"  stored="true"/>
-   <dynamicField name="*_d"  type="double" indexed="true"  stored="true"/>
-   <dynamicField name="*_dt" type="date"    indexed="true"  stored="true"/>
-
-   <dynamicField name="*_sI" type="string"  indexed="true"  stored="false"/>
-   <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
-   <dynamicField name="t_*"  type="text"    indexed="true"  stored="true"/>
-   <dynamicField name="tv_*"  type="text" indexed="true"  stored="true" 
-      termVectors="true" termPositions="true" termOffsets="true"/>
-
-   <dynamicField name="stream_*"  type="text" indexed="true"  stored="true"/>
-   <dynamicField name="Content*"  type="text" indexed="true"  stored="true"/>
-
-
-   <!-- special fields for dynamic copyField test -->
-   <dynamicField name="dynamic_*" type="string" indexed="true" stored="true"/>
-   <dynamicField name="*_dynamic" type="string" indexed="true" stored="true"/>
-  
-   <!-- for testing to ensure that longer patterns are matched first -->
-   <dynamicField name="*aa"  type="string"  indexed="true" stored="true"/>
-   <dynamicField name="*aaa" type="int" indexed="false" stored="true"/>
-
-   <!-- ignored because not stored or indexed -->
-   <dynamicField name="ignored_*" type="text" indexed="false" stored="false"/>
-
- </fields>
-
- <defaultSearchField>text</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+
+  <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="name" type="nametext" indexed="true" stored="true"/>
+  <field name="text" type="text" indexed="true" stored="false"/>
+  <field name="subject" type="text" indexed="true" stored="true"/>
+  <field name="title" type="nametext" indexed="true" stored="true"/>
+  <field name="weight" type="float" indexed="true" stored="true"/>
+  <field name="bday" type="date" indexed="true" stored="true"/>
+
+  <field name="title_stemmed" type="text" indexed="true" stored="false"/>
+  <field name="title_lettertok" type="lettertok" indexed="true" stored="false"/>
+
+  <field name="syn" type="syn" indexed="true" stored="true"/>
+
+  <!-- to test property inheritance and overriding -->
+  <field name="shouldbeunstored" type="unstored"/>
+  <field name="shouldbestored" type="unstored" stored="true"/>
+  <field name="shouldbeunindexed" type="unstored" indexed="false" stored="true"/>
+
+
+  <!-- test different combinations of indexed and stored -->
+  <field name="bind" type="boolean" indexed="true" stored="false"/>
+  <field name="bsto" type="boolean" indexed="false" stored="true"/>
+  <field name="bindsto" type="boolean" indexed="true" stored="true"/>
+  <field name="isto" type="int" indexed="false" stored="true"/>
+  <field name="iind" type="int" indexed="true" stored="false"/>
+  <field name="ssto" type="string" indexed="false" stored="true"/>
+  <field name="sind" type="string" indexed="true" stored="false"/>
+  <field name="sindsto" type="string" indexed="true" stored="true"/>
+
+  <!-- test combinations of term vector settings -->
+  <field name="test_basictv" type="text" termVectors="true"/>
+  <field name="test_notv" type="text" termVectors="false"/>
+  <field name="test_postv" type="text" termVectors="true" termPositions="true"/>
+  <field name="test_offtv" type="text" termVectors="true" termOffsets="true"/>
+  <field name="test_posofftv" type="text" termVectors="true"
+         termPositions="true" termOffsets="true"/>
+
+  <!-- test highlit field settings -->
+  <field name="test_hlt" type="highlittext" indexed="true"/>
+  <field name="test_hlt_off" type="highlittext" indexed="true"/>
+
+  <!-- fields to test individual tokenizers and tokenfilters -->
+  <field name="teststop" type="teststop" indexed="true" stored="true"/>
+  <field name="lowertok" type="lowertok" indexed="true" stored="true"/>
+  <field name="keywordtok" type="keywordtok" indexed="true" stored="true"/>
+  <field name="standardtok" type="standardtok" indexed="true" stored="true"/>
+  <field name="HTMLstandardtok" type="HTMLstandardtok" indexed="true" stored="true"/>
+  <field name="lettertok" type="lettertok" indexed="true" stored="true"/>
+  <field name="whitetok" type="whitetok" indexed="true" stored="true"/>
+  <field name="HTMLwhitetok" type="HTMLwhitetok" indexed="true" stored="true"/>
+  <field name="standardtokfilt" type="standardtokfilt" indexed="true" stored="true"/>
+  <field name="standardfilt" type="standardfilt" indexed="true" stored="true"/>
+  <field name="lowerfilt" type="lowerfilt" indexed="true" stored="true"/>
+  <field name="patternreplacefilt" type="patternreplacefilt" indexed="true" stored="true"/>
+  <field name="porterfilt" type="porterfilt" indexed="true" stored="true"/>
+  <field name="engporterfilt" type="engporterfilt" indexed="true" stored="true"/>
+  <field name="custengporterfilt" type="custengporterfilt" indexed="true" stored="true"/>
+  <field name="stopfilt" type="stopfilt" indexed="true" stored="true"/>
+  <field name="custstopfilt" type="custstopfilt" indexed="true" stored="true"/>
+  <field name="lengthfilt" type="lengthfilt" indexed="true" stored="true"/>
+  <field name="dedup" type="dedup" indexed="true" stored="true"/>
+  <field name="wdf_nocase" type="wdf_nocase" indexed="true" stored="true"/>
+  <field name="wdf_preserve" type="wdf_preserve" indexed="true" stored="true"/>
+
+  <field name="numberpartfail" type="failtype1" indexed="true" stored="true"/>
+
+  <field name="nullfirst" type="string" indexed="true" stored="true" sortMissingFirst="true"/>
+
+  <field name="subword" type="subword" indexed="true" stored="true"/>
+  <field name="sku1" type="skutype1" indexed="true" stored="true"/>
+  <field name="sku2" type="skutype2" indexed="true" stored="true"/>
+
+  <field name="textgap" type="textgap" indexed="true" stored="true"/>
+
+  <field name="timestamp" type="date" indexed="true" stored="true" default="NOW" multiValued="false"/>
+  <field name="multiDefault" type="string" indexed="true" stored="true" default="muLti-Default" multiValued="true"/>
+  <field name="intDefault" type="int" indexed="true" stored="true" default="42" multiValued="false"/>
+
+  <field name="extractedDate" type="date" indexed="true" stored="true" multiValued="true"/>
+  <field name="extractedContent" type="text" indexed="true" stored="true" multiValued="true"/>
+  <field name="extractedProducer" type="text" indexed="true" stored="true" multiValued="true"/>
+  <field name="extractedCreator" type="text" indexed="true" stored="true" multiValued="true"/>
+  <field name="extractedKeywords" type="text" indexed="true" stored="true" multiValued="true"/>
+  <field name="extractedAuthor" type="text" indexed="true" stored="true" multiValued="true"/>
+  <field name="extractedLanguage" type="string" indexed="true" stored="true" multiValued="true"/>
+  <field name="resourceName" type="string" indexed="true" stored="true" multiValued="true"/>
+
+  <field name="extractionLiteralMV" type="string" indexed="true" stored="true" multiValued="true"/>
+  <field name="extractionLiteral" type="string" indexed="true" stored="true" multiValued="false"/>
+
+  <field name="defaultExtr" type="string" indexed="true" stored="false"/>
+
+  <!-- Dynamic field definitions.  If a field name is not found, dynamicFields
+       will be used if the name matches any of the patterns.
+       RESTRICTION: the glob-like pattern in the name attribute must have
+       a "*" only at the start or the end.
+       EXAMPLE:  name="*_i" will match any field ending in _i (like myid_i, z_i)
+       Longer patterns will be matched first.  if equal size patterns
+       both match, the first appearing in the schema will be used.
+  -->
+  <dynamicField name="*_i" type="int" indexed="true" stored="true"/>
+  <dynamicField name="*_s" type="string" indexed="true" stored="true"/>
+  <dynamicField name="*_s1" type="string" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_l" type="long" indexed="true" stored="true"/>
+  <dynamicField name="*_t" type="text" indexed="true" stored="true"/>
+  <dynamicField name="*_b" type="boolean" indexed="true" stored="true"/>
+  <dynamicField name="*_f" type="float" indexed="true" stored="true"/>
+  <dynamicField name="*_d" type="double" indexed="true" stored="true"/>
+  <dynamicField name="*_dt" type="date" indexed="true" stored="true"/>
+
+  <dynamicField name="*_sI" type="string" indexed="true" stored="false"/>
+  <dynamicField name="*_sS" type="string" indexed="false" stored="true"/>
+  <dynamicField name="t_*" type="text" indexed="true" stored="true"/>
+  <dynamicField name="tv_*" type="text" indexed="true" stored="true"
+                termVectors="true" termPositions="true" termOffsets="true"/>
+
+  <dynamicField name="stream_*" type="text" indexed="true" stored="true"/>
+  <dynamicField name="Content*" type="text" indexed="true" stored="true"/>
+
+
+  <!-- special fields for dynamic copyField test -->
+  <dynamicField name="dynamic_*" type="string" indexed="true" stored="true"/>
+  <dynamicField name="*_dynamic" type="string" indexed="true" stored="true"/>
+
+  <!-- for testing to ensure that longer patterns are matched first -->
+  <dynamicField name="*aa" type="string" indexed="true" stored="true"/>
+  <dynamicField name="*aaa" type="int" indexed="false" stored="true"/>
+
+  <!-- ignored because not stored or indexed -->
+  <dynamicField name="ignored_*" type="text" indexed="false" stored="false"/>
+
+
+  <defaultSearchField>text</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 
   <!-- copyField commands copy one field to another at the time a document
         is added to the index.  It's used either to index the same field different
         ways, or to add multiple fields to the same field for easier/faster searching.
    -->
-   <copyField source="title" dest="title_stemmed"/>
-   <copyField source="title" dest="title_lettertok"/>
-
-   <copyField source="title" dest="text"/>
-   <copyField source="subject" dest="text"/>
- 
-   <copyField source="*_t" dest="text"/>
-   
-   <!-- dynamic destination -->
-   <copyField source="*_dynamic" dest="dynamic_*"/>
-    
+  <copyField source="title" dest="title_stemmed"/>
+  <copyField source="title" dest="title_lettertok"/>
+
+  <copyField source="title" dest="text"/>
+  <copyField source="subject" dest="text"/>
+
+  <copyField source="*_t" dest="text"/>
+
+  <!-- dynamic destination -->
+  <copyField source="*_dynamic" dest="dynamic_*"/>
+
 
 </schema>
diff --git a/solr/contrib/langid/src/test-files/langid/solr/collection1/conf/schema.xml b/solr/contrib/langid/src/test-files/langid/solr/collection1/conf/schema.xml
index cb5a6e8..8fe71e9 100644
--- a/solr/contrib/langid/src/test-files/langid/solr/collection1/conf/schema.xml
+++ b/solr/contrib/langid/src/test-files/langid/solr/collection1/conf/schema.xml
@@ -26,53 +26,50 @@
   -->
 
 <schema name="test" version="1.6">
-  <types>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
-    <!-- solr.TextField allows the specification of custom
-         text analyzers specified as a tokenizer and a list
-         of token filters.
-      -->
-    <fieldType name="text" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="nametext" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.core.WhitespaceAnalyzer"/>
-    </fieldType>
- </types>
-
-
- <fields>
-   <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="false"/>
-   <field name="name" type="nametext" indexed="true" stored="true"/>
-   <field name="subject" type="text" indexed="true" stored="true"/>
-
-
-   <!-- Dynamic field definitions.  If a field name is not found, dynamicFields
-        will be used if the name matches any of the patterns.
-        RESTRICTION: the glob-like pattern in the name attribute must have
-        a "*" only at the start or the end.
-        EXAMPLE:  name="*_i" will match any field ending in _i (like myid_i, z_i)
-        Longer patterns will be matched first.  if equal size patterns
-        both match, the first appearing in the schema will be used.
-   -->
-   <dynamicField name="*_s"  type="string"  indexed="true"  stored="true"/>
-   <dynamicField name="*_sm"  type="string"  indexed="true"  stored="true" multiValued="true" />
-
-   <!-- Fields for language identification -->
-   <dynamicField name="name_*" type="string" indexed="true" stored="false"/>
-   <dynamicField name="subject_*" type="string" indexed="true" stored="false"/>
-
- </fields>
-
- <defaultSearchField>name</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+  <!-- solr.TextField allows the specification of custom
+       text analyzers specified as a tokenizer and a list
+       of token filters.
+    -->
+  <fieldType name="text" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="nametext" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.core.WhitespaceAnalyzer"/>
+  </fieldType>
+
+
+  <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="name" type="nametext" indexed="true" stored="true"/>
+  <field name="subject" type="text" indexed="true" stored="true"/>
+
+
+  <!-- Dynamic field definitions.  If a field name is not found, dynamicFields
+       will be used if the name matches any of the patterns.
+       RESTRICTION: the glob-like pattern in the name attribute must have
+       a "*" only at the start or the end.
+       EXAMPLE:  name="*_i" will match any field ending in _i (like myid_i, z_i)
+       Longer patterns will be matched first.  if equal size patterns
+       both match, the first appearing in the schema will be used.
+  -->
+  <dynamicField name="*_s" type="string" indexed="true" stored="true"/>
+  <dynamicField name="*_sm" type="string" indexed="true" stored="true" multiValued="true"/>
+
+  <!-- Fields for language identification -->
+  <dynamicField name="name_*" type="string" indexed="true" stored="false"/>
+  <dynamicField name="subject_*" type="string" indexed="true" stored="false"/>
+
+
+  <defaultSearchField>name</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 
 
 </schema>
diff --git a/solr/contrib/morphlines-core/src/test-files/solr/collection1/conf/schema.xml b/solr/contrib/morphlines-core/src/test-files/solr/collection1/conf/schema.xml
index 9e720b0..11c1f76 100644
--- a/solr/contrib/morphlines-core/src/test-files/solr/collection1/conf/schema.xml
+++ b/solr/contrib/morphlines-core/src/test-files/solr/collection1/conf/schema.xml
@@ -64,854 +64,855 @@
        1.6: useDocValuesAsStored defaults to true.
      -->
 
- <fields>
-   <!-- Valid attributes for fields:
-     name: mandatory - the name for the field
-     type: mandatory - the name of a field type from the 
-       <types> fieldType section
-     indexed: true if this field should be indexed (searchable or sortable)
-     stored: true if this field should be retrievable
-     multiValued: true if this field may contain multiple values per document
-     omitNorms: (expert) set to true to omit the norms associated with
-       this field (this disables length normalization and index-time
-       boosting for the field, and saves some memory).  Only full-text
-       fields or fields that need an index-time boost need norms.
-       Norms are omitted for primitive (non-analyzed) types by default.
-     termVectors: [false] set to true to store the term vector for a
-       given field.
-       When using MoreLikeThis, fields used for similarity should be
-       stored for best performance.
-     termPositions: Store position information with the term vector.  
-       This will increase storage costs.
-     termOffsets: Store offset information with the term vector. This 
-       will increase storage costs.
-     required: The field is required.  It will throw an error if the
-       value does not exist
-     default: a value that should be used if no value is specified
-       when adding a document.
-   -->
 
-   <!-- field names should consist of alphanumeric or underscore characters only and
-      not start with a digit.  This is not currently strictly enforced,
-      but other field names will not have first class support from all components
-      and back compatibility is not guaranteed.  Names with both leading and
-      trailing underscores (e.g. _version_) are reserved.
-   -->
-        
-   <field name="id" type="string" indexed="true" stored="true" required="true" multiValued="false" /> 
-   <field name="user_friends_count" type="tint" indexed="true" stored="true" />
-   <field name="user_location" type="lowercase" indexed="true" stored="true" />
-   <field name="user_description" type="text_en" indexed="true" stored="false"/>
-   <field name="user_statuses_count" type="tint" indexed="true" stored="true" />
-   <field name="user_followers_count" type="tint" indexed="true" stored="true"/>
-   <field name="user_name" type="text_en" indexed="true" stored="true" />
-   <field name="user_screen_name" type="text_en" indexed="true" stored="true" />
-   <field name="created_at" type="tdate" indexed="true" stored="true" />
-   <field name="text" type="text_en" indexed="true" stored="true" multiValued="true" />
-   <field name="retweet_count" type="tint" indexed="true" stored="true" />
-   <field name="retweeted" type="boolean" indexed="true" stored="false" />
-   <field name="in_reply_to_user_id" type="long" indexed="true" stored="true" />
-   <field name="source" type="lowercase" indexed="true" stored="true" />
-   <field name="in_reply_to_status_id" type="long" indexed="true" stored="true" multiValued="true"/>
-   <field name="media_url_https" type="string" indexed="false" stored="true" />
-   <field name="expanded_url" type="string" indexed="false" stored="true" />
-
-   <!-- file metadata -->   
-   <field name="file_download_url" type="string" indexed="false" stored="true" />
-   <field name="file_upload_url" type="string" indexed="false" stored="true" />
-   <field name="file_scheme" type="string" indexed="true" stored="true" />
-   <field name="file_host" type="string" indexed="true" stored="true" />
-   <field name="file_port" type="int" indexed="true" stored="true" />
-   <field name="file_path" type="string" indexed="true" stored="true" />
-   <field name="file_name" type="string" indexed="true" stored="true" />
-   <field name="file_length" type="tlong" indexed="true" stored="true" />
-   <field name="file_last_modified" type="tlong" indexed="true" stored="true" />
-   <field name="file_owner" type="string" indexed="true" stored="true" />
-   <field name="file_group" type="string" indexed="true" stored="true" />
-   <field name="file_permissions_user" type="string" indexed="true" stored="true" />
-   <field name="file_permissions_group" type="string" indexed="true" stored="true" />
-   <field name="file_permissions_other" type="string" indexed="true" stored="true" />
-   <field name="file_permissions_stickybit" type="boolean" indexed="true" stored="true" />
-
-   <!-- tika metadata -->
-   <field name="content_type" type="lowercase" indexed="true" stored="true" />
-
-   <field name="_version_" type="long" indexed="true" stored="true"/>
-   <dynamicField name="ignored_*" type="ignored"/>
-   
- </fields>
-
-
- <!-- Field to use to determine and enforce document uniqueness. 
-      Unless this field is marked with required="false", it will be a required field
-   -->
- <uniqueKey>id</uniqueKey>
-
- <!-- DEPRECATED: The defaultSearchField is consulted by various query parsers when
-  parsing a query string that isn't explicit about the field.  Machine (non-user)
-  generated queries are best made explicit, or they can use the "df" request parameter
-  which takes precedence over this.
-  Note: Un-commenting defaultSearchField will be insufficient if your request handler
-  in solrconfig.xml defines "df", which takes precedence. That would need to be removed.
- <defaultSearchField>text</defaultSearchField> -->
-
- <!-- DEPRECATED: The defaultOperator (AND|OR) is consulted by various query parsers
-  when parsing a query string to determine if a clause of the query should be marked as
-  required or optional, assuming the clause isn't already marked by some operator.
-  The default is OR, which is generally assumed so it is not a good idea to change it
-  globally here.  The "q.op" request parameter takes precedence over this.
- <solrQueryParser defaultOperator="OR"/> -->
+  <!-- Valid attributes for fields:
+    name: mandatory - the name for the field
+    type: mandatory - the name of a field type from the 
+      fieldType section
+    indexed: true if this field should be indexed (searchable or sortable)
+    stored: true if this field should be retrievable
+    multiValued: true if this field may contain multiple values per document
+    omitNorms: (expert) set to true to omit the norms associated with
+      this field (this disables length normalization and index-time
+      boosting for the field, and saves some memory).  Only full-text
+      fields or fields that need an index-time boost need norms.
+      Norms are omitted for primitive (non-analyzed) types by default.
+    termVectors: [false] set to true to store the term vector for a
+      given field.
+      When using MoreLikeThis, fields used for similarity should be
+      stored for best performance.
+    termPositions: Store position information with the term vector.  
+      This will increase storage costs.
+    termOffsets: Store offset information with the term vector. This 
+      will increase storage costs.
+    required: The field is required.  It will throw an error if the
+      value does not exist
+    default: a value that should be used if no value is specified
+      when adding a document.
+  -->
+
+  <!-- field names should consist of alphanumeric or underscore characters only and
+     not start with a digit.  This is not currently strictly enforced,
+     but other field names will not have first class support from all components
+     and back compatibility is not guaranteed.  Names with both leading and
+     trailing underscores (e.g. _version_) are reserved.
+  -->
+
+  <field name="id" type="string" indexed="true" stored="true" required="true" multiValued="false"/>
+  <field name="user_friends_count" type="tint" indexed="true" stored="true"/>
+  <field name="user_location" type="lowercase" indexed="true" stored="true"/>
+  <field name="user_description" type="text_en" indexed="true" stored="false"/>
+  <field name="user_statuses_count" type="tint" indexed="true" stored="true"/>
+  <field name="user_followers_count" type="tint" indexed="true" stored="true"/>
+  <field name="user_name" type="text_en" indexed="true" stored="true"/>
+  <field name="user_screen_name" type="text_en" indexed="true" stored="true"/>
+  <field name="created_at" type="tdate" indexed="true" stored="true"/>
+  <field name="text" type="text_en" indexed="true" stored="true" multiValued="true"/>
+  <field name="retweet_count" type="tint" indexed="true" stored="true"/>
+  <field name="retweeted" type="boolean" indexed="true" stored="false"/>
+  <field name="in_reply_to_user_id" type="long" indexed="true" stored="true"/>
+  <field name="source" type="lowercase" indexed="true" stored="true"/>
+  <field name="in_reply_to_status_id" type="long" indexed="true" stored="true" multiValued="true"/>
+  <field name="media_url_https" type="string" indexed="false" stored="true"/>
+  <field name="expanded_url" type="string" indexed="false" stored="true"/>
+
+  <!-- file metadata -->
+  <field name="file_download_url" type="string" indexed="false" stored="true"/>
+  <field name="file_upload_url" type="string" indexed="false" stored="true"/>
+  <field name="file_scheme" type="string" indexed="true" stored="true"/>
+  <field name="file_host" type="string" indexed="true" stored="true"/>
+  <field name="file_port" type="int" indexed="true" stored="true"/>
+  <field name="file_path" type="string" indexed="true" stored="true"/>
+  <field name="file_name" type="string" indexed="true" stored="true"/>
+  <field name="file_length" type="tlong" indexed="true" stored="true"/>
+  <field name="file_last_modified" type="tlong" indexed="true" stored="true"/>
+  <field name="file_owner" type="string" indexed="true" stored="true"/>
+  <field name="file_group" type="string" indexed="true" stored="true"/>
+  <field name="file_permissions_user" type="string" indexed="true" stored="true"/>
+  <field name="file_permissions_group" type="string" indexed="true" stored="true"/>
+  <field name="file_permissions_other" type="string" indexed="true" stored="true"/>
+  <field name="file_permissions_stickybit" type="boolean" indexed="true" stored="true"/>
+
+  <!-- tika metadata -->
+  <field name="content_type" type="lowercase" indexed="true" stored="true"/>
+
+  <field name="_version_" type="long" indexed="true" stored="true"/>
+  <dynamicField name="ignored_*" type="ignored"/>
+
+
+  <!-- Field to use to determine and enforce document uniqueness. 
+       Unless this field is marked with required="false", it will be a required field
+    -->
+  <uniqueKey>id</uniqueKey>
+
+  <!-- DEPRECATED: The defaultSearchField is consulted by various query parsers when
+   parsing a query string that isn't explicit about the field.  Machine (non-user)
+   generated queries are best made explicit, or they can use the "df" request parameter
+   which takes precedence over this.
+   Note: Un-commenting defaultSearchField will be insufficient if your request handler
+   in solrconfig.xml defines "df", which takes precedence. That would need to be removed.
+  <defaultSearchField>text</defaultSearchField> -->
+
+  <!-- DEPRECATED: The defaultOperator (AND|OR) is consulted by various query parsers
+   when parsing a query string to determine if a clause of the query should be marked as
+   required or optional, assuming the clause isn't already marked by some operator.
+   The default is OR, which is generally assumed so it is not a good idea to change it
+   globally here.  The "q.op" request parameter takes precedence over this.
+  <solrQueryParser defaultOperator="OR"/> -->
 
   <!-- copyField commands copy one field to another at the time a document
         is added to the index.  It's used either to index the same field differently,
         or to add multiple fields to the same field for easier/faster searching.  -->
 
-  
-  <types>
-    <!-- field type definitions. The "name" attribute is
-       just a label to be used by field definitions.  The "class"
-       attribute and any other attributes determine the real
-       behavior of the fieldType.
-         Class names starting with "solr" refer to java classes in a
-       standard package such as org.apache.solr.analysis
-    -->
 
-    <!-- The StrField type is not analyzed, but indexed/stored verbatim. -->
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true" />
-
-    <!-- boolean type: "true" or "false" -->
-    <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
-
-    <!-- sortMissingLast and sortMissingFirst attributes are optional attributes are
-         currently supported on types that are sorted internally as strings
-         and on numeric types.
-       This includes "string","boolean", and, as of 3.5 (and 4.x),
-       int, float, long, date, double, including the "Trie" variants.
-       - If sortMissingLast="true", then a sort on this field will cause documents
-         without the field to come after documents with the field,
-         regardless of the requested sort order (asc or desc).
-       - If sortMissingFirst="true", then a sort on this field will cause documents
-         without the field to come before documents with the field,
-         regardless of the requested sort order.
-       - If sortMissingLast="false" and sortMissingFirst="false" (the default),
-         then default lucene sorting will be used which places docs without the
-         field first in an ascending sort and last in a descending sort.
-    -->    
-
-    <!--
-      Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
-    -->
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
-
-    <!--
-     Numeric field types that index each value at various levels of precision
-     to accelerate range queries when the number of values between the range
-     endpoints is large. See the javadoc for LegacyNumericRangeQuery for internal
-     implementation details.
-
-     Smaller precisionStep values (specified in bits) will lead to more tokens
-     indexed per value, slightly larger index size, and faster range queries.
-     A precisionStep of 0 disables indexing at different precision levels.
+  <!-- field type definitions. The "name" attribute is
+     just a label to be used by field definitions.  The "class"
+     attribute and any other attributes determine the real
+     behavior of the fieldType.
+       Class names starting with "solr" refer to java classes in a
+     standard package such as org.apache.solr.analysis
+  -->
+
+  <!-- The StrField type is not analyzed, but indexed/stored verbatim. -->
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+
+  <!-- boolean type: "true" or "false" -->
+  <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
+
+  <!-- sortMissingLast and sortMissingFirst attributes are optional attributes are
+       currently supported on types that are sorted internally as strings
+       and on numeric types.
+     This includes "string","boolean", and, as of 3.5 (and 4.x),
+     int, float, long, date, double, including the "Trie" variants.
+     - If sortMissingLast="true", then a sort on this field will cause documents
+       without the field to come after documents with the field,
+       regardless of the requested sort order (asc or desc).
+     - If sortMissingFirst="true", then a sort on this field will cause documents
+       without the field to come before documents with the field,
+       regardless of the requested sort order.
+     - If sortMissingLast="false" and sortMissingFirst="false" (the default),
+       then default lucene sorting will be used which places docs without the
+       field first in an ascending sort and last in a descending sort.
+  -->
+
+  <!--
+    Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
+  -->
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
+
+  <!--
+   Numeric field types that index each value at various levels of precision
+   to accelerate range queries when the number of values between the range
+   endpoints is large. See the javadoc for LegacyNumericRangeQuery for internal
+   implementation details.
+
+   Smaller precisionStep values (specified in bits) will lead to more tokens
+   indexed per value, slightly larger index size, and faster range queries.
+   A precisionStep of 0 disables indexing at different precision levels.
+  -->
+  <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
+
+  <!-- The format for this date field is of the form 1995-12-31T23:59:59Z, and
+       is a more restricted form of the canonical representation of dateTime
+       http://www.w3.org/TR/xmlschema-2/#dateTime    
+       The trailing "Z" designates UTC time and is mandatory.
+       Optional fractional seconds are allowed: 1995-12-31T23:59:59.999Z
+       All other components are mandatory.
+
+       Expressions can also be used to denote calculations that should be
+       performed relative to "NOW" to determine the value, ie...
+
+             NOW/HOUR
+                ... Round to the start of the current hour
+             NOW-1DAY
+                ... Exactly 1 day prior to now
+             NOW/DAY+6MONTHS+3DAYS
+                ... 6 months and 3 days in the future from the start of
+                    the current day
+                    
+       Consult the TrieDateField javadocs for more information.
+
+       Note: For faster range queries, consider the tdate type
     -->
-    <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
-
-    <!-- The format for this date field is of the form 1995-12-31T23:59:59Z, and
-         is a more restricted form of the canonical representation of dateTime
-         http://www.w3.org/TR/xmlschema-2/#dateTime    
-         The trailing "Z" designates UTC time and is mandatory.
-         Optional fractional seconds are allowed: 1995-12-31T23:59:59.999Z
-         All other components are mandatory.
-
-         Expressions can also be used to denote calculations that should be
-         performed relative to "NOW" to determine the value, ie...
-
-               NOW/HOUR
-                  ... Round to the start of the current hour
-               NOW-1DAY
-                  ... Exactly 1 day prior to now
-               NOW/DAY+6MONTHS+3DAYS
-                  ... 6 months and 3 days in the future from the start of
-                      the current day
-                      
-         Consult the TrieDateField javadocs for more information.
-
-         Note: For faster range queries, consider the tdate type
-      -->
-    <fieldType name="date" class="solr.TrieDateField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="date" class="solr.TrieDateField" precisionStep="0" positionIncrementGap="0"/>
 
-    <!-- A Trie based date field for faster date range queries and date faceting. -->
-    <fieldType name="tdate" class="solr.TrieDateField" precisionStep="6" positionIncrementGap="0"/>
+  <!-- A Trie based date field for faster date range queries and date faceting. -->
+  <fieldType name="tdate" class="solr.TrieDateField" precisionStep="6" positionIncrementGap="0"/>
 
 
-    <!--Binary data type. The data should be sent/retrieved in as Base64 encoded Strings -->
-    <fieldType name="binary" class="solr.BinaryField"/>
+  <!--Binary data type. The data should be sent/retrieved in as Base64 encoded Strings -->
+  <fieldType name="binary" class="solr.BinaryField"/>
 
-    <!-- The "RandomSortField" is not used to store or search any
-         data.  You can declare fields of this type it in your schema
-         to generate pseudo-random orderings of your docs for sorting 
-         or function purposes.  The ordering is generated based on the field
-         name and the version of the index. As long as the index version
-         remains unchanged, and the same field name is reused,
-         the ordering of the docs will be consistent.  
-         If you want different psuedo-random orderings of documents,
-         for the same version of the index, use a dynamicField and
-         change the field name in the request.
-     -->
-    <fieldType name="random" class="solr.RandomSortField" indexed="true" />
+  <!-- The "RandomSortField" is not used to store or search any
+       data.  You can declare fields of this type it in your schema
+       to generate pseudo-random orderings of your docs for sorting 
+       or function purposes.  The ordering is generated based on the field
+       name and the version of the index. As long as the index version
+       remains unchanged, and the same field name is reused,
+       the ordering of the docs will be consistent.  
+       If you want different psuedo-random orderings of documents,
+       for the same version of the index, use a dynamicField and
+       change the field name in the request.
+   -->
+  <fieldType name="random" class="solr.RandomSortField" indexed="true"/>
 
-    <!-- solr.TextField allows the specification of custom text analyzers
-         specified as a tokenizer and a list of token filters. Different
-         analyzers may be specified for indexing and querying.
+  <!-- solr.TextField allows the specification of custom text analyzers
+       specified as a tokenizer and a list of token filters. Different
+       analyzers may be specified for indexing and querying.
 
-         The optional positionIncrementGap puts space between multiple fields of
-         this type on the same document, with the purpose of preventing false phrase
-         matching across fields.
+       The optional positionIncrementGap puts space between multiple fields of
+       this type on the same document, with the purpose of preventing false phrase
+       matching across fields.
 
-         For more info on customizing your analyzer chain, please see
-         http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters
-     -->
+       For more info on customizing your analyzer chain, please see
+       http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters
+   -->
 
-    <!-- One can also specify an existing Analyzer class that has a
-         default constructor via the class attribute on the analyzer element.
-         Example:
-    <fieldType name="text_greek" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.el.GreekAnalyzer"/>
-    </fieldType>
-    -->
+  <!-- One can also specify an existing Analyzer class that has a
+       default constructor via the class attribute on the analyzer element.
+       Example:
+  <fieldType name="text_greek" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.el.GreekAnalyzer"/>
+  </fieldType>
+  -->
+
+  <!-- A text field that only splits on whitespace for exact matching of words -->
+  <fieldType name="text_ws" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- A general text field that has reasonable, generic
+       cross-language defaults: it tokenizes with StandardTokenizer,
+ removes stop words from case-insensitive "stopwords.txt"
+ (empty by default), and down cases.  At query time only, it
+ also applies synonyms. -->
+  <fieldType name="text_general" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+      <!-- in this example, we will only use synonyms at query time
+      <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
+      -->
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- A text field with defaults appropriate for English: it
+       tokenizes with StandardTokenizer, removes English stop words
+       (lang/stopwords_en.txt), down cases, protects words from protwords.txt, and
+       finally applies Porter's stemming.  The query time analyzer
+       also applies synonyms from synonyms.txt. -->
+  <fieldType name="text_en" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- in this example, we will only use synonyms at query time
+      <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
+      -->
+      <!-- Case insensitive stop word removal. -->
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="lang/stopwords_en.txt"
+
+      />
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.EnglishPossessiveFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+            <filter class="solr.EnglishMinimalStemFilterFactory"/>
+      -->
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="lang/stopwords_en.txt"
+
+      />
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.EnglishPossessiveFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+            <filter class="solr.EnglishMinimalStemFilterFactory"/>
+      -->
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- A text field with defaults appropriate for English, plus
+ aggressive word-splitting and autophrase features enabled.
+ This field is just like text_en, except it adds
+ WordDelimiterFilter to enable splitting and matching of
+ words on case-change, alpha numeric boundaries, and
+ non-alphanumeric chars.  This means certain compound word
+ cases will work, for example query "wi fi" will match
+ document "WiFi" or "wi-fi".
+      -->
+  <fieldType name="text_en_splitting" class="solr.TextField" positionIncrementGap="100"
+             autoGeneratePhraseQueries="true">
+    <analyzer type="index">
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <!-- in this example, we will only use synonyms at query time
+      <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
+      -->
+      <!-- Case insensitive stop word removal. -->
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="lang/stopwords_en.txt"
+
+      />
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="lang/stopwords_en.txt"
+
+      />
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Less flexible matching, but less false matches.  Probably not ideal for product names,
+       but may be good for SKUs.  Can insert dashes in the wrong place and still match. -->
+  <fieldType name="text_en_splitting_tight" class="solr.TextField" positionIncrementGap="100"
+             autoGeneratePhraseQueries="true">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="false"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_en.txt"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.EnglishMinimalStemFilterFactory"/>
+      <!-- this filter can remove any duplicate tokens that appear at the same position - sometimes
+           possible with WordDelimiterFilter in conjuncton with stemming. -->
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Just like text_general except it reverses the characters of
+ each token, to enable more efficient leading wildcard queries. -->
+  <fieldType name="text_general_rev" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.ReversedWildcardFilterFactory" withOriginal="true"
+              maxPosAsterisk="3" maxPosQuestion="2" maxFractionAsterisk="0.33"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- charFilter + WhitespaceTokenizer  -->
+  <!--
+  <fieldType name="text_char_norm" class="solr.TextField" positionIncrementGap="100" >
+    <analyzer>
+      <charFilter class="solr.MappingCharFilterFactory" mapping="mapping-ISOLatin1Accent.txt"/>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  -->
 
-    <!-- A text field that only splits on whitespace for exact matching of words -->
-    <fieldType name="text_ws" class="solr.TextField" positionIncrementGap="100">
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- A general text field that has reasonable, generic
-         cross-language defaults: it tokenizes with StandardTokenizer,
-   removes stop words from case-insensitive "stopwords.txt"
-   (empty by default), and down cases.  At query time only, it
-   also applies synonyms. -->
-    <fieldType name="text_general" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt" />
-        <!-- in this example, we will only use synonyms at query time
-        <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
+  <!-- This is an example of using the KeywordTokenizer along
+       With various TokenFilterFactories to produce a sortable field
+       that does not include some properties of the source text
+    -->
+  <fieldType name="alphaOnlySort" class="solr.TextField" sortMissingLast="true" omitNorms="true">
+    <analyzer>
+      <!-- KeywordTokenizer does no actual tokenizing, so the entire
+           input string is preserved as a single token
         -->
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt" />
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- A text field with defaults appropriate for English: it
-         tokenizes with StandardTokenizer, removes English stop words
-         (lang/stopwords_en.txt), down cases, protects words from protwords.txt, and
-         finally applies Porter's stemming.  The query time analyzer
-         also applies synonyms from synonyms.txt. -->
-    <fieldType name="text_en" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- in this example, we will only use synonyms at query time
-        <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
+      <tokenizer class="solr.KeywordTokenizerFactory"/>
+      <!-- The LowerCase TokenFilter does what you expect, which can be
+           when you want your sorting to be case insensitive
         -->
-        <!-- Case insensitive stop word removal. -->
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="lang/stopwords_en.txt"
-               
-                />
-        <filter class="solr.LowerCaseFilterFactory"/>
-  <filter class="solr.EnglishPossessiveFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
-        <filter class="solr.EnglishMinimalStemFilterFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <!-- The TrimFilter removes any leading or trailing whitespace -->
+      <filter class="solr.TrimFilterFactory"/>
+      <!-- The PatternReplaceFilter gives you the flexibility to use
+           Java Regular expression to replace any sequence of characters
+           matching a pattern with an arbitrary replacement string, 
+           which may include back references to portions of the original
+           string matched by the pattern.
+           
+           See the Java Regular Expression documentation for more
+           information on pattern and replacement string syntax.
+           
+           http://java.sun.com/j2se/1.6.0/docs/api/java/util/regex/package-summary.html
+        -->
+      <filter class="solr.PatternReplaceFilterFactory"
+              pattern="([^a-z])" replacement="" replace="all"
+      />
+    </analyzer>
+  </fieldType>
+
+  <!--    
+  <fieldType name="phonetic" stored="false" indexed="true" class="solr.TextField" >
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.DoubleMetaphoneFilterFactory" inject="false"/>
+    </analyzer>
+  </fieldType>
   -->
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="lang/stopwords_en.txt"
-               
-                />
-        <filter class="solr.LowerCaseFilterFactory"/>
-  <filter class="solr.EnglishPossessiveFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
-        <filter class="solr.EnglishMinimalStemFilterFactory"/>
+
+  <fieldType name="payloads" stored="false" indexed="true" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <!--
+      The DelimitedPayloadTokenFilter can put payloads on tokens... for example,
+      a token of "foo|1.4"  would be indexed as "foo" with a payload of 1.4f
+      Attributes of the DelimitedPayloadTokenFilterFactory : 
+       "delimiter" - a one character delimiter. Default is | (pipe)
+ "encoder" - how to encode the following value into a playload
+    float -> org.apache.lucene.analysis.payloads.FloatEncoder,
+    integer -> o.a.l.a.p.IntegerEncoder
+    identity -> o.a.l.a.p.IdentityEncoder
+          Fully Qualified class name implementing PayloadEncoder, Encoder must have a no arg constructor.
+       -->
+      <filter class="solr.DelimitedPayloadTokenFilterFactory" encoder="float"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- lowercases the entire field value, keeping it as a single token.  -->
+  <fieldType name="lowercase" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.KeywordTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- 
+    Example of using PathHierarchyTokenizerFactory at index time, so
+    queries for paths match documents at that path, or in descendent paths
   -->
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- A text field with defaults appropriate for English, plus
-   aggressive word-splitting and autophrase features enabled.
-   This field is just like text_en, except it adds
-   WordDelimiterFilter to enable splitting and matching of
-   words on case-change, alpha numeric boundaries, and
-   non-alphanumeric chars.  This means certain compound word
-   cases will work, for example query "wi fi" will match
-   document "WiFi" or "wi-fi".
-        -->
-    <fieldType name="text_en_splitting" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true">
-      <analyzer type="index">
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <!-- in this example, we will only use synonyms at query time
-        <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
-        -->
-        <!-- Case insensitive stop word removal. -->
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="lang/stopwords_en.txt"
-               
-                />
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="lang/stopwords_en.txt"
-               
-                />
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- Less flexible matching, but less false matches.  Probably not ideal for product names,
-         but may be good for SKUs.  Can insert dashes in the wrong place and still match. -->
-    <fieldType name="text_en_splitting_tight" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true">
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="false"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_en.txt"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.EnglishMinimalStemFilterFactory"/>
-        <!-- this filter can remove any duplicate tokens that appear at the same position - sometimes
-             possible with WordDelimiterFilter in conjuncton with stemming. -->
-        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- Just like text_general except it reverses the characters of
-   each token, to enable more efficient leading wildcard queries. -->
-    <fieldType name="text_general_rev" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt" />
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.ReversedWildcardFilterFactory" withOriginal="true"
-           maxPosAsterisk="3" maxPosQuestion="2" maxFractionAsterisk="0.33"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt" />
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- charFilter + WhitespaceTokenizer  -->
-    <!--
-    <fieldType name="text_char_norm" class="solr.TextField" positionIncrementGap="100" >
-      <analyzer>
-        <charFilter class="solr.MappingCharFilterFactory" mapping="mapping-ISOLatin1Accent.txt"/>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-    -->
+  <fieldType name="descendent_path" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.KeywordTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <!-- 
+    Example of using PathHierarchyTokenizerFactory at query time, so
+    queries for paths match documents at that path, or in ancestor paths
+  -->
+  <fieldType name="ancestor_path" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.KeywordTokenizerFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- since fields of this type are by default not stored or indexed,
+       any data added to them will be ignored outright.  -->
+  <fieldType name="ignored" stored="false" indexed="false" multiValued="true" class="solr.StrField"/>
+
+  <!-- This point type indexes the coordinates as separate fields (subFields)
+    If subFieldType is defined, it references a type, and a dynamic field
+    definition is created matching *___<typename>.  Alternately, if 
+    subFieldSuffix is defined, that is used to create the subFields.
+    Example: if subFieldType="double", then the coordinates would be
+      indexed in fields myloc_0___double,myloc_1___double.
+    Example: if subFieldSuffix="_d" then the coordinates would be indexed
+      in fields myloc_0_d,myloc_1_d
+    The subFields are an implementation detail of the fieldType, and end
+    users normally should not need to know about them.
+   -->
+  <fieldType name="point" class="solr.PointType" dimension="2" subFieldSuffix="_d"/>
 
-    <!-- This is an example of using the KeywordTokenizer along
-         With various TokenFilterFactories to produce a sortable field
-         that does not include some properties of the source text
-      -->
-    <fieldType name="alphaOnlySort" class="solr.TextField" sortMissingLast="true" omitNorms="true">
-      <analyzer>
-        <!-- KeywordTokenizer does no actual tokenizing, so the entire
-             input string is preserved as a single token
-          -->
-        <tokenizer class="solr.KeywordTokenizerFactory"/>
-        <!-- The LowerCase TokenFilter does what you expect, which can be
-             when you want your sorting to be case insensitive
-          -->
-        <filter class="solr.LowerCaseFilterFactory" />
-        <!-- The TrimFilter removes any leading or trailing whitespace -->
-        <filter class="solr.TrimFilterFactory" />
-        <!-- The PatternReplaceFilter gives you the flexibility to use
-             Java Regular expression to replace any sequence of characters
-             matching a pattern with an arbitrary replacement string, 
-             which may include back references to portions of the original
-             string matched by the pattern.
-             
-             See the Java Regular Expression documentation for more
-             information on pattern and replacement string syntax.
-             
-             http://java.sun.com/j2se/1.6.0/docs/api/java/util/regex/package-summary.html
-          -->
-        <filter class="solr.PatternReplaceFilterFactory"
-                pattern="([^a-z])" replacement="" replace="all"
-        />
-      </analyzer>
-    </fieldType>
-
-    <!--    
-    <fieldType name="phonetic" stored="false" indexed="true" class="solr.TextField" >
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.DoubleMetaphoneFilterFactory" inject="false"/>
-      </analyzer>
-    </fieldType>
-    -->
-    
-    <fieldType name="payloads" stored="false" indexed="true" class="solr.TextField" >
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <!--
-        The DelimitedPayloadTokenFilter can put payloads on tokens... for example,
-        a token of "foo|1.4"  would be indexed as "foo" with a payload of 1.4f
-        Attributes of the DelimitedPayloadTokenFilterFactory : 
-         "delimiter" - a one character delimiter. Default is | (pipe)
-   "encoder" - how to encode the following value into a playload
-      float -> org.apache.lucene.analysis.payloads.FloatEncoder,
-      integer -> o.a.l.a.p.IntegerEncoder
-      identity -> o.a.l.a.p.IdentityEncoder
-            Fully Qualified class name implementing PayloadEncoder, Encoder must have a no arg constructor.
-         -->
-        <filter class="solr.DelimitedPayloadTokenFilterFactory" encoder="float"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- lowercases the entire field value, keeping it as a single token.  -->
-    <fieldType name="lowercase" class="solr.TextField" positionIncrementGap="100">
-      <analyzer>
-        <tokenizer class="solr.KeywordTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory" />
-      </analyzer>
-    </fieldType>
-
-    <!-- 
-      Example of using PathHierarchyTokenizerFactory at index time, so
-      queries for paths match documents at that path, or in descendent paths
-    -->
-    <fieldType name="descendent_path" class="solr.TextField">
-      <analyzer type="index">
-  <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
-      </analyzer>
-      <analyzer type="query">
-  <tokenizer class="solr.KeywordTokenizerFactory" />
-      </analyzer>
-    </fieldType>
-    <!-- 
-      Example of using PathHierarchyTokenizerFactory at query time, so
-      queries for paths match documents at that path, or in ancestor paths
-    -->
-    <fieldType name="ancestor_path" class="solr.TextField">
-      <analyzer type="index">
-  <tokenizer class="solr.KeywordTokenizerFactory" />
-      </analyzer>
-      <analyzer type="query">
-  <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
-      </analyzer>
-    </fieldType>
-
-    <!-- since fields of this type are by default not stored or indexed,
-         any data added to them will be ignored outright.  --> 
-    <fieldType name="ignored" stored="false" indexed="false" multiValued="true" class="solr.StrField" />
-
-    <!-- This point type indexes the coordinates as separate fields (subFields)
-      If subFieldType is defined, it references a type, and a dynamic field
-      definition is created matching *___<typename>.  Alternately, if 
-      subFieldSuffix is defined, that is used to create the subFields.
-      Example: if subFieldType="double", then the coordinates would be
-        indexed in fields myloc_0___double,myloc_1___double.
-      Example: if subFieldSuffix="_d" then the coordinates would be indexed
-        in fields myloc_0_d,myloc_1_d
-      The subFields are an implementation detail of the fieldType, and end
-      users normally should not need to know about them.
-     -->
-    <fieldType name="point" class="solr.PointType" dimension="2" subFieldSuffix="_d"/>
+  <!-- A specialized field for geospatial search. If indexed, this fieldType must not be multivalued. -->
+  <fieldType name="location" class="solr.LatLonType" subFieldSuffix="_coordinate"/>
+
+  <!--
+   A Geohash is a compact representation of a latitude longitude pair in a single field.
+   See http://wiki.apache.org/solr/SpatialSearch
+  -->
+  <fieldType name="geohash" class="solr.GeoHashField"/>
+
+  <!-- Money/currency field type. See http://wiki.apache.org/solr/MoneyFieldType
+       Parameters:
+         defaultCurrency: Specifies the default currency if none specified. Defaults to "USD"
+         precisionStep:   Specifies the precisionStep for the TrieLong field used for the amount
+         providerClass:   Lets you plug in other exchange provider backend:
+                          solr.FileExchangeRateProvider is the default and takes one parameter:
+                            currencyConfig: name of an xml file holding exhange rates
+                          solr.OpenExchangeRatesOrgProvider uses rates from openexchangerates.org:
+                            ratesFileLocation: URL or path to rates JSON file (default latest.json on the web)
+                            refreshInterval: Number of minutes between each rates fetch (default: 1440, min: 60)
+  -->
+  <fieldType name="currency" class="solr.CurrencyField" precisionStep="8" defaultCurrency="USD"
+             currencyConfig="currency.xml"/>
+
+
+  <!-- some examples for different languages (generally ordered by ISO code) -->
+
+  <!-- Arabic -->
+  <fieldType name="text_ar" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- for any non-arabic -->
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ar.txt"/>
+      <!-- normalizes ? to ?, etc -->
+      <filter class="solr.ArabicNormalizationFilterFactory"/>
+      <filter class="solr.ArabicStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Bulgarian -->
+  <fieldType name="text_bg" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_bg.txt"/>
+      <filter class="solr.BulgarianStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Catalan -->
+  <fieldType name="text_ca" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- removes l', etc -->
+      <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_ca.txt"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ca.txt"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Catalan"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- CJK bigram (see text_ja for a Japanese configuration using morphological analysis) -->
+  <fieldType name="text_cjk" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- normalize width before bigram, as e.g. half-width dakuten combine  -->
+      <filter class="solr.CJKWidthFilterFactory"/>
+      <!-- for any non-CJK -->
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.CJKBigramFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Czech -->
+  <fieldType name="text_cz" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_cz.txt"/>
+      <filter class="solr.CzechStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Danish -->
+  <fieldType name="text_da" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_da.txt" format="snowball"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Danish"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- German -->
+  <fieldType name="text_de" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_de.txt" format="snowball"/>
+      <filter class="solr.GermanNormalizationFilterFactory"/>
+      <filter class="solr.GermanLightStemFilterFactory"/>
+      <!-- less aggressive: <filter class="solr.GermanMinimalStemFilterFactory"/> -->
+      <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="German2"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Greek -->
+  <fieldType name="text_el" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- greek specific lowercase for sigma -->
+      <filter class="solr.GreekLowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="false" words="lang/stopwords_el.txt"/>
+      <filter class="solr.GreekStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Spanish -->
+  <fieldType name="text_es" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_es.txt" format="snowball"/>
+      <filter class="solr.SpanishLightStemFilterFactory"/>
+      <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="Spanish"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Basque -->
+  <fieldType name="text_eu" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_eu.txt"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Basque"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Persian -->
+  <fieldType name="text_fa" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <!-- for ZWNJ -->
+      <charFilter class="solr.PersianCharFilterFactory"/>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.ArabicNormalizationFilterFactory"/>
+      <filter class="solr.PersianNormalizationFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_fa.txt"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Finnish -->
+  <fieldType name="text_fi" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_fi.txt" format="snowball"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Finnish"/>
+      <!-- less aggressive: <filter class="solr.FinnishLightStemFilterFactory"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- French -->
+  <fieldType name="text_fr" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- removes l', etc -->
+      <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_fr.txt"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_fr.txt" format="snowball"/>
+      <filter class="solr.FrenchLightStemFilterFactory"/>
+      <!-- less aggressive: <filter class="solr.FrenchMinimalStemFilterFactory"/> -->
+      <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="French"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Irish -->
+  <fieldType name="text_ga" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- removes d', etc -->
+      <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_ga.txt"/>
+      <!-- removes n-, etc. position increments is intentionally false! -->
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/hyphenations_ga.txt"/>
+      <filter class="solr.IrishLowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ga.txt"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Irish"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Galician -->
+  <fieldType name="text_gl" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_gl.txt"/>
+      <filter class="solr.GalicianStemFilterFactory"/>
+      <!-- less aggressive: <filter class="solr.GalicianMinimalStemFilterFactory"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Hindi -->
+  <fieldType name="text_hi" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <!-- normalizes unicode representation -->
+      <filter class="solr.IndicNormalizationFilterFactory"/>
+      <!-- normalizes variation in spelling -->
+      <filter class="solr.HindiNormalizationFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_hi.txt"/>
+      <filter class="solr.HindiStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Hungarian -->
+  <fieldType name="text_hu" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_hu.txt" format="snowball"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Hungarian"/>
+      <!-- less aggressive: <filter class="solr.HungarianLightStemFilterFactory"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Armenian -->
+  <fieldType name="text_hy" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_hy.txt"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Armenian"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Indonesian -->
+  <fieldType name="text_id" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_id.txt"/>
+      <!-- for a less aggressive approach (only inflectional suffixes), set stemDerivational to false -->
+      <filter class="solr.IndonesianStemFilterFactory" stemDerivational="true"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Italian -->
+  <fieldType name="text_it" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- removes l', etc -->
+      <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_it.txt"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_it.txt" format="snowball"/>
+      <filter class="solr.ItalianLightStemFilterFactory"/>
+      <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="Italian"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Latvian -->
+  <fieldType name="text_lv" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_lv.txt"/>
+      <filter class="solr.LatvianStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Dutch -->
+  <fieldType name="text_nl" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_nl.txt" format="snowball"/>
+      <filter class="solr.StemmerOverrideFilterFactory" dictionary="lang/stemdict_nl.txt" ignoreCase="false"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Dutch"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Norwegian -->
+  <fieldType name="text_no" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_no.txt" format="snowball"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Norwegian"/>
+      <!-- less aggressive: <filter class="solr.NorwegianLightStemFilterFactory"/> -->
+      <!-- singular/plural: <filter class="solr.NorwegianMinimalStemFilterFactory"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Portuguese -->
+  <fieldType name="text_pt" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_pt.txt" format="snowball"/>
+      <filter class="solr.PortugueseLightStemFilterFactory"/>
+      <!-- less aggressive: <filter class="solr.PortugueseMinimalStemFilterFactory"/> -->
+      <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="Portuguese"/> -->
+      <!-- most aggressive: <filter class="solr.PortugueseStemFilterFactory"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Romanian -->
+  <fieldType name="text_ro" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ro.txt"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Romanian"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Russian -->
+  <fieldType name="text_ru" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ru.txt" format="snowball"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Russian"/>
+      <!-- less aggressive: <filter class="solr.RussianLightStemFilterFactory"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Swedish -->
+  <fieldType name="text_sv" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_sv.txt" format="snowball"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Swedish"/>
+      <!-- less aggressive: <filter class="solr.SwedishLightStemFilterFactory"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Thai -->
+  <fieldType name="text_th" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.ThaiTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_th.txt"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Turkish -->
+  <fieldType name="text_tr" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.TurkishLowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="false" words="lang/stopwords_tr.txt"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Turkish"/>
+    </analyzer>
+  </fieldType>
 
-    <!-- A specialized field for geospatial search. If indexed, this fieldType must not be multivalued. -->
-    <fieldType name="location" class="solr.LatLonType" subFieldSuffix="_coordinate"/>
 
-   <!--
-    A Geohash is a compact representation of a latitude longitude pair in a single field.
-    See http://wiki.apache.org/solr/SpatialSearch
-   -->
-    <fieldType name="geohash" class="solr.GeoHashField"/>
-
-   <!-- Money/currency field type. See http://wiki.apache.org/solr/MoneyFieldType
-        Parameters:
-          defaultCurrency: Specifies the default currency if none specified. Defaults to "USD"
-          precisionStep:   Specifies the precisionStep for the TrieLong field used for the amount
-          providerClass:   Lets you plug in other exchange provider backend:
-                           solr.FileExchangeRateProvider is the default and takes one parameter:
-                             currencyConfig: name of an xml file holding exhange rates
-                           solr.OpenExchangeRatesOrgProvider uses rates from openexchangerates.org:
-                             ratesFileLocation: URL or path to rates JSON file (default latest.json on the web)
-                             refreshInterval: Number of minutes between each rates fetch (default: 1440, min: 60)
-   -->
-    <fieldType name="currency" class="solr.CurrencyField" precisionStep="8" defaultCurrency="USD" currencyConfig="currency.xml" />
-             
-
-
-   <!-- some examples for different languages (generally ordered by ISO code) -->
-
-    <!-- Arabic -->
-    <fieldType name="text_ar" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- for any non-arabic -->
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ar.txt"/>
-        <!-- normalizes ? to ?, etc -->
-        <filter class="solr.ArabicNormalizationFilterFactory"/>
-        <filter class="solr.ArabicStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- Bulgarian -->
-    <fieldType name="text_bg" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/> 
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_bg.txt"/>
-        <filter class="solr.BulgarianStemFilterFactory"/>       
-      </analyzer>
-    </fieldType>
-    
-    <!-- Catalan -->
-    <fieldType name="text_ca" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- removes l', etc -->
-        <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_ca.txt"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ca.txt"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Catalan"/>       
-      </analyzer>
-    </fieldType>
-    
-    <!-- CJK bigram (see text_ja for a Japanese configuration using morphological analysis) -->
-    <fieldType name="text_cjk" class="solr.TextField" positionIncrementGap="100">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- normalize width before bigram, as e.g. half-width dakuten combine  -->
-        <filter class="solr.CJKWidthFilterFactory"/>
-        <!-- for any non-CJK -->
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.CJKBigramFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- Czech -->
-    <fieldType name="text_cz" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_cz.txt"/>
-        <filter class="solr.CzechStemFilterFactory"/>       
-      </analyzer>
-    </fieldType>
-    
-    <!-- Danish -->
-    <fieldType name="text_da" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_da.txt" format="snowball"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Danish"/>       
-      </analyzer>
-    </fieldType>
-    
-    <!-- German -->
-    <fieldType name="text_de" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_de.txt" format="snowball"/>
-        <filter class="solr.GermanNormalizationFilterFactory"/>
-        <filter class="solr.GermanLightStemFilterFactory"/>
-        <!-- less aggressive: <filter class="solr.GermanMinimalStemFilterFactory"/> -->
-        <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="German2"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Greek -->
-    <fieldType name="text_el" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- greek specific lowercase for sigma -->
-        <filter class="solr.GreekLowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="false" words="lang/stopwords_el.txt"/>
-        <filter class="solr.GreekStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Spanish -->
-    <fieldType name="text_es" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_es.txt" format="snowball"/>
-        <filter class="solr.SpanishLightStemFilterFactory"/>
-        <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="Spanish"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Basque -->
-    <fieldType name="text_eu" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_eu.txt"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Basque"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Persian -->
-    <fieldType name="text_fa" class="solr.TextField" positionIncrementGap="100">
-      <analyzer>
-        <!-- for ZWNJ -->
-        <charFilter class="solr.PersianCharFilterFactory"/>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.ArabicNormalizationFilterFactory"/>
-        <filter class="solr.PersianNormalizationFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_fa.txt"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Finnish -->
-    <fieldType name="text_fi" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_fi.txt" format="snowball"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Finnish"/>
-        <!-- less aggressive: <filter class="solr.FinnishLightStemFilterFactory"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- French -->
-    <fieldType name="text_fr" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- removes l', etc -->
-        <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_fr.txt"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_fr.txt" format="snowball"/>
-        <filter class="solr.FrenchLightStemFilterFactory"/>
-        <!-- less aggressive: <filter class="solr.FrenchMinimalStemFilterFactory"/> -->
-        <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="French"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Irish -->
-    <fieldType name="text_ga" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- removes d', etc -->
-        <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_ga.txt"/>
-        <!-- removes n-, etc. position increments is intentionally false! -->
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/hyphenations_ga.txt"/>
-        <filter class="solr.IrishLowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ga.txt"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Irish"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Galician -->
-    <fieldType name="text_gl" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_gl.txt"/>
-        <filter class="solr.GalicianStemFilterFactory"/>
-        <!-- less aggressive: <filter class="solr.GalicianMinimalStemFilterFactory"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Hindi -->
-    <fieldType name="text_hi" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <!-- normalizes unicode representation -->
-        <filter class="solr.IndicNormalizationFilterFactory"/>
-        <!-- normalizes variation in spelling -->
-        <filter class="solr.HindiNormalizationFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_hi.txt"/>
-        <filter class="solr.HindiStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Hungarian -->
-    <fieldType name="text_hu" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_hu.txt" format="snowball"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Hungarian"/>
-        <!-- less aggressive: <filter class="solr.HungarianLightStemFilterFactory"/> -->   
-      </analyzer>
-    </fieldType>
-    
-    <!-- Armenian -->
-    <fieldType name="text_hy" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_hy.txt"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Armenian"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Indonesian -->
-    <fieldType name="text_id" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_id.txt"/>
-        <!-- for a less aggressive approach (only inflectional suffixes), set stemDerivational to false -->
-        <filter class="solr.IndonesianStemFilterFactory" stemDerivational="true"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Italian -->
-    <fieldType name="text_it" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- removes l', etc -->
-        <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_it.txt"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_it.txt" format="snowball"/>
-        <filter class="solr.ItalianLightStemFilterFactory"/>
-        <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="Italian"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Latvian -->
-    <fieldType name="text_lv" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_lv.txt"/>
-        <filter class="solr.LatvianStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Dutch -->
-    <fieldType name="text_nl" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_nl.txt" format="snowball"/>
-        <filter class="solr.StemmerOverrideFilterFactory" dictionary="lang/stemdict_nl.txt" ignoreCase="false"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Dutch"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Norwegian -->
-    <fieldType name="text_no" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_no.txt" format="snowball"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Norwegian"/>
-        <!-- less aggressive: <filter class="solr.NorwegianLightStemFilterFactory"/> -->
-        <!-- singular/plural: <filter class="solr.NorwegianMinimalStemFilterFactory"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Portuguese -->
-    <fieldType name="text_pt" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_pt.txt" format="snowball"/>
-        <filter class="solr.PortugueseLightStemFilterFactory"/>
-        <!-- less aggressive: <filter class="solr.PortugueseMinimalStemFilterFactory"/> -->
-        <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="Portuguese"/> -->
-        <!-- most aggressive: <filter class="solr.PortugueseStemFilterFactory"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Romanian -->
-    <fieldType name="text_ro" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ro.txt"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Romanian"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Russian -->
-    <fieldType name="text_ru" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ru.txt" format="snowball"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Russian"/>
-        <!-- less aggressive: <filter class="solr.RussianLightStemFilterFactory"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Swedish -->
-    <fieldType name="text_sv" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_sv.txt" format="snowball"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Swedish"/>
-        <!-- less aggressive: <filter class="solr.SwedishLightStemFilterFactory"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Thai -->
-    <fieldType name="text_th" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.ThaiTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_th.txt"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Turkish -->
-    <fieldType name="text_tr" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.TurkishLowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="false" words="lang/stopwords_tr.txt"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Turkish"/>
-      </analyzer>
-    </fieldType>
-
- </types>
-  
   <!-- Similarity is the scoring routine for each document vs. a query.
        A custom Similarity or SimilarityFactory may be specified here, but 
        the default is fine for most applications.  
diff --git a/solr/contrib/morphlines-core/src/test-files/solr/minimr/conf/schema.xml b/solr/contrib/morphlines-core/src/test-files/solr/minimr/conf/schema.xml
index bc3e89d..1dee871 100644
--- a/solr/contrib/morphlines-core/src/test-files/solr/minimr/conf/schema.xml
+++ b/solr/contrib/morphlines-core/src/test-files/solr/minimr/conf/schema.xml
@@ -64,868 +64,869 @@
        1.6: useDocValuesAsStored defaults to true.
      -->
 
- <fields>
-   <!-- Valid attributes for fields:
-     name: mandatory - the name for the field
-     type: mandatory - the name of a field type from the 
-       <types> fieldType section
-     indexed: true if this field should be indexed (searchable or sortable)
-     stored: true if this field should be retrievable
-     docValues: true if this field should have doc values. Doc values are
-       useful for faceting, grouping, sorting and function queries. Although not
-       required, doc values will make the index faster to load, more
-       NRT-friendly and more memory-efficient. They however come with some
-       limitations: they are currently only supported by StrField, UUIDField
-       and all Trie*Fields, and depending on the field type, they might
-       require the field to be single-valued, be required or have a default
-       value (check the documentation of the field type you're interested in
-       for more information)
-     multiValued: true if this field may contain multiple values per document
-     omitNorms: (expert) set to true to omit the norms associated with
-       this field (this disables length normalization and index-time
-       boosting for the field, and saves some memory).  Only full-text
-       fields or fields that need an index-time boost need norms.
-       Norms are omitted for primitive (non-analyzed) types by default.
-     termVectors: [false] set to true to store the term vector for a
-       given field.
-       When using MoreLikeThis, fields used for similarity should be
-       stored for best performance.
-     termPositions: Store position information with the term vector.  
-       This will increase storage costs.
-     termOffsets: Store offset information with the term vector. This 
-       will increase storage costs.
-     required: The field is required.  It will throw an error if the
-       value does not exist
-     default: a value that should be used if no value is specified
-       when adding a document.
-   -->
 
-   <!-- field names should consist of alphanumeric or underscore characters only and
-      not start with a digit.  This is not currently strictly enforced,
-      but other field names will not have first class support from all components
-      and back compatibility is not guaranteed.  Names with both leading and
-      trailing underscores (e.g. _version_) are reserved.
-   -->
-        
-   <field name="id" type="string" indexed="true" stored="true" required="true" multiValued="false" /> 
-   <field name="user_friends_count" type="tint" indexed="true" stored="true" />
-   <field name="user_location" type="lowercase" indexed="true" stored="true" />
-   <field name="user_description" type="text_en" indexed="true" stored="false"/>
-   <field name="user_statuses_count" type="tint" indexed="true" stored="true" />
-   <field name="user_followers_count" type="tint" indexed="true" stored="true"/>
-   <field name="user_name" type="text_en" indexed="true" stored="true" />
-   <field name="user_screen_name" type="text_en" indexed="true" stored="true" />
-   <field name="created_at" type="tdate" indexed="true" stored="true" />
-   <field name="text" type="text_en" indexed="true" stored="true" />
-   <field name="retweet_count" type="tint" indexed="true" stored="true" />
-   <field name="retweeted" type="boolean" indexed="true" stored="false" />
-   <field name="in_reply_to_user_id" type="long" indexed="true" stored="true" />
-   <field name="source" type="lowercase" indexed="true" stored="true" />
-   <field name="in_reply_to_status_id" type="long" indexed="true" stored="true" multiValued="true"/>
-   <field name="media_url_https" type="string" indexed="false" stored="true" />
-   <field name="expanded_url" type="string" indexed="false" stored="true" />
-
-   <!-- file metadata -->   
-   <field name="file_download_url" type="string" indexed="false" stored="true" />
-   <field name="file_upload_url" type="string" indexed="false" stored="true" />
-   <field name="file_scheme" type="string" indexed="true" stored="true" />
-   <field name="file_host" type="string" indexed="true" stored="true" />
-   <field name="file_port" type="int" indexed="true" stored="true" />
-   <field name="file_path" type="string" indexed="true" stored="true" />
-   <field name="file_name" type="string" indexed="true" stored="true" />
-   <field name="file_length" type="tlong" indexed="true" stored="true" />
-   <field name="file_last_modified" type="tlong" indexed="true" stored="true" />
-   <field name="file_owner" type="string" indexed="true" stored="true" />
-   <field name="file_group" type="string" indexed="true" stored="true" />
-   <field name="file_permissions_user" type="string" indexed="true" stored="true" />
-   <field name="file_permissions_group" type="string" indexed="true" stored="true" />
-   <field name="file_permissions_other" type="string" indexed="true" stored="true" />
-   <field name="file_permissions_stickybit" type="boolean" indexed="true" stored="true" />
-
-   <!-- tika metadata -->
-   <field name="content_type" type="lowercase" indexed="true" stored="true" />
-
-   <field name="_version_" type="long" indexed="true" stored="true"/>
-   <dynamicField name="ignored_*" type="ignored"/>
-   
- </fields>
-
-
- <!-- Field to use to determine and enforce document uniqueness. 
-      Unless this field is marked with required="false", it will be a required field
-   -->
- <uniqueKey>id</uniqueKey>
-
- <!-- DEPRECATED: The defaultSearchField is consulted by various query parsers when
-  parsing a query string that isn't explicit about the field.  Machine (non-user)
-  generated queries are best made explicit, or they can use the "df" request parameter
-  which takes precedence over this.
-  Note: Un-commenting defaultSearchField will be insufficient if your request handler
-  in solrconfig.xml defines "df", which takes precedence. That would need to be removed.
- <defaultSearchField>text</defaultSearchField> -->
-
- <!-- DEPRECATED: The defaultOperator (AND|OR) is consulted by various query parsers
-  when parsing a query string to determine if a clause of the query should be marked as
-  required or optional, assuming the clause isn't already marked by some operator.
-  The default is OR, which is generally assumed so it is not a good idea to change it
-  globally here.  The "q.op" request parameter takes precedence over this.
- <solrQueryParser defaultOperator="OR"/> -->
+  <!-- Valid attributes for fields:
+    name: mandatory - the name for the field
+    type: mandatory - the name of a field type from the 
+      fieldTypes section
+    indexed: true if this field should be indexed (searchable or sortable)
+    stored: true if this field should be retrievable
+    docValues: true if this field should have doc values. Doc values are
+      useful for faceting, grouping, sorting and function queries. Although not
+      required, doc values will make the index faster to load, more
+      NRT-friendly and more memory-efficient. They however come with some
+      limitations: they are currently only supported by StrField, UUIDField
+      and all Trie*Fields, and depending on the field type, they might
+      require the field to be single-valued, be required or have a default
+      value (check the documentation of the field type you're interested in
+      for more information)
+    multiValued: true if this field may contain multiple values per document
+    omitNorms: (expert) set to true to omit the norms associated with
+      this field (this disables length normalization and index-time
+      boosting for the field, and saves some memory).  Only full-text
+      fields or fields that need an index-time boost need norms.
+      Norms are omitted for primitive (non-analyzed) types by default.
+    termVectors: [false] set to true to store the term vector for a
+      given field.
+      When using MoreLikeThis, fields used for similarity should be
+      stored for best performance.
+    termPositions: Store position information with the term vector.  
+      This will increase storage costs.
+    termOffsets: Store offset information with the term vector. This 
+      will increase storage costs.
+    required: The field is required.  It will throw an error if the
+      value does not exist
+    default: a value that should be used if no value is specified
+      when adding a document.
+  -->
+
+  <!-- field names should consist of alphanumeric or underscore characters only and
+     not start with a digit.  This is not currently strictly enforced,
+     but other field names will not have first class support from all components
+     and back compatibility is not guaranteed.  Names with both leading and
+     trailing underscores (e.g. _version_) are reserved.
+  -->
+
+  <field name="id" type="string" indexed="true" stored="true" required="true" multiValued="false"/>
+  <field name="user_friends_count" type="tint" indexed="true" stored="true"/>
+  <field name="user_location" type="lowercase" indexed="true" stored="true"/>
+  <field name="user_description" type="text_en" indexed="true" stored="false"/>
+  <field name="user_statuses_count" type="tint" indexed="true" stored="true"/>
+  <field name="user_followers_count" type="tint" indexed="true" stored="true"/>
+  <field name="user_name" type="text_en" indexed="true" stored="true"/>
+  <field name="user_screen_name" type="text_en" indexed="true" stored="true"/>
+  <field name="created_at" type="tdate" indexed="true" stored="true"/>
+  <field name="text" type="text_en" indexed="true" stored="true"/>
+  <field name="retweet_count" type="tint" indexed="true" stored="true"/>
+  <field name="retweeted" type="boolean" indexed="true" stored="false"/>
+  <field name="in_reply_to_user_id" type="long" indexed="true" stored="true"/>
+  <field name="source" type="lowercase" indexed="true" stored="true"/>
+  <field name="in_reply_to_status_id" type="long" indexed="true" stored="true" multiValued="true"/>
+  <field name="media_url_https" type="string" indexed="false" stored="true"/>
+  <field name="expanded_url" type="string" indexed="false" stored="true"/>
+
+  <!-- file metadata -->
+  <field name="file_download_url" type="string" indexed="false" stored="true"/>
+  <field name="file_upload_url" type="string" indexed="false" stored="true"/>
+  <field name="file_scheme" type="string" indexed="true" stored="true"/>
+  <field name="file_host" type="string" indexed="true" stored="true"/>
+  <field name="file_port" type="int" indexed="true" stored="true"/>
+  <field name="file_path" type="string" indexed="true" stored="true"/>
+  <field name="file_name" type="string" indexed="true" stored="true"/>
+  <field name="file_length" type="tlong" indexed="true" stored="true"/>
+  <field name="file_last_modified" type="tlong" indexed="true" stored="true"/>
+  <field name="file_owner" type="string" indexed="true" stored="true"/>
+  <field name="file_group" type="string" indexed="true" stored="true"/>
+  <field name="file_permissions_user" type="string" indexed="true" stored="true"/>
+  <field name="file_permissions_group" type="string" indexed="true" stored="true"/>
+  <field name="file_permissions_other" type="string" indexed="true" stored="true"/>
+  <field name="file_permissions_stickybit" type="boolean" indexed="true" stored="true"/>
+
+  <!-- tika metadata -->
+  <field name="content_type" type="lowercase" indexed="true" stored="true"/>
+
+  <field name="_version_" type="long" indexed="true" stored="true"/>
+  <dynamicField name="ignored_*" type="ignored"/>
+
+
+  <!-- Field to use to determine and enforce document uniqueness. 
+       Unless this field is marked with required="false", it will be a required field
+    -->
+  <uniqueKey>id</uniqueKey>
+
+  <!-- DEPRECATED: The defaultSearchField is consulted by various query parsers when
+   parsing a query string that isn't explicit about the field.  Machine (non-user)
+   generated queries are best made explicit, or they can use the "df" request parameter
+   which takes precedence over this.
+   Note: Un-commenting defaultSearchField will be insufficient if your request handler
+   in solrconfig.xml defines "df", which takes precedence. That would need to be removed.
+  <defaultSearchField>text</defaultSearchField> -->
+
+  <!-- DEPRECATED: The defaultOperator (AND|OR) is consulted by various query parsers
+   when parsing a query string to determine if a clause of the query should be marked as
+   required or optional, assuming the clause isn't already marked by some operator.
+   The default is OR, which is generally assumed so it is not a good idea to change it
+   globally here.  The "q.op" request parameter takes precedence over this.
+  <solrQueryParser defaultOperator="OR"/> -->
 
   <!-- copyField commands copy one field to another at the time a document
         is added to the index.  It's used either to index the same field differently,
         or to add multiple fields to the same field for easier/faster searching.  -->
 
-  
-  <types>
-    <!-- field type definitions. The "name" attribute is
-       just a label to be used by field definitions.  The "class"
-       attribute and any other attributes determine the real
-       behavior of the fieldType.
-         Class names starting with "solr" refer to java classes in a
-       standard package such as org.apache.solr.analysis
-    -->
 
-    <!-- The StrField type is not analyzed, but indexed/stored verbatim.
-       It supports doc values but in that case the field needs to be
-       single-valued and either required or have a default value.
-      -->
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true" />
-
-    <!-- boolean type: "true" or "false" -->
-    <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
-
-    <!-- sortMissingLast and sortMissingFirst attributes are optional attributes are
-         currently supported on types that are sorted internally as strings
-         and on numeric types.
-       This includes "string","boolean", and, as of 3.5 (and 4.x),
-       int, float, long, date, double, including the "Trie" variants.
-       - If sortMissingLast="true", then a sort on this field will cause documents
-         without the field to come after documents with the field,
-         regardless of the requested sort order (asc or desc).
-       - If sortMissingFirst="true", then a sort on this field will cause documents
-         without the field to come before documents with the field,
-         regardless of the requested sort order.
-       - If sortMissingLast="false" and sortMissingFirst="false" (the default),
-         then default lucene sorting will be used which places docs without the
-         field first in an ascending sort and last in a descending sort.
-    -->    
-
-    <!--
-      Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
-
-      These fields support doc values, but they require the field to be
-      single-valued and either be required or have a default value.
+  <!-- field type definitions. The "name" attribute is
+     just a label to be used by field definitions.  The "class"
+     attribute and any other attributes determine the real
+     behavior of the fieldType.
+       Class names starting with "solr" refer to java classes in a
+     standard package such as org.apache.solr.analysis
+  -->
+
+  <!-- The StrField type is not analyzed, but indexed/stored verbatim.
+     It supports doc values but in that case the field needs to be
+     single-valued and either required or have a default value.
     -->
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
-
-    <!--
-     Numeric field types that index each value at various levels of precision
-     to accelerate range queries when the number of values between the range
-     endpoints is large. See the javadoc for LegacyNumericRangeQuery for internal
-     implementation details.
-
-     Smaller precisionStep values (specified in bits) will lead to more tokens
-     indexed per value, slightly larger index size, and faster range queries.
-     A precisionStep of 0 disables indexing at different precision levels.
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+
+  <!-- boolean type: "true" or "false" -->
+  <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
+
+  <!-- sortMissingLast and sortMissingFirst attributes are optional attributes are
+       currently supported on types that are sorted internally as strings
+       and on numeric types.
+     This includes "string","boolean", and, as of 3.5 (and 4.x),
+     int, float, long, date, double, including the "Trie" variants.
+     - If sortMissingLast="true", then a sort on this field will cause documents
+       without the field to come after documents with the field,
+       regardless of the requested sort order (asc or desc).
+     - If sortMissingFirst="true", then a sort on this field will cause documents
+       without the field to come before documents with the field,
+       regardless of the requested sort order.
+     - If sortMissingLast="false" and sortMissingFirst="false" (the default),
+       then default lucene sorting will be used which places docs without the
+       field first in an ascending sort and last in a descending sort.
+  -->
+
+  <!--
+    Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
+
+    These fields support doc values, but they require the field to be
+    single-valued and either be required or have a default value.
+  -->
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
+
+  <!--
+   Numeric field types that index each value at various levels of precision
+   to accelerate range queries when the number of values between the range
+   endpoints is large. See the javadoc for LegacyNumericRangeQuery for internal
+   implementation details.
+
+   Smaller precisionStep values (specified in bits) will lead to more tokens
+   indexed per value, slightly larger index size, and faster range queries.
+   A precisionStep of 0 disables indexing at different precision levels.
+  -->
+  <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
+
+  <!-- The format for this date field is of the form 1995-12-31T23:59:59Z, and
+       is a more restricted form of the canonical representation of dateTime
+       http://www.w3.org/TR/xmlschema-2/#dateTime    
+       The trailing "Z" designates UTC time and is mandatory.
+       Optional fractional seconds are allowed: 1995-12-31T23:59:59.999Z
+       All other components are mandatory.
+
+       Expressions can also be used to denote calculations that should be
+       performed relative to "NOW" to determine the value, ie...
+
+             NOW/HOUR
+                ... Round to the start of the current hour
+             NOW-1DAY
+                ... Exactly 1 day prior to now
+             NOW/DAY+6MONTHS+3DAYS
+                ... 6 months and 3 days in the future from the start of
+                    the current day
+                    
+       Consult the TrieDateField javadocs for more information.
+
+       Note: For faster range queries, consider the tdate type
     -->
-    <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
-
-    <!-- The format for this date field is of the form 1995-12-31T23:59:59Z, and
-         is a more restricted form of the canonical representation of dateTime
-         http://www.w3.org/TR/xmlschema-2/#dateTime    
-         The trailing "Z" designates UTC time and is mandatory.
-         Optional fractional seconds are allowed: 1995-12-31T23:59:59.999Z
-         All other components are mandatory.
-
-         Expressions can also be used to denote calculations that should be
-         performed relative to "NOW" to determine the value, ie...
-
-               NOW/HOUR
-                  ... Round to the start of the current hour
-               NOW-1DAY
-                  ... Exactly 1 day prior to now
-               NOW/DAY+6MONTHS+3DAYS
-                  ... 6 months and 3 days in the future from the start of
-                      the current day
-                      
-         Consult the TrieDateField javadocs for more information.
-
-         Note: For faster range queries, consider the tdate type
-      -->
-    <fieldType name="date" class="solr.TrieDateField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="date" class="solr.TrieDateField" precisionStep="0" positionIncrementGap="0"/>
 
-    <!-- A Trie based date field for faster date range queries and date faceting. -->
-    <fieldType name="tdate" class="solr.TrieDateField" precisionStep="6" positionIncrementGap="0"/>
+  <!-- A Trie based date field for faster date range queries and date faceting. -->
+  <fieldType name="tdate" class="solr.TrieDateField" precisionStep="6" positionIncrementGap="0"/>
 
 
-    <!--Binary data type. The data should be sent/retrieved in as Base64 encoded Strings -->
-    <fieldType name="binary" class="solr.BinaryField"/>
+  <!--Binary data type. The data should be sent/retrieved in as Base64 encoded Strings -->
+  <fieldType name="binary" class="solr.BinaryField"/>
 
-    <!-- The "RandomSortField" is not used to store or search any
-         data.  You can declare fields of this type it in your schema
-         to generate pseudo-random orderings of your docs for sorting 
-         or function purposes.  The ordering is generated based on the field
-         name and the version of the index. As long as the index version
-         remains unchanged, and the same field name is reused,
-         the ordering of the docs will be consistent.  
-         If you want different psuedo-random orderings of documents,
-         for the same version of the index, use a dynamicField and
-         change the field name in the request.
-     -->
-    <fieldType name="random" class="solr.RandomSortField" indexed="true" />
+  <!-- The "RandomSortField" is not used to store or search any
+       data.  You can declare fields of this type it in your schema
+       to generate pseudo-random orderings of your docs for sorting 
+       or function purposes.  The ordering is generated based on the field
+       name and the version of the index. As long as the index version
+       remains unchanged, and the same field name is reused,
+       the ordering of the docs will be consistent.  
+       If you want different psuedo-random orderings of documents,
+       for the same version of the index, use a dynamicField and
+       change the field name in the request.
+   -->
+  <fieldType name="random" class="solr.RandomSortField" indexed="true"/>
 
-    <!-- solr.TextField allows the specification of custom text analyzers
-         specified as a tokenizer and a list of token filters. Different
-         analyzers may be specified for indexing and querying.
+  <!-- solr.TextField allows the specification of custom text analyzers
+       specified as a tokenizer and a list of token filters. Different
+       analyzers may be specified for indexing and querying.
 
-         The optional positionIncrementGap puts space between multiple fields of
-         this type on the same document, with the purpose of preventing false phrase
-         matching across fields.
+       The optional positionIncrementGap puts space between multiple fields of
+       this type on the same document, with the purpose of preventing false phrase
+       matching across fields.
 
-         For more info on customizing your analyzer chain, please see
-         http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters
-     -->
+       For more info on customizing your analyzer chain, please see
+       http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters
+   -->
 
-    <!-- One can also specify an existing Analyzer class that has a
-         default constructor via the class attribute on the analyzer element.
-         Example:
-    <fieldType name="text_greek" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.el.GreekAnalyzer"/>
-    </fieldType>
-    -->
+  <!-- One can also specify an existing Analyzer class that has a
+       default constructor via the class attribute on the analyzer element.
+       Example:
+  <fieldType name="text_greek" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.el.GreekAnalyzer"/>
+  </fieldType>
+  -->
 
-    <!-- A text field that only splits on whitespace for exact matching of words -->
-    <fieldType name="text_ws" class="solr.TextField" positionIncrementGap="100">
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- A general text field that has reasonable, generic
-         cross-language defaults: it tokenizes with StandardTokenizer,
-   removes stop words from case-insensitive "stopwords.txt"
-   (empty by default), and down cases.  At query time only, it
-   also applies synonyms. -->
-    <fieldType name="text_general" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt" />
-        <!-- in this example, we will only use synonyms at query time
-        <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
+  <!-- A text field that only splits on whitespace for exact matching of words -->
+  <fieldType name="text_ws" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- A general text field that has reasonable, generic
+       cross-language defaults: it tokenizes with StandardTokenizer,
+ removes stop words from case-insensitive "stopwords.txt"
+ (empty by default), and down cases.  At query time only, it
+ also applies synonyms. -->
+  <fieldType name="text_general" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+      <!-- in this example, we will only use synonyms at query time
+      <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
+      -->
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- A text field with defaults appropriate for English: it
+       tokenizes with StandardTokenizer, removes English stop words
+       (lang/stopwords_en.txt), down cases, protects words from protwords.txt, and
+       finally applies Porter's stemming.  The query time analyzer
+       also applies synonyms from synonyms.txt. -->
+  <fieldType name="text_en" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- in this example, we will only use synonyms at query time
+      <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
+      -->
+      <!-- Case insensitive stop word removal. -->
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="lang/stopwords_en.txt"
+
+      />
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.EnglishPossessiveFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+            <filter class="solr.EnglishMinimalStemFilterFactory"/>
+      -->
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="lang/stopwords_en.txt"
+
+      />
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.EnglishPossessiveFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+            <filter class="solr.EnglishMinimalStemFilterFactory"/>
+      -->
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- A text field with defaults appropriate for English, plus
+ aggressive word-splitting and autophrase features enabled.
+ This field is just like text_en, except it adds
+ WordDelimiterFilter to enable splitting and matching of
+ words on case-change, alpha numeric boundaries, and
+ non-alphanumeric chars.  This means certain compound word
+ cases will work, for example query "wi fi" will match
+ document "WiFi" or "wi-fi".
+      -->
+  <fieldType name="text_en_splitting" class="solr.TextField" positionIncrementGap="100"
+             autoGeneratePhraseQueries="true">
+    <analyzer type="index">
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <!-- in this example, we will only use synonyms at query time
+      <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
+      -->
+      <!-- Case insensitive stop word removal. -->
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="lang/stopwords_en.txt"
+
+      />
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="lang/stopwords_en.txt"
+
+      />
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Less flexible matching, but less false matches.  Probably not ideal for product names,
+       but may be good for SKUs.  Can insert dashes in the wrong place and still match. -->
+  <fieldType name="text_en_splitting_tight" class="solr.TextField" positionIncrementGap="100"
+             autoGeneratePhraseQueries="true">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="false"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_en.txt"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.EnglishMinimalStemFilterFactory"/>
+      <!-- this filter can remove any duplicate tokens that appear at the same position - sometimes
+           possible with WordDelimiterFilter in conjuncton with stemming. -->
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Just like text_general except it reverses the characters of
+ each token, to enable more efficient leading wildcard queries. -->
+  <fieldType name="text_general_rev" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.ReversedWildcardFilterFactory" withOriginal="true"
+              maxPosAsterisk="3" maxPosQuestion="2" maxFractionAsterisk="0.33"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- charFilter + WhitespaceTokenizer  -->
+  <!--
+  <fieldType name="text_char_norm" class="solr.TextField" positionIncrementGap="100" >
+    <analyzer>
+      <charFilter class="solr.MappingCharFilterFactory" mapping="mapping-ISOLatin1Accent.txt"/>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  -->
+
+  <!-- This is an example of using the KeywordTokenizer along
+       With various TokenFilterFactories to produce a sortable field
+       that does not include some properties of the source text
+    -->
+  <fieldType name="alphaOnlySort" class="solr.TextField" sortMissingLast="true" omitNorms="true">
+    <analyzer>
+      <!-- KeywordTokenizer does no actual tokenizing, so the entire
+           input string is preserved as a single token
+        -->
+      <tokenizer class="solr.KeywordTokenizerFactory"/>
+      <!-- The LowerCase TokenFilter does what you expect, which can be
+           when you want your sorting to be case insensitive
         -->
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt" />
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- A text field with defaults appropriate for English: it
-         tokenizes with StandardTokenizer, removes English stop words
-         (lang/stopwords_en.txt), down cases, protects words from protwords.txt, and
-         finally applies Porter's stemming.  The query time analyzer
-         also applies synonyms from synonyms.txt. -->
-    <fieldType name="text_en" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- in this example, we will only use synonyms at query time
-        <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <!-- The TrimFilter removes any leading or trailing whitespace -->
+      <filter class="solr.TrimFilterFactory"/>
+      <!-- The PatternReplaceFilter gives you the flexibility to use
+           Java Regular expression to replace any sequence of characters
+           matching a pattern with an arbitrary replacement string, 
+           which may include back references to portions of the original
+           string matched by the pattern.
+           
+           See the Java Regular Expression documentation for more
+           information on pattern and replacement string syntax.
+           
+           http://java.sun.com/j2se/1.6.0/docs/api/java/util/regex/package-summary.html
         -->
-        <!-- Case insensitive stop word removal. -->
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="lang/stopwords_en.txt"
-               
-                />
-        <filter class="solr.LowerCaseFilterFactory"/>
-  <filter class="solr.EnglishPossessiveFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
-        <filter class="solr.EnglishMinimalStemFilterFactory"/>
+      <filter class="solr.PatternReplaceFilterFactory"
+              pattern="([^a-z])" replacement="" replace="all"
+      />
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="phonetic" stored="false" indexed="true" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.DoubleMetaphoneFilterFactory" inject="false"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="payloads" stored="false" indexed="true" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <!--
+      The DelimitedPayloadTokenFilter can put payloads on tokens... for example,
+      a token of "foo|1.4"  would be indexed as "foo" with a payload of 1.4f
+      Attributes of the DelimitedPayloadTokenFilterFactory : 
+       "delimiter" - a one character delimiter. Default is | (pipe)
+ "encoder" - how to encode the following value into a playload
+    float -> org.apache.lucene.analysis.payloads.FloatEncoder,
+    integer -> o.a.l.a.p.IntegerEncoder
+    identity -> o.a.l.a.p.IdentityEncoder
+          Fully Qualified class name implementing PayloadEncoder, Encoder must have a no arg constructor.
+       -->
+      <filter class="solr.DelimitedPayloadTokenFilterFactory" encoder="float"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- lowercases the entire field value, keeping it as a single token.  -->
+  <fieldType name="lowercase" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.KeywordTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- 
+    Example of using PathHierarchyTokenizerFactory at index time, so
+    queries for paths match documents at that path, or in descendent paths
   -->
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="lang/stopwords_en.txt"
-               
-                />
-        <filter class="solr.LowerCaseFilterFactory"/>
-  <filter class="solr.EnglishPossessiveFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
-        <filter class="solr.EnglishMinimalStemFilterFactory"/>
+  <fieldType name="descendent_path" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.KeywordTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <!-- 
+    Example of using PathHierarchyTokenizerFactory at query time, so
+    queries for paths match documents at that path, or in ancestor paths
   -->
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- A text field with defaults appropriate for English, plus
-   aggressive word-splitting and autophrase features enabled.
-   This field is just like text_en, except it adds
-   WordDelimiterFilter to enable splitting and matching of
-   words on case-change, alpha numeric boundaries, and
-   non-alphanumeric chars.  This means certain compound word
-   cases will work, for example query "wi fi" will match
-   document "WiFi" or "wi-fi".
-        -->
-    <fieldType name="text_en_splitting" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true">
-      <analyzer type="index">
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <!-- in this example, we will only use synonyms at query time
-        <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
-        -->
-        <!-- Case insensitive stop word removal. -->
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="lang/stopwords_en.txt"
-               
-                />
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="lang/stopwords_en.txt"
-               
-                />
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- Less flexible matching, but less false matches.  Probably not ideal for product names,
-         but may be good for SKUs.  Can insert dashes in the wrong place and still match. -->
-    <fieldType name="text_en_splitting_tight" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true">
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="false"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_en.txt"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.EnglishMinimalStemFilterFactory"/>
-        <!-- this filter can remove any duplicate tokens that appear at the same position - sometimes
-             possible with WordDelimiterFilter in conjuncton with stemming. -->
-        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- Just like text_general except it reverses the characters of
-   each token, to enable more efficient leading wildcard queries. -->
-    <fieldType name="text_general_rev" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt" />
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.ReversedWildcardFilterFactory" withOriginal="true"
-           maxPosAsterisk="3" maxPosQuestion="2" maxFractionAsterisk="0.33"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt" />
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- charFilter + WhitespaceTokenizer  -->
-    <!--
-    <fieldType name="text_char_norm" class="solr.TextField" positionIncrementGap="100" >
-      <analyzer>
-        <charFilter class="solr.MappingCharFilterFactory" mapping="mapping-ISOLatin1Accent.txt"/>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-    -->
+  <fieldType name="ancestor_path" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.KeywordTokenizerFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- since fields of this type are by default not stored or indexed,
+       any data added to them will be ignored outright.  -->
+  <fieldType name="ignored" stored="false" indexed="false" multiValued="true" class="solr.StrField"/>
+
+  <!-- This point type indexes the coordinates as separate fields (subFields)
+    If subFieldType is defined, it references a type, and a dynamic field
+    definition is created matching *___<typename>.  Alternately, if 
+    subFieldSuffix is defined, that is used to create the subFields.
+    Example: if subFieldType="double", then the coordinates would be
+      indexed in fields myloc_0___double,myloc_1___double.
+    Example: if subFieldSuffix="_d" then the coordinates would be indexed
+      in fields myloc_0_d,myloc_1_d
+    The subFields are an implementation detail of the fieldType, and end
+    users normally should not need to know about them.
+   -->
+  <fieldType name="point" class="solr.PointType" dimension="2" subFieldSuffix="_d"/>
 
-    <!-- This is an example of using the KeywordTokenizer along
-         With various TokenFilterFactories to produce a sortable field
-         that does not include some properties of the source text
-      -->
-    <fieldType name="alphaOnlySort" class="solr.TextField" sortMissingLast="true" omitNorms="true">
-      <analyzer>
-        <!-- KeywordTokenizer does no actual tokenizing, so the entire
-             input string is preserved as a single token
-          -->
-        <tokenizer class="solr.KeywordTokenizerFactory"/>
-        <!-- The LowerCase TokenFilter does what you expect, which can be
-             when you want your sorting to be case insensitive
-          -->
-        <filter class="solr.LowerCaseFilterFactory" />
-        <!-- The TrimFilter removes any leading or trailing whitespace -->
-        <filter class="solr.TrimFilterFactory" />
-        <!-- The PatternReplaceFilter gives you the flexibility to use
-             Java Regular expression to replace any sequence of characters
-             matching a pattern with an arbitrary replacement string, 
-             which may include back references to portions of the original
-             string matched by the pattern.
-             
-             See the Java Regular Expression documentation for more
-             information on pattern and replacement string syntax.
-             
-             http://java.sun.com/j2se/1.6.0/docs/api/java/util/regex/package-summary.html
-          -->
-        <filter class="solr.PatternReplaceFilterFactory"
-                pattern="([^a-z])" replacement="" replace="all"
-        />
-      </analyzer>
-    </fieldType>
-    
-    <fieldType name="phonetic" stored="false" indexed="true" class="solr.TextField" >
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.DoubleMetaphoneFilterFactory" inject="false"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="payloads" stored="false" indexed="true" class="solr.TextField" >
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <!--
-        The DelimitedPayloadTokenFilter can put payloads on tokens... for example,
-        a token of "foo|1.4"  would be indexed as "foo" with a payload of 1.4f
-        Attributes of the DelimitedPayloadTokenFilterFactory : 
-         "delimiter" - a one character delimiter. Default is | (pipe)
-   "encoder" - how to encode the following value into a playload
-      float -> org.apache.lucene.analysis.payloads.FloatEncoder,
-      integer -> o.a.l.a.p.IntegerEncoder
-      identity -> o.a.l.a.p.IdentityEncoder
-            Fully Qualified class name implementing PayloadEncoder, Encoder must have a no arg constructor.
-         -->
-        <filter class="solr.DelimitedPayloadTokenFilterFactory" encoder="float"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- lowercases the entire field value, keeping it as a single token.  -->
-    <fieldType name="lowercase" class="solr.TextField" positionIncrementGap="100">
-      <analyzer>
-        <tokenizer class="solr.KeywordTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory" />
-      </analyzer>
-    </fieldType>
-
-    <!-- 
-      Example of using PathHierarchyTokenizerFactory at index time, so
-      queries for paths match documents at that path, or in descendent paths
-    -->
-    <fieldType name="descendent_path" class="solr.TextField">
-      <analyzer type="index">
-  <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
-      </analyzer>
-      <analyzer type="query">
-  <tokenizer class="solr.KeywordTokenizerFactory" />
-      </analyzer>
-    </fieldType>
-    <!-- 
-      Example of using PathHierarchyTokenizerFactory at query time, so
-      queries for paths match documents at that path, or in ancestor paths
-    -->
-    <fieldType name="ancestor_path" class="solr.TextField">
-      <analyzer type="index">
-  <tokenizer class="solr.KeywordTokenizerFactory" />
-      </analyzer>
-      <analyzer type="query">
-  <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
-      </analyzer>
-    </fieldType>
-
-    <!-- since fields of this type are by default not stored or indexed,
-         any data added to them will be ignored outright.  --> 
-    <fieldType name="ignored" stored="false" indexed="false" multiValued="true" class="solr.StrField" />
-
-    <!-- This point type indexes the coordinates as separate fields (subFields)
-      If subFieldType is defined, it references a type, and a dynamic field
-      definition is created matching *___<typename>.  Alternately, if 
-      subFieldSuffix is defined, that is used to create the subFields.
-      Example: if subFieldType="double", then the coordinates would be
-        indexed in fields myloc_0___double,myloc_1___double.
-      Example: if subFieldSuffix="_d" then the coordinates would be indexed
-        in fields myloc_0_d,myloc_1_d
-      The subFields are an implementation detail of the fieldType, and end
-      users normally should not need to know about them.
-     -->
-    <fieldType name="point" class="solr.PointType" dimension="2" subFieldSuffix="_d"/>
+  <!-- A specialized field for geospatial search. If indexed, this fieldType must not be multivalued. -->
+  <fieldType name="location" class="solr.LatLonType" subFieldSuffix="_coordinate"/>
+
+  <!-- An alternative geospatial field type new to Solr 4.  It supports multiValued and polygon shapes.
+    For more information about this and other Spatial fields new to Solr 4, see:
+    http://wiki.apache.org/solr/SolrAdaptersForLuceneSpatial4
+  -->
+  <fieldType name="location_rpt" class="solr.SpatialRecursivePrefixTreeFieldType"
+             geo="true" distErrPct="0.025" maxDistErr="0.001" distanceUnits="kilometers"/>
+
+  <!-- Money/currency field type. See http://wiki.apache.org/solr/MoneyFieldType
+       Parameters:
+         defaultCurrency: Specifies the default currency if none specified. Defaults to "USD"
+         precisionStep:   Specifies the precisionStep for the TrieLong field used for the amount
+         providerClass:   Lets you plug in other exchange provider backend:
+                          solr.FileExchangeRateProvider is the default and takes one parameter:
+                            currencyConfig: name of an xml file holding exchange rates
+                          solr.OpenExchangeRatesOrgProvider uses rates from openexchangerates.org:
+                            ratesFileLocation: URL or path to rates JSON file (default latest.json on the web)
+                            refreshInterval: Number of minutes between each rates fetch (default: 1440, min: 60)
+  -->
+  <fieldType name="currency" class="solr.CurrencyField" precisionStep="8" defaultCurrency="USD"
+             currencyConfig="currency.xml"/>
+
+
+  <!-- some examples for different languages (generally ordered by ISO code) -->
+
+  <!-- Arabic -->
+  <fieldType name="text_ar" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- for any non-arabic -->
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ar.txt"/>
+      <!-- normalizes ? to ?, etc -->
+      <filter class="solr.ArabicNormalizationFilterFactory"/>
+      <filter class="solr.ArabicStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Bulgarian -->
+  <fieldType name="text_bg" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_bg.txt"/>
+      <filter class="solr.BulgarianStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Catalan -->
+  <fieldType name="text_ca" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- removes l', etc -->
+      <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_ca.txt"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ca.txt"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Catalan"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- CJK bigram (see text_ja for a Japanese configuration using morphological analysis) -->
+  <fieldType name="text_cjk" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- normalize width before bigram, as e.g. half-width dakuten combine  -->
+      <filter class="solr.CJKWidthFilterFactory"/>
+      <!-- for any non-CJK -->
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.CJKBigramFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Czech -->
+  <fieldType name="text_cz" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_cz.txt"/>
+      <filter class="solr.CzechStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Danish -->
+  <fieldType name="text_da" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_da.txt" format="snowball"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Danish"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- German -->
+  <fieldType name="text_de" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_de.txt" format="snowball"/>
+      <filter class="solr.GermanNormalizationFilterFactory"/>
+      <filter class="solr.GermanLightStemFilterFactory"/>
+      <!-- less aggressive: <filter class="solr.GermanMinimalStemFilterFactory"/> -->
+      <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="German2"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Greek -->
+  <fieldType name="text_el" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- greek specific lowercase for sigma -->
+      <filter class="solr.GreekLowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="false" words="lang/stopwords_el.txt"/>
+      <filter class="solr.GreekStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Spanish -->
+  <fieldType name="text_es" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_es.txt" format="snowball"/>
+      <filter class="solr.SpanishLightStemFilterFactory"/>
+      <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="Spanish"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Basque -->
+  <fieldType name="text_eu" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_eu.txt"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Basque"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Persian -->
+  <fieldType name="text_fa" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <!-- for ZWNJ -->
+      <charFilter class="solr.PersianCharFilterFactory"/>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.ArabicNormalizationFilterFactory"/>
+      <filter class="solr.PersianNormalizationFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_fa.txt"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Finnish -->
+  <fieldType name="text_fi" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_fi.txt" format="snowball"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Finnish"/>
+      <!-- less aggressive: <filter class="solr.FinnishLightStemFilterFactory"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- French -->
+  <fieldType name="text_fr" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- removes l', etc -->
+      <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_fr.txt"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_fr.txt" format="snowball"/>
+      <filter class="solr.FrenchLightStemFilterFactory"/>
+      <!-- less aggressive: <filter class="solr.FrenchMinimalStemFilterFactory"/> -->
+      <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="French"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Irish -->
+  <fieldType name="text_ga" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- removes d', etc -->
+      <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_ga.txt"/>
+      <!-- removes n-, etc. position increments is intentionally false! -->
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/hyphenations_ga.txt"/>
+      <filter class="solr.IrishLowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ga.txt"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Irish"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Galician -->
+  <fieldType name="text_gl" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_gl.txt"/>
+      <filter class="solr.GalicianStemFilterFactory"/>
+      <!-- less aggressive: <filter class="solr.GalicianMinimalStemFilterFactory"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Hindi -->
+  <fieldType name="text_hi" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <!-- normalizes unicode representation -->
+      <filter class="solr.IndicNormalizationFilterFactory"/>
+      <!-- normalizes variation in spelling -->
+      <filter class="solr.HindiNormalizationFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_hi.txt"/>
+      <filter class="solr.HindiStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Hungarian -->
+  <fieldType name="text_hu" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_hu.txt" format="snowball"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Hungarian"/>
+      <!-- less aggressive: <filter class="solr.HungarianLightStemFilterFactory"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Armenian -->
+  <fieldType name="text_hy" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_hy.txt"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Armenian"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Indonesian -->
+  <fieldType name="text_id" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_id.txt"/>
+      <!-- for a less aggressive approach (only inflectional suffixes), set stemDerivational to false -->
+      <filter class="solr.IndonesianStemFilterFactory" stemDerivational="true"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Italian -->
+  <fieldType name="text_it" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- removes l', etc -->
+      <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_it.txt"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_it.txt" format="snowball"/>
+      <filter class="solr.ItalianLightStemFilterFactory"/>
+      <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="Italian"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Latvian -->
+  <fieldType name="text_lv" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_lv.txt"/>
+      <filter class="solr.LatvianStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Dutch -->
+  <fieldType name="text_nl" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_nl.txt" format="snowball"/>
+      <filter class="solr.StemmerOverrideFilterFactory" dictionary="lang/stemdict_nl.txt" ignoreCase="false"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Dutch"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Norwegian -->
+  <fieldType name="text_no" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_no.txt" format="snowball"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Norwegian"/>
+      <!-- less aggressive: <filter class="solr.NorwegianLightStemFilterFactory"/> -->
+      <!-- singular/plural: <filter class="solr.NorwegianMinimalStemFilterFactory"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Portuguese -->
+  <fieldType name="text_pt" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_pt.txt" format="snowball"/>
+      <filter class="solr.PortugueseLightStemFilterFactory"/>
+      <!-- less aggressive: <filter class="solr.PortugueseMinimalStemFilterFactory"/> -->
+      <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="Portuguese"/> -->
+      <!-- most aggressive: <filter class="solr.PortugueseStemFilterFactory"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Romanian -->
+  <fieldType name="text_ro" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ro.txt"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Romanian"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Russian -->
+  <fieldType name="text_ru" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ru.txt" format="snowball"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Russian"/>
+      <!-- less aggressive: <filter class="solr.RussianLightStemFilterFactory"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Swedish -->
+  <fieldType name="text_sv" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_sv.txt" format="snowball"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Swedish"/>
+      <!-- less aggressive: <filter class="solr.SwedishLightStemFilterFactory"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Thai -->
+  <fieldType name="text_th" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.ThaiTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_th.txt"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Turkish -->
+  <fieldType name="text_tr" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.TurkishLowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="false" words="lang/stopwords_tr.txt"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Turkish"/>
+    </analyzer>
+  </fieldType>
 
-    <!-- A specialized field for geospatial search. If indexed, this fieldType must not be multivalued. -->
-    <fieldType name="location" class="solr.LatLonType" subFieldSuffix="_coordinate"/>
 
-    <!-- An alternative geospatial field type new to Solr 4.  It supports multiValued and polygon shapes.
-      For more information about this and other Spatial fields new to Solr 4, see:
-      http://wiki.apache.org/solr/SolrAdaptersForLuceneSpatial4
-    -->
-    <fieldType name="location_rpt" class="solr.SpatialRecursivePrefixTreeFieldType"
-        geo="true" distErrPct="0.025" maxDistErr="0.001" distanceUnits="kilometers" />
-
-   <!-- Money/currency field type. See http://wiki.apache.org/solr/MoneyFieldType
-        Parameters:
-          defaultCurrency: Specifies the default currency if none specified. Defaults to "USD"
-          precisionStep:   Specifies the precisionStep for the TrieLong field used for the amount
-          providerClass:   Lets you plug in other exchange provider backend:
-                           solr.FileExchangeRateProvider is the default and takes one parameter:
-                             currencyConfig: name of an xml file holding exchange rates
-                           solr.OpenExchangeRatesOrgProvider uses rates from openexchangerates.org:
-                             ratesFileLocation: URL or path to rates JSON file (default latest.json on the web)
-                             refreshInterval: Number of minutes between each rates fetch (default: 1440, min: 60)
-   -->
-    <fieldType name="currency" class="solr.CurrencyField" precisionStep="8" defaultCurrency="USD" currencyConfig="currency.xml" />
-             
-
-
-   <!-- some examples for different languages (generally ordered by ISO code) -->
-
-    <!-- Arabic -->
-    <fieldType name="text_ar" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- for any non-arabic -->
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ar.txt"/>
-        <!-- normalizes ? to ?, etc -->
-        <filter class="solr.ArabicNormalizationFilterFactory"/>
-        <filter class="solr.ArabicStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- Bulgarian -->
-    <fieldType name="text_bg" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/> 
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_bg.txt"/>
-        <filter class="solr.BulgarianStemFilterFactory"/>       
-      </analyzer>
-    </fieldType>
-    
-    <!-- Catalan -->
-    <fieldType name="text_ca" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- removes l', etc -->
-        <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_ca.txt"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ca.txt"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Catalan"/>       
-      </analyzer>
-    </fieldType>
-    
-    <!-- CJK bigram (see text_ja for a Japanese configuration using morphological analysis) -->
-    <fieldType name="text_cjk" class="solr.TextField" positionIncrementGap="100">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- normalize width before bigram, as e.g. half-width dakuten combine  -->
-        <filter class="solr.CJKWidthFilterFactory"/>
-        <!-- for any non-CJK -->
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.CJKBigramFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- Czech -->
-    <fieldType name="text_cz" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_cz.txt"/>
-        <filter class="solr.CzechStemFilterFactory"/>       
-      </analyzer>
-    </fieldType>
-    
-    <!-- Danish -->
-    <fieldType name="text_da" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_da.txt" format="snowball"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Danish"/>       
-      </analyzer>
-    </fieldType>
-    
-    <!-- German -->
-    <fieldType name="text_de" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_de.txt" format="snowball"/>
-        <filter class="solr.GermanNormalizationFilterFactory"/>
-        <filter class="solr.GermanLightStemFilterFactory"/>
-        <!-- less aggressive: <filter class="solr.GermanMinimalStemFilterFactory"/> -->
-        <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="German2"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Greek -->
-    <fieldType name="text_el" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- greek specific lowercase for sigma -->
-        <filter class="solr.GreekLowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="false" words="lang/stopwords_el.txt"/>
-        <filter class="solr.GreekStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Spanish -->
-    <fieldType name="text_es" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_es.txt" format="snowball"/>
-        <filter class="solr.SpanishLightStemFilterFactory"/>
-        <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="Spanish"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Basque -->
-    <fieldType name="text_eu" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_eu.txt"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Basque"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Persian -->
-    <fieldType name="text_fa" class="solr.TextField" positionIncrementGap="100">
-      <analyzer>
-        <!-- for ZWNJ -->
-        <charFilter class="solr.PersianCharFilterFactory"/>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.ArabicNormalizationFilterFactory"/>
-        <filter class="solr.PersianNormalizationFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_fa.txt"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Finnish -->
-    <fieldType name="text_fi" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_fi.txt" format="snowball"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Finnish"/>
-        <!-- less aggressive: <filter class="solr.FinnishLightStemFilterFactory"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- French -->
-    <fieldType name="text_fr" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- removes l', etc -->
-        <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_fr.txt"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_fr.txt" format="snowball"/>
-        <filter class="solr.FrenchLightStemFilterFactory"/>
-        <!-- less aggressive: <filter class="solr.FrenchMinimalStemFilterFactory"/> -->
-        <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="French"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Irish -->
-    <fieldType name="text_ga" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- removes d', etc -->
-        <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_ga.txt"/>
-        <!-- removes n-, etc. position increments is intentionally false! -->
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/hyphenations_ga.txt"/>
-        <filter class="solr.IrishLowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ga.txt"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Irish"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Galician -->
-    <fieldType name="text_gl" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_gl.txt"/>
-        <filter class="solr.GalicianStemFilterFactory"/>
-        <!-- less aggressive: <filter class="solr.GalicianMinimalStemFilterFactory"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Hindi -->
-    <fieldType name="text_hi" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <!-- normalizes unicode representation -->
-        <filter class="solr.IndicNormalizationFilterFactory"/>
-        <!-- normalizes variation in spelling -->
-        <filter class="solr.HindiNormalizationFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_hi.txt"/>
-        <filter class="solr.HindiStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Hungarian -->
-    <fieldType name="text_hu" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_hu.txt" format="snowball"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Hungarian"/>
-        <!-- less aggressive: <filter class="solr.HungarianLightStemFilterFactory"/> -->   
-      </analyzer>
-    </fieldType>
-    
-    <!-- Armenian -->
-    <fieldType name="text_hy" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_hy.txt"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Armenian"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Indonesian -->
-    <fieldType name="text_id" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_id.txt"/>
-        <!-- for a less aggressive approach (only inflectional suffixes), set stemDerivational to false -->
-        <filter class="solr.IndonesianStemFilterFactory" stemDerivational="true"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Italian -->
-    <fieldType name="text_it" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- removes l', etc -->
-        <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_it.txt"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_it.txt" format="snowball"/>
-        <filter class="solr.ItalianLightStemFilterFactory"/>
-        <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="Italian"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Latvian -->
-    <fieldType name="text_lv" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_lv.txt"/>
-        <filter class="solr.LatvianStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Dutch -->
-    <fieldType name="text_nl" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_nl.txt" format="snowball"/>
-        <filter class="solr.StemmerOverrideFilterFactory" dictionary="lang/stemdict_nl.txt" ignoreCase="false"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Dutch"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Norwegian -->
-    <fieldType name="text_no" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_no.txt" format="snowball"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Norwegian"/>
-        <!-- less aggressive: <filter class="solr.NorwegianLightStemFilterFactory"/> -->
-        <!-- singular/plural: <filter class="solr.NorwegianMinimalStemFilterFactory"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Portuguese -->
-    <fieldType name="text_pt" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_pt.txt" format="snowball"/>
-        <filter class="solr.PortugueseLightStemFilterFactory"/>
-        <!-- less aggressive: <filter class="solr.PortugueseMinimalStemFilterFactory"/> -->
-        <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="Portuguese"/> -->
-        <!-- most aggressive: <filter class="solr.PortugueseStemFilterFactory"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Romanian -->
-    <fieldType name="text_ro" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ro.txt"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Romanian"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Russian -->
-    <fieldType name="text_ru" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ru.txt" format="snowball"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Russian"/>
-        <!-- less aggressive: <filter class="solr.RussianLightStemFilterFactory"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Swedish -->
-    <fieldType name="text_sv" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_sv.txt" format="snowball"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Swedish"/>
-        <!-- less aggressive: <filter class="solr.SwedishLightStemFilterFactory"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Thai -->
-    <fieldType name="text_th" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.ThaiTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_th.txt"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Turkish -->
-    <fieldType name="text_tr" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.TurkishLowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="false" words="lang/stopwords_tr.txt"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Turkish"/>
-      </analyzer>
-    </fieldType>
-
- </types>
-  
   <!-- Similarity is the scoring routine for each document vs. a query.
        A custom Similarity or SimilarityFactory may be specified here, but 
        the default is fine for most applications.  
diff --git a/solr/contrib/morphlines-core/src/test-files/solr/mrunit/conf/schema.xml b/solr/contrib/morphlines-core/src/test-files/solr/mrunit/conf/schema.xml
index e1dc373..bb2f803 100644
--- a/solr/contrib/morphlines-core/src/test-files/solr/mrunit/conf/schema.xml
+++ b/solr/contrib/morphlines-core/src/test-files/solr/mrunit/conf/schema.xml
@@ -64,868 +64,868 @@
        1.6: useDocValuesAsStored defaults to true.
      -->
 
- <fields>
-   <!-- Valid attributes for fields:
-     name: mandatory - the name for the field
-     type: mandatory - the name of a field type from the 
-       <types> fieldType section
-     indexed: true if this field should be indexed (searchable or sortable)
-     stored: true if this field should be retrievable
-     docValues: true if this field should have doc values. Doc values are
-       useful for faceting, grouping, sorting and function queries. Although not
-       required, doc values will make the index faster to load, more
-       NRT-friendly and more memory-efficient. They however come with some
-       limitations: they are currently only supported by StrField, UUIDField
-       and all Trie*Fields, and depending on the field type, they might
-       require the field to be single-valued, be required or have a default
-       value (check the documentation of the field type you're interested in
-       for more information)
-     multiValued: true if this field may contain multiple values per document
-     omitNorms: (expert) set to true to omit the norms associated with
-       this field (this disables length normalization and index-time
-       boosting for the field, and saves some memory).  Only full-text
-       fields or fields that need an index-time boost need norms.
-       Norms are omitted for primitive (non-analyzed) types by default.
-     termVectors: [false] set to true to store the term vector for a
-       given field.
-       When using MoreLikeThis, fields used for similarity should be
-       stored for best performance.
-     termPositions: Store position information with the term vector.  
-       This will increase storage costs.
-     termOffsets: Store offset information with the term vector. This 
-       will increase storage costs.
-     required: The field is required.  It will throw an error if the
-       value does not exist
-     default: a value that should be used if no value is specified
-       when adding a document.
-   -->
 
-   <!-- field names should consist of alphanumeric or underscore characters only and
-      not start with a digit.  This is not currently strictly enforced,
-      but other field names will not have first class support from all components
-      and back compatibility is not guaranteed.  Names with both leading and
-      trailing underscores (e.g. _version_) are reserved.
-   -->
-        
-   <field name="id" type="string" indexed="true" stored="true" required="true" multiValued="false" /> 
-   <field name="user_friends_count" type="tint" indexed="true" stored="true" />
-   <field name="user_location" type="lowercase" indexed="true" stored="true" />
-   <field name="user_description" type="text_en" indexed="true" stored="false"/>
-   <field name="user_statuses_count" type="tint" indexed="true" stored="true" />
-   <field name="user_followers_count" type="tint" indexed="true" stored="true"/>
-   <field name="user_name" type="text_en" indexed="true" stored="true" />
-   <field name="user_screen_name" type="text_en" indexed="true" stored="true" />
-   <field name="created_at" type="tdate" indexed="true" stored="true" />
-   <field name="text" type="text_en" indexed="true" stored="true" />
-   <field name="retweet_count" type="tint" indexed="true" stored="true" />
-   <field name="retweeted" type="boolean" indexed="true" stored="false" />
-   <field name="in_reply_to_user_id" type="long" indexed="true" stored="true" />
-   <field name="source" type="lowercase" indexed="true" stored="true" />
-   <field name="in_reply_to_status_id" type="long" indexed="true" stored="true" multiValued="true"/>
-   <field name="media_url_https" type="string" indexed="false" stored="true" />
-   <field name="expanded_url" type="string" indexed="false" stored="true" />
-
-   <!-- file metadata -->   
-   <field name="file_download_url" type="string" indexed="false" stored="true" />
-   <field name="file_upload_url" type="string" indexed="false" stored="true" />
-   <field name="file_scheme" type="string" indexed="true" stored="true" />
-   <field name="file_host" type="string" indexed="true" stored="true" />
-   <field name="file_port" type="int" indexed="true" stored="true" />
-   <field name="file_path" type="string" indexed="true" stored="true" />
-   <field name="file_name" type="string" indexed="true" stored="true" />
-   <field name="file_length" type="tlong" indexed="true" stored="true" />
-   <field name="file_last_modified" type="tlong" indexed="true" stored="true" />
-   <field name="file_owner" type="string" indexed="true" stored="true" />
-   <field name="file_group" type="string" indexed="true" stored="true" />
-   <field name="file_permissions_user" type="string" indexed="true" stored="true" />
-   <field name="file_permissions_group" type="string" indexed="true" stored="true" />
-   <field name="file_permissions_other" type="string" indexed="true" stored="true" />
-   <field name="file_permissions_stickybit" type="boolean" indexed="true" stored="true" />
-
-   <!-- tika metadata -->
-   <field name="content_type" type="lowercase" indexed="true" stored="true" />
-
-   <field name="_version_" type="long" indexed="true" stored="true"/>
-   <dynamicField name="ignored_*" type="ignored"/>
-   
- </fields>
-
-
- <!-- Field to use to determine and enforce document uniqueness. 
-      Unless this field is marked with required="false", it will be a required field
-   -->
- <uniqueKey>id</uniqueKey>
-
- <!-- DEPRECATED: The defaultSearchField is consulted by various query parsers when
-  parsing a query string that isn't explicit about the field.  Machine (non-user)
-  generated queries are best made explicit, or they can use the "df" request parameter
-  which takes precedence over this.
-  Note: Un-commenting defaultSearchField will be insufficient if your request handler
-  in solrconfig.xml defines "df", which takes precedence. That would need to be removed.
- <defaultSearchField>text</defaultSearchField> -->
-
- <!-- DEPRECATED: The defaultOperator (AND|OR) is consulted by various query parsers
-  when parsing a query string to determine if a clause of the query should be marked as
-  required or optional, assuming the clause isn't already marked by some operator.
-  The default is OR, which is generally assumed so it is not a good idea to change it
-  globally here.  The "q.op" request parameter takes precedence over this.
- <solrQueryParser defaultOperator="OR"/> -->
+  <!-- Valid attributes for fields:
+    name: mandatory - the name for the field
+    type: mandatory - the name of a field type from the 
+      fieldTypes section
+    indexed: true if this field should be indexed (searchable or sortable)
+    stored: true if this field should be retrievable
+    docValues: true if this field should have doc values. Doc values are
+      useful for faceting, grouping, sorting and function queries. Although not
+      required, doc values will make the index faster to load, more
+      NRT-friendly and more memory-efficient. They however come with some
+      limitations: they are currently only supported by StrField, UUIDField
+      and all Trie*Fields, and depending on the field type, they might
+      require the field to be single-valued, be required or have a default
+      value (check the documentation of the field type you're interested in
+      for more information)
+    multiValued: true if this field may contain multiple values per document
+    omitNorms: (expert) set to true to omit the norms associated with
+      this field (this disables length normalization and index-time
+      boosting for the field, and saves some memory).  Only full-text
+      fields or fields that need an index-time boost need norms.
+      Norms are omitted for primitive (non-analyzed) types by default.
+    termVectors: [false] set to true to store the term vector for a
+      given field.
+      When using MoreLikeThis, fields used for similarity should be
+      stored for best performance.
+    termPositions: Store position information with the term vector.  
+      This will increase storage costs.
+    termOffsets: Store offset information with the term vector. This 
+      will increase storage costs.
+    required: The field is required.  It will throw an error if the
+      value does not exist
+    default: a value that should be used if no value is specified
+      when adding a document.
+  -->
+
+  <!-- field names should consist of alphanumeric or underscore characters only and
+     not start with a digit.  This is not currently strictly enforced,
+     but other field names will not have first class support from all components
+     and back compatibility is not guaranteed.  Names with both leading and
+     trailing underscores (e.g. _version_) are reserved.
+  -->
+
+  <field name="id" type="string" indexed="true" stored="true" required="true" multiValued="false"/>
+  <field name="user_friends_count" type="tint" indexed="true" stored="true"/>
+  <field name="user_location" type="lowercase" indexed="true" stored="true"/>
+  <field name="user_description" type="text_en" indexed="true" stored="false"/>
+  <field name="user_statuses_count" type="tint" indexed="true" stored="true"/>
+  <field name="user_followers_count" type="tint" indexed="true" stored="true"/>
+  <field name="user_name" type="text_en" indexed="true" stored="true"/>
+  <field name="user_screen_name" type="text_en" indexed="true" stored="true"/>
+  <field name="created_at" type="tdate" indexed="true" stored="true"/>
+  <field name="text" type="text_en" indexed="true" stored="true"/>
+  <field name="retweet_count" type="tint" indexed="true" stored="true"/>
+  <field name="retweeted" type="boolean" indexed="true" stored="false"/>
+  <field name="in_reply_to_user_id" type="long" indexed="true" stored="true"/>
+  <field name="source" type="lowercase" indexed="true" stored="true"/>
+  <field name="in_reply_to_status_id" type="long" indexed="true" stored="true" multiValued="true"/>
+  <field name="media_url_https" type="string" indexed="false" stored="true"/>
+  <field name="expanded_url" type="string" indexed="false" stored="true"/>
+
+  <!-- file metadata -->
+  <field name="file_download_url" type="string" indexed="false" stored="true"/>
+  <field name="file_upload_url" type="string" indexed="false" stored="true"/>
+  <field name="file_scheme" type="string" indexed="true" stored="true"/>
+  <field name="file_host" type="string" indexed="true" stored="true"/>
+  <field name="file_port" type="int" indexed="true" stored="true"/>
+  <field name="file_path" type="string" indexed="true" stored="true"/>
+  <field name="file_name" type="string" indexed="true" stored="true"/>
+  <field name="file_length" type="tlong" indexed="true" stored="true"/>
+  <field name="file_last_modified" type="tlong" indexed="true" stored="true"/>
+  <field name="file_owner" type="string" indexed="true" stored="true"/>
+  <field name="file_group" type="string" indexed="true" stored="true"/>
+  <field name="file_permissions_user" type="string" indexed="true" stored="true"/>
+  <field name="file_permissions_group" type="string" indexed="true" stored="true"/>
+  <field name="file_permissions_other" type="string" indexed="true" stored="true"/>
+  <field name="file_permissions_stickybit" type="boolean" indexed="true" stored="true"/>
+
+  <!-- tika metadata -->
+  <field name="content_type" type="lowercase" indexed="true" stored="true"/>
+
+  <field name="_version_" type="long" indexed="true" stored="true"/>
+  <dynamicField name="ignored_*" type="ignored"/>
+
+  <!-- Field to use to determine and enforce document uniqueness. 
+       Unless this field is marked with required="false", it will be a required field
+    -->
+  <uniqueKey>id</uniqueKey>
+
+  <!-- DEPRECATED: The defaultSearchField is consulted by various query parsers when
+   parsing a query string that isn't explicit about the field.  Machine (non-user)
+   generated queries are best made explicit, or they can use the "df" request parameter
+   which takes precedence over this.
+   Note: Un-commenting defaultSearchField will be insufficient if your request handler
+   in solrconfig.xml defines "df", which takes precedence. That would need to be removed.
+  <defaultSearchField>text</defaultSearchField> -->
+
+  <!-- DEPRECATED: The defaultOperator (AND|OR) is consulted by various query parsers
+   when parsing a query string to determine if a clause of the query should be marked as
+   required or optional, assuming the clause isn't already marked by some operator.
+   The default is OR, which is generally assumed so it is not a good idea to change it
+   globally here.  The "q.op" request parameter takes precedence over this.
+  <solrQueryParser defaultOperator="OR"/> -->
 
   <!-- copyField commands copy one field to another at the time a document
         is added to the index.  It's used either to index the same field differently,
         or to add multiple fields to the same field for easier/faster searching.  -->
 
-  
-  <types>
-    <!-- field type definitions. The "name" attribute is
-       just a label to be used by field definitions.  The "class"
-       attribute and any other attributes determine the real
-       behavior of the fieldType.
-         Class names starting with "solr" refer to java classes in a
-       standard package such as org.apache.solr.analysis
-    -->
 
-    <!-- The StrField type is not analyzed, but indexed/stored verbatim.
-       It supports doc values but in that case the field needs to be
-       single-valued and either required or have a default value.
-      -->
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true" />
-
-    <!-- boolean type: "true" or "false" -->
-    <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
-
-    <!-- sortMissingLast and sortMissingFirst attributes are optional attributes are
-         currently supported on types that are sorted internally as strings
-         and on numeric types.
-       This includes "string","boolean", and, as of 3.5 (and 4.x),
-       int, float, long, date, double, including the "Trie" variants.
-       - If sortMissingLast="true", then a sort on this field will cause documents
-         without the field to come after documents with the field,
-         regardless of the requested sort order (asc or desc).
-       - If sortMissingFirst="true", then a sort on this field will cause documents
-         without the field to come before documents with the field,
-         regardless of the requested sort order.
-       - If sortMissingLast="false" and sortMissingFirst="false" (the default),
-         then default lucene sorting will be used which places docs without the
-         field first in an ascending sort and last in a descending sort.
-    -->    
-
-    <!--
-      Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
-
-      These fields support doc values, but they require the field to be
-      single-valued and either be required or have a default value.
+  <!-- field type definitions. The "name" attribute is
+     just a label to be used by field definitions.  The "class"
+     attribute and any other attributes determine the real
+     behavior of the fieldType.
+       Class names starting with "solr" refer to java classes in a
+     standard package such as org.apache.solr.analysis
+  -->
+
+  <!-- The StrField type is not analyzed, but indexed/stored verbatim.
+     It supports doc values but in that case the field needs to be
+     single-valued and either required or have a default value.
     -->
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
-
-    <!--
-     Numeric field types that index each value at various levels of precision
-     to accelerate range queries when the number of values between the range
-     endpoints is large. See the javadoc for LegacyNumericRangeQuery for internal
-     implementation details.
-
-     Smaller precisionStep values (specified in bits) will lead to more tokens
-     indexed per value, slightly larger index size, and faster range queries.
-     A precisionStep of 0 disables indexing at different precision levels.
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+
+  <!-- boolean type: "true" or "false" -->
+  <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
+
+  <!-- sortMissingLast and sortMissingFirst attributes are optional attributes are
+       currently supported on types that are sorted internally as strings
+       and on numeric types.
+     This includes "string","boolean", and, as of 3.5 (and 4.x),
+     int, float, long, date, double, including the "Trie" variants.
+     - If sortMissingLast="true", then a sort on this field will cause documents
+       without the field to come after documents with the field,
+       regardless of the requested sort order (asc or desc).
+     - If sortMissingFirst="true", then a sort on this field will cause documents
+       without the field to come before documents with the field,
+       regardless of the requested sort order.
+     - If sortMissingLast="false" and sortMissingFirst="false" (the default),
+       then default lucene sorting will be used which places docs without the
+       field first in an ascending sort and last in a descending sort.
+  -->
+
+  <!--
+    Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
+
+    These fields support doc values, but they require the field to be
+    single-valued and either be required or have a default value.
+  -->
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
+
+  <!--
+   Numeric field types that index each value at various levels of precision
+   to accelerate range queries when the number of values between the range
+   endpoints is large. See the javadoc for LegacyNumericRangeQuery for internal
+   implementation details.
+
+   Smaller precisionStep values (specified in bits) will lead to more tokens
+   indexed per value, slightly larger index size, and faster range queries.
+   A precisionStep of 0 disables indexing at different precision levels.
+  -->
+  <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
+
+  <!-- The format for this date field is of the form 1995-12-31T23:59:59Z, and
+       is a more restricted form of the canonical representation of dateTime
+       http://www.w3.org/TR/xmlschema-2/#dateTime    
+       The trailing "Z" designates UTC time and is mandatory.
+       Optional fractional seconds are allowed: 1995-12-31T23:59:59.999Z
+       All other components are mandatory.
+
+       Expressions can also be used to denote calculations that should be
+       performed relative to "NOW" to determine the value, ie...
+
+             NOW/HOUR
+                ... Round to the start of the current hour
+             NOW-1DAY
+                ... Exactly 1 day prior to now
+             NOW/DAY+6MONTHS+3DAYS
+                ... 6 months and 3 days in the future from the start of
+                    the current day
+                    
+       Consult the TrieDateField javadocs for more information.
+
+       Note: For faster range queries, consider the tdate type
     -->
-    <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
-
-    <!-- The format for this date field is of the form 1995-12-31T23:59:59Z, and
-         is a more restricted form of the canonical representation of dateTime
-         http://www.w3.org/TR/xmlschema-2/#dateTime    
-         The trailing "Z" designates UTC time and is mandatory.
-         Optional fractional seconds are allowed: 1995-12-31T23:59:59.999Z
-         All other components are mandatory.
-
-         Expressions can also be used to denote calculations that should be
-         performed relative to "NOW" to determine the value, ie...
-
-               NOW/HOUR
-                  ... Round to the start of the current hour
-               NOW-1DAY
-                  ... Exactly 1 day prior to now
-               NOW/DAY+6MONTHS+3DAYS
-                  ... 6 months and 3 days in the future from the start of
-                      the current day
-                      
-         Consult the TrieDateField javadocs for more information.
-
-         Note: For faster range queries, consider the tdate type
-      -->
-    <fieldType name="date" class="solr.TrieDateField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="date" class="solr.TrieDateField" precisionStep="0" positionIncrementGap="0"/>
 
-    <!-- A Trie based date field for faster date range queries and date faceting. -->
-    <fieldType name="tdate" class="solr.TrieDateField" precisionStep="6" positionIncrementGap="0"/>
+  <!-- A Trie based date field for faster date range queries and date faceting. -->
+  <fieldType name="tdate" class="solr.TrieDateField" precisionStep="6" positionIncrementGap="0"/>
 
 
-    <!--Binary data type. The data should be sent/retrieved in as Base64 encoded Strings -->
-    <fieldType name="binary" class="solr.BinaryField"/>
+  <!--Binary data type. The data should be sent/retrieved in as Base64 encoded Strings -->
+  <fieldType name="binary" class="solr.BinaryField"/>
 
-    <!-- The "RandomSortField" is not used to store or search any
-         data.  You can declare fields of this type it in your schema
-         to generate pseudo-random orderings of your docs for sorting 
-         or function purposes.  The ordering is generated based on the field
-         name and the version of the index. As long as the index version
-         remains unchanged, and the same field name is reused,
-         the ordering of the docs will be consistent.  
-         If you want different psuedo-random orderings of documents,
-         for the same version of the index, use a dynamicField and
-         change the field name in the request.
-     -->
-    <fieldType name="random" class="solr.RandomSortField" indexed="true" />
+  <!-- The "RandomSortField" is not used to store or search any
+       data.  You can declare fields of this type it in your schema
+       to generate pseudo-random orderings of your docs for sorting 
+       or function purposes.  The ordering is generated based on the field
+       name and the version of the index. As long as the index version
+       remains unchanged, and the same field name is reused,
+       the ordering of the docs will be consistent.  
+       If you want different psuedo-random orderings of documents,
+       for the same version of the index, use a dynamicField and
+       change the field name in the request.
+   -->
+  <fieldType name="random" class="solr.RandomSortField" indexed="true"/>
 
-    <!-- solr.TextField allows the specification of custom text analyzers
-         specified as a tokenizer and a list of token filters. Different
-         analyzers may be specified for indexing and querying.
+  <!-- solr.TextField allows the specification of custom text analyzers
+       specified as a tokenizer and a list of token filters. Different
+       analyzers may be specified for indexing and querying.
 
-         The optional positionIncrementGap puts space between multiple fields of
-         this type on the same document, with the purpose of preventing false phrase
-         matching across fields.
+       The optional positionIncrementGap puts space between multiple fields of
+       this type on the same document, with the purpose of preventing false phrase
+       matching across fields.
 
-         For more info on customizing your analyzer chain, please see
-         http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters
-     -->
+       For more info on customizing your analyzer chain, please see
+       http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters
+   -->
 
-    <!-- One can also specify an existing Analyzer class that has a
-         default constructor via the class attribute on the analyzer element.
-         Example:
-    <fieldType name="text_greek" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.el.GreekAnalyzer"/>
-    </fieldType>
-    -->
+  <!-- One can also specify an existing Analyzer class that has a
+       default constructor via the class attribute on the analyzer element.
+       Example:
+  <fieldType name="text_greek" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.el.GreekAnalyzer"/>
+  </fieldType>
+  -->
 
-    <!-- A text field that only splits on whitespace for exact matching of words -->
-    <fieldType name="text_ws" class="solr.TextField" positionIncrementGap="100">
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- A general text field that has reasonable, generic
-         cross-language defaults: it tokenizes with StandardTokenizer,
-   removes stop words from case-insensitive "stopwords.txt"
-   (empty by default), and down cases.  At query time only, it
-   also applies synonyms. -->
-    <fieldType name="text_general" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"  />
-        <!-- in this example, we will only use synonyms at query time
-        <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
+  <!-- A text field that only splits on whitespace for exact matching of words -->
+  <fieldType name="text_ws" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- A general text field that has reasonable, generic
+       cross-language defaults: it tokenizes with StandardTokenizer,
+ removes stop words from case-insensitive "stopwords.txt"
+ (empty by default), and down cases.  At query time only, it
+ also applies synonyms. -->
+  <fieldType name="text_general" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+      <!-- in this example, we will only use synonyms at query time
+      <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
+      -->
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- A text field with defaults appropriate for English: it
+       tokenizes with StandardTokenizer, removes English stop words
+       (lang/stopwords_en.txt), down cases, protects words from protwords.txt, and
+       finally applies Porter's stemming.  The query time analyzer
+       also applies synonyms from synonyms.txt. -->
+  <fieldType name="text_en" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- in this example, we will only use synonyms at query time
+      <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
+      -->
+      <!-- Case insensitive stop word removal. -->
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="lang/stopwords_en.txt"
+
+      />
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.EnglishPossessiveFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+            <filter class="solr.EnglishMinimalStemFilterFactory"/>
+      -->
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="lang/stopwords_en.txt"
+
+      />
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.EnglishPossessiveFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+            <filter class="solr.EnglishMinimalStemFilterFactory"/>
+      -->
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- A text field with defaults appropriate for English, plus
+ aggressive word-splitting and autophrase features enabled.
+ This field is just like text_en, except it adds
+ WordDelimiterFilter to enable splitting and matching of
+ words on case-change, alpha numeric boundaries, and
+ non-alphanumeric chars.  This means certain compound word
+ cases will work, for example query "wi fi" will match
+ document "WiFi" or "wi-fi".
+      -->
+  <fieldType name="text_en_splitting" class="solr.TextField" positionIncrementGap="100"
+             autoGeneratePhraseQueries="true">
+    <analyzer type="index">
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <!-- in this example, we will only use synonyms at query time
+      <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
+      -->
+      <!-- Case insensitive stop word removal. -->
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="lang/stopwords_en.txt"
+
+      />
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="lang/stopwords_en.txt"
+
+      />
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Less flexible matching, but less false matches.  Probably not ideal for product names,
+       but may be good for SKUs.  Can insert dashes in the wrong place and still match. -->
+  <fieldType name="text_en_splitting_tight" class="solr.TextField" positionIncrementGap="100"
+             autoGeneratePhraseQueries="true">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="false"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_en.txt"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.EnglishMinimalStemFilterFactory"/>
+      <!-- this filter can remove any duplicate tokens that appear at the same position - sometimes
+           possible with WordDelimiterFilter in conjuncton with stemming. -->
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Just like text_general except it reverses the characters of
+ each token, to enable more efficient leading wildcard queries. -->
+  <fieldType name="text_general_rev" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.ReversedWildcardFilterFactory" withOriginal="true"
+              maxPosAsterisk="3" maxPosQuestion="2" maxFractionAsterisk="0.33"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- charFilter + WhitespaceTokenizer  -->
+  <!--
+  <fieldType name="text_char_norm" class="solr.TextField" positionIncrementGap="100" >
+    <analyzer>
+      <charFilter class="solr.MappingCharFilterFactory" mapping="mapping-ISOLatin1Accent.txt"/>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  -->
+
+  <!-- This is an example of using the KeywordTokenizer along
+       With various TokenFilterFactories to produce a sortable field
+       that does not include some properties of the source text
+    -->
+  <fieldType name="alphaOnlySort" class="solr.TextField" sortMissingLast="true" omitNorms="true">
+    <analyzer>
+      <!-- KeywordTokenizer does no actual tokenizing, so the entire
+           input string is preserved as a single token
+        -->
+      <tokenizer class="solr.KeywordTokenizerFactory"/>
+      <!-- The LowerCase TokenFilter does what you expect, which can be
+           when you want your sorting to be case insensitive
         -->
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"  />
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- A text field with defaults appropriate for English: it
-         tokenizes with StandardTokenizer, removes English stop words
-         (lang/stopwords_en.txt), down cases, protects words from protwords.txt, and
-         finally applies Porter's stemming.  The query time analyzer
-         also applies synonyms from synonyms.txt. -->
-    <fieldType name="text_en" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- in this example, we will only use synonyms at query time
-        <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <!-- The TrimFilter removes any leading or trailing whitespace -->
+      <filter class="solr.TrimFilterFactory"/>
+      <!-- The PatternReplaceFilter gives you the flexibility to use
+           Java Regular expression to replace any sequence of characters
+           matching a pattern with an arbitrary replacement string, 
+           which may include back references to portions of the original
+           string matched by the pattern.
+           
+           See the Java Regular Expression documentation for more
+           information on pattern and replacement string syntax.
+           
+           http://java.sun.com/j2se/1.6.0/docs/api/java/util/regex/package-summary.html
         -->
-        <!-- Case insensitive stop word removal. -->
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="lang/stopwords_en.txt"
-                
-                />
-        <filter class="solr.LowerCaseFilterFactory"/>
-  <filter class="solr.EnglishPossessiveFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
-        <filter class="solr.EnglishMinimalStemFilterFactory"/>
+      <filter class="solr.PatternReplaceFilterFactory"
+              pattern="([^a-z])" replacement="" replace="all"
+      />
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="phonetic" stored="false" indexed="true" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.DoubleMetaphoneFilterFactory" inject="false"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="payloads" stored="false" indexed="true" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <!--
+      The DelimitedPayloadTokenFilter can put payloads on tokens... for example,
+      a token of "foo|1.4"  would be indexed as "foo" with a payload of 1.4f
+      Attributes of the DelimitedPayloadTokenFilterFactory : 
+       "delimiter" - a one character delimiter. Default is | (pipe)
+ "encoder" - how to encode the following value into a playload
+    float -> org.apache.lucene.analysis.payloads.FloatEncoder,
+    integer -> o.a.l.a.p.IntegerEncoder
+    identity -> o.a.l.a.p.IdentityEncoder
+          Fully Qualified class name implementing PayloadEncoder, Encoder must have a no arg constructor.
+       -->
+      <filter class="solr.DelimitedPayloadTokenFilterFactory" encoder="float"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- lowercases the entire field value, keeping it as a single token.  -->
+  <fieldType name="lowercase" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.KeywordTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- 
+    Example of using PathHierarchyTokenizerFactory at index time, so
+    queries for paths match documents at that path, or in descendent paths
   -->
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="lang/stopwords_en.txt"
-                
-                />
-        <filter class="solr.LowerCaseFilterFactory"/>
-  <filter class="solr.EnglishPossessiveFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
-        <filter class="solr.EnglishMinimalStemFilterFactory"/>
+  <fieldType name="descendent_path" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.KeywordTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <!-- 
+    Example of using PathHierarchyTokenizerFactory at query time, so
+    queries for paths match documents at that path, or in ancestor paths
   -->
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- A text field with defaults appropriate for English, plus
-   aggressive word-splitting and autophrase features enabled.
-   This field is just like text_en, except it adds
-   WordDelimiterFilter to enable splitting and matching of
-   words on case-change, alpha numeric boundaries, and
-   non-alphanumeric chars.  This means certain compound word
-   cases will work, for example query "wi fi" will match
-   document "WiFi" or "wi-fi".
-        -->
-    <fieldType name="text_en_splitting" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true">
-      <analyzer type="index">
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <!-- in this example, we will only use synonyms at query time
-        <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
-        -->
-        <!-- Case insensitive stop word removal. -->
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="lang/stopwords_en.txt"
-                
-                />
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="lang/stopwords_en.txt"
-                
-                />
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- Less flexible matching, but less false matches.  Probably not ideal for product names,
-         but may be good for SKUs.  Can insert dashes in the wrong place and still match. -->
-    <fieldType name="text_en_splitting_tight" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true">
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="false"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_en.txt"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.EnglishMinimalStemFilterFactory"/>
-        <!-- this filter can remove any duplicate tokens that appear at the same position - sometimes
-             possible with WordDelimiterFilter in conjuncton with stemming. -->
-        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- Just like text_general except it reverses the characters of
-   each token, to enable more efficient leading wildcard queries. -->
-    <fieldType name="text_general_rev" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"  />
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.ReversedWildcardFilterFactory" withOriginal="true"
-           maxPosAsterisk="3" maxPosQuestion="2" maxFractionAsterisk="0.33"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"  />
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- charFilter + WhitespaceTokenizer  -->
-    <!--
-    <fieldType name="text_char_norm" class="solr.TextField" positionIncrementGap="100" >
-      <analyzer>
-        <charFilter class="solr.MappingCharFilterFactory" mapping="mapping-ISOLatin1Accent.txt"/>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-    -->
+  <fieldType name="ancestor_path" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.KeywordTokenizerFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- since fields of this type are by default not stored or indexed,
+       any data added to them will be ignored outright.  -->
+  <fieldType name="ignored" stored="false" indexed="false" multiValued="true" class="solr.StrField"/>
+
+  <!-- This point type indexes the coordinates as separate fields (subFields)
+    If subFieldType is defined, it references a type, and a dynamic field
+    definition is created matching *___<typename>.  Alternately, if 
+    subFieldSuffix is defined, that is used to create the subFields.
+    Example: if subFieldType="double", then the coordinates would be
+      indexed in fields myloc_0___double,myloc_1___double.
+    Example: if subFieldSuffix="_d" then the coordinates would be indexed
+      in fields myloc_0_d,myloc_1_d
+    The subFields are an implementation detail of the fieldType, and end
+    users normally should not need to know about them.
+   -->
+  <fieldType name="point" class="solr.PointType" dimension="2" subFieldSuffix="_d"/>
 
-    <!-- This is an example of using the KeywordTokenizer along
-         With various TokenFilterFactories to produce a sortable field
-         that does not include some properties of the source text
-      -->
-    <fieldType name="alphaOnlySort" class="solr.TextField" sortMissingLast="true" omitNorms="true">
-      <analyzer>
-        <!-- KeywordTokenizer does no actual tokenizing, so the entire
-             input string is preserved as a single token
-          -->
-        <tokenizer class="solr.KeywordTokenizerFactory"/>
-        <!-- The LowerCase TokenFilter does what you expect, which can be
-             when you want your sorting to be case insensitive
-          -->
-        <filter class="solr.LowerCaseFilterFactory" />
-        <!-- The TrimFilter removes any leading or trailing whitespace -->
-        <filter class="solr.TrimFilterFactory" />
-        <!-- The PatternReplaceFilter gives you the flexibility to use
-             Java Regular expression to replace any sequence of characters
-             matching a pattern with an arbitrary replacement string, 
-             which may include back references to portions of the original
-             string matched by the pattern.
-             
-             See the Java Regular Expression documentation for more
-             information on pattern and replacement string syntax.
-             
-             http://java.sun.com/j2se/1.6.0/docs/api/java/util/regex/package-summary.html
-          -->
-        <filter class="solr.PatternReplaceFilterFactory"
-                pattern="([^a-z])" replacement="" replace="all"
-        />
-      </analyzer>
-    </fieldType>
-    
-    <fieldType name="phonetic" stored="false" indexed="true" class="solr.TextField" >
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.DoubleMetaphoneFilterFactory" inject="false"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="payloads" stored="false" indexed="true" class="solr.TextField" >
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <!--
-        The DelimitedPayloadTokenFilter can put payloads on tokens... for example,
-        a token of "foo|1.4"  would be indexed as "foo" with a payload of 1.4f
-        Attributes of the DelimitedPayloadTokenFilterFactory : 
-         "delimiter" - a one character delimiter. Default is | (pipe)
-   "encoder" - how to encode the following value into a playload
-      float -> org.apache.lucene.analysis.payloads.FloatEncoder,
-      integer -> o.a.l.a.p.IntegerEncoder
-      identity -> o.a.l.a.p.IdentityEncoder
-            Fully Qualified class name implementing PayloadEncoder, Encoder must have a no arg constructor.
-         -->
-        <filter class="solr.DelimitedPayloadTokenFilterFactory" encoder="float"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- lowercases the entire field value, keeping it as a single token.  -->
-    <fieldType name="lowercase" class="solr.TextField" positionIncrementGap="100">
-      <analyzer>
-        <tokenizer class="solr.KeywordTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory" />
-      </analyzer>
-    </fieldType>
-
-    <!-- 
-      Example of using PathHierarchyTokenizerFactory at index time, so
-      queries for paths match documents at that path, or in descendent paths
-    -->
-    <fieldType name="descendent_path" class="solr.TextField">
-      <analyzer type="index">
-  <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
-      </analyzer>
-      <analyzer type="query">
-  <tokenizer class="solr.KeywordTokenizerFactory" />
-      </analyzer>
-    </fieldType>
-    <!-- 
-      Example of using PathHierarchyTokenizerFactory at query time, so
-      queries for paths match documents at that path, or in ancestor paths
-    -->
-    <fieldType name="ancestor_path" class="solr.TextField">
-      <analyzer type="index">
-  <tokenizer class="solr.KeywordTokenizerFactory" />
-      </analyzer>
-      <analyzer type="query">
-  <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
-      </analyzer>
-    </fieldType>
-
-    <!-- since fields of this type are by default not stored or indexed,
-         any data added to them will be ignored outright.  --> 
-    <fieldType name="ignored" stored="false" indexed="false" multiValued="true" class="solr.StrField" />
-
-    <!-- This point type indexes the coordinates as separate fields (subFields)
-      If subFieldType is defined, it references a type, and a dynamic field
-      definition is created matching *___<typename>.  Alternately, if 
-      subFieldSuffix is defined, that is used to create the subFields.
-      Example: if subFieldType="double", then the coordinates would be
-        indexed in fields myloc_0___double,myloc_1___double.
-      Example: if subFieldSuffix="_d" then the coordinates would be indexed
-        in fields myloc_0_d,myloc_1_d
-      The subFields are an implementation detail of the fieldType, and end
-      users normally should not need to know about them.
-     -->
-    <fieldType name="point" class="solr.PointType" dimension="2" subFieldSuffix="_d"/>
+  <!-- A specialized field for geospatial search. If indexed, this fieldType must not be multivalued. -->
+  <fieldType name="location" class="solr.LatLonType" subFieldSuffix="_coordinate"/>
+
+  <!-- An alternative geospatial field type new to Solr 4.  It supports multiValued and polygon shapes.
+    For more information about this and other Spatial fields new to Solr 4, see:
+    http://wiki.apache.org/solr/SolrAdaptersForLuceneSpatial4
+  -->
+  <fieldType name="location_rpt" class="solr.SpatialRecursivePrefixTreeFieldType"
+             geo="true" distErrPct="0.025" maxDistErr="0.001" distanceUnits="kilometers"/>
+
+  <!-- Money/currency field type. See http://wiki.apache.org/solr/MoneyFieldType
+       Parameters:
+         defaultCurrency: Specifies the default currency if none specified. Defaults to "USD"
+         precisionStep:   Specifies the precisionStep for the TrieLong field used for the amount
+         providerClass:   Lets you plug in other exchange provider backend:
+                          solr.FileExchangeRateProvider is the default and takes one parameter:
+                            currencyConfig: name of an xml file holding exchange rates
+                          solr.OpenExchangeRatesOrgProvider uses rates from openexchangerates.org:
+                            ratesFileLocation: URL or path to rates JSON file (default latest.json on the web)
+                            refreshInterval: Number of minutes between each rates fetch (default: 1440, min: 60)
+  -->
+  <fieldType name="currency" class="solr.CurrencyField" precisionStep="8" defaultCurrency="USD"
+             currencyConfig="currency.xml"/>
+
+
+  <!-- some examples for different languages (generally ordered by ISO code) -->
+
+  <!-- Arabic -->
+  <fieldType name="text_ar" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- for any non-arabic -->
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ar.txt"/>
+      <!-- normalizes ? to ?, etc -->
+      <filter class="solr.ArabicNormalizationFilterFactory"/>
+      <filter class="solr.ArabicStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Bulgarian -->
+  <fieldType name="text_bg" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_bg.txt"/>
+      <filter class="solr.BulgarianStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Catalan -->
+  <fieldType name="text_ca" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- removes l', etc -->
+      <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_ca.txt"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ca.txt"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Catalan"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- CJK bigram (see text_ja for a Japanese configuration using morphological analysis) -->
+  <fieldType name="text_cjk" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- normalize width before bigram, as e.g. half-width dakuten combine  -->
+      <filter class="solr.CJKWidthFilterFactory"/>
+      <!-- for any non-CJK -->
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.CJKBigramFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Czech -->
+  <fieldType name="text_cz" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_cz.txt"/>
+      <filter class="solr.CzechStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Danish -->
+  <fieldType name="text_da" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_da.txt" format="snowball"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Danish"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- German -->
+  <fieldType name="text_de" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_de.txt" format="snowball"/>
+      <filter class="solr.GermanNormalizationFilterFactory"/>
+      <filter class="solr.GermanLightStemFilterFactory"/>
+      <!-- less aggressive: <filter class="solr.GermanMinimalStemFilterFactory"/> -->
+      <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="German2"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Greek -->
+  <fieldType name="text_el" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- greek specific lowercase for sigma -->
+      <filter class="solr.GreekLowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="false" words="lang/stopwords_el.txt"/>
+      <filter class="solr.GreekStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Spanish -->
+  <fieldType name="text_es" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_es.txt" format="snowball"/>
+      <filter class="solr.SpanishLightStemFilterFactory"/>
+      <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="Spanish"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Basque -->
+  <fieldType name="text_eu" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_eu.txt"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Basque"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Persian -->
+  <fieldType name="text_fa" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <!-- for ZWNJ -->
+      <charFilter class="solr.PersianCharFilterFactory"/>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.ArabicNormalizationFilterFactory"/>
+      <filter class="solr.PersianNormalizationFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_fa.txt"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Finnish -->
+  <fieldType name="text_fi" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_fi.txt" format="snowball"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Finnish"/>
+      <!-- less aggressive: <filter class="solr.FinnishLightStemFilterFactory"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- French -->
+  <fieldType name="text_fr" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- removes l', etc -->
+      <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_fr.txt"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_fr.txt" format="snowball"/>
+      <filter class="solr.FrenchLightStemFilterFactory"/>
+      <!-- less aggressive: <filter class="solr.FrenchMinimalStemFilterFactory"/> -->
+      <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="French"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Irish -->
+  <fieldType name="text_ga" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- removes d', etc -->
+      <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_ga.txt"/>
+      <!-- removes n-, etc. position increments is intentionally false! -->
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/hyphenations_ga.txt"/>
+      <filter class="solr.IrishLowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ga.txt"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Irish"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Galician -->
+  <fieldType name="text_gl" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_gl.txt"/>
+      <filter class="solr.GalicianStemFilterFactory"/>
+      <!-- less aggressive: <filter class="solr.GalicianMinimalStemFilterFactory"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Hindi -->
+  <fieldType name="text_hi" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <!-- normalizes unicode representation -->
+      <filter class="solr.IndicNormalizationFilterFactory"/>
+      <!-- normalizes variation in spelling -->
+      <filter class="solr.HindiNormalizationFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_hi.txt"/>
+      <filter class="solr.HindiStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Hungarian -->
+  <fieldType name="text_hu" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_hu.txt" format="snowball"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Hungarian"/>
+      <!-- less aggressive: <filter class="solr.HungarianLightStemFilterFactory"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Armenian -->
+  <fieldType name="text_hy" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_hy.txt"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Armenian"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Indonesian -->
+  <fieldType name="text_id" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_id.txt"/>
+      <!-- for a less aggressive approach (only inflectional suffixes), set stemDerivational to false -->
+      <filter class="solr.IndonesianStemFilterFactory" stemDerivational="true"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Italian -->
+  <fieldType name="text_it" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- removes l', etc -->
+      <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_it.txt"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_it.txt" format="snowball"/>
+      <filter class="solr.ItalianLightStemFilterFactory"/>
+      <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="Italian"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Latvian -->
+  <fieldType name="text_lv" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_lv.txt"/>
+      <filter class="solr.LatvianStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Dutch -->
+  <fieldType name="text_nl" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_nl.txt" format="snowball"/>
+      <filter class="solr.StemmerOverrideFilterFactory" dictionary="lang/stemdict_nl.txt" ignoreCase="false"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Dutch"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Norwegian -->
+  <fieldType name="text_no" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_no.txt" format="snowball"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Norwegian"/>
+      <!-- less aggressive: <filter class="solr.NorwegianLightStemFilterFactory"/> -->
+      <!-- singular/plural: <filter class="solr.NorwegianMinimalStemFilterFactory"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Portuguese -->
+  <fieldType name="text_pt" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_pt.txt" format="snowball"/>
+      <filter class="solr.PortugueseLightStemFilterFactory"/>
+      <!-- less aggressive: <filter class="solr.PortugueseMinimalStemFilterFactory"/> -->
+      <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="Portuguese"/> -->
+      <!-- most aggressive: <filter class="solr.PortugueseStemFilterFactory"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Romanian -->
+  <fieldType name="text_ro" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ro.txt"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Romanian"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Russian -->
+  <fieldType name="text_ru" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ru.txt" format="snowball"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Russian"/>
+      <!-- less aggressive: <filter class="solr.RussianLightStemFilterFactory"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Swedish -->
+  <fieldType name="text_sv" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_sv.txt" format="snowball"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Swedish"/>
+      <!-- less aggressive: <filter class="solr.SwedishLightStemFilterFactory"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Thai -->
+  <fieldType name="text_th" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.ThaiTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_th.txt"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Turkish -->
+  <fieldType name="text_tr" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.TurkishLowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="false" words="lang/stopwords_tr.txt"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Turkish"/>
+    </analyzer>
+  </fieldType>
 
-    <!-- A specialized field for geospatial search. If indexed, this fieldType must not be multivalued. -->
-    <fieldType name="location" class="solr.LatLonType" subFieldSuffix="_coordinate"/>
 
-    <!-- An alternative geospatial field type new to Solr 4.  It supports multiValued and polygon shapes.
-      For more information about this and other Spatial fields new to Solr 4, see:
-      http://wiki.apache.org/solr/SolrAdaptersForLuceneSpatial4
-    -->
-    <fieldType name="location_rpt" class="solr.SpatialRecursivePrefixTreeFieldType"
-        geo="true" distErrPct="0.025" maxDistErr="0.001" distanceUnits="kilometers" />
-
-   <!-- Money/currency field type. See http://wiki.apache.org/solr/MoneyFieldType
-        Parameters:
-          defaultCurrency: Specifies the default currency if none specified. Defaults to "USD"
-          precisionStep:   Specifies the precisionStep for the TrieLong field used for the amount
-          providerClass:   Lets you plug in other exchange provider backend:
-                           solr.FileExchangeRateProvider is the default and takes one parameter:
-                             currencyConfig: name of an xml file holding exchange rates
-                           solr.OpenExchangeRatesOrgProvider uses rates from openexchangerates.org:
-                             ratesFileLocation: URL or path to rates JSON file (default latest.json on the web)
-                             refreshInterval: Number of minutes between each rates fetch (default: 1440, min: 60)
-   -->
-    <fieldType name="currency" class="solr.CurrencyField" precisionStep="8" defaultCurrency="USD" currencyConfig="currency.xml" />
-             
-
-
-   <!-- some examples for different languages (generally ordered by ISO code) -->
-
-    <!-- Arabic -->
-    <fieldType name="text_ar" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- for any non-arabic -->
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ar.txt" />
-        <!-- normalizes ? to ?, etc -->
-        <filter class="solr.ArabicNormalizationFilterFactory"/>
-        <filter class="solr.ArabicStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- Bulgarian -->
-    <fieldType name="text_bg" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/> 
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_bg.txt" />
-        <filter class="solr.BulgarianStemFilterFactory"/>       
-      </analyzer>
-    </fieldType>
-    
-    <!-- Catalan -->
-    <fieldType name="text_ca" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- removes l', etc -->
-        <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_ca.txt"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ca.txt" />
-        <filter class="solr.SnowballPorterFilterFactory" language="Catalan"/>       
-      </analyzer>
-    </fieldType>
-    
-    <!-- CJK bigram (see text_ja for a Japanese configuration using morphological analysis) -->
-    <fieldType name="text_cjk" class="solr.TextField" positionIncrementGap="100">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- normalize width before bigram, as e.g. half-width dakuten combine  -->
-        <filter class="solr.CJKWidthFilterFactory"/>
-        <!-- for any non-CJK -->
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.CJKBigramFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- Czech -->
-    <fieldType name="text_cz" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_cz.txt" />
-        <filter class="solr.CzechStemFilterFactory"/>       
-      </analyzer>
-    </fieldType>
-    
-    <!-- Danish -->
-    <fieldType name="text_da" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_da.txt" format="snowball" />
-        <filter class="solr.SnowballPorterFilterFactory" language="Danish"/>       
-      </analyzer>
-    </fieldType>
-    
-    <!-- German -->
-    <fieldType name="text_de" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_de.txt" format="snowball" />
-        <filter class="solr.GermanNormalizationFilterFactory"/>
-        <filter class="solr.GermanLightStemFilterFactory"/>
-        <!-- less aggressive: <filter class="solr.GermanMinimalStemFilterFactory"/> -->
-        <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="German2"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Greek -->
-    <fieldType name="text_el" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- greek specific lowercase for sigma -->
-        <filter class="solr.GreekLowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="false" words="lang/stopwords_el.txt" />
-        <filter class="solr.GreekStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Spanish -->
-    <fieldType name="text_es" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_es.txt" format="snowball" />
-        <filter class="solr.SpanishLightStemFilterFactory"/>
-        <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="Spanish"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Basque -->
-    <fieldType name="text_eu" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_eu.txt" />
-        <filter class="solr.SnowballPorterFilterFactory" language="Basque"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Persian -->
-    <fieldType name="text_fa" class="solr.TextField" positionIncrementGap="100">
-      <analyzer>
-        <!-- for ZWNJ -->
-        <charFilter class="solr.PersianCharFilterFactory"/>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.ArabicNormalizationFilterFactory"/>
-        <filter class="solr.PersianNormalizationFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_fa.txt" />
-      </analyzer>
-    </fieldType>
-    
-    <!-- Finnish -->
-    <fieldType name="text_fi" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_fi.txt" format="snowball" />
-        <filter class="solr.SnowballPorterFilterFactory" language="Finnish"/>
-        <!-- less aggressive: <filter class="solr.FinnishLightStemFilterFactory"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- French -->
-    <fieldType name="text_fr" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- removes l', etc -->
-        <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_fr.txt"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_fr.txt" format="snowball" />
-        <filter class="solr.FrenchLightStemFilterFactory"/>
-        <!-- less aggressive: <filter class="solr.FrenchMinimalStemFilterFactory"/> -->
-        <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="French"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Irish -->
-    <fieldType name="text_ga" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- removes d', etc -->
-        <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_ga.txt"/>
-        <!-- removes n-, etc. position increments is intentionally false! -->
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/hyphenations_ga.txt"/>
-        <filter class="solr.IrishLowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ga.txt" />
-        <filter class="solr.SnowballPorterFilterFactory" language="Irish"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Galician -->
-    <fieldType name="text_gl" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_gl.txt" />
-        <filter class="solr.GalicianStemFilterFactory"/>
-        <!-- less aggressive: <filter class="solr.GalicianMinimalStemFilterFactory"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Hindi -->
-    <fieldType name="text_hi" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <!-- normalizes unicode representation -->
-        <filter class="solr.IndicNormalizationFilterFactory"/>
-        <!-- normalizes variation in spelling -->
-        <filter class="solr.HindiNormalizationFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_hi.txt" />
-        <filter class="solr.HindiStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Hungarian -->
-    <fieldType name="text_hu" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_hu.txt" format="snowball" />
-        <filter class="solr.SnowballPorterFilterFactory" language="Hungarian"/>
-        <!-- less aggressive: <filter class="solr.HungarianLightStemFilterFactory"/> -->   
-      </analyzer>
-    </fieldType>
-    
-    <!-- Armenian -->
-    <fieldType name="text_hy" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_hy.txt" />
-        <filter class="solr.SnowballPorterFilterFactory" language="Armenian"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Indonesian -->
-    <fieldType name="text_id" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_id.txt" />
-        <!-- for a less aggressive approach (only inflectional suffixes), set stemDerivational to false -->
-        <filter class="solr.IndonesianStemFilterFactory" stemDerivational="true"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Italian -->
-    <fieldType name="text_it" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- removes l', etc -->
-        <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_it.txt"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_it.txt" format="snowball" />
-        <filter class="solr.ItalianLightStemFilterFactory"/>
-        <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="Italian"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Latvian -->
-    <fieldType name="text_lv" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_lv.txt" />
-        <filter class="solr.LatvianStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Dutch -->
-    <fieldType name="text_nl" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_nl.txt" format="snowball" />
-        <filter class="solr.StemmerOverrideFilterFactory" dictionary="lang/stemdict_nl.txt" ignoreCase="false"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Dutch"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Norwegian -->
-    <fieldType name="text_no" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_no.txt" format="snowball" />
-        <filter class="solr.SnowballPorterFilterFactory" language="Norwegian"/>
-        <!-- less aggressive: <filter class="solr.NorwegianLightStemFilterFactory"/> -->
-        <!-- singular/plural: <filter class="solr.NorwegianMinimalStemFilterFactory"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Portuguese -->
-    <fieldType name="text_pt" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_pt.txt" format="snowball" />
-        <filter class="solr.PortugueseLightStemFilterFactory"/>
-        <!-- less aggressive: <filter class="solr.PortugueseMinimalStemFilterFactory"/> -->
-        <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="Portuguese"/> -->
-        <!-- most aggressive: <filter class="solr.PortugueseStemFilterFactory"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Romanian -->
-    <fieldType name="text_ro" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ro.txt" />
-        <filter class="solr.SnowballPorterFilterFactory" language="Romanian"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Russian -->
-    <fieldType name="text_ru" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ru.txt" format="snowball" />
-        <filter class="solr.SnowballPorterFilterFactory" language="Russian"/>
-        <!-- less aggressive: <filter class="solr.RussianLightStemFilterFactory"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Swedish -->
-    <fieldType name="text_sv" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_sv.txt" format="snowball" />
-        <filter class="solr.SnowballPorterFilterFactory" language="Swedish"/>
-        <!-- less aggressive: <filter class="solr.SwedishLightStemFilterFactory"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Thai -->
-    <fieldType name="text_th" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.ThaiTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_th.txt" />
-      </analyzer>
-    </fieldType>
-    
-    <!-- Turkish -->
-    <fieldType name="text_tr" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.TurkishLowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="false" words="lang/stopwords_tr.txt" />
-        <filter class="solr.SnowballPorterFilterFactory" language="Turkish"/>
-      </analyzer>
-    </fieldType>
-
- </types>
-  
   <!-- Similarity is the scoring routine for each document vs. a query.
        A custom Similarity or SimilarityFactory may be specified here, but 
        the default is fine for most applications.  
diff --git a/solr/contrib/morphlines-core/src/test-files/solr/solrcelltest/collection1/conf/schema.xml b/solr/contrib/morphlines-core/src/test-files/solr/solrcelltest/collection1/conf/schema.xml
index edc838c..aed9f44 100644
--- a/solr/contrib/morphlines-core/src/test-files/solr/solrcelltest/collection1/conf/schema.xml
+++ b/solr/contrib/morphlines-core/src/test-files/solr/solrcelltest/collection1/conf/schema.xml
@@ -64,821 +64,821 @@
        1.6: useDocValuesAsStored defaults to true.
      -->
 
- <fields>
-   <!-- Valid attributes for fields:
-     name: mandatory - the name for the field
-     type: mandatory - the name of a field type from the 
-       <types> fieldType section
-     indexed: true if this field should be indexed (searchable or sortable)
-     stored: true if this field should be retrievable
-     multiValued: true if this field may contain multiple values per document
-     omitNorms: (expert) set to true to omit the norms associated with
-       this field (this disables length normalization and index-time
-       boosting for the field, and saves some memory).  Only full-text
-       fields or fields that need an index-time boost need norms.
-       Norms are omitted for primitive (non-analyzed) types by default.
-     termVectors: [false] set to true to store the term vector for a
-       given field.
-       When using MoreLikeThis, fields used for similarity should be
-       stored for best performance.
-     termPositions: Store position information with the term vector.  
-       This will increase storage costs.
-     termOffsets: Store offset information with the term vector. This 
-       will increase storage costs.
-     required: The field is required.  It will throw an error if the
-       value does not exist
-     default: a value that should be used if no value is specified
-       when adding a document.
-   -->
 
-   <!-- field names should consist of alphanumeric or underscore characters only and
-      not start with a digit.  This is not currently strictly enforced,
-      but other field names will not have first class support from all components
-      and back compatibility is not guaranteed.  Names with both leading and
-      trailing underscores (e.g. _version_) are reserved.
-   -->
-        
-   <field name="id" type="string" indexed="true" stored="true" required="true" multiValued="false" /> 
-   <field name="username" type="text_en" indexed="true" stored="true" />
-   <field name="created_at" type="tdate" indexed="true" stored="true" />
-   <field name="text" type="text_en" indexed="true" stored="true" />
+  <!-- Valid attributes for fields:
+    name: mandatory - the name for the field
+    type: mandatory - the name of a field type from the 
+      fieldTypes
+    indexed: true if this field should be indexed (searchable or sortable)
+    stored: true if this field should be retrievable
+    multiValued: true if this field may contain multiple values per document
+    omitNorms: (expert) set to true to omit the norms associated with
+      this field (this disables length normalization and index-time
+      boosting for the field, and saves some memory).  Only full-text
+      fields or fields that need an index-time boost need norms.
+      Norms are omitted for primitive (non-analyzed) types by default.
+    termVectors: [false] set to true to store the term vector for a
+      given field.
+      When using MoreLikeThis, fields used for similarity should be
+      stored for best performance.
+    termPositions: Store position information with the term vector.  
+      This will increase storage costs.
+    termOffsets: Store offset information with the term vector. This 
+      will increase storage costs.
+    required: The field is required.  It will throw an error if the
+      value does not exist
+    default: a value that should be used if no value is specified
+      when adding a document.
+  -->
 
-   <field name="_version_" type="long" indexed="true" stored="true"/>
-   <dynamicField name="ignored_*" type="ignored"/>
-   
- </fields>
+  <!-- field names should consist of alphanumeric or underscore characters only and
+     not start with a digit.  This is not currently strictly enforced,
+     but other field names will not have first class support from all components
+     and back compatibility is not guaranteed.  Names with both leading and
+     trailing underscores (e.g. _version_) are reserved.
+  -->
 
+  <field name="id" type="string" indexed="true" stored="true" required="true" multiValued="false"/>
+  <field name="username" type="text_en" indexed="true" stored="true"/>
+  <field name="created_at" type="tdate" indexed="true" stored="true"/>
+  <field name="text" type="text_en" indexed="true" stored="true"/>
 
- <!-- Field to use to determine and enforce document uniqueness. 
-      Unless this field is marked with required="false", it will be a required field
-   -->
- <uniqueKey>id</uniqueKey>
-
- <!-- DEPRECATED: The defaultSearchField is consulted by various query parsers when
-  parsing a query string that isn't explicit about the field.  Machine (non-user)
-  generated queries are best made explicit, or they can use the "df" request parameter
-  which takes precedence over this.
-  Note: Un-commenting defaultSearchField will be insufficient if your request handler
-  in solrconfig.xml defines "df", which takes precedence. That would need to be removed.
- <defaultSearchField>text</defaultSearchField> -->
-
- <!-- DEPRECATED: The defaultOperator (AND|OR) is consulted by various query parsers
-  when parsing a query string to determine if a clause of the query should be marked as
-  required or optional, assuming the clause isn't already marked by some operator.
-  The default is OR, which is generally assumed so it is not a good idea to change it
-  globally here.  The "q.op" request parameter takes precedence over this.
- <solrQueryParser defaultOperator="OR"/> -->
+  <field name="_version_" type="long" indexed="true" stored="true"/>
+  <dynamicField name="ignored_*" type="ignored"/>
+
+
+  <!-- Field to use to determine and enforce document uniqueness. 
+       Unless this field is marked with required="false", it will be a required field
+    -->
+  <uniqueKey>id</uniqueKey>
+
+  <!-- DEPRECATED: The defaultSearchField is consulted by various query parsers when
+   parsing a query string that isn't explicit about the field.  Machine (non-user)
+   generated queries are best made explicit, or they can use the "df" request parameter
+   which takes precedence over this.
+   Note: Un-commenting defaultSearchField will be insufficient if your request handler
+   in solrconfig.xml defines "df", which takes precedence. That would need to be removed.
+  <defaultSearchField>text</defaultSearchField> -->
+
+  <!-- DEPRECATED: The defaultOperator (AND|OR) is consulted by various query parsers
+   when parsing a query string to determine if a clause of the query should be marked as
+   required or optional, assuming the clause isn't already marked by some operator.
+   The default is OR, which is generally assumed so it is not a good idea to change it
+   globally here.  The "q.op" request parameter takes precedence over this.
+  <solrQueryParser defaultOperator="OR"/> -->
 
   <!-- copyField commands copy one field to another at the time a document
         is added to the index.  It's used either to index the same field differently,
         or to add multiple fields to the same field for easier/faster searching.  -->
 
-  
-  <types>
-    <!-- field type definitions. The "name" attribute is
-       just a label to be used by field definitions.  The "class"
-       attribute and any other attributes determine the real
-       behavior of the fieldType.
-         Class names starting with "solr" refer to java classes in a
-       standard package such as org.apache.solr.analysis
-    -->
 
-    <!-- The StrField type is not analyzed, but indexed/stored verbatim. -->
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true" />
-
-    <!-- boolean type: "true" or "false" -->
-    <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
-
-    <!-- sortMissingLast and sortMissingFirst attributes are optional attributes are
-         currently supported on types that are sorted internally as strings
-         and on numeric types.
-       This includes "string","boolean", and, as of 3.5 (and 4.x),
-       int, float, long, date, double, including the "Trie" variants.
-       - If sortMissingLast="true", then a sort on this field will cause documents
-         without the field to come after documents with the field,
-         regardless of the requested sort order (asc or desc).
-       - If sortMissingFirst="true", then a sort on this field will cause documents
-         without the field to come before documents with the field,
-         regardless of the requested sort order.
-       - If sortMissingLast="false" and sortMissingFirst="false" (the default),
-         then default lucene sorting will be used which places docs without the
-         field first in an ascending sort and last in a descending sort.
-    -->    
-
-    <!--
-      Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
-    -->
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
-
-    <!--
-     Numeric field types that index each value at various levels of precision
-     to accelerate range queries when the number of values between the range
-     endpoints is large. See the javadoc for LegacyNumericRangeQuery for internal
-     implementation details.
-
-     Smaller precisionStep values (specified in bits) will lead to more tokens
-     indexed per value, slightly larger index size, and faster range queries.
-     A precisionStep of 0 disables indexing at different precision levels.
+  <!-- field type definitions. The "name" attribute is
+     just a label to be used by field definitions.  The "class"
+     attribute and any other attributes determine the real
+     behavior of the fieldType.
+       Class names starting with "solr" refer to java classes in a
+     standard package such as org.apache.solr.analysis
+  -->
+
+  <!-- The StrField type is not analyzed, but indexed/stored verbatim. -->
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+
+  <!-- boolean type: "true" or "false" -->
+  <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
+
+  <!-- sortMissingLast and sortMissingFirst attributes are optional attributes are
+       currently supported on types that are sorted internally as strings
+       and on numeric types.
+     This includes "string","boolean", and, as of 3.5 (and 4.x),
+     int, float, long, date, double, including the "Trie" variants.
+     - If sortMissingLast="true", then a sort on this field will cause documents
+       without the field to come after documents with the field,
+       regardless of the requested sort order (asc or desc).
+     - If sortMissingFirst="true", then a sort on this field will cause documents
+       without the field to come before documents with the field,
+       regardless of the requested sort order.
+     - If sortMissingLast="false" and sortMissingFirst="false" (the default),
+       then default lucene sorting will be used which places docs without the
+       field first in an ascending sort and last in a descending sort.
+  -->
+
+  <!--
+    Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
+  -->
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
+
+  <!--
+   Numeric field types that index each value at various levels of precision
+   to accelerate range queries when the number of values between the range
+   endpoints is large. See the javadoc for LegacyNumericRangeQuery for internal
+   implementation details.
+
+   Smaller precisionStep values (specified in bits) will lead to more tokens
+   indexed per value, slightly larger index size, and faster range queries.
+   A precisionStep of 0 disables indexing at different precision levels.
+  -->
+  <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
+
+  <!-- The format for this date field is of the form 1995-12-31T23:59:59Z, and
+       is a more restricted form of the canonical representation of dateTime
+       http://www.w3.org/TR/xmlschema-2/#dateTime    
+       The trailing "Z" designates UTC time and is mandatory.
+       Optional fractional seconds are allowed: 1995-12-31T23:59:59.999Z
+       All other components are mandatory.
+
+       Expressions can also be used to denote calculations that should be
+       performed relative to "NOW" to determine the value, ie...
+
+             NOW/HOUR
+                ... Round to the start of the current hour
+             NOW-1DAY
+                ... Exactly 1 day prior to now
+             NOW/DAY+6MONTHS+3DAYS
+                ... 6 months and 3 days in the future from the start of
+                    the current day
+                    
+       Consult the TrieDateField javadocs for more information.
+
+       Note: For faster range queries, consider the tdate type
     -->
-    <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
-
-    <!-- The format for this date field is of the form 1995-12-31T23:59:59Z, and
-         is a more restricted form of the canonical representation of dateTime
-         http://www.w3.org/TR/xmlschema-2/#dateTime    
-         The trailing "Z" designates UTC time and is mandatory.
-         Optional fractional seconds are allowed: 1995-12-31T23:59:59.999Z
-         All other components are mandatory.
-
-         Expressions can also be used to denote calculations that should be
-         performed relative to "NOW" to determine the value, ie...
-
-               NOW/HOUR
-                  ... Round to the start of the current hour
-               NOW-1DAY
-                  ... Exactly 1 day prior to now
-               NOW/DAY+6MONTHS+3DAYS
-                  ... 6 months and 3 days in the future from the start of
-                      the current day
-                      
-         Consult the TrieDateField javadocs for more information.
-
-         Note: For faster range queries, consider the tdate type
-      -->
-    <fieldType name="date" class="solr.TrieDateField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="date" class="solr.TrieDateField" precisionStep="0" positionIncrementGap="0"/>
 
-    <!-- A Trie based date field for faster date range queries and date faceting. -->
-    <fieldType name="tdate" class="solr.TrieDateField" precisionStep="6" positionIncrementGap="0"/>
+  <!-- A Trie based date field for faster date range queries and date faceting. -->
+  <fieldType name="tdate" class="solr.TrieDateField" precisionStep="6" positionIncrementGap="0"/>
 
 
-    <!--Binary data type. The data should be sent/retrieved in as Base64 encoded Strings -->
-    <fieldType name="binary" class="solr.BinaryField"/>
+  <!--Binary data type. The data should be sent/retrieved in as Base64 encoded Strings -->
+  <fieldType name="binary" class="solr.BinaryField"/>
 
-    <!-- The "RandomSortField" is not used to store or search any
-         data.  You can declare fields of this type it in your schema
-         to generate pseudo-random orderings of your docs for sorting 
-         or function purposes.  The ordering is generated based on the field
-         name and the version of the index. As long as the index version
-         remains unchanged, and the same field name is reused,
-         the ordering of the docs will be consistent.  
-         If you want different psuedo-random orderings of documents,
-         for the same version of the index, use a dynamicField and
-         change the field name in the request.
-     -->
-    <fieldType name="random" class="solr.RandomSortField" indexed="true" />
+  <!-- The "RandomSortField" is not used to store or search any
+       data.  You can declare fields of this type it in your schema
+       to generate pseudo-random orderings of your docs for sorting 
+       or function purposes.  The ordering is generated based on the field
+       name and the version of the index. As long as the index version
+       remains unchanged, and the same field name is reused,
+       the ordering of the docs will be consistent.  
+       If you want different psuedo-random orderings of documents,
+       for the same version of the index, use a dynamicField and
+       change the field name in the request.
+   -->
+  <fieldType name="random" class="solr.RandomSortField" indexed="true"/>
 
-    <!-- solr.TextField allows the specification of custom text analyzers
-         specified as a tokenizer and a list of token filters. Different
-         analyzers may be specified for indexing and querying.
+  <!-- solr.TextField allows the specification of custom text analyzers
+       specified as a tokenizer and a list of token filters. Different
+       analyzers may be specified for indexing and querying.
 
-         The optional positionIncrementGap puts space between multiple fields of
-         this type on the same document, with the purpose of preventing false phrase
-         matching across fields.
+       The optional positionIncrementGap puts space between multiple fields of
+       this type on the same document, with the purpose of preventing false phrase
+       matching across fields.
 
-         For more info on customizing your analyzer chain, please see
-         http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters
-     -->
+       For more info on customizing your analyzer chain, please see
+       http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters
+   -->
 
-    <!-- One can also specify an existing Analyzer class that has a
-         default constructor via the class attribute on the analyzer element.
-         Example:
-    <fieldType name="text_greek" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.el.GreekAnalyzer"/>
-    </fieldType>
-    -->
+  <!-- One can also specify an existing Analyzer class that has a
+       default constructor via the class attribute on the analyzer element.
+       Example:
+  <fieldType name="text_greek" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.el.GreekAnalyzer"/>
+  </fieldType>
+  -->
 
-    <!-- A text field that only splits on whitespace for exact matching of words -->
-    <fieldType name="text_ws" class="solr.TextField" positionIncrementGap="100">
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- A general text field that has reasonable, generic
-         cross-language defaults: it tokenizes with StandardTokenizer,
-   removes stop words from case-insensitive "stopwords.txt"
-   (empty by default), and down cases.  At query time only, it
-   also applies synonyms. -->
-    <fieldType name="text_general" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt" />
-        <!-- in this example, we will only use synonyms at query time
-        <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
+  <!-- A text field that only splits on whitespace for exact matching of words -->
+  <fieldType name="text_ws" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- A general text field that has reasonable, generic
+       cross-language defaults: it tokenizes with StandardTokenizer,
+ removes stop words from case-insensitive "stopwords.txt"
+ (empty by default), and down cases.  At query time only, it
+ also applies synonyms. -->
+  <fieldType name="text_general" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+      <!-- in this example, we will only use synonyms at query time
+      <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
+      -->
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- A text field with defaults appropriate for English: it
+       tokenizes with StandardTokenizer, removes English stop words
+       (lang/stopwords_en.txt), down cases, protects words from protwords.txt, and
+       finally applies Porter's stemming.  The query time analyzer
+       also applies synonyms from synonyms.txt. -->
+  <fieldType name="text_en" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- in this example, we will only use synonyms at query time
+      <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
+      -->
+      <!-- Case insensitive stop word removal. -->
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="lang/stopwords_en.txt"
+
+      />
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.EnglishPossessiveFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+            <filter class="solr.EnglishMinimalStemFilterFactory"/>
+      -->
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="lang/stopwords_en.txt"
+
+      />
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.EnglishPossessiveFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+            <filter class="solr.EnglishMinimalStemFilterFactory"/>
+      -->
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- A text field with defaults appropriate for English, plus
+ aggressive word-splitting and autophrase features enabled.
+ This field is just like text_en, except it adds
+ WordDelimiterFilter to enable splitting and matching of
+ words on case-change, alpha numeric boundaries, and
+ non-alphanumeric chars.  This means certain compound word
+ cases will work, for example query "wi fi" will match
+ document "WiFi" or "wi-fi".
+      -->
+  <fieldType name="text_en_splitting" class="solr.TextField" positionIncrementGap="100"
+             autoGeneratePhraseQueries="true">
+    <analyzer type="index">
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <!-- in this example, we will only use synonyms at query time
+      <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
+      -->
+      <!-- Case insensitive stop word removal. -->
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="lang/stopwords_en.txt"
+
+      />
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="lang/stopwords_en.txt"
+
+      />
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Less flexible matching, but less false matches.  Probably not ideal for product names,
+       but may be good for SKUs.  Can insert dashes in the wrong place and still match. -->
+  <fieldType name="text_en_splitting_tight" class="solr.TextField" positionIncrementGap="100"
+             autoGeneratePhraseQueries="true">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="false"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_en.txt"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.EnglishMinimalStemFilterFactory"/>
+      <!-- this filter can remove any duplicate tokens that appear at the same position - sometimes
+           possible with WordDelimiterFilter in conjuncton with stemming. -->
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Just like text_general except it reverses the characters of
+ each token, to enable more efficient leading wildcard queries. -->
+  <fieldType name="text_general_rev" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.ReversedWildcardFilterFactory" withOriginal="true"
+              maxPosAsterisk="3" maxPosQuestion="2" maxFractionAsterisk="0.33"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- charFilter + WhitespaceTokenizer  -->
+  <!--
+  <fieldType name="text_char_norm" class="solr.TextField" positionIncrementGap="100" >
+    <analyzer>
+      <charFilter class="solr.MappingCharFilterFactory" mapping="mapping-ISOLatin1Accent.txt"/>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  -->
+
+  <!-- This is an example of using the KeywordTokenizer along
+       With various TokenFilterFactories to produce a sortable field
+       that does not include some properties of the source text
+    -->
+  <fieldType name="alphaOnlySort" class="solr.TextField" sortMissingLast="true" omitNorms="true">
+    <analyzer>
+      <!-- KeywordTokenizer does no actual tokenizing, so the entire
+           input string is preserved as a single token
+        -->
+      <tokenizer class="solr.KeywordTokenizerFactory"/>
+      <!-- The LowerCase TokenFilter does what you expect, which can be
+           when you want your sorting to be case insensitive
         -->
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt" />
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- A text field with defaults appropriate for English: it
-         tokenizes with StandardTokenizer, removes English stop words
-         (lang/stopwords_en.txt), down cases, protects words from protwords.txt, and
-         finally applies Porter's stemming.  The query time analyzer
-         also applies synonyms from synonyms.txt. -->
-    <fieldType name="text_en" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- in this example, we will only use synonyms at query time
-        <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <!-- The TrimFilter removes any leading or trailing whitespace -->
+      <filter class="solr.TrimFilterFactory"/>
+      <!-- The PatternReplaceFilter gives you the flexibility to use
+           Java Regular expression to replace any sequence of characters
+           matching a pattern with an arbitrary replacement string, 
+           which may include back references to portions of the original
+           string matched by the pattern.
+           
+           See the Java Regular Expression documentation for more
+           information on pattern and replacement string syntax.
+           
+           http://java.sun.com/j2se/1.6.0/docs/api/java/util/regex/package-summary.html
         -->
-        <!-- Case insensitive stop word removal. -->
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="lang/stopwords_en.txt"
-               
-                />
-        <filter class="solr.LowerCaseFilterFactory"/>
-  <filter class="solr.EnglishPossessiveFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
-        <filter class="solr.EnglishMinimalStemFilterFactory"/>
+      <filter class="solr.PatternReplaceFilterFactory"
+              pattern="([^a-z])" replacement="" replace="all"
+      />
+    </analyzer>
+  </fieldType>
+
+  <!--    
+  <fieldType name="phonetic" stored="false" indexed="true" class="solr.TextField" >
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.DoubleMetaphoneFilterFactory" inject="false"/>
+    </analyzer>
+  </fieldType>
   -->
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="lang/stopwords_en.txt"
-               
-                />
-        <filter class="solr.LowerCaseFilterFactory"/>
-  <filter class="solr.EnglishPossessiveFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
-        <filter class="solr.EnglishMinimalStemFilterFactory"/>
+
+  <fieldType name="payloads" stored="false" indexed="true" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <!--
+      The DelimitedPayloadTokenFilter can put payloads on tokens... for example,
+      a token of "foo|1.4"  would be indexed as "foo" with a payload of 1.4f
+      Attributes of the DelimitedPayloadTokenFilterFactory : 
+       "delimiter" - a one character delimiter. Default is | (pipe)
+ "encoder" - how to encode the following value into a playload
+    float -> org.apache.lucene.analysis.payloads.FloatEncoder,
+    integer -> o.a.l.a.p.IntegerEncoder
+    identity -> o.a.l.a.p.IdentityEncoder
+          Fully Qualified class name implementing PayloadEncoder, Encoder must have a no arg constructor.
+       -->
+      <filter class="solr.DelimitedPayloadTokenFilterFactory" encoder="float"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- lowercases the entire field value, keeping it as a single token.  -->
+  <fieldType name="lowercase" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.KeywordTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- 
+    Example of using PathHierarchyTokenizerFactory at index time, so
+    queries for paths match documents at that path, or in descendent paths
   -->
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- A text field with defaults appropriate for English, plus
-   aggressive word-splitting and autophrase features enabled.
-   This field is just like text_en, except it adds
-   WordDelimiterFilter to enable splitting and matching of
-   words on case-change, alpha numeric boundaries, and
-   non-alphanumeric chars.  This means certain compound word
-   cases will work, for example query "wi fi" will match
-   document "WiFi" or "wi-fi".
-        -->
-    <fieldType name="text_en_splitting" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true">
-      <analyzer type="index">
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <!-- in this example, we will only use synonyms at query time
-        <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
-        -->
-        <!-- Case insensitive stop word removal. -->
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="lang/stopwords_en.txt"
-               
-                />
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="lang/stopwords_en.txt"
-               
-                />
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- Less flexible matching, but less false matches.  Probably not ideal for product names,
-         but may be good for SKUs.  Can insert dashes in the wrong place and still match. -->
-    <fieldType name="text_en_splitting_tight" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true">
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="false"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_en.txt"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.EnglishMinimalStemFilterFactory"/>
-        <!-- this filter can remove any duplicate tokens that appear at the same position - sometimes
-             possible with WordDelimiterFilter in conjuncton with stemming. -->
-        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- Just like text_general except it reverses the characters of
-   each token, to enable more efficient leading wildcard queries. -->
-    <fieldType name="text_general_rev" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt" />
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.ReversedWildcardFilterFactory" withOriginal="true"
-           maxPosAsterisk="3" maxPosQuestion="2" maxFractionAsterisk="0.33"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt" />
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- charFilter + WhitespaceTokenizer  -->
-    <!--
-    <fieldType name="text_char_norm" class="solr.TextField" positionIncrementGap="100" >
-      <analyzer>
-        <charFilter class="solr.MappingCharFilterFactory" mapping="mapping-ISOLatin1Accent.txt"/>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-    -->
+  <fieldType name="descendent_path" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.KeywordTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <!-- 
+    Example of using PathHierarchyTokenizerFactory at query time, so
+    queries for paths match documents at that path, or in ancestor paths
+  -->
+  <fieldType name="ancestor_path" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.KeywordTokenizerFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- since fields of this type are by default not stored or indexed,
+       any data added to them will be ignored outright.  -->
+  <fieldType name="ignored" stored="false" indexed="false" multiValued="true" class="solr.StrField"/>
+
+  <!-- This point type indexes the coordinates as separate fields (subFields)
+    If subFieldType is defined, it references a type, and a dynamic field
+    definition is created matching *___<typename>.  Alternately, if 
+    subFieldSuffix is defined, that is used to create the subFields.
+    Example: if subFieldType="double", then the coordinates would be
+      indexed in fields myloc_0___double,myloc_1___double.
+    Example: if subFieldSuffix="_d" then the coordinates would be indexed
+      in fields myloc_0_d,myloc_1_d
+    The subFields are an implementation detail of the fieldType, and end
+    users normally should not need to know about them.
+   -->
+  <fieldType name="point" class="solr.PointType" dimension="2" subFieldSuffix="_d"/>
 
-    <!-- This is an example of using the KeywordTokenizer along
-         With various TokenFilterFactories to produce a sortable field
-         that does not include some properties of the source text
-      -->
-    <fieldType name="alphaOnlySort" class="solr.TextField" sortMissingLast="true" omitNorms="true">
-      <analyzer>
-        <!-- KeywordTokenizer does no actual tokenizing, so the entire
-             input string is preserved as a single token
-          -->
-        <tokenizer class="solr.KeywordTokenizerFactory"/>
-        <!-- The LowerCase TokenFilter does what you expect, which can be
-             when you want your sorting to be case insensitive
-          -->
-        <filter class="solr.LowerCaseFilterFactory" />
-        <!-- The TrimFilter removes any leading or trailing whitespace -->
-        <filter class="solr.TrimFilterFactory" />
-        <!-- The PatternReplaceFilter gives you the flexibility to use
-             Java Regular expression to replace any sequence of characters
-             matching a pattern with an arbitrary replacement string, 
-             which may include back references to portions of the original
-             string matched by the pattern.
-             
-             See the Java Regular Expression documentation for more
-             information on pattern and replacement string syntax.
-             
-             http://java.sun.com/j2se/1.6.0/docs/api/java/util/regex/package-summary.html
-          -->
-        <filter class="solr.PatternReplaceFilterFactory"
-                pattern="([^a-z])" replacement="" replace="all"
-        />
-      </analyzer>
-    </fieldType>
-
-    <!--    
-    <fieldType name="phonetic" stored="false" indexed="true" class="solr.TextField" >
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.DoubleMetaphoneFilterFactory" inject="false"/>
-      </analyzer>
-    </fieldType>
-    -->
-    
-    <fieldType name="payloads" stored="false" indexed="true" class="solr.TextField" >
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <!--
-        The DelimitedPayloadTokenFilter can put payloads on tokens... for example,
-        a token of "foo|1.4"  would be indexed as "foo" with a payload of 1.4f
-        Attributes of the DelimitedPayloadTokenFilterFactory : 
-         "delimiter" - a one character delimiter. Default is | (pipe)
-   "encoder" - how to encode the following value into a playload
-      float -> org.apache.lucene.analysis.payloads.FloatEncoder,
-      integer -> o.a.l.a.p.IntegerEncoder
-      identity -> o.a.l.a.p.IdentityEncoder
-            Fully Qualified class name implementing PayloadEncoder, Encoder must have a no arg constructor.
-         -->
-        <filter class="solr.DelimitedPayloadTokenFilterFactory" encoder="float"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- lowercases the entire field value, keeping it as a single token.  -->
-    <fieldType name="lowercase" class="solr.TextField" positionIncrementGap="100">
-      <analyzer>
-        <tokenizer class="solr.KeywordTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory" />
-      </analyzer>
-    </fieldType>
-
-    <!-- 
-      Example of using PathHierarchyTokenizerFactory at index time, so
-      queries for paths match documents at that path, or in descendent paths
-    -->
-    <fieldType name="descendent_path" class="solr.TextField">
-      <analyzer type="index">
-  <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
-      </analyzer>
-      <analyzer type="query">
-  <tokenizer class="solr.KeywordTokenizerFactory" />
-      </analyzer>
-    </fieldType>
-    <!-- 
-      Example of using PathHierarchyTokenizerFactory at query time, so
-      queries for paths match documents at that path, or in ancestor paths
-    -->
-    <fieldType name="ancestor_path" class="solr.TextField">
-      <analyzer type="index">
-  <tokenizer class="solr.KeywordTokenizerFactory" />
-      </analyzer>
-      <analyzer type="query">
-  <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
-      </analyzer>
-    </fieldType>
-
-    <!-- since fields of this type are by default not stored or indexed,
-         any data added to them will be ignored outright.  --> 
-    <fieldType name="ignored" stored="false" indexed="false" multiValued="true" class="solr.StrField" />
-
-    <!-- This point type indexes the coordinates as separate fields (subFields)
-      If subFieldType is defined, it references a type, and a dynamic field
-      definition is created matching *___<typename>.  Alternately, if 
-      subFieldSuffix is defined, that is used to create the subFields.
-      Example: if subFieldType="double", then the coordinates would be
-        indexed in fields myloc_0___double,myloc_1___double.
-      Example: if subFieldSuffix="_d" then the coordinates would be indexed
-        in fields myloc_0_d,myloc_1_d
-      The subFields are an implementation detail of the fieldType, and end
-      users normally should not need to know about them.
-     -->
-    <fieldType name="point" class="solr.PointType" dimension="2" subFieldSuffix="_d"/>
+  <!-- A specialized field for geospatial search. If indexed, this fieldType must not be multivalued. -->
+  <fieldType name="location" class="solr.LatLonType" subFieldSuffix="_coordinate"/>
 
-    <!-- A specialized field for geospatial search. If indexed, this fieldType must not be multivalued. -->
-    <fieldType name="location" class="solr.LatLonType" subFieldSuffix="_coordinate"/>
+  <!--
+   A Geohash is a compact representation of a latitude longitude pair in a single field.
+   See http://wiki.apache.org/solr/SpatialSearch
+  -->
+  <fieldType name="geohash" class="solr.GeoHashField"/>
+
+  <!-- Money/currency field type. See http://wiki.apache.org/solr/MoneyFieldType
+       Parameters:
+         defaultCurrency: Specifies the default currency if none specified. Defaults to "USD"
+         precisionStep:   Specifies the precisionStep for the TrieLong field used for the amount
+         providerClass:   Lets you plug in other exchange provider backend:
+                          solr.FileExchangeRateProvider is the default and takes one parameter:
+                            currencyConfig: name of an xml file holding exhange rates
+                          solr.OpenExchangeRatesOrgProvider uses rates from openexchangerates.org:
+                            ratesFileLocation: URL or path to rates JSON file (default latest.json on the web)
+                            refreshInterval: Number of minutes between each rates fetch (default: 1440, min: 60)
+  -->
+  <fieldType name="currency" class="solr.CurrencyField" precisionStep="8" defaultCurrency="USD"
+             currencyConfig="currency.xml"/>
+
+
+  <!-- some examples for different languages (generally ordered by ISO code) -->
+
+  <!-- Arabic -->
+  <fieldType name="text_ar" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- for any non-arabic -->
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ar.txt"/>
+      <!-- normalizes ? to ?, etc -->
+      <filter class="solr.ArabicNormalizationFilterFactory"/>
+      <filter class="solr.ArabicStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Bulgarian -->
+  <fieldType name="text_bg" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_bg.txt"/>
+      <filter class="solr.BulgarianStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Catalan -->
+  <fieldType name="text_ca" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- removes l', etc -->
+      <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_ca.txt"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ca.txt"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Catalan"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- CJK bigram (see text_ja for a Japanese configuration using morphological analysis) -->
+  <fieldType name="text_cjk" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- normalize width before bigram, as e.g. half-width dakuten combine  -->
+      <filter class="solr.CJKWidthFilterFactory"/>
+      <!-- for any non-CJK -->
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.CJKBigramFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Czech -->
+  <fieldType name="text_cz" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_cz.txt"/>
+      <filter class="solr.CzechStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Danish -->
+  <fieldType name="text_da" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_da.txt" format="snowball"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Danish"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- German -->
+  <fieldType name="text_de" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_de.txt" format="snowball"/>
+      <filter class="solr.GermanNormalizationFilterFactory"/>
+      <filter class="solr.GermanLightStemFilterFactory"/>
+      <!-- less aggressive: <filter class="solr.GermanMinimalStemFilterFactory"/> -->
+      <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="German2"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Greek -->
+  <fieldType name="text_el" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- greek specific lowercase for sigma -->
+      <filter class="solr.GreekLowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="false" words="lang/stopwords_el.txt"/>
+      <filter class="solr.GreekStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Spanish -->
+  <fieldType name="text_es" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_es.txt" format="snowball"/>
+      <filter class="solr.SpanishLightStemFilterFactory"/>
+      <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="Spanish"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Basque -->
+  <fieldType name="text_eu" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_eu.txt"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Basque"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Persian -->
+  <fieldType name="text_fa" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <!-- for ZWNJ -->
+      <charFilter class="solr.PersianCharFilterFactory"/>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.ArabicNormalizationFilterFactory"/>
+      <filter class="solr.PersianNormalizationFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_fa.txt"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Finnish -->
+  <fieldType name="text_fi" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_fi.txt" format="snowball"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Finnish"/>
+      <!-- less aggressive: <filter class="solr.FinnishLightStemFilterFactory"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- French -->
+  <fieldType name="text_fr" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- removes l', etc -->
+      <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_fr.txt"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_fr.txt" format="snowball"/>
+      <filter class="solr.FrenchLightStemFilterFactory"/>
+      <!-- less aggressive: <filter class="solr.FrenchMinimalStemFilterFactory"/> -->
+      <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="French"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Irish -->
+  <fieldType name="text_ga" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- removes d', etc -->
+      <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_ga.txt"/>
+      <!-- removes n-, etc. position increments is intentionally false! -->
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/hyphenations_ga.txt"/>
+      <filter class="solr.IrishLowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ga.txt"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Irish"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Galician -->
+  <fieldType name="text_gl" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_gl.txt"/>
+      <filter class="solr.GalicianStemFilterFactory"/>
+      <!-- less aggressive: <filter class="solr.GalicianMinimalStemFilterFactory"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Hindi -->
+  <fieldType name="text_hi" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <!-- normalizes unicode representation -->
+      <filter class="solr.IndicNormalizationFilterFactory"/>
+      <!-- normalizes variation in spelling -->
+      <filter class="solr.HindiNormalizationFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_hi.txt"/>
+      <filter class="solr.HindiStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Hungarian -->
+  <fieldType name="text_hu" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_hu.txt" format="snowball"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Hungarian"/>
+      <!-- less aggressive: <filter class="solr.HungarianLightStemFilterFactory"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Armenian -->
+  <fieldType name="text_hy" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_hy.txt"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Armenian"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Indonesian -->
+  <fieldType name="text_id" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_id.txt"/>
+      <!-- for a less aggressive approach (only inflectional suffixes), set stemDerivational to false -->
+      <filter class="solr.IndonesianStemFilterFactory" stemDerivational="true"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Italian -->
+  <fieldType name="text_it" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- removes l', etc -->
+      <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_it.txt"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_it.txt" format="snowball"/>
+      <filter class="solr.ItalianLightStemFilterFactory"/>
+      <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="Italian"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Latvian -->
+  <fieldType name="text_lv" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_lv.txt"/>
+      <filter class="solr.LatvianStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Dutch -->
+  <fieldType name="text_nl" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_nl.txt" format="snowball"/>
+      <filter class="solr.StemmerOverrideFilterFactory" dictionary="lang/stemdict_nl.txt" ignoreCase="false"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Dutch"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Norwegian -->
+  <fieldType name="text_no" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_no.txt" format="snowball"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Norwegian"/>
+      <!-- less aggressive: <filter class="solr.NorwegianLightStemFilterFactory"/> -->
+      <!-- singular/plural: <filter class="solr.NorwegianMinimalStemFilterFactory"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Portuguese -->
+  <fieldType name="text_pt" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_pt.txt" format="snowball"/>
+      <filter class="solr.PortugueseLightStemFilterFactory"/>
+      <!-- less aggressive: <filter class="solr.PortugueseMinimalStemFilterFactory"/> -->
+      <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="Portuguese"/> -->
+      <!-- most aggressive: <filter class="solr.PortugueseStemFilterFactory"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Romanian -->
+  <fieldType name="text_ro" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ro.txt"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Romanian"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Russian -->
+  <fieldType name="text_ru" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ru.txt" format="snowball"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Russian"/>
+      <!-- less aggressive: <filter class="solr.RussianLightStemFilterFactory"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Swedish -->
+  <fieldType name="text_sv" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_sv.txt" format="snowball"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Swedish"/>
+      <!-- less aggressive: <filter class="solr.SwedishLightStemFilterFactory"/> -->
+    </analyzer>
+  </fieldType>
+
+  <!-- Thai -->
+  <fieldType name="text_th" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.ThaiTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_th.txt"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Turkish -->
+  <fieldType name="text_tr" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.TurkishLowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="false" words="lang/stopwords_tr.txt"/>
+      <filter class="solr.SnowballPorterFilterFactory" language="Turkish"/>
+    </analyzer>
+  </fieldType>
 
-   <!--
-    A Geohash is a compact representation of a latitude longitude pair in a single field.
-    See http://wiki.apache.org/solr/SpatialSearch
-   -->
-    <fieldType name="geohash" class="solr.GeoHashField"/>
-
-   <!-- Money/currency field type. See http://wiki.apache.org/solr/MoneyFieldType
-        Parameters:
-          defaultCurrency: Specifies the default currency if none specified. Defaults to "USD"
-          precisionStep:   Specifies the precisionStep for the TrieLong field used for the amount
-          providerClass:   Lets you plug in other exchange provider backend:
-                           solr.FileExchangeRateProvider is the default and takes one parameter:
-                             currencyConfig: name of an xml file holding exhange rates
-                           solr.OpenExchangeRatesOrgProvider uses rates from openexchangerates.org:
-                             ratesFileLocation: URL or path to rates JSON file (default latest.json on the web)
-                             refreshInterval: Number of minutes between each rates fetch (default: 1440, min: 60)
-   -->
-    <fieldType name="currency" class="solr.CurrencyField" precisionStep="8" defaultCurrency="USD" currencyConfig="currency.xml" />
-             
-
-
-   <!-- some examples for different languages (generally ordered by ISO code) -->
-
-    <!-- Arabic -->
-    <fieldType name="text_ar" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- for any non-arabic -->
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ar.txt"/>
-        <!-- normalizes ? to ?, etc -->
-        <filter class="solr.ArabicNormalizationFilterFactory"/>
-        <filter class="solr.ArabicStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- Bulgarian -->
-    <fieldType name="text_bg" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/> 
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_bg.txt"/>
-        <filter class="solr.BulgarianStemFilterFactory"/>       
-      </analyzer>
-    </fieldType>
-    
-    <!-- Catalan -->
-    <fieldType name="text_ca" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- removes l', etc -->
-        <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_ca.txt"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ca.txt"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Catalan"/>       
-      </analyzer>
-    </fieldType>
-    
-    <!-- CJK bigram (see text_ja for a Japanese configuration using morphological analysis) -->
-    <fieldType name="text_cjk" class="solr.TextField" positionIncrementGap="100">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- normalize width before bigram, as e.g. half-width dakuten combine  -->
-        <filter class="solr.CJKWidthFilterFactory"/>
-        <!-- for any non-CJK -->
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.CJKBigramFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- Czech -->
-    <fieldType name="text_cz" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_cz.txt"/>
-        <filter class="solr.CzechStemFilterFactory"/>       
-      </analyzer>
-    </fieldType>
-    
-    <!-- Danish -->
-    <fieldType name="text_da" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_da.txt" format="snowball"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Danish"/>       
-      </analyzer>
-    </fieldType>
-    
-    <!-- German -->
-    <fieldType name="text_de" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_de.txt" format="snowball"/>
-        <filter class="solr.GermanNormalizationFilterFactory"/>
-        <filter class="solr.GermanLightStemFilterFactory"/>
-        <!-- less aggressive: <filter class="solr.GermanMinimalStemFilterFactory"/> -->
-        <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="German2"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Greek -->
-    <fieldType name="text_el" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- greek specific lowercase for sigma -->
-        <filter class="solr.GreekLowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="false" words="lang/stopwords_el.txt"/>
-        <filter class="solr.GreekStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Spanish -->
-    <fieldType name="text_es" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_es.txt" format="snowball"/>
-        <filter class="solr.SpanishLightStemFilterFactory"/>
-        <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="Spanish"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Basque -->
-    <fieldType name="text_eu" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_eu.txt"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Basque"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Persian -->
-    <fieldType name="text_fa" class="solr.TextField" positionIncrementGap="100">
-      <analyzer>
-        <!-- for ZWNJ -->
-        <charFilter class="solr.PersianCharFilterFactory"/>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.ArabicNormalizationFilterFactory"/>
-        <filter class="solr.PersianNormalizationFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_fa.txt"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Finnish -->
-    <fieldType name="text_fi" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_fi.txt" format="snowball"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Finnish"/>
-        <!-- less aggressive: <filter class="solr.FinnishLightStemFilterFactory"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- French -->
-    <fieldType name="text_fr" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- removes l', etc -->
-        <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_fr.txt"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_fr.txt" format="snowball"/>
-        <filter class="solr.FrenchLightStemFilterFactory"/>
-        <!-- less aggressive: <filter class="solr.FrenchMinimalStemFilterFactory"/> -->
-        <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="French"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Irish -->
-    <fieldType name="text_ga" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- removes d', etc -->
-        <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_ga.txt"/>
-        <!-- removes n-, etc. position increments is intentionally false! -->
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/hyphenations_ga.txt"/>
-        <filter class="solr.IrishLowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ga.txt"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Irish"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Galician -->
-    <fieldType name="text_gl" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_gl.txt"/>
-        <filter class="solr.GalicianStemFilterFactory"/>
-        <!-- less aggressive: <filter class="solr.GalicianMinimalStemFilterFactory"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Hindi -->
-    <fieldType name="text_hi" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <!-- normalizes unicode representation -->
-        <filter class="solr.IndicNormalizationFilterFactory"/>
-        <!-- normalizes variation in spelling -->
-        <filter class="solr.HindiNormalizationFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_hi.txt"/>
-        <filter class="solr.HindiStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Hungarian -->
-    <fieldType name="text_hu" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_hu.txt" format="snowball"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Hungarian"/>
-        <!-- less aggressive: <filter class="solr.HungarianLightStemFilterFactory"/> -->   
-      </analyzer>
-    </fieldType>
-    
-    <!-- Armenian -->
-    <fieldType name="text_hy" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_hy.txt"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Armenian"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Indonesian -->
-    <fieldType name="text_id" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_id.txt"/>
-        <!-- for a less aggressive approach (only inflectional suffixes), set stemDerivational to false -->
-        <filter class="solr.IndonesianStemFilterFactory" stemDerivational="true"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Italian -->
-    <fieldType name="text_it" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- removes l', etc -->
-        <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_it.txt"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_it.txt" format="snowball"/>
-        <filter class="solr.ItalianLightStemFilterFactory"/>
-        <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="Italian"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Latvian -->
-    <fieldType name="text_lv" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_lv.txt"/>
-        <filter class="solr.LatvianStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Dutch -->
-    <fieldType name="text_nl" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_nl.txt" format="snowball"/>
-        <filter class="solr.StemmerOverrideFilterFactory" dictionary="lang/stemdict_nl.txt" ignoreCase="false"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Dutch"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Norwegian -->
-    <fieldType name="text_no" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_no.txt" format="snowball"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Norwegian"/>
-        <!-- less aggressive: <filter class="solr.NorwegianLightStemFilterFactory"/> -->
-        <!-- singular/plural: <filter class="solr.NorwegianMinimalStemFilterFactory"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Portuguese -->
-    <fieldType name="text_pt" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_pt.txt" format="snowball"/>
-        <filter class="solr.PortugueseLightStemFilterFactory"/>
-        <!-- less aggressive: <filter class="solr.PortugueseMinimalStemFilterFactory"/> -->
-        <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="Portuguese"/> -->
-        <!-- most aggressive: <filter class="solr.PortugueseStemFilterFactory"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Romanian -->
-    <fieldType name="text_ro" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ro.txt"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Romanian"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Russian -->
-    <fieldType name="text_ru" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ru.txt" format="snowball"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Russian"/>
-        <!-- less aggressive: <filter class="solr.RussianLightStemFilterFactory"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Swedish -->
-    <fieldType name="text_sv" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_sv.txt" format="snowball"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Swedish"/>
-        <!-- less aggressive: <filter class="solr.SwedishLightStemFilterFactory"/> -->
-      </analyzer>
-    </fieldType>
-    
-    <!-- Thai -->
-    <fieldType name="text_th" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.ThaiTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_th.txt"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Turkish -->
-    <fieldType name="text_tr" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.TurkishLowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="false" words="lang/stopwords_tr.txt"/>
-        <filter class="solr.SnowballPorterFilterFactory" language="Turkish"/>
-      </analyzer>
-    </fieldType>
-
- </types>
-  
   <!-- Similarity is the scoring routine for each document vs. a query.
        A custom Similarity or SimilarityFactory may be specified here, but 
        the default is fine for most applications.  
diff --git a/solr/contrib/uima/src/test-files/uima/solr/collection1/conf/schema.xml b/solr/contrib/uima/src/test-files/uima/solr/collection1/conf/schema.xml
index dcfadf5..5e0273e 100644
--- a/solr/contrib/uima/src/test-files/uima/solr/collection1/conf/schema.xml
+++ b/solr/contrib/uima/src/test-files/uima/solr/collection1/conf/schema.xml
@@ -51,7 +51,6 @@
     attribute introduced, true by default except for text fields.
   -->
 
-  <types>
     <!--
       field type definitions. The "name" attribute is just a label to be
       used by field definitions. The "class" attribute and any other
@@ -416,14 +415,12 @@
     <fieldType name="ignored" stored="false" indexed="false"
       multiValued="true" class="solr.StrField" />
 
-  </types>
 
 
-  <fields>
     <!--
       Valid attributes for fields: name: mandatory - the name for the
       field type: mandatory - the name of a previously defined type from
-      the <types> section indexed: true if this field should be indexed
+      the <fieldType>s indexed: true if this field should be indexed
       (searchable or sortable) stored: true if this field should be
       retrievable multiValued: true if this field may contain multiple
       values per document omitNorms: (expert) set to true to omit the
@@ -558,7 +555,6 @@
     -->
     <!--dynamicField name="*" type="ignored" multiValued="true" /-->
 
-  </fields>
 
   <!--
     Field to use to determine and enforce document uniqueness. Unless
diff --git a/solr/contrib/uima/src/test-files/uima/uima-tokenizers-schema.xml b/solr/contrib/uima/src/test-files/uima/uima-tokenizers-schema.xml
index b88fa3b..0007be7 100644
--- a/solr/contrib/uima/src/test-files/uima/uima-tokenizers-schema.xml
+++ b/solr/contrib/uima/src/test-files/uima/uima-tokenizers-schema.xml
@@ -1,43 +1,43 @@
 <?xml version="1.0" encoding="UTF-8" ?>
-  <!--
-    Licensed to the Apache Software Foundation (ASF) under one or more
-    contributor license agreements. See the NOTICE file distributed with
-    this work for additional information regarding copyright ownership.
-    The ASF licenses this file to You under the Apache License, Version
-    2.0 (the "License"); you may not use this file except in compliance
-    with the License. You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0 Unless required by
-    applicable law or agreed to in writing, software distributed under
-    the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
-    OR CONDITIONS OF ANY KIND, either express or implied. See the
-    License for the specific language governing permissions and
-    limitations under the License.
-  -->
-
-  <!--
-    This is the Solr schema file. This file should be named "schema.xml"
-    and should be in the conf directory under the solr home (i.e.
-    ./solr/conf/schema.xml by default) or located where the classloader
-    for the Solr webapp can find it. This example schema is the
-    recommended starting point for users. It should be kept correct and
-    concise, usable out-of-the-box. For more information, on how to
-    customize this file, please see
-    http://wiki.apache.org/solr/SchemaXml PERFORMANCE NOTE: this schema
-    includes many optional features and should not be used for
-    benchmarking. To improve performance one could - set stored="false"
-    for all fields possible (esp large fields) when you only need to
-    search on the field but don't need to return the original value. -
-    set indexed="false" if you don't need to search on the field, but
-    only return the field as a result of searching on other indexed
-    fields. - remove all unneeded copyField statements - for best index
-    size and searching performance, set "index" to false for all general
-    text fields, use copyField to copy them to the catchall "text"
-    field, and use that for searching. - For maximum indexing
-    performance, use the ConcurrentUpdateSolrServer java client. -
-    Remember to run the JVM in server mode, and use a higher logging
-    level that avoids logging every request
-  -->
+<!--
+  Licensed to the Apache Software Foundation (ASF) under one or more
+  contributor license agreements. See the NOTICE file distributed with
+  this work for additional information regarding copyright ownership.
+  The ASF licenses this file to You under the Apache License, Version
+  2.0 (the "License"); you may not use this file except in compliance
+  with the License. You may obtain a copy of the License at
+
+  http://www.apache.org/licenses/LICENSE-2.0 Unless required by
+  applicable law or agreed to in writing, software distributed under
+  the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+  OR CONDITIONS OF ANY KIND, either express or implied. See the
+  License for the specific language governing permissions and
+  limitations under the License.
+-->
+
+<!--
+  This is the Solr schema file. This file should be named "schema.xml"
+  and should be in the conf directory under the solr home (i.e.
+  ./solr/conf/schema.xml by default) or located where the classloader
+  for the Solr webapp can find it. This example schema is the
+  recommended starting point for users. It should be kept correct and
+  concise, usable out-of-the-box. For more information, on how to
+  customize this file, please see
+  http://wiki.apache.org/solr/SchemaXml PERFORMANCE NOTE: this schema
+  includes many optional features and should not be used for
+  benchmarking. To improve performance one could - set stored="false"
+  for all fields possible (esp large fields) when you only need to
+  search on the field but don't need to return the original value. -
+  set indexed="false" if you don't need to search on the field, but
+  only return the field as a result of searching on other indexed
+  fields. - remove all unneeded copyField statements - for best index
+  size and searching performance, set "index" to false for all general
+  text fields, use copyField to copy them to the catchall "text"
+  field, and use that for searching. - For maximum indexing
+  performance, use the ConcurrentUpdateSolrServer java client. -
+  Remember to run the JVM in server mode, and use a higher logging
+  level that avoids logging every request
+-->
 
 <schema name="sample" version="1.2">
   <!--
@@ -51,515 +51,509 @@
     attribute introduced, true by default except for text fields.
   -->
 
-  <types>
-    <!--
-      field type definitions. The "name" attribute is just a label to be
-      used by field definitions. The "class" attribute and any other
-      attributes determine the real behavior of the fieldType. Class
-      names starting with "solr" refer to java classes in the
-      org.apache.solr.analysis package.
-    -->
-
-    <!--
-      The StrField type is not analyzed, but indexed/stored verbatim. -
-      StrField and TextField support an optional compressThreshold which
-      limits compression (if enabled in the derived fields) to values
-      which exceed a certain size (in characters).
-    -->
-    <fieldType name="string" class="solr.StrField"
-      sortMissingLast="true" omitNorms="true" />
-
-    <!-- boolean type: "true" or "false" -->
-    <fieldType name="boolean" class="solr.BoolField"
-      sortMissingLast="true" omitNorms="true" />
-    <!--
-      Binary data type. The data should be sent/retrieved in as Base64
-      encoded Strings
-    -->
-    <fieldType name="binary" class="solr.BinaryField" />
-
-    <!--
-      If sortMissingLast="true", then a sort on this field will cause
-      documents without the field to come after documents with the
-      field, regardless of the requested sort order (asc or desc). - If
-      sortMissingFirst="true", then a sort on this field will cause
-      documents without the field to come before documents with the
-      field, regardless of the requested sort order. - If
-      sortMissingLast="false" and sortMissingFirst="false" (the
-      default), then default lucene sorting will be used which places
-      docs without the field first in an ascending sort and last in a
-      descending sort.
-    -->
-
-    <!--
-      Default numeric field types. For faster range queries, consider
-      the tint/tfloat/tlong/tdouble types.
-    -->
-    <fieldType name="int" class="solr.TrieIntField"
-      precisionStep="0" omitNorms="true" positionIncrementGap="0" />
-    <fieldType name="float" class="solr.TrieFloatField"
-      precisionStep="0" omitNorms="true" positionIncrementGap="0" />
-    <fieldType name="long" class="solr.TrieLongField"
-      precisionStep="0" omitNorms="true" positionIncrementGap="0" />
-    <fieldType name="double" class="solr.TrieDoubleField"
-      precisionStep="0" omitNorms="true" positionIncrementGap="0" />
-
-    <!--
-      Numeric field types that index each value at various levels of
-      precision to accelerate range queries when the number of values
-      between the range endpoints is large. See the javadoc for
-      LegacyNumericRangeQuery for internal implementation details. Smaller
-      precisionStep values (specified in bits) will lead to more tokens
-      indexed per value, slightly larger index size, and faster range
-      queries. A precisionStep of 0 disables indexing at different
-      precision levels.
-    -->
-    <fieldType name="tint" class="solr.TrieIntField"
-      precisionStep="8" omitNorms="true" positionIncrementGap="0" />
-    <fieldType name="tfloat" class="solr.TrieFloatField"
-      precisionStep="8" omitNorms="true" positionIncrementGap="0" />
-    <fieldType name="tlong" class="solr.TrieLongField"
-      precisionStep="8" omitNorms="true" positionIncrementGap="0" />
-    <fieldType name="tdouble" class="solr.TrieDoubleField"
-      precisionStep="8" omitNorms="true" positionIncrementGap="0" />
-
-    <!--
-      The format for this date field is of the form
-      1995-12-31T23:59:59Z, and is a more restricted form of the
-      canonical representation of dateTime
-      http://www.w3.org/TR/xmlschema-2/#dateTime The trailing "Z"
-      designates UTC time and is mandatory. Optional fractional seconds
-      are allowed: 1995-12-31T23:59:59.999Z All other components are
-      mandatory. Expressions can also be used to denote calculations
-      that should be performed relative to "NOW" to determine the value,
-      ie... NOW/HOUR ... Round to the start of the current hour NOW-1DAY
-      ... Exactly 1 day prior to now NOW/DAY+6MONTHS+3DAYS ... 6 months
-      and 3 days in the future from the start of the current day Consult
-      the TrieDateField javadocs for more information. Note: For faster
-      range queries, consider the tdate type
-    -->
-    <fieldType name="date" class="solr.TrieDateField"
-      omitNorms="true" precisionStep="0" positionIncrementGap="0" />
-
-    <!--
-      A Trie based date field for faster date range queries and date
-      faceting.
-    -->
-    <fieldType name="tdate" class="solr.TrieDateField"
-      omitNorms="true" precisionStep="6" positionIncrementGap="0" />
-
-    <!--
-      The "RandomSortField" is not used to store or search any data. You
-      can declare fields of this type it in your schema to generate
-      pseudo-random orderings of your docs for sorting purposes. The
-      ordering is generated based on the field name and the version of
-      the index, As long as the index version remains unchanged, and the
-      same field name is reused, the ordering of the docs will be
-      consistent. If you want different psuedo-random orderings of
-      documents, for the same version of the index, use a dynamicField
-      and change the name
-    -->
-    <fieldType name="random" class="solr.RandomSortField"
-      indexed="true" />
-
-    <!--
-      solr.TextField allows the specification of custom text analyzers
-      specified as a tokenizer and a list of token filters. Different
-      analyzers may be specified for indexing and querying. The optional
-      positionIncrementGap puts space between multiple fields of this
-      type on the same document, with the purpose of preventing false
-      phrase matching across fields. For more info on customizing your
-      analyzer chain, please see
-      http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters
-    -->
-
-    <!--
-      One can also specify an existing Analyzer class that has a default
-      constructor via the class attribute on the analyzer element
-      <fieldType name="text_greek" class="solr.TextField"> <analyzer
-      class="org.apache.lucene.analysis.el.GreekAnalyzer"/> </fieldType>
-    -->
-
-    <!--
-      A text field that only splits on whitespace for exact matching of
-      words
-    -->
-    <fieldType name="text_ws" class="solr.TextField"
-      positionIncrementGap="100">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory" />
-      </analyzer>
-    </fieldType>
-
-    <!--
-      A text field that uses WordDelimiterFilter to enable splitting and
-      matching of words on case-change, alpha numeric boundaries, and
-      non-alphanumeric chars, so that a query of "wifi" or "wi fi" could
-      match a document containing "Wi-Fi". Synonyms and stopwords are
-      customized by external files, and stemming is enabled.
-    -->
-    <fieldType name="text" class="solr.TextField"
-      positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory" />
-        <!--
-          in this example, we will only use synonyms at query time
-          <filter class="solr.SynonymFilterFactory"
-          synonyms="index_synonyms.txt" ignoreCase="true"
-          expand="false"/>
-        -->
-        <!--
-          Case insensitive stop word removal. add
-        -->
-        <filter class="solr.WordDelimiterFilterFactory"
-          generateWordParts="1" generateNumberParts="1" catenateWords="1"
-          catenateNumbers="1" catenateAll="0" splitOnCaseChange="1" />
-        <filter class="solr.LowerCaseFilterFactory" />
-        
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory" />
-
-        <filter class="solr.WordDelimiterFilterFactory"
-          generateWordParts="1" generateNumberParts="1" catenateWords="0"
-          catenateNumbers="0" catenateAll="0" splitOnCaseChange="1" />
-        <filter class="solr.LowerCaseFilterFactory" />
-        
-      </analyzer>
-    </fieldType>
-
-
-    <!--
-      Less flexible matching, but less false matches. Probably not ideal
-      for product names, but may be good for SKUs. Can insert dashes in
-      the wrong place and still match.
-    -->
-    <fieldType name="textTight" class="solr.TextField"
-      positionIncrementGap="100">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory" />
-        <filter class="solr.WordDelimiterFilterFactory"
-          generateWordParts="0" generateNumberParts="0" catenateWords="1"
-          catenateNumbers="1" catenateAll="0" />
-        <filter class="solr.LowerCaseFilterFactory" />
-        
-        <!--
-          this filter can remove any duplicate tokens that appear at the
-          same position - sometimes possible with WordDelimiterFilter in
-          conjuncton with stemming.
-        -->
-        <filter class="solr.RemoveDuplicatesTokenFilterFactory" />
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="uima_sentences" class="solr.TextField" positionIncrementGap="100">
-      <analyzer>
-        <tokenizer class="solr.UIMAAnnotationsTokenizerFactory"
-                   descriptorPath="/uima/AggregateSentenceAE.xml" tokenType="org.apache.uima.SentenceAnnotation"
-                   ngramsize="2"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="uima_nouns" class="solr.TextField" positionIncrementGap="100">
-      <analyzer>
-        <tokenizer class="solr.UIMATypeAwareAnnotationsTokenizerFactory"
-                   descriptorPath="/uima/AggregateSentenceAE.xml" tokenType="org.apache.uima.TokenAnnotation"
-                   featurePath="posTag"/>
-        <filter class="solr.TypeTokenFilterFactory" types="uima/stoptypes.txt" />
-      </analyzer>
-    </fieldType>
-
-
-    <!--
-      A general unstemmed text field - good if one does not know the
-      language of the field
-    -->
-    <fieldType name="textgen" class="solr.TextField"
-      positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory" />
-        <filter class="solr.WordDelimiterFilterFactory"
-          generateWordParts="1" generateNumberParts="1" catenateWords="1"
-          catenateNumbers="1" catenateAll="0" splitOnCaseChange="0" />
-        <filter class="solr.LowerCaseFilterFactory" />
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory" />
-        <filter class="solr.WordDelimiterFilterFactory"
-          generateWordParts="1" generateNumberParts="1" catenateWords="0"
-          catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" />
-        <filter class="solr.LowerCaseFilterFactory" />
-      </analyzer>
-    </fieldType>
-
-
-    <!--
-      A general unstemmed text field that indexes tokens normally and
-      also reversed (via ReversedWildcardFilterFactory), to enable more
-      efficient leading wildcard queries.
-    -->
-    <fieldType name="text_rev" class="solr.TextField"
-      positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory" />
-        <filter class="solr.WordDelimiterFilterFactory"
-          generateWordParts="1" generateNumberParts="1" catenateWords="1"
-          catenateNumbers="1" catenateAll="0" splitOnCaseChange="0" />
-        <filter class="solr.LowerCaseFilterFactory" />
-        <filter class="solr.ReversedWildcardFilterFactory"
-          withOriginal="true" maxPosAsterisk="3" maxPosQuestion="2"
-          maxFractionAsterisk="0.33" />
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory" />
-        <filter class="solr.WordDelimiterFilterFactory"
-          generateWordParts="1" generateNumberParts="1" catenateWords="0"
-          catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" />
-        <filter class="solr.LowerCaseFilterFactory" />
-      </analyzer>
-    </fieldType>
-
-    <!-- charFilter + WhitespaceTokenizer  -->
-    <!--
-      <fieldType name="textCharNorm" class="solr.TextField"
-      positionIncrementGap="100" > <analyzer> <charFilter
-      class="solr.MappingCharFilterFactory"
-      mapping="mapping-ISOLatin1Accent.txt"/> <tokenizer
-      class="solr.MockTokenizerFactory"/> </analyzer> </fieldType>
-    -->
-
-    <!--
-      This is an example of using the KeywordTokenizer along With
-      various TokenFilterFactories to produce a sortable field that does
-      not include some properties of the source text
-    -->
-    <fieldType name="alphaOnlySort" class="solr.TextField"
-      sortMissingLast="true" omitNorms="true">
-      <analyzer>
-        <!--
-          KeywordTokenizer does no actual tokenizing, so the entire
-          input string is preserved as a single token
-        -->
-        <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
-        <!--
-          The LowerCase TokenFilter does what you expect, which can be
-          when you want your sorting to be case insensitive
-        -->
-        <filter class="solr.LowerCaseFilterFactory" />
-        <!-- The TrimFilter removes any leading or trailing whitespace -->
-        <filter class="solr.TrimFilterFactory" />
-        <!--
-          The PatternReplaceFilter gives you the flexibility to use Java
-          Regular expression to replace any sequence of characters
-          matching a pattern with an arbitrary replacement string, which
-          may include back references to portions of the original string
-          matched by the pattern. See the Java Regular Expression
-          documentation for more information on pattern and replacement
-          string syntax.
-
-          http://docs.oracle.com/javase/8/docs/api/java/util/regex/package-summary.html
-        -->
-        <filter class="solr.PatternReplaceFilterFactory" pattern="([^a-z])"
-          replacement="" replace="all" />
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="phonetic" stored="false" indexed="true"
-      class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory" />
-        <filter class="solr.DoubleMetaphoneFilterFactory" inject="false" />
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="payloads" stored="false" indexed="true"
-      class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory" />
-        <!--
-          The DelimitedPayloadTokenFilter can put payloads on tokens...
-          for example, a token of "foo|1.4" would be indexed as "foo"
-          with a payload of 1.4f Attributes of the
-          DelimitedPayloadTokenFilterFactory : "delimiter" - a one
-          character delimiter. Default is | (pipe) "encoder" - how to
-          encode the following value into a playload float ->
-          org.apache.lucene.analysis.payloads.FloatEncoder, integer ->
-          o.a.l.a.p.IntegerEncoder identity -> o.a.l.a.p.IdentityEncoder
-          Fully Qualified class name implementing PayloadEncoder,
-          Encoder must have a no arg constructor.
-        -->
-        <filter class="solr.DelimitedPayloadTokenFilterFactory"
-          encoder="float" />
-      </analyzer>
-    </fieldType>
-
-    <!--
-      lowercases the entire field value, keeping it as a single token.
-    -->
-    <fieldType name="lowercase" class="solr.TextField"
-      positionIncrementGap="100">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
-        <filter class="solr.LowerCaseFilterFactory" />
-      </analyzer>
-    </fieldType>
-
-
-    <!--
-      since fields of this type are by default not stored or indexed,
-      any data added to them will be ignored outright.
-    -->
-    <fieldType name="ignored" stored="false" indexed="false"
-      multiValued="true" class="solr.StrField" />
-
-  </types>
-
-
-  <fields>
-    <!--
-      Valid attributes for fields: name: mandatory - the name for the
-      field type: mandatory - the name of a previously defined type from
-      the <types> section indexed: true if this field should be indexed
-      (searchable or sortable) stored: true if this field should be
-      retrievable multiValued: true if this field may contain multiple
-      values per document omitNorms: (expert) set to true to omit the
-      norms associated with this field (this disables length
-      normalization and index-time boosting for the field, and saves
-      some memory). Only full-text fields or fields that need an
-      index-time boost need norms. termVectors: [false] set to true to
-      store the term vector for a given field. When using MoreLikeThis,
-      fields used for similarity should be stored for best performance.
-      termPositions: Store position information with the term vector.
-      This will increase storage costs. termOffsets: Store offset
-      information with the term vector. This will increase storage
-      costs. default: a value that should be used if no value is
-      specified when adding a document.
-    -->
-    <field name="id" type="string" indexed="true" stored="true"
-      required="true" />
-    <field name="sku" type="textTight" indexed="true" stored="true"
-      omitNorms="true" />
-    <field name="name" type="textgen" indexed="true" stored="true" />
-    <field name="alphaNameSort" type="alphaOnlySort" indexed="true"
-      stored="false" />
-    <field name="manu" type="textgen" indexed="true" stored="true"
-      omitNorms="true" />
-    <field name="cat" type="text_ws" indexed="true" stored="true"
-      multiValued="true" omitNorms="true" />
-    <field name="features" type="text" indexed="true" stored="true"
-      multiValued="true" />
-    <field name="includes" type="text" indexed="true" stored="true"
-      termVectors="true" termPositions="true" termOffsets="true" />
-
-    <field name="sentences" type="uima_sentences" indexed="true" stored="true" multiValued="true"
-          termVectors="true" termPositions="true" termOffsets="true" />
-    <field name="nouns" type="uima_nouns" indexed="true" stored="true" multiValued="true"
-      termVectors="true" termPositions="true" termOffsets="true" />
-
-    <field name="weight" type="float" indexed="true" stored="true" />
-    <field name="price" type="float" indexed="true" stored="true" />
-    <field name="popularity" type="int" indexed="true" stored="true" />
-    <field name="inStock" type="boolean" indexed="true" stored="true" />
-
-
-    <!--
-      Common metadata fields, named specifically to match up with
-      SolrCell metadata when parsing rich documents such as Word, PDF.
-      Some fields are multiValued only because Tika currently may return
-      multiple values for them.
-    -->
-    <field name="title" type="text" indexed="true" stored="true"
-      multiValued="true" />
-    <field name="subject" type="text" indexed="true" stored="true" />
-    <field name="description" type="text" indexed="true" stored="true" />
-    <field name="comments" type="text" indexed="true" stored="true" />
-    <field name="author" type="textgen" indexed="true" stored="true" />
-    <field name="keywords" type="textgen" indexed="true" stored="true" />
-    <field name="category" type="textgen" indexed="true" stored="true" />
-    <field name="content_type" type="string" indexed="true"
-      stored="true" multiValued="true" />
-    <field name="last_modified" type="date" indexed="true" stored="true" />
-    <field name="links" type="string" indexed="true" stored="true"
-      multiValued="true" />
-
-
-    <!--
-      catchall field, containing all other searchable text fields
-      (implemented via copyField further on in this schema
-    -->
-    <field name="text" type="text" indexed="true" stored="false"
-      multiValued="true" />
-
-    <!--
-      catchall text field that indexes tokens both normally and in
-      reverse for efficient leading wildcard queries.
-    -->
-    <field name="text_rev" type="text_rev" indexed="true" stored="false"
-      multiValued="true" />
-
-    <!--
-      non-tokenized version of manufacturer to make it easier to sort or
-      group results by manufacturer. copied from "manu" via copyField
-    -->
-    <field name="manu_exact" type="string" indexed="true" stored="false" />
-
-    <field name="payloads" type="payloads" indexed="true" stored="true" />
-
-    <!--
-      Uncommenting the following will create a "timestamp" field using a
-      default value of "NOW" to indicate when each document was indexed.
-    -->
-    <!--
-      <field name="timestamp" type="date" indexed="true" stored="true"
-      default="NOW" multiValued="false"/>
-    -->
+  <!--
+    field type definitions. The "name" attribute is just a label to be
+    used by field definitions. The "class" attribute and any other
+    attributes determine the real behavior of the fieldType. Class
+    names starting with "solr" refer to java classes in the
+    org.apache.solr.analysis package.
+  -->
+
+  <!--
+    The StrField type is not analyzed, but indexed/stored verbatim. -
+    StrField and TextField support an optional compressThreshold which
+    limits compression (if enabled in the derived fields) to values
+    which exceed a certain size (in characters).
+  -->
+  <fieldType name="string" class="solr.StrField"
+             sortMissingLast="true" omitNorms="true"/>
+
+  <!-- boolean type: "true" or "false" -->
+  <fieldType name="boolean" class="solr.BoolField"
+             sortMissingLast="true" omitNorms="true"/>
+  <!--
+    Binary data type. The data should be sent/retrieved in as Base64
+    encoded Strings
+  -->
+  <fieldType name="binary" class="solr.BinaryField"/>
+
+  <!--
+    If sortMissingLast="true", then a sort on this field will cause
+    documents without the field to come after documents with the
+    field, regardless of the requested sort order (asc or desc). - If
+    sortMissingFirst="true", then a sort on this field will cause
+    documents without the field to come before documents with the
+    field, regardless of the requested sort order. - If
+    sortMissingLast="false" and sortMissingFirst="false" (the
+    default), then default lucene sorting will be used which places
+    docs without the field first in an ascending sort and last in a
+    descending sort.
+  -->
+
+  <!--
+    Default numeric field types. For faster range queries, consider
+    the tint/tfloat/tlong/tdouble types.
+  -->
+  <fieldType name="int" class="solr.TrieIntField"
+             precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="float" class="solr.TrieFloatField"
+             precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField"
+             precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField"
+             precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+
+  <!--
+    Numeric field types that index each value at various levels of
+    precision to accelerate range queries when the number of values
+    between the range endpoints is large. See the javadoc for
+    LegacyNumericRangeQuery for internal implementation details. Smaller
+    precisionStep values (specified in bits) will lead to more tokens
+    indexed per value, slightly larger index size, and faster range
+    queries. A precisionStep of 0 disables indexing at different
+    precision levels.
+  -->
+  <fieldType name="tint" class="solr.TrieIntField"
+             precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="tfloat" class="solr.TrieFloatField"
+             precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="tlong" class="solr.TrieLongField"
+             precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="tdouble" class="solr.TrieDoubleField"
+             precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+
+  <!--
+    The format for this date field is of the form
+    1995-12-31T23:59:59Z, and is a more restricted form of the
+    canonical representation of dateTime
+    http://www.w3.org/TR/xmlschema-2/#dateTime The trailing "Z"
+    designates UTC time and is mandatory. Optional fractional seconds
+    are allowed: 1995-12-31T23:59:59.999Z All other components are
+    mandatory. Expressions can also be used to denote calculations
+    that should be performed relative to "NOW" to determine the value,
+    ie... NOW/HOUR ... Round to the start of the current hour NOW-1DAY
+    ... Exactly 1 day prior to now NOW/DAY+6MONTHS+3DAYS ... 6 months
+    and 3 days in the future from the start of the current day Consult
+    the TrieDateField javadocs for more information. Note: For faster
+    range queries, consider the tdate type
+  -->
+  <fieldType name="date" class="solr.TrieDateField"
+             omitNorms="true" precisionStep="0" positionIncrementGap="0"/>
+
+  <!--
+    A Trie based date field for faster date range queries and date
+    faceting.
+  -->
+  <fieldType name="tdate" class="solr.TrieDateField"
+             omitNorms="true" precisionStep="6" positionIncrementGap="0"/>
+
+  <!--
+    The "RandomSortField" is not used to store or search any data. You
+    can declare fields of this type it in your schema to generate
+    pseudo-random orderings of your docs for sorting purposes. The
+    ordering is generated based on the field name and the version of
+    the index, As long as the index version remains unchanged, and the
+    same field name is reused, the ordering of the docs will be
+    consistent. If you want different psuedo-random orderings of
+    documents, for the same version of the index, use a dynamicField
+    and change the name
+  -->
+  <fieldType name="random" class="solr.RandomSortField"
+             indexed="true"/>
+
+  <!--
+    solr.TextField allows the specification of custom text analyzers
+    specified as a tokenizer and a list of token filters. Different
+    analyzers may be specified for indexing and querying. The optional
+    positionIncrementGap puts space between multiple fields of this
+    type on the same document, with the purpose of preventing false
+    phrase matching across fields. For more info on customizing your
+    analyzer chain, please see
+    http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters
+  -->
+
+  <!--
+    One can also specify an existing Analyzer class that has a default
+    constructor via the class attribute on the analyzer element
+    <fieldType name="text_greek" class="solr.TextField"> <analyzer
+    class="org.apache.lucene.analysis.el.GreekAnalyzer"/> </fieldType>
+  -->
+
+  <!--
+    A text field that only splits on whitespace for exact matching of
+    words
+  -->
+  <fieldType name="text_ws" class="solr.TextField"
+             positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!--
+    A text field that uses WordDelimiterFilter to enable splitting and
+    matching of words on case-change, alpha numeric boundaries, and
+    non-alphanumeric chars, so that a query of "wifi" or "wi fi" could
+    match a document containing "Wi-Fi". Synonyms and stopwords are
+    customized by external files, and stemming is enabled.
+  -->
+  <fieldType name="text" class="solr.TextField"
+             positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <!--
+        in this example, we will only use synonyms at query time
+        <filter class="solr.SynonymFilterFactory"
+        synonyms="index_synonyms.txt" ignoreCase="true"
+        expand="false"/>
+      -->
+      <!--
+        Case insensitive stop word removal. add
+      -->
+      <filter class="solr.WordDelimiterFilterFactory"
+              generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+
+      <filter class="solr.WordDelimiterFilterFactory"
+              generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+
+    </analyzer>
+  </fieldType>
+
+
+  <!--
+    Less flexible matching, but less false matches. Probably not ideal
+    for product names, but may be good for SKUs. Can insert dashes in
+    the wrong place and still match.
+  -->
+  <fieldType name="textTight" class="solr.TextField"
+             positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory"
+              generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+
+      <!--
+        this filter can remove any duplicate tokens that appear at the
+        same position - sometimes possible with WordDelimiterFilter in
+        conjuncton with stemming.
+      -->
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="uima_sentences" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.UIMAAnnotationsTokenizerFactory"
+                 descriptorPath="/uima/AggregateSentenceAE.xml" tokenType="org.apache.uima.SentenceAnnotation"
+                 ngramsize="2"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="uima_nouns" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.UIMATypeAwareAnnotationsTokenizerFactory"
+                 descriptorPath="/uima/AggregateSentenceAE.xml" tokenType="org.apache.uima.TokenAnnotation"
+                 featurePath="posTag"/>
+      <filter class="solr.TypeTokenFilterFactory" types="uima/stoptypes.txt"/>
+    </analyzer>
+  </fieldType>
+
+
+  <!--
+    A general unstemmed text field - good if one does not know the
+    language of the field
+  -->
+  <fieldType name="textgen" class="solr.TextField"
+             positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory"
+              generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0" splitOnCaseChange="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory"
+              generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <!--
+    A general unstemmed text field that indexes tokens normally and
+    also reversed (via ReversedWildcardFilterFactory), to enable more
+    efficient leading wildcard queries.
+  -->
+  <fieldType name="text_rev" class="solr.TextField"
+             positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory"
+              generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0" splitOnCaseChange="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.ReversedWildcardFilterFactory"
+              withOriginal="true" maxPosAsterisk="3" maxPosQuestion="2"
+              maxFractionAsterisk="0.33"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory"
+              generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- charFilter + WhitespaceTokenizer  -->
+  <!--
+    <fieldType name="textCharNorm" class="solr.TextField"
+    positionIncrementGap="100" > <analyzer> <charFilter
+    class="solr.MappingCharFilterFactory"
+    mapping="mapping-ISOLatin1Accent.txt"/> <tokenizer
+    class="solr.MockTokenizerFactory"/> </analyzer> </fieldType>
+  -->
+
+  <!--
+    This is an example of using the KeywordTokenizer along With
+    various TokenFilterFactories to produce a sortable field that does
+    not include some properties of the source text
+  -->
+  <fieldType name="alphaOnlySort" class="solr.TextField"
+             sortMissingLast="true" omitNorms="true">
+    <analyzer>
+      <!--
+        KeywordTokenizer does no actual tokenizing, so the entire
+        input string is preserved as a single token
+      -->
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+      <!--
+        The LowerCase TokenFilter does what you expect, which can be
+        when you want your sorting to be case insensitive
+      -->
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <!-- The TrimFilter removes any leading or trailing whitespace -->
+      <filter class="solr.TrimFilterFactory"/>
+      <!--
+        The PatternReplaceFilter gives you the flexibility to use Java
+        Regular expression to replace any sequence of characters
+        matching a pattern with an arbitrary replacement string, which
+        may include back references to portions of the original string
+        matched by the pattern. See the Java Regular Expression
+        documentation for more information on pattern and replacement
+        string syntax.
+
+        http://docs.oracle.com/javase/8/docs/api/java/util/regex/package-summary.html
+      -->
+      <filter class="solr.PatternReplaceFilterFactory" pattern="([^a-z])"
+              replacement="" replace="all"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="phonetic" stored="false" indexed="true"
+             class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.DoubleMetaphoneFilterFactory" inject="false"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="payloads" stored="false" indexed="true"
+             class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <!--
+        The DelimitedPayloadTokenFilter can put payloads on tokens...
+        for example, a token of "foo|1.4" would be indexed as "foo"
+        with a payload of 1.4f Attributes of the
+        DelimitedPayloadTokenFilterFactory : "delimiter" - a one
+        character delimiter. Default is | (pipe) "encoder" - how to
+        encode the following value into a playload float ->
+        org.apache.lucene.analysis.payloads.FloatEncoder, integer ->
+        o.a.l.a.p.IntegerEncoder identity -> o.a.l.a.p.IdentityEncoder
+        Fully Qualified class name implementing PayloadEncoder,
+        Encoder must have a no arg constructor.
+      -->
+      <filter class="solr.DelimitedPayloadTokenFilterFactory"
+              encoder="float"/>
+    </analyzer>
+  </fieldType>
+
+  <!--
+    lowercases the entire field value, keeping it as a single token.
+  -->
+  <fieldType name="lowercase" class="solr.TextField"
+             positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <!--
+    since fields of this type are by default not stored or indexed,
+    any data added to them will be ignored outright.
+  -->
+  <fieldType name="ignored" stored="false" indexed="false"
+             multiValued="true" class="solr.StrField"/>
+
+  <!--
+    Valid attributes for fields: name: mandatory - the name for the
+    field type: mandatory - the name of a previously defined type from
+    the <fieldType>s indexed: true if this field should be indexed
+    (searchable or sortable) stored: true if this field should be
+    retrievable multiValued: true if this field may contain multiple
+    values per document omitNorms: (expert) set to true to omit the
+    norms associated with this field (this disables length
+    normalization and index-time boosting for the field, and saves
+    some memory). Only full-text fields or fields that need an
+    index-time boost need norms. termVectors: [false] set to true to
+    store the term vector for a given field. When using MoreLikeThis,
+    fields used for similarity should be stored for best performance.
+    termPositions: Store position information with the term vector.
+    This will increase storage costs. termOffsets: Store offset
+    information with the term vector. This will increase storage
+    costs. default: a value that should be used if no value is
+    specified when adding a document.
+  -->
+  <field name="id" type="string" indexed="true" stored="true"
+         required="true"/>
+  <field name="sku" type="textTight" indexed="true" stored="true"
+         omitNorms="true"/>
+  <field name="name" type="textgen" indexed="true" stored="true"/>
+  <field name="alphaNameSort" type="alphaOnlySort" indexed="true"
+         stored="false"/>
+  <field name="manu" type="textgen" indexed="true" stored="true"
+         omitNorms="true"/>
+  <field name="cat" type="text_ws" indexed="true" stored="true"
+         multiValued="true" omitNorms="true"/>
+  <field name="features" type="text" indexed="true" stored="true"
+         multiValued="true"/>
+  <field name="includes" type="text" indexed="true" stored="true"
+         termVectors="true" termPositions="true" termOffsets="true"/>
+
+  <field name="sentences" type="uima_sentences" indexed="true" stored="true" multiValued="true"
+         termVectors="true" termPositions="true" termOffsets="true"/>
+  <field name="nouns" type="uima_nouns" indexed="true" stored="true" multiValued="true"
+         termVectors="true" termPositions="true" termOffsets="true"/>
+
+  <field name="weight" type="float" indexed="true" stored="true"/>
+  <field name="price" type="float" indexed="true" stored="true"/>
+  <field name="popularity" type="int" indexed="true" stored="true"/>
+  <field name="inStock" type="boolean" indexed="true" stored="true"/>
+
+
+  <!--
+    Common metadata fields, named specifically to match up with
+    SolrCell metadata when parsing rich documents such as Word, PDF.
+    Some fields are multiValued only because Tika currently may return
+    multiple values for them.
+  -->
+  <field name="title" type="text" indexed="true" stored="true"
+         multiValued="true"/>
+  <field name="subject" type="text" indexed="true" stored="true"/>
+  <field name="description" type="text" indexed="true" stored="true"/>
+  <field name="comments" type="text" indexed="true" stored="true"/>
+  <field name="author" type="textgen" indexed="true" stored="true"/>
+  <field name="keywords" type="textgen" indexed="true" stored="true"/>
+  <field name="category" type="textgen" indexed="true" stored="true"/>
+  <field name="content_type" type="string" indexed="true"
+         stored="true" multiValued="true"/>
+  <field name="last_modified" type="date" indexed="true" stored="true"/>
+  <field name="links" type="string" indexed="true" stored="true"
+         multiValued="true"/>
+
+
+  <!--
+    catchall field, containing all other searchable text fields
+    (implemented via copyField further on in this schema
+  -->
+  <field name="text" type="text" indexed="true" stored="false"
+         multiValued="true"/>
+
+  <!--
+    catchall text field that indexes tokens both normally and in
+    reverse for efficient leading wildcard queries.
+  -->
+  <field name="text_rev" type="text_rev" indexed="true" stored="false"
+         multiValued="true"/>
+
+  <!--
+    non-tokenized version of manufacturer to make it easier to sort or
+    group results by manufacturer. copied from "manu" via copyField
+  -->
+  <field name="manu_exact" type="string" indexed="true" stored="false"/>
+
+  <field name="payloads" type="payloads" indexed="true" stored="true"/>
+
+  <!--
+    Uncommenting the following will create a "timestamp" field using a
+    default value of "NOW" to indicate when each document was indexed.
+  -->
+  <!--
+    <field name="timestamp" type="date" indexed="true" stored="true"
+    default="NOW" multiValued="false"/>
+  -->
 
   <field name="language" type="string" indexed="true" stored="true" required="false"/>
-  <field name="sentence" type="text" indexed="true" stored="true" multiValued="true" required="false" />
+  <field name="sentence" type="text" indexed="true" stored="true" multiValued="true" required="false"/>
   <field name="sentiment" type="string" indexed="true" stored="true" multiValued="true"/>
   <field name="entity" type="text" indexed="true" stored="true" multiValued="true"/>
 
-    <!--
-      Dynamic field definitions. If a field name is not found,
-      dynamicFields will be used if the name matches any of the
-      patterns. RESTRICTION: the glob-like pattern in the name attribute
-      must have a "*" only at the start or the end. EXAMPLE: name="*_i"
-      will match any field ending in _i (like myid_i, z_i) Longer
-      patterns will be matched first. if equal size patterns both match,
-      the first appearing in the schema will be used. <dynamicField
-      name="*_i" type="int" indexed="true" stored="true"/> <dynamicField
-      name="*_s" type="string" indexed="true" stored="true"/>
-      <dynamicField name="*_l" type="long" indexed="true"
-      stored="true"/> <dynamicField name="*_t" type="text"
-      indexed="true" stored="true"/> <dynamicField name="*_b"
-      type="boolean" indexed="true" stored="true"/> <dynamicField
-      name="*_f" type="float" indexed="true" stored="true"/>
-      <dynamicField name="*_d" type="double" indexed="true"
-      stored="true"/> <dynamicField name="*_dt" type="date"
-      indexed="true" stored="true"/> <dynamicField name="*_ti"
-      type="tint" indexed="true" stored="true"/> <dynamicField
-      name="*_tl" type="tlong" indexed="true" stored="true"/>
-      <dynamicField name="*_tf" type="tfloat" indexed="true"
-      stored="true"/> <dynamicField name="*_td" type="tdouble"
-      indexed="true" stored="true"/> <dynamicField name="*_tdt"
-      type="tdate" indexed="true" stored="true"/>
-
-      <dynamicField name="ignored_*" type="ignored" multiValued="true"/>
-      <dynamicField name="attr_*" type="textgen" indexed="true"
-      stored="true" multiValued="true"/> <dynamicField name="random_*"
-      type="random" />
-    -->
-    <dynamicField name="*_sm" type="string" indexed="true" stored="true" multiValued="true"/>
-    <!--
-      uncomment the following to ignore any fields that don't already
-      match an existing field name or dynamic field, rather than
-      reporting them as an error. alternately, change the type="ignored"
-      to some other type e.g. "text" if you want unknown fields indexed
-      and/or stored by default
-    -->
-    <!--dynamicField name="*" type="ignored" multiValued="true" /-->
-
-  </fields>
+  <!--
+    Dynamic field definitions. If a field name is not found,
+    dynamicFields will be used if the name matches any of the
+    patterns. RESTRICTION: the glob-like pattern in the name attribute
+    must have a "*" only at the start or the end. EXAMPLE: name="*_i"
+    will match any field ending in _i (like myid_i, z_i) Longer
+    patterns will be matched first. if equal size patterns both match,
+    the first appearing in the schema will be used. <dynamicField
+    name="*_i" type="int" indexed="true" stored="true"/> <dynamicField
+    name="*_s" type="string" indexed="true" stored="true"/>
+    <dynamicField name="*_l" type="long" indexed="true"
+    stored="true"/> <dynamicField name="*_t" type="text"
+    indexed="true" stored="true"/> <dynamicField name="*_b"
+    type="boolean" indexed="true" stored="true"/> <dynamicField
+    name="*_f" type="float" indexed="true" stored="true"/>
+    <dynamicField name="*_d" type="double" indexed="true"
+    stored="true"/> <dynamicField name="*_dt" type="date"
+    indexed="true" stored="true"/> <dynamicField name="*_ti"
+    type="tint" indexed="true" stored="true"/> <dynamicField
+    name="*_tl" type="tlong" indexed="true" stored="true"/>
+    <dynamicField name="*_tf" type="tfloat" indexed="true"
+    stored="true"/> <dynamicField name="*_td" type="tdouble"
+    indexed="true" stored="true"/> <dynamicField name="*_tdt"
+    type="tdate" indexed="true" stored="true"/>
+
+    <dynamicField name="ignored_*" type="ignored" multiValued="true"/>
+    <dynamicField name="attr_*" type="textgen" indexed="true"
+    stored="true" multiValued="true"/> <dynamicField name="random_*"
+    type="random" />
+  -->
+  <dynamicField name="*_sm" type="string" indexed="true" stored="true" multiValued="true"/>
+  <!--
+    uncomment the following to ignore any fields that don't already
+    match an existing field name or dynamic field, rather than
+    reporting them as an error. alternately, change the type="ignored"
+    to some other type e.g. "text" if you want unknown fields indexed
+    and/or stored by default
+  -->
+  <!--dynamicField name="*" type="ignored" multiValued="true" /-->
+
 
   <!--
     Field to use to determine and enforce document uniqueness. Unless
@@ -575,7 +569,7 @@
   <defaultSearchField>text</defaultSearchField>
 
   <!-- SolrQueryParser configuration: defaultOperator="AND|OR" -->
-  <solrQueryParser defaultOperator="OR" />
+  <solrQueryParser defaultOperator="OR"/>
 
   <!--
     copyField commands copy one field to another at the time a document
@@ -584,14 +578,14 @@
     easier/faster searching.
   -->
 
-  <copyField source="cat" dest="text" />
-  <copyField source="name" dest="text" />
-  <copyField source="manu" dest="text" />
-  <copyField source="features" dest="text" />
-  <copyField source="includes" dest="text" />
-  <copyField source="text" dest="nouns" />
-  <copyField source="text" dest="sentences" />
-  <copyField source="manu" dest="manu_exact" />
+  <copyField source="cat" dest="text"/>
+  <copyField source="name" dest="text"/>
+  <copyField source="manu" dest="text"/>
+  <copyField source="features" dest="text"/>
+  <copyField source="includes" dest="text"/>
+  <copyField source="text" dest="nouns"/>
+  <copyField source="text" dest="sentences"/>
+  <copyField source="manu" dest="manu_exact"/>
 
 
   <!--copyField source="Titolo" dest="text"/-->
diff --git a/solr/contrib/velocity/src/test-files/velocity/solr/collection1/conf/schema.xml b/solr/contrib/velocity/src/test-files/velocity/solr/collection1/conf/schema.xml
index 45f0aaf..85b129e 100644
--- a/solr/contrib/velocity/src/test-files/velocity/solr/collection1/conf/schema.xml
+++ b/solr/contrib/velocity/src/test-files/velocity/solr/collection1/conf/schema.xml
@@ -17,20 +17,15 @@
 -->
 
 <schema name="minimal-velocity" version="1.6">
-  <types>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true" />
- </types>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
 
+  <field name="id" type="string" indexed="true" stored="true" required="true"/>
+  <dynamicField name="*_s" type="string" indexed="true" stored="true"/>
 
- <fields>
-   <field name="id" type="string" indexed="true" stored="true" required="true" />
-   <dynamicField name="*_s"  type="string"  indexed="true"  stored="true"/>
- </fields>
+  <uniqueKey>id</uniqueKey>
 
- <uniqueKey>id</uniqueKey>
+  <defaultSearchField>id</defaultSearchField>
 
- <defaultSearchField>id</defaultSearchField>
-
- <solrQueryParser defaultOperator="OR"/>
+  <solrQueryParser defaultOperator="OR"/>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/analysisconfs/analysis-err-schema.xml b/solr/core/src/test-files/solr/analysisconfs/analysis-err-schema.xml
index e9b508c..54f1b1c 100644
--- a/solr/core/src/test-files/solr/analysisconfs/analysis-err-schema.xml
+++ b/solr/core/src/test-files/solr/analysisconfs/analysis-err-schema.xml
@@ -21,24 +21,21 @@
   -->
 
 <schema name="test" version="1.6">
-  <types>
-    <fieldType name="long" class="solr.TrieLongField" stored="true" indexed="true" />
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0"/>
-    <fieldType name="text" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="org.apache.solr.analysis.ThrowingMockTokenFilterFactory" exceptionClassName="java.lang.RuntimeException"/>
-      </analyzer>
-    </fieldType>
- </types>
+  <fieldType name="long" class="solr.TrieLongField" stored="true" indexed="true"/>
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0"/>
+  <fieldType name="text" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="org.apache.solr.analysis.ThrowingMockTokenFilterFactory"
+              exceptionClassName="java.lang.RuntimeException"/>
+    </analyzer>
+  </fieldType>
 
 
- <fields>
-   <field name="id" type="int" indexed="true" stored="true" multiValued="false"/>
-   <field name="text" type="text" indexed="true" stored="true"/>
-   <field name="_version_" type="long" />
- </fields>
+  <field name="id" type="int" indexed="true" stored="true" multiValued="false"/>
+  <field name="text" type="text" indexed="true" stored="true"/>
+  <field name="_version_" type="long"/>
 
- <defaultSearchField>text</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+  <defaultSearchField>text</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-analyzer-class-and-nested.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-analyzer-class-and-nested.xml
index 1679636..38dc937 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-analyzer-class-and-nested.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-analyzer-class-and-nested.xml
@@ -17,24 +17,20 @@
 -->
 
 <schema name="bad-schema-analyzer-class-and-nested" version="1.0">
-  <types>
-    <fieldType name="bad_type" class="solr.TextField">
-      <!-- BEGIN BAD STUFF -->
-      <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer">
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-      </analyzer>
-      <!-- END BAD STUFF -->
-    </fieldType>
-    <fieldType name="string" class="solr.StrField" />
- </types>
-
-
- <fields>
-   <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="false"/>
-   
- </fields>
-
- <defaultSearchField>id</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+  <fieldType name="bad_type" class="solr.TextField">
+    <!-- BEGIN BAD STUFF -->
+    <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer">
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+    </analyzer>
+    <!-- END BAD STUFF -->
+  </fieldType>
+  <fieldType name="string" class="solr.StrField"/>
+
+
+  <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="false"/>
+
+
+  <defaultSearchField>id</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-bogus-analysis-parameters.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-bogus-analysis-parameters.xml
index 2f8963f..82ce742 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-bogus-analysis-parameters.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-bogus-analysis-parameters.xml
@@ -17,16 +17,12 @@
 -->
 
 <schema name="bad-schema-bogus-analysis-parameters" version="1.6">
-  <types>
-    <fieldType name="text" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory" bogusArg="bogusValue"/>
-      </analyzer>
-    </fieldType>
- </types>
+  <fieldType name="text" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory" bogusArg="bogusValue"/>
+    </analyzer>
+  </fieldType>
 
- <fields>
-   <field name="id" type="text"/>
- </fields>
+  <field name="id" type="text"/>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-bogus-field-parameters.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-bogus-field-parameters.xml
index 6516875..e927286 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-bogus-field-parameters.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-bogus-field-parameters.xml
@@ -17,13 +17,9 @@
 -->
 
 <schema name="bad-schema-bogus-field-parameters" version="1.6">
-  <types>
-    <fieldType name="binary" class="solr.BinaryField" />
- </types>
+  <fieldType name="binary" class="solr.BinaryField"/>
 
 
- <fields>
-   <field name="id" type="binary" someBogusParam="true"/>
- </fields>
+  <field name="id" type="binary" someBogusParam="true"/>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-codec-global-vs-ft-mismatch.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-codec-global-vs-ft-mismatch.xml
index 29db2cb..8f3f082 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-codec-global-vs-ft-mismatch.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-codec-global-vs-ft-mismatch.xml
@@ -17,20 +17,16 @@
 -->
 
 <schema name="bad-schema-codec-global-vs-ft-mismatch" version="1.0">
-  <types>
-    <!-- BAD: postingsFormat here but no codec that allows it -->
-    <fieldType name="direct1" class="solr.TextField" postingsFormat="Direct">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
- </types>
+  <!-- BAD: postingsFormat here but no codec that allows it -->
+  <fieldType name="direct1" class="solr.TextField" postingsFormat="Direct">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
 
- <fields>
-   <field name="direct1text" type="direct1" indexed="true" stored="true"/>
-   <dynamicField name="*" type="direct1" />
- </fields>
+  <field name="direct1text" type="direct1" indexed="true" stored="true"/>
+  <dynamicField name="*" type="direct1"/>
 
- <defaultSearchField>direct1text</defaultSearchField>
+  <defaultSearchField>direct1text</defaultSearchField>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-currency-dynamic-multivalued.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-currency-dynamic-multivalued.xml
index a71b361..b11ea56 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-currency-dynamic-multivalued.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-currency-dynamic-multivalued.xml
@@ -17,20 +17,15 @@
 -->
 
 <schema name="bad-schema-currency-ft-multivalued" version="1.4">
-  <types>
-    <fieldType name="string" class="solr.StrField" multiValued="true"/>
-    <fieldType name="currency" class="solr.CurrencyField" currencyConfig="currency.xml" multiValued="false" />
+  <fieldType name="string" class="solr.StrField" multiValued="true"/>
+  <fieldType name="currency" class="solr.CurrencyField" currencyConfig="currency.xml" multiValued="false"/>
 
- </types>
+  <field name="id" type="string" indexed="true" stored="true" multiValued="false"/>
+  <!-- BEGIN BAD STUFF: multiValued -->
+  <dynamicField name="*_c" type="currency" indexed="true" stored="true" multiValued="true"/>
+  <!-- END BAD STUFF -->
 
- <fields>
-   <field name="id" type="string" indexed="true" stored="true" multiValued="false"/>
-   <!-- BEGIN BAD STUFF: multiValued -->
-   <dynamicField name="*_c" type="currency" indexed="true" stored="true" multiValued="true" />
-   <!-- END BAD STUFF -->
- </fields>
-
- <defaultSearchField>id</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+  <defaultSearchField>id</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-currency-ft-bogus-code-in-xml.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-currency-ft-bogus-code-in-xml.xml
index 6339ae2..917ca2e 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-currency-ft-bogus-code-in-xml.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-currency-ft-bogus-code-in-xml.xml
@@ -17,22 +17,18 @@
 -->
 
 <schema name="bad-schema-currency-ft-bogus-code-in-xml" version="1.4">
-  <types>
-    <fieldType name="string" class="solr.StrField" multiValued="true"/>
-    <!-- BEGIN BAD STUFF: bad-currency.xml has bogus code-->
-    <fieldType name="currency" 
-               class="solr.CurrencyField"
-               defaultCurrency="USD"
-               currencyConfig="bad-currency.xml"
-               multiValued="false" />
- </types>
+  <fieldType name="string" class="solr.StrField" multiValued="true"/>
+  <!-- BEGIN BAD STUFF: bad-currency.xml has bogus code-->
+  <fieldType name="currency"
+             class="solr.CurrencyField"
+             defaultCurrency="USD"
+             currencyConfig="bad-currency.xml"
+             multiValued="false"/>
 
- <fields>
-   <field name="id" type="string" indexed="true" stored="true" multiValued="false"/>
-   <field name="money" type="currency" indexed="true" stored="true" />
- </fields>
+  <field name="id" type="string" indexed="true" stored="true" multiValued="false"/>
+  <field name="money" type="currency" indexed="true" stored="true"/>
 
- <defaultSearchField>id</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+  <defaultSearchField>id</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-currency-ft-bogus-default-code.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-currency-ft-bogus-default-code.xml
index 1f929777..9524c74 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-currency-ft-bogus-default-code.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-currency-ft-bogus-default-code.xml
@@ -17,22 +17,18 @@
 -->
 
 <schema name="bad-schema-currency-ft-bogus-default-code" version="1.4">
-  <types>
-    <fieldType name="string" class="solr.StrField" multiValued="true"/>
-    <!-- BEGIN BAD STUFF: default -->
-    <fieldType name="currency" 
-               class="solr.CurrencyField"
-               defaultCurrency="HOSS"
-               currencyConfig="currency.xml"
-               multiValued="false" />
- </types>
+  <fieldType name="string" class="solr.StrField" multiValued="true"/>
+  <!-- BEGIN BAD STUFF: default -->
+  <fieldType name="currency"
+             class="solr.CurrencyField"
+             defaultCurrency="HOSS"
+             currencyConfig="currency.xml"
+             multiValued="false"/>
 
- <fields>
-   <field name="id" type="string" indexed="true" stored="true" multiValued="false"/>
-   <field name="money" type="currency" indexed="true" stored="true" />
- </fields>
+  <field name="id" type="string" indexed="true" stored="true" multiValued="false"/>
+  <field name="money" type="currency" indexed="true" stored="true"/>
 
- <defaultSearchField>id</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+  <defaultSearchField>id</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-currency-ft-multivalued.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-currency-ft-multivalued.xml
index a1b788e..110f604 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-currency-ft-multivalued.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-currency-ft-multivalued.xml
@@ -17,18 +17,14 @@
 -->
 
 <schema name="bad-schema-currency-ft-multivalued" version="1.4">
-  <types>
-    <fieldType name="string" class="solr.StrField" multiValued="true"/>
-    <!-- BEGIN BAD STUFF: multiValued -->
-    <fieldType name="currency" class="solr.CurrencyField" currencyConfig="currency.xml" multiValued="true" />
- </types>
+  <fieldType name="string" class="solr.StrField" multiValued="true"/>
+  <!-- BEGIN BAD STUFF: multiValued -->
+  <fieldType name="currency" class="solr.CurrencyField" currencyConfig="currency.xml" multiValued="true"/>
 
- <fields>
-   <field name="id" type="string" indexed="true" stored="true" multiValued="false"/>
-   <field name="money" type="currency" indexed="true" stored="true" />
- </fields>
+  <field name="id" type="string" indexed="true" stored="true" multiValued="false"/>
+  <field name="money" type="currency" indexed="true" stored="true"/>
 
- <defaultSearchField>id</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+  <defaultSearchField>id</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-currency-ft-oer-norates.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-currency-ft-oer-norates.xml
index bd23933..c1a78ac 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-currency-ft-oer-norates.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-currency-ft-oer-norates.xml
@@ -17,21 +17,17 @@
 -->
 
 <schema name="bad-schema-currency-ft-oer-norates" version="1.4">
-  <types>
-    <fieldType name="string" class="solr.StrField" multiValued="true"/>
-    <!-- BEGIN BAD STUFF: multiValued -->
-    <fieldType name="currency" 
-               class="solr.CurrencyField" 
-               providerClass="solr.OpenExchangeRatesOrgProvider"
-               multiValued="false" />
- </types>
+  <fieldType name="string" class="solr.StrField" multiValued="true"/>
+  <!-- BEGIN BAD STUFF: multiValued -->
+  <fieldType name="currency"
+             class="solr.CurrencyField"
+             providerClass="solr.OpenExchangeRatesOrgProvider"
+             multiValued="false"/>
 
- <fields>
-   <field name="id" type="string" indexed="true" stored="true" multiValued="false"/>
-   <field name="money" type="currency" indexed="true" stored="true" />
- </fields>
+  <field name="id" type="string" indexed="true" stored="true" multiValued="false"/>
+  <field name="money" type="currency" indexed="true" stored="true"/>
 
- <defaultSearchField>id</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+  <defaultSearchField>id</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-currency-multivalued.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-currency-multivalued.xml
index 84bfaea..83880a0 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-currency-multivalued.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-currency-multivalued.xml
@@ -17,19 +17,15 @@
 -->
 
 <schema name="bad-schema-currency-multivalued" version="1.4">
-  <types>
-    <fieldType name="string" class="solr.StrField" multiValued="true"/>
-    <fieldType name="currency" class="solr.CurrencyField" currencyConfig="currency.xml"/>
- </types>
+  <fieldType name="string" class="solr.StrField" multiValued="true"/>
+  <fieldType name="currency" class="solr.CurrencyField" currencyConfig="currency.xml"/>
 
- <fields>
-   <field name="id" type="string" indexed="true" stored="true" multiValued="false"/>
-   <!-- BEGIN BAD STUFF: multiValued -->
-   <field name="money" type="currency" indexed="true" stored="true" multiValued="true" />
-   <!-- END BAD STUFF -->
- </fields>
+  <field name="id" type="string" indexed="true" stored="true" multiValued="false"/>
+  <!-- BEGIN BAD STUFF: multiValued -->
+  <field name="money" type="currency" indexed="true" stored="true" multiValued="true"/>
+  <!-- END BAD STUFF -->
 
- <defaultSearchField>id</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+  <defaultSearchField>id</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-dup-dynamicField.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-dup-dynamicField.xml
index 460fbda..41a8c75 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-dup-dynamicField.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-dup-dynamicField.xml
@@ -17,27 +17,20 @@
 -->
 
 <schema name="bad-schema-dup-dynamicField" version="1.0">
-  <types>
 
-    <fieldType name="string" class="solr.StrField"/>
+  <fieldType name="string" class="solr.StrField"/>
 
- </types>
+  <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="signatureField" type="string" indexed="true" stored="false"/>
 
+  <dynamicField name="*_sS" type="string" indexed="false" stored="true"/>
 
- <fields>
-   <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="false"/>
-   <field name="signatureField" type="string" indexed="true" stored="false"/>
-    
-   <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
+  <!-- BEGIN BAD STUFF -->
+  <dynamicField name="*_twice" type="string" indexed="true" stored="true"/>
+  <dynamicField name="*_twice" type="string" indexed="true" stored="true"/>
+  <!-- END BAD STUFF -->
 
-   <!-- BEGIN BAD STUFF -->
-   <dynamicField name="*_twice"  type="string"  indexed="true"  stored="true"/>
-   <dynamicField name="*_twice"  type="string"  indexed="true"  stored="true"/>
-   <!-- END BAD STUFF -->
-
- </fields>
-
- <defaultSearchField>id</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+  <defaultSearchField>id</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-dup-field.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-dup-field.xml
index 02cc1af..12b6a11 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-dup-field.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-dup-field.xml
@@ -17,27 +17,23 @@
 -->
 
 <schema name="bad-schema-dup-field" version="1.0">
-  <types>
-    <fieldType name="string" class="solr.StrField"/>
-    <fieldType name="text" class="solr.TextField" />
- </types>
+  <fieldType name="string" class="solr.StrField"/>
+  <fieldType name="text" class="solr.TextField"/>
 
 
- <fields>
-   <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="false"/>
-   
-   <field name="signatureField" type="string" indexed="true" stored="false"/>
+  <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="false"/>
 
-   <!-- BEGIN BAD STUFF -->
-   <field name="fAgain" type="text" indexed="true" stored="true"/>
-   <field name="fAgain" type="text" indexed="true" stored="true"/>
-   <!-- END BAD STUFF -->
+  <field name="signatureField" type="string" indexed="true" stored="false"/>
 
-   <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
+  <!-- BEGIN BAD STUFF -->
+  <field name="fAgain" type="text" indexed="true" stored="true"/>
+  <field name="fAgain" type="text" indexed="true" stored="true"/>
+  <!-- END BAD STUFF -->
 
- </fields>
+  <dynamicField name="*_sS" type="string" indexed="false" stored="true"/>
 
- <defaultSearchField>id</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+
+  <defaultSearchField>id</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-dup-fieldType.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-dup-fieldType.xml
index 1e20eb7..fbb4305 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-dup-fieldType.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-dup-fieldType.xml
@@ -17,28 +17,22 @@
 -->
 
 <schema name="bad-schema-dup-fieldType" version="1.0">
-  <types>
-    
-    <fieldType name="text" class="solr.TextField" />
-    <fieldType name="string" class="solr.StrField"/>
-    
-    <!-- BEGIN BAD STUFF -->
-    <fieldType name="ftAgain" class="solr.TrieIntField"/>
-    <fieldType name="ftAgain" class="solr.TrieIntField"/>
-    <!-- END BAD STUFF -->
-    
- </types>
-
-
- <fields>
-   <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="false"/>
-   
-   <field name="signatureField" type="string" indexed="true" stored="false"/>
-   <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
-
- </fields>
-
- <defaultSearchField>id</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+
+  <fieldType name="text" class="solr.TextField"/>
+  <fieldType name="string" class="solr.StrField"/>
+
+  <!-- BEGIN BAD STUFF -->
+  <fieldType name="ftAgain" class="solr.TrieIntField"/>
+  <fieldType name="ftAgain" class="solr.TrieIntField"/>
+  <!-- END BAD STUFF -->
+
+  <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="false"/>
+
+  <field name="signatureField" type="string" indexed="true" stored="false"/>
+  <dynamicField name="*_sS" type="string" indexed="false" stored="true"/>
+
+
+  <defaultSearchField>id</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-dynamicfield-default-val.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-dynamicfield-default-val.xml
index 0e3595d..04b2511 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-dynamicfield-default-val.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-dynamicfield-default-val.xml
@@ -17,18 +17,14 @@
 -->
 
 <schema name="bad-schema-dynamicfield-default-val" version="1.4">
-  <types>
-    <fieldType name="string" class="solr.StrField"/>
- </types>
+  <fieldType name="string" class="solr.StrField"/>
 
- <fields>
-   <field name="id" type="string" indexed="true" stored="true" />
-   <!-- BEGIN BAD STUFF -->
-   <dynamicField name="bad_*" type="string" default="BAD" />
-   <!-- END BAD STUFF -->
- </fields>
+  <field name="id" type="string" indexed="true" stored="true"/>
+  <!-- BEGIN BAD STUFF -->
+  <dynamicField name="bad_*" type="string" default="BAD"/>
+  <!-- END BAD STUFF -->
 
- <defaultSearchField>id</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+  <defaultSearchField>id</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-dynamicfield-required.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-dynamicfield-required.xml
index c372afd..aed2024 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-dynamicfield-required.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-dynamicfield-required.xml
@@ -17,18 +17,14 @@
 -->
 
 <schema name="bad-schema-dynamicfield-required" version="1.4">
-  <types>
-    <fieldType name="string" class="solr.StrField"/>
- </types>
+  <fieldType name="string" class="solr.StrField"/>
 
- <fields>
-   <field name="id" type="string" indexed="true" stored="true" />
-   <!-- BEGIN BAD STUFF -->
-   <dynamicField name="bad_*" type="string" required="true" />
-   <!-- END BAD STUFF -->
- </fields>
+  <field name="id" type="string" indexed="true" stored="true"/>
+  <!-- BEGIN BAD STUFF -->
+  <dynamicField name="bad_*" type="string" required="true"/>
+  <!-- END BAD STUFF -->
 
- <defaultSearchField>id</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+  <defaultSearchField>id</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-external-filefield.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-external-filefield.xml
index e7874c8..75d6a30 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-external-filefield.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-external-filefield.xml
@@ -16,12 +16,10 @@
   -->
 
 <schema name="bad-schema-external-filefield" version="1.0">
-  <types>
-    <fieldType name="tint" class="solr.TrieIntField" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="tint" class="solr.TrieIntField" omitNorms="true" positionIncrementGap="0"/>
 
-    <fieldType name="eff_none" keyField="id" defVal="0"
-               stored="false" indexed="true"
-               class="solr.ExternalFileField" valType="tint"/>
+  <fieldType name="eff_none" keyField="id" defVal="0"
+             stored="false" indexed="true"
+             class="solr.ExternalFileField" valType="tint"/>
 
-  </types>
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-init-error.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-init-error.xml
index 85a97eb..d1f610e 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-init-error.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-init-error.xml
@@ -17,13 +17,9 @@
 -->
 
 <schema name="bad-schema-throws-java-error" version="1.6">
-  <types>
-    <fieldType name="error_ft" class="solr.ThrowErrorOnInitFieldType" />
- </types>
+  <fieldType name="error_ft" class="solr.ThrowErrorOnInitFieldType"/>
 
 
- <fields>
-   <field name="id" type="error_ft" />
- </fields>
+  <field name="id" type="error_ft"/>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-misplaced-asterisk-copyfield-dest-should-fail-test.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-misplaced-asterisk-copyfield-dest-should-fail-test.xml
index 83b4b4e..8b68072 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-misplaced-asterisk-copyfield-dest-should-fail-test.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-misplaced-asterisk-copyfield-dest-should-fail-test.xml
@@ -17,12 +17,8 @@
 -->
 
 <schema name="test" version="1.6">
-  <types>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
-  </types>
-  <fields>
-    <field name="text" type="string" indexed="true" stored="true"/>
-  </fields>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+  <field name="text" type="string" indexed="true" stored="true"/>
 
   <!-- This should cause an exception, since the copyField dest contains an asterisk at a position
        that is neither the start or the end.
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-misplaced-asterisk-copyfield-source-should-fail-test.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-misplaced-asterisk-copyfield-source-should-fail-test.xml
index e29e351..9f9ed98 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-misplaced-asterisk-copyfield-source-should-fail-test.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-misplaced-asterisk-copyfield-source-should-fail-test.xml
@@ -17,12 +17,8 @@
 -->
 
 <schema name="test" version="1.6">
-  <types>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
-  </types>
-  <fields>
-    <field name="text" type="string" indexed="true" stored="true"/>
-  </fields>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+  <field name="text" type="string" indexed="true" stored="true"/>
 
   <!-- This should cause an exception, since the copyField source contains an asterisk at a position
        that is neither the start or the end. 
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-multiple-asterisk-copyfield-dest-should-fail-test.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-multiple-asterisk-copyfield-dest-should-fail-test.xml
index 650d64c..582f2d5 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-multiple-asterisk-copyfield-dest-should-fail-test.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-multiple-asterisk-copyfield-dest-should-fail-test.xml
@@ -17,12 +17,8 @@
 -->
 
 <schema name="test" version="1.6">
-  <types>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
-  </types>
-  <fields>
-    <field name="text" type="string" indexed="true" stored="true"/>
-  </fields>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+  <field name="text" type="string" indexed="true" stored="true"/>
 
   <!-- This should cause an exception, since the copyField dest contains more than one asterisk -->
   <copyField source="text" dest="*too_many_asterisks*"/>
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-multiple-asterisk-copyfield-source-should-fail-test.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-multiple-asterisk-copyfield-source-should-fail-test.xml
index 6737b1f..ee89244 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-multiple-asterisk-copyfield-source-should-fail-test.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-multiple-asterisk-copyfield-source-should-fail-test.xml
@@ -17,12 +17,8 @@
 -->
 
 <schema name="test" version="1.6">
-  <types>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
-  </types>
-  <fields>
-    <field name="text" type="string" indexed="true" stored="true"/>
-  </fields>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+  <field name="text" type="string" indexed="true" stored="true"/>
 
   <!-- This should cause an exception, since the copyField source contains more than one asterisk -->
   <copyField source="*too_many_asterisks*" dest="text"/>
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-non-glob-copyfield-source-matching-nothing-should-fail-test.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-non-glob-copyfield-source-matching-nothing-should-fail-test.xml
index 621ef29..d01ed87 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-non-glob-copyfield-source-matching-nothing-should-fail-test.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-non-glob-copyfield-source-matching-nothing-should-fail-test.xml
@@ -17,16 +17,11 @@
 -->
 
 <schema name="test" version="1.6">
-  <types>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
-  </types>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
 
-
-  <fields>
-    <field name="id" type="string" indexed="true" stored="true" required="true"/>
-    <field name="text" type="string" indexed="true" stored="true"/>
-    <dynamicField name="*_s"  type="string"  indexed="true"  stored="true"/>
-  </fields>
+  <field name="id" type="string" indexed="true" stored="true" required="true"/>
+  <field name="text" type="string" indexed="true" stored="true"/>
+  <dynamicField name="*_s" type="string" indexed="true" stored="true"/>
 
 
   <!-- This should cause an exception, since the copyField source is not a glob 
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-nontext-analyzer.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-nontext-analyzer.xml
index 06a689a..f8fd0b5 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-nontext-analyzer.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-nontext-analyzer.xml
@@ -17,23 +17,18 @@
 -->
 
 <schema name="bad-schema-nontext-analyzer" version="1.0">
-  <types>
-    <!-- BEGIN BAD STUFF -->
-    <fieldType name="bad_type" class="solr.StrField">
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-    <!-- END BAD STUFF -->
- </types>
+  <!-- BEGIN BAD STUFF -->
+  <fieldType name="bad_type" class="solr.StrField">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <!-- END BAD STUFF -->
 
+  <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="false"/>
 
- <fields>
-   <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="false"/>
-   
- </fields>
 
- <defaultSearchField>id</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+  <defaultSearchField>id</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-not-indexed-but-norms.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-not-indexed-but-norms.xml
index f7c4e9b..a42805e 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-not-indexed-but-norms.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-not-indexed-but-norms.xml
@@ -17,24 +17,20 @@
 -->
 
 <schema name="bad-schema-not-indexed-but-norms" version="1.0">
-  <types>
-    <fieldType name="string" class="solr.StrField"/>
- </types>
+  <fieldType name="string" class="solr.StrField"/>
 
- <fields>
-   <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="false"/>
-   
-   <field name="signatureField" type="string" indexed="true" stored="false"/>
+  <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="false"/>
 
-   <!-- BEGIN BAD STUFF -->
-   <field name="bad_field" type="string" indexed="false" omitNorms="false" />
-   <!-- END BAD STUFF -->
+  <field name="signatureField" type="string" indexed="true" stored="false"/>
 
-   <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
+  <!-- BEGIN BAD STUFF -->
+  <field name="bad_field" type="string" indexed="false" omitNorms="false"/>
+  <!-- END BAD STUFF -->
 
- </fields>
+  <dynamicField name="*_sS" type="string" indexed="false" stored="true"/>
 
- <defaultSearchField>id</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+
+  <defaultSearchField>id</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-not-indexed-but-pos.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-not-indexed-but-pos.xml
index 774d587..d74ce67 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-not-indexed-but-pos.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-not-indexed-but-pos.xml
@@ -17,24 +17,20 @@
 -->
 
 <schema name="bad-schema-not-indexed-but-pos" version="1.0">
-  <types>
-    <fieldType name="string" class="solr.StrField"/>
- </types>
+  <fieldType name="string" class="solr.StrField"/>
 
- <fields>
-   <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="false"/>
-   
-   <field name="signatureField" type="string" indexed="true" stored="false"/>
+  <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="false"/>
 
-   <!-- BEGIN BAD STUFF -->
-   <field name="bad_field" type="string" indexed="false" omitPositions="false" />
-   <!-- END BAD STUFF -->
+  <field name="signatureField" type="string" indexed="true" stored="false"/>
 
-   <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
+  <!-- BEGIN BAD STUFF -->
+  <field name="bad_field" type="string" indexed="false" omitPositions="false"/>
+  <!-- END BAD STUFF -->
 
- </fields>
+  <dynamicField name="*_sS" type="string" indexed="false" stored="true"/>
 
- <defaultSearchField>id</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+
+  <defaultSearchField>id</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-not-indexed-but-tf.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-not-indexed-but-tf.xml
index d153793..1f872ec 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-not-indexed-but-tf.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-not-indexed-but-tf.xml
@@ -17,24 +17,19 @@
 -->
 
 <schema name="bad-schema-not-indexed-but-tf" version="1.0">
-  <types>
-    <fieldType name="string" class="solr.StrField"/>
- </types>
+  <fieldType name="string" class="solr.StrField"/>
 
- <fields>
-   <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="false"/>
-   
-   <field name="signatureField" type="string" indexed="true" stored="false"/>
+  <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="false"/>
 
-   <!-- BEGIN BAD STUFF -->
-   <field name="bad_field" type="string" indexed="false" omitTermFreqAndPositions="false" />
-   <!-- END BAD STUFF -->
+  <field name="signatureField" type="string" indexed="true" stored="false"/>
 
-   <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
+  <!-- BEGIN BAD STUFF -->
+  <field name="bad_field" type="string" indexed="false" omitTermFreqAndPositions="false"/>
+  <!-- END BAD STUFF -->
 
- </fields>
+  <dynamicField name="*_sS" type="string" indexed="false" stored="true"/>
 
- <defaultSearchField>id</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+  <defaultSearchField>id</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-omit-tf-but-not-pos.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-omit-tf-but-not-pos.xml
index 116f116..338b236 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-omit-tf-but-not-pos.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-omit-tf-but-not-pos.xml
@@ -17,25 +17,20 @@
 -->
 
 <schema name="bad-schema-omit-tf-but-not-pos" version="1.0">
-  <types>
-    <fieldType name="string" class="solr.StrField"/>
- </types>
+  <fieldType name="string" class="solr.StrField"/>
 
- <fields>
-   <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="false"/>
-   
-   <field name="signatureField" type="string" indexed="true" stored="false"/>
+  <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="false"/>
 
-   <!-- BEGIN BAD STUFF -->
-   <field name="bad_field" type="string" indexed="true" 
-          omitTermFreqAndPositions="true" omitPositions="false" />
-   <!-- END BAD STUFF -->
+  <field name="signatureField" type="string" indexed="true" stored="false"/>
 
-   <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
+  <!-- BEGIN BAD STUFF -->
+  <field name="bad_field" type="string" indexed="true"
+         omitTermFreqAndPositions="true" omitPositions="false"/>
+  <!-- END BAD STUFF -->
 
- </fields>
+  <dynamicField name="*_sS" type="string" indexed="false" stored="true"/>
 
- <defaultSearchField>id</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+  <defaultSearchField>id</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-sim-global-vs-ft-mismatch.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-sim-global-vs-ft-mismatch.xml
index b875b44..ac8ee89 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-sim-global-vs-ft-mismatch.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-sim-global-vs-ft-mismatch.xml
@@ -18,23 +18,19 @@
 
 <schema name="bad-schema-sim-global-vs-ft-mismatch" version="1.0">
 
-  <similarity class="solr.BM25SimilarityFactory" /> <!-- global sim -->
-  
-  <types>
-    <fieldType name="sim1" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-      <!-- BAD: similarity here but global sim does not allow it -->
-      <similarity class="org.apache.lucene.misc.SweetSpotSimilarity"/>
-    </fieldType>
- </types>
-
- <fields>
-   <field name="sim1text" type="sim1" indexed="true" stored="true"/>
-   <dynamicField name="*" type="sim1" />
- </fields>
-
- <defaultSearchField>sim1text</defaultSearchField>
+  <similarity class="solr.BM25SimilarityFactory"/> <!-- global sim -->
+
+  <fieldType name="sim1" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+    <!-- BAD: similarity here but global sim does not allow it -->
+    <similarity class="org.apache.lucene.misc.SweetSpotSimilarity"/>
+  </fieldType>
+
+  <field name="sim1text" type="sim1" indexed="true" stored="true"/>
+  <dynamicField name="*" type="sim1"/>
+
+  <defaultSearchField>sim1text</defaultSearchField>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-sweetspot-both-tf.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-sweetspot-both-tf.xml
index 99028c1..12ee4e9 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-sweetspot-both-tf.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-sweetspot-both-tf.xml
@@ -17,32 +17,28 @@
 -->
 
 <schema name="bad-schema-sweetspot-both-tf" version="1.0">
-  <types>
-
-    <fieldType name="string" class="solr.StrField" />
-
-    <fieldType name="bad_ss_ft" class="solr.TextField"
-               indexed="true" stored="false">
-      <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
-      <similarity class="solr.SweetSpotSimilarityFactory">
-        <!-- BAD: using both dypes of TF settings -->
-        <float name="baselineTfMin">6.0</float>
-        <float name="baselineTfBase">1.5</float>
-        <float name="hyperbolicTfMin">3.3</float>
-        <float name="hyperbolicTfMax">7.7</float>
-        <double name="hyperbolicTfBase">5.0</double>
-        <float name="hyperbolicTfOffset">5.0</float>
-      </similarity>
-    </fieldType>
-  </types>
-
-
- <fields>
-   <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="false"/>
-   
- </fields>
-
- <defaultSearchField>id</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+
+  <fieldType name="string" class="solr.StrField"/>
+
+  <fieldType name="bad_ss_ft" class="solr.TextField"
+             indexed="true" stored="false">
+    <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
+    <similarity class="solr.SweetSpotSimilarityFactory">
+      <!-- BAD: using both dypes of TF settings -->
+      <float name="baselineTfMin">6.0</float>
+      <float name="baselineTfBase">1.5</float>
+      <float name="hyperbolicTfMin">3.3</float>
+      <float name="hyperbolicTfMax">7.7</float>
+      <double name="hyperbolicTfBase">5.0</double>
+      <float name="hyperbolicTfOffset">5.0</float>
+    </similarity>
+  </fieldType>
+
+
+  <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="false"/>
+
+
+  <defaultSearchField>id</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-sweetspot-partial-baseline.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-sweetspot-partial-baseline.xml
index cf34ec8..dd9959f 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-sweetspot-partial-baseline.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-sweetspot-partial-baseline.xml
@@ -17,28 +17,24 @@
 -->
 
 <schema name="bad-schema-sweetspot-partial-baseline" version="1.0">
-  <types>
 
-    <fieldType name="string" class="solr.StrField" />
+  <fieldType name="string" class="solr.StrField"/>
 
-    <fieldType name="bad_ss_ft" class="solr.TextField"
-               indexed="true" stored="false">
-      <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
-      <similarity class="solr.SweetSpotSimilarityFactory">
-        <!-- BAD: missing a baseline setting -->
-        <float name="baselineTfMin">6.0</float>
-        <!-- <float name="baselineTfBase">1.5</float> -->
-      </similarity>
-    </fieldType>
-  </types>
+  <fieldType name="bad_ss_ft" class="solr.TextField"
+             indexed="true" stored="false">
+    <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
+    <similarity class="solr.SweetSpotSimilarityFactory">
+      <!-- BAD: missing a baseline setting -->
+      <float name="baselineTfMin">6.0</float>
+      <!-- <float name="baselineTfBase">1.5</float> -->
+    </similarity>
+  </fieldType>
 
 
- <fields>
-   <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="false"/>
-   
- </fields>
+  <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="false"/>
 
- <defaultSearchField>id</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+
+  <defaultSearchField>id</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-sweetspot-partial-hyperbolic.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-sweetspot-partial-hyperbolic.xml
index 61e18ad..7ba1aad 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-sweetspot-partial-hyperbolic.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-sweetspot-partial-hyperbolic.xml
@@ -17,30 +17,26 @@
 -->
 
 <schema name="bad-schema-sweetspot-partial-hyperbolic" version="1.0">
-  <types>
-
-    <fieldType name="string" class="solr.StrField" />
-
-    <fieldType name="bad_ss_ft" class="solr.TextField"
-               indexed="true" stored="false">
-      <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
-      <similarity class="solr.SweetSpotSimilarityFactory">
-        <!-- BAD: missing a hyperbolic setting -->
-        <float name="hyperbolicTfMin">3.3</float>
-        <!-- <float name="hyperbolicTfMax">7.7</float> -->
-        <double name="hyperbolicTfBase">5.0</double>
-        <float name="hyperbolicTfOffset">5.0</float>
-      </similarity>
-    </fieldType>
-  </types>
-
-
- <fields>
-   <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="false"/>
-   
- </fields>
-
- <defaultSearchField>id</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+
+  <fieldType name="string" class="solr.StrField"/>
+
+  <fieldType name="bad_ss_ft" class="solr.TextField"
+             indexed="true" stored="false">
+    <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
+    <similarity class="solr.SweetSpotSimilarityFactory">
+      <!-- BAD: missing a hyperbolic setting -->
+      <float name="hyperbolicTfMin">3.3</float>
+      <!-- <float name="hyperbolicTfMax">7.7</float> -->
+      <double name="hyperbolicTfBase">5.0</double>
+      <float name="hyperbolicTfOffset">5.0</float>
+    </similarity>
+  </fieldType>
+
+
+  <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="false"/>
+
+
+  <defaultSearchField>id</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-sweetspot-partial-norms.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-sweetspot-partial-norms.xml
index ef4e804..5e6ae96 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-sweetspot-partial-norms.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-sweetspot-partial-norms.xml
@@ -17,29 +17,25 @@
 -->
 
 <schema name="bad-schema-sweetspot-partial-norms" version="1.0">
-  <types>
-
-    <fieldType name="string" class="solr.StrField" />
-
-    <fieldType name="bad_ss_ft" class="solr.TextField"
-               indexed="true" stored="false">
-      <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
-      <similarity class="solr.SweetSpotSimilarityFactory">
-        <!-- BAD: missing a norm setting -->
-        <int name="lengthNormMin">3</int>
-        <!-- <int name="lengthNormMax">5</int> -->
-        <float name="lengthNormSteepness">0.5</float>
-      </similarity>
-    </fieldType>
-  </types>
-
-
- <fields>
-   <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="false"/>
-   
- </fields>
-
- <defaultSearchField>id</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+
+  <fieldType name="string" class="solr.StrField"/>
+
+  <fieldType name="bad_ss_ft" class="solr.TextField"
+             indexed="true" stored="false">
+    <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
+    <similarity class="solr.SweetSpotSimilarityFactory">
+      <!-- BAD: missing a norm setting -->
+      <int name="lengthNormMin">3</int>
+      <!-- <int name="lengthNormMax">5</int> -->
+      <float name="lengthNormSteepness">0.5</float>
+    </similarity>
+  </fieldType>
+
+
+  <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="false"/>
+
+
+  <defaultSearchField>id</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-uniquekey-is-copyfield-dest.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-uniquekey-is-copyfield-dest.xml
index bf1d532..2939535 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-uniquekey-is-copyfield-dest.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-uniquekey-is-copyfield-dest.xml
@@ -17,20 +17,16 @@
 -->
 
 <schema name="bad-schema-uniquekey-is-copyfield-dest" version="1.4">
-  <types>
-    <fieldType name="string" class="solr.StrField"/>
- </types>
+  <fieldType name="string" class="solr.StrField"/>
 
- <fields>
-   <field name="id" type="string" indexed="true" stored="true"/>
-   <field name="XXX" type="string" indexed="true" stored="true"/>
+  <field name="id" type="string" indexed="true" stored="true"/>
+  <field name="XXX" type="string" indexed="true" stored="true"/>
 
-   <!-- BEGIN BAD STUFF -->
-   <copyField source="XXX" dest="id"/>
-   <!-- END BAD STUFF -->
- </fields>
+  <!-- BEGIN BAD STUFF -->
+  <copyField source="XXX" dest="id"/>
+  <!-- END BAD STUFF -->
 
- <defaultSearchField>id</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+  <defaultSearchField>id</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-uniquekey-multivalued.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-uniquekey-multivalued.xml
index 81ce319..130e3a6 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-uniquekey-multivalued.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-uniquekey-multivalued.xml
@@ -17,17 +17,13 @@
 -->
 
 <schema name="bad-schema-uniquekey-multivalued" version="1.4">
-  <types>
-    <fieldType name="string" class="solr.StrField" multiValued="true"/>
- </types>
+  <fieldType name="string" class="solr.StrField" multiValued="true"/>
 
- <fields>
-   <!-- BEGIN BAD STUFF: multiValued inherited from field type -->
-   <field name="id" type="string" indexed="true" stored="true" />
-   <!-- END BAD STUFF -->
- </fields>
+  <!-- BEGIN BAD STUFF: multiValued inherited from field type -->
+  <field name="id" type="string" indexed="true" stored="true"/>
+  <!-- END BAD STUFF -->
 
- <defaultSearchField>id</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+  <defaultSearchField>id</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-uniquekey-uses-default.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-uniquekey-uses-default.xml
index 026b529..ccf3822 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-uniquekey-uses-default.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-uniquekey-uses-default.xml
@@ -17,17 +17,13 @@
 -->
 
 <schema name="bad-schema-uniquekey-uses-default" version="1.4">
-  <types>
-    <fieldType name="string" class="solr.StrField"/>
- </types>
+  <fieldType name="string" class="solr.StrField"/>
 
- <fields>
-   <!-- BEGIN BAD STUFF -->
-   <field name="id" type="string" indexed="true" stored="true" default="XXX"/>
-   <!-- END BAD STUFF -->
- </fields>
+  <!-- BEGIN BAD STUFF -->
+  <field name="id" type="string" indexed="true" stored="true" default="XXX"/>
+  <!-- END BAD STUFF -->
 
- <defaultSearchField>id</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+  <defaultSearchField>id</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-unsupported-docValues.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-unsupported-docValues.xml
index 552e27d..9741a38 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-unsupported-docValues.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-unsupported-docValues.xml
@@ -17,14 +17,10 @@
 -->
 
 <schema name="bad-schema-docValues-unsupported" version="1.6">
-  <types>
-    <fieldType name="binary" class="solr.BinaryField" />
- </types>
+  <fieldType name="binary" class="solr.BinaryField"/>
 
 
- <fields>
-   <!-- change the type if BinaryField gets doc values -->
-   <field name="id" type="binary" docValues="true"/>
- </fields>
+  <!-- change the type if BinaryField gets doc values -->
+  <field name="id" type="binary" docValues="true"/>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-HighlighterMaxOffsetTest.xml b/solr/core/src/test-files/solr/collection1/conf/schema-HighlighterMaxOffsetTest.xml
index ab5c7e8..808453c 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-HighlighterMaxOffsetTest.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-HighlighterMaxOffsetTest.xml
@@ -23,70 +23,64 @@ Test for HighlighterMaxOffsetTest which requires the use of ReversedWildcardFilt
 -->
 <schema name="example" version="1.6">
 
- <fields>
-        
-   <field name="id" type="string" indexed="true" stored="true" required="true"/>
-   <field name="_version_" type="long" indexed="true" stored="true"/>
-
-   <field name="content"       type="text_general_rev" indexed="true" stored="true"  multiValued="true"/>
-
-   <field name="indexed_multiValued"       type="text_stx" indexed="true" stored="true"  multiValued="true"/>
-   <field name="indexed_singleValued"      type="text_stx" indexed="true" stored="true"   multiValued="false"/>
-
-   <field name="non_indexed_multiValued"    type="text_stx" indexed="false" stored="true"  multiValued="true"/>
-   <field name="non_indexed_singleValued"   type="text_stx" indexed="false" stored="true"   multiValued="false"/>
-
- </fields>   
-
- <uniqueKey>id</uniqueKey>
- <defaultSearchField>content</defaultSearchField>
- <solrQueryParser defaultOperator="AND"/>
- 
-  <types>
-
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true" />
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
-
-
-
-    <!-- Just like text_general except it reverses the characters of
-   each token, to enable more efficient leading wildcard queries. -->
-    <fieldType name="text_general_rev" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt" />
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.ReversedWildcardFilterFactory" withOriginal="true"
-                maxPosAsterisk="3" maxPosQuestion="2" maxFractionAsterisk="0.33"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt" />
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <fieldType name="text_stx" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0" splitOnCaseChange="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.ReversedWildcardFilterFactory" withOriginal="true"
-           maxPosAsterisk="3" maxPosQuestion="2" maxFractionAsterisk="0.33"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
- </types>
-  
+
+  <field name="id" type="string" indexed="true" stored="true" required="true"/>
+  <field name="_version_" type="long" indexed="true" stored="true"/>
+
+  <field name="content" type="text_general_rev" indexed="true" stored="true" multiValued="true"/>
+
+  <field name="indexed_multiValued" type="text_stx" indexed="true" stored="true" multiValued="true"/>
+  <field name="indexed_singleValued" type="text_stx" indexed="true" stored="true" multiValued="false"/>
+
+  <field name="non_indexed_multiValued" type="text_stx" indexed="false" stored="true" multiValued="true"/>
+  <field name="non_indexed_singleValued" type="text_stx" indexed="false" stored="true" multiValued="false"/>
+
+
+  <uniqueKey>id</uniqueKey>
+  <defaultSearchField>content</defaultSearchField>
+  <solrQueryParser defaultOperator="AND"/>
+
+
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
+
+
+  <!-- Just like text_general except it reverses the characters of
+ each token, to enable more efficient leading wildcard queries. -->
+  <fieldType name="text_general_rev" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.ReversedWildcardFilterFactory" withOriginal="true"
+              maxPosAsterisk="3" maxPosQuestion="2" maxFractionAsterisk="0.33"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <fieldType name="text_stx" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0" splitOnCaseChange="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.ReversedWildcardFilterFactory" withOriginal="true"
+              maxPosAsterisk="3" maxPosQuestion="2" maxFractionAsterisk="0.33"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
 
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-add-schema-fields-update-processor.xml b/solr/core/src/test-files/solr/collection1/conf/schema-add-schema-fields-update-processor.xml
index 16949d1..7f24944 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-add-schema-fields-update-processor.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-add-schema-fields-update-processor.xml
@@ -33,18 +33,16 @@
     </analyzer>
   </fieldType>
 
-  <fields>
-    <field name="id"           type="string"  indexed="true" stored="true" multiValued="false" required="true"/>
-    <field name="_version_"    type="long"    indexed="true" stored="true"/>
-    <field name="_root_"       type="string"  indexed="true" stored="true" multiValued="false"/>
-    
-    <dynamicField name="*_t"   type="text"    indexed="true" stored="true"/>
-    <dynamicField name="*_ti"  type="tint"    indexed="true" stored="true"/>
-    <dynamicField name="*_tl"  type="tlong"   indexed="true" stored="true"/>
-    <dynamicField name="*_tf"  type="tfloat"  indexed="true" stored="true"/>
-    <dynamicField name="*_td"  type="tdouble" indexed="true" stored="true"/>
-    <dynamicField name="*_tdt" type="tdate"   indexed="true" stored="true"/>
-  </fields>
+  <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="true"/>
+  <field name="_version_" type="long" indexed="true" stored="true"/>
+  <field name="_root_" type="string" indexed="true" stored="true" multiValued="false"/>
+
+  <dynamicField name="*_t" type="text" indexed="true" stored="true"/>
+  <dynamicField name="*_ti" type="tint" indexed="true" stored="true"/>
+  <dynamicField name="*_tl" type="tlong" indexed="true" stored="true"/>
+  <dynamicField name="*_tf" type="tfloat" indexed="true" stored="true"/>
+  <dynamicField name="*_td" type="tdouble" indexed="true" stored="true"/>
+  <dynamicField name="*_tdt" type="tdate" indexed="true" stored="true"/>
 
   <uniqueKey>id</uniqueKey>
 
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-behavior.xml b/solr/core/src/test-files/solr/collection1/conf/schema-behavior.xml
index 474ea29..9a0b6d3 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-behavior.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-behavior.xml
@@ -22,115 +22,111 @@
  -->
 <schema name="version-behavior" version="${solr.schema.test.ver}">
 
-  <types>
-    <!-- all behavior is default -->
-    <fieldType name="text" class="solr.TextField"/>
-    <fieldType name="bool" class="solr.BoolField"/>
-    <fieldType name="str" class="solr.StrField"/>
-    <fieldType name="int" class="solr.TrieIntField"/>
-
-    <!-- explicit props on type -->
-    <fieldType name="multi_f" class="solr.StrField" multiValued="false"/>
-    <fieldType name="multi_t" class="solr.StrField" multiValued="true"/>
-
-    <fieldType name="strnorm_f" class="solr.StrField" omitNorms="false"/>
-    <fieldType name="strnorm_t" class="solr.StrField" omitNorms="true"/>
-    <fieldType name="txtnorm_f" class="solr.TextField" omitNorms="false"/>
-    <fieldType name="txtnorm_t" class="solr.TextField" omitNorms="true"/>
-
-    <fieldType name="strTfP_f" class="solr.StrField" omitTermFreqAndPositions="false"/>
-    <fieldType name="strTfP_t" class="solr.StrField" omitTermFreqAndPositions="true"/>
-    <fieldType name="txtTfP_f" class="solr.TextField" omitTermFreqAndPositions="false"/>
-    <fieldType name="txtTfP_t" class="solr.TextField" omitTermFreqAndPositions="true"/>
-
-    <fieldType name="txt_phrase_f" class="solr.TextField"
-               autoGeneratePhraseQueries="false"/>
-    <fieldType name="txt_phrase_t" class="solr.TextField"
-               autoGeneratePhraseQueries="true"/>
-
-    <fieldType name="int_dvas_t" class="solr.TrieIntField" useDocValuesAsStored="true"/>
-    <fieldType name="int_dvas_f" class="solr.TrieIntField" useDocValuesAsStored="false"/>
-  </types>
-  <fields>
-
-    <!-- all behavior is default -->
-
-    <field name="text" type="text"/>
-    <field name="bool" type="bool"/>
-    <field name="str" type="str"/>
-    <field name="int" type="int"/>
-
-    <dynamicField name="*_dyn_text" type="text"/>
-    <dynamicField name="*_dyn_bool" type="bool"/>
-    <dynamicField name="*_dyn_str" type="str"/>
-    <dynamicField name="*_dyn_int" type="int"/>
-
-    <!-- explicit props on type -->
-    <field name="ft_multi_f" type="multi_f"/>
-    <field name="ft_multi_t" type="multi_t"/>
-    <dynamicField name="*_dyn_str_ft_multi_f" type="multi_f"/>
-    <dynamicField name="*_dyn_str_ft_multi_t" type="multi_t"/>
-
-    <field name="ft_strnorm_f" type="strnorm_f"/>
-    <field name="ft_strnorm_t" type="strnorm_t"/>
-    <dynamicField name="*_dyn_ft_strnorm_f" type="strnorm_f"/>
-    <dynamicField name="*_dyn_ft_strnorm_t" type="strnorm_t"/>
-
-    <field name="ft_txtnorm_f" type="txtnorm_f"/>
-    <field name="ft_txtnorm_t" type="txtnorm_t"/>
-    <dynamicField name="*_dyn_ft_txtnorm_f" type="txtnorm_f"/>
-    <dynamicField name="*_dyn_ft_txtnorm_t" type="txtnorm_t"/>
-
-    <field name="ft_strTfP_f" type="strTfP_f"/>
-    <field name="ft_strTfP_t" type="strTfP_t"/>
-    <dynamicField name="*_dyn_ft_strTfP_f" type="strTfP_f"/>
-    <dynamicField name="*_dyn_ft_strTfP_t" type="strTfP_t"/>
-
-    <field name="ft_txtTfP_f" type="txtTfP_f"/>
-    <field name="ft_txtTfP_t" type="txtTfP_t"/>
-    <dynamicField name="*_dyn_ft_txtTfP_f" type="txtTfP_f"/>
-    <dynamicField name="*_dyn_ft_txtTfP_t" type="txtTfP_t"/>
-
-    <field name="ft_txt_phrase_f" type="txt_phrase_f"/>
-    <field name="ft_txt_phrase_t" type="txt_phrase_t"/>
-    <dynamicField name="*_dyn_ft_txt_phrase_f" type="txt_phrase_f"/>
-    <dynamicField name="*_dyn_ft_txt_phrase_t" type="txt_phrase_t"/>
-
-    <field name="ft_intdvas_t" type="int_dvas_t"/>
-    <field name="ft_intdvas_f" type="int_dvas_f"/>
-    <dynamicField name="*_dyn_ft_intdvas_t" type="int_dvas_t"/>
-    <dynamicField name="*_dyn_ft_intdvas_f" type="int_dvas_f"/>
-
-    <!-- explicit props on field -->
-    <field name="multi_f" type="str" multiValued="false"/>
-    <field name="multi_t" type="str" multiValued="true"/>
-    <dynamicField name="*_dyn_str_multi_f" type="str" multiValued="false"/>
-    <dynamicField name="*_dyn_str_multi_t" type="str" multiValued="true"/>
-
-    <field name="strnorm_f" type="str" omitNorms="false"/>
-    <field name="strnorm_t" type="str" omitNorms="true"/>
-    <dynamicField name="*_dyn_strnorm_f" type="str" omitNorms="false"/>
-    <dynamicField name="*_dyn_strnorm_t" type="str" omitNorms="true"/>
-
-    <field name="txtnorm_f" type="text" omitNorms="false"/>
-    <field name="txtnorm_t" type="text" omitNorms="true"/>
-    <dynamicField name="*_dyn_txtnorm_f" type="text" omitNorms="false"/>
-    <dynamicField name="*_dyn_txtnorm_t" type="text" omitNorms="true"/>
-
-    <field name="strTfP_f" type="str" omitTermFreqAndPositions="false"/>
-    <field name="strTfP_t" type="str" omitTermFreqAndPositions="true"/>
-    <dynamicField name="*_dyn_strTfP_f" type="str" omitTermFreqAndPositions="false"/>
-    <dynamicField name="*_dyn_strTfP_t" type="str" omitTermFreqAndPositions="true"/>
-
-    <field name="txtTfP_f" type="text" omitTermFreqAndPositions="false"/>
-    <field name="txtTfP_t" type="text" omitTermFreqAndPositions="true"/>
-    <dynamicField name="*_dyn_txtTfP_f" type="text" omitTermFreqAndPositions="false"/>
-    <dynamicField name="*_dyn_txtTfP_t" type="text" omitTermFreqAndPositions="true"/>
-
-    <field name="intdvas_t" type="int" useDocValuesAsStored="true"/>
-    <field name="intdvas_f" type="int" useDocValuesAsStored="false"/>
-    <dynamicField name="*_dyn_intdvas_t" type="int" useDocValuesAsStored="true"/>
-    <dynamicField name="*_dyn_intdvas_f" type="int" useDocValuesAsStored="false"/>
-
-  </fields>
+  <!-- all behavior is default -->
+  <fieldType name="text" class="solr.TextField"/>
+  <fieldType name="bool" class="solr.BoolField"/>
+  <fieldType name="str" class="solr.StrField"/>
+  <fieldType name="int" class="solr.TrieIntField"/>
+
+  <!-- explicit props on type -->
+  <fieldType name="multi_f" class="solr.StrField" multiValued="false"/>
+  <fieldType name="multi_t" class="solr.StrField" multiValued="true"/>
+
+  <fieldType name="strnorm_f" class="solr.StrField" omitNorms="false"/>
+  <fieldType name="strnorm_t" class="solr.StrField" omitNorms="true"/>
+  <fieldType name="txtnorm_f" class="solr.TextField" omitNorms="false"/>
+  <fieldType name="txtnorm_t" class="solr.TextField" omitNorms="true"/>
+
+  <fieldType name="strTfP_f" class="solr.StrField" omitTermFreqAndPositions="false"/>
+  <fieldType name="strTfP_t" class="solr.StrField" omitTermFreqAndPositions="true"/>
+  <fieldType name="txtTfP_f" class="solr.TextField" omitTermFreqAndPositions="false"/>
+  <fieldType name="txtTfP_t" class="solr.TextField" omitTermFreqAndPositions="true"/>
+
+  <fieldType name="txt_phrase_f" class="solr.TextField"
+             autoGeneratePhraseQueries="false"/>
+  <fieldType name="txt_phrase_t" class="solr.TextField"
+             autoGeneratePhraseQueries="true"/>
+
+  <fieldType name="int_dvas_t" class="solr.TrieIntField" useDocValuesAsStored="true"/>
+  <fieldType name="int_dvas_f" class="solr.TrieIntField" useDocValuesAsStored="false"/>
+
+  <!-- all behavior is default -->
+
+  <field name="text" type="text"/>
+  <field name="bool" type="bool"/>
+  <field name="str" type="str"/>
+  <field name="int" type="int"/>
+
+  <dynamicField name="*_dyn_text" type="text"/>
+  <dynamicField name="*_dyn_bool" type="bool"/>
+  <dynamicField name="*_dyn_str" type="str"/>
+  <dynamicField name="*_dyn_int" type="int"/>
+
+  <!-- explicit props on type -->
+  <field name="ft_multi_f" type="multi_f"/>
+  <field name="ft_multi_t" type="multi_t"/>
+  <dynamicField name="*_dyn_str_ft_multi_f" type="multi_f"/>
+  <dynamicField name="*_dyn_str_ft_multi_t" type="multi_t"/>
+
+  <field name="ft_strnorm_f" type="strnorm_f"/>
+  <field name="ft_strnorm_t" type="strnorm_t"/>
+  <dynamicField name="*_dyn_ft_strnorm_f" type="strnorm_f"/>
+  <dynamicField name="*_dyn_ft_strnorm_t" type="strnorm_t"/>
+
+  <field name="ft_txtnorm_f" type="txtnorm_f"/>
+  <field name="ft_txtnorm_t" type="txtnorm_t"/>
+  <dynamicField name="*_dyn_ft_txtnorm_f" type="txtnorm_f"/>
+  <dynamicField name="*_dyn_ft_txtnorm_t" type="txtnorm_t"/>
+
+  <field name="ft_strTfP_f" type="strTfP_f"/>
+  <field name="ft_strTfP_t" type="strTfP_t"/>
+  <dynamicField name="*_dyn_ft_strTfP_f" type="strTfP_f"/>
+  <dynamicField name="*_dyn_ft_strTfP_t" type="strTfP_t"/>
+
+  <field name="ft_txtTfP_f" type="txtTfP_f"/>
+  <field name="ft_txtTfP_t" type="txtTfP_t"/>
+  <dynamicField name="*_dyn_ft_txtTfP_f" type="txtTfP_f"/>
+  <dynamicField name="*_dyn_ft_txtTfP_t" type="txtTfP_t"/>
+
+  <field name="ft_txt_phrase_f" type="txt_phrase_f"/>
+  <field name="ft_txt_phrase_t" type="txt_phrase_t"/>
+  <dynamicField name="*_dyn_ft_txt_phrase_f" type="txt_phrase_f"/>
+  <dynamicField name="*_dyn_ft_txt_phrase_t" type="txt_phrase_t"/>
+
+  <field name="ft_intdvas_t" type="int_dvas_t"/>
+  <field name="ft_intdvas_f" type="int_dvas_f"/>
+  <dynamicField name="*_dyn_ft_intdvas_t" type="int_dvas_t"/>
+  <dynamicField name="*_dyn_ft_intdvas_f" type="int_dvas_f"/>
+
+  <!-- explicit props on field -->
+  <field name="multi_f" type="str" multiValued="false"/>
+  <field name="multi_t" type="str" multiValued="true"/>
+  <dynamicField name="*_dyn_str_multi_f" type="str" multiValued="false"/>
+  <dynamicField name="*_dyn_str_multi_t" type="str" multiValued="true"/>
+
+  <field name="strnorm_f" type="str" omitNorms="false"/>
+  <field name="strnorm_t" type="str" omitNorms="true"/>
+  <dynamicField name="*_dyn_strnorm_f" type="str" omitNorms="false"/>
+  <dynamicField name="*_dyn_strnorm_t" type="str" omitNorms="true"/>
+
+  <field name="txtnorm_f" type="text" omitNorms="false"/>
+  <field name="txtnorm_t" type="text" omitNorms="true"/>
+  <dynamicField name="*_dyn_txtnorm_f" type="text" omitNorms="false"/>
+  <dynamicField name="*_dyn_txtnorm_t" type="text" omitNorms="true"/>
+
+  <field name="strTfP_f" type="str" omitTermFreqAndPositions="false"/>
+  <field name="strTfP_t" type="str" omitTermFreqAndPositions="true"/>
+  <dynamicField name="*_dyn_strTfP_f" type="str" omitTermFreqAndPositions="false"/>
+  <dynamicField name="*_dyn_strTfP_t" type="str" omitTermFreqAndPositions="true"/>
+
+  <field name="txtTfP_f" type="text" omitTermFreqAndPositions="false"/>
+  <field name="txtTfP_t" type="text" omitTermFreqAndPositions="true"/>
+  <dynamicField name="*_dyn_txtTfP_f" type="text" omitTermFreqAndPositions="false"/>
+  <dynamicField name="*_dyn_txtTfP_t" type="text" omitTermFreqAndPositions="true"/>
+
+  <field name="intdvas_t" type="int" useDocValuesAsStored="true"/>
+  <field name="intdvas_f" type="int" useDocValuesAsStored="false"/>
+  <dynamicField name="*_dyn_intdvas_t" type="int" useDocValuesAsStored="true"/>
+  <dynamicField name="*_dyn_intdvas_f" type="int" useDocValuesAsStored="false"/>
+
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-binaryfield.xml b/solr/core/src/test-files/solr/collection1/conf/schema-binaryfield.xml
index fcf7656..eb33896 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-binaryfield.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-binaryfield.xml
@@ -26,58 +26,52 @@
   -->
 
 <schema name="test" version="1.2">
-  <types>
 
-    <!-- field type definitions... note that the "name" attribute is
-         just a label to be used by field definitions.  The "class"
-         attribute and any other attributes determine the real type and
-         behavior of the fieldType.
-      -->
-
-    <!--
-      Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
-    -->
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
-
-    <!--
-     Numeric field types that index each value at various levels of precision
-     to accelerate range queries when the number of values between the range
-     endpoints is large. See the javadoc for LegacyNumericRangeQuery for internal
-     implementation details.
-
-     Smaller precisionStep values (specified in bits) will lead to more tokens
-     indexed per value, slightly larger index size, and faster range queries.
-     A precisionStep of 0 disables indexing at different precision levels.
+  <!-- field type definitions... note that the "name" attribute is
+       just a label to be used by field definitions.  The "class"
+       attribute and any other attributes determine the real type and
+       behavior of the fieldType.
     -->
-    <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
-
 
-    <fieldType name="binary" class="solr.BinaryField"/>
-    <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+  <!--
+    Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
+  -->
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
+
+  <!--
+   Numeric field types that index each value at various levels of precision
+   to accelerate range queries when the number of values between the range
+   endpoints is large. See the javadoc for LegacyNumericRangeQuery for internal
+   implementation details.
+
+   Smaller precisionStep values (specified in bits) will lead to more tokens
+   indexed per value, slightly larger index size, and faster range queries.
+   A precisionStep of 0 disables indexing at different precision levels.
+  -->
+  <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
 
-    <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
-         seconds part (.999) is optional.
-      -->
-    <fieldType name="date" class="solr.TrieDateField" sortMissingLast="true"/>
 
+  <fieldType name="binary" class="solr.BinaryField"/>
+  <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
 
+  <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
+       seconds part (.999) is optional.
+    -->
+  <fieldType name="date" class="solr.TrieDateField" sortMissingLast="true"/>
 
- </types>
 
- <fields>
-   <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="true"/>
-   <field name="data" type="binary" stored="true"/>
+  <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="true"/>
+  <field name="data" type="binary" stored="true"/>
 
- </fields>
 
- <uniqueKey>id</uniqueKey>
+  <uniqueKey>id</uniqueKey>
 
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-blockjoinfacetcomponent.xml b/solr/core/src/test-files/solr/collection1/conf/schema-blockjoinfacetcomponent.xml
index 5c30012..9ea5ec7 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-blockjoinfacetcomponent.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-blockjoinfacetcomponent.xml
@@ -17,29 +17,24 @@
   -->
 
 <schema name="test" version="1.0">
-  <types>
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldtype name="string" class="solr.StrField" sortMissingLast="true"/>
-  </types>
-
- 
-  <fields>
-    <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
-    <field name="_version_" type="long" indexed="true" stored="true" multiValued="false"/>
-    <field name="_root_" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
-
-    <field name="name" type="string" indexed="true" stored="true"/>
-    <dynamicField name="*_s" type="string" indexed="true" stored="true" multiValued="false"/>
-
-    <!-- facet docValues fields -->
-    <dynamicField name="*_s_single" type="string" indexed="true" stored="true" docValues="true" multiValued="false"/>
-    <dynamicField name="*_s_multi" type="string" indexed="true" stored="true" docValues="true" multiValued="true"/>
-    <dynamicField name="*_i_multi" type="int" indexed="true" stored="true" docValues="true" multiValued="true"/>
-    <dynamicField name="*_f_multi" type="float" indexed="true" stored="true" docValues="true"  multiValued="true"/>
-
-  </fields>
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldtype name="string" class="solr.StrField" sortMissingLast="true"/>
+
+  <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="_version_" type="long" indexed="true" stored="true" multiValued="false"/>
+  <field name="_root_" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
+
+  <field name="name" type="string" indexed="true" stored="true"/>
+  <dynamicField name="*_s" type="string" indexed="true" stored="true" multiValued="false"/>
+
+  <!-- facet docValues fields -->
+  <dynamicField name="*_s_single" type="string" indexed="true" stored="true" docValues="true" multiValued="false"/>
+  <dynamicField name="*_s_multi" type="string" indexed="true" stored="true" docValues="true" multiValued="true"/>
+  <dynamicField name="*_i_multi" type="int" indexed="true" stored="true" docValues="true" multiValued="true"/>
+  <dynamicField name="*_f_multi" type="float" indexed="true" stored="true" docValues="true" multiValued="true"/>
+
 
   <defaultSearchField>name</defaultSearchField>
   <uniqueKey>id</uniqueKey>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-bm25.xml b/solr/core/src/test-files/solr/collection1/conf/schema-bm25.xml
index 8673deb..ad76b6e 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-bm25.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-bm25.xml
@@ -19,33 +19,29 @@
 <!-- Test schema file for BM25SimilarityFactory -->
 
 <schema name="test" version="1.0">
-  <types>
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    
-    <!-- default parameters -->
-    <fieldType name="text" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
-      <similarity class="solr.BM25SimilarityFactory"/>
-    </fieldType>
-    
-    <!-- with parameters -->
-    <fieldType name="text_params" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
-      <similarity class="solr.BM25SimilarityFactory">
-        <float name="k1">1.2</float>
-        <float name="b">0.76</float>
-      </similarity>
-    </fieldType>
-   
-  </types>
-
-  <fields>
-    <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
-    <field name="text" type="text" indexed="true" stored="false"/>
-    <field name="text_params" type="text_params" indexed="true" stored="false"/>
-  </fields>
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+
+  <!-- default parameters -->
+  <fieldType name="text" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
+    <similarity class="solr.BM25SimilarityFactory"/>
+  </fieldType>
+
+  <!-- with parameters -->
+  <fieldType name="text_params" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
+    <similarity class="solr.BM25SimilarityFactory">
+      <float name="k1">1.2</float>
+      <float name="b">0.76</float>
+    </similarity>
+  </fieldType>
+
+
+  <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="text" type="text" indexed="true" stored="false"/>
+  <field name="text_params" type="text_params" indexed="true" stored="false"/>
 
   <defaultSearchField>text</defaultSearchField>
   <uniqueKey>id</uniqueKey>
-  
+
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-charfilters.xml b/solr/core/src/test-files/solr/collection1/conf/schema-charfilters.xml
index 5eaab1f..852c9cf 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-charfilters.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-charfilters.xml
@@ -16,35 +16,31 @@
   -->
 
 <schema name="test" version="1.0">
-  <types>
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="4" omitNorms="true" positionIncrementGap="0"/>
-    <!--  charfilter only at query-time -->
-    <fieldType name="text" class="solr.TextField">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <charFilter class="solr.MockCharFilterFactory" remainder="7"/>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-    <!--  charfilter only at index-time -->
-    <fieldType name="text2" class="solr.TextField">
-      <analyzer type="index">
-        <charFilter class="solr.MockCharFilterFactory" remainder="7"/>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-  </types>
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="4" omitNorms="true" positionIncrementGap="0"/>
+  <!--  charfilter only at query-time -->
+  <fieldType name="text" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <charFilter class="solr.MockCharFilterFactory" remainder="7"/>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <!--  charfilter only at index-time -->
+  <fieldType name="text2" class="solr.TextField">
+    <analyzer type="index">
+      <charFilter class="solr.MockCharFilterFactory" remainder="7"/>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
 
-  <fields>
-    <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="true"/>
-    <field name="content" type="text" indexed="true" stored="true"/>
-    <field name="content2" type="text2" indexed="true" stored="true"/>
-  </fields>
+  <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="true"/>
+  <field name="content" type="text" indexed="true" stored="true"/>
+  <field name="content2" type="text2" indexed="true" stored="true"/>
 
   <defaultSearchField>content</defaultSearchField>
   <uniqueKey>id</uniqueKey>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-class-name-shortening-on-serialization.xml b/solr/core/src/test-files/solr/collection1/conf/schema-class-name-shortening-on-serialization.xml
index 82a6709..55f1213 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-class-name-shortening-on-serialization.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-class-name-shortening-on-serialization.xml
@@ -16,29 +16,25 @@
  limitations under the License.
 -->
 <schema name="test-class-name-shortening-on-serialization" version="1.6">
-  <types>
-    <fieldType name="fullClassNames" class="org.apache.solr.schema.TextField">
-      <analyzer>
-        <charFilter class="org.apache.solr.analysis.MockCharFilterFactory" remainder="0"/>
-        <tokenizer class="org.apache.solr.analysis.MockTokenizerFactory"/>
-        <filter class="org.apache.solr.analysis.MockTokenFilterFactory" stopset="empty"/>
-      </analyzer>
-      <similarity class="org.apache.lucene.misc.SweetSpotSimilarity"/>
-    </fieldType>
-    <fieldType name="shortenedClassNames" class="solr.TextField">
-      <analyzer>
-        <charFilter class="solr.MockCharFilterFactory" remainder="0"/>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.MockTokenFilterFactory" stopset="empty"/>
-      </analyzer>
-      <similarity class="solr.SweetSpotSimilarityFactory"/>
-    </fieldType>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
-  </types>
-  <fields>
-    <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="true"/>
-    <field name="signatureField" type="string" indexed="true" stored="false"/>
-  </fields>
+  <fieldType name="fullClassNames" class="org.apache.solr.schema.TextField">
+    <analyzer>
+      <charFilter class="org.apache.solr.analysis.MockCharFilterFactory" remainder="0"/>
+      <tokenizer class="org.apache.solr.analysis.MockTokenizerFactory"/>
+      <filter class="org.apache.solr.analysis.MockTokenFilterFactory" stopset="empty"/>
+    </analyzer>
+    <similarity class="org.apache.lucene.misc.SweetSpotSimilarity"/>
+  </fieldType>
+  <fieldType name="shortenedClassNames" class="solr.TextField">
+    <analyzer>
+      <charFilter class="solr.MockCharFilterFactory" remainder="0"/>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.MockTokenFilterFactory" stopset="empty"/>
+    </analyzer>
+    <similarity class="solr.SweetSpotSimilarityFactory"/>
+  </fieldType>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+  <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="true"/>
+  <field name="signatureField" type="string" indexed="true" stored="false"/>
 
   <!--
       Even though SchemaSimilarityFactory is the current implicit default in IndexSchema, we
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-collate-dv.xml b/solr/core/src/test-files/solr/collection1/conf/schema-collate-dv.xml
index 85ed89b..20d2da0 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-collate-dv.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-collate-dv.xml
@@ -19,35 +19,33 @@
 <!-- Test schema file for CollationField -->
 
 <schema name="test" version="1.0">
-  <types>
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-
-    <!-- basic text field -->
-    <fieldType name="text" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    
-    <fieldType name="sort_ar_t"       class="solr.CollationField" language="ar"/>
-    <fieldType name="sort_de_t"       class="solr.CollationField" language="de" strength="primary"/>
-    <fieldType name="sort_tr_canon_t" class="solr.CollationField" language="tr" strength="primary"   decomposition="canonical"/>
-    <fieldType name="sort_zh_full_t"  class="solr.CollationField" language="zh" strength="identical" decomposition="full"/>
-    <fieldType name="sort_da_t"       class="solr.CollationField" language="da" strength="primary"/>
-    <fieldType name="sort_custom_t"   class="solr.CollationField" custom="customrules.dat" strength="primary"/>
-  </types>
-
-  <fields>
-    <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
-    <field name="text" type="text" indexed="true" stored="false"/>
-    <field name="sort_ar"       type="sort_ar_t"       indexed="false" stored="false" multiValued="false" docValues="true"/>
-    <field name="sort_de"       type="sort_de_t"       indexed="false" stored="false" multiValued="false" docValues="true"/>
-    <field name="sort_tr_canon" type="sort_tr_canon_t" indexed="false" stored="false" multiValued="true" docValues="true"/>
-    <field name="sort_zh_full"  type="sort_zh_full_t"  indexed="false" stored="false" multiValued="false" docValues="true"/>
-    <field name="sort_da"       type="sort_da_t"       indexed="false" stored="false" multiValued="false" docValues="true"/>
-    <field name="sort_custom"   type="sort_custom_t"   indexed="false" stored="false" multiValued="true" docValues="true"/>
-  </fields>
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+
+  <!-- basic text field -->
+  <fieldType name="text" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="sort_ar_t" class="solr.CollationField" language="ar"/>
+  <fieldType name="sort_de_t" class="solr.CollationField" language="de" strength="primary"/>
+  <fieldType name="sort_tr_canon_t" class="solr.CollationField" language="tr" strength="primary"
+             decomposition="canonical"/>
+  <fieldType name="sort_zh_full_t" class="solr.CollationField" language="zh" strength="identical" decomposition="full"/>
+  <fieldType name="sort_da_t" class="solr.CollationField" language="da" strength="primary"/>
+  <fieldType name="sort_custom_t" class="solr.CollationField" custom="customrules.dat" strength="primary"/>
+
+  <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="text" type="text" indexed="true" stored="false"/>
+  <field name="sort_ar" type="sort_ar_t" indexed="false" stored="false" multiValued="false" docValues="true"/>
+  <field name="sort_de" type="sort_de_t" indexed="false" stored="false" multiValued="false" docValues="true"/>
+  <field name="sort_tr_canon" type="sort_tr_canon_t" indexed="false" stored="false" multiValued="true"
+         docValues="true"/>
+  <field name="sort_zh_full" type="sort_zh_full_t" indexed="false" stored="false" multiValued="false" docValues="true"/>
+  <field name="sort_da" type="sort_da_t" indexed="false" stored="false" multiValued="false" docValues="true"/>
+  <field name="sort_custom" type="sort_custom_t" indexed="false" stored="false" multiValued="true" docValues="true"/>
 
   <defaultSearchField>text</defaultSearchField>
   <uniqueKey>id</uniqueKey>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-collate.xml b/solr/core/src/test-files/solr/collection1/conf/schema-collate.xml
index 2b3dbdf..5167134 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-collate.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-collate.xml
@@ -19,35 +19,32 @@
 <!-- Test schema file for CollationField -->
 
 <schema name="test" version="1.0">
-  <types>
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-
-    <!-- basic text field -->
-    <fieldType name="text" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    
-    <fieldType name="sort_ar_t"       class="solr.CollationField" language="ar"/>
-    <fieldType name="sort_de_t"       class="solr.CollationField" language="de" strength="primary"/>
-    <fieldType name="sort_tr_canon_t" class="solr.CollationField" language="tr" strength="primary"   decomposition="canonical"/>
-    <fieldType name="sort_zh_full_t"  class="solr.CollationField" language="zh" strength="identical" decomposition="full"/>
-    <fieldType name="sort_da_t"       class="solr.CollationField" language="da" strength="primary"/>
-    <fieldType name="sort_custom_t"   class="solr.CollationField" custom="customrules.dat" strength="primary"/>
-  </types>
-
-  <fields>
-    <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
-    <field name="text" type="text" indexed="true" stored="false"/>
-    <field name="sort_ar"       type="sort_ar_t"       indexed="true" stored="false" multiValued="false"/>
-    <field name="sort_de"       type="sort_de_t"       indexed="true" stored="false" multiValued="false"/>
-    <field name="sort_tr_canon" type="sort_tr_canon_t" indexed="true" stored="false" multiValued="false"/>
-    <field name="sort_zh_full"  type="sort_zh_full_t"  indexed="true" stored="false" multiValued="false"/>
-    <field name="sort_da"       type="sort_da_t"       indexed="true" stored="false" multiValued="false"/>
-    <field name="sort_custom"   type="sort_custom_t"   indexed="true" stored="false" multiValued="false"/>
-  </fields>
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+
+  <!-- basic text field -->
+  <fieldType name="text" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="sort_ar_t" class="solr.CollationField" language="ar"/>
+  <fieldType name="sort_de_t" class="solr.CollationField" language="de" strength="primary"/>
+  <fieldType name="sort_tr_canon_t" class="solr.CollationField" language="tr" strength="primary"
+             decomposition="canonical"/>
+  <fieldType name="sort_zh_full_t" class="solr.CollationField" language="zh" strength="identical" decomposition="full"/>
+  <fieldType name="sort_da_t" class="solr.CollationField" language="da" strength="primary"/>
+  <fieldType name="sort_custom_t" class="solr.CollationField" custom="customrules.dat" strength="primary"/>
+
+  <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="text" type="text" indexed="true" stored="false"/>
+  <field name="sort_ar" type="sort_ar_t" indexed="true" stored="false" multiValued="false"/>
+  <field name="sort_de" type="sort_de_t" indexed="true" stored="false" multiValued="false"/>
+  <field name="sort_tr_canon" type="sort_tr_canon_t" indexed="true" stored="false" multiValued="false"/>
+  <field name="sort_zh_full" type="sort_zh_full_t" indexed="true" stored="false" multiValued="false"/>
+  <field name="sort_da" type="sort_da_t" indexed="true" stored="false" multiValued="false"/>
+  <field name="sort_custom" type="sort_custom_t" indexed="true" stored="false" multiValued="false"/>
 
   <defaultSearchField>text</defaultSearchField>
   <uniqueKey>id</uniqueKey>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-complex-phrase.xml b/solr/core/src/test-files/solr/collection1/conf/schema-complex-phrase.xml
index 272513a..caf8778 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-complex-phrase.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-complex-phrase.xml
@@ -16,21 +16,17 @@
  limitations under the License.
 -->
 <schema name="test" version="1.2">
-  <types>
 
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
 
-    <fieldType name="nametext" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
-    </fieldType>
-  </types>
+  <fieldType name="nametext" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
+  </fieldType>
 
-  <fields>
-    <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="true"/>
-    <field name="name" type="nametext" indexed="true" stored="true"/>
-    <field name="title" type="nametext" indexed="true" stored="true"/>
-    <field name="text" type="nametext" indexed="true" stored="true"/>
-  </fields>
+  <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="true"/>
+  <field name="name" type="nametext" indexed="true" stored="true"/>
+  <field name="title" type="nametext" indexed="true" stored="true"/>
+  <field name="text" type="nametext" indexed="true" stored="true"/>
 
   <defaultSearchField>text</defaultSearchField>
   <solrQueryParser defaultOperator="AND"/>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-copyfield-test.xml b/solr/core/src/test-files/solr/collection1/conf/schema-copyfield-test.xml
index f24570a..47ddeb2 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-copyfield-test.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-copyfield-test.xml
@@ -26,437 +26,450 @@
   -->
 
 <schema name="test" version="1.0">
-  <types>
 
-    <!-- field type definitions... note that the "name" attribute is
-         just a label to be used by field definitions.  The "class"
-         attribute and any other attributes determine the real type and
-         behavior of the fieldType.
-      -->
+  <!-- field type definitions... note that the "name" attribute is
+       just a label to be used by field definitions.  The "class"
+       attribute and any other attributes determine the real type and
+       behavior of the fieldType.
+    -->
+
+  <!--
+    Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
+  -->
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
+
+  <!--
+   Numeric field types that index each value at various levels of precision
+   to accelerate range queries when the number of values between the range
+   endpoints is large. See the javadoc for LegacyNumericRangeQuery for internal
+   implementation details.
+
+   Smaller precisionStep values (specified in bits) will lead to more tokens
+   indexed per value, slightly larger index size, and faster range queries.
+   A precisionStep of 0 disables indexing at different precision levels.
+  -->
+  <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
+
+  <!-- Field type demonstrating an Analyzer failure -->
+  <fieldType name="failtype1" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0"
+              catenateNumbers="0" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Demonstrating ignoreCaseChange -->
+  <fieldType name="wdf_nocase" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <!-- HighlitText optimizes storage for (long) columns which will be highlit -->
+  <fieldType name="highlittext" class="solr.TextField" compressThreshold="345"/>
 
-    <!--
-      Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
+  <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+
+  <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
+       seconds part (.999) is optional.
     -->
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
-
-    <!--
-     Numeric field types that index each value at various levels of precision
-     to accelerate range queries when the number of values between the range
-     endpoints is large. See the javadoc for LegacyNumericRangeQuery for internal
-     implementation details.
-
-     Smaller precisionStep values (specified in bits) will lead to more tokens
-     indexed per value, slightly larger index size, and faster range queries.
-     A precisionStep of 0 disables indexing at different precision levels.
+  <fieldType name="date" class="solr.TrieDateField" sortMissingLast="true"/>
+
+  <!-- solr.TextField allows the specification of custom
+       text analyzers specified as a tokenizer and a list
+       of token filters.
     -->
-    <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
-
-    <!-- Field type demonstrating an Analyzer failure -->
-    <fieldType name="failtype1" class="solr.TextField">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- Demonstrating ignoreCaseChange -->
-    <fieldType name="wdf_nocase" class="solr.TextField">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <!-- HighlitText optimizes storage for (long) columns which will be highlit -->
-    <fieldType name="highlittext" class="solr.TextField" compressThreshold="345" />
-
-    <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
-
-    <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
-         seconds part (.999) is optional.
-      -->
-    <fieldType name="date" class="solr.TrieDateField" sortMissingLast="true"/>
-
-    <!-- solr.TextField allows the specification of custom
-         text analyzers specified as a tokenizer and a list
-         of token filters.
-      -->
-    <fieldType name="text" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <fieldType name="nametext" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.core.WhitespaceAnalyzer"/>
-    </fieldType>
-
-    <fieldType name="teststop" class="solr.TextField">
-       <analyzer>
-        <tokenizer class="solr.LowerCaseTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-        <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- fieldTypes in this section isolate tokenizers and tokenfilters for testing -->
-    <fieldType name="lowertok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.LowerCaseTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="keywordtok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/></analyzer>
-    </fieldType>
-    <fieldType name="standardtok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.StandardTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="lettertok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.LetterTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="whitetok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.MockTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="HTMLstandardtok" class="solr.TextField">
-      <analyzer>
+  <fieldType name="text" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <fieldType name="nametext" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.core.WhitespaceAnalyzer"/>
+  </fieldType>
+
+  <fieldType name="teststop" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LowerCaseTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+      <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- fieldTypes in this section isolate tokenizers and tokenfilters for testing -->
+  <fieldType name="lowertok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LowerCaseTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="keywordtok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="standardtok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="lettertok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LetterTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="whitetok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="HTMLstandardtok" class="solr.TextField">
+    <analyzer>
       <charFilter class="solr.HTMLStripCharFilterFactory"/>
       <tokenizer class="solr.StandardTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="HTMLwhitetok" class="solr.TextField">
-      <analyzer>
+    </analyzer>
+  </fieldType>
+  <fieldType name="HTMLwhitetok" class="solr.TextField">
+    <analyzer>
       <charFilter class="solr.HTMLStripCharFilterFactory"/>
       <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="standardtokfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="standardfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="lowerfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="patternreplacefilt" class="solr.TextField">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
-        <filter class="solr.PatternReplaceFilterFactory"
-                pattern="([^a-zA-Z])" replacement="_" replace="all"
-        />
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="porterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <!-- fieldType name="snowballfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.SnowballPorterFilterFactory"/>
-      </analyzer>
-    </fieldType -->
-    <fieldType name="engporterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="custengporterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="stopfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="custstopfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="lengthfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LengthFilterFactory" min="2" max="5"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="subword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.StopFilterFactory"/>
-          <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.StopFilterFactory"/>
-          <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- more flexible in matching skus, but more chance of a false match -->
-    <fieldType name="skutype1" class="solr.TextField">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- less flexible in matching skus, but less chance of a false match -->
-    <fieldType name="skutype2" class="solr.TextField">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- less flexible in matching skus, but less chance of a false match -->
-    <fieldType name="syn" class="solr.TextField">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Demonstrates How RemoveDuplicatesTokenFilter makes stemmed
-         synonyms "better"
-      -->
-    <fieldType name="dedup" class="solr.TextField">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.SynonymFilterFactory"
-                  synonyms="synonyms.txt" expand="true" />
-          <filter class="solr.PorterStemFilterFactory"/>
-          <filter class="solr.RemoveDuplicatesTokenFilterFactory" />
-      </analyzer>
-    </fieldType>
-
-    <fieldType  name="unstored" class="solr.StrField" indexed="true" stored="false"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="standardtokfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="standardfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="lowerfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="patternreplacefilt" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+      <filter class="solr.PatternReplaceFilterFactory"
+              pattern="([^a-zA-Z])" replacement="_" replace="all"
+      />
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="porterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <!-- fieldType name="snowballfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SnowballPorterFilterFactory"/>
+    </analyzer>
+  </fieldType -->
+  <fieldType name="engporterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="custengporterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="stopfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="custstopfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="lengthfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LengthFilterFactory" min="2" max="5"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="subword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- more flexible in matching skus, but more chance of a false match -->
+  <fieldType name="skutype1" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- less flexible in matching skus, but less chance of a false match -->
+  <fieldType name="skutype2" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- less flexible in matching skus, but less chance of a false match -->
+  <fieldType name="syn" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Demonstrates How RemoveDuplicatesTokenFilter makes stemmed
+       synonyms "better"
+    -->
+  <fieldType name="dedup" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory"
+              synonyms="synonyms.txt" expand="true"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="unstored" class="solr.StrField" indexed="true" stored="false"/>
 
 
   <fieldType name="textgap" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
   </fieldType>
 
- </types>
-
-
- <fields>
-   <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
-   <field name="name" type="nametext" indexed="true" stored="true"/>
-   <field name="text" type="text" indexed="true" stored="false"/>
-   <field name="subject" type="text" indexed="true" stored="true"/>
-   <field name="title" type="nametext" indexed="true" stored="true"/>
-   <field name="weight" type="float" indexed="true" stored="true"/>
-   <field name="bday" type="date" indexed="true" stored="true"/>
-
-   <field name="title_stemmed" type="text" indexed="true" stored="false"/>
-   <field name="title_lettertok" type="lettertok" indexed="true" stored="false"/>
-
-   <field name="syn" type="syn" indexed="true" stored="true"/>
-
-   <!-- to test property inheritance and overriding -->
-   <field name="shouldbeunstored" type="unstored" />
-   <field name="shouldbestored" type="unstored" stored="true"/>
-   <field name="shouldbeunindexed" type="unstored" indexed="false" stored="true"/>
-
-
-   <!-- test different combinations of indexed and stored -->
-   <field name="bind" type="boolean" indexed="true" stored="false"/>
-   <field name="bsto" type="boolean" indexed="false" stored="true"/>
-   <field name="bindsto" type="boolean" indexed="true" stored="true"/>
-   <field name="isto" type="int" indexed="false" stored="true"/>
-   <field name="iind" type="int" indexed="true" stored="false"/>
-   <field name="ssto" type="string" indexed="false" stored="true"/>
-   <field name="sind" type="string" indexed="true" stored="false"/>
-   <field name="sindsto" type="string" indexed="true" stored="true"/>
-
-   <!-- test combinations of term vector settings -->
-   <field name="test_basictv" type="text" termVectors="true"/>
-   <field name="test_notv" type="text" termVectors="false"/>
-   <field name="test_postv" type="text" termVectors="true" termPositions="true"/>
-   <field name="test_offtv" type="text" termVectors="true" termOffsets="true"/>
-   <field name="test_posofftv" type="text" termVectors="true" 
-     termPositions="true" termOffsets="true"/>
-
-   <!-- test highlit field settings -->
-   <field name="test_hlt" type="highlittext" indexed="true"/>
-   <field name="test_hlt_off" type="highlittext" indexed="true"/>
-
-   <!-- fields to test individual tokenizers and tokenfilters -->
-   <field name="teststop" type="teststop" indexed="true" stored="true"/>
-   <field name="lowertok" type="lowertok" indexed="true" stored="true"/>
-   <field name="keywordtok" type="keywordtok" indexed="true" stored="true"/>
-   <field name="standardtok" type="standardtok" indexed="true" stored="true"/>
-   <field name="HTMLstandardtok" type="HTMLstandardtok" indexed="true" stored="true"/>
-   <field name="lettertok" type="lettertok" indexed="true" stored="true"/>
-   <field name="whitetok" type="whitetok" indexed="true" stored="true"/>
-   <field name="HTMLwhitetok" type="HTMLwhitetok" indexed="true" stored="true"/>
-   <field name="standardtokfilt" type="standardtokfilt" indexed="true" stored="true"/>
-   <field name="standardfilt" type="standardfilt" indexed="true" stored="true"/>
-   <field name="lowerfilt" type="lowerfilt" indexed="true" stored="true"/>
-   <field name="patternreplacefilt" type="patternreplacefilt" indexed="true" stored="true"/>
-   <field name="porterfilt" type="porterfilt" indexed="true" stored="true"/>
-   <field name="engporterfilt" type="engporterfilt" indexed="true" stored="true"/>
-   <field name="custengporterfilt" type="custengporterfilt" indexed="true" stored="true"/>
-   <field name="stopfilt" type="stopfilt" indexed="true" stored="true"/>
-   <field name="custstopfilt" type="custstopfilt" indexed="true" stored="true"/>
-   <field name="lengthfilt" type="lengthfilt" indexed="true" stored="true"/>
-   <field name="dedup" type="dedup" indexed="true" stored="true"/>
-   <field name="wdf_nocase" type="wdf_nocase" indexed="true" stored="true"/>
-
-   <field name="numberpartfail" type="failtype1" indexed="true" stored="true"/>
-
-   <field name="nullfirst" type="string" indexed="true" stored="true" sortMissingFirst="true"/>
-
-   <field name="subword" type="subword" indexed="true" stored="true"/>
-   <field name="sku1" type="skutype1" indexed="true" stored="true"/>
-   <field name="sku2" type="skutype2" indexed="true" stored="true"/>
-
-   <field name="textgap" type="textgap" indexed="true" stored="true"/>
-   
-   <field name="timestamp" type="date" indexed="true" stored="true" default="NOW" multiValued="false"/>
-   <field name="multiDefault" type="string" indexed="true" stored="true" default="muLti-Default" multiValued="true"/>
-   <field name="intDefault" type="int" indexed="true" stored="true" default="42" multiValued="false"/>
-   
-   <!-- test maxChars copyField attribute -->
-   <field name="text_fr"  type="text" indexed="true"  stored="true" 
-      termVectors="true" termPositions="true" termOffsets="true"/>
-   <field name="text_en"  type="text" indexed="true"  stored="true" 
-      termVectors="true" termPositions="true" termOffsets="true"/>
-   <field name="highlight"  type="text" indexed="true"  stored="true" 
-      termVectors="true" termPositions="true" termOffsets="true"/>
-   <field name="signatureField" type="string" indexed="true" stored="false"/>
-   
-   <field name="_version_" type="long" indexed="true" stored="true" multiValued="false" />
-
-   
-   <!-- Dynamic field definitions.  If a field name is not found, dynamicFields
-        will be used if the name matches any of the patterns.
-        RESTRICTION: the glob-like pattern in the name attribute must have
-        a "*" only at the start or the end.
-        EXAMPLE:  name="*_i" will match any field ending in _i (like myid_i, z_i)
-        Longer patterns will be matched first.  if equal size patterns
-        both match, the first appearing in the schema will be used.
-   -->
-   <dynamicField name="*_i"  type="int"    indexed="true"  stored="true"/>
-   <dynamicField name="*_s"  type="string"  indexed="true"  stored="true"/>
-   <dynamicField name="*_s1"  type="string"  indexed="true"  stored="true" multiValued="false"/>
-   <dynamicField name="*_l"  type="long"   indexed="true"  stored="true"/>
-   <dynamicField name="*_t"  type="text"    indexed="true"  stored="true"/>
-   <dynamicField name="*_b"  type="boolean" indexed="true"  stored="true"/>
-   <dynamicField name="*_f"  type="float"  indexed="true"  stored="true"/>
-   <dynamicField name="*_d"  type="double" indexed="true"  stored="true"/>
-   <dynamicField name="*_dt" type="date"    indexed="true"  stored="true"/>
-
-   <dynamicField name="*_sI" type="string"  indexed="true"  stored="false"/>
-   <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
-   <dynamicField name="t_*"  type="text"    indexed="true"  stored="true"/>
-   <dynamicField name="tv_*"  type="text" indexed="true"  stored="true" 
-      termVectors="true" termPositions="true" termOffsets="true"/>
-
-   <!-- special fields for dynamic copyField test -->
-   <dynamicField name="dynamic_*" type="string" indexed="true" stored="true"/>
-   <dynamicField name="*_dynamic" type="string" indexed="true" stored="true"/>
-  
-   <!-- for testing to ensure that longer patterns are matched first -->
-   <dynamicField name="*aa"  type="string"  indexed="true" stored="true"/>
-   <dynamicField name="*aaa" type="int" indexed="false" stored="true"/>
-
-   <!-- ignored becuase not stored or indexed -->
-   <dynamicField name="*_ignored" type="text" indexed="false" stored="false"/>
-   
-   <!-- test maxSize copyField attribute -->
-   <dynamicField name="text_*"  type="text" indexed="true"  stored="true" 
-      termVectors="true" termPositions="true" termOffsets="true"/>
-
- </fields>
-
- <defaultSearchField>text</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+
+  <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="name" type="nametext" indexed="true" stored="true"/>
+  <field name="text" type="text" indexed="true" stored="false"/>
+  <field name="subject" type="text" indexed="true" stored="true"/>
+  <field name="title" type="nametext" indexed="true" stored="true"/>
+  <field name="weight" type="float" indexed="true" stored="true"/>
+  <field name="bday" type="date" indexed="true" stored="true"/>
+
+  <field name="title_stemmed" type="text" indexed="true" stored="false"/>
+  <field name="title_lettertok" type="lettertok" indexed="true" stored="false"/>
+
+  <field name="syn" type="syn" indexed="true" stored="true"/>
+
+  <!-- to test property inheritance and overriding -->
+  <field name="shouldbeunstored" type="unstored"/>
+  <field name="shouldbestored" type="unstored" stored="true"/>
+  <field name="shouldbeunindexed" type="unstored" indexed="false" stored="true"/>
+
+
+  <!-- test different combinations of indexed and stored -->
+  <field name="bind" type="boolean" indexed="true" stored="false"/>
+  <field name="bsto" type="boolean" indexed="false" stored="true"/>
+  <field name="bindsto" type="boolean" indexed="true" stored="true"/>
+  <field name="isto" type="int" indexed="false" stored="true"/>
+  <field name="iind" type="int" indexed="true" stored="false"/>
+  <field name="ssto" type="string" indexed="false" stored="true"/>
+  <field name="sind" type="string" indexed="true" stored="false"/>
+  <field name="sindsto" type="string" indexed="true" stored="true"/>
+
+  <!-- test combinations of term vector settings -->
+  <field name="test_basictv" type="text" termVectors="true"/>
+  <field name="test_notv" type="text" termVectors="false"/>
+  <field name="test_postv" type="text" termVectors="true" termPositions="true"/>
+  <field name="test_offtv" type="text" termVectors="true" termOffsets="true"/>
+  <field name="test_posofftv" type="text" termVectors="true"
+         termPositions="true" termOffsets="true"/>
+
+  <!-- test highlit field settings -->
+  <field name="test_hlt" type="highlittext" indexed="true"/>
+  <field name="test_hlt_off" type="highlittext" indexed="true"/>
+
+  <!-- fields to test individual tokenizers and tokenfilters -->
+  <field name="teststop" type="teststop" indexed="true" stored="true"/>
+  <field name="lowertok" type="lowertok" indexed="true" stored="true"/>
+  <field name="keywordtok" type="keywordtok" indexed="true" stored="true"/>
+  <field name="standardtok" type="standardtok" indexed="true" stored="true"/>
+  <field name="HTMLstandardtok" type="HTMLstandardtok" indexed="true" stored="true"/>
+  <field name="lettertok" type="lettertok" indexed="true" stored="true"/>
+  <field name="whitetok" type="whitetok" indexed="true" stored="true"/>
+  <field name="HTMLwhitetok" type="HTMLwhitetok" indexed="true" stored="true"/>
+  <field name="standardtokfilt" type="standardtokfilt" indexed="true" stored="true"/>
+  <field name="standardfilt" type="standardfilt" indexed="true" stored="true"/>
+  <field name="lowerfilt" type="lowerfilt" indexed="true" stored="true"/>
+  <field name="patternreplacefilt" type="patternreplacefilt" indexed="true" stored="true"/>
+  <field name="porterfilt" type="porterfilt" indexed="true" stored="true"/>
+  <field name="engporterfilt" type="engporterfilt" indexed="true" stored="true"/>
+  <field name="custengporterfilt" type="custengporterfilt" indexed="true" stored="true"/>
+  <field name="stopfilt" type="stopfilt" indexed="true" stored="true"/>
+  <field name="custstopfilt" type="custstopfilt" indexed="true" stored="true"/>
+  <field name="lengthfilt" type="lengthfilt" indexed="true" stored="true"/>
+  <field name="dedup" type="dedup" indexed="true" stored="true"/>
+  <field name="wdf_nocase" type="wdf_nocase" indexed="true" stored="true"/>
+
+  <field name="numberpartfail" type="failtype1" indexed="true" stored="true"/>
+
+  <field name="nullfirst" type="string" indexed="true" stored="true" sortMissingFirst="true"/>
+
+  <field name="subword" type="subword" indexed="true" stored="true"/>
+  <field name="sku1" type="skutype1" indexed="true" stored="true"/>
+  <field name="sku2" type="skutype2" indexed="true" stored="true"/>
+
+  <field name="textgap" type="textgap" indexed="true" stored="true"/>
+
+  <field name="timestamp" type="date" indexed="true" stored="true" default="NOW" multiValued="false"/>
+  <field name="multiDefault" type="string" indexed="true" stored="true" default="muLti-Default" multiValued="true"/>
+  <field name="intDefault" type="int" indexed="true" stored="true" default="42" multiValued="false"/>
+
+  <!-- test maxChars copyField attribute -->
+  <field name="text_fr" type="text" indexed="true" stored="true"
+         termVectors="true" termPositions="true" termOffsets="true"/>
+  <field name="text_en" type="text" indexed="true" stored="true"
+         termVectors="true" termPositions="true" termOffsets="true"/>
+  <field name="highlight" type="text" indexed="true" stored="true"
+         termVectors="true" termPositions="true" termOffsets="true"/>
+  <field name="signatureField" type="string" indexed="true" stored="false"/>
+
+  <field name="_version_" type="long" indexed="true" stored="true" multiValued="false"/>
+
+
+  <!-- Dynamic field definitions.  If a field name is not found, dynamicFields
+       will be used if the name matches any of the patterns.
+       RESTRICTION: the glob-like pattern in the name attribute must have
+       a "*" only at the start or the end.
+       EXAMPLE:  name="*_i" will match any field ending in _i (like myid_i, z_i)
+       Longer patterns will be matched first.  if equal size patterns
+       both match, the first appearing in the schema will be used.
+  -->
+  <dynamicField name="*_i" type="int" indexed="true" stored="true"/>
+  <dynamicField name="*_s" type="string" indexed="true" stored="true"/>
+  <dynamicField name="*_s1" type="string" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_l" type="long" indexed="true" stored="true"/>
+  <dynamicField name="*_t" type="text" indexed="true" stored="true"/>
+  <dynamicField name="*_b" type="boolean" indexed="true" stored="true"/>
+  <dynamicField name="*_f" type="float" indexed="true" stored="true"/>
+  <dynamicField name="*_d" type="double" indexed="true" stored="true"/>
+  <dynamicField name="*_dt" type="date" indexed="true" stored="true"/>
+
+  <dynamicField name="*_sI" type="string" indexed="true" stored="false"/>
+  <dynamicField name="*_sS" type="string" indexed="false" stored="true"/>
+  <dynamicField name="t_*" type="text" indexed="true" stored="true"/>
+  <dynamicField name="tv_*" type="text" indexed="true" stored="true"
+                termVectors="true" termPositions="true" termOffsets="true"/>
+
+  <!-- special fields for dynamic copyField test -->
+  <dynamicField name="dynamic_*" type="string" indexed="true" stored="true"/>
+  <dynamicField name="*_dynamic" type="string" indexed="true" stored="true"/>
+
+  <!-- for testing to ensure that longer patterns are matched first -->
+  <dynamicField name="*aa" type="string" indexed="true" stored="true"/>
+  <dynamicField name="*aaa" type="int" indexed="false" stored="true"/>
+
+  <!-- ignored becuase not stored or indexed -->
+  <dynamicField name="*_ignored" type="text" indexed="false" stored="false"/>
+
+  <!-- test maxSize copyField attribute -->
+  <dynamicField name="text_*" type="text" indexed="true" stored="true"
+                termVectors="true" termPositions="true" termOffsets="true"/>
+
+
+  <defaultSearchField>text</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 
   <!-- copyField commands copy one field to another at the time a document
         is added to the index.  It's used either to index the same field different
         ways, or to add multiple fields to the same field for easier/faster searching.
    -->
-   <copyField source="title" dest="title_stemmed"/>
-   <copyField source="title" dest="title_lettertok"/>
-
-   <copyField source="title" dest="text"/>
-   <copyField source="subject" dest="text"/>
- 
-   <copyField source="*_t" dest="text"/>
-   
-   <!-- dynamic destination -->
-   <copyField source="*_dynamic" dest="dynamic_*"/>
-   
-   <!-- test maxSize copyField attribute -->
-   <copyField source="text_fr" dest="highlight" maxChars="25" />
-   <copyField source="text_en" dest="highlight" maxChars="25" />
-   <copyField source="text_*" dest="highlight" maxChars="25" />
-
-   <!-- test source glob matching multiple explicit fields: sku1 and sku2 -->
-   <copyField source="sku*" dest="text"/>
-   <copyField source="sku*" dest="*_s"/>
-   <copyField source="sku*" dest="*_dest_sub_s"/>
-   <copyField source="sku*" dest="dest_sub_no_ast_s"/>
-
-   <!-- test source glob that doesn't match any explicit or dynamic field -->
-   <copyField source="testing123_*" dest="text"/>
-  
-   <copyField source="*" dest="catchall_t"/>
+  <copyField source="title" dest="title_stemmed"/>
+  <copyField source="title" dest="title_lettertok"/>
+
+  <copyField source="title" dest="text"/>
+  <copyField source="subject" dest="text"/>
+
+  <copyField source="*_t" dest="text"/>
+
+  <!-- dynamic destination -->
+  <copyField source="*_dynamic" dest="dynamic_*"/>
+
+  <!-- test maxSize copyField attribute -->
+  <copyField source="text_fr" dest="highlight" maxChars="25"/>
+  <copyField source="text_en" dest="highlight" maxChars="25"/>
+  <copyField source="text_*" dest="highlight" maxChars="25"/>
+
+  <!-- test source glob matching multiple explicit fields: sku1 and sku2 -->
+  <copyField source="sku*" dest="text"/>
+  <copyField source="sku*" dest="*_s"/>
+  <copyField source="sku*" dest="*_dest_sub_s"/>
+  <copyField source="sku*" dest="dest_sub_no_ast_s"/>
+
+  <!-- test source glob that doesn't match any explicit or dynamic field -->
+  <copyField source="testing123_*" dest="text"/>
+
+  <copyField source="*" dest="catchall_t"/>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-custom-field.xml b/solr/core/src/test-files/solr/collection1/conf/schema-custom-field.xml
index a0551d3..cdf5dee 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-custom-field.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-custom-field.xml
@@ -17,29 +17,25 @@
 -->
 
 <schema name="test-custom-field-sort" version="1.6">
-  <types>
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
-    <fieldType name="text" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType class="org.apache.solr.schema.SortableBinaryField" name="sortable_binary"/>
-  </types>
-  <fields>
-    <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
-    <field name="_version_" type="long" indexed="true" stored="true" multiValued="false"/>
-    <field name="signatureField" type="string" indexed="true" stored="false"/>
-    <field name="text" type="text" indexed="true" stored="false"/>
-    <field name="payload" type="sortable_binary" indexed="false" 
-           stored="true"  multiValued="false"    docValues="true" required="true"/>
-    <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+  <fieldType name="text" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType class="org.apache.solr.schema.SortableBinaryField" name="sortable_binary"/>
+  <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="_version_" type="long" indexed="true" stored="true" multiValued="false"/>
+  <field name="signatureField" type="string" indexed="true" stored="false"/>
+  <field name="text" type="text" indexed="true" stored="false"/>
+  <field name="payload" type="sortable_binary" indexed="false"
+         stored="true" multiValued="false" docValues="true" required="true"/>
+  <dynamicField name="*_sS" type="string" indexed="false" stored="true"/>
 
-    <!-- catchall wildcard to help ensure we aren't breaking function sorting -->
-    <dynamicField name="*" type="string"  indexed="true" stored="true"/>
-  </fields>
+  <!-- catchall wildcard to help ensure we aren't breaking function sorting -->
+  <dynamicField name="*" type="string" indexed="true" stored="true"/>
   <defaultSearchField>text</defaultSearchField>
   <uniqueKey>id</uniqueKey>
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-customfield.xml b/solr/core/src/test-files/solr/collection1/conf/schema-customfield.xml
index 790bc2c..4d0cbfd 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-customfield.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-customfield.xml
@@ -26,58 +26,54 @@
   -->
 
 <schema name="test" version="1.2">
-  <types>
 
-    <!-- field type definitions... note that the "name" attribute is
-         just a label to be used by field definitions.  The "class"
-         attribute and any other attributes determine the real type and
-         behavior of the fieldType.
-      -->
-
-    <!--
-      Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
-    -->
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
-
-    <!--
-     Numeric field types that index each value at various levels of precision
-     to accelerate range queries when the number of values between the range
-     endpoints is large. See the javadoc for LegacyNumericRangeQuery for internal
-     implementation details.
-
-     Smaller precisionStep values (specified in bits) will lead to more tokens
-     indexed per value, slightly larger index size, and faster range queries.
-     A precisionStep of 0 disables indexing at different precision levels.
+  <!-- field type definitions... note that the "name" attribute is
+       just a label to be used by field definitions.  The "class"
+       attribute and any other attributes determine the real type and
+       behavior of the fieldType.
     -->
-    <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
 
-    <fieldType name="customfield" class="org.apache.solr.schema.MyCrazyCustomField" multiValued="true" positionIncrementGap="100">
+  <!--
+    Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
+  -->
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
+
+  <!--
+   Numeric field types that index each value at various levels of precision
+   to accelerate range queries when the number of values between the range
+   endpoints is large. See the javadoc for LegacyNumericRangeQuery for internal
+   implementation details.
+
+   Smaller precisionStep values (specified in bits) will lead to more tokens
+   indexed per value, slightly larger index size, and faster range queries.
+   A precisionStep of 0 disables indexing at different precision levels.
+  -->
+  <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
+
+  <fieldType name="customfield" class="org.apache.solr.schema.MyCrazyCustomField" multiValued="true"
+             positionIncrementGap="100">
     <analyzer>
       <tokenizer class="solr.StandardTokenizerFactory"/>
     </analyzer>
-    </fieldType>
-
-    <fieldType name="customtrieintfield" class="org.apache.solr.schema.TrieIntPrefixActsAsRangeQueryFieldType"/>
+  </fieldType>
 
- </types>
+  <fieldType name="customtrieintfield" class="org.apache.solr.schema.TrieIntPrefixActsAsRangeQueryFieldType"/>
 
- <fields>
-   <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="true"/>
-   <field name="intfield" type="int" indexed="true" stored="true"/>
-   <field name="swap_foo_bar_in_prefix_query" type="customfield" indexed="true" stored="true" multiValued="true"/>
-   <field name="int_prefix_as_range" type="customtrieintfield" indexed="true" stored="true"/>
+  <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="true"/>
+  <field name="intfield" type="int" indexed="true" stored="true"/>
+  <field name="swap_foo_bar_in_prefix_query" type="customfield" indexed="true" stored="true" multiValued="true"/>
+  <field name="int_prefix_as_range" type="customtrieintfield" indexed="true" stored="true"/>
 
-   <field name="_version_" type="long" indexed="true" stored="true" multiValued="false" />
+  <field name="_version_" type="long" indexed="true" stored="true" multiValued="false"/>
 
- </fields>
 
- <uniqueKey>id</uniqueKey>
+  <uniqueKey>id</uniqueKey>
 
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-dfi.xml b/solr/core/src/test-files/solr/collection1/conf/schema-dfi.xml
index d334fee..038ce51 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-dfi.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-dfi.xml
@@ -19,34 +19,29 @@
 <!-- Test schema file for DFISimilarityFactory -->
 
 <schema name="dfi" version="1.5">
-  <types>
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-
-    <!-- default parameters -->
-    <fieldType name="text" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
-      <similarity class="solr.DFISimilarityFactory">
-        <str name="independenceMeasure">ChiSquared</str>
-      </similarity>
-    </fieldType>
-
-    <!-- with discountOverlaps parameter -->
-    <fieldType name="text_params" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
-      <similarity class="solr.DFISimilarityFactory">
-        <str name="independenceMeasure">ChiSquared</str>
-        <bool name="discountOverlaps">false</bool>
-      </similarity>
-    </fieldType>
-
-
-  </types>
-
-  <fields>
-    <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
-    <field name="text" type="text" indexed="true" stored="false"/>
-    <field name="text_params" type="text_params" indexed="true" stored="false"/>
-  </fields>
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+
+  <!-- default parameters -->
+  <fieldType name="text" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
+    <similarity class="solr.DFISimilarityFactory">
+      <str name="independenceMeasure">ChiSquared</str>
+    </similarity>
+  </fieldType>
+
+  <!-- with discountOverlaps parameter -->
+  <fieldType name="text_params" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
+    <similarity class="solr.DFISimilarityFactory">
+      <str name="independenceMeasure">ChiSquared</str>
+      <bool name="discountOverlaps">false</bool>
+    </similarity>
+  </fieldType>
+
+
+  <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="text" type="text" indexed="true" stored="false"/>
+  <field name="text_params" type="text_params" indexed="true" stored="false"/>
 
   <defaultSearchField>text</defaultSearchField>
   <uniqueKey>id</uniqueKey>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-dfr.xml b/solr/core/src/test-files/solr/collection1/conf/schema-dfr.xml
index b9bb006..f99a776 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-dfr.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-dfr.xml
@@ -19,51 +19,47 @@
 <!-- Test schema file for DFRSimilarityFactory -->
 
 <schema name="test" version="1.0">
-  <types>
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    
-    <!-- default parameters -->
-    <fieldType name="text" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
-      <similarity class="solr.DFRSimilarityFactory">
-        <str name="basicModel">I(F)</str>
-        <str name="afterEffect">B</str>
-        <str name="normalization">H2</str>
-      </similarity>
-    </fieldType>
-    
-    <!-- with parameters -->
-    <fieldType name="text_params" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
-      <similarity class="solr.DFRSimilarityFactory">
-        <str name="basicModel">I(F)</str>
-        <str name="afterEffect">B</str>
-        <str name="normalization">H3</str>
-        <float name="mu">900</float>
-      </similarity>
-    </fieldType>
-    
-    <!-- with parameter C -->
-    <fieldType name="text_paramc" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
-      <similarity class="solr.DFRSimilarityFactory">
-        <str name="basicModel">P</str>
-        <str name="afterEffect">L</str>
-        <str name="normalization">H2</str>
-        <float name="c">7</float>
-      </similarity>
-    </fieldType>
-   
-  </types>
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
 
-  <fields>
-    <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
-    <field name="text" type="text" indexed="true" stored="false"/>
-    <field name="text_params" type="text_params" indexed="true" stored="false"/>
-    <field name="text_paramc" type="text_paramc" indexed="true" stored="false"/>
-  </fields>
+  <!-- default parameters -->
+  <fieldType name="text" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
+    <similarity class="solr.DFRSimilarityFactory">
+      <str name="basicModel">I(F)</str>
+      <str name="afterEffect">B</str>
+      <str name="normalization">H2</str>
+    </similarity>
+  </fieldType>
+
+  <!-- with parameters -->
+  <fieldType name="text_params" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
+    <similarity class="solr.DFRSimilarityFactory">
+      <str name="basicModel">I(F)</str>
+      <str name="afterEffect">B</str>
+      <str name="normalization">H3</str>
+      <float name="mu">900</float>
+    </similarity>
+  </fieldType>
+
+  <!-- with parameter C -->
+  <fieldType name="text_paramc" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
+    <similarity class="solr.DFRSimilarityFactory">
+      <str name="basicModel">P</str>
+      <str name="afterEffect">L</str>
+      <str name="normalization">H2</str>
+      <float name="c">7</float>
+    </similarity>
+  </fieldType>
+
+
+  <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="text" type="text" indexed="true" stored="false"/>
+  <field name="text_params" type="text_params" indexed="true" stored="false"/>
+  <field name="text_paramc" type="text_paramc" indexed="true" stored="false"/>
 
   <defaultSearchField>text</defaultSearchField>
   <uniqueKey>id</uniqueKey>
-  
+
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-distrib-interval-faceting.xml b/solr/core/src/test-files/solr/collection1/conf/schema-distrib-interval-faceting.xml
index 9b1d3d6..79d200d 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-distrib-interval-faceting.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-distrib-interval-faceting.xml
@@ -17,66 +17,63 @@
 -->
 
 <schema name="test" version="1.6">
-  <types>
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="date" class="solr.TrieDateField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
-    <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
-  </types>
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="date" class="solr.TrieDateField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+  <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
 
-  <fields>
-    <field name="id"    type="string" indexed="true"  stored="true"  docValues="false" multiValued="false" required="true"/>
-    <field name="id_dv" type="string" indexed="false" stored="false" docValues="true"  multiValued="false" required="true"/>
-    <dynamicField name="*_i"     type="int"    indexed="true"  stored="false" docValues="false"/>
-    <dynamicField name="*_i_dv"  type="int"    indexed="false" stored="false" docValues="true"/>  
-    <dynamicField name="*_is"    type="int"    indexed="true"  stored="false" docValues="false" multiValued="true"/>
-    <dynamicField name="*_is_dv" type="int"    indexed="false" stored="false" docValues="true"  multiValued="true"/>
-    <dynamicField name="*_s"     type="string" indexed="true"  stored="false" docValues="false"/>
-    <dynamicField name="*_s_dv"  type="string" indexed="false" stored="false" docValues="true"/>
-    <dynamicField name="*_ss"    type="string" indexed="true"  stored="false" docValues="false" multiValued="true"/>
-    <dynamicField name="*_ss_dv" type="string" indexed="false" stored="false" docValues="true"  multiValued="true"/>
-    <dynamicField name="*_f"     type="float"  indexed="true"  stored="false" docValues="false"/>
-    <dynamicField name="*_f_dv"  type="float"  indexed="true"  stored="false" docValues="true"/>
-    <dynamicField name="*_fs_dv" type="float"  indexed="true"  stored="false" docValues="true"  multiValued="true"/>
-    <dynamicField name="*_l"     type="long"   indexed="true"  stored="false" docValues="false"/>
-    <dynamicField name="*_l_dv"  type="long"   indexed="true"  stored="false" docValues="true"/>
-    <dynamicField name="*_ls_dv" type="long"   indexed="true"  stored="false" docValues="true"  multiValued="true"/>
-    <dynamicField name="*_d"     type="double" indexed="true"  stored="false" docValues="false"/>
-    <dynamicField name="*_d_dv"  type="double" indexed="true"  stored="false" docValues="true"/>
-    <dynamicField name="*_ds_dv" type="double" indexed="true"  stored="false" docValues="true"  multiValued="true"/>
-    <dynamicField name="*_dt"    type="date"   indexed="true"  stored="false" docValues="false"/>
-    <dynamicField name="*_dt_dv" type="date"   indexed="true"  stored="false" docValues="true"/>
-    <dynamicField name="*_dts_dv" type="date"  indexed="true"  stored="false" docValues="true"  multiValued="true"/>
-    <dynamicField name="*_b"  type="boolean" indexed="true"  stored="true"/>
-    
-    <dynamicField name="*_ti1" type="int"    indexed="true"  stored="true" multiValued="false"/>
-    <dynamicField name="*_tl" type="long"   indexed="true"  stored="true"/>
-    <dynamicField name="*_tl1" type="long"   indexed="true"  stored="true" multiValued="false"/>
-    <dynamicField name="*_tf" type="float"  indexed="true"  stored="true"/>
-    <dynamicField name="*_tf1" type="float"  indexed="true"  stored="true" multiValued="false"/>
-    <dynamicField name="*_td" type="double" indexed="true"  stored="true"/>
-    <dynamicField name="*_td1" type="double" indexed="true" stored="true" multiValued="false"/>
-    <dynamicField name="*_tds" type="double" indexed="true" stored="true" multiValued="false"/>
-    <dynamicField name="*_tdt" type="date"  indexed="true"  stored="true"/>
-    <dynamicField name="*_tdt1" type="date"  indexed="true"  stored="true" multiValued="false"/>
-    
-    <dynamicField name="*_i1" type="int"    indexed="true"  stored="true" multiValued="false"/>
-    <dynamicField name="*_l1" type="long"   indexed="true"  stored="true" multiValued="false"/>
-    <dynamicField name="*_f1" type="float"  indexed="true"  stored="true" multiValued="false"/>
-    <dynamicField name="*_d1" type="double" indexed="true" stored="true" multiValued="false"/>
-    <dynamicField name="*_dt1" type="date"  indexed="true"  stored="true" multiValued="false"/>
-  </fields>
+  <field name="id" type="string" indexed="true" stored="true" docValues="false" multiValued="false" required="true"/>
+  <field name="id_dv" type="string" indexed="false" stored="false" docValues="true" multiValued="false"
+         required="true"/>
+  <dynamicField name="*_i" type="int" indexed="true" stored="false" docValues="false"/>
+  <dynamicField name="*_i_dv" type="int" indexed="false" stored="false" docValues="true"/>
+  <dynamicField name="*_is" type="int" indexed="true" stored="false" docValues="false" multiValued="true"/>
+  <dynamicField name="*_is_dv" type="int" indexed="false" stored="false" docValues="true" multiValued="true"/>
+  <dynamicField name="*_s" type="string" indexed="true" stored="false" docValues="false"/>
+  <dynamicField name="*_s_dv" type="string" indexed="false" stored="false" docValues="true"/>
+  <dynamicField name="*_ss" type="string" indexed="true" stored="false" docValues="false" multiValued="true"/>
+  <dynamicField name="*_ss_dv" type="string" indexed="false" stored="false" docValues="true" multiValued="true"/>
+  <dynamicField name="*_f" type="float" indexed="true" stored="false" docValues="false"/>
+  <dynamicField name="*_f_dv" type="float" indexed="true" stored="false" docValues="true"/>
+  <dynamicField name="*_fs_dv" type="float" indexed="true" stored="false" docValues="true" multiValued="true"/>
+  <dynamicField name="*_l" type="long" indexed="true" stored="false" docValues="false"/>
+  <dynamicField name="*_l_dv" type="long" indexed="true" stored="false" docValues="true"/>
+  <dynamicField name="*_ls_dv" type="long" indexed="true" stored="false" docValues="true" multiValued="true"/>
+  <dynamicField name="*_d" type="double" indexed="true" stored="false" docValues="false"/>
+  <dynamicField name="*_d_dv" type="double" indexed="true" stored="false" docValues="true"/>
+  <dynamicField name="*_ds_dv" type="double" indexed="true" stored="false" docValues="true" multiValued="true"/>
+  <dynamicField name="*_dt" type="date" indexed="true" stored="false" docValues="false"/>
+  <dynamicField name="*_dt_dv" type="date" indexed="true" stored="false" docValues="true"/>
+  <dynamicField name="*_dts_dv" type="date" indexed="true" stored="false" docValues="true" multiValued="true"/>
+  <dynamicField name="*_b" type="boolean" indexed="true" stored="true"/>
+
+  <dynamicField name="*_ti1" type="int" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_tl" type="long" indexed="true" stored="true"/>
+  <dynamicField name="*_tl1" type="long" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_tf" type="float" indexed="true" stored="true"/>
+  <dynamicField name="*_tf1" type="float" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_td" type="double" indexed="true" stored="true"/>
+  <dynamicField name="*_td1" type="double" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_tds" type="double" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_tdt" type="date" indexed="true" stored="true"/>
+  <dynamicField name="*_tdt1" type="date" indexed="true" stored="true" multiValued="false"/>
+
+  <dynamicField name="*_i1" type="int" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_l1" type="long" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_f1" type="float" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_d1" type="double" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_dt1" type="date" indexed="true" stored="true" multiValued="false"/>
 
   <defaultSearchField>id</defaultSearchField>
   <uniqueKey>id</uniqueKey>
-  
-  <copyField source="*_i" dest="*_i_dv" />
-  <copyField source="*_f" dest="*_f_dv" />
-  <copyField source="*_is" dest="*_is_dv" />
-  <copyField source="*_s" dest="*_s_dv" />
-  <copyField source="*_ss" dest="*_ss_dv" />
-  <copyField source="id" dest="id_dv" />
+
+  <copyField source="*_i" dest="*_i_dv"/>
+  <copyField source="*_f" dest="*_f_dv"/>
+  <copyField source="*_is" dest="*_is_dv"/>
+  <copyField source="*_s" dest="*_s_dv"/>
+  <copyField source="*_ss" dest="*_ss_dv"/>
+  <copyField source="id" dest="id_dv"/>
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-distributed-missing-sort.xml b/solr/core/src/test-files/solr/collection1/conf/schema-distributed-missing-sort.xml
index 4fe84d2..822d2be 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-distributed-missing-sort.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-distributed-missing-sort.xml
@@ -17,67 +17,66 @@
 -->
 
 <schema name="test-distributed-missing-sort" version="1.6">
-  <types>
-    <fieldType name="int"       class="solr.TrieIntField"     precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="tint"      class="solr.TrieIntField"     precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
 
-    <fieldType name="long"      class="solr.TrieLongField"    precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="tlong"     class="solr.TrieLongField"    precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
 
-    <fieldType name="float"     class="solr.TrieFloatField"   precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="tfloat"    class="solr.TrieFloatField"   precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
 
-    <fieldType name="double"    class="solr.TrieDoubleField"  precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="tdouble"   class="solr.TrieDoubleField"  precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
 
-    <fieldType name="date"      class="solr.TrieDateField"    precisionStep="0"/>
-    <fieldType name="tdate"     class="solr.TrieDateField"    precisionStep="6"/>
+  <fieldType name="date" class="solr.TrieDateField" precisionStep="0"/>
+  <fieldType name="tdate" class="solr.TrieDateField" precisionStep="6"/>
 
-    <fieldType name="boolean"   class="solr.BoolField"        sortMissingLast="true"/>
+  <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
 
-    <fieldType name="int_ml"   class="solr.TrieIntField" precisionStep="0" sortMissingLast="true"/>
-    <fieldType name="int_mf"   class="solr.TrieIntField" precisionStep="0" sortMissingFirst="true"/>
+  <fieldType name="int_ml" class="solr.TrieIntField" precisionStep="0" sortMissingLast="true"/>
+  <fieldType name="int_mf" class="solr.TrieIntField" precisionStep="0" sortMissingFirst="true"/>
 
-    <fieldType name="long_ml"   class="solr.TrieLongField"    precisionStep="0" omitNorms="true" positionIncrementGap="0" sortMissingLast="true"/>
-    <fieldType name="long_mf"   class="solr.TrieLongField"    precisionStep="0" omitNorms="true" positionIncrementGap="0" sortMissingFirst="true"/>
+  <fieldType name="long_ml" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"
+             sortMissingLast="true"/>
+  <fieldType name="long_mf" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"
+             sortMissingFirst="true"/>
 
-    <fieldType name="string_ml" class="solr.StrField"         sortMissingLast="true"/>
-    <fieldType name="string_mf" class="solr.StrField"         sortMissingFirst="true"/>
-  </types>
+  <fieldType name="string_ml" class="solr.StrField" sortMissingLast="true"/>
+  <fieldType name="string_mf" class="solr.StrField" sortMissingFirst="true"/>
 
-  <fields>
-    <field name="id"              type="int"       indexed="true"  stored="true"  multiValued="false" required="false"/>
-    <field name="_version_"       type="long"      indexed="true"  stored="true"  multiValued="false"/>
-    <field name="signatureField"  type="string_ml" indexed="true"  stored="false"/>
+  <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="_version_" type="long" indexed="true" stored="true" multiValued="false"/>
+  <field name="signatureField" type="string_ml" indexed="true" stored="false"/>
 
-    <dynamicField name="*_ti1"    type="tint"      indexed="true"  stored="true"  multiValued="false"/>
-    <dynamicField name="*_i1_ml"  type="int_ml"    indexed="true"  stored="true"  multiValued="false"/>
-    <dynamicField name="*_i1_mf"  type="int_mf"    indexed="true"  stored="true"  multiValued="false"/>
+  <dynamicField name="*_ti1" type="tint" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_i1_ml" type="int_ml" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_i1_mf" type="int_mf" indexed="true" stored="true" multiValued="false"/>
 
-    <dynamicField name="*_l1_ml"  type="long_ml"   indexed="true"  stored="true"  multiValued="false"/>
-    <dynamicField name="*_l1_mf"  type="long_mf"   indexed="true"  stored="true"  multiValued="false"/>
+  <dynamicField name="*_l1_ml" type="long_ml" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_l1_mf" type="long_mf" indexed="true" stored="true" multiValued="false"/>
 
-    <dynamicField name="*_l1"     type="long"      indexed="true"  stored="true"  multiValued="false"/>
-    <dynamicField name="*_tl1"    type="tlong"     indexed="true"  stored="true"  multiValued="false"/>
+  <dynamicField name="*_l1" type="long" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_tl1" type="tlong" indexed="true" stored="true" multiValued="false"/>
 
-    <dynamicField name="*_f"      type="float"     indexed="true"  stored="true"/>
-    <dynamicField name="*_f1"     type="float"     indexed="true"  stored="true"  multiValued="false"/>
-    <dynamicField name="*_tf1"    type="tfloat"    indexed="true"  stored="true"  multiValued="false"/>
+  <dynamicField name="*_f" type="float" indexed="true" stored="true"/>
+  <dynamicField name="*_f1" type="float" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_tf1" type="tfloat" indexed="true" stored="true" multiValued="false"/>
 
-    <dynamicField name="*_d"      type="double"    indexed="true"  stored="true"/>
-    <dynamicField name="*_d1"     type="double"    indexed="true"  stored="true"  multiValued="false"/>
-    <dynamicField name="*_td1"    type="tdouble"   indexed="true"  stored="true"  multiValued="false"/>
+  <dynamicField name="*_d" type="double" indexed="true" stored="true"/>
+  <dynamicField name="*_d1" type="double" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_td1" type="tdouble" indexed="true" stored="true" multiValued="false"/>
 
-    <dynamicField name="*_dt1"    type="date"      indexed="true"  stored="true"  multiValued="false"/>
-    <dynamicField name="*_tdt1"   type="tdate"     indexed="true"  stored="true"  multiValued="false"/>
+  <dynamicField name="*_dt1" type="date" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_tdt1" type="tdate" indexed="true" stored="true" multiValued="false"/>
 
-    <dynamicField name="*_b"      type="boolean"   indexed="true"  stored="true"/>
+  <dynamicField name="*_b" type="boolean" indexed="true" stored="true"/>
 
-    <dynamicField name="*_s1_ml"  type="string_ml" indexed="true"  stored="true"  multiValued="false"/>
-    <dynamicField name="*_s1_mf"  type="string_mf" indexed="true"  stored="true"  multiValued="false"/>
+  <dynamicField name="*_s1_ml" type="string_ml" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_s1_mf" type="string_mf" indexed="true" stored="true" multiValued="false"/>
+
+  <dynamicField name="*_mfacet" type="string_ml" indexed="true" stored="false" multiValued="true"/>
+  <dynamicField name="*_sS" type="string_ml" indexed="false" stored="true"/>
 
-    <dynamicField name="*_mfacet" type="string_ml" indexed="true"  stored="false" multiValued="true" />
-    <dynamicField name="*_sS"     type="string_ml" indexed="false" stored="true"/>
-  </fields>
   <uniqueKey>id</uniqueKey>
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-docValues.xml b/solr/core/src/test-files/solr/collection1/conf/schema-docValues.xml
index 680ac04..59fe99a 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-docValues.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-docValues.xml
@@ -26,59 +26,50 @@
   -->
 
 <schema name="schema-docValues" version="1.6">
-  <types>
-
-    <!-- field type definitions... note that the "name" attribute is
-         just a label to be used by field definitions.  The "class"
-         attribute and any other attributes determine the real type and
-         behavior of the fieldType.
-      -->
-
-    <!-- numeric field types that store and index the text
-         value verbatim (and hence don't sort correctly or support range queries.)
-         These are provided more for backward compatability, allowing one
-         to create a schema that matches an existing lucene index.
-    -->
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
-         seconds part (.999) is optional.
-      -->
-    <fieldType name="date" class="solr.TrieDateField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-
-    <fieldType name="boolean" class="solr.BoolField" />
-    <fieldType name="string" class="solr.StrField" />
-
-    <fieldType name="uuid" class="solr.UUIDField" />
-
-  </types>
 
+  <!-- field type definitions... note that the "name" attribute is
+       just a label to be used by field definitions.  The "class"
+       attribute and any other attributes determine the real type and
+       behavior of the fieldType.
+    -->
 
-  <fields>
+  <!-- numeric field types that store and index the text
+       value verbatim (and hence don't sort correctly or support range queries.)
+       These are provided more for backward compatability, allowing one
+       to create a schema that matches an existing lucene index.
+  -->
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
+       seconds part (.999) is optional.
+    -->
+  <fieldType name="date" class="solr.TrieDateField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
 
-    <field name="id" type="int" required="true" />
+  <fieldType name="boolean" class="solr.BoolField"/>
+  <fieldType name="string" class="solr.StrField"/>
 
-    <field name="floatdv" type="float" indexed="false" stored="false" docValues="true" default="1" />
-    <field name="intdv" type="int" indexed="false" stored="false" docValues="true" default="2" />
-    <field name="doubledv" type="double" indexed="false" stored="false" docValues="true" default="3" />
-    <field name="longdv" type="long" indexed="false" stored="false" docValues="true" default="4" />
-    <field name="datedv" type="date" indexed="false" stored="false" docValues="true" default="1995-12-31T23:59:59.999Z" />
+  <fieldType name="uuid" class="solr.UUIDField"/>
 
-    <field name="stringdv" type="string" indexed="false" stored="false" docValues="true" default="solr" />
 
-    <field name="floatdvs" type="float" indexed="false" stored="false" docValues="true" default="1" />
-    <field name="intdvs" type="int" indexed="false" stored="false" docValues="true" default="2" />
-    <field name="doubledvs" type="double" indexed="false" stored="false" docValues="true" default="3" />
-    <field name="longdvs" type="long" indexed="false" stored="false" docValues="true" default="4" />
-    <field name="datedvs" type="date" indexed="false" stored="false" docValues="true" default="1995-12-31T23:59:59.999Z" />
-    <field name="stringdvs" type="string" indexed="false" stored="false" docValues="true" default="solr" />
+  <field name="id" type="int" required="true"/>
 
+  <field name="floatdv" type="float" indexed="false" stored="false" docValues="true" default="1"/>
+  <field name="intdv" type="int" indexed="false" stored="false" docValues="true" default="2"/>
+  <field name="doubledv" type="double" indexed="false" stored="false" docValues="true" default="3"/>
+  <field name="longdv" type="long" indexed="false" stored="false" docValues="true" default="4"/>
+  <field name="datedv" type="date" indexed="false" stored="false" docValues="true" default="1995-12-31T23:59:59.999Z"/>
 
+  <field name="stringdv" type="string" indexed="false" stored="false" docValues="true" default="solr"/>
 
+  <field name="floatdvs" type="float" indexed="false" stored="false" docValues="true" default="1"/>
+  <field name="intdvs" type="int" indexed="false" stored="false" docValues="true" default="2"/>
+  <field name="doubledvs" type="double" indexed="false" stored="false" docValues="true" default="3"/>
+  <field name="longdvs" type="long" indexed="false" stored="false" docValues="true" default="4"/>
+  <field name="datedvs" type="date" indexed="false" stored="false" docValues="true" default="1995-12-31T23:59:59.999Z"/>
+  <field name="stringdvs" type="string" indexed="false" stored="false" docValues="true" default="solr"/>
 
-  </fields>
 
   <uniqueKey>id</uniqueKey>
 
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-docValuesFaceting.xml b/solr/core/src/test-files/solr/collection1/conf/schema-docValuesFaceting.xml
index e3f4f5f..113e868 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-docValuesFaceting.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-docValuesFaceting.xml
@@ -17,56 +17,53 @@
 -->
 
 <schema name="test" version="1.6">
-  <types>
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="date" class="solr.TrieDateField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
-  </types>
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="date" class="solr.TrieDateField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
 
-  <fields>
-    <field name="id"    type="string" indexed="true"  stored="true"  docValues="false" multiValued="false" required="true"/>
-    <field name="id_dv" type="string" indexed="false" stored="false" docValues="true"  multiValued="false" required="true"/>
-    <dynamicField name="*_i"     type="int"    indexed="true"  stored="false" docValues="false"/>
-    <dynamicField name="*_i_dv"  type="int"    indexed="false" stored="false" docValues="true"/>  
-    <dynamicField name="*_is"    type="int"    indexed="true"  stored="false" docValues="false" multiValued="true"/>
-    <dynamicField name="*_is_dv" type="int"    indexed="false" stored="false" docValues="true"  multiValued="true"/>
-    <dynamicField name="*_s"     type="string" indexed="true"  stored="false" docValues="false"/>
-    <dynamicField name="*_s_dv"  type="string" indexed="false" stored="false" docValues="true"/>
-    <dynamicField name="*_ss"    type="string" indexed="true"  stored="false" docValues="false" multiValued="true"/>
-    <dynamicField name="*_ss_dv" type="string" indexed="false" stored="false" docValues="true"  multiValued="true"/>
-    <dynamicField name="*_f"     type="float"  indexed="true"  stored="false" docValues="false"/>
-    <dynamicField name="*_f_dv"  type="float"  indexed="true"  stored="false" docValues="true"/>
-    <dynamicField name="*_fs"    type="float"  indexed="true"  stored="false" docValues="false"  multiValued="true"/>
-    <dynamicField name="*_fs_dv" type="float"  indexed="true"  stored="false" docValues="true"  multiValued="true"/>
-    <dynamicField name="*_l"     type="long"   indexed="true"  stored="false" docValues="false"/>
-    <dynamicField name="*_l_dv"  type="long"   indexed="true"  stored="false" docValues="true"/>
-    <dynamicField name="*_ls"    type="long"   indexed="true"  stored="false" docValues="false"  multiValued="true"/>
-    <dynamicField name="*_ls_dv" type="long"   indexed="true"  stored="false" docValues="true"  multiValued="true"/>
-    <dynamicField name="*_d"     type="double" indexed="true"  stored="false" docValues="false"/>
-    <dynamicField name="*_d_dv"  type="double" indexed="true"  stored="false" docValues="true"/>
-    <dynamicField name="*_ds"    type="double" indexed="true"  stored="false" docValues="false"  multiValued="true"/>
-    <dynamicField name="*_ds_dv" type="double" indexed="true"  stored="false" docValues="true"  multiValued="true"/>
-    <dynamicField name="*_dt"    type="date"   indexed="true"  stored="false" docValues="false"/>
-    <dynamicField name="*_dt_dv" type="date"   indexed="true"  stored="false" docValues="true"/>
-    <dynamicField name="*_dts_dv" type="date"  indexed="true"  stored="false" docValues="true"  multiValued="true"/>
-  </fields>
+  <field name="id" type="string" indexed="true" stored="true" docValues="false" multiValued="false" required="true"/>
+  <field name="id_dv" type="string" indexed="false" stored="false" docValues="true" multiValued="false"
+         required="true"/>
+  <dynamicField name="*_i" type="int" indexed="true" stored="false" docValues="false"/>
+  <dynamicField name="*_i_dv" type="int" indexed="false" stored="false" docValues="true"/>
+  <dynamicField name="*_is" type="int" indexed="true" stored="false" docValues="false" multiValued="true"/>
+  <dynamicField name="*_is_dv" type="int" indexed="false" stored="false" docValues="true" multiValued="true"/>
+  <dynamicField name="*_s" type="string" indexed="true" stored="false" docValues="false"/>
+  <dynamicField name="*_s_dv" type="string" indexed="false" stored="false" docValues="true"/>
+  <dynamicField name="*_ss" type="string" indexed="true" stored="false" docValues="false" multiValued="true"/>
+  <dynamicField name="*_ss_dv" type="string" indexed="false" stored="false" docValues="true" multiValued="true"/>
+  <dynamicField name="*_f" type="float" indexed="true" stored="false" docValues="false"/>
+  <dynamicField name="*_f_dv" type="float" indexed="true" stored="false" docValues="true"/>
+  <dynamicField name="*_fs" type="float" indexed="true" stored="false" docValues="false" multiValued="true"/>
+  <dynamicField name="*_fs_dv" type="float" indexed="true" stored="false" docValues="true" multiValued="true"/>
+  <dynamicField name="*_l" type="long" indexed="true" stored="false" docValues="false"/>
+  <dynamicField name="*_l_dv" type="long" indexed="true" stored="false" docValues="true"/>
+  <dynamicField name="*_ls" type="long" indexed="true" stored="false" docValues="false" multiValued="true"/>
+  <dynamicField name="*_ls_dv" type="long" indexed="true" stored="false" docValues="true" multiValued="true"/>
+  <dynamicField name="*_d" type="double" indexed="true" stored="false" docValues="false"/>
+  <dynamicField name="*_d_dv" type="double" indexed="true" stored="false" docValues="true"/>
+  <dynamicField name="*_ds" type="double" indexed="true" stored="false" docValues="false" multiValued="true"/>
+  <dynamicField name="*_ds_dv" type="double" indexed="true" stored="false" docValues="true" multiValued="true"/>
+  <dynamicField name="*_dt" type="date" indexed="true" stored="false" docValues="false"/>
+  <dynamicField name="*_dt_dv" type="date" indexed="true" stored="false" docValues="true"/>
+  <dynamicField name="*_dts_dv" type="date" indexed="true" stored="false" docValues="true" multiValued="true"/>
 
   <defaultSearchField>id</defaultSearchField>
   <uniqueKey>id</uniqueKey>
-  
-  <copyField source="*_i" dest="*_i_dv" />
-  <copyField source="*_f" dest="*_f_dv" />
-  <copyField source="*_is" dest="*_is_dv" />
-  <copyField source="*_s" dest="*_s_dv" />
-  <copyField source="*_l" dest="*_l_dv" />
-  <copyField source="*_d" dest="*_d_dv" />
-  <copyField source="*_ss" dest="*_ss_dv" />
-  <copyField source="*_is" dest="*_is_dv" />
-  <copyField source="*_fs" dest="*_fs_dv" />
-  <copyField source="*_ls" dest="*_ls_dv" />
-  <copyField source="*_ds" dest="*_ds_dv" />
-  <copyField source="id" dest="id_dv" />
+
+  <copyField source="*_i" dest="*_i_dv"/>
+  <copyField source="*_f" dest="*_f_dv"/>
+  <copyField source="*_is" dest="*_is_dv"/>
+  <copyField source="*_s" dest="*_s_dv"/>
+  <copyField source="*_l" dest="*_l_dv"/>
+  <copyField source="*_d" dest="*_d_dv"/>
+  <copyField source="*_ss" dest="*_ss_dv"/>
+  <copyField source="*_is" dest="*_is_dv"/>
+  <copyField source="*_fs" dest="*_fs_dv"/>
+  <copyField source="*_ls" dest="*_ls_dv"/>
+  <copyField source="*_ds" dest="*_ds_dv"/>
+  <copyField source="id" dest="id_dv"/>
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-docValuesJoin.xml b/solr/core/src/test-files/solr/collection1/conf/schema-docValuesJoin.xml
index 5bcb1a1..1d559bb 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-docValuesJoin.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-docValuesJoin.xml
@@ -29,78 +29,77 @@
        1.5: omitNorms defaults to true for primitive field types (int, float, boolean, string...)
        1.6: useDocValuesAsStored defaults to true.
      -->
-  <types>
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="date" class="solr.TrieDateField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldtype name="string" class="solr.StrField" sortMissingLast="true" useDocValuesAsStored="false"/>
-    <fieldType name="text" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true" >
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="stopwords.txt"
-                />
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="stopwords.txt"
-                />
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-  </types>
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="date" class="solr.TrieDateField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldtype name="string" class="solr.StrField" sortMissingLast="true" useDocValuesAsStored="false"/>
+  <fieldType name="text" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="stopwords.txt"
+      />
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="stopwords.txt"
+      />
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <field name="id" type="string" indexed="true" stored="true" docValues="false" multiValued="false" required="true"/>
+  <field name="id_dv" type="string" indexed="false" stored="false" docValues="true" multiValued="false"
+         required="true"/>
+  <dynamicField name="*_i" type="int" indexed="true" stored="false" docValues="false"/>
+  <dynamicField name="*_i_dv" type="int" indexed="true" stored="true" docValues="true"/>
+  <dynamicField name="*_is" type="int" indexed="true" stored="false" docValues="false" multiValued="true"/>
+  <dynamicField name="*_is_dv" type="int" indexed="true" stored="true" docValues="true" multiValued="true"/>
+  <dynamicField name="*_s" type="string" indexed="true" stored="false" docValues="false"/>
+  <dynamicField name="*_s_dv" type="string" indexed="true" stored="true" docValues="true"/>
+  <dynamicField name="*_ss" type="string" indexed="true" stored="false" docValues="false" multiValued="true"/>
+  <dynamicField name="*_ss_dv" type="string" indexed="true" stored="true" docValues="true" multiValued="true"/>
+  <dynamicField name="*_f" type="float" indexed="true" stored="false" docValues="false"/>
+  <dynamicField name="*_f_dv" type="float" indexed="true" stored="true" docValues="true"/>
+  <dynamicField name="*_fs_dv" type="float" indexed="true" stored="true" docValues="true" multiValued="true"/>
+  <dynamicField name="*_l" type="long" indexed="true" stored="false" docValues="false"/>
+  <dynamicField name="*_l_dv" type="long" indexed="true" stored="false" docValues="true"/>
+  <dynamicField name="*_ls_dv" type="long" indexed="true" stored="false" docValues="true" multiValued="true"/>
+  <dynamicField name="*_d" type="double" indexed="true" stored="false" docValues="false"/>
+  <dynamicField name="*_d_dv" type="double" indexed="true" stored="false" docValues="true"/>
+  <dynamicField name="*_ds_dv" type="double" indexed="true" stored="false" docValues="true" multiValued="true"/>
+  <dynamicField name="*_dt" type="date" indexed="true" stored="false" docValues="false"/>
+  <dynamicField name="*_dt_dv" type="date" indexed="true" stored="false" docValues="true"/>
+  <dynamicField name="*_dts_dv" type="date" indexed="true" stored="false" docValues="true" multiValued="true"/>
+  <dynamicField name="*_t" type="text" indexed="true" stored="true"/>
+
+
+  <field name="_version_" type="long" indexed="true" stored="true" multiValued="false"/>
 
-  <fields>
-    <field name="id"    type="string" indexed="true"  stored="true"  docValues="false" multiValued="false" required="true"/>
-    <field name="id_dv" type="string" indexed="false" stored="false" docValues="true"  multiValued="false" required="true"/>
-    <dynamicField name="*_i"     type="int"    indexed="true"  stored="false" docValues="false"/>
-    <dynamicField name="*_i_dv"  type="int"    indexed="true" stored="true" docValues="true"/>  
-    <dynamicField name="*_is"    type="int"    indexed="true"  stored="false" docValues="false" multiValued="true"/>
-    <dynamicField name="*_is_dv" type="int"    indexed="true" stored="true" docValues="true"  multiValued="true"/>
-    <dynamicField name="*_s"     type="string" indexed="true"  stored="false" docValues="false"/>
-    <dynamicField name="*_s_dv"  type="string" indexed="true" stored="true" docValues="true"/>
-    <dynamicField name="*_ss"    type="string" indexed="true"  stored="false" docValues="false" multiValued="true"/>
-    <dynamicField name="*_ss_dv" type="string" indexed="true" stored="true" docValues="true"  multiValued="true"/>
-    <dynamicField name="*_f"     type="float"  indexed="true"  stored="false" docValues="false"/>
-    <dynamicField name="*_f_dv"  type="float"  indexed="true"  stored="true" docValues="true"/>
-    <dynamicField name="*_fs_dv" type="float"  indexed="true"  stored="true" docValues="true"  multiValued="true"/>
-    <dynamicField name="*_l"     type="long"   indexed="true"  stored="false" docValues="false"/>
-    <dynamicField name="*_l_dv"  type="long"   indexed="true"  stored="false" docValues="true"/>
-    <dynamicField name="*_ls_dv" type="long"   indexed="true"  stored="false" docValues="true"  multiValued="true"/>
-    <dynamicField name="*_d"     type="double" indexed="true"  stored="false" docValues="false"/>
-    <dynamicField name="*_d_dv"  type="double" indexed="true"  stored="false" docValues="true"/>
-    <dynamicField name="*_ds_dv" type="double" indexed="true"  stored="false" docValues="true"  multiValued="true"/>
-    <dynamicField name="*_dt"    type="date"   indexed="true"  stored="false" docValues="false"/>
-    <dynamicField name="*_dt_dv" type="date"   indexed="true"  stored="false" docValues="true"/>
-    <dynamicField name="*_dts_dv" type="date"  indexed="true"  stored="false" docValues="true"  multiValued="true"/>
-    <dynamicField name="*_t"  type="text"    indexed="true"  stored="true"/>
-    
-       
-   <field name="_version_" type="long" indexed="true" stored="true" multiValued="false"/>
-   
-  </fields>
 
   <defaultSearchField>id</defaultSearchField>
   <uniqueKey>id</uniqueKey>
-  
-  <copyField source="*_i" dest="*_i_dv" />
-  <copyField source="*_f" dest="*_f_dv" />
-  <copyField source="*_is" dest="*_is_dv" />
-  <copyField source="*_s" dest="*_s_dv" />
-  <copyField source="*_ss" dest="*_ss_dv" />
-  <copyField source="id" dest="id_dv" />
-  
+
+  <copyField source="*_i" dest="*_i_dv"/>
+  <copyField source="*_f" dest="*_f_dv"/>
+  <copyField source="*_is" dest="*_is_dv"/>
+  <copyField source="*_s" dest="*_s_dv"/>
+  <copyField source="*_ss" dest="*_ss_dv"/>
+  <copyField source="id" dest="id_dv"/>
+
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-docValuesMissing.xml b/solr/core/src/test-files/solr/collection1/conf/schema-docValuesMissing.xml
index c87a1f4..2204749 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-docValuesMissing.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-docValuesMissing.xml
@@ -19,69 +19,84 @@
 <!-- schema file for testing sorting/faceting/functions on single-valued DV with missing values -->
 
 <schema name="schema-docValuesMissing" version="1.6">
-  <types>
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="date" class="solr.TrieDateField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="string" class="solr.StrField" />
-  </types>
-
-  <fields>
-    <field name="id" type="string" required="true" />
-
-    <field name="floatdv"               type="float" indexed="false" stored="false" docValues="true"/>
-    <field name="floatdv_missingfirst"  type="float" indexed="false" stored="false" docValues="true" sortMissingFirst="true"/>
-    <field name="floatdv_missinglast"   type="float" indexed="false" stored="false" docValues="true" sortMissingLast="true"/>
-    
-    <field name="intdv"                 type="int" indexed="false" stored="false" docValues="true"/>
-    <field name="intdv_missingfirst"    type="int" indexed="false" stored="false" docValues="true" sortMissingFirst="true"/>
-    <field name="intdv_missinglast"     type="int" indexed="false" stored="false" docValues="true" sortMissingLast="true"/>
-
-    <field name="doubledv"              type="double" indexed="false" stored="false" docValues="true"/>
-    <field name="doubledv_missingfirst" type="double" indexed="false" stored="false" docValues="true" sortMissingFirst="true"/>
-    <field name="doubledv_missinglast"  type="double" indexed="false" stored="false" docValues="true" sortMissingLast="true"/>
-
-    <field name="longdv"                type="long" indexed="false" stored="false" docValues="true"/>
-    <field name="longdv_missingfirst"   type="long" indexed="false" stored="false" docValues="true" sortMissingFirst="true"/>
-    <field name="longdv_missinglast"    type="long" indexed="false" stored="false" docValues="true" sortMissingLast="true"/>
- 
-    <field name="datedv"                type="date" indexed="false" stored="false" docValues="true"/>
-    <field name="datedv_missingfirst"   type="date" indexed="false" stored="false" docValues="true" sortMissingFirst="true"/>
-    <field name="datedv_missinglast"    type="date" indexed="false" stored="false" docValues="true" sortMissingLast="true"/>
-
-    <field name="stringdv"              type="string" indexed="false" stored="false" docValues="true"/>
-    <field name="stringdv_missingfirst" type="string" indexed="false" stored="false" docValues="true" sortMissingFirst="true"/>
-    <field name="stringdv_missinglast"  type="string" indexed="false" stored="false" docValues="true" sortMissingLast="true"/>
-
-
-    <dynamicField name="*_floatdv"               type="float" indexed="false" stored="false" docValues="true"/>
-    <dynamicField name="*_floatdv_missingfirst"  type="float" indexed="false" stored="false" docValues="true" sortMissingFirst="true"/>
-    <dynamicField name="*_floatdv_missinglast"   type="float" indexed="false" stored="false" docValues="true" sortMissingLast="true"/>
-    
-    <dynamicField name="*_intdv"                 type="int" indexed="false" stored="false" docValues="true"/>
-    <dynamicField name="*_intdv_missingfirst"    type="int" indexed="false" stored="false" docValues="true" sortMissingFirst="true"/>
-    <dynamicField name="*_intdv_missinglast"     type="int" indexed="false" stored="false" docValues="true" sortMissingLast="true"/>
-
-    <dynamicField name="*_doubledv"              type="double" indexed="false" stored="false" docValues="true"/>
-    <dynamicField name="*_doubledv_missingfirst" type="double" indexed="false" stored="false" docValues="true" sortMissingFirst="true"/>
-    <dynamicField name="*_doubledv_missinglast"  type="double" indexed="false" stored="false" docValues="true" sortMissingLast="true"/>
-
-    <dynamicField name="*_longdv"                type="long" indexed="false" stored="false" docValues="true"/>
-    <dynamicField name="*_longdv_missingfirst"   type="long" indexed="false" stored="false" docValues="true" sortMissingFirst="true"/>
-    <dynamicField name="*_longdv_missinglast"    type="long" indexed="false" stored="false" docValues="true" sortMissingLast="true"/>
- 
-    <dynamicField name="*_datedv"                type="date" indexed="false" stored="false" docValues="true"/>
-    <dynamicField name="*_datedv_missingfirst"   type="date" indexed="false" stored="false" docValues="true" sortMissingFirst="true"/>
-    <dynamicField name="*_datedv_missinglast"    type="date" indexed="false" stored="false" docValues="true" sortMissingLast="true"/>
-
-    <dynamicField name="*_stringdv"              type="string" indexed="false" stored="false" docValues="true"/>
-    <dynamicField name="*_stringdv_missingfirst" type="string" indexed="false" stored="false" docValues="true" sortMissingFirst="true"/>
-    <dynamicField name="*_stringdv_missinglast"  type="string" indexed="false" stored="false" docValues="true" sortMissingLast="true"/>
-
-
-  </fields>
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="date" class="solr.TrieDateField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="string" class="solr.StrField"/>
+
+  <field name="id" type="string" required="true"/>
+
+  <field name="floatdv" type="float" indexed="false" stored="false" docValues="true"/>
+  <field name="floatdv_missingfirst" type="float" indexed="false" stored="false" docValues="true"
+         sortMissingFirst="true"/>
+  <field name="floatdv_missinglast" type="float" indexed="false" stored="false" docValues="true"
+         sortMissingLast="true"/>
+
+  <field name="intdv" type="int" indexed="false" stored="false" docValues="true"/>
+  <field name="intdv_missingfirst" type="int" indexed="false" stored="false" docValues="true" sortMissingFirst="true"/>
+  <field name="intdv_missinglast" type="int" indexed="false" stored="false" docValues="true" sortMissingLast="true"/>
+
+  <field name="doubledv" type="double" indexed="false" stored="false" docValues="true"/>
+  <field name="doubledv_missingfirst" type="double" indexed="false" stored="false" docValues="true"
+         sortMissingFirst="true"/>
+  <field name="doubledv_missinglast" type="double" indexed="false" stored="false" docValues="true"
+         sortMissingLast="true"/>
+
+  <field name="longdv" type="long" indexed="false" stored="false" docValues="true"/>
+  <field name="longdv_missingfirst" type="long" indexed="false" stored="false" docValues="true"
+         sortMissingFirst="true"/>
+  <field name="longdv_missinglast" type="long" indexed="false" stored="false" docValues="true" sortMissingLast="true"/>
+
+  <field name="datedv" type="date" indexed="false" stored="false" docValues="true"/>
+  <field name="datedv_missingfirst" type="date" indexed="false" stored="false" docValues="true"
+         sortMissingFirst="true"/>
+  <field name="datedv_missinglast" type="date" indexed="false" stored="false" docValues="true" sortMissingLast="true"/>
+
+  <field name="stringdv" type="string" indexed="false" stored="false" docValues="true"/>
+  <field name="stringdv_missingfirst" type="string" indexed="false" stored="false" docValues="true"
+         sortMissingFirst="true"/>
+  <field name="stringdv_missinglast" type="string" indexed="false" stored="false" docValues="true"
+         sortMissingLast="true"/>
+
+
+  <dynamicField name="*_floatdv" type="float" indexed="false" stored="false" docValues="true"/>
+  <dynamicField name="*_floatdv_missingfirst" type="float" indexed="false" stored="false" docValues="true"
+                sortMissingFirst="true"/>
+  <dynamicField name="*_floatdv_missinglast" type="float" indexed="false" stored="false" docValues="true"
+                sortMissingLast="true"/>
+
+  <dynamicField name="*_intdv" type="int" indexed="false" stored="false" docValues="true"/>
+  <dynamicField name="*_intdv_missingfirst" type="int" indexed="false" stored="false" docValues="true"
+                sortMissingFirst="true"/>
+  <dynamicField name="*_intdv_missinglast" type="int" indexed="false" stored="false" docValues="true"
+                sortMissingLast="true"/>
+
+  <dynamicField name="*_doubledv" type="double" indexed="false" stored="false" docValues="true"/>
+  <dynamicField name="*_doubledv_missingfirst" type="double" indexed="false" stored="false" docValues="true"
+                sortMissingFirst="true"/>
+  <dynamicField name="*_doubledv_missinglast" type="double" indexed="false" stored="false" docValues="true"
+                sortMissingLast="true"/>
+
+  <dynamicField name="*_longdv" type="long" indexed="false" stored="false" docValues="true"/>
+  <dynamicField name="*_longdv_missingfirst" type="long" indexed="false" stored="false" docValues="true"
+                sortMissingFirst="true"/>
+  <dynamicField name="*_longdv_missinglast" type="long" indexed="false" stored="false" docValues="true"
+                sortMissingLast="true"/>
+
+  <dynamicField name="*_datedv" type="date" indexed="false" stored="false" docValues="true"/>
+  <dynamicField name="*_datedv_missingfirst" type="date" indexed="false" stored="false" docValues="true"
+                sortMissingFirst="true"/>
+  <dynamicField name="*_datedv_missinglast" type="date" indexed="false" stored="false" docValues="true"
+                sortMissingLast="true"/>
+
+  <dynamicField name="*_stringdv" type="string" indexed="false" stored="false" docValues="true"/>
+  <dynamicField name="*_stringdv_missingfirst" type="string" indexed="false" stored="false" docValues="true"
+                sortMissingFirst="true"/>
+  <dynamicField name="*_stringdv_missinglast" type="string" indexed="false" stored="false" docValues="true"
+                sortMissingLast="true"/>
+
 
   <uniqueKey>id</uniqueKey>
 
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-docValuesMulti.xml b/solr/core/src/test-files/solr/collection1/conf/schema-docValuesMulti.xml
index f0a4007..93a8588 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-docValuesMulti.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-docValuesMulti.xml
@@ -17,37 +17,31 @@
 -->
 
 <schema name="schema-docValuesMulti" version="1.6">
-  <types>
 
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
-         seconds part (.999) is optional.
-      -->
-    <fieldType name="date" class="solr.TrieDateField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
+       seconds part (.999) is optional.
+    -->
+  <fieldType name="date" class="solr.TrieDateField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
 
-    <fieldType name="boolean" class="solr.BoolField" />
-    <fieldType name="string" class="solr.StrField" />
+  <fieldType name="boolean" class="solr.BoolField"/>
+  <fieldType name="string" class="solr.StrField"/>
 
-    <fieldType name="uuid" class="solr.UUIDField" />
+  <fieldType name="uuid" class="solr.UUIDField"/>
 
-  </types>
 
+  <field name="id" type="string" required="true"/>
 
-  <fields>
+  <field name="floatdv" type="float" indexed="false" stored="false" docValues="true" multiValued="true"/>
+  <field name="intdv" type="int" indexed="false" stored="false" docValues="true" multiValued="true"/>
+  <field name="doubledv" type="double" indexed="false" stored="false" docValues="true" multiValued="true"/>
+  <field name="longdv" type="long" indexed="false" stored="false" docValues="true" multiValued="true"/>
+  <field name="datedv" type="date" indexed="false" stored="false" docValues="true" multiValued="true"/>
 
-    <field name="id" type="string" required="true" />
-
-    <field name="floatdv" type="float" indexed="false" stored="false" docValues="true" multiValued="true" />
-    <field name="intdv" type="int" indexed="false" stored="false" docValues="true" multiValued="true" />
-    <field name="doubledv" type="double" indexed="false" stored="false" docValues="true" multiValued="true" />
-    <field name="longdv" type="long" indexed="false" stored="false" docValues="true" multiValued="true" />
-    <field name="datedv" type="date" indexed="false" stored="false" docValues="true" multiValued="true" />
-
-    <field name="stringdv" type="string" indexed="false" stored="false" docValues="true" multiValued="true" />
-  </fields>
+  <field name="stringdv" type="string" indexed="false" stored="false" docValues="true" multiValued="true"/>
 
   <uniqueKey>id</uniqueKey>
 
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-eff.xml b/solr/core/src/test-files/solr/collection1/conf/schema-eff.xml
index 46f89cd..d68a3da 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-eff.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-eff.xml
@@ -19,27 +19,22 @@
 
 <schema name="example" version="1.6">
 
- <fields>
-        
-   <field name="id" type="string" indexed="true" stored="true" required="true" multiValued="false" />
-   <field name="eff" type="eff"/>
 
- </fields>
+  <field name="id" type="string" indexed="true" stored="true" required="true" multiValued="false"/>
+  <field name="eff" type="eff"/>
 
 
- <!-- Field to use to determine and enforce document uniqueness. 
-      Unless this field is marked with required="false", it will be a required field
-   -->
- <uniqueKey>id</uniqueKey>
+  <!-- Field to use to determine and enforce document uniqueness. 
+       Unless this field is marked with required="false", it will be a required field
+    -->
+  <uniqueKey>id</uniqueKey>
 
- <types>
 
-    <!-- The StrField type is not analyzed, but indexed/stored verbatim. -->
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true" />
+  <!-- The StrField type is not analyzed, but indexed/stored verbatim. -->
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
 
-    <!-- Our external file field type -->
-    <fieldType name="eff" class="solr.ExternalFileField"/>
+  <!-- Our external file field type -->
+  <fieldType name="eff" class="solr.ExternalFileField"/>
 
- </types>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-enums.xml b/solr/core/src/test-files/solr/collection1/conf/schema-enums.xml
index b736b89..b3a9515 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-enums.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-enums.xml
@@ -16,28 +16,24 @@
  limitations under the License.
 -->
 <schema name="tiny" version="1.1">
-  <fields>
-    <field name="id" type="string" indexed="true" stored="true" required="true"/>
-    <field name="_version_" type="long" indexed="true" stored="true" multiValued="false"/>
-    <!-- Test EnumField -->
-    <field name="severity" type="severityType" indexed="true" stored="true" multiValued="false"/>
-    <field name="severity_dv" type="severityType" indexed="true" stored="true" multiValued="false" docValues="true"/>
-    <field name="text" type="text" indexed="true" stored="true" multiValued="true"/>
-  </fields>
+  <field name="id" type="string" indexed="true" stored="true" required="true"/>
+  <field name="_version_" type="long" indexed="true" stored="true" multiValued="false"/>
+  <!-- Test EnumField -->
+  <field name="severity" type="severityType" indexed="true" stored="true" multiValued="false"/>
+  <field name="severity_dv" type="severityType" indexed="true" stored="true" multiValued="false" docValues="true"/>
+  <field name="text" type="text" indexed="true" stored="true" multiValued="true"/>
   <uniqueKey>id</uniqueKey>
 
-  <types>
-    <fieldType name="text" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <!-- note: you cannot change the order/existing values in enum without reindexing.
-         but you can always add new values to the end. -->
-    <fieldType name="severityType" class="solr.EnumField" enumsConfig="enumsConfig.xml" enumName="severity"/>
-    <fieldType name="string" class="solr.StrField"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="text" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <!-- note: you cannot change the order/existing values in enum without reindexing.
+       but you can always add new values to the end. -->
+  <fieldType name="severityType" class="solr.EnumField" enumsConfig="enumsConfig.xml" enumName="severity"/>
+  <fieldType name="string" class="solr.StrField"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
 
-  </types>
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-field-sort-values.xml b/solr/core/src/test-files/solr/collection1/conf/schema-field-sort-values.xml
index 3fdce47..f678663 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-field-sort-values.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-field-sort-values.xml
@@ -17,25 +17,21 @@
 -->
 
 <schema name="test-custom-comparator" version="1.6">
-  <types>
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
-    <fieldType name="text" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType class="org.apache.solr.schema.WrappedIntField" name="wrapped_int"/>
-  </types>
-  <fields>
-    <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
-    <field name="_version_" type="long" indexed="true" stored="true" multiValued="false"/>
-    <field name="text" type="text" indexed="true" stored="false"/>
-    <field name="payload" type="wrapped_int" indexed="false"
-           stored="true"  multiValued="false"    docValues="true" required="true"/>
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+  <fieldType name="text" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType class="org.apache.solr.schema.WrappedIntField" name="wrapped_int"/>
+  <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="_version_" type="long" indexed="true" stored="true" multiValued="false"/>
+  <field name="text" type="text" indexed="true" stored="false"/>
+  <field name="payload" type="wrapped_int" indexed="false"
+         stored="true" multiValued="false" docValues="true" required="true"/>
 
-  </fields>
   <defaultSearchField>text</defaultSearchField>
   <uniqueKey>id</uniqueKey>
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-folding.xml b/solr/core/src/test-files/solr/collection1/conf/schema-folding.xml
index 971a344..cc9cae3 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-folding.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-folding.xml
@@ -16,249 +16,245 @@
   -->
 
 <schema name="test" version="1.0">
-  <types>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true" multiValued="false"/>
-
-    <fieldType name="text" class="solr.TextField" multiValued="false">
-      <analyzer>
-        <tokenizer class="solr.PatternTokenizerFactory" pattern="\s+"/>
-        <filter class="solr.ASCIIFoldingFilterFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="text_multi" class="solr.TextField" multiValued="true">
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.ASCIIFoldingFilterFactory"/>
-        <filter class="solr.TrimFilterFactory"/>
-      </analyzer>
-      <analyzer type="multiterm">        <!-- Intentionally different to test that these are kept  distinct -->
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.ASCIIFoldingFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="text_multi_bad" class="solr.TextField" multiValued="false">
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.ASCIIFoldingFilterFactory"/>
-        <filter class="solr.TrimFilterFactory"/>
-      </analyzer>
-      <analyzer type="multiterm">        <!-- Intentionally different to test that these are kept  distinct -->
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
-                catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.ASCIIFoldingFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <fieldType name="text_ws" class="solr.TextField" multiValued="true">
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.ASCIIFoldingFilterFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="text_rev" class="solr.TextField">
-      <analyzer type="index">
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.ASCIIFoldingFilterFactory"/>
-        <filter class="solr.ReversedWildcardFilterFactory" withOriginal="false"
-                maxPosAsterisk="1" maxPosQuestion="2" maxFractionAsterisk="0.99"
-                minTrailing="1"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.ASCIIFoldingFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="text_lower_token" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.LowerCaseTokenizerFactory"/>
-        <filter class="solr.ASCIIFoldingFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="text_oldstyle" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.ASCIIFoldingFilterFactory"/>
-      </analyzer>
-      <analyzer type="multiterm">
-        <tokenizer class="solr.KeywordTokenizerFactory" />
-      </analyzer>
-    </fieldType>
-
-
-    <fieldType name="text_charfilter" class="solr.TextField" multiValued="false">
-      <analyzer type="index">
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.ASCIIFoldingFilterFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <charFilter class="solr.MappingCharFilterFactory" mapping="mapping-ISOLatin1Accent.txt"/>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="text_straight" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="text_lower" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="text_folding" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.ASCIIFoldingFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="text_stemming" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.ASCIIFoldingFilterFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="text_keyword" class="solr.TextField" sortMissingLast="true" omitNorms="true">
-      <analyzer>
-         <tokenizer class="solr.KeywordTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory" />
-      </analyzer>
-    </fieldType>
-
-
-    <fieldType name="text_greek" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.GreekLowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="text_turkish" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.TurkishLowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="text_russian" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    
-    <fieldType name="text_persian" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.PersianNormalizationFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    
-    <fieldType name="text_arabic" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.ArabicNormalizationFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    
-    <fieldType name="text_hindi" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.IndicNormalizationFilterFactory"/>
-        <filter class="solr.HindiNormalizationFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    
-    <fieldType name="text_german" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.GermanNormalizationFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    
-    <fieldType name="text_width" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.CJKWidthFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="text_fr" class="solr.TextField" positionIncrementGap="100">
-      <analyzer> 
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- removes l', etc -->
-        <filter class="solr.ElisionFilterFactory" ignoreCase="true" />
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.FrenchLightStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="4" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="float" class="solr.TrieFloatField" precisionStep="4" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="4" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="4" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
-    <fieldType name="date" class="solr.TrieDateField" precisionStep="0"/>
-  </types>
-
-  <fields>
-    <field name="id" type="string" indexed="true" stored="true" required="true"/>
-    <field name="int_f" type="int"/>
-    <field name="float_f" type="float"/>
-    <field name="long_f" type="long"/>
-    <field name="double_f" type="double"/>
-    <field name="bool_f" type="boolean"/>
-    <field name="date_f" type="date"/>
-
-    <field name="content" type="text" indexed="true" stored="true"/>
-    <field name="content_ws" type="text_ws" indexed="true" stored="true"/>
-    <field name="content_rev" type="text_rev" indexed="true" stored="true"/>
-    <field name="content_multi" type="text_multi" indexed="true" stored="true"/>
-    <field name="content_lower_token" type="text_lower_token" indexed="true" stored="true"/>
-    <field name="content_oldstyle" type="text_oldstyle" indexed="true" stored="true"/>
-    <field name="content_charfilter" type="text_charfilter" indexed="true" stored="true"/>
-    <field name="content_multi_bad" type="text_multi_bad" indexed="true" stored="true"/>
-    <field name="content_greek" type="text_greek" indexed="true" stored="true"/>
-    <field name="content_turkish" type="text_turkish" indexed="true" stored="true"/>
-    <field name="content_russian" type="text_russian" indexed="true" stored="true"/>
-    <field name="content_persian" type="text_persian" indexed="true" stored="true"/>
-    <field name="content_arabic" type="text_arabic" indexed="true" stored="true"/>
-    <field name="content_hindi" type="text_hindi" indexed="true" stored="true"/>
-    <field name="content_german" type="text_german" indexed="true" stored="true"/>
-    <field name="content_width" type="text_width" indexed="true" stored="true"/>
-
-    <dynamicField name="*_straight" type="text_straight" indexed="true" stored="true"/>
-    <dynamicField name="*_lower" type="text_lower" indexed="true" stored="true"/>
-    <dynamicField name="*_folding" type="text_folding" indexed="true" stored="true"/>
-    <dynamicField name="*_stemming" type="text_stemming" indexed="true" stored="true"/>
-    <dynamicField name="*_keyword" type="text_keyword" indexed="true" stored="true"/>
-    <dynamicField name="*_fr" type="text_fr" indexed="true" stored="true"/>
-
-  </fields>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true" multiValued="false"/>
+
+  <fieldType name="text" class="solr.TextField" multiValued="false">
+    <analyzer>
+      <tokenizer class="solr.PatternTokenizerFactory" pattern="\s+"/>
+      <filter class="solr.ASCIIFoldingFilterFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="text_multi" class="solr.TextField" multiValued="true">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.ASCIIFoldingFilterFactory"/>
+      <filter class="solr.TrimFilterFactory"/>
+    </analyzer>
+    <analyzer type="multiterm">        <!-- Intentionally different to test that these are kept  distinct -->
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.ASCIIFoldingFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="text_multi_bad" class="solr.TextField" multiValued="false">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.ASCIIFoldingFilterFactory"/>
+      <filter class="solr.TrimFilterFactory"/>
+    </analyzer>
+    <analyzer type="multiterm">        <!-- Intentionally different to test that these are kept  distinct -->
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.ASCIIFoldingFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <fieldType name="text_ws" class="solr.TextField" multiValued="true">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.ASCIIFoldingFilterFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="text_rev" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.ASCIIFoldingFilterFactory"/>
+      <filter class="solr.ReversedWildcardFilterFactory" withOriginal="false"
+              maxPosAsterisk="1" maxPosQuestion="2" maxFractionAsterisk="0.99"
+              minTrailing="1"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.ASCIIFoldingFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="text_lower_token" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LowerCaseTokenizerFactory"/>
+      <filter class="solr.ASCIIFoldingFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="text_oldstyle" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.ASCIIFoldingFilterFactory"/>
+    </analyzer>
+    <analyzer type="multiterm">
+      <tokenizer class="solr.KeywordTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <fieldType name="text_charfilter" class="solr.TextField" multiValued="false">
+    <analyzer type="index">
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.ASCIIFoldingFilterFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <charFilter class="solr.MappingCharFilterFactory" mapping="mapping-ISOLatin1Accent.txt"/>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="text_straight" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="text_lower" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="text_folding" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.ASCIIFoldingFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="text_stemming" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.ASCIIFoldingFilterFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="text_keyword" class="solr.TextField" sortMissingLast="true" omitNorms="true">
+    <analyzer>
+      <tokenizer class="solr.KeywordTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <fieldType name="text_greek" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.GreekLowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="text_turkish" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.TurkishLowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="text_russian" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="text_persian" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.PersianNormalizationFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="text_arabic" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.ArabicNormalizationFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="text_hindi" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.IndicNormalizationFilterFactory"/>
+      <filter class="solr.HindiNormalizationFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="text_german" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.GermanNormalizationFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="text_width" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.CJKWidthFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="text_fr" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- removes l', etc -->
+      <filter class="solr.ElisionFilterFactory" ignoreCase="true"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.FrenchLightStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="4" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="float" class="solr.TrieFloatField" precisionStep="4" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="4" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="4" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
+  <fieldType name="date" class="solr.TrieDateField" precisionStep="0"/>
+
+  <field name="id" type="string" indexed="true" stored="true" required="true"/>
+  <field name="int_f" type="int"/>
+  <field name="float_f" type="float"/>
+  <field name="long_f" type="long"/>
+  <field name="double_f" type="double"/>
+  <field name="bool_f" type="boolean"/>
+  <field name="date_f" type="date"/>
+
+  <field name="content" type="text" indexed="true" stored="true"/>
+  <field name="content_ws" type="text_ws" indexed="true" stored="true"/>
+  <field name="content_rev" type="text_rev" indexed="true" stored="true"/>
+  <field name="content_multi" type="text_multi" indexed="true" stored="true"/>
+  <field name="content_lower_token" type="text_lower_token" indexed="true" stored="true"/>
+  <field name="content_oldstyle" type="text_oldstyle" indexed="true" stored="true"/>
+  <field name="content_charfilter" type="text_charfilter" indexed="true" stored="true"/>
+  <field name="content_multi_bad" type="text_multi_bad" indexed="true" stored="true"/>
+  <field name="content_greek" type="text_greek" indexed="true" stored="true"/>
+  <field name="content_turkish" type="text_turkish" indexed="true" stored="true"/>
+  <field name="content_russian" type="text_russian" indexed="true" stored="true"/>
+  <field name="content_persian" type="text_persian" indexed="true" stored="true"/>
+  <field name="content_arabic" type="text_arabic" indexed="true" stored="true"/>
+  <field name="content_hindi" type="text_hindi" indexed="true" stored="true"/>
+  <field name="content_german" type="text_german" indexed="true" stored="true"/>
+  <field name="content_width" type="text_width" indexed="true" stored="true"/>
+
+  <dynamicField name="*_straight" type="text_straight" indexed="true" stored="true"/>
+  <dynamicField name="*_lower" type="text_lower" indexed="true" stored="true"/>
+  <dynamicField name="*_folding" type="text_folding" indexed="true" stored="true"/>
+  <dynamicField name="*_stemming" type="text_stemming" indexed="true" stored="true"/>
+  <dynamicField name="*_keyword" type="text_keyword" indexed="true" stored="true"/>
+  <dynamicField name="*_fr" type="text_fr" indexed="true" stored="true"/>
+
 
   <defaultSearchField>content</defaultSearchField>
   <uniqueKey>id</uniqueKey>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-hash.xml b/solr/core/src/test-files/solr/collection1/conf/schema-hash.xml
index ec36dc6..b132473 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-hash.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-hash.xml
@@ -26,540 +26,561 @@
   -->
 
 <schema name="test" version="1.6">
-  <types>
-
-    <!-- field type definitions... note that the "name" attribute is
-         just a label to be used by field definitions.  The "class"
-         attribute and any other attributes determine the real type and
-         behavior of the fieldtype.
-      -->
-
-    <!-- numeric field types that store and index the text
-         value verbatim (and hence don't sort correctly or support range queries.)
-         These are provided more for backward compatability, allowing one
-         to create a schema that matches an existing lucene index.
-    -->
 
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0" docValues="true"/>
-    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0" docValues="true"/>
-    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-
-    <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
-
-    <!-- numeric field types that manipulate the value into
-       a string value that isn't human readable in it's internal form,
-       but sorts correctly and supports range queries.
-
-         If sortMissingLast="true" then a sort on this field will cause documents
-       without the field to come after documents with the field,
-       regardless of the requested sort order.
-         If sortMissingFirst="true" then a sort on this field will cause documents
-       without the field to come before documents with the field,
-       regardless of the requested sort order.
-         If sortMissingLast="false" and sortMissingFirst="false" (the default),
-       then default lucene sorting will be used which places docs without the field
-       first in an ascending sort and last in a descending sort.
+
+  <!-- field type definitions... note that the "name" attribute is
+       just a label to be used by field definitions.  The "class"
+       attribute and any other attributes determine the real type and
+       behavior of the fieldtype.
     -->
 
+  <!-- numeric field types that store and index the text
+       value verbatim (and hence don't sort correctly or support range queries.)
+       These are provided more for backward compatability, allowing one
+       to create a schema that matches an existing lucene index.
+  -->
 
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"
+             docValues="true"/>
+  <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"
+             docValues="true"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+
+  <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+
+  <!-- numeric field types that manipulate the value into
+     a string value that isn't human readable in it's internal form,
+     but sorts correctly and supports range queries.
+
+       If sortMissingLast="true" then a sort on this field will cause documents
+     without the field to come after documents with the field,
+     regardless of the requested sort order.
+       If sortMissingFirst="true" then a sort on this field will cause documents
+     without the field to come before documents with the field,
+     regardless of the requested sort order.
+       If sortMissingLast="false" and sortMissingFirst="false" (the default),
+     then default lucene sorting will be used which places docs without the field
+     first in an ascending sort and last in a descending sort.
+  -->
 
-    <!-- Field type demonstrating an Analyzer failure -->
-    <fieldtype name="failtype1" class="solr.TextField">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-
-    <!-- Demonstrating ignoreCaseChange -->
-    <fieldtype name="wdf_nocase" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-
-    <fieldtype name="wdf_preserve" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-
-
-    <fieldtype name="boolean" class="solr.BoolField" sortMissingLast="true"/>
-    <fieldtype name="string" class="solr.StrField" sortMissingLast="true" docValues="true"/>
-
-    <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
-         seconds part (.999) is optional.
-      -->
-    <fieldtype name="date" class="solr.TrieDateField" precisionStep="0"/>
-    <fieldtype name="tdate" class="solr.TrieDateField" precisionStep="6"/>
-
-
-    <!-- solr.TextField allows the specification of custom
-         text analyzers specified as a tokenizer and a list
-         of token filters.
-      -->
-    <fieldtype name="text" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-
-
-    <fieldtype name="nametext" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.core.WhitespaceAnalyzer"/>
-    </fieldtype>
-
-    <fieldtype name="teststop" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.LowerCaseTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-
-    <!-- fieldtypes in this section isolate tokenizers and tokenfilters for testing -->
-    <fieldtype name="lowertok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.LowerCaseTokenizerFactory"/></analyzer>
-    </fieldtype>
-    <fieldtype name="keywordtok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/></analyzer>
-    </fieldtype>
-    <fieldtype name="standardtok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.StandardTokenizerFactory"/></analyzer>
-    </fieldtype>
-    <fieldtype name="lettertok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.LetterTokenizerFactory"/></analyzer>
-    </fieldtype>
-    <fieldtype name="whitetok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.MockTokenizerFactory"/></analyzer>
-    </fieldtype>
-    <fieldtype name="HTMLstandardtok" class="solr.TextField">
-      <analyzer>
-        <charFilter class="solr.HTMLStripCharFilterFactory"/>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="HTMLwhitetok" class="solr.TextField">
-      <analyzer>
-        <charFilter class="solr.HTMLStripCharFilterFactory"/>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="standardtokfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="standardfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="lowerfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="lowerpunctfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="1" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="patternreplacefilt" class="solr.TextField">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
-        <filter class="solr.PatternReplaceFilterFactory"
-                pattern="([^a-zA-Z])" replacement="_" replace="all"
-            />
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="patterntok" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.PatternTokenizerFactory" pattern=","/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="porterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-    <!-- fieldtype name="snowballfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.SnowballPorterFilterFactory"/>
-      </analyzer>
-    </fieldtype -->
-    <fieldtype name="engporterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="custengporterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="stopfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true"/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="custstopfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="lengthfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LengthFilterFactory" min="2" max="5"/>
-      </analyzer>
-    </fieldtype>
-    <fieldType name="charfilthtmlmap" class="solr.TextField">
-      <analyzer>
-        <charFilter class="solr.HTMLStripCharFilterFactory"/>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldtype name="subword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-
-    <fieldtype name="numericsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-        <filter class="solr.StopFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-        <filter class="solr.StopFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-
-    <fieldtype name="protectedsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory"  splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-
-
-    <!-- more flexible in matching skus, but more chance of a false match -->
-    <fieldtype name="skutype1" class="solr.TextField">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-
-    <!-- less flexible in matching skus, but less chance of a false match -->
-    <fieldtype name="skutype2" class="solr.TextField">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-
-    <!-- less flexible in matching skus, but less chance of a false match -->
-    <fieldtype name="syn" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldtype>
-
-
-    <fieldtype  name="unstored" class="solr.StrField" indexed="true" stored="false"/>
-
-
-    <fieldtype name="textgap" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-
-    <fieldType name="uuid" class="solr.UUIDField" />
-
-    <!-- Try out some point types -->
-    <fieldType name="xy" class="solr.PointType" dimension="2" subFieldType="double"/>
-    <fieldType name="x" class="solr.PointType" dimension="1" subFieldType="double"/>
-    <fieldType name="tenD" class="solr.PointType" dimension="10" subFieldType="double"/>
-    <!-- Use the sub field suffix -->
-    <fieldType name="xyd" class="solr.PointType" dimension="2" subFieldSuffix="_d1"/>
-    <fieldtype name="geohash" class="solr.GeoHashField"/>
-
-
-    <fieldType name="latLon" class="solr.LatLonType" subFieldType="double"/>
-
-    <!--  some per-field similarity examples -->
-
-    <!--  specify a Similarity classname directly -->
-    <!--
-    <fieldType name="sim1" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-      <similarity class="org.apache.lucene.misc.SweetSpotSimilarity"/>
-    </fieldType>
-    -->
-    <!--  specify a Similarity factory -->
-    <!--
-    <fieldType name="sim2" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-      <similarity class="org.apache.solr.search.similarities.CustomSimilarityFactory">
-        <str name="echo">is there an echo?</str>
-      </similarity>
-    </fieldType>
-    -->
-    <!-- don't specify any sim at all: get the default  -->
-    <!--
-    <fieldType name="sim3" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
+
+  <!-- Field type demonstrating an Analyzer failure -->
+  <fieldtype name="failtype1" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0"
+              catenateNumbers="0" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+
+  <!-- Demonstrating ignoreCaseChange -->
+  <fieldtype name="wdf_nocase" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+
+  <fieldtype name="wdf_preserve" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+
+
+  <fieldtype name="boolean" class="solr.BoolField" sortMissingLast="true"/>
+  <fieldtype name="string" class="solr.StrField" sortMissingLast="true" docValues="true"/>
+
+  <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
+       seconds part (.999) is optional.
     -->
-  </types>
-
-
-  <fields>
-    <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
-    <field name="signatureField" type="string" indexed="true" stored="false"/>
-    <field name="uuid" type="uuid" stored="true" />
-    <field name="name" type="nametext" indexed="true" stored="true"/>
-    <field name="text" type="text" indexed="true" stored="false"/>
-    <field name="subject" type="text" indexed="true" stored="true"/>
-    <field name="title" type="nametext" indexed="true" stored="true"/>
-    <field name="weight" type="float" indexed="true" stored="true" multiValued="false"/>
-    <field name="bday" type="date" indexed="true" stored="true" multiValued="false"/>
-
-    <field name="title_stemmed" type="text" indexed="true" stored="false"/>
-    <field name="title_lettertok" type="lettertok" indexed="true" stored="false"/>
-
-    <field name="syn" type="syn" indexed="true" stored="true"/>
-
-    <!-- to test property inheritance and overriding -->
-    <field name="shouldbeunstored" type="unstored" />
-    <field name="shouldbestored" type="unstored" stored="true"/>
-    <field name="shouldbeunindexed" type="unstored" indexed="false" stored="true"/>
-
-    <!-- Test points -->
-    <!-- Test points -->
-    <field name="home" type="xy" indexed="true" stored="true" multiValued="false"/>
-    <field name="x" type="x" indexed="true" stored="true" multiValued="false"/>
-    <field name="homed" type="xyd" indexed="true" stored="true" multiValued="false"/>
-    <field name="home_ns" type="xy" indexed="true" stored="false" multiValued="false"/>
-    <field name="work" type="xy" indexed="true" stored="true" multiValued="false"/>
-
-    <field name="home_ll" type="latLon" indexed="true" stored="true" multiValued="false"/>
-    <field name="home_gh" type="geohash" indexed="true" stored="true" multiValued="false"/>
-
-
-    <field name="point10" type="tenD" indexed="true" stored="true" multiValued="false"/>
-
-
-    <!-- test different combinations of indexed and stored -->
-    <field name="bind" type="boolean" indexed="true" stored="false"/>
-    <field name="bsto" type="boolean" indexed="false" stored="true"/>
-    <field name="bindsto" type="boolean" indexed="true" stored="true"/>
-    <field name="isto" type="int" indexed="false" stored="true"/>
-    <field name="iind" type="int" indexed="true" stored="false"/>
-    <field name="ssto" type="string" indexed="false" stored="true"/>
-    <field name="sind" type="string" indexed="true" stored="false"/>
-    <field name="sindsto" type="string" indexed="true" stored="true"/>
-
-    <!-- test combinations of term vector settings -->
-    <field name="test_basictv" type="text" termVectors="true"/>
-    <field name="test_notv" type="text" termVectors="false"/>
-    <field name="test_postv" type="text" termVectors="true" termPositions="true"/>
-    <field name="test_offtv" type="text" termVectors="true" termOffsets="true"/>
-    <field name="test_posofftv" type="text" termVectors="true"
-           termPositions="true" termOffsets="true"/>
-
-    <!-- fields to test individual tokenizers and tokenfilters -->
-    <field name="teststop" type="teststop" indexed="true" stored="true"/>
-    <field name="lowertok" type="lowertok" indexed="true" stored="true"/>
-    <field name="keywordtok" type="keywordtok" indexed="true" stored="true"/>
-    <field name="standardtok" type="standardtok" indexed="true" stored="true"/>
-    <field name="HTMLstandardtok" type="HTMLstandardtok" indexed="true" stored="true"/>
-    <field name="lettertok" type="lettertok" indexed="true" stored="true"/>
-    <field name="whitetok" type="whitetok" indexed="true" stored="true"/>
-    <field name="HTMLwhitetok" type="HTMLwhitetok" indexed="true" stored="true"/>
-    <field name="standardtokfilt" type="standardtokfilt" indexed="true" stored="true"/>
-    <field name="standardfilt" type="standardfilt" indexed="true" stored="true"/>
-    <field name="lowerfilt" type="lowerfilt" indexed="true" stored="true"/>
-    <field name="lowerfilt1" type="lowerfilt" indexed="true" stored="true"/>
-    <field name="lowerfilt1and2" type="lowerfilt" indexed="true" stored="true"/>
-    <field name="patterntok" type="patterntok" indexed="true" stored="true"/>
-    <field name="patternreplacefilt" type="patternreplacefilt" indexed="true" stored="true"/>
-    <field name="porterfilt" type="porterfilt" indexed="true" stored="true"/>
-    <field name="engporterfilt" type="engporterfilt" indexed="true" stored="true"/>
-    <field name="custengporterfilt" type="custengporterfilt" indexed="true" stored="true"/>
-    <field name="stopfilt" type="stopfilt" indexed="true" stored="true"/>
-    <field name="custstopfilt" type="custstopfilt" indexed="true" stored="true"/>
-    <field name="lengthfilt" type="lengthfilt" indexed="true" stored="true"/>
-    <field name="wdf_nocase" type="wdf_nocase" indexed="true" stored="true"/>
-    <field name="wdf_preserve" type="wdf_preserve" indexed="true" stored="true"/>
-
-    <field name="numberpartfail" type="failtype1" indexed="true" stored="true"/>
-
-    <field name="nullfirst" type="string" indexed="true" stored="true" sortMissingFirst="true" multiValued="false"/>
-
-    <field name="subword" type="subword" indexed="true" stored="true"/>
-    <field name="subword_offsets" type="subword" indexed="true" stored="true" termOffsets="true"/>
-    <field name="numericsubword" type="numericsubword" indexed="true" stored="true"/>
-    <field name="protectedsubword" type="protectedsubword" indexed="true" stored="true"/>
-
-    <field name="sku1" type="skutype1" indexed="true" stored="true"/>
-    <field name="sku2" type="skutype2" indexed="true" stored="true"/>
-
-    <field name="textgap" type="textgap" indexed="true" stored="true"/>
-
-    <field name="timestamp" type="date" indexed="true" stored="true" default="NOW" multiValued="false"/>
-    <field name="multiDefault" type="string" indexed="true" stored="true" default="muLti-Default" multiValued="true"/>
-    <field name="intDefault" type="int" indexed="true" stored="true" default="42" multiValued="false"/>
-
-    <!--
-    <field name="sim1text" type="sim1" indexed="true" stored="true"/>
-    <field name="sim2text" type="sim2" indexed="true" stored="true"/>
-    <field name="sim3text" type="sim3" indexed="true" stored="true"/>
+  <fieldtype name="date" class="solr.TrieDateField" precisionStep="0"/>
+  <fieldtype name="tdate" class="solr.TrieDateField" precisionStep="6"/>
+
+
+  <!-- solr.TextField allows the specification of custom
+       text analyzers specified as a tokenizer and a list
+       of token filters.
     -->
+  <fieldtype name="text" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+
+
+  <fieldtype name="nametext" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.core.WhitespaceAnalyzer"/>
+  </fieldtype>
+
+  <fieldtype name="teststop" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LowerCaseTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+
+  <!-- fieldtypes in this section isolate tokenizers and tokenfilters for testing -->
+  <fieldtype name="lowertok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LowerCaseTokenizerFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="keywordtok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="standardtok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="lettertok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LetterTokenizerFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="whitetok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="HTMLstandardtok" class="solr.TextField">
+    <analyzer>
+      <charFilter class="solr.HTMLStripCharFilterFactory"/>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="HTMLwhitetok" class="solr.TextField">
+    <analyzer>
+      <charFilter class="solr.HTMLStripCharFilterFactory"/>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="standardtokfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="standardfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="lowerfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="lowerpunctfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="1" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="patternreplacefilt" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+      <filter class="solr.PatternReplaceFilterFactory"
+              pattern="([^a-zA-Z])" replacement="_" replace="all"
+      />
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="patterntok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.PatternTokenizerFactory" pattern=","/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="porterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+  <!-- fieldtype name="snowballfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SnowballPorterFilterFactory"/>
+    </analyzer>
+  </fieldtype -->
+  <fieldtype name="engporterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="custengporterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="stopfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="custstopfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="lengthfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LengthFilterFactory" min="2" max="5"/>
+    </analyzer>
+  </fieldtype>
+  <fieldType name="charfilthtmlmap" class="solr.TextField">
+    <analyzer>
+      <charFilter class="solr.HTMLStripCharFilterFactory"/>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldtype name="subword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+
+  <fieldtype name="numericsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1"
+              generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1"
+              generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+
+  <fieldtype name="protectedsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1"
+              generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+
+
+  <!-- more flexible in matching skus, but more chance of a false match -->
+  <fieldtype name="skutype1" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+
+  <!-- less flexible in matching skus, but less chance of a false match -->
+  <fieldtype name="skutype2" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+
+  <!-- less flexible in matching skus, but less chance of a false match -->
+  <fieldtype name="syn" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldtype>
+
+
+  <fieldtype name="unstored" class="solr.StrField" indexed="true" stored="false"/>
+
+
+  <fieldtype name="textgap" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+
+  <fieldType name="uuid" class="solr.UUIDField"/>
+
+  <!-- Try out some point types -->
+  <fieldType name="xy" class="solr.PointType" dimension="2" subFieldType="double"/>
+  <fieldType name="x" class="solr.PointType" dimension="1" subFieldType="double"/>
+  <fieldType name="tenD" class="solr.PointType" dimension="10" subFieldType="double"/>
+  <!-- Use the sub field suffix -->
+  <fieldType name="xyd" class="solr.PointType" dimension="2" subFieldSuffix="_d1"/>
+  <fieldtype name="geohash" class="solr.GeoHashField"/>
+
+
+  <fieldType name="latLon" class="solr.LatLonType" subFieldType="double"/>
+
+  <!--  some per-field similarity examples -->
+
+  <!--  specify a Similarity classname directly -->
+  <!--
+  <fieldType name="sim1" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+    <similarity class="org.apache.lucene.misc.SweetSpotSimilarity"/>
+  </fieldType>
+  -->
+  <!--  specify a Similarity factory -->
+  <!--
+  <fieldType name="sim2" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+    <similarity class="org.apache.solr.search.similarities.CustomSimilarityFactory">
+      <str name="echo">is there an echo?</str>
+    </similarity>
+  </fieldType>
+  -->
+  <!-- don't specify any sim at all: get the default  -->
+  <!--
+  <fieldType name="sim3" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  -->
 
-    <field name="tlong" type="tlong" indexed="true" stored="true" />
 
-    <field name="_version_" type="long" indexed="true" stored="true"/>
+  <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="signatureField" type="string" indexed="true" stored="false"/>
+  <field name="uuid" type="uuid" stored="true"/>
+  <field name="name" type="nametext" indexed="true" stored="true"/>
+  <field name="text" type="text" indexed="true" stored="false"/>
+  <field name="subject" type="text" indexed="true" stored="true"/>
+  <field name="title" type="nametext" indexed="true" stored="true"/>
+  <field name="weight" type="float" indexed="true" stored="true" multiValued="false"/>
+  <field name="bday" type="date" indexed="true" stored="true" multiValued="false"/>
+
+  <field name="title_stemmed" type="text" indexed="true" stored="false"/>
+  <field name="title_lettertok" type="lettertok" indexed="true" stored="false"/>
+
+  <field name="syn" type="syn" indexed="true" stored="true"/>
+
+  <!-- to test property inheritance and overriding -->
+  <field name="shouldbeunstored" type="unstored"/>
+  <field name="shouldbestored" type="unstored" stored="true"/>
+  <field name="shouldbeunindexed" type="unstored" indexed="false" stored="true"/>
+
+  <!-- Test points -->
+  <!-- Test points -->
+  <field name="home" type="xy" indexed="true" stored="true" multiValued="false"/>
+  <field name="x" type="x" indexed="true" stored="true" multiValued="false"/>
+  <field name="homed" type="xyd" indexed="true" stored="true" multiValued="false"/>
+  <field name="home_ns" type="xy" indexed="true" stored="false" multiValued="false"/>
+  <field name="work" type="xy" indexed="true" stored="true" multiValued="false"/>
+
+  <field name="home_ll" type="latLon" indexed="true" stored="true" multiValued="false"/>
+  <field name="home_gh" type="geohash" indexed="true" stored="true" multiValued="false"/>
+
+
+  <field name="point10" type="tenD" indexed="true" stored="true" multiValued="false"/>
+
+
+  <!-- test different combinations of indexed and stored -->
+  <field name="bind" type="boolean" indexed="true" stored="false"/>
+  <field name="bsto" type="boolean" indexed="false" stored="true"/>
+  <field name="bindsto" type="boolean" indexed="true" stored="true"/>
+  <field name="isto" type="int" indexed="false" stored="true"/>
+  <field name="iind" type="int" indexed="true" stored="false"/>
+  <field name="ssto" type="string" indexed="false" stored="true"/>
+  <field name="sind" type="string" indexed="true" stored="false"/>
+  <field name="sindsto" type="string" indexed="true" stored="true"/>
+
+  <!-- test combinations of term vector settings -->
+  <field name="test_basictv" type="text" termVectors="true"/>
+  <field name="test_notv" type="text" termVectors="false"/>
+  <field name="test_postv" type="text" termVectors="true" termPositions="true"/>
+  <field name="test_offtv" type="text" termVectors="true" termOffsets="true"/>
+  <field name="test_posofftv" type="text" termVectors="true"
+         termPositions="true" termOffsets="true"/>
+
+  <!-- fields to test individual tokenizers and tokenfilters -->
+  <field name="teststop" type="teststop" indexed="true" stored="true"/>
+  <field name="lowertok" type="lowertok" indexed="true" stored="true"/>
+  <field name="keywordtok" type="keywordtok" indexed="true" stored="true"/>
+  <field name="standardtok" type="standardtok" indexed="true" stored="true"/>
+  <field name="HTMLstandardtok" type="HTMLstandardtok" indexed="true" stored="true"/>
+  <field name="lettertok" type="lettertok" indexed="true" stored="true"/>
+  <field name="whitetok" type="whitetok" indexed="true" stored="true"/>
+  <field name="HTMLwhitetok" type="HTMLwhitetok" indexed="true" stored="true"/>
+  <field name="standardtokfilt" type="standardtokfilt" indexed="true" stored="true"/>
+  <field name="standardfilt" type="standardfilt" indexed="true" stored="true"/>
+  <field name="lowerfilt" type="lowerfilt" indexed="true" stored="true"/>
+  <field name="lowerfilt1" type="lowerfilt" indexed="true" stored="true"/>
+  <field name="lowerfilt1and2" type="lowerfilt" indexed="true" stored="true"/>
+  <field name="patterntok" type="patterntok" indexed="true" stored="true"/>
+  <field name="patternreplacefilt" type="patternreplacefilt" indexed="true" stored="true"/>
+  <field name="porterfilt" type="porterfilt" indexed="true" stored="true"/>
+  <field name="engporterfilt" type="engporterfilt" indexed="true" stored="true"/>
+  <field name="custengporterfilt" type="custengporterfilt" indexed="true" stored="true"/>
+  <field name="stopfilt" type="stopfilt" indexed="true" stored="true"/>
+  <field name="custstopfilt" type="custstopfilt" indexed="true" stored="true"/>
+  <field name="lengthfilt" type="lengthfilt" indexed="true" stored="true"/>
+  <field name="wdf_nocase" type="wdf_nocase" indexed="true" stored="true"/>
+  <field name="wdf_preserve" type="wdf_preserve" indexed="true" stored="true"/>
+
+  <field name="numberpartfail" type="failtype1" indexed="true" stored="true"/>
+
+  <field name="nullfirst" type="string" indexed="true" stored="true" sortMissingFirst="true" multiValued="false"/>
+
+  <field name="subword" type="subword" indexed="true" stored="true"/>
+  <field name="subword_offsets" type="subword" indexed="true" stored="true" termOffsets="true"/>
+  <field name="numericsubword" type="numericsubword" indexed="true" stored="true"/>
+  <field name="protectedsubword" type="protectedsubword" indexed="true" stored="true"/>
+
+  <field name="sku1" type="skutype1" indexed="true" stored="true"/>
+  <field name="sku2" type="skutype2" indexed="true" stored="true"/>
+
+  <field name="textgap" type="textgap" indexed="true" stored="true"/>
+
+  <field name="timestamp" type="date" indexed="true" stored="true" default="NOW" multiValued="false"/>
+  <field name="multiDefault" type="string" indexed="true" stored="true" default="muLti-Default" multiValued="true"/>
+  <field name="intDefault" type="int" indexed="true" stored="true" default="42" multiValued="false"/>
+
+  <!--
+  <field name="sim1text" type="sim1" indexed="true" stored="true"/>
+  <field name="sim2text" type="sim2" indexed="true" stored="true"/>
+  <field name="sim3text" type="sim3" indexed="true" stored="true"/>
+  -->
 
-    <!-- Dynamic field definitions.  If a field name is not found, dynamicFields
-         will be used if the name matches any of the patterns.
-         RESTRICTION: the glob-like pattern in the name attribute must have
-         a "*" only at the start or the end.
-         EXAMPLE:  name="*_i" will match any field ending in _i (like myid_i, z_i)
-         Longer patterns will be matched first.  if equal size patterns
-         both match, the first appearing in the schema will be used.
-    -->
-    <dynamicField name="*_i"  type="int"    indexed="true"  stored="true"/>
-    <dynamicField name="*_i1"  type="int"    indexed="true" stored="true" multiValued="false"/>
-
-    <dynamicField name="*_s"  type="string"  indexed="true"  stored="true"/>
-    <dynamicField name="*_s1"  type="string"  indexed="true"  stored="true" multiValued="false"/>
-    <dynamicField name="*_l"  type="long"   indexed="true"  stored="true"/>
-    <dynamicField name="*_l1"  type="long"   indexed="true"  stored="true" multiValued="false"/>
-    <dynamicField name="*_t"  type="text"    indexed="true"  stored="true"/>
-    <dynamicField name="*_b"  type="boolean" indexed="true"  stored="true"/>
-    <dynamicField name="*_f"  type="float"  indexed="true"  stored="true"/>
-    <dynamicField name="*_f1"  type="float"  indexed="true"  stored="true" multiValued="false"/>
-    <dynamicField name="*_d"  type="double" indexed="true"  stored="true"/>
-    <dynamicField name="*_d1"  type="double" indexed="true"  stored="true" multiValued="false"/>
-    <dynamicField name="*_dt" type="date"    indexed="true"  stored="true"/>
-    <dynamicField name="*_dt1" type="date"    indexed="true"  stored="true" multiValued="false"/>
-
-    <!-- some trie-coded dynamic fields for faster range queries -->
-    <dynamicField name="*_ti" type="tint"    indexed="true"  stored="true"/>
-    <dynamicField name="*_ti1" type="tint"    indexed="true"  stored="true" multiValued="false"/>
-    <dynamicField name="*_tl" type="tlong"   indexed="true"  stored="true"/>
-    <dynamicField name="*_tl1" type="tlong"   indexed="true"  stored="true" multiValued="false"/>
-    <dynamicField name="*_tf" type="tfloat"  indexed="true"  stored="true"/>
-    <dynamicField name="*_tf1" type="tfloat"  indexed="true"  stored="true" multiValued="false"/>
-    <dynamicField name="*_td" type="tdouble" indexed="true"  stored="true"/>
-    <dynamicField name="*_td1" type="tdouble" indexed="true" stored="true" multiValued="false"/>
-    <dynamicField name="*_tds" type="tdouble" indexed="true" stored="true" multiValued="false"/>
-    <dynamicField name="*_tdt" type="tdate"  indexed="true"  stored="true"/>
-    <dynamicField name="*_tdt1" type="tdate"  indexed="true"  stored="true" multiValued="false"/>
-
-
-    <dynamicField name="*_sI" type="string"  indexed="true"  stored="false"/>
-    <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
-    <dynamicField name="t_*"  type="text"    indexed="true"  stored="true"/>
-    <dynamicField name="tv_*"  type="text" indexed="true"  stored="true"
-                  termVectors="true" termPositions="true" termOffsets="true"/>
-    <dynamicField name="tv_mv_*"  type="text" indexed="true"  stored="true" multiValued="true"
-                  termVectors="true" termPositions="true" termOffsets="true"/>
-
-    <dynamicField name="*_p"  type="xyd" indexed="true"  stored="true" multiValued="false"/>
-
-    <!-- special fields for dynamic copyField test -->
-    <dynamicField name="dynamic_*" type="string" indexed="true" stored="true"/>
-    <dynamicField name="*_dynamic" type="string" indexed="true" stored="true"/>
-
-    <!-- for testing to ensure that longer patterns are matched first -->
-    <dynamicField name="*aa"  type="string"  indexed="true" stored="true"/>
-
-    <!-- ignored becuase not stored or indexed -->
-    <dynamicField name="*_ignored" type="text" indexed="false" stored="false"/>
-
-    <dynamicField name="*_mfacet" type="string" indexed="true" stored="false" multiValued="true" />
-
-    <!-- make sure custom sims work with dynamic fields -->
-    <!--
-    <dynamicField name="*_sim1" type="sim1" indexed="true" stored="true"/>
-    <dynamicField name="*_sim2" type="sim2" indexed="true" stored="true"/>
-    <dynamicField name="*_sim3" type="sim3" indexed="true" stored="true"/>
-    -->
-  </fields>
+  <field name="tlong" type="tlong" indexed="true" stored="true"/>
+
+  <field name="_version_" type="long" indexed="true" stored="true"/>
+
+  <!-- Dynamic field definitions.  If a field name is not found, dynamicFields
+       will be used if the name matches any of the patterns.
+       RESTRICTION: the glob-like pattern in the name attribute must have
+       a "*" only at the start or the end.
+       EXAMPLE:  name="*_i" will match any field ending in _i (like myid_i, z_i)
+       Longer patterns will be matched first.  if equal size patterns
+       both match, the first appearing in the schema will be used.
+  -->
+  <dynamicField name="*_i" type="int" indexed="true" stored="true"/>
+  <dynamicField name="*_i1" type="int" indexed="true" stored="true" multiValued="false"/>
+
+  <dynamicField name="*_s" type="string" indexed="true" stored="true"/>
+  <dynamicField name="*_s1" type="string" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_l" type="long" indexed="true" stored="true"/>
+  <dynamicField name="*_l1" type="long" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_t" type="text" indexed="true" stored="true"/>
+  <dynamicField name="*_b" type="boolean" indexed="true" stored="true"/>
+  <dynamicField name="*_f" type="float" indexed="true" stored="true"/>
+  <dynamicField name="*_f1" type="float" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_d" type="double" indexed="true" stored="true"/>
+  <dynamicField name="*_d1" type="double" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_dt" type="date" indexed="true" stored="true"/>
+  <dynamicField name="*_dt1" type="date" indexed="true" stored="true" multiValued="false"/>
+
+  <!-- some trie-coded dynamic fields for faster range queries -->
+  <dynamicField name="*_ti" type="tint" indexed="true" stored="true"/>
+  <dynamicField name="*_ti1" type="tint" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_tl" type="tlong" indexed="true" stored="true"/>
+  <dynamicField name="*_tl1" type="tlong" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_tf" type="tfloat" indexed="true" stored="true"/>
+  <dynamicField name="*_tf1" type="tfloat" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_td" type="tdouble" indexed="true" stored="true"/>
+  <dynamicField name="*_td1" type="tdouble" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_tds" type="tdouble" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_tdt" type="tdate" indexed="true" stored="true"/>
+  <dynamicField name="*_tdt1" type="tdate" indexed="true" stored="true" multiValued="false"/>
+
+
+  <dynamicField name="*_sI" type="string" indexed="true" stored="false"/>
+  <dynamicField name="*_sS" type="string" indexed="false" stored="true"/>
+  <dynamicField name="t_*" type="text" indexed="true" stored="true"/>
+  <dynamicField name="tv_*" type="text" indexed="true" stored="true"
+                termVectors="true" termPositions="true" termOffsets="true"/>
+  <dynamicField name="tv_mv_*" type="text" indexed="true" stored="true" multiValued="true"
+                termVectors="true" termPositions="true" termOffsets="true"/>
+
+  <dynamicField name="*_p" type="xyd" indexed="true" stored="true" multiValued="false"/>
+
+  <!-- special fields for dynamic copyField test -->
+  <dynamicField name="dynamic_*" type="string" indexed="true" stored="true"/>
+  <dynamicField name="*_dynamic" type="string" indexed="true" stored="true"/>
+
+  <!-- for testing to ensure that longer patterns are matched first -->
+  <dynamicField name="*aa" type="string" indexed="true" stored="true"/>
+
+  <!-- ignored becuase not stored or indexed -->
+  <dynamicField name="*_ignored" type="text" indexed="false" stored="false"/>
+
+  <dynamicField name="*_mfacet" type="string" indexed="true" stored="false" multiValued="true"/>
+
+  <!-- make sure custom sims work with dynamic fields -->
+  <!--
+  <dynamicField name="*_sim1" type="sim1" indexed="true" stored="true"/>
+  <dynamicField name="*_sim2" type="sim2" indexed="true" stored="true"/>
+  <dynamicField name="*_sim3" type="sim3" indexed="true" stored="true"/>
+  -->
 
   <defaultSearchField>text</defaultSearchField>
   <uniqueKey>id</uniqueKey>
@@ -580,7 +601,6 @@
   <copyField source="*_t" dest="text"/>
 
 
-
   <!-- dynamic destination -->
   <copyField source="*_dynamic" dest="dynamic_*"/>
 
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-ib.xml b/solr/core/src/test-files/solr/collection1/conf/schema-ib.xml
index 943a0ce..db7d5a3 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-ib.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-ib.xml
@@ -19,37 +19,32 @@
 <!-- Test schema file for IBSimilarityFactory -->
 
 <schema name="test" version="1.0">
-  <types>
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    
-    <!-- default parameters -->
-    <fieldType name="text" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
-      <similarity class="solr.IBSimilarityFactory">
-        <str name="distribution">SPL</str>
-        <str name="lambda">DF</str>
-        <str name="normalization">H2</str>
-      </similarity>
-    </fieldType>
-    
-    <!-- with parameters -->
-    <fieldType name="text_params" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
-      <similarity class="solr.IBSimilarityFactory">
-        <str name="distribution">LL</str>
-        <str name="lambda">TTF</str>
-        <str name="normalization">H3</str>
-        <float name="mu">900</float>
-      </similarity>
-    </fieldType>
-   
-  </types>
-
-  <fields>
-    <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
-    <field name="text" type="text" indexed="true" stored="false"/>
-    <field name="text_params" type="text_params" indexed="true" stored="false"/>
-  </fields>
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+
+  <!-- default parameters -->
+  <fieldType name="text" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
+    <similarity class="solr.IBSimilarityFactory">
+      <str name="distribution">SPL</str>
+      <str name="lambda">DF</str>
+      <str name="normalization">H2</str>
+    </similarity>
+  </fieldType>
+
+  <!-- with parameters -->
+  <fieldType name="text_params" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
+    <similarity class="solr.IBSimilarityFactory">
+      <str name="distribution">LL</str>
+      <str name="lambda">TTF</str>
+      <str name="normalization">H3</str>
+      <float name="mu">900</float>
+    </similarity>
+  </fieldType>
+
+  <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="text" type="text" indexed="true" stored="false"/>
+  <field name="text_params" type="text_params" indexed="true" stored="false"/>
 
   <defaultSearchField>text</defaultSearchField>
   <uniqueKey>id</uniqueKey>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-id-and-version-fields-only.xml b/solr/core/src/test-files/solr/collection1/conf/schema-id-and-version-fields-only.xml
index 10e6dc2..96f0866 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-id-and-version-fields-only.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-id-and-version-fields-only.xml
@@ -17,13 +17,9 @@
 -->
 
 <schema name="id-and-version-fields-only" version="1.6">
-  <types>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
-  </types>
-  <fields>
-    <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="true"/>
-    <field name="_version_" type="long" indexed="true" stored="true"/>
-  </fields>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+  <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="true"/>
+  <field name="_version_" type="long" indexed="true" stored="true"/>
   <uniqueKey>id</uniqueKey>
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-lmdirichlet.xml b/solr/core/src/test-files/solr/collection1/conf/schema-lmdirichlet.xml
index 1649e76..063957b 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-lmdirichlet.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-lmdirichlet.xml
@@ -19,30 +19,25 @@
 <!-- Test schema file for LMDirichletSimilarityFactory -->
 
 <schema name="test" version="1.0">
-  <types>
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    
-    <!-- default parameters -->
-    <fieldType name="text" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
-      <similarity class="solr.LMDirichletSimilarityFactory"/>
-    </fieldType>
-    
-    <!-- with parameters -->
-    <fieldType name="text_params" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
-      <similarity class="solr.LMDirichletSimilarityFactory">
-        <float name="mu">1000</float>
-      </similarity>
-    </fieldType>
-   
-  </types>
-
-  <fields>
-    <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
-    <field name="text" type="text" indexed="true" stored="false"/>
-    <field name="text_params" type="text_params" indexed="true" stored="false"/>
-  </fields>
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+
+  <!-- default parameters -->
+  <fieldType name="text" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
+    <similarity class="solr.LMDirichletSimilarityFactory"/>
+  </fieldType>
+
+  <!-- with parameters -->
+  <fieldType name="text_params" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
+    <similarity class="solr.LMDirichletSimilarityFactory">
+      <float name="mu">1000</float>
+    </similarity>
+  </fieldType>
+
+  <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="text" type="text" indexed="true" stored="false"/>
+  <field name="text_params" type="text_params" indexed="true" stored="false"/>
 
   <defaultSearchField>text</defaultSearchField>
   <uniqueKey>id</uniqueKey>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-lmjelinekmercer.xml b/solr/core/src/test-files/solr/collection1/conf/schema-lmjelinekmercer.xml
index 7dc2581..e137bd7 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-lmjelinekmercer.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-lmjelinekmercer.xml
@@ -19,30 +19,25 @@
 <!-- Test schema file for LMJelinekMercerSimilarityFactory -->
 
 <schema name="test" version="1.0">
-  <types>
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    
-    <!-- default parameters -->
-    <fieldType name="text" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
-      <similarity class="solr.LMJelinekMercerSimilarityFactory"/>
-    </fieldType>
-    
-    <!-- with parameters -->
-    <fieldType name="text_params" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
-      <similarity class="solr.LMJelinekMercerSimilarityFactory">
-        <float name="lambda">0.4</float>
-      </similarity>
-    </fieldType>
-   
-  </types>
-
-  <fields>
-    <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
-    <field name="text" type="text" indexed="true" stored="false"/>
-    <field name="text_params" type="text_params" indexed="true" stored="false"/>
-  </fields>
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+
+  <!-- default parameters -->
+  <fieldType name="text" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
+    <similarity class="solr.LMJelinekMercerSimilarityFactory"/>
+  </fieldType>
+
+  <!-- with parameters -->
+  <fieldType name="text_params" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
+    <similarity class="solr.LMJelinekMercerSimilarityFactory">
+      <float name="lambda">0.4</float>
+    </similarity>
+  </fieldType>
+
+  <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="text" type="text" indexed="true" stored="false"/>
+  <field name="text_params" type="text_params" indexed="true" stored="false"/>
 
   <defaultSearchField>text</defaultSearchField>
   <uniqueKey>id</uniqueKey>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-luceneMatchVersion.xml b/solr/core/src/test-files/solr/collection1/conf/schema-luceneMatchVersion.xml
index a61250d..95d6e03 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-luceneMatchVersion.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-luceneMatchVersion.xml
@@ -16,7 +16,6 @@
  limitations under the License.
 -->
 <schema name="luceneMatchVersionTest" version="1.1">
- <types>
   <fieldType name="long" class="solr.TrieLongField"/>
   <fieldType name="string" class="solr.StrField"/>
   <fieldType name="text40" class="solr.TextField">
@@ -43,16 +42,13 @@
   <fieldType name="textTurkishAnalyzerDefault" class="solr.TextField">
     <analyzer class="org.apache.lucene.analysis.tr.TurkishAnalyzer"/>
   </fieldType>
- </types>
- <fields>
-   <field name="id" type="string" indexed="true" stored="true"/>
-   <field name="signatureField" type="string" indexed="true" stored="false"/>
-   <field name="text40" type="text40" indexed="true" stored="false" />
-   <field name="textDefault" type="textDefault" indexed="true" stored="false" />
-   <field name="textTurkishAnalyzer40" type="textTurkishAnalyzer40" indexed="true" stored="false" />
-   <field name="textTurkishAnalyzerDefault" type="textTurkishAnalyzerDefault" indexed="true" stored="false" />
-   <field name="_version_" type="long" indexed="true" stored="true" multiValued="false" />
-   <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
- </fields>
- <uniqueKey>id</uniqueKey>
+  <field name="id" type="string" indexed="true" stored="true"/>
+  <field name="signatureField" type="string" indexed="true" stored="false"/>
+  <field name="text40" type="text40" indexed="true" stored="false"/>
+  <field name="textDefault" type="textDefault" indexed="true" stored="false"/>
+  <field name="textTurkishAnalyzer40" type="textTurkishAnalyzer40" indexed="true" stored="false"/>
+  <field name="textTurkishAnalyzerDefault" type="textTurkishAnalyzerDefault" indexed="true" stored="false"/>
+  <field name="_version_" type="long" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_sS" type="string" indexed="false" stored="true"/>
+  <uniqueKey>id</uniqueKey>
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-minimal.xml b/solr/core/src/test-files/solr/collection1/conf/schema-minimal.xml
index 9e2f947..287d4fe 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-minimal.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-minimal.xml
@@ -16,10 +16,6 @@
  limitations under the License.
 -->
 <schema name="minimal" version="1.1">
- <types>
   <fieldType name="string" class="solr.StrField"/>
- </types>
- <fields>
-   <dynamicField name="*" type="string" indexed="true" stored="true" />
- </fields>
+  <dynamicField name="*" type="string" indexed="true" stored="true"/>
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-not-required-unique-key.xml b/solr/core/src/test-files/solr/collection1/conf/schema-not-required-unique-key.xml
index 222c946..fa61c89 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-not-required-unique-key.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-not-required-unique-key.xml
@@ -22,25 +22,20 @@
 
   -->
 <schema name="test" version="1.0">
-  <types>
-    <fieldType name="string" class="solr.StrField"/>
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0"/>
-    <fieldType name="text" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-      </analyzer>
-    </fieldType>
- </types>
+  <fieldType name="string" class="solr.StrField"/>
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0"/>
+  <fieldType name="text" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+    </analyzer>
+  </fieldType>
 
+  <field name="id" type="int" multiValued="false" indexed="true" stored="true" required="false"/>
+  <field name="subject" type="text" indexed="true" stored="true"/>
+  <field name="signatureField" type="string" indexed="true" stored="false"/>
+  <dynamicField name="*_sS" type="string" indexed="false" stored="true"/>
 
- <fields>
-   <field name="id" type="int" multiValued="false" indexed="true" stored="true" required="false"/>
-   <field name="subject" type="text" indexed="true" stored="true"/>
-   <field name="signatureField" type="string" indexed="true" stored="false"/>
-   <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
- </fields>
-
- <defaultSearchField>subject</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+  <defaultSearchField>subject</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-numeric.xml b/solr/core/src/test-files/solr/collection1/conf/schema-numeric.xml
index fb5f07b..954de42 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-numeric.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-numeric.xml
@@ -26,50 +26,60 @@
   -->
 
 <schema name="test" version="1.0">
-  <types>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
 
-    <fieldType name="int"          class="solr.TrieIntField"    precisionStep="0" sortMissingLast="false" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="float"        class="solr.TrieFloatField"  precisionStep="0" sortMissingLast="false" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="long"         class="solr.TrieLongField"   precisionStep="0" sortMissingLast="false" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="date"         class="solr.TrieDateField"   precisionStep="0" sortMissingLast="false" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="double"       class="solr.TrieDoubleField" precisionStep="0" sortMissingLast="false" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" sortMissingLast="false" omitNorms="true"
+             positionIncrementGap="0"/>
+  <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" sortMissingLast="false" omitNorms="true"
+             positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" sortMissingLast="false" omitNorms="true"
+             positionIncrementGap="0"/>
+  <fieldType name="date" class="solr.TrieDateField" precisionStep="0" sortMissingLast="false" omitNorms="true"
+             positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" sortMissingLast="false" omitNorms="true"
+             positionIncrementGap="0"/>
 
-    <fieldType name="int_last"     class="solr.TrieIntField"    precisionStep="0" sortMissingLast="true" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="float_last"   class="solr.TrieFloatField"  precisionStep="0" sortMissingLast="true" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="long_last"    class="solr.TrieLongField"   precisionStep="0" sortMissingLast="true" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="date_last"    class="solr.TrieDateField"   precisionStep="0" sortMissingLast="true" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="double_last"  class="solr.TrieDoubleField" precisionStep="0" sortMissingLast="true" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="int_last" class="solr.TrieIntField" precisionStep="0" sortMissingLast="true" omitNorms="true"
+             positionIncrementGap="0"/>
+  <fieldType name="float_last" class="solr.TrieFloatField" precisionStep="0" sortMissingLast="true" omitNorms="true"
+             positionIncrementGap="0"/>
+  <fieldType name="long_last" class="solr.TrieLongField" precisionStep="0" sortMissingLast="true" omitNorms="true"
+             positionIncrementGap="0"/>
+  <fieldType name="date_last" class="solr.TrieDateField" precisionStep="0" sortMissingLast="true" omitNorms="true"
+             positionIncrementGap="0"/>
+  <fieldType name="double_last" class="solr.TrieDoubleField" precisionStep="0" sortMissingLast="true" omitNorms="true"
+             positionIncrementGap="0"/>
 
-    <fieldType name="int_first"    class="solr.TrieIntField"    precisionStep="0" sortMissingFirst="true" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="float_first"  class="solr.TrieFloatField"  precisionStep="0" sortMissingFirst="true" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="long_first"   class="solr.TrieLongField"   precisionStep="0" sortMissingFirst="true" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="date_first"   class="solr.TrieDateField"   precisionStep="0" sortMissingFirst="true" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="double_first" class="solr.TrieDoubleField" precisionStep="0" sortMissingFirst="true" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="int_first" class="solr.TrieIntField" precisionStep="0" sortMissingFirst="true" omitNorms="true"
+             positionIncrementGap="0"/>
+  <fieldType name="float_first" class="solr.TrieFloatField" precisionStep="0" sortMissingFirst="true" omitNorms="true"
+             positionIncrementGap="0"/>
+  <fieldType name="long_first" class="solr.TrieLongField" precisionStep="0" sortMissingFirst="true" omitNorms="true"
+             positionIncrementGap="0"/>
+  <fieldType name="date_first" class="solr.TrieDateField" precisionStep="0" sortMissingFirst="true" omitNorms="true"
+             positionIncrementGap="0"/>
+  <fieldType name="double_first" class="solr.TrieDoubleField" precisionStep="0" sortMissingFirst="true" omitNorms="true"
+             positionIncrementGap="0"/>
 
-  </types>
+  <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="true"/>
 
-  <fields>
-    <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="true"/>
+  <field name="int" type="int" indexed="true" stored="true" multiValued="false"/>
+  <field name="float" type="float" indexed="true" stored="true" multiValued="false"/>
+  <field name="long" type="long" indexed="true" stored="true" multiValued="false"/>
+  <field name="date" type="date" indexed="true" stored="true" multiValued="false"/>
+  <field name="double" type="double" indexed="true" stored="true" multiValued="false"/>
 
-    <field name="int"          type="int"          indexed="true" stored="true" multiValued="false"/>
-    <field name="float"        type="float"        indexed="true" stored="true" multiValued="false"/>
-    <field name="long"         type="long"         indexed="true" stored="true" multiValued="false"/>
-    <field name="date"         type="date"         indexed="true" stored="true" multiValued="false"/>
-    <field name="double"       type="double"       indexed="true" stored="true" multiValued="false"/>
+  <field name="int_last" type="int_last" indexed="true" stored="true" multiValued="false"/>
+  <field name="float_last" type="float_last" indexed="true" stored="true" multiValued="false"/>
+  <field name="long_last" type="long_last" indexed="true" stored="true" multiValued="false"/>
+  <field name="date_last" type="date_last" indexed="true" stored="true" multiValued="false"/>
+  <field name="double_last" type="double_last" indexed="true" stored="true" multiValued="false"/>
 
-    <field name="int_last"     type="int_last"     indexed="true" stored="true" multiValued="false"/>
-    <field name="float_last"   type="float_last"   indexed="true" stored="true" multiValued="false"/>
-    <field name="long_last"    type="long_last"    indexed="true" stored="true" multiValued="false"/>
-    <field name="date_last"    type="date_last"    indexed="true" stored="true" multiValued="false"/>
-    <field name="double_last"  type="double_last"  indexed="true" stored="true" multiValued="false"/>
+  <field name="int_first" type="int_first" indexed="true" stored="true" multiValued="false"/>
+  <field name="float_first" type="float_first" indexed="true" stored="true" multiValued="false"/>
+  <field name="long_first" type="long_first" indexed="true" stored="true" multiValued="false"/>
+  <field name="date_first" type="date_first" indexed="true" stored="true" multiValued="false"/>
+  <field name="double_first" type="double_first" indexed="true" stored="true" multiValued="false"/>
 
-    <field name="int_first"    type="int_first"    indexed="true" stored="true" multiValued="false"/>
-    <field name="float_first"  type="float_first"  indexed="true" stored="true" multiValued="false"/>
-    <field name="long_first"   type="long_first"   indexed="true" stored="true" multiValued="false"/>
-    <field name="date_first"   type="date_first"   indexed="true" stored="true" multiValued="false"/>
-    <field name="double_first" type="double_first" indexed="true" stored="true" multiValued="false"/>
-   
-  </fields>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-one-field-no-dynamic-field-unique-key.xml b/solr/core/src/test-files/solr/collection1/conf/schema-one-field-no-dynamic-field-unique-key.xml
index 783ae77..49a587a 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-one-field-no-dynamic-field-unique-key.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-one-field-no-dynamic-field-unique-key.xml
@@ -16,14 +16,10 @@
  limitations under the License.
 -->
 <schema name="one_field_no_dynamic_field_unique_key" version="1.1">
-  <types>
-    <fieldType name="string" class="solr.StrField"/>
-    <fieldType name="text" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
-    </fieldType>
-  </types>
-  <fields>
-    <field name="str" type="string" indexed="true" stored="true"/>
-  </fields>
+  <fieldType name="string" class="solr.StrField"/>
+  <fieldType name="text" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
+  </fieldType>
+  <field name="str" type="string" indexed="true" stored="true"/>
   <uniqueKey>str</uniqueKey>
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-one-field-no-dynamic-field.xml b/solr/core/src/test-files/solr/collection1/conf/schema-one-field-no-dynamic-field.xml
index 035f975d..8a22324 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-one-field-no-dynamic-field.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-one-field-no-dynamic-field.xml
@@ -16,13 +16,9 @@
  limitations under the License.
 -->
 <schema name="one_field_no_dynamic_field" version="1.1">
-  <types>
-    <fieldType name="string" class="solr.StrField"/>
-    <fieldType name="text" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
-    </fieldType>
-  </types>
-  <fields>
-    <field name="str" type="string" indexed="true" stored="true"/>
-  </fields>
+  <fieldType name="string" class="solr.StrField"/>
+  <fieldType name="text" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
+  </fieldType>
+  <field name="str" type="string" indexed="true" stored="true"/>
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-phrasesuggest.xml b/solr/core/src/test-files/solr/collection1/conf/schema-phrasesuggest.xml
index a585502..0c8261c 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-phrasesuggest.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-phrasesuggest.xml
@@ -19,18 +19,17 @@
 <!-- Test schema file for phrase suggestions -->
 
 <schema name="test" version="1.0">
-  <types>
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-
-    <!-- basic text field -->
-    <fieldType name="text" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    
-    <fieldType name="phrase_suggest" class="solr.TextField">
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+
+  <!-- basic text field -->
+  <fieldType name="text" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="phrase_suggest" class="solr.TextField">
     <analyzer>
       <tokenizer class="solr.KeywordTokenizerFactory"/>
       <filter class="solr.PatternReplaceFilterFactory"
@@ -40,7 +39,7 @@
       <filter class="solr.TrimFilterFactory"/>
     </analyzer>
   </fieldType>
-  
+
   <fieldType name="ja_suggest" class="solr.TextField">
     <analyzer>
       <tokenizer class="solr.JapaneseTokenizerFactory" mode="normal"/>
@@ -48,13 +47,10 @@
       <filter class="solr.JapaneseReadingFormFilterFactory" useRomaji="true"/>
     </analyzer>
   </fieldType>
-  </types>
 
-  <fields>
-    <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
-    <field name="text" type="text" indexed="true" stored="false"/>
-    <field name="stext" type="text" indexed="true" stored="true"/>
-  </fields>
+  <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="text" type="text" indexed="true" stored="false"/>
+  <field name="stext" type="text" indexed="true" stored="true"/>
 
   <defaultSearchField>text</defaultSearchField>
   <uniqueKey>id</uniqueKey>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-postingshighlight.xml b/solr/core/src/test-files/solr/collection1/conf/schema-postingshighlight.xml
index 0915509..cdacba4 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-postingshighlight.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-postingshighlight.xml
@@ -19,32 +19,28 @@
 <!-- Test schema file for PostingsHighlighter -->
 
 <schema name="postingshighlight" version="1.0">
-  <types>
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-
-    <!-- basic text field: no offsets! -->
-    <fieldType name="text" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- text field with offsets -->
-    <fieldType name="text_offsets" class="solr.TextField" storeOffsetsWithPositions="true">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-   </types>
-
-  <fields>
-    <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
-    <field name="text" type="text_offsets" indexed="true" stored="true"/>
-    <field name="text2" type="text" indexed="true" stored="true"/>
-    <field name="text3" type="text_offsets" indexed="true" stored="true"/>
-  </fields>
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+
+  <!-- basic text field: no offsets! -->
+  <fieldType name="text" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- text field with offsets -->
+  <fieldType name="text_offsets" class="solr.TextField" storeOffsetsWithPositions="true">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="text" type="text_offsets" indexed="true" stored="true"/>
+  <field name="text2" type="text" indexed="true" stored="true"/>
+  <field name="text3" type="text_offsets" indexed="true" stored="true"/>
 
   <defaultSearchField>text</defaultSearchField>
   <uniqueKey>id</uniqueKey>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-preanalyzed.xml b/solr/core/src/test-files/solr/collection1/conf/schema-preanalyzed.xml
index 8bd9a4c..8a27392 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-preanalyzed.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-preanalyzed.xml
@@ -17,30 +17,27 @@
 -->
 <schema name="tiny" version="1.1">
 
-  <types>
-    <fieldType name="preanalyzed-no-analyzer" class="solr.PreAnalyzedField" parserImpl="json"/>
-    <fieldType name="preanalyzed-with-analyzer" class="solr.PreAnalyzedField">
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="preanalyzed-with-query-analyzer" class="solr.PreAnalyzedField">
-      <analyzer type="query">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="string" class="solr.StrField"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-  </types>
+  <fieldType name="preanalyzed-no-analyzer" class="solr.PreAnalyzedField" parserImpl="json"/>
+  <fieldType name="preanalyzed-with-analyzer" class="solr.PreAnalyzedField">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="preanalyzed-with-query-analyzer" class="solr.PreAnalyzedField">
+    <analyzer type="query">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="string" class="solr.StrField"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
 
-  <fields>
-    <field name="id" type="string" indexed="true" stored="true" required="true"/>
-    <field name="_version_" type="long" indexed="true" stored="true" multiValued="false"/>
-    <field name="pre_no_analyzer" type="preanalyzed-no-analyzer" indexed="true" stored="true" multiValued="false"/>
-    <field name="pre_with_analyzer" type="preanalyzed-with-analyzer" indexed="true" stored="true" multiValued="false"/>
-    <field name="pre_with_query_analyzer" type="preanalyzed-with-query-analyzer" indexed="true" stored="true" multiValued="false"/>
-  </fields>
+  <field name="id" type="string" indexed="true" stored="true" required="true"/>
+  <field name="_version_" type="long" indexed="true" stored="true" multiValued="false"/>
+  <field name="pre_no_analyzer" type="preanalyzed-no-analyzer" indexed="true" stored="true" multiValued="false"/>
+  <field name="pre_with_analyzer" type="preanalyzed-with-analyzer" indexed="true" stored="true" multiValued="false"/>
+  <field name="pre_with_query_analyzer" type="preanalyzed-with-query-analyzer" indexed="true" stored="true"
+         multiValued="false"/>
 
   <uniqueKey>id</uniqueKey>
 
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-replication1.xml b/solr/core/src/test-files/solr/collection1/conf/schema-replication1.xml
index 6a2184f..b647fa2 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-replication1.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-replication1.xml
@@ -26,20 +26,13 @@
   -->
 
 <schema name="test" version="1.2">
-  <types>
 
-    <fieldType name="integer" class="solr.TrieIntField" precisionStep="0"/>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+  <fieldType name="integer" class="solr.TrieIntField" precisionStep="0"/>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
 
+  <field name="id" type="integer" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="name" type="string" indexed="true" stored="true"/>
 
-  </types>
-
-
-  <fields>
-    <field name="id" type="integer" indexed="true" stored="true" multiValued="false" required="false"/>
-    <field name="name" type="string" indexed="true" stored="true"/>
-
-  </fields>
 
   <uniqueKey>id</uniqueKey>
 
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-replication2.xml b/solr/core/src/test-files/solr/collection1/conf/schema-replication2.xml
index f0a6434..8c8c49d 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-replication2.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-replication2.xml
@@ -26,23 +26,15 @@
   -->
 
 <schema name="test" version="1.2">
-  <types>
 
-    <fieldType name="integer" class="solr.TrieIntField" precisionStep="0"/>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+  <fieldType name="integer" class="solr.TrieIntField" precisionStep="0"/>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
 
-  </types>
+  <field name="id" type="integer" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="name" type="string" indexed="true" stored="true"/>
 
-
-  <fields>
-    <field name="id" type="integer" indexed="true" stored="true" multiValued="false" required="false"/>
-    <field name="name" type="string" indexed="true" stored="true"/>
-
-    <!--adding new field newname in replication test.-->
-    <field name="newname" type="string" indexed="true" stored="true"/>
-
-
-  </fields>
+  <!--adding new field newname in replication test.-->
+  <field name="newname" type="string" indexed="true" stored="true"/>
 
   <uniqueKey>id</uniqueKey>
 
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-required-fields.xml b/solr/core/src/test-files/solr/collection1/conf/schema-required-fields.xml
index 454ece4..d3a7818 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-required-fields.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-required-fields.xml
@@ -26,391 +26,402 @@
   -->
 
 <schema name="test" version="1.0">
-  <types>
 
-    <!-- field type definitions... note that the "name" attribute is
-         just a label to be used by field definitions.  The "class"
-         attribute and any other attributes determine the real type and
-         behavior of the fieldType.
-      -->
+  <!-- field type definitions... note that the "name" attribute is
+       just a label to be used by field definitions.  The "class"
+       attribute and any other attributes determine the real type and
+       behavior of the fieldType.
+    -->
+
+  <!--
+    Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
+  -->
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
+
+  <!--
+   Numeric field types that index each value at various levels of precision
+   to accelerate range queries when the number of values between the range
+   endpoints is large. See the javadoc for LegacyNumericRangeQuery for internal
+   implementation details.
+
+   Smaller precisionStep values (specified in bits) will lead to more tokens
+   indexed per value, slightly larger index size, and faster range queries.
+   A precisionStep of 0 disables indexing at different precision levels.
+  -->
+  <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
+
+  <!-- Field type demonstrating an Analyzer failure -->
+  <fieldType name="failtype1" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0"
+              catenateNumbers="0" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <!-- HighlitText optimizes storage for (long) columns which will be highlit -->
+  <fieldType name="highlittext" class="solr.TextField" compressThreshold="345"/>
 
-    <!--
-      Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
+  <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+
+  <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
+       seconds part (.999) is optional.
     -->
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
-
-    <!--
-     Numeric field types that index each value at various levels of precision
-     to accelerate range queries when the number of values between the range
-     endpoints is large. See the javadoc for LegacyNumericRangeQuery for internal
-     implementation details.
-
-     Smaller precisionStep values (specified in bits) will lead to more tokens
-     indexed per value, slightly larger index size, and faster range queries.
-     A precisionStep of 0 disables indexing at different precision levels.
+  <fieldType name="date" class="solr.TrieDateField" sortMissingLast="true"/>
+
+  <!-- solr.TextField allows the specification of custom
+       text analyzers specified as a tokenizer and a list
+       of token filters.
     -->
-    <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
-
-    <!-- Field type demonstrating an Analyzer failure -->
-    <fieldType name="failtype1" class="solr.TextField">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <!-- HighlitText optimizes storage for (long) columns which will be highlit -->
-    <fieldType name="highlittext" class="solr.TextField" compressThreshold="345" />
-
-    <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
-
-    <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
-         seconds part (.999) is optional.
-      -->
-    <fieldType name="date" class="solr.TrieDateField" sortMissingLast="true"/>
-
-    <!-- solr.TextField allows the specification of custom
-         text analyzers specified as a tokenizer and a list
-         of token filters.
-      -->
-    <fieldType name="text" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <fieldType name="nametext" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.core.WhitespaceAnalyzer"/>
-    </fieldType>
-
-    <fieldType name="teststop" class="solr.TextField">
-       <analyzer>
-        <tokenizer class="solr.LowerCaseTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-        <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- fieldTypes in this section isolate tokenizers and tokenfilters for testing -->
-    <fieldType name="lowertok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.LowerCaseTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="keywordtok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/></analyzer>
-    </fieldType>
-    <fieldType name="standardtok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.StandardTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="lettertok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.LetterTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="whitetok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.MockTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="HTMLstandardtok" class="solr.TextField">
-      <analyzer>
+  <fieldType name="text" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <fieldType name="nametext" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.core.WhitespaceAnalyzer"/>
+  </fieldType>
+
+  <fieldType name="teststop" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LowerCaseTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+      <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- fieldTypes in this section isolate tokenizers and tokenfilters for testing -->
+  <fieldType name="lowertok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LowerCaseTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="keywordtok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="standardtok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="lettertok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LetterTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="whitetok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="HTMLstandardtok" class="solr.TextField">
+    <analyzer>
       <charFilter class="solr.HTMLStripCharFilterFactory"/>
       <tokenizer class="solr.StandardTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="HTMLwhitetok" class="solr.TextField">
-      <analyzer>
+    </analyzer>
+  </fieldType>
+  <fieldType name="HTMLwhitetok" class="solr.TextField">
+    <analyzer>
       <charFilter class="solr.HTMLStripCharFilterFactory"/>
       <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="standardtokfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="standardfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="lowerfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="patternreplacefilt" class="solr.TextField">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
-        <filter class="solr.PatternReplaceFilterFactory"
-                pattern="([^a-zA-Z])" replacement="_" replace="all"
-        />
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="porterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <!-- fieldType name="snowballfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.SnowballPorterFilterFactory"/>
-      </analyzer>
-    </fieldType -->
-    <fieldType name="engporterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="custengporterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="stopfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="custstopfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="lengthfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LengthFilterFactory" min="2" max="5"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="subword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.StopFilterFactory"/>
-          <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.StopFilterFactory"/>
-          <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- more flexible in matching skus, but more chance of a false match -->
-    <fieldType name="skutype1" class="solr.TextField">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- less flexible in matching skus, but less chance of a false match -->
-    <fieldType name="skutype2" class="solr.TextField">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- less flexible in matching skus, but less chance of a false match -->
-    <fieldType name="syn" class="solr.TextField">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt"/>
-      </analyzer>
-    </fieldType>
-    
-    <!-- Demonstrates How RemoveDuplicatesTokenFilter makes stemmed
-         synonyms "better"
-      -->
-    <fieldType name="dedup" class="solr.TextField">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.SynonymFilterFactory"
-                  synonyms="synonyms.txt" expand="true" />
-          <filter class="solr.PorterStemFilterFactory"/>
-          <filter class="solr.RemoveDuplicatesTokenFilterFactory" />
-      </analyzer>
-    </fieldType>
-
-    <fieldType  name="unstored" class="solr.StrField" indexed="true" stored="false"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="standardtokfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="standardfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="lowerfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="patternreplacefilt" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+      <filter class="solr.PatternReplaceFilterFactory"
+              pattern="([^a-zA-Z])" replacement="_" replace="all"
+      />
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="porterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <!-- fieldType name="snowballfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SnowballPorterFilterFactory"/>
+    </analyzer>
+  </fieldType -->
+  <fieldType name="engporterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="custengporterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="stopfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="custstopfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="lengthfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LengthFilterFactory" min="2" max="5"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="subword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- more flexible in matching skus, but more chance of a false match -->
+  <fieldType name="skutype1" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- less flexible in matching skus, but less chance of a false match -->
+  <fieldType name="skutype2" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- less flexible in matching skus, but less chance of a false match -->
+  <fieldType name="syn" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Demonstrates How RemoveDuplicatesTokenFilter makes stemmed
+       synonyms "better"
+    -->
+  <fieldType name="dedup" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory"
+              synonyms="synonyms.txt" expand="true"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="unstored" class="solr.StrField" indexed="true" stored="false"/>
 
 
   <fieldType name="textgap" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
   </fieldType>
 
- </types>
-
-
- <fields>
-   <field name="id" type="int" multiValued="false" indexed="true" stored="true"/> <!-- the uniqueKey is required by default -->
-   <field name="name" type="nametext" indexed="true" stored="true" required="true"/>
-   <field name="text" type="text" indexed="true" stored="false"/>
-   <field name="subject" type="text" indexed="true" stored="true" required="true" default="Stuff"/>
-   <field name="title" type="nametext" indexed="true" stored="true"/>
-   <field name="weight" type="float" indexed="true" stored="true"/>
-   <field name="bday" type="date" indexed="true" stored="true"/>
-
-   <field name="title_stemmed" type="text" indexed="true" stored="false"/>
-   <field name="title_lettertok" type="lettertok" indexed="true" stored="false"/>
-
-   <field name="syn" type="syn" indexed="true" stored="true"/>
-
-   <!-- to test property inheritance and overriding -->
-   <field name="shouldbeunstored" type="unstored" />
-   <field name="shouldbestored" type="unstored" stored="true"/>
-   <field name="shouldbeunindexed" type="unstored" indexed="false" stored="true"/>
-
-
-   <!-- test different combinations of indexed and stored -->
-   <field name="bind" type="boolean" indexed="true" stored="false"/>
-   <field name="bsto" type="boolean" indexed="false" stored="true"/>
-   <field name="bindsto" type="boolean" indexed="true" stored="true"/>
-   <field name="isto" type="int" indexed="false" stored="true"/>
-   <field name="iind" type="int" indexed="true" stored="false"/>
-   <field name="ssto" type="string" indexed="false" stored="true"/>
-   <field name="sind" type="string" indexed="true" stored="false"/>
-   <field name="sindsto" type="string" indexed="true" stored="true"/>
-
-   <!-- test combinations of term vector settings -->
-   <field name="test_basictv" type="text" termVectors="true"/>
-   <field name="test_notv" type="text" termVectors="false"/>
-   <field name="test_postv" type="text" termVectors="true" termPositions="true"/>
-   <field name="test_offtv" type="text" termVectors="true" termOffsets="true"/>
-   <field name="test_posofftv" type="text" termVectors="true" 
-     termPositions="true" termOffsets="true"/>
-
-   <!-- test highlit field settings -->
-   <field name="test_hlt" type="highlittext" indexed="true"/>
-   <field name="test_hlt_off" type="highlittext" indexed="true"/>
-
-   <!-- fields to test individual tokenizers and tokenfilters -->
-   <field name="teststop" type="teststop" indexed="true" stored="true"/>
-   <field name="lowertok" type="lowertok" indexed="true" stored="true"/>
-   <field name="keywordtok" type="keywordtok" indexed="true" stored="true"/>
-   <field name="standardtok" type="standardtok" indexed="true" stored="true"/>
-   <field name="HTMLstandardtok" type="HTMLstandardtok" indexed="true" stored="true"/>
-   <field name="lettertok" type="lettertok" indexed="true" stored="true"/>
-   <field name="whitetok" type="whitetok" indexed="true" stored="true"/>
-   <field name="HTMLwhitetok" type="HTMLwhitetok" indexed="true" stored="true"/>
-   <field name="standardtokfilt" type="standardtokfilt" indexed="true" stored="true"/>
-   <field name="standardfilt" type="standardfilt" indexed="true" stored="true"/>
-   <field name="lowerfilt" type="lowerfilt" indexed="true" stored="true"/>
-   <field name="patternreplacefilt" type="patternreplacefilt" indexed="true" stored="true"/>
-   <field name="porterfilt" type="porterfilt" indexed="true" stored="true"/>
-   <field name="engporterfilt" type="engporterfilt" indexed="true" stored="true"/>
-   <field name="custengporterfilt" type="custengporterfilt" indexed="true" stored="true"/>
-   <field name="stopfilt" type="stopfilt" indexed="true" stored="true"/>
-   <field name="custstopfilt" type="custstopfilt" indexed="true" stored="true"/>
-   <field name="lengthfilt" type="lengthfilt" indexed="true" stored="true"/>
-   <field name="dedup" type="dedup" indexed="true" stored="true"/>
-
-   <field name="numberpartfail" type="failtype1" indexed="true" stored="true"/>
-
-   <field name="nullfirst" type="string" indexed="true" stored="true" sortMissingFirst="true"/>
-
-   <field name="subword" type="subword" indexed="true" stored="true"/>
-   <field name="sku1" type="skutype1" indexed="true" stored="true"/>
-   <field name="sku2" type="skutype2" indexed="true" stored="true"/>
-
-   <field name="textgap" type="textgap" indexed="true" stored="true"/>
-   
-   <field name="timestamp" type="date" indexed="true" stored="true" default="NOW" multiValued="false"/>
-   <field name="multiDefault" type="string" indexed="true" stored="true" default="muLti-Default" multiValued="true"/>
-   <field name="intDefault" type="int" indexed="true" stored="true" default="42" multiValued="false"/>
-   <field name="signatureField" type="string" indexed="true" stored="false"/>
-   
-   <field name="_version_" type="long" indexed="true" stored="true" multiValued="false" />
-   
-   <!-- Dynamic field definitions.  If a field name is not found, dynamicFields
-        will be used if the name matches any of the patterns.
-        RESTRICTION: the glob-like pattern in the name attribute must have
-        a "*" only at the start or the end.
-        EXAMPLE:  name="*_i" will match any field ending in _i (like myid_i, z_i)
-        Longer patterns will be matched first.  if equal size patterns
-        both match, the first appearing in the schema will be used.
-   -->
-   <dynamicField name="*_i"  type="int"    indexed="true"  stored="true"/>
-   <dynamicField name="*_s"  type="string"  indexed="true"  stored="true"/>
-   <dynamicField name="*_s1"  type="string"  indexed="true"  stored="true" multiValued="false"/>
-   <dynamicField name="*_l"  type="long"   indexed="true"  stored="true"/>
-   <dynamicField name="*_t"  type="text"    indexed="true"  stored="true"/>
-   <dynamicField name="*_b"  type="boolean" indexed="true"  stored="true"/>
-   <dynamicField name="*_f"  type="float"  indexed="true"  stored="true"/>
-   <dynamicField name="*_d"  type="double" indexed="true"  stored="true"/>
-   <dynamicField name="*_dt" type="date"    indexed="true"  stored="true"/>
 
-   <dynamicField name="*_sI" type="string"  indexed="true"  stored="false"/>
-   <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
-   <dynamicField name="t_*"  type="text"    indexed="true"  stored="true"/>
-   <dynamicField name="tv_*"  type="text" indexed="true"  stored="true" 
-      termVectors="true" termPositions="true" termOffsets="true"/>
-   
+  <field name="id" type="int" multiValued="false" indexed="true"
+         stored="true"/> <!-- the uniqueKey is required by default -->
+  <field name="name" type="nametext" indexed="true" stored="true" required="true"/>
+  <field name="text" type="text" indexed="true" stored="false"/>
+  <field name="subject" type="text" indexed="true" stored="true" required="true" default="Stuff"/>
+  <field name="title" type="nametext" indexed="true" stored="true"/>
+  <field name="weight" type="float" indexed="true" stored="true"/>
+  <field name="bday" type="date" indexed="true" stored="true"/>
+
+  <field name="title_stemmed" type="text" indexed="true" stored="false"/>
+  <field name="title_lettertok" type="lettertok" indexed="true" stored="false"/>
+
+  <field name="syn" type="syn" indexed="true" stored="true"/>
+
+  <!-- to test property inheritance and overriding -->
+  <field name="shouldbeunstored" type="unstored"/>
+  <field name="shouldbestored" type="unstored" stored="true"/>
+  <field name="shouldbeunindexed" type="unstored" indexed="false" stored="true"/>
+
+
+  <!-- test different combinations of indexed and stored -->
+  <field name="bind" type="boolean" indexed="true" stored="false"/>
+  <field name="bsto" type="boolean" indexed="false" stored="true"/>
+  <field name="bindsto" type="boolean" indexed="true" stored="true"/>
+  <field name="isto" type="int" indexed="false" stored="true"/>
+  <field name="iind" type="int" indexed="true" stored="false"/>
+  <field name="ssto" type="string" indexed="false" stored="true"/>
+  <field name="sind" type="string" indexed="true" stored="false"/>
+  <field name="sindsto" type="string" indexed="true" stored="true"/>
+
+  <!-- test combinations of term vector settings -->
+  <field name="test_basictv" type="text" termVectors="true"/>
+  <field name="test_notv" type="text" termVectors="false"/>
+  <field name="test_postv" type="text" termVectors="true" termPositions="true"/>
+  <field name="test_offtv" type="text" termVectors="true" termOffsets="true"/>
+  <field name="test_posofftv" type="text" termVectors="true"
+         termPositions="true" termOffsets="true"/>
+
+  <!-- test highlit field settings -->
+  <field name="test_hlt" type="highlittext" indexed="true"/>
+  <field name="test_hlt_off" type="highlittext" indexed="true"/>
+
+  <!-- fields to test individual tokenizers and tokenfilters -->
+  <field name="teststop" type="teststop" indexed="true" stored="true"/>
+  <field name="lowertok" type="lowertok" indexed="true" stored="true"/>
+  <field name="keywordtok" type="keywordtok" indexed="true" stored="true"/>
+  <field name="standardtok" type="standardtok" indexed="true" stored="true"/>
+  <field name="HTMLstandardtok" type="HTMLstandardtok" indexed="true" stored="true"/>
+  <field name="lettertok" type="lettertok" indexed="true" stored="true"/>
+  <field name="whitetok" type="whitetok" indexed="true" stored="true"/>
+  <field name="HTMLwhitetok" type="HTMLwhitetok" indexed="true" stored="true"/>
+  <field name="standardtokfilt" type="standardtokfilt" indexed="true" stored="true"/>
+  <field name="standardfilt" type="standardfilt" indexed="true" stored="true"/>
+  <field name="lowerfilt" type="lowerfilt" indexed="true" stored="true"/>
+  <field name="patternreplacefilt" type="patternreplacefilt" indexed="true" stored="true"/>
+  <field name="porterfilt" type="porterfilt" indexed="true" stored="true"/>
+  <field name="engporterfilt" type="engporterfilt" indexed="true" stored="true"/>
+  <field name="custengporterfilt" type="custengporterfilt" indexed="true" stored="true"/>
+  <field name="stopfilt" type="stopfilt" indexed="true" stored="true"/>
+  <field name="custstopfilt" type="custstopfilt" indexed="true" stored="true"/>
+  <field name="lengthfilt" type="lengthfilt" indexed="true" stored="true"/>
+  <field name="dedup" type="dedup" indexed="true" stored="true"/>
+
+  <field name="numberpartfail" type="failtype1" indexed="true" stored="true"/>
+
+  <field name="nullfirst" type="string" indexed="true" stored="true" sortMissingFirst="true"/>
+
+  <field name="subword" type="subword" indexed="true" stored="true"/>
+  <field name="sku1" type="skutype1" indexed="true" stored="true"/>
+  <field name="sku2" type="skutype2" indexed="true" stored="true"/>
+
+  <field name="textgap" type="textgap" indexed="true" stored="true"/>
+
+  <field name="timestamp" type="date" indexed="true" stored="true" default="NOW" multiValued="false"/>
+  <field name="multiDefault" type="string" indexed="true" stored="true" default="muLti-Default" multiValued="true"/>
+  <field name="intDefault" type="int" indexed="true" stored="true" default="42" multiValued="false"/>
+  <field name="signatureField" type="string" indexed="true" stored="false"/>
+
+  <field name="_version_" type="long" indexed="true" stored="true" multiValued="false"/>
+
+  <!-- Dynamic field definitions.  If a field name is not found, dynamicFields
+       will be used if the name matches any of the patterns.
+       RESTRICTION: the glob-like pattern in the name attribute must have
+       a "*" only at the start or the end.
+       EXAMPLE:  name="*_i" will match any field ending in _i (like myid_i, z_i)
+       Longer patterns will be matched first.  if equal size patterns
+       both match, the first appearing in the schema will be used.
+  -->
+  <dynamicField name="*_i" type="int" indexed="true" stored="true"/>
+  <dynamicField name="*_s" type="string" indexed="true" stored="true"/>
+  <dynamicField name="*_s1" type="string" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_l" type="long" indexed="true" stored="true"/>
+  <dynamicField name="*_t" type="text" indexed="true" stored="true"/>
+  <dynamicField name="*_b" type="boolean" indexed="true" stored="true"/>
+  <dynamicField name="*_f" type="float" indexed="true" stored="true"/>
+  <dynamicField name="*_d" type="double" indexed="true" stored="true"/>
+  <dynamicField name="*_dt" type="date" indexed="true" stored="true"/>
 
-   <!-- for testing to ensure that longer patterns are matched first -->
-   <dynamicField name="*aa"  type="string"  indexed="true" stored="true"/>
-   <dynamicField name="*aaa" type="int" indexed="false" stored="true"/>
+  <dynamicField name="*_sI" type="string" indexed="true" stored="false"/>
+  <dynamicField name="*_sS" type="string" indexed="false" stored="true"/>
+  <dynamicField name="t_*" type="text" indexed="true" stored="true"/>
+  <dynamicField name="tv_*" type="text" indexed="true" stored="true"
+                termVectors="true" termPositions="true" termOffsets="true"/>
 
 
+  <!-- for testing to ensure that longer patterns are matched first -->
+  <dynamicField name="*aa" type="string" indexed="true" stored="true"/>
+  <dynamicField name="*aaa" type="int" indexed="false" stored="true"/>
 
- </fields>
 
- <defaultSearchField>text</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+  <defaultSearchField>text</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 
   <!-- copyField commands copy one field to another at the time a document
         is added to the index.  It's used either to index the same field different
         ways, or to add multiple fields to the same field for easier/faster searching.
    -->
-   <copyField source="title" dest="title_stemmed"/>
-   <copyField source="title" dest="title_lettertok"/>
-
-   <copyField source="title" dest="text"/>
-   <copyField source="subject" dest="text"/>
- 
-   <copyField source="*_t" dest="text"/>
-   
+  <copyField source="title" dest="title_stemmed"/>
+  <copyField source="title" dest="title_lettertok"/>
+
+  <copyField source="title" dest="text"/>
+  <copyField source="subject" dest="text"/>
+
+  <copyField source="*_t" dest="text"/>
+
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-rest-lucene-match-version.xml b/solr/core/src/test-files/solr/collection1/conf/schema-rest-lucene-match-version.xml
index dd9ded7..23c418c 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-rest-lucene-match-version.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-rest-lucene-match-version.xml
@@ -16,25 +16,21 @@
  limitations under the License.
 -->
 <schema name="test-class-name-shortening-on-serialization" version="1.6">
-  <types>
-    <fieldType name="explicitLuceneMatchVersions" class="org.apache.solr.schema.TextField">
-      <analyzer>
-        <charFilter class="org.apache.solr.analysis.MockCharFilterFactory" luceneMatchVersion="LUCENE_40" remainder="0"/>
-        <tokenizer class="org.apache.solr.analysis.MockTokenizerFactory" luceneMatchVersion="LUCENE_4_0" />
-        <filter class="org.apache.solr.analysis.MockTokenFilterFactory" luceneMatchVersion="4.0" stopset="empty"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="noLuceneMatchVersions" class="org.apache.solr.schema.TextField">
-      <analyzer>
-        <charFilter class="org.apache.solr.analysis.MockCharFilterFactory" remainder="0"/>
-        <tokenizer class="org.apache.solr.analysis.MockTokenizerFactory" />
-        <filter class="org.apache.solr.analysis.MockTokenFilterFactory" stopset="empty"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
-  </types>
-  <fields>
-    <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="true"/>
-    <field name="signatureField" type="string" indexed="true" stored="false"/>
-  </fields>
+  <fieldType name="explicitLuceneMatchVersions" class="org.apache.solr.schema.TextField">
+    <analyzer>
+      <charFilter class="org.apache.solr.analysis.MockCharFilterFactory" luceneMatchVersion="LUCENE_40" remainder="0"/>
+      <tokenizer class="org.apache.solr.analysis.MockTokenizerFactory" luceneMatchVersion="LUCENE_4_0"/>
+      <filter class="org.apache.solr.analysis.MockTokenFilterFactory" luceneMatchVersion="4.0" stopset="empty"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="noLuceneMatchVersions" class="org.apache.solr.schema.TextField">
+    <analyzer>
+      <charFilter class="org.apache.solr.analysis.MockCharFilterFactory" remainder="0"/>
+      <tokenizer class="org.apache.solr.analysis.MockTokenizerFactory"/>
+      <filter class="org.apache.solr.analysis.MockTokenFilterFactory" stopset="empty"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+  <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="true"/>
+  <field name="signatureField" type="string" indexed="true" stored="false"/>
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-rest.xml b/solr/core/src/test-files/solr/collection1/conf/schema-rest.xml
index e52473b..8bd603b 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-rest.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-rest.xml
@@ -31,607 +31,630 @@
        1.5: omitNorms defaults to true for primitive field types (int, float, boolean, string...)
        1.6: useDocValuesAsStored defaults to true.
      -->
-  <types>
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>  
-
-    <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
-
-    <!-- Field type demonstrating an Analyzer failure -->
-    <fieldType name="failtype1" class="solr.TextField">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- Demonstrating ignoreCaseChange -->
-    <fieldType name="wdf_nocase" class="solr.TextField">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    
-     <fieldType name="wdf_preserve" class="solr.TextField">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="1"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <!-- HighlitText optimizes storage for (long) columns which will be highlit -->
-    <fieldType name="highlittext" class="solr.TextField"/>
-
-    <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
-
-    <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
-         seconds part (.999) is optional.
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
+
+  <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
+
+  <!-- Field type demonstrating an Analyzer failure -->
+  <fieldType name="failtype1" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0"
+              catenateNumbers="0" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Demonstrating ignoreCaseChange -->
+  <fieldType name="wdf_nocase" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="wdf_preserve" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <!-- HighlitText optimizes storage for (long) columns which will be highlit -->
+  <fieldType name="highlittext" class="solr.TextField"/>
+
+  <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+
+  <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
+       seconds part (.999) is optional.
+    -->
+  <fieldType name="date" class="solr.TrieDateField" sortMissingLast="true"/>
+  <fieldType name="tdate" class="solr.TrieDateField" sortMissingLast="true" precisionStep="6"/>
+
+  <fieldType name="text" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="stopwords.txt"
+      />
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="stopwords.txt"
+      />
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <!-- A text field with defaults appropriate for English: it
+   tokenizes with StandardTokenizer, removes English stop words
+   (lang/stopwords_en.txt), down cases, protects words from protwords.txt, and
+   finally applies Porter's stemming.  The query time analyzer
+   also applies synonyms from synonyms.txt. -->
+  <fieldType name="text_en" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- in this example, we will only use synonyms at query time
+      <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
       -->
-    <fieldType name="date" class="solr.TrieDateField" sortMissingLast="true"/>
-    <fieldType name="tdate" class="solr.TrieDateField" sortMissingLast="true" precisionStep="6"/>
-
-  <fieldType name="text" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true" >
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="stopwords.txt"
-                />
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="stopwords.txt"
-                />
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <!-- A text field with defaults appropriate for English: it
-     tokenizes with StandardTokenizer, removes English stop words
-     (lang/stopwords_en.txt), down cases, protects words from protwords.txt, and
-     finally applies Porter's stemming.  The query time analyzer
-     also applies synonyms from synonyms.txt. -->
-    <fieldType name="text_en" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- in this example, we will only use synonyms at query time
-        <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
-        -->
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.EnglishPossessiveFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
-              <filter class="solr.EnglishMinimalStemFilterFactory"/>
-        -->
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.EnglishPossessiveFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
-              <filter class="solr.EnglishMinimalStemFilterFactory"/>
-        -->
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <!-- field type that doesn't generate phrases from unquoted multiple tokens per analysis unit -->
-   <fieldType name="text_np" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="stopwords.txt"
-                />
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="stopwords.txt"
-                />
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="nametext" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.core.WhitespaceAnalyzer"/>
-    </fieldType>
-
-    <fieldType name="teststop" class="solr.TextField">
-       <analyzer>
-        <tokenizer class="solr.LowerCaseTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-        <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- fieldTypes in this section isolate tokenizers and tokenfilters for testing -->
-    <fieldType name="lowertok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.LowerCaseTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="keywordtok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/></analyzer>
-    </fieldType>
-    <fieldType name="standardtok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.StandardTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="lettertok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.LetterTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="whitetok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.MockTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="HTMLstandardtok" class="solr.TextField">
-      <analyzer>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.EnglishPossessiveFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+            <filter class="solr.EnglishMinimalStemFilterFactory"/>
+      -->
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.EnglishPossessiveFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+            <filter class="solr.EnglishMinimalStemFilterFactory"/>
+      -->
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <!-- field type that doesn't generate phrases from unquoted multiple tokens per analysis unit -->
+  <fieldType name="text_np" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="stopwords.txt"
+      />
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="stopwords.txt"
+      />
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="nametext" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.core.WhitespaceAnalyzer"/>
+  </fieldType>
+
+  <fieldType name="teststop" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LowerCaseTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+      <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- fieldTypes in this section isolate tokenizers and tokenfilters for testing -->
+  <fieldType name="lowertok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LowerCaseTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="keywordtok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="standardtok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="lettertok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LetterTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="whitetok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="HTMLstandardtok" class="solr.TextField">
+    <analyzer>
       <charFilter class="solr.HTMLStripCharFilterFactory"/>
       <tokenizer class="solr.StandardTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="HTMLwhitetok" class="solr.TextField">
-      <analyzer>
+    </analyzer>
+  </fieldType>
+  <fieldType name="HTMLwhitetok" class="solr.TextField">
+    <analyzer>
       <charFilter class="solr.HTMLStripCharFilterFactory"/>
       <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="standardtokfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="standardfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="lowerfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="patternreplacefilt" class="solr.TextField">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
-        <filter class="solr.PatternReplaceFilterFactory"
-                pattern="([^a-zA-Z])" replacement="_" replace="all"
-        />
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="porterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="engporterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="custengporterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="stopfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="custstopfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="lengthfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LengthFilterFactory" min="2" max="5"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="limitfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LimitTokenCountFilterFactory" maxTokenCount="100" />
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="subword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.StopFilterFactory"/>
-          <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.StopFilterFactory"/>
-          <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="numericsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-          <filter class="solr.StopFilterFactory"/>
-          <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.StopFilterFactory"/>
-          <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="protectedsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <!-- more flexible in matching skus, but more chance of a false match -->
-    <fieldType name="skutype1" class="solr.TextField">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- less flexible in matching skus, but less chance of a false match -->
-    <fieldType name="skutype2" class="solr.TextField">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- less flexible in matching skus, but less chance of a false match -->
-    <fieldType name="syn" class="solr.TextField">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- a text field with the stop filter only on the query analyzer 
-     -->
-    <fieldType name="text_sw" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <!-- in this example, we will only use synonyms at query time
-        <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
-        -->
-        <!--<filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>-->
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
-                catenateNumbers="1" catenateAll="0" splitOnCaseChange="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
-                catenateNumbers="0" catenateAll="0" splitOnCaseChange="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    
-    <!-- Demonstrates How RemoveDuplicatesTokenFilter makes stemmed
-         synonyms "better"
+    </analyzer>
+  </fieldType>
+  <fieldType name="standardtokfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="standardfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="lowerfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="patternreplacefilt" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+      <filter class="solr.PatternReplaceFilterFactory"
+              pattern="([^a-zA-Z])" replacement="_" replace="all"
+      />
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="porterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="engporterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="custengporterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="stopfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="custstopfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="lengthfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LengthFilterFactory" min="2" max="5"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="limitfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LimitTokenCountFilterFactory" maxTokenCount="100"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="subword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="numericsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0"
+              splitOnCaseChange="0" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0"
+              catenateAll="0"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0"
+              splitOnCaseChange="0" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1"
+              catenateAll="0"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="protectedsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0"
+              splitOnCaseChange="0" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0"
+              catenateAll="0"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <!-- more flexible in matching skus, but more chance of a false match -->
+  <fieldType name="skutype1" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- less flexible in matching skus, but less chance of a false match -->
+  <fieldType name="skutype2" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- less flexible in matching skus, but less chance of a false match -->
+  <fieldType name="syn" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- a text field with the stop filter only on the query analyzer 
+   -->
+  <fieldType name="text_sw" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <!-- in this example, we will only use synonyms at query time
+      <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
       -->
-    <fieldType name="dedup" class="solr.TextField">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.SynonymFilterFactory"
-                  synonyms="synonyms.txt" expand="true" />
-          <filter class="solr.PorterStemFilterFactory"/>
-          <filter class="solr.RemoveDuplicatesTokenFilterFactory" />
-      </analyzer>
-    </fieldType>
+      <!--<filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>-->
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0" splitOnCaseChange="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
 
-    <fieldType  name="unstored" class="solr.StrField" indexed="true" stored="false"/>
+  <!-- Demonstrates How RemoveDuplicatesTokenFilter makes stemmed
+       synonyms "better"
+    -->
+  <fieldType name="dedup" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory"
+              synonyms="synonyms.txt" expand="true"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="unstored" class="solr.StrField" indexed="true" stored="false"/>
 
 
   <fieldType name="textgap" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-  </fieldType>
-
-  <fieldType name="uuid" class="solr.UUIDField" />
-  <fieldType name="ignored" class="solr.StrField" indexed="false" stored="false" />
-
-
-  <fieldType name="random" class="solr.RandomSortField" indexed="true" />  
-  
-    <!-- Poly field -->
-    <fieldType name="xy" class="solr.PointType" dimension="2" subFieldType="double"/>
-    <fieldType name="xyd" class="solr.PointType" dimension="2" subFieldSuffix="*_d"/>
-    <fieldType name="geohash" class="solr.GeoHashField"/>
-
-   <fieldType name="point" class="solr.PointType" dimension="2" subFieldSuffix="_d"/>
-    <!-- A specialized field for geospatial search. If indexed, this fieldType must not be multivalued. -->
-    <fieldType name="location" class="solr.LatLonType" subFieldSuffix="_coordinate"/>
-
-    <!-- Field type where english stopwords are managed by the REST API -->
-    <fieldType name="managed_en" class="solr.TextField">
-       <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.ManagedStopFilterFactory" managed="english" />
-        <filter class="solr.ManagedSynonymFilterFactory" managed="english" />
-      </analyzer>
-    </fieldType>
-
-    <!-- Field type where german stopwords are managed by the REST API -->
-    <fieldType name="managed_de" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.ManagedStopFilterFactory" managed="german" />
-        <filter class="solr.ManagedSynonymFilterFactory" managed="german" />
-      </analyzer>
-    </fieldType>
-
- </types>
-
-
- <fields>
-   <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="true"/>
-   <field name="signatureField" type="string" indexed="true" stored="false"/>
-   <field name="uuid" type="uuid" stored="true" />
-   <field name="name" type="nametext" indexed="true" stored="true"/>
-   <field name="text" type="text" indexed="true" stored="false" multiValued="true" />
-   <field name="subject" type="text" indexed="true" stored="true"/>
-   <field name="title" type="nametext" indexed="true" stored="true"/>
-   <field name="weight" type="float" indexed="true" stored="true"/>
-   <field name="bday" type="date" indexed="true" stored="true"/>
-
-   <field name="text_np" type="text_np" indexed="true" stored="false"/>
-
-   <field name="title_stemmed" type="text" indexed="true" stored="false"/>
-   <field name="title_lettertok" type="lettertok" indexed="true" stored="false"/>
-
-   <field name="syn" type="syn" indexed="true" stored="true"/>
-
-   <!-- to test property inheritance and overriding -->
-   <field name="shouldbeunstored" type="unstored" />
-   <field name="shouldbestored" type="unstored" stored="true"/>
-   <field name="shouldbeunindexed" type="unstored" indexed="false" stored="true"/>
-
-
-   <!-- test different combinations of indexed and stored -->
-   <field name="bind" type="boolean" indexed="true" stored="false"/>
-   <field name="bsto" type="boolean" indexed="false" stored="true"/>
-   <field name="bindsto" type="boolean" indexed="true" stored="true"/>
-   <field name="isto" type="int" indexed="false" stored="true"/>
-   <field name="iind" type="int" indexed="true" stored="false"/>
-   <field name="ssto" type="string" indexed="false" stored="true"/>
-   <field name="sind" type="string" indexed="true" stored="false"/>
-   <field name="sindsto" type="string" indexed="true" stored="true"/>
-
-   <!-- test combinations of term vector settings -->
-   <field name="test_basictv" type="text" termVectors="true"/>
-   <field name="test_notv" type="text" termVectors="false"/>
-   <field name="test_postv" type="text" termVectors="true" termPositions="true"/>
-   <field name="test_offtv" type="text" termVectors="true" termOffsets="true"/>
-   <field name="test_posofftv" type="text" termVectors="true" 
-     termPositions="true" termOffsets="true"/>
-
-   <!-- test highlit field settings -->
-   <field name="test_hlt" type="highlittext" indexed="true"/>
-   <field name="test_hlt_off" type="highlittext" indexed="true"/>
-
-   <!-- fields to test individual tokenizers and tokenfilters -->
-   <field name="teststop" type="teststop" indexed="true" stored="true"/>
-   <field name="lowertok" type="lowertok" indexed="true" stored="true"/>
-   <field name="keywordtok" type="keywordtok" indexed="true" stored="true"/>
-   <field name="standardtok" type="standardtok" indexed="true" stored="true"/>
-   <field name="HTMLstandardtok" type="HTMLstandardtok" indexed="true" stored="true"/>
-   <field name="lettertok" type="lettertok" indexed="true" stored="true"/>
-   <field name="whitetok" type="whitetok" indexed="true" stored="true"/>
-   <field name="HTMLwhitetok" type="HTMLwhitetok" indexed="true" stored="true"/>
-   <field name="standardtokfilt" type="standardtokfilt" indexed="true" stored="true"/>
-   <field name="standardfilt" type="standardfilt" indexed="true" stored="true"/>
-   <field name="lowerfilt" type="lowerfilt" indexed="true" stored="true"/>
-   <field name="patternreplacefilt" type="patternreplacefilt" indexed="true" stored="true"/>
-   <field name="porterfilt" type="porterfilt" indexed="true" stored="true"/>
-   <field name="engporterfilt" type="engporterfilt" indexed="true" stored="true"/>
-   <field name="custengporterfilt" type="custengporterfilt" indexed="true" stored="true"/>
-   <field name="stopfilt" type="stopfilt" indexed="true" stored="true"/>
-   <field name="custstopfilt" type="custstopfilt" indexed="true" stored="true"/>
-   <field name="lengthfilt" type="lengthfilt" indexed="true" stored="true"/>
-   <field name="dedup" type="dedup" indexed="true" stored="true"/>
-   <field name="wdf_nocase" type="wdf_nocase" indexed="true" stored="true"/>
-   <field name="wdf_preserve" type="wdf_preserve" indexed="true" stored="true"/>
-
-   <field name="numberpartfail" type="failtype1" indexed="true" stored="true"/>
-
-   <field name="nullfirst" type="string" indexed="true" stored="true" sortMissingFirst="true"/>
-
-   <field name="subword" type="subword" indexed="true" stored="true"/>
-   <field name="numericsubword" type="numericsubword" indexed="true" stored="true"/>
-   <field name="protectedsubword" type="protectedsubword" indexed="true" stored="true"/>
-
-   <field name="sku1" type="skutype1" indexed="true" stored="true"/>
-   <field name="sku2" type="skutype2" indexed="true" stored="true"/>
-
-   <field name="textgap" type="textgap" indexed="true" stored="true"/>
-   
-   <!--
-   <field name="timestamp" type="date" indexed="true" stored="true" default="NOW"/>
-   -->
-   <field name="timestamp" type="date" indexed="true" stored="true"/>
-
-   <!-- Test a point field for distances -->
-   <field name="point" type="xy" indexed="true" stored="true" multiValued="false"/>
-   <field name="pointD" type="xyd" indexed="true" stored="true" multiValued="false"/>
-   <field name="point_hash" type="geohash" indexed="true" stored="true" multiValued="false"/>
-   <field name="store" type="location" indexed="true" stored="true"/>
-   
-   <!-- to test uniq fields -->   
-   <field name="uniq" type="string" indexed="true" stored="true" multiValued="true"/>
-   <field name="uniq2" type="string" indexed="true" stored="true" multiValued="true"/>
-   <field name="uniq3" type="string" indexed="true" stored="true"/>
-   <field name="nouniq" type="string" indexed="true" stored="true" multiValued="true"/>
-
-   <!-- for versioning -->
-   <field name="_version_" type="long" indexed="true" stored="true"/>
-
-    
-   <field name="copyfield_source" type="string" indexed="true" stored="true" multiValued="true"/>
-
-
-
-   <dynamicField name="*_coordinate"  type="tdouble" indexed="true"  stored="false"/>
-
-   <dynamicField name="*_sI" type="string"  indexed="true"  stored="false"/>
-   <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
-   <dynamicField name="t_*"  type="text"    indexed="true"  stored="true"/>
-   <dynamicField name="tv_*"  type="text" indexed="true"  stored="true" 
-      termVectors="true" termPositions="true" termOffsets="true"/>
-   <dynamicField name="tv_mv_*"  type="text" indexed="true"  stored="true" multiValued="true"
-      termVectors="true" termPositions="true" termOffsets="true"/>
-
-   <dynamicField name="*_mfacet" type="string" indexed="true" stored="false" multiValued="true" />
-
-   <dynamicField name="*_sw" type="text_sw" indexed="true" stored="true" multiValued="true"/>
-
-   <dynamicField name="*_i"  type="int"    indexed="true"  stored="true"/>
-   <dynamicField name="*_is"  type="int"    indexed="true"  stored="true" multiValued="true"/>
-   <dynamicField name="*_s1"  type="string"  indexed="true" stored="true" multiValued="false"/>
-   <!-- :TODO: why are these identical?!?!?! -->
-   <dynamicField name="*_s"  type="string"  indexed="true"  stored="true" multiValued="true"/>
-   <dynamicField name="*_ss"  type="string"  indexed="true"  stored="true" multiValued="true"/>
-   <dynamicField name="*_l"  type="long"   indexed="true"  stored="true"/>
-   <dynamicField name="*_t"  type="text"    indexed="true"  stored="true"/>
-   <dynamicField name="*_tt"  type="text"    indexed="true"  stored="true"/>
-   <dynamicField name="*_b"  type="boolean" indexed="true"  stored="true"/>
-   <dynamicField name="*_f"  type="float"  indexed="true"  stored="true"/>
-   <dynamicField name="*_d"  type="double" indexed="true"  stored="true"/>
-   <dynamicField name="*_dt" type="date"    indexed="true"  stored="true"/>
-
-   <!-- some trie-coded dynamic fields for faster range queries -->
-   <dynamicField name="*_ti" type="tint"    indexed="true"  stored="true"/>
-   <dynamicField name="*_tl" type="tlong"   indexed="true"  stored="true"/>
-   <dynamicField name="*_tf" type="tfloat"  indexed="true"  stored="true"/>
-   <dynamicField name="*_td" type="tdouble" indexed="true"  stored="true"/>
-   <dynamicField name="*_tdt" type="tdate"  indexed="true"  stored="true"/>
-
-   <dynamicField name="ignored_*" type="ignored" multiValued="true"/>
-   <dynamicField name="attr_*" type="text" indexed="true" stored="true" multiValued="true"/>
-
-   <dynamicField name="random_*" type="random" />
-
- </fields>
-
- <defaultSearchField>text</defaultSearchField>
- <uniqueKey>id</uniqueKey>
-
-   <copyField source="title" dest="title_stemmed" maxChars="200"/>
-   <copyField source="title" dest="title_lettertok"/>
-
-   <copyField source="title" dest="text"/>
-   <copyField source="subject" dest="text"/>
-
-   <copyField source="copyfield_source" dest="text"/>
-   <copyField source="copyfield_source" dest="copyfield_dest_ss"/>  <!-- copyField into another stored copyField - not best practice -->
-
-   <copyField source="title" dest="dest_sub_no_ast_s"/>
-
-   <copyField source="*_i" dest="title"/>
-   <copyField source="*_i" dest="*_s"/>
-   <copyField source="*_i" dest="*_dest_sub_s"/>
-   <copyField source="*_i" dest="dest_sub_no_ast_s"/>
-
-   <copyField source="*_src_sub_i" dest="title"/>
-   <copyField source="*_src_sub_i" dest="*_s"/>
-   <copyField source="*_src_sub_i" dest="*_dest_sub_s"/>
-   <copyField source="*_src_sub_i" dest="dest_sub_no_ast_s"/>
-
-   <copyField source="src_sub_no_ast_i" dest="title"/>
-   <copyField source="src_sub_no_ast_i" dest="*_s"/>
-   <copyField source="src_sub_no_ast_i" dest="*_dest_sub_s"/>
-   <copyField source="src_sub_no_ast_i" dest="dest_sub_no_ast_s"/>
-
-   <!-- test source glob matching multiple explicit fields: title_stemmed and title_lettertok -->
-   <copyField source="title_*" dest="text"/>
-   <copyField source="title_*" dest="*_s"/>
-   <copyField source="title_*" dest="*_dest_sub_s"/>
-   <copyField source="title_*" dest="dest_sub_no_ast_s"/>
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="uuid" class="solr.UUIDField"/>
+  <fieldType name="ignored" class="solr.StrField" indexed="false" stored="false"/>
+
+
+  <fieldType name="random" class="solr.RandomSortField" indexed="true"/>
+
+  <!-- Poly field -->
+  <fieldType name="xy" class="solr.PointType" dimension="2" subFieldType="double"/>
+  <fieldType name="xyd" class="solr.PointType" dimension="2" subFieldSuffix="*_d"/>
+  <fieldType name="geohash" class="solr.GeoHashField"/>
+
+  <fieldType name="point" class="solr.PointType" dimension="2" subFieldSuffix="_d"/>
+  <!-- A specialized field for geospatial search. If indexed, this fieldType must not be multivalued. -->
+  <fieldType name="location" class="solr.LatLonType" subFieldSuffix="_coordinate"/>
+
+  <!-- Field type where english stopwords are managed by the REST API -->
+  <fieldType name="managed_en" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.ManagedStopFilterFactory" managed="english"/>
+      <filter class="solr.ManagedSynonymFilterFactory" managed="english"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Field type where german stopwords are managed by the REST API -->
+  <fieldType name="managed_de" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.ManagedStopFilterFactory" managed="german"/>
+      <filter class="solr.ManagedSynonymFilterFactory" managed="german"/>
+    </analyzer>
+  </fieldType>
+
+  <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="true"/>
+  <field name="signatureField" type="string" indexed="true" stored="false"/>
+  <field name="uuid" type="uuid" stored="true"/>
+  <field name="name" type="nametext" indexed="true" stored="true"/>
+  <field name="text" type="text" indexed="true" stored="false" multiValued="true"/>
+  <field name="subject" type="text" indexed="true" stored="true"/>
+  <field name="title" type="nametext" indexed="true" stored="true"/>
+  <field name="weight" type="float" indexed="true" stored="true"/>
+  <field name="bday" type="date" indexed="true" stored="true"/>
+
+  <field name="text_np" type="text_np" indexed="true" stored="false"/>
+
+  <field name="title_stemmed" type="text" indexed="true" stored="false"/>
+  <field name="title_lettertok" type="lettertok" indexed="true" stored="false"/>
+
+  <field name="syn" type="syn" indexed="true" stored="true"/>
+
+  <!-- to test property inheritance and overriding -->
+  <field name="shouldbeunstored" type="unstored"/>
+  <field name="shouldbestored" type="unstored" stored="true"/>
+  <field name="shouldbeunindexed" type="unstored" indexed="false" stored="true"/>
+
+
+  <!-- test different combinations of indexed and stored -->
+  <field name="bind" type="boolean" indexed="true" stored="false"/>
+  <field name="bsto" type="boolean" indexed="false" stored="true"/>
+  <field name="bindsto" type="boolean" indexed="true" stored="true"/>
+  <field name="isto" type="int" indexed="false" stored="true"/>
+  <field name="iind" type="int" indexed="true" stored="false"/>
+  <field name="ssto" type="string" indexed="false" stored="true"/>
+  <field name="sind" type="string" indexed="true" stored="false"/>
+  <field name="sindsto" type="string" indexed="true" stored="true"/>
+
+  <!-- test combinations of term vector settings -->
+  <field name="test_basictv" type="text" termVectors="true"/>
+  <field name="test_notv" type="text" termVectors="false"/>
+  <field name="test_postv" type="text" termVectors="true" termPositions="true"/>
+  <field name="test_offtv" type="text" termVectors="true" termOffsets="true"/>
+  <field name="test_posofftv" type="text" termVectors="true"
+         termPositions="true" termOffsets="true"/>
+
+  <!-- test highlit field settings -->
+  <field name="test_hlt" type="highlittext" indexed="true"/>
+  <field name="test_hlt_off" type="highlittext" indexed="true"/>
+
+  <!-- fields to test individual tokenizers and tokenfilters -->
+  <field name="teststop" type="teststop" indexed="true" stored="true"/>
+  <field name="lowertok" type="lowertok" indexed="true" stored="true"/>
+  <field name="keywordtok" type="keywordtok" indexed="true" stored="true"/>
+  <field name="standardtok" type="standardtok" indexed="true" stored="true"/>
+  <field name="HTMLstandardtok" type="HTMLstandardtok" indexed="true" stored="true"/>
+  <field name="lettertok" type="lettertok" indexed="true" stored="true"/>
+  <field name="whitetok" type="whitetok" indexed="true" stored="true"/>
+  <field name="HTMLwhitetok" type="HTMLwhitetok" indexed="true" stored="true"/>
+  <field name="standardtokfilt" type="standardtokfilt" indexed="true" stored="true"/>
+  <field name="standardfilt" type="standardfilt" indexed="true" stored="true"/>
+  <field name="lowerfilt" type="lowerfilt" indexed="true" stored="true"/>
+  <field name="patternreplacefilt" type="patternreplacefilt" indexed="true" stored="true"/>
+  <field name="porterfilt" type="porterfilt" indexed="true" stored="true"/>
+  <field name="engporterfilt" type="engporterfilt" indexed="true" stored="true"/>
+  <field name="custengporterfilt" type="custengporterfilt" indexed="true" stored="true"/>
+  <field name="stopfilt" type="stopfilt" indexed="true" stored="true"/>
+  <field name="custstopfilt" type="custstopfilt" indexed="true" stored="true"/>
+  <field name="lengthfilt" type="lengthfilt" indexed="true" stored="true"/>
+  <field name="dedup" type="dedup" indexed="true" stored="true"/>
+  <field name="wdf_nocase" type="wdf_nocase" indexed="true" stored="true"/>
+  <field name="wdf_preserve" type="wdf_preserve" indexed="true" stored="true"/>
+
+  <field name="numberpartfail" type="failtype1" indexed="true" stored="true"/>
+
+  <field name="nullfirst" type="string" indexed="true" stored="true" sortMissingFirst="true"/>
+
+  <field name="subword" type="subword" indexed="true" stored="true"/>
+  <field name="numericsubword" type="numericsubword" indexed="true" stored="true"/>
+  <field name="protectedsubword" type="protectedsubword" indexed="true" stored="true"/>
+
+  <field name="sku1" type="skutype1" indexed="true" stored="true"/>
+  <field name="sku2" type="skutype2" indexed="true" stored="true"/>
+
+  <field name="textgap" type="textgap" indexed="true" stored="true"/>
+
+  <!--
+  <field name="timestamp" type="date" indexed="true" stored="true" default="NOW"/>
+  -->
+  <field name="timestamp" type="date" indexed="true" stored="true"/>
+
+  <!-- Test a point field for distances -->
+  <field name="point" type="xy" indexed="true" stored="true" multiValued="false"/>
+  <field name="pointD" type="xyd" indexed="true" stored="true" multiValued="false"/>
+  <field name="point_hash" type="geohash" indexed="true" stored="true" multiValued="false"/>
+  <field name="store" type="location" indexed="true" stored="true"/>
+
+  <!-- to test uniq fields -->
+  <field name="uniq" type="string" indexed="true" stored="true" multiValued="true"/>
+  <field name="uniq2" type="string" indexed="true" stored="true" multiValued="true"/>
+  <field name="uniq3" type="string" indexed="true" stored="true"/>
+  <field name="nouniq" type="string" indexed="true" stored="true" multiValued="true"/>
+
+  <!-- for versioning -->
+  <field name="_version_" type="long" indexed="true" stored="true"/>
+
+
+  <field name="copyfield_source" type="string" indexed="true" stored="true" multiValued="true"/>
+
+
+  <dynamicField name="*_coordinate" type="tdouble" indexed="true" stored="false"/>
+
+  <dynamicField name="*_sI" type="string" indexed="true" stored="false"/>
+  <dynamicField name="*_sS" type="string" indexed="false" stored="true"/>
+  <dynamicField name="t_*" type="text" indexed="true" stored="true"/>
+  <dynamicField name="tv_*" type="text" indexed="true" stored="true"
+                termVectors="true" termPositions="true" termOffsets="true"/>
+  <dynamicField name="tv_mv_*" type="text" indexed="true" stored="true" multiValued="true"
+                termVectors="true" termPositions="true" termOffsets="true"/>
+
+  <dynamicField name="*_mfacet" type="string" indexed="true" stored="false" multiValued="true"/>
+
+  <dynamicField name="*_sw" type="text_sw" indexed="true" stored="true" multiValued="true"/>
+
+  <dynamicField name="*_i" type="int" indexed="true" stored="true"/>
+  <dynamicField name="*_is" type="int" indexed="true" stored="true" multiValued="true"/>
+  <dynamicField name="*_s1" type="string" indexed="true" stored="true" multiValued="false"/>
+  <!-- :TODO: why are these identical?!?!?! -->
+  <dynamicField name="*_s" type="string" indexed="true" stored="true" multiValued="true"/>
+  <dynamicField name="*_ss" type="string" indexed="true" stored="true" multiValued="true"/>
+  <dynamicField name="*_l" type="long" indexed="true" stored="true"/>
+  <dynamicField name="*_t" type="text" indexed="true" stored="true"/>
+  <dynamicField name="*_tt" type="text" indexed="true" stored="true"/>
+  <dynamicField name="*_b" type="boolean" indexed="true" stored="true"/>
+  <dynamicField name="*_f" type="float" indexed="true" stored="true"/>
+  <dynamicField name="*_d" type="double" indexed="true" stored="true"/>
+  <dynamicField name="*_dt" type="date" indexed="true" stored="true"/>
+
+  <!-- some trie-coded dynamic fields for faster range queries -->
+  <dynamicField name="*_ti" type="tint" indexed="true" stored="true"/>
+  <dynamicField name="*_tl" type="tlong" indexed="true" stored="true"/>
+  <dynamicField name="*_tf" type="tfloat" indexed="true" stored="true"/>
+  <dynamicField name="*_td" type="tdouble" indexed="true" stored="true"/>
+  <dynamicField name="*_tdt" type="tdate" indexed="true" stored="true"/>
+
+  <dynamicField name="ignored_*" type="ignored" multiValued="true"/>
+  <dynamicField name="attr_*" type="text" indexed="true" stored="true" multiValued="true"/>
+
+  <dynamicField name="random_*" type="random"/>
+
+
+  <defaultSearchField>text</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
+
+  <copyField source="title" dest="title_stemmed" maxChars="200"/>
+  <copyField source="title" dest="title_lettertok"/>
+
+  <copyField source="title" dest="text"/>
+  <copyField source="subject" dest="text"/>
+
+  <copyField source="copyfield_source" dest="text"/>
+  <copyField source="copyfield_source"
+             dest="copyfield_dest_ss"/>  <!-- copyField into another stored copyField - not best practice -->
+
+  <copyField source="title" dest="dest_sub_no_ast_s"/>
+
+  <copyField source="*_i" dest="title"/>
+  <copyField source="*_i" dest="*_s"/>
+  <copyField source="*_i" dest="*_dest_sub_s"/>
+  <copyField source="*_i" dest="dest_sub_no_ast_s"/>
+
+  <copyField source="*_src_sub_i" dest="title"/>
+  <copyField source="*_src_sub_i" dest="*_s"/>
+  <copyField source="*_src_sub_i" dest="*_dest_sub_s"/>
+  <copyField source="*_src_sub_i" dest="dest_sub_no_ast_s"/>
+
+  <copyField source="src_sub_no_ast_i" dest="title"/>
+  <copyField source="src_sub_no_ast_i" dest="*_s"/>
+  <copyField source="src_sub_no_ast_i" dest="*_dest_sub_s"/>
+  <copyField source="src_sub_no_ast_i" dest="dest_sub_no_ast_s"/>
+
+  <!-- test source glob matching multiple explicit fields: title_stemmed and title_lettertok -->
+  <copyField source="title_*" dest="text"/>
+  <copyField source="title_*" dest="*_s"/>
+  <copyField source="title_*" dest="*_dest_sub_s"/>
+  <copyField source="title_*" dest="dest_sub_no_ast_s"/>
 
   <solrQueryParser defaultOperator="OR"/>
 
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-reversed.xml b/solr/core/src/test-files/solr/collection1/conf/schema-reversed.xml
index 80a0bc6..8730e93 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-reversed.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-reversed.xml
@@ -22,67 +22,63 @@
   -->
 
 <schema name="test" version="1.0">
-  <types>
-
-
-    <fieldType name="long" class="solr.TrieLongField" />
-    <fieldType name="integer" class="solr.TrieIntField" precisionStep="0"/>
-    <fieldType name="string" class="solr.StrField" />
-
-    <fieldType name="text" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    
-    <fieldType name="srev" class="solr.TextField">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.ReversedWildcardFilterFactory" withOriginal="true"
-            maxPosAsterisk="3" maxPosQuestion="2" maxFractionAsterisk="0.33"/>
-      </analyzer>
-
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-
-      </analyzer>
-    </fieldType>
-    <fieldType name="rev" class="solr.TextField">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.ReversedWildcardFilterFactory" withOriginal="false"
-            maxPosAsterisk="3" maxPosQuestion="2" maxFractionAsterisk="0.33"
-            minTrailing="1"/>
-      </analyzer>
-
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-
-      </analyzer>
-    </fieldType>
- </types>
-
-
- <fields>
-   <field name="id" type="integer" indexed="true" stored="true" multiValued="false" required="false"/>
-   <field name="one" type="srev" indexed="true" stored="false"/>
-   <field name="two" type="rev" indexed="true" stored="false"/>
-   <field name="three" type="text" indexed="true" stored="false"/>
-
-   <field name="_version_" type="long" indexed="true" stored="true" multiValued="false" />
-
-   <field name="signatureField" type="string" indexed="true" stored="false"/>
-   <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
-
- </fields>
-
- <defaultSearchField>one</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+
+
+  <fieldType name="long" class="solr.TrieLongField"/>
+  <fieldType name="integer" class="solr.TrieIntField" precisionStep="0"/>
+  <fieldType name="string" class="solr.StrField"/>
+
+  <fieldType name="text" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="srev" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.ReversedWildcardFilterFactory" withOriginal="true"
+              maxPosAsterisk="3" maxPosQuestion="2" maxFractionAsterisk="0.33"/>
+    </analyzer>
+
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+
+    </analyzer>
+  </fieldType>
+  <fieldType name="rev" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.ReversedWildcardFilterFactory" withOriginal="false"
+              maxPosAsterisk="3" maxPosQuestion="2" maxFractionAsterisk="0.33"
+              minTrailing="1"/>
+    </analyzer>
+
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+
+    </analyzer>
+  </fieldType>
+
+
+  <field name="id" type="integer" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="one" type="srev" indexed="true" stored="false"/>
+  <field name="two" type="rev" indexed="true" stored="false"/>
+  <field name="three" type="text" indexed="true" stored="false"/>
+
+  <field name="_version_" type="long" indexed="true" stored="true" multiValued="false"/>
+
+  <field name="signatureField" type="string" indexed="true" stored="false"/>
+  <dynamicField name="*_sS" type="string" indexed="false" stored="true"/>
+
+
+  <defaultSearchField>one</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-sim.xml b/solr/core/src/test-files/solr/collection1/conf/schema-sim.xml
index 914d871..cffd1e5 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-sim.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-sim.xml
@@ -19,9 +19,8 @@
 <!-- Per-field similarity example for testing -->
 
 <schema name="test" version="1.0">
-  <types>
   <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-  <!--  some per-field similarity examples --> 
+  <!--  some per-field similarity examples -->
   <!--  specify a Similarity classname directly -->
   <fieldType name="sim1" class="solr.TextField">
     <analyzer>
@@ -30,7 +29,7 @@
     <similarity class="org.apache.lucene.misc.SweetSpotSimilarity"/>
   </fieldType>
 
-  <!--  specify a Similarity factory -->  
+  <!--  specify a Similarity factory -->
   <fieldType name="sim2" class="solr.TextField">
     <analyzer>
       <tokenizer class="solr.MockTokenizerFactory"/>
@@ -39,36 +38,33 @@
       <str name="echo">is there an echo?</str>
     </similarity>
   </fieldType>
-  
+
   <!-- don't specify any sim at all: get the default  -->
   <fieldType name="sim3" class="solr.TextField">
     <analyzer>
       <tokenizer class="solr.MockTokenizerFactory"/>
     </analyzer>
   </fieldType>
- </types>
 
- <fields>
-   <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
-   <field name="sim1text" type="sim1" indexed="true" stored="true"/>
-   <field name="sim2text" type="sim2" indexed="true" stored="true"/>
-   <field name="sim3text" type="sim3" indexed="true" stored="true"/>
+  <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="sim1text" type="sim1" indexed="true" stored="true"/>
+  <field name="sim2text" type="sim2" indexed="true" stored="true"/>
+  <field name="sim3text" type="sim3" indexed="true" stored="true"/>
 
-   <!-- make sure custom sims work with dynamic fields -->
-   <dynamicField name="*_sim1" type="sim1" indexed="true" stored="true"/>
-   <dynamicField name="*_sim2" type="sim2" indexed="true" stored="true"/>
-   <dynamicField name="*_sim3" type="sim3" indexed="true" stored="true"/>
- </fields>
+  <!-- make sure custom sims work with dynamic fields -->
+  <dynamicField name="*_sim1" type="sim1" indexed="true" stored="true"/>
+  <dynamicField name="*_sim2" type="sim2" indexed="true" stored="true"/>
+  <dynamicField name="*_sim3" type="sim3" indexed="true" stored="true"/>
 
- <defaultSearchField>sim1text</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+  <defaultSearchField>sim1text</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 
- <!-- Global similarity, defers to the fieldType.
-      
-      Even though SchemaSimilarityFactory is the current implicit default in IndexSchema, we
-      are explicit about it here in this schema file because TestPerFieldSimilarityClassic overrides
-      the luceneMatchVersion which results in a diff implicit global default - but we still
-      need per-fieldtype sims for that test.
- -->
- <similarity class="solr.SchemaSimilarityFactory"/>
+  <!-- Global similarity, defers to the fieldType.
+       
+       Even though SchemaSimilarityFactory is the current implicit default in IndexSchema, we
+       are explicit about it here in this schema file because TestPerFieldSimilarityClassic overrides
+       the luceneMatchVersion which results in a diff implicit global default - but we still
+       need per-fieldtype sims for that test.
+  -->
+  <similarity class="solr.SchemaSimilarityFactory"/>
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-simpleqpplugin.xml b/solr/core/src/test-files/solr/collection1/conf/schema-simpleqpplugin.xml
index 825836a..507024f 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-simpleqpplugin.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-simpleqpplugin.xml
@@ -20,45 +20,41 @@
 <!-- Test schema file for SimpleQParserPlugin. -->
 
 <schema name="simpleqp" version="1.0">
-  <types>
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-
-    <!-- basic text field: no offsets -->
-    <fieldType name="text" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory" pattern="whitespace"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.ASCIIFoldingFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- basic text field: except it will use the keyword analyzer -->
-    <fieldType name="text-keyword" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- basic text field: except it will use the keyword analyzer -->
-    <fieldType name="text-query" class="solr.TextField">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory" pattern="whitespace"/>
-      </analyzer>
-      <!-- only lower case at query time, so we can check the query analyzer is used -->
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory" pattern="whitespace"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-  </types>
-
-  <fields>
-    <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
-    <field name="text0" type="text" indexed="true" stored="true"/>
-    <field name="text1" type="text" indexed="true" stored="true"/>
-    <field name="text-keyword0" type="text-keyword" indexed="true" stored="true"/>
-    <field name="text-query0" type="text-query" indexed="true" stored="true"/>
-  </fields>
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+
+  <!-- basic text field: no offsets -->
+  <fieldType name="text" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory" pattern="whitespace"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.ASCIIFoldingFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- basic text field: except it will use the keyword analyzer -->
+  <fieldType name="text-keyword" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- basic text field: except it will use the keyword analyzer -->
+  <fieldType name="text-query" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory" pattern="whitespace"/>
+    </analyzer>
+    <!-- only lower case at query time, so we can check the query analyzer is used -->
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory" pattern="whitespace"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="text0" type="text" indexed="true" stored="true"/>
+  <field name="text1" type="text" indexed="true" stored="true"/>
+  <field name="text-keyword0" type="text-keyword" indexed="true" stored="true"/>
+  <field name="text-query0" type="text-query" indexed="true" stored="true"/>
 
   <defaultSearchField>text0</defaultSearchField>
   <uniqueKey>id</uniqueKey>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-single-dynamic-copy-field.xml b/solr/core/src/test-files/solr/collection1/conf/schema-single-dynamic-copy-field.xml
index 3b514dd..f7cbf6d 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-single-dynamic-copy-field.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-single-dynamic-copy-field.xml
@@ -31,578 +31,600 @@
          1.5: omitNorms defaults to true for primitive field types (int, float, boolean, string...)
          1.6: useDocValuesAsStored defaults to true.
        -->
-  <types>
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
-
-    <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
-
-    <!-- Field type demonstrating an Analyzer failure -->
-    <fieldType name="failtype1" class="solr.TextField">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- Demonstrating ignoreCaseChange -->
-    <fieldType name="wdf_nocase" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="wdf_preserve" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <!-- HighlitText optimizes storage for (long) columns which will be highlit -->
-    <fieldType name="highlittext" class="solr.TextField"/>
-
-    <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
-
-    <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
-             seconds part (.999) is optional.
-          -->
-    <fieldType name="date" class="solr.TrieDateField" sortMissingLast="true"/>
-    <fieldType name="tdate" class="solr.TrieDateField" sortMissingLast="true" precisionStep="6"/>
-
-    <fieldType name="text" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true" >
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="stopwords.txt"
-            />
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="stopwords.txt"
-            />
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <!-- A text field with defaults appropriate for English: it
-         tokenizes with StandardTokenizer, removes English stop words
-         (lang/stopwords_en.txt), down cases, protects words from protwords.txt, and
-         finally applies Porter's stemming.  The query time analyzer
-         also applies synonyms from synonyms.txt. -->
-    <fieldType name="text_en" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- in this example, we will only use synonyms at query time
-                <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
-                -->
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.EnglishPossessiveFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
-                      <filter class="solr.EnglishMinimalStemFilterFactory"/>
-                -->
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.EnglishPossessiveFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
-                      <filter class="solr.EnglishMinimalStemFilterFactory"/>
-                -->
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <!-- field type that doesn't generate phrases from unquoted multiple tokens per analysis unit -->
-    <fieldType name="text_np" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="stopwords.txt"
-            />
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="stopwords.txt"
-            />
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="nametext" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.core.WhitespaceAnalyzer"/>
-    </fieldType>
-
-    <fieldType name="teststop" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.LowerCaseTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-        <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- fieldTypes in this section isolate tokenizers and tokenfilters for testing -->
-    <fieldType name="lowertok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.LowerCaseTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="keywordtok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/></analyzer>
-    </fieldType>
-    <fieldType name="standardtok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.StandardTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="lettertok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.LetterTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="whitetok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.MockTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="HTMLstandardtok" class="solr.TextField">
-      <analyzer>
-        <charFilter class="solr.HTMLStripCharFilterFactory"/>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="HTMLwhitetok" class="solr.TextField">
-      <analyzer>
-        <charFilter class="solr.HTMLStripCharFilterFactory"/>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="standardtokfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="standardfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="lowerfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="patternreplacefilt" class="solr.TextField">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
-        <filter class="solr.PatternReplaceFilterFactory"
-                pattern="([^a-zA-Z])" replacement="_" replace="all"
-            />
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="porterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="engporterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="custengporterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="stopfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="custstopfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="lengthfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LengthFilterFactory" min="2" max="5"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="limitfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LimitTokenCountFilterFactory" maxTokenCount="100" />
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="subword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="numericsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-        <filter class="solr.StopFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-        <filter class="solr.StopFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="protectedsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <!-- more flexible in matching skus, but more chance of a false match -->
-    <fieldType name="skutype1" class="solr.TextField">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- less flexible in matching skus, but less chance of a false match -->
-    <fieldType name="skutype2" class="solr.TextField">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- less flexible in matching skus, but less chance of a false match -->
-    <fieldType name="syn" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- a text field with the stop filter only on the query analyzer 
-         -->
-    <fieldType name="text_sw" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <!-- in this example, we will only use synonyms at query time
-                <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
-                -->
-        <!--<filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>-->
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
-                catenateNumbers="1" catenateAll="0" splitOnCaseChange="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
-                catenateNumbers="0" catenateAll="0" splitOnCaseChange="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <!-- Demonstrates How RemoveDuplicatesTokenFilter makes stemmed
-             synonyms "better"
-          -->
-    <fieldType name="dedup" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory"
-                synonyms="synonyms.txt" expand="true" />
-        <filter class="solr.PorterStemFilterFactory"/>
-        <filter class="solr.RemoveDuplicatesTokenFilterFactory" />
-      </analyzer>
-    </fieldType>
-
-    <fieldType  name="unstored" class="solr.StrField" indexed="true" stored="false"/>
-
-
-    <fieldType name="textgap" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="uuid" class="solr.UUIDField" />
-    <fieldType name="ignored" class="solr.StrField" indexed="false" stored="false" />
-
-
-    <fieldType name="random" class="solr.RandomSortField" indexed="true" />
-
-    <!-- Poly field -->
-    <fieldType name="xy" class="solr.PointType" dimension="2" subFieldType="double"/>
-    <fieldType name="xyd" class="solr.PointType" dimension="2" subFieldSuffix="*_d"/>
-    <fieldType name="geohash" class="solr.GeoHashField"/>
-
-    <fieldType name="point" class="solr.PointType" dimension="2" subFieldSuffix="_d"/>
-    <!-- A specialized field for geospatial search. If indexed, this fieldType must not be multivalued. -->
-    <fieldType name="location" class="solr.LatLonType" subFieldSuffix="_coordinate"/>
-
-    <!-- Field type where english stopwords are managed by the REST API -->
-    <fieldType name="managed_en" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.ManagedStopFilterFactory" managed="english" />
-        <filter class="solr.ManagedSynonymFilterFactory" managed="english" />
-      </analyzer>
-    </fieldType>
-
-    <!-- Field type where german stopwords are managed by the REST API -->
-    <fieldType name="managed_de" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.ManagedStopFilterFactory" managed="german" />
-        <filter class="solr.ManagedSynonymFilterFactory" managed="german" />
-      </analyzer>
-    </fieldType>
-
-  </types>
-
-
-  <fields>
-    <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="true"/>
-    <field name="signatureField" type="string" indexed="true" stored="false"/>
-    <field name="uuid" type="uuid" stored="true" />
-    <field name="name" type="nametext" indexed="true" stored="true"/>
-    <field name="text" type="text" indexed="true" stored="false" multiValued="true" />
-    <field name="subject" type="text" indexed="true" stored="true"/>
-    <field name="title" type="nametext" indexed="true" stored="true"/>
-    <field name="weight" type="float" indexed="true" stored="true"/>
-    <field name="bday" type="date" indexed="true" stored="true"/>
-
-    <field name="text_np" type="text_np" indexed="true" stored="false"/>
-
-    <field name="title_stemmed" type="text" indexed="true" stored="false"/>
-    <field name="title_lettertok" type="lettertok" indexed="true" stored="false"/>
-
-    <field name="syn" type="syn" indexed="true" stored="true"/>
-
-    <!-- to test property inheritance and overriding -->
-    <field name="shouldbeunstored" type="unstored" />
-    <field name="shouldbestored" type="unstored" stored="true"/>
-    <field name="shouldbeunindexed" type="unstored" indexed="false" stored="true"/>
-
-
-    <!-- test different combinations of indexed and stored -->
-    <field name="bind" type="boolean" indexed="true" stored="false"/>
-    <field name="bsto" type="boolean" indexed="false" stored="true"/>
-    <field name="bindsto" type="boolean" indexed="true" stored="true"/>
-    <field name="isto" type="int" indexed="false" stored="true"/>
-    <field name="iind" type="int" indexed="true" stored="false"/>
-    <field name="ssto" type="string" indexed="false" stored="true"/>
-    <field name="sind" type="string" indexed="true" stored="false"/>
-    <field name="sindsto" type="string" indexed="true" stored="true"/>
-
-    <!-- test combinations of term vector settings -->
-    <field name="test_basictv" type="text" termVectors="true"/>
-    <field name="test_notv" type="text" termVectors="false"/>
-    <field name="test_postv" type="text" termVectors="true" termPositions="true"/>
-    <field name="test_offtv" type="text" termVectors="true" termOffsets="true"/>
-    <field name="test_posofftv" type="text" termVectors="true"
-           termPositions="true" termOffsets="true"/>
-
-    <!-- test highlit field settings -->
-    <field name="test_hlt" type="highlittext" indexed="true"/>
-    <field name="test_hlt_off" type="highlittext" indexed="true"/>
-
-    <!-- fields to test individual tokenizers and tokenfilters -->
-    <field name="teststop" type="teststop" indexed="true" stored="true"/>
-    <field name="lowertok" type="lowertok" indexed="true" stored="true"/>
-    <field name="keywordtok" type="keywordtok" indexed="true" stored="true"/>
-    <field name="standardtok" type="standardtok" indexed="true" stored="true"/>
-    <field name="HTMLstandardtok" type="HTMLstandardtok" indexed="true" stored="true"/>
-    <field name="lettertok" type="lettertok" indexed="true" stored="true"/>
-    <field name="whitetok" type="whitetok" indexed="true" stored="true"/>
-    <field name="HTMLwhitetok" type="HTMLwhitetok" indexed="true" stored="true"/>
-    <field name="standardtokfilt" type="standardtokfilt" indexed="true" stored="true"/>
-    <field name="standardfilt" type="standardfilt" indexed="true" stored="true"/>
-    <field name="lowerfilt" type="lowerfilt" indexed="true" stored="true"/>
-    <field name="patternreplacefilt" type="patternreplacefilt" indexed="true" stored="true"/>
-    <field name="porterfilt" type="porterfilt" indexed="true" stored="true"/>
-    <field name="engporterfilt" type="engporterfilt" indexed="true" stored="true"/>
-    <field name="custengporterfilt" type="custengporterfilt" indexed="true" stored="true"/>
-    <field name="stopfilt" type="stopfilt" indexed="true" stored="true"/>
-    <field name="custstopfilt" type="custstopfilt" indexed="true" stored="true"/>
-    <field name="lengthfilt" type="lengthfilt" indexed="true" stored="true"/>
-    <field name="dedup" type="dedup" indexed="true" stored="true"/>
-    <field name="wdf_nocase" type="wdf_nocase" indexed="true" stored="true"/>
-    <field name="wdf_preserve" type="wdf_preserve" indexed="true" stored="true"/>
-
-    <field name="numberpartfail" type="failtype1" indexed="true" stored="true"/>
-
-    <field name="nullfirst" type="string" indexed="true" stored="true" sortMissingFirst="true"/>
-
-    <field name="subword" type="subword" indexed="true" stored="true"/>
-    <field name="numericsubword" type="numericsubword" indexed="true" stored="true"/>
-    <field name="protectedsubword" type="protectedsubword" indexed="true" stored="true"/>
-
-    <field name="sku1" type="skutype1" indexed="true" stored="true"/>
-    <field name="sku2" type="skutype2" indexed="true" stored="true"/>
-
-    <field name="textgap" type="textgap" indexed="true" stored="true"/>
-
-    <!--
-        <field name="timestamp" type="date" indexed="true" stored="true" default="NOW"/>
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
+
+  <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
+
+  <!-- Field type demonstrating an Analyzer failure -->
+  <fieldType name="failtype1" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0"
+              catenateNumbers="0" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Demonstrating ignoreCaseChange -->
+  <fieldType name="wdf_nocase" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="wdf_preserve" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <!-- HighlitText optimizes storage for (long) columns which will be highlit -->
+  <fieldType name="highlittext" class="solr.TextField"/>
+
+  <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+
+  <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
+           seconds part (.999) is optional.
         -->
-    <field name="timestamp" type="date" indexed="true" stored="true"/>
-
-    <!-- Test a point field for distances -->
-    <field name="point" type="xy" indexed="true" stored="true" multiValued="false"/>
-    <field name="pointD" type="xyd" indexed="true" stored="true" multiValued="false"/>
-    <field name="point_hash" type="geohash" indexed="true" stored="true" multiValued="false"/>
-    <field name="store" type="location" indexed="true" stored="true"/>
-
-    <!-- to test uniq fields -->
-    <field name="uniq" type="string" indexed="true" stored="true" multiValued="true"/>
-    <field name="uniq2" type="string" indexed="true" stored="true" multiValued="true"/>
-    <field name="uniq3" type="string" indexed="true" stored="true"/>
-    <field name="nouniq" type="string" indexed="true" stored="true" multiValued="true"/>
-
-    <!-- for versioning -->
-    <field name="_version_" type="long" indexed="true" stored="true"/>
-
-
-    <field name="copyfield_source" type="string" indexed="true" stored="true" multiValued="true"/>
-
-
-
-    <dynamicField name="*_coordinate"  type="tdouble" indexed="true"  stored="false"/>
-
-    <dynamicField name="*_sI" type="string"  indexed="true"  stored="false"/>
-    <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
-    <dynamicField name="t_*"  type="text"    indexed="true"  stored="true"/>
-    <dynamicField name="tv_*"  type="text" indexed="true"  stored="true"
-                  termVectors="true" termPositions="true" termOffsets="true"/>
-    <dynamicField name="tv_mv_*"  type="text" indexed="true"  stored="true" multiValued="true"
-                  termVectors="true" termPositions="true" termOffsets="true"/>
-
-    <dynamicField name="*_mfacet" type="string" indexed="true" stored="false" multiValued="true" />
-
-    <dynamicField name="*_sw" type="text_sw" indexed="true" stored="true" multiValued="true"/>
-
-    <dynamicField name="*_i"  type="int"    indexed="true"  stored="true"/>
-    <dynamicField name="*_is"  type="int"    indexed="true"  stored="true" multiValued="true"/>
-    <dynamicField name="*_s1"  type="string"  indexed="true" stored="true" multiValued="false"/>
-    <!-- :TODO: why are these identical?!?!?! -->
-    <dynamicField name="*_s"  type="string"  indexed="true"  stored="true" multiValued="true"/>
-    <dynamicField name="*_ss"  type="string"  indexed="true"  stored="true" multiValued="true"/>
-    <dynamicField name="*_l"  type="long"   indexed="true"  stored="true"/>
-    <dynamicField name="*_t"  type="text"    indexed="true"  stored="true"/>
-    <dynamicField name="*_tt"  type="text"    indexed="true"  stored="true"/>
-    <dynamicField name="*_b"  type="boolean" indexed="true"  stored="true"/>
-    <dynamicField name="*_f"  type="float"  indexed="true"  stored="true"/>
-    <dynamicField name="*_d"  type="double" indexed="true"  stored="true"/>
-    <dynamicField name="*_dt" type="date"    indexed="true"  stored="true"/>
-
-    <!-- some trie-coded dynamic fields for faster range queries -->
-    <dynamicField name="*_ti" type="tint"    indexed="true"  stored="true"/>
-    <dynamicField name="*_tl" type="tlong"   indexed="true"  stored="true"/>
-    <dynamicField name="*_tf" type="tfloat"  indexed="true"  stored="true"/>
-    <dynamicField name="*_td" type="tdouble" indexed="true"  stored="true"/>
-    <dynamicField name="*_tdt" type="tdate"  indexed="true"  stored="true"/>
-
-    <dynamicField name="ignored_*" type="ignored" multiValued="true"/>
-    <dynamicField name="attr_*" type="text" indexed="true" stored="true" multiValued="true"/>
-
-    <dynamicField name="random_*" type="random" />
+  <fieldType name="date" class="solr.TrieDateField" sortMissingLast="true"/>
+  <fieldType name="tdate" class="solr.TrieDateField" sortMissingLast="true" precisionStep="6"/>
+
+  <fieldType name="text" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="stopwords.txt"
+      />
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="stopwords.txt"
+      />
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <!-- A text field with defaults appropriate for English: it
+       tokenizes with StandardTokenizer, removes English stop words
+       (lang/stopwords_en.txt), down cases, protects words from protwords.txt, and
+       finally applies Porter's stemming.  The query time analyzer
+       also applies synonyms from synonyms.txt. -->
+  <fieldType name="text_en" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- in this example, we will only use synonyms at query time
+              <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
+              -->
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.EnglishPossessiveFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+                    <filter class="solr.EnglishMinimalStemFilterFactory"/>
+              -->
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.EnglishPossessiveFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+                    <filter class="solr.EnglishMinimalStemFilterFactory"/>
+              -->
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <!-- field type that doesn't generate phrases from unquoted multiple tokens per analysis unit -->
+  <fieldType name="text_np" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="stopwords.txt"
+      />
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="stopwords.txt"
+      />
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="nametext" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.core.WhitespaceAnalyzer"/>
+  </fieldType>
+
+  <fieldType name="teststop" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LowerCaseTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+      <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- fieldTypes in this section isolate tokenizers and tokenfilters for testing -->
+  <fieldType name="lowertok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LowerCaseTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="keywordtok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="standardtok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="lettertok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LetterTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="whitetok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="HTMLstandardtok" class="solr.TextField">
+    <analyzer>
+      <charFilter class="solr.HTMLStripCharFilterFactory"/>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="HTMLwhitetok" class="solr.TextField">
+    <analyzer>
+      <charFilter class="solr.HTMLStripCharFilterFactory"/>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="standardtokfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="standardfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="lowerfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="patternreplacefilt" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+      <filter class="solr.PatternReplaceFilterFactory"
+              pattern="([^a-zA-Z])" replacement="_" replace="all"
+      />
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="porterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="engporterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="custengporterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="stopfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="custstopfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="lengthfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LengthFilterFactory" min="2" max="5"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="limitfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LimitTokenCountFilterFactory" maxTokenCount="100"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="subword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="numericsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0"
+              splitOnCaseChange="0" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0"
+              catenateAll="0"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0"
+              splitOnCaseChange="0" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1"
+              catenateAll="0"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="protectedsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0"
+              splitOnCaseChange="0" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0"
+              catenateAll="0"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <!-- more flexible in matching skus, but more chance of a false match -->
+  <fieldType name="skutype1" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- less flexible in matching skus, but less chance of a false match -->
+  <fieldType name="skutype2" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- less flexible in matching skus, but less chance of a false match -->
+  <fieldType name="syn" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- a text field with the stop filter only on the query analyzer 
+       -->
+  <fieldType name="text_sw" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <!-- in this example, we will only use synonyms at query time
+              <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
+              -->
+      <!--<filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>-->
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0" splitOnCaseChange="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <!-- Demonstrates How RemoveDuplicatesTokenFilter makes stemmed
+           synonyms "better"
+        -->
+  <fieldType name="dedup" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory"
+              synonyms="synonyms.txt" expand="true"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="unstored" class="solr.StrField" indexed="true" stored="false"/>
+
+
+  <fieldType name="textgap" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="uuid" class="solr.UUIDField"/>
+  <fieldType name="ignored" class="solr.StrField" indexed="false" stored="false"/>
+
+
+  <fieldType name="random" class="solr.RandomSortField" indexed="true"/>
+
+  <!-- Poly field -->
+  <fieldType name="xy" class="solr.PointType" dimension="2" subFieldType="double"/>
+  <fieldType name="xyd" class="solr.PointType" dimension="2" subFieldSuffix="*_d"/>
+  <fieldType name="geohash" class="solr.GeoHashField"/>
+
+  <fieldType name="point" class="solr.PointType" dimension="2" subFieldSuffix="_d"/>
+  <!-- A specialized field for geospatial search. If indexed, this fieldType must not be multivalued. -->
+  <fieldType name="location" class="solr.LatLonType" subFieldSuffix="_coordinate"/>
+
+  <!-- Field type where english stopwords are managed by the REST API -->
+  <fieldType name="managed_en" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.ManagedStopFilterFactory" managed="english"/>
+      <filter class="solr.ManagedSynonymFilterFactory" managed="english"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Field type where german stopwords are managed by the REST API -->
+  <fieldType name="managed_de" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.ManagedStopFilterFactory" managed="german"/>
+      <filter class="solr.ManagedSynonymFilterFactory" managed="german"/>
+    </analyzer>
+  </fieldType>
+
+  <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="true"/>
+  <field name="signatureField" type="string" indexed="true" stored="false"/>
+  <field name="uuid" type="uuid" stored="true"/>
+  <field name="name" type="nametext" indexed="true" stored="true"/>
+  <field name="text" type="text" indexed="true" stored="false" multiValued="true"/>
+  <field name="subject" type="text" indexed="true" stored="true"/>
+  <field name="title" type="nametext" indexed="true" stored="true"/>
+  <field name="weight" type="float" indexed="true" stored="true"/>
+  <field name="bday" type="date" indexed="true" stored="true"/>
+
+  <field name="text_np" type="text_np" indexed="true" stored="false"/>
+
+  <field name="title_stemmed" type="text" indexed="true" stored="false"/>
+  <field name="title_lettertok" type="lettertok" indexed="true" stored="false"/>
+
+  <field name="syn" type="syn" indexed="true" stored="true"/>
+
+  <!-- to test property inheritance and overriding -->
+  <field name="shouldbeunstored" type="unstored"/>
+  <field name="shouldbestored" type="unstored" stored="true"/>
+  <field name="shouldbeunindexed" type="unstored" indexed="false" stored="true"/>
+
+
+  <!-- test different combinations of indexed and stored -->
+  <field name="bind" type="boolean" indexed="true" stored="false"/>
+  <field name="bsto" type="boolean" indexed="false" stored="true"/>
+  <field name="bindsto" type="boolean" indexed="true" stored="true"/>
+  <field name="isto" type="int" indexed="false" stored="true"/>
+  <field name="iind" type="int" indexed="true" stored="false"/>
+  <field name="ssto" type="string" indexed="false" stored="true"/>
+  <field name="sind" type="string" indexed="true" stored="false"/>
+  <field name="sindsto" type="string" indexed="true" stored="true"/>
+
+  <!-- test combinations of term vector settings -->
+  <field name="test_basictv" type="text" termVectors="true"/>
+  <field name="test_notv" type="text" termVectors="false"/>
+  <field name="test_postv" type="text" termVectors="true" termPositions="true"/>
+  <field name="test_offtv" type="text" termVectors="true" termOffsets="true"/>
+  <field name="test_posofftv" type="text" termVectors="true"
+         termPositions="true" termOffsets="true"/>
+
+  <!-- test highlit field settings -->
+  <field name="test_hlt" type="highlittext" indexed="true"/>
+  <field name="test_hlt_off" type="highlittext" indexed="true"/>
+
+  <!-- fields to test individual tokenizers and tokenfilters -->
+  <field name="teststop" type="teststop" indexed="true" stored="true"/>
+  <field name="lowertok" type="lowertok" indexed="true" stored="true"/>
+  <field name="keywordtok" type="keywordtok" indexed="true" stored="true"/>
+  <field name="standardtok" type="standardtok" indexed="true" stored="true"/>
+  <field name="HTMLstandardtok" type="HTMLstandardtok" indexed="true" stored="true"/>
+  <field name="lettertok" type="lettertok" indexed="true" stored="true"/>
+  <field name="whitetok" type="whitetok" indexed="true" stored="true"/>
+  <field name="HTMLwhitetok" type="HTMLwhitetok" indexed="true" stored="true"/>
+  <field name="standardtokfilt" type="standardtokfilt" indexed="true" stored="true"/>
+  <field name="standardfilt" type="standardfilt" indexed="true" stored="true"/>
+  <field name="lowerfilt" type="lowerfilt" indexed="true" stored="true"/>
+  <field name="patternreplacefilt" type="patternreplacefilt" indexed="true" stored="true"/>
+  <field name="porterfilt" type="porterfilt" indexed="true" stored="true"/>
+  <field name="engporterfilt" type="engporterfilt" indexed="true" stored="true"/>
+  <field name="custengporterfilt" type="custengporterfilt" indexed="true" stored="true"/>
+  <field name="stopfilt" type="stopfilt" indexed="true" stored="true"/>
+  <field name="custstopfilt" type="custstopfilt" indexed="true" stored="true"/>
+  <field name="lengthfilt" type="lengthfilt" indexed="true" stored="true"/>
+  <field name="dedup" type="dedup" indexed="true" stored="true"/>
+  <field name="wdf_nocase" type="wdf_nocase" indexed="true" stored="true"/>
+  <field name="wdf_preserve" type="wdf_preserve" indexed="true" stored="true"/>
+
+  <field name="numberpartfail" type="failtype1" indexed="true" stored="true"/>
+
+  <field name="nullfirst" type="string" indexed="true" stored="true" sortMissingFirst="true"/>
+
+  <field name="subword" type="subword" indexed="true" stored="true"/>
+  <field name="numericsubword" type="numericsubword" indexed="true" stored="true"/>
+  <field name="protectedsubword" type="protectedsubword" indexed="true" stored="true"/>
+
+  <field name="sku1" type="skutype1" indexed="true" stored="true"/>
+  <field name="sku2" type="skutype2" indexed="true" stored="true"/>
+
+  <field name="textgap" type="textgap" indexed="true" stored="true"/>
+
+  <!--
+      <field name="timestamp" type="date" indexed="true" stored="true" default="NOW"/>
+      -->
+  <field name="timestamp" type="date" indexed="true" stored="true"/>
+
+  <!-- Test a point field for distances -->
+  <field name="point" type="xy" indexed="true" stored="true" multiValued="false"/>
+  <field name="pointD" type="xyd" indexed="true" stored="true" multiValued="false"/>
+  <field name="point_hash" type="geohash" indexed="true" stored="true" multiValued="false"/>
+  <field name="store" type="location" indexed="true" stored="true"/>
+
+  <!-- to test uniq fields -->
+  <field name="uniq" type="string" indexed="true" stored="true" multiValued="true"/>
+  <field name="uniq2" type="string" indexed="true" stored="true" multiValued="true"/>
+  <field name="uniq3" type="string" indexed="true" stored="true"/>
+  <field name="nouniq" type="string" indexed="true" stored="true" multiValued="true"/>
+
+  <!-- for versioning -->
+  <field name="_version_" type="long" indexed="true" stored="true"/>
+
+
+  <field name="copyfield_source" type="string" indexed="true" stored="true" multiValued="true"/>
+
+
+  <dynamicField name="*_coordinate" type="tdouble" indexed="true" stored="false"/>
+
+  <dynamicField name="*_sI" type="string" indexed="true" stored="false"/>
+  <dynamicField name="*_sS" type="string" indexed="false" stored="true"/>
+  <dynamicField name="t_*" type="text" indexed="true" stored="true"/>
+  <dynamicField name="tv_*" type="text" indexed="true" stored="true"
+                termVectors="true" termPositions="true" termOffsets="true"/>
+  <dynamicField name="tv_mv_*" type="text" indexed="true" stored="true" multiValued="true"
+                termVectors="true" termPositions="true" termOffsets="true"/>
+
+  <dynamicField name="*_mfacet" type="string" indexed="true" stored="false" multiValued="true"/>
+
+  <dynamicField name="*_sw" type="text_sw" indexed="true" stored="true" multiValued="true"/>
+
+  <dynamicField name="*_i" type="int" indexed="true" stored="true"/>
+  <dynamicField name="*_is" type="int" indexed="true" stored="true" multiValued="true"/>
+  <dynamicField name="*_s1" type="string" indexed="true" stored="true" multiValued="false"/>
+  <!-- :TODO: why are these identical?!?!?! -->
+  <dynamicField name="*_s" type="string" indexed="true" stored="true" multiValued="true"/>
+  <dynamicField name="*_ss" type="string" indexed="true" stored="true" multiValued="true"/>
+  <dynamicField name="*_l" type="long" indexed="true" stored="true"/>
+  <dynamicField name="*_t" type="text" indexed="true" stored="true"/>
+  <dynamicField name="*_tt" type="text" indexed="true" stored="true"/>
+  <dynamicField name="*_b" type="boolean" indexed="true" stored="true"/>
+  <dynamicField name="*_f" type="float" indexed="true" stored="true"/>
+  <dynamicField name="*_d" type="double" indexed="true" stored="true"/>
+  <dynamicField name="*_dt" type="date" indexed="true" stored="true"/>
+
+  <!-- some trie-coded dynamic fields for faster range queries -->
+  <dynamicField name="*_ti" type="tint" indexed="true" stored="true"/>
+  <dynamicField name="*_tl" type="tlong" indexed="true" stored="true"/>
+  <dynamicField name="*_tf" type="tfloat" indexed="true" stored="true"/>
+  <dynamicField name="*_td" type="tdouble" indexed="true" stored="true"/>
+  <dynamicField name="*_tdt" type="tdate" indexed="true" stored="true"/>
+
+  <dynamicField name="ignored_*" type="ignored" multiValued="true"/>
+  <dynamicField name="attr_*" type="text" indexed="true" stored="true" multiValued="true"/>
+
+  <dynamicField name="random_*" type="random"/>
 
-  </fields>
 
   <defaultSearchField>text</defaultSearchField>
   <uniqueKey>id</uniqueKey>
 
   <copyField source="*" dest="text"/>
-  
+
   <solrQueryParser defaultOperator="OR"/>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-sortingresponse.xml b/solr/core/src/test-files/solr/collection1/conf/schema-sortingresponse.xml
index a264c01..ecf0daf 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-sortingresponse.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-sortingresponse.xml
@@ -17,43 +17,36 @@
 -->
 
 <schema name="schema-docValuesMulti" version="1.6">
-  <types>
-
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
-         seconds part (.999) is optional.
-      -->
-    <fieldType name="date" class="solr.TrieDateField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-
-    <fieldType name="boolean" class="solr.BoolField" />
-    <fieldType name="string" class="solr.StrField" />
-
-    <fieldType name="uuid" class="solr.UUIDField" />
-
-  </types>
-
-
-  <fields>
-    <field name="id" type="string" required="true" indexed="true" />
-    <field name="floatdv_m" type="float" indexed="false" stored="false" docValues="true" multiValued="true" />
-    <field name="intdv_m" type="int" indexed="false" stored="false" docValues="true" multiValued="true" />
-    <field name="doubledv_m" type="double" indexed="false" stored="false" docValues="true" multiValued="true" />
-    <field name="longdv_m" type="long" indexed="false" stored="false" docValues="true" multiValued="true" />
-    <field name="datedv_m" type="date" indexed="false" stored="false" docValues="true" multiValued="true" />
-    <field name="stringdv_m" type="string" indexed="false" stored="false" docValues="true" multiValued="true" />
-
-    <field name="floatdv" type="float" indexed="false" stored="false" docValues="true" />
-    <field name="intdv" type="int" indexed="false" stored="false" docValues="true"/>
-    <field name="doubledv" type="double" indexed="false" stored="false" docValues="true"/>
-    <field name="longdv" type="long" indexed="false" stored="false" docValues="true"/>
-    <field name="datedv" type="date" indexed="false" stored="false" docValues="true"/>
-    <field name="stringdv" type="string" indexed="false" stored="false" docValues="true"/>
-    
-    
-  </fields>
+
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
+       seconds part (.999) is optional.
+    -->
+  <fieldType name="date" class="solr.TrieDateField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+
+  <fieldType name="boolean" class="solr.BoolField"/>
+  <fieldType name="string" class="solr.StrField"/>
+
+  <fieldType name="uuid" class="solr.UUIDField"/>
+
+  <field name="id" type="string" required="true" indexed="true"/>
+  <field name="floatdv_m" type="float" indexed="false" stored="false" docValues="true" multiValued="true"/>
+  <field name="intdv_m" type="int" indexed="false" stored="false" docValues="true" multiValued="true"/>
+  <field name="doubledv_m" type="double" indexed="false" stored="false" docValues="true" multiValued="true"/>
+  <field name="longdv_m" type="long" indexed="false" stored="false" docValues="true" multiValued="true"/>
+  <field name="datedv_m" type="date" indexed="false" stored="false" docValues="true" multiValued="true"/>
+  <field name="stringdv_m" type="string" indexed="false" stored="false" docValues="true" multiValued="true"/>
+
+  <field name="floatdv" type="float" indexed="false" stored="false" docValues="true"/>
+  <field name="intdv" type="int" indexed="false" stored="false" docValues="true"/>
+  <field name="doubledv" type="double" indexed="false" stored="false" docValues="true"/>
+  <field name="longdv" type="long" indexed="false" stored="false" docValues="true"/>
+  <field name="datedv" type="date" indexed="false" stored="false" docValues="true"/>
+  <field name="stringdv" type="string" indexed="false" stored="false" docValues="true"/>
+
 
   <uniqueKey>id</uniqueKey>
 
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-sorts.xml b/solr/core/src/test-files/solr/collection1/conf/schema-sorts.xml
index ec2d73c..c918017 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-sorts.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-sorts.xml
@@ -25,262 +25,293 @@ NOTE: Tests expect every field in this schema to be sortable.
 <schema name="sortable" version="1.6">
   <uniqueKey>id</uniqueKey>
 
-  <fields>
-    <field name="id" type="int" />
-    <field name="_version_" type="long" />
-
-    <field name="str" type="str" />
-    <field name="str_last" type="str_last" />
-    <field name="str_first" type="str_first" />
-    <field name="str_dv" type="str_dv" />
-    <field name="str_dv_last" type="str_dv_last" />
-    <field name="str_dv_first" type="str_dv_first" />
-
-    <field name="bin" type="bin" />
-    <field name="bin_last" type="bin_last" />
-    <field name="bin_first" type="bin_first" />
-    <field name="bin_dv" type="bin_dv" />
-    <field name="bin_dv_last" type="bin_dv_last" />
-    <field name="bin_dv_first" type="bin_dv_first" />
-
-    <field name="int" type="int" />
-    <field name="int_last" type="int_last" />
-    <field name="int_first" type="int_first" />
-    <field name="int_dv" type="int_dv" />
-    <field name="int_dv_last" type="int_dv_last" />
-    <field name="int_dv_first" type="int_dv_first" />
-
-    <field name="long" type="long" />
-    <field name="long_last" type="long_last" />
-    <field name="long_first" type="long_first" />
-    <field name="long_dv" type="long_dv" />
-    <field name="long_dv_last" type="long_dv_last" />
-    <field name="long_dv_first" type="long_dv_first" />
-
-    <field name="float" type="float" />
-    <field name="float_last" type="float_last" />
-    <field name="float_first" type="float_first" />
-    <field name="float_dv" type="float_dv" />
-    <field name="float_dv_last" type="float_dv_last" />
-    <field name="float_dv_first" type="float_dv_first" />
-
-    <field name="double" type="double" />
-    <field name="double_last" type="double_last" />
-    <field name="double_first" type="double_first" />
-    <field name="double_dv" type="double_dv" />
-    <field name="double_dv_last" type="double_dv_last" />
-    <field name="double_dv_first" type="double_dv_first" />
-
-    <field name="date" type="date" />
-    <field name="date_last" type="date_last" />
-    <field name="date_first" type="date_first" />
-    <field name="date_dv" type="date_dv" />
-    <field name="date_dv_last" type="date_dv_last" />
-    <field name="date_dv_first" type="date_dv_first" />
-
-    <field name="uuid" type="uuid" />
-    <field name="uuid_last" type="uuid_last" />
-    <field name="uuid_first" type="uuid_first" />
-    <field name="uuid_dv" type="uuid_dv" />
-    <field name="uuid_dv_last" type="uuid_dv_last" />
-    <field name="uuid_dv_first" type="uuid_dv_first" />
-
-    <field name="currency" type="currency" />
-    <field name="currency_last" type="currency_last" />
-    <field name="currency_first" type="currency_first" />
-
-    <field name="collation_en_primary" type="collation_en_primary" />
-    <field name="collation_en_primary_last" type="collation_en_primary_last" />
-    <field name="collation_en_primary_first" type="collation_en_primary_first" />
-    <field name="collation_en_primary_dv" type="collation_en_primary_dv" />
-    <field name="collation_en_primary_dv_last" type="collation_en_primary_dv_last" />
-    <field name="collation_en_primary_dv_first" type="collation_en_primary_dv_first" />
-
-    <field name="icu_collation_en_primary" type="icu_collation_en_primary" />
-    <field name="icu_collation_en_primary_last" type="icu_collation_en_primary_last" />
-    <field name="icu_collation_en_primary_first" type="icu_collation_en_primary_first" />
-    <field name="icu_collation_en_primary_dv" type="icu_collation_en_primary_dv" />
-    <field name="icu_collation_en_primary_dv_last" type="icu_collation_en_primary_dv_last" />
-    <field name="icu_collation_en_primary_dv_first" type="icu_collation_en_primary_dv_first" />
-
-    <field name="bool" type="bool" />
-    <field name="bool_last" type="bool_last" />
-    <field name="bool_first" type="bool_first" />
-
-    <field name="enum" type="enum" />
-    <field name="enum_last" type="enum_last" />
-    <field name="enum_first" type="enum_first" />
-    <!-- EnumField incorrectly disallows missing DocValues - see SOLR-5927 -->
-    <!-- <field name="enum_dv" type="enum_dv" />                   -->
-    <!-- <field name="enum_dv_last" type="enum_dv_last" />         -->
-    <!-- <field name="enum_dv_first" type="enum_dv_first" />       -->
-
-    <!-- ensure function sorts don't mistakenly get interpreted as field sorts
-         https://issues.apache.org/jira/browse/SOLR-5354?focusedCommentId=13835891&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-13835891
-    -->
-    <dynamicField name="*" type="str" multiValued="false" />
-  </fields>
-
-  <copyField source="str" dest="str_last" />
-  <copyField source="str" dest="str_first" />
-  <copyField source="str" dest="str_dv" />
-  <copyField source="str" dest="str_dv_last" />
-  <copyField source="str" dest="str_dv_first" />
-  <copyField source="str" dest="collation_en_primary_last" />
-  <copyField source="str" dest="collation_en_primary_first" />
-  <copyField source="str" dest="collation_en_primary_dv" />
-  <copyField source="str" dest="collation_en_primary_dv_last" />
-  <copyField source="str" dest="collation_en_primary_dv_first" />
-  <copyField source="str" dest="icu_collation_en_primary_last" />
-  <copyField source="str" dest="icu_collation_en_primary_first" />
-  <copyField source="str" dest="icu_collation_en_primary_dv" />
-  <copyField source="str" dest="icu_collation_en_primary_dv_last" />
-  <copyField source="str" dest="icu_collation_en_primary_dv_first" />
-
-  <copyField source="bin" dest="bin_last" />
-  <copyField source="bin" dest="bin_first" />
-  <copyField source="bin" dest="bin_dv" />
-  <copyField source="bin" dest="bin_dv_last" />
-  <copyField source="bin" dest="bin_dv_first" />
-
-  <copyField source="int" dest="int_last" />
-  <copyField source="int" dest="int_first" />
-  <copyField source="int" dest="int_dv" />
-  <copyField source="int" dest="int_dv_last" />
-  <copyField source="int" dest="int_dv_first" />
-
-  <copyField source="long" dest="long_last" />
-  <copyField source="long" dest="long_first" />
-  <copyField source="long" dest="long_dv" />
-  <copyField source="long" dest="long_dv_last" />
-  <copyField source="long" dest="long_dv_first" />
-
-  <copyField source="float" dest="float_last" />
-  <copyField source="float" dest="float_first" />
-  <copyField source="float" dest="float_dv" />
-  <copyField source="float" dest="float_dv_last" />
-  <copyField source="float" dest="float_dv_first" />
-
-  <copyField source="double" dest="double_last" />
-  <copyField source="double" dest="double_first" />
-  <copyField source="double" dest="double_dv" />
-  <copyField source="double" dest="double_dv_last" />
-  <copyField source="double" dest="double_dv_first" />
-
-  <copyField source="date" dest="date_last" />
-  <copyField source="date" dest="date_first" />
-  <copyField source="date" dest="date_dv" />
-  <copyField source="date" dest="date_dv_last" />
-  <copyField source="date" dest="date_dv_first" />
-
-  <copyField source="uuid" dest="uuid_last" />
-  <copyField source="uuid" dest="uuid_first" />
-  <copyField source="uuid" dest="uuid_dv" />
-  <copyField source="uuid" dest="uuid_dv_last" />
-  <copyField source="uuid" dest="uuid_dv_first" />
-
-  <copyField source="currency" dest="currency_last" />
-  <copyField source="currency" dest="currency_first" />
-
-  <copyField source="bool" dest="bool_last" />
-  <copyField source="bool" dest="bool_first" />
-
-  <copyField source="enum" dest="enum_last" />
-  <copyField source="enum" dest="enum_first" />
+  <field name="id" type="int"/>
+  <field name="_version_" type="long"/>
+
+  <field name="str" type="str"/>
+  <field name="str_last" type="str_last"/>
+  <field name="str_first" type="str_first"/>
+  <field name="str_dv" type="str_dv"/>
+  <field name="str_dv_last" type="str_dv_last"/>
+  <field name="str_dv_first" type="str_dv_first"/>
+
+  <field name="bin" type="bin"/>
+  <field name="bin_last" type="bin_last"/>
+  <field name="bin_first" type="bin_first"/>
+  <field name="bin_dv" type="bin_dv"/>
+  <field name="bin_dv_last" type="bin_dv_last"/>
+  <field name="bin_dv_first" type="bin_dv_first"/>
+
+  <field name="int" type="int"/>
+  <field name="int_last" type="int_last"/>
+  <field name="int_first" type="int_first"/>
+  <field name="int_dv" type="int_dv"/>
+  <field name="int_dv_last" type="int_dv_last"/>
+  <field name="int_dv_first" type="int_dv_first"/>
+
+  <field name="long" type="long"/>
+  <field name="long_last" type="long_last"/>
+  <field name="long_first" type="long_first"/>
+  <field name="long_dv" type="long_dv"/>
+  <field name="long_dv_last" type="long_dv_last"/>
+  <field name="long_dv_first" type="long_dv_first"/>
+
+  <field name="float" type="float"/>
+  <field name="float_last" type="float_last"/>
+  <field name="float_first" type="float_first"/>
+  <field name="float_dv" type="float_dv"/>
+  <field name="float_dv_last" type="float_dv_last"/>
+  <field name="float_dv_first" type="float_dv_first"/>
+
+  <field name="double" type="double"/>
+  <field name="double_last" type="double_last"/>
+  <field name="double_first" type="double_first"/>
+  <field name="double_dv" type="double_dv"/>
+  <field name="double_dv_last" type="double_dv_last"/>
+  <field name="double_dv_first" type="double_dv_first"/>
+
+  <field name="date" type="date"/>
+  <field name="date_last" type="date_last"/>
+  <field name="date_first" type="date_first"/>
+  <field name="date_dv" type="date_dv"/>
+  <field name="date_dv_last" type="date_dv_last"/>
+  <field name="date_dv_first" type="date_dv_first"/>
+
+  <field name="uuid" type="uuid"/>
+  <field name="uuid_last" type="uuid_last"/>
+  <field name="uuid_first" type="uuid_first"/>
+  <field name="uuid_dv" type="uuid_dv"/>
+  <field name="uuid_dv_last" type="uuid_dv_last"/>
+  <field name="uuid_dv_first" type="uuid_dv_first"/>
+
+  <field name="currency" type="currency"/>
+  <field name="currency_last" type="currency_last"/>
+  <field name="currency_first" type="currency_first"/>
+
+  <field name="collation_en_primary" type="collation_en_primary"/>
+  <field name="collation_en_primary_last" type="collation_en_primary_last"/>
+  <field name="collation_en_primary_first" type="collation_en_primary_first"/>
+  <field name="collation_en_primary_dv" type="collation_en_primary_dv"/>
+  <field name="collation_en_primary_dv_last" type="collation_en_primary_dv_last"/>
+  <field name="collation_en_primary_dv_first" type="collation_en_primary_dv_first"/>
+
+  <field name="icu_collation_en_primary" type="icu_collation_en_primary"/>
+  <field name="icu_collation_en_primary_last" type="icu_collation_en_primary_last"/>
+  <field name="icu_collation_en_primary_first" type="icu_collation_en_primary_first"/>
+  <field name="icu_collation_en_primary_dv" type="icu_collation_en_primary_dv"/>
+  <field name="icu_collation_en_primary_dv_last" type="icu_collation_en_primary_dv_last"/>
+  <field name="icu_collation_en_primary_dv_first" type="icu_collation_en_primary_dv_first"/>
+
+  <field name="bool" type="bool"/>
+  <field name="bool_last" type="bool_last"/>
+  <field name="bool_first" type="bool_first"/>
+
+  <field name="enum" type="enum"/>
+  <field name="enum_last" type="enum_last"/>
+  <field name="enum_first" type="enum_first"/>
+  <!-- EnumField incorrectly disallows missing DocValues - see SOLR-5927 -->
+  <!-- <field name="enum_dv" type="enum_dv" />                   -->
+  <!-- <field name="enum_dv_last" type="enum_dv_last" />         -->
+  <!-- <field name="enum_dv_first" type="enum_dv_first" />       -->
+
+  <!-- ensure function sorts don't mistakenly get interpreted as field sorts
+       https://issues.apache.org/jira/browse/SOLR-5354?focusedCommentId=13835891&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-13835891
+  -->
+  <dynamicField name="*" type="str" multiValued="false"/>
+
+  <copyField source="str" dest="str_last"/>
+  <copyField source="str" dest="str_first"/>
+  <copyField source="str" dest="str_dv"/>
+  <copyField source="str" dest="str_dv_last"/>
+  <copyField source="str" dest="str_dv_first"/>
+  <copyField source="str" dest="collation_en_primary_last"/>
+  <copyField source="str" dest="collation_en_primary_first"/>
+  <copyField source="str" dest="collation_en_primary_dv"/>
+  <copyField source="str" dest="collation_en_primary_dv_last"/>
+  <copyField source="str" dest="collation_en_primary_dv_first"/>
+  <copyField source="str" dest="icu_collation_en_primary_last"/>
+  <copyField source="str" dest="icu_collation_en_primary_first"/>
+  <copyField source="str" dest="icu_collation_en_primary_dv"/>
+  <copyField source="str" dest="icu_collation_en_primary_dv_last"/>
+  <copyField source="str" dest="icu_collation_en_primary_dv_first"/>
+
+  <copyField source="bin" dest="bin_last"/>
+  <copyField source="bin" dest="bin_first"/>
+  <copyField source="bin" dest="bin_dv"/>
+  <copyField source="bin" dest="bin_dv_last"/>
+  <copyField source="bin" dest="bin_dv_first"/>
+
+  <copyField source="int" dest="int_last"/>
+  <copyField source="int" dest="int_first"/>
+  <copyField source="int" dest="int_dv"/>
+  <copyField source="int" dest="int_dv_last"/>
+  <copyField source="int" dest="int_dv_first"/>
+
+  <copyField source="long" dest="long_last"/>
+  <copyField source="long" dest="long_first"/>
+  <copyField source="long" dest="long_dv"/>
+  <copyField source="long" dest="long_dv_last"/>
+  <copyField source="long" dest="long_dv_first"/>
+
+  <copyField source="float" dest="float_last"/>
+  <copyField source="float" dest="float_first"/>
+  <copyField source="float" dest="float_dv"/>
+  <copyField source="float" dest="float_dv_last"/>
+  <copyField source="float" dest="float_dv_first"/>
+
+  <copyField source="double" dest="double_last"/>
+  <copyField source="double" dest="double_first"/>
+  <copyField source="double" dest="double_dv"/>
+  <copyField source="double" dest="double_dv_last"/>
+  <copyField source="double" dest="double_dv_first"/>
+
+  <copyField source="date" dest="date_last"/>
+  <copyField source="date" dest="date_first"/>
+  <copyField source="date" dest="date_dv"/>
+  <copyField source="date" dest="date_dv_last"/>
+  <copyField source="date" dest="date_dv_first"/>
+
+  <copyField source="uuid" dest="uuid_last"/>
+  <copyField source="uuid" dest="uuid_first"/>
+  <copyField source="uuid" dest="uuid_dv"/>
+  <copyField source="uuid" dest="uuid_dv_last"/>
+  <copyField source="uuid" dest="uuid_dv_first"/>
+
+  <copyField source="currency" dest="currency_last"/>
+  <copyField source="currency" dest="currency_first"/>
+
+  <copyField source="bool" dest="bool_last"/>
+  <copyField source="bool" dest="bool_first"/>
+
+  <copyField source="enum" dest="enum_last"/>
+  <copyField source="enum" dest="enum_first"/>
   <!-- EnumField incorrectly disallows missing DocValues - see SOLR-5927 -->
   <!-- <copyField source="enum" dest="enum_dv" />                -->
   <!-- <copyField source="enum" dest="enum_dv_last" />           -->
   <!-- <copyField source="enum" dest="enum_dv_first" />          -->
 
-  <types>
-
-    <fieldType name="str" class="solr.StrField" stored="true" indexed="true" />
-    <fieldType name="str_last" class="solr.StrField" stored="true" indexed="true" sortMissingLast="true"/>
-    <fieldType name="str_first" class="solr.StrField" stored="true" indexed="true" sortMissingFirst="true"/>
-    <fieldType name="str_dv" class="solr.StrField" stored="true" indexed="false" docValues="true"/>
-    <fieldType name="str_dv_last" class="solr.StrField" stored="true" indexed="false" docValues="true" sortMissingLast="true"/>
-    <fieldType name="str_dv_first" class="solr.StrField" stored="true" indexed="false" docValues="true" sortMissingFirst="true"/>
-
-    <!-- note: all 'binary' fields have docvalues, because this fieldType doesnt support indexing -->
-    <fieldType name="bin" class="solr.SortableBinaryField" stored="true" indexed="true" docValues="true"/>
-    <fieldType name="bin_last" class="solr.SortableBinaryField" stored="true" indexed="true" docValues="true" sortMissingLast="true"/>
-    <fieldType name="bin_first" class="solr.SortableBinaryField" stored="true" indexed="true" docValues="true" sortMissingFirst="true"/>
-    <fieldType name="bin_dv" class="solr.SortableBinaryField" stored="true" indexed="false" docValues="true"/>
-    <fieldType name="bin_dv_last" class="solr.SortableBinaryField" stored="true" indexed="false" docValues="true" sortMissingLast="true"/>
-    <fieldType name="bin_dv_first" class="solr.SortableBinaryField" stored="true" indexed="false" docValues="true" sortMissingFirst="true"/>
-
-    <fieldType name="int" class="solr.TrieIntField" stored="true" indexed="true" />
-    <fieldType name="int_last" class="solr.TrieIntField" stored="true" indexed="true" sortMissingLast="true"/>
-    <fieldType name="int_first" class="solr.TrieIntField" stored="true" indexed="true" sortMissingFirst="true"/>
-    <fieldType name="int_dv" class="solr.TrieIntField" stored="true" indexed="false" docValues="true"/>
-    <fieldType name="int_dv_last" class="solr.TrieIntField" stored="true" indexed="false" docValues="true" sortMissingLast="true"/>
-    <fieldType name="int_dv_first" class="solr.TrieIntField" stored="true" indexed="false" docValues="true" sortMissingFirst="true"/>
-
-    <fieldType name="long" class="solr.TrieLongField" stored="true" indexed="true" />
-    <fieldType name="long_last" class="solr.TrieLongField" stored="true" indexed="true" sortMissingLast="true"/>
-    <fieldType name="long_first" class="solr.TrieLongField" stored="true" indexed="true" sortMissingFirst="true"/>
-    <fieldType name="long_dv" class="solr.TrieLongField" stored="true" indexed="false" docValues="true"/>
-    <fieldType name="long_dv_last" class="solr.TrieLongField" stored="true" indexed="false" docValues="true" sortMissingLast="true"/>
-    <fieldType name="long_dv_first" class="solr.TrieLongField" stored="true" indexed="false" docValues="true" sortMissingFirst="true"/>
-
-    <fieldType name="float" class="solr.TrieFloatField" stored="true" indexed="true" />
-    <fieldType name="float_last" class="solr.TrieFloatField" stored="true" indexed="true" sortMissingLast="true"/>
-    <fieldType name="float_first" class="solr.TrieFloatField" stored="true" indexed="true" sortMissingFirst="true"/>
-    <fieldType name="float_dv" class="solr.TrieFloatField" stored="true" indexed="false" docValues="true"/>
-    <fieldType name="float_dv_last" class="solr.TrieFloatField" stored="true" indexed="false" docValues="true" sortMissingLast="true"/>
-    <fieldType name="float_dv_first" class="solr.TrieFloatField" stored="true" indexed="false" docValues="true" sortMissingFirst="true"/>
-
-    <fieldType name="double" class="solr.TrieDoubleField" stored="true" indexed="true" />
-    <fieldType name="double_last" class="solr.TrieDoubleField" stored="true" indexed="true" sortMissingLast="true"/>
-    <fieldType name="double_first" class="solr.TrieDoubleField" stored="true" indexed="true" sortMissingFirst="true"/>
-    <fieldType name="double_dv" class="solr.TrieDoubleField" stored="true" indexed="false" docValues="true"/>
-    <fieldType name="double_dv_last" class="solr.TrieDoubleField" stored="true" indexed="false" docValues="true" sortMissingLast="true"/>
-    <fieldType name="double_dv_first" class="solr.TrieDoubleField" stored="true" indexed="false" docValues="true" sortMissingFirst="true"/>
-
-    <fieldType name="date" class="solr.TrieDateField" stored="true" indexed="true" />
-    <fieldType name="date_last" class="solr.TrieDateField" stored="true" indexed="true" sortMissingLast="true"/>
-    <fieldType name="date_first" class="solr.TrieDateField" stored="true" indexed="true" sortMissingFirst="true"/>
-    <fieldType name="date_dv" class="solr.TrieDateField" stored="true" indexed="false" docValues="true"/>
-    <fieldType name="date_dv_last" class="solr.TrieDateField" stored="true" indexed="false" docValues="true" sortMissingLast="true"/>
-    <fieldType name="date_dv_first" class="solr.TrieDateField" stored="true" indexed="false" docValues="true" sortMissingFirst="true"/>
-
-    <fieldType name="uuid" class="solr.UUIDField" stored="true" indexed="true" />
-    <fieldType name="uuid_last" class="solr.UUIDField" stored="true" indexed="true" sortMissingLast="true"/>
-    <fieldType name="uuid_first" class="solr.UUIDField" stored="true" indexed="true" sortMissingFirst="true"/>
-    <fieldType name="uuid_dv" class="solr.UUIDField" stored="true" indexed="false" docValues="true"/>
-    <fieldType name="uuid_dv_last" class="solr.UUIDField" stored="true" indexed="false" docValues="true" sortMissingLast="true"/>
-    <fieldType name="uuid_dv_first" class="solr.UUIDField" stored="true" indexed="false" docValues="true" sortMissingFirst="true"/>
-
-    <fieldType name="currency" class="solr.CurrencyField" stored="true" indexed="true" foo="bar" providerClass="solr.MockExchangeRateProvider"/>
-    <fieldType name="currency_last" class="solr.CurrencyField" stored="true" indexed="true" foo="bar" providerClass="solr.MockExchangeRateProvider" sortMissingLast="true"/>
-    <fieldType name="currency_first" class="solr.CurrencyField" stored="true" indexed="true" foo="bar" providerClass="solr.MockExchangeRateProvider" sortMissingFirst="true"/>
-
-    <fieldType name="collation_en_primary" class="solr.CollationField" language="en" strength="primary" stored="true" indexed="true" />
-    <fieldType name="collation_en_primary_last" class="solr.CollationField" language="en" strength="primary" stored="true" indexed="true" sortMissingLast="true"/>
-    <fieldType name="collation_en_primary_first" class="solr.CollationField" language="en" strength="primary" stored="true" indexed="true" sortMissingFirst="true"/>
-    <fieldType name="collation_en_primary_dv" class="solr.CollationField" language="en" strength="primary" stored="true" indexed="false" docValues="true"/>
-    <fieldType name="collation_en_primary_dv_last" class="solr.CollationField" language="en" strength="primary" stored="true" indexed="false" docValues="true" sortMissingLast="true"/>
-    <fieldType name="collation_en_primary_dv_first" class="solr.CollationField" language="en" strength="primary" stored="true" indexed="false" docValues="true" sortMissingFirst="true"/>
-
-    <fieldType name="icu_collation_en_primary" class="solr.ICUCollationField" locale="en" strength="primary" stored="true" indexed="true" />
-    <fieldType name="icu_collation_en_primary_last" class="solr.ICUCollationField" locale="en" strength="primary" stored="true" indexed="true" sortMissingLast="true"/>
-    <fieldType name="icu_collation_en_primary_first" class="solr.ICUCollationField" locale="en" strength="primary" stored="true" indexed="true" sortMissingFirst="true"/>
-    <fieldType name="icu_collation_en_primary_dv" class="solr.ICUCollationField" locale="en" strength="primary" stored="true" indexed="false" docValues="true"/>
-    <fieldType name="icu_collation_en_primary_dv_last" class="solr.ICUCollationField" locale="en" strength="primary" stored="true" indexed="false" docValues="true" sortMissingLast="true"/>
-    <fieldType name="icu_collation_en_primary_dv_first" class="solr.ICUCollationField" locale="en" strength="primary" stored="true" indexed="false" docValues="true" sortMissingFirst="true"/>
-
-    <!-- BoolField does not support DocValues - see SOLR-5933 -->
-    <fieldType name="bool" class="solr.BoolField" stored="true" indexed="true" />
-    <fieldType name="bool_last" class="solr.BoolField" stored="true" indexed="true" sortMissingLast="true"/>
-    <fieldType name="bool_first" class="solr.BoolField" stored="true" indexed="true" sortMissingFirst="true"/>
-
-    <fieldType name="enum" class="solr.EnumField" enumsConfig="enumsConfig.xml" enumName="severity"/>
-    <fieldType name="enum_last" class="solr.EnumField" enumsConfig="enumsConfig.xml" enumName="severity" sortMissingLast="true"/>
-    <fieldType name="enum_first" class="solr.EnumField" enumsConfig="enumsConfig.xml" enumName="severity" sortMissingFirst="true"/>
-    <!-- EnumField incorrectly disallows missing DocValues - see SOLR-5927 -->
-    <!-- <fieldType name="enum_dv" class="solr.EnumField" enumsConfig="enumsConfig.xml" enumName="severity" docValues="true"/> -->
-    <!-- <fieldType name="enum_dv_last" class="solr.EnumField" enumsConfig="enumsConfig.xml" enumName="severity" docValues="true" sortMissingLast="true"/> -->
-    <!-- <fieldType name="enum_dv_first" class="solr.EnumField" enumsConfig="enumsConfig.xml" enumName="severity" docValues="true" sortMissingFirst="true"/> -->
-  </types>
+
+  <fieldType name="str" class="solr.StrField" stored="true" indexed="true"/>
+  <fieldType name="str_last" class="solr.StrField" stored="true" indexed="true" sortMissingLast="true"/>
+  <fieldType name="str_first" class="solr.StrField" stored="true" indexed="true" sortMissingFirst="true"/>
+  <fieldType name="str_dv" class="solr.StrField" stored="true" indexed="false" docValues="true"/>
+  <fieldType name="str_dv_last" class="solr.StrField" stored="true" indexed="false" docValues="true"
+             sortMissingLast="true"/>
+  <fieldType name="str_dv_first" class="solr.StrField" stored="true" indexed="false" docValues="true"
+             sortMissingFirst="true"/>
+
+  <!-- note: all 'binary' fields have docvalues, because this fieldType doesnt support indexing -->
+  <fieldType name="bin" class="solr.SortableBinaryField" stored="true" indexed="true" docValues="true"/>
+  <fieldType name="bin_last" class="solr.SortableBinaryField" stored="true" indexed="true" docValues="true"
+             sortMissingLast="true"/>
+  <fieldType name="bin_first" class="solr.SortableBinaryField" stored="true" indexed="true" docValues="true"
+             sortMissingFirst="true"/>
+  <fieldType name="bin_dv" class="solr.SortableBinaryField" stored="true" indexed="false" docValues="true"/>
+  <fieldType name="bin_dv_last" class="solr.SortableBinaryField" stored="true" indexed="false" docValues="true"
+             sortMissingLast="true"/>
+  <fieldType name="bin_dv_first" class="solr.SortableBinaryField" stored="true" indexed="false" docValues="true"
+             sortMissingFirst="true"/>
+
+  <fieldType name="int" class="solr.TrieIntField" stored="true" indexed="true"/>
+  <fieldType name="int_last" class="solr.TrieIntField" stored="true" indexed="true" sortMissingLast="true"/>
+  <fieldType name="int_first" class="solr.TrieIntField" stored="true" indexed="true" sortMissingFirst="true"/>
+  <fieldType name="int_dv" class="solr.TrieIntField" stored="true" indexed="false" docValues="true"/>
+  <fieldType name="int_dv_last" class="solr.TrieIntField" stored="true" indexed="false" docValues="true"
+             sortMissingLast="true"/>
+  <fieldType name="int_dv_first" class="solr.TrieIntField" stored="true" indexed="false" docValues="true"
+             sortMissingFirst="true"/>
+
+  <fieldType name="long" class="solr.TrieLongField" stored="true" indexed="true"/>
+  <fieldType name="long_last" class="solr.TrieLongField" stored="true" indexed="true" sortMissingLast="true"/>
+  <fieldType name="long_first" class="solr.TrieLongField" stored="true" indexed="true" sortMissingFirst="true"/>
+  <fieldType name="long_dv" class="solr.TrieLongField" stored="true" indexed="false" docValues="true"/>
+  <fieldType name="long_dv_last" class="solr.TrieLongField" stored="true" indexed="false" docValues="true"
+             sortMissingLast="true"/>
+  <fieldType name="long_dv_first" class="solr.TrieLongField" stored="true" indexed="false" docValues="true"
+             sortMissingFirst="true"/>
+
+  <fieldType name="float" class="solr.TrieFloatField" stored="true" indexed="true"/>
+  <fieldType name="float_last" class="solr.TrieFloatField" stored="true" indexed="true" sortMissingLast="true"/>
+  <fieldType name="float_first" class="solr.TrieFloatField" stored="true" indexed="true" sortMissingFirst="true"/>
+  <fieldType name="float_dv" class="solr.TrieFloatField" stored="true" indexed="false" docValues="true"/>
+  <fieldType name="float_dv_last" class="solr.TrieFloatField" stored="true" indexed="false" docValues="true"
+             sortMissingLast="true"/>
+  <fieldType name="float_dv_first" class="solr.TrieFloatField" stored="true" indexed="false" docValues="true"
+             sortMissingFirst="true"/>
+
+  <fieldType name="double" class="solr.TrieDoubleField" stored="true" indexed="true"/>
+  <fieldType name="double_last" class="solr.TrieDoubleField" stored="true" indexed="true" sortMissingLast="true"/>
+  <fieldType name="double_first" class="solr.TrieDoubleField" stored="true" indexed="true" sortMissingFirst="true"/>
+  <fieldType name="double_dv" class="solr.TrieDoubleField" stored="true" indexed="false" docValues="true"/>
+  <fieldType name="double_dv_last" class="solr.TrieDoubleField" stored="true" indexed="false" docValues="true"
+             sortMissingLast="true"/>
+  <fieldType name="double_dv_first" class="solr.TrieDoubleField" stored="true" indexed="false" docValues="true"
+             sortMissingFirst="true"/>
+
+  <fieldType name="date" class="solr.TrieDateField" stored="true" indexed="true"/>
+  <fieldType name="date_last" class="solr.TrieDateField" stored="true" indexed="true" sortMissingLast="true"/>
+  <fieldType name="date_first" class="solr.TrieDateField" stored="true" indexed="true" sortMissingFirst="true"/>
+  <fieldType name="date_dv" class="solr.TrieDateField" stored="true" indexed="false" docValues="true"/>
+  <fieldType name="date_dv_last" class="solr.TrieDateField" stored="true" indexed="false" docValues="true"
+             sortMissingLast="true"/>
+  <fieldType name="date_dv_first" class="solr.TrieDateField" stored="true" indexed="false" docValues="true"
+             sortMissingFirst="true"/>
+
+  <fieldType name="uuid" class="solr.UUIDField" stored="true" indexed="true"/>
+  <fieldType name="uuid_last" class="solr.UUIDField" stored="true" indexed="true" sortMissingLast="true"/>
+  <fieldType name="uuid_first" class="solr.UUIDField" stored="true" indexed="true" sortMissingFirst="true"/>
+  <fieldType name="uuid_dv" class="solr.UUIDField" stored="true" indexed="false" docValues="true"/>
+  <fieldType name="uuid_dv_last" class="solr.UUIDField" stored="true" indexed="false" docValues="true"
+             sortMissingLast="true"/>
+  <fieldType name="uuid_dv_first" class="solr.UUIDField" stored="true" indexed="false" docValues="true"
+             sortMissingFirst="true"/>
+
+  <fieldType name="currency" class="solr.CurrencyField" stored="true" indexed="true" foo="bar"
+             providerClass="solr.MockExchangeRateProvider"/>
+  <fieldType name="currency_last" class="solr.CurrencyField" stored="true" indexed="true" foo="bar"
+             providerClass="solr.MockExchangeRateProvider" sortMissingLast="true"/>
+  <fieldType name="currency_first" class="solr.CurrencyField" stored="true" indexed="true" foo="bar"
+             providerClass="solr.MockExchangeRateProvider" sortMissingFirst="true"/>
+
+  <fieldType name="collation_en_primary" class="solr.CollationField" language="en" strength="primary" stored="true"
+             indexed="true"/>
+  <fieldType name="collation_en_primary_last" class="solr.CollationField" language="en" strength="primary" stored="true"
+             indexed="true" sortMissingLast="true"/>
+  <fieldType name="collation_en_primary_first" class="solr.CollationField" language="en" strength="primary"
+             stored="true" indexed="true" sortMissingFirst="true"/>
+  <fieldType name="collation_en_primary_dv" class="solr.CollationField" language="en" strength="primary" stored="true"
+             indexed="false" docValues="true"/>
+  <fieldType name="collation_en_primary_dv_last" class="solr.CollationField" language="en" strength="primary"
+             stored="true" indexed="false" docValues="true" sortMissingLast="true"/>
+  <fieldType name="collation_en_primary_dv_first" class="solr.CollationField" language="en" strength="primary"
+             stored="true" indexed="false" docValues="true" sortMissingFirst="true"/>
+
+  <fieldType name="icu_collation_en_primary" class="solr.ICUCollationField" locale="en" strength="primary" stored="true"
+             indexed="true"/>
+  <fieldType name="icu_collation_en_primary_last" class="solr.ICUCollationField" locale="en" strength="primary"
+             stored="true" indexed="true" sortMissingLast="true"/>
+  <fieldType name="icu_collation_en_primary_first" class="solr.ICUCollationField" locale="en" strength="primary"
+             stored="true" indexed="true" sortMissingFirst="true"/>
+  <fieldType name="icu_collation_en_primary_dv" class="solr.ICUCollationField" locale="en" strength="primary"
+             stored="true" indexed="false" docValues="true"/>
+  <fieldType name="icu_collation_en_primary_dv_last" class="solr.ICUCollationField" locale="en" strength="primary"
+             stored="true" indexed="false" docValues="true" sortMissingLast="true"/>
+  <fieldType name="icu_collation_en_primary_dv_first" class="solr.ICUCollationField" locale="en" strength="primary"
+             stored="true" indexed="false" docValues="true" sortMissingFirst="true"/>
+
+  <!-- BoolField does not support DocValues - see SOLR-5933 -->
+  <fieldType name="bool" class="solr.BoolField" stored="true" indexed="true"/>
+  <fieldType name="bool_last" class="solr.BoolField" stored="true" indexed="true" sortMissingLast="true"/>
+  <fieldType name="bool_first" class="solr.BoolField" stored="true" indexed="true" sortMissingFirst="true"/>
+
+  <fieldType name="enum" class="solr.EnumField" enumsConfig="enumsConfig.xml" enumName="severity"/>
+  <fieldType name="enum_last" class="solr.EnumField" enumsConfig="enumsConfig.xml" enumName="severity"
+             sortMissingLast="true"/>
+  <fieldType name="enum_first" class="solr.EnumField" enumsConfig="enumsConfig.xml" enumName="severity"
+             sortMissingFirst="true"/>
+  <!-- EnumField incorrectly disallows missing DocValues - see SOLR-5927 -->
+  <!-- <fieldType name="enum_dv" class="solr.EnumField" enumsConfig="enumsConfig.xml" enumName="severity" docValues="true"/> -->
+  <!-- <fieldType name="enum_dv_last" class="solr.EnumField" enumsConfig="enumsConfig.xml" enumName="severity" docValues="true" sortMissingLast="true"/> -->
+  <!-- <fieldType name="enum_dv_first" class="solr.EnumField" enumsConfig="enumsConfig.xml" enumName="severity" docValues="true" sortMissingFirst="true"/> -->
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-spatial.xml b/solr/core/src/test-files/solr/collection1/conf/schema-spatial.xml
index 15837f3..254f58b 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-spatial.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-spatial.xml
@@ -17,62 +17,57 @@
   -->
 
 <schema name="test" version="1.4">
-  <types>
 
-    <fieldType name="tint" class="solr.TrieIntField" precisionStep="8"/>
-    <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8"/>
-    <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8"/>
-    <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8"/>
-    <fieldType name="tdoubleDV" class="solr.TrieDoubleField" precisionStep="8" docValues="true"/>
+  <fieldType name="tint" class="solr.TrieIntField" precisionStep="8"/>
+  <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8"/>
+  <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8"/>
+  <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8"/>
+  <fieldType name="tdoubleDV" class="solr.TrieDoubleField" precisionStep="8" docValues="true"/>
 
-    <fieldType name="boolean" class="solr.BoolField"/>
+  <fieldType name="boolean" class="solr.BoolField"/>
 
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
 
-    <fieldType name="srpt_geohash"   class="solr.SpatialRecursivePrefixTreeFieldType"
-               prefixTree="geohash" distanceUnits="degrees"
-        />
-    <fieldType name="srpt_quad"   class="solr.SpatialRecursivePrefixTreeFieldType"
-              prefixTree="quad" distanceUnits="degrees"
-        />
-    <fieldType name="srpt_packedquad"   class="solr.SpatialRecursivePrefixTreeFieldType"
-              prefixTree="packedQuad" distanceUnits="degrees"
-        />
-    <fieldType name="srpt_100km"   class="solr.SpatialRecursivePrefixTreeFieldType"
-              maxDistErr="100" distanceUnits="kilometers"
-        />
-    <fieldType name="stqpt_geohash"   class="solr.SpatialTermQueryPrefixTreeFieldType"
-              prefixTree="geohash" distanceUnits="degrees" />
+  <fieldType name="srpt_geohash" class="solr.SpatialRecursivePrefixTreeFieldType"
+             prefixTree="geohash" distanceUnits="degrees"
+  />
+  <fieldType name="srpt_quad" class="solr.SpatialRecursivePrefixTreeFieldType"
+             prefixTree="quad" distanceUnits="degrees"
+  />
+  <fieldType name="srpt_packedquad" class="solr.SpatialRecursivePrefixTreeFieldType"
+             prefixTree="packedQuad" distanceUnits="degrees"
+  />
+  <fieldType name="srpt_100km" class="solr.SpatialRecursivePrefixTreeFieldType"
+             maxDistErr="100" distanceUnits="kilometers"
+  />
+  <fieldType name="stqpt_geohash" class="solr.SpatialTermQueryPrefixTreeFieldType"
+             prefixTree="geohash" distanceUnits="degrees"/>
 
-    <fieldType name="stqpt_u"  class="solr.SpatialTermQueryPrefixTreeFieldType"
-        geo="false" distCalculator="cartesian^2" worldBounds="ENVELOPE(0, 1000, 1000, 0)" distanceUnits="degrees"/>
+  <fieldType name="stqpt_u" class="solr.SpatialTermQueryPrefixTreeFieldType"
+             geo="false" distCalculator="cartesian^2" worldBounds="ENVELOPE(0, 1000, 1000, 0)" distanceUnits="degrees"/>
 
-    <fieldType name="pointvector" class="solr.SpatialPointVectorFieldType"
-               numberType="tdouble" distanceUnits="degrees"/>
+  <fieldType name="pointvector" class="solr.SpatialPointVectorFieldType"
+             numberType="tdouble" distanceUnits="degrees"/>
 
-    <fieldType name="srptgeom" class="solr.RptWithGeometrySpatialField" />
+  <fieldType name="srptgeom" class="solr.RptWithGeometrySpatialField"/>
 
-    <fieldType name="bbox" class="solr.BBoxField"
-               numberType="tdoubleDV" distanceUnits="degrees" storeSubFields="false"/>
-  </types>
+  <fieldType name="bbox" class="solr.BBoxField"
+             numberType="tdoubleDV" distanceUnits="degrees" storeSubFields="false"/>
 
 
-  <fields>
+  <field name="id" type="string" required="true"/>
 
-    <field name="id" type="string" required="true"/>
+  <field name="srpt_geohash" type="srpt_geohash" multiValued="true"/>
+  <field name="srpt_quad" type="srpt_quad" multiValued="true"/>
+  <field name="srpt_packedquad" type="srpt_packedquad" multiValued="true"/>
+  <field name="stqpt_geohash" type="stqpt_geohash" multiValued="true"/>
+  <field name="pointvector" type="pointvector"/>
+  <field name="srptgeom" type="srptgeom"/>
+  <field name="bbox" type="bbox"/>
 
-    <field name="srpt_geohash" type="srpt_geohash" multiValued="true" />
-    <field name="srpt_quad" type="srpt_quad" multiValued="true" />
-    <field name="srpt_packedquad" type="srpt_packedquad" multiValued="true" />
-    <field name="stqpt_geohash" type="stqpt_geohash" multiValued="true" />
-    <field name="pointvector" type="pointvector" />
-    <field name="srptgeom" type="srptgeom" />
-    <field name="bbox" type="bbox" />
+  <dynamicField name="bboxD_*" type="bbox" indexed="true"/>
+  <dynamicField name="str_*" type="string" indexed="true" stored="true"/>
 
-    <dynamicField name="bboxD_*" type="bbox" indexed="true" />
-    <dynamicField name="str_*" type="string" indexed="true" stored="true"/>
-
-  </fields>
 
   <uniqueKey>id</uniqueKey>
 
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-spellchecker.xml b/solr/core/src/test-files/solr/collection1/conf/schema-spellchecker.xml
index e145e14..11e7dba 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-spellchecker.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-spellchecker.xml
@@ -33,18 +33,17 @@
        1.0: multiValued attribute did not exist, all fields are multiValued by nature
        1.1: multiValued attribute introduced, false by default -->
 
-  <types>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true" omitNorms="true"/>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true" omitNorms="true"/>
 
-    <fieldType name="text" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
+  <fieldType name="text" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
 
   <fieldType name="spellText" class="solr.TextField" positionIncrementGap="100">
     <analyzer type="index">
@@ -61,27 +60,22 @@
       <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
     </analyzer>
   </fieldType>
-  
- </types>
-
 
- <fields>
-   <field name="id" type="string" indexed="true" stored="true"/>
-   <field name="spell" type="spellText" indexed="true" stored="true" />
-   <field name="suggest" type="spellText" indexed="true" stored="true" />
-   <field name="text" type="text" indexed="true" stored="false" multiValued="true"/>
- </fields>
+  <field name="id" type="string" indexed="true" stored="true"/>
+  <field name="spell" type="spellText" indexed="true" stored="true"/>
+  <field name="suggest" type="spellText" indexed="true" stored="true"/>
+  <field name="text" type="text" indexed="true" stored="false" multiValued="true"/>
 
- <copyField source="text" dest="spell"/>
- <copyField source="text" dest="suggest"/>
+  <copyField source="text" dest="spell"/>
+  <copyField source="text" dest="suggest"/>
 
- <!-- field to use to determine and enforce document uniqueness. -->
- <uniqueKey>id</uniqueKey>
+  <!-- field to use to determine and enforce document uniqueness. -->
+  <uniqueKey>id</uniqueKey>
 
- <!-- field for the QueryParser to use when an explicit fieldname is absent -->
- <defaultSearchField>text</defaultSearchField>
+  <!-- field for the QueryParser to use when an explicit fieldname is absent -->
+  <defaultSearchField>text</defaultSearchField>
 
- <!-- SolrQueryParser configuration: defaultOperator="AND|OR" -->
- <solrQueryParser defaultOperator="OR"/>
+  <!-- SolrQueryParser configuration: defaultOperator="AND|OR" -->
+  <solrQueryParser defaultOperator="OR"/>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-sql.xml b/solr/core/src/test-files/solr/collection1/conf/schema-sql.xml
index bf16327..818a6c8 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-sql.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-sql.xml
@@ -26,550 +26,568 @@
   -->
 
 <schema name="test" version="1.6">
-  <types>
-
-    <!-- field type definitions... note that the "name" attribute is
-         just a label to be used by field definitions.  The "class"
-         attribute and any other attributes determine the real type and
-         behavior of the fieldtype.
-      -->
-
-    <!-- numeric field types that store and index the text
-         value verbatim (and hence don't sort correctly or support range queries.)
-         These are provided more for backward compatability, allowing one
-         to create a schema that matches an existing lucene index.
+
+  <!-- field type definitions... note that the "name" attribute is
+       just a label to be used by field definitions.  The "class"
+       attribute and any other attributes determine the real type and
+       behavior of the fieldtype.
     -->
 
+  <!-- numeric field types that store and index the text
+       value verbatim (and hence don't sort correctly or support range queries.)
+       These are provided more for backward compatability, allowing one
+       to create a schema that matches an existing lucene index.
+  -->
 
-    <fieldType name="int" docValues="true" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="float" docValues="true" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-
-    <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
-
-    <!-- numeric field types that manipulate the value into
-       a string value that isn't human readable in it's internal form,
-       but sorts correctly and supports range queries.
-
-         If sortMissingLast="true" then a sort on this field will cause documents
-       without the field to come after documents with the field,
-       regardless of the requested sort order.
-         If sortMissingFirst="true" then a sort on this field will cause documents
-       without the field to come before documents with the field,
-       regardless of the requested sort order.
-         If sortMissingLast="false" and sortMissingFirst="false" (the default),
-       then default lucene sorting will be used which places docs without the field
-       first in an ascending sort and last in a descending sort.
-    -->
 
+  <fieldType name="int" docValues="true" class="solr.TrieIntField" precisionStep="0" omitNorms="true"
+             positionIncrementGap="0"/>
+  <fieldType name="float" docValues="true" class="solr.TrieFloatField" precisionStep="0" omitNorms="true"
+             positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+
+  <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+
+  <!-- numeric field types that manipulate the value into
+     a string value that isn't human readable in it's internal form,
+     but sorts correctly and supports range queries.
+
+       If sortMissingLast="true" then a sort on this field will cause documents
+     without the field to come after documents with the field,
+     regardless of the requested sort order.
+       If sortMissingFirst="true" then a sort on this field will cause documents
+     without the field to come before documents with the field,
+     regardless of the requested sort order.
+       If sortMissingLast="false" and sortMissingFirst="false" (the default),
+     then default lucene sorting will be used which places docs without the field
+     first in an ascending sort and last in a descending sort.
+  -->
 
 
-    <!-- Field type demonstrating an Analyzer failure -->
-    <fieldtype name="failtype1" class="solr.TextField">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-
-    <!-- Demonstrating ignoreCaseChange -->
-    <fieldtype name="wdf_nocase" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-
-    <fieldtype name="wdf_preserve" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-
-
-    <fieldtype name="boolean" class="solr.BoolField" sortMissingLast="true"/>
-    <fieldtype name="string" class="solr.StrField" sortMissingLast="true" docValues="true"/>
-
-    <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
-         seconds part (.999) is optional.
-      -->
-    <fieldtype name="date" class="solr.TrieDateField" precisionStep="0"/>
-    <fieldtype name="tdate" class="solr.TrieDateField" precisionStep="6"/>
-
-
-    <!-- solr.TextField allows the specification of custom
-         text analyzers specified as a tokenizer and a list
-         of token filters.
-      -->
-    <fieldtype name="text" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-
-
-    <fieldtype name="nametext" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.core.WhitespaceAnalyzer"/>
-    </fieldtype>
-
-    <fieldtype name="teststop" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.LowerCaseTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-
-    <!-- fieldtypes in this section isolate tokenizers and tokenfilters for testing -->
-    <fieldtype name="lowertok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.LowerCaseTokenizerFactory"/></analyzer>
-    </fieldtype>
-    <fieldtype name="keywordtok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/></analyzer>
-    </fieldtype>
-    <fieldtype name="standardtok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.StandardTokenizerFactory"/></analyzer>
-    </fieldtype>
-    <fieldtype name="lettertok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.LetterTokenizerFactory"/></analyzer>
-    </fieldtype>
-    <fieldtype name="whitetok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.MockTokenizerFactory"/></analyzer>
-    </fieldtype>
-    <fieldtype name="HTMLstandardtok" class="solr.TextField">
-      <analyzer>
-        <charFilter class="solr.HTMLStripCharFilterFactory"/>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="HTMLwhitetok" class="solr.TextField">
-      <analyzer>
-        <charFilter class="solr.HTMLStripCharFilterFactory"/>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="standardtokfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="standardfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="lowerfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="lowerpunctfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="1" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="patternreplacefilt" class="solr.TextField">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
-        <filter class="solr.PatternReplaceFilterFactory"
-                pattern="([^a-zA-Z])" replacement="_" replace="all"
-            />
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="patterntok" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.PatternTokenizerFactory" pattern=","/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="porterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-    <!-- fieldtype name="snowballfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.SnowballPorterFilterFactory"/>
-      </analyzer>
-    </fieldtype -->
-    <fieldtype name="engporterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="custengporterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="stopfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true"/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="custstopfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="lengthfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LengthFilterFactory" min="2" max="5"/>
-      </analyzer>
-    </fieldtype>
-    <fieldType name="charfilthtmlmap" class="solr.TextField">
-      <analyzer>
-        <charFilter class="solr.HTMLStripCharFilterFactory"/>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldtype name="subword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-
-    <fieldtype name="numericsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-        <filter class="solr.StopFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-        <filter class="solr.StopFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-
-    <fieldtype name="protectedsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory"  splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-
-
-    <!-- more flexible in matching skus, but more chance of a false match -->
-    <fieldtype name="skutype1" class="solr.TextField">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-
-    <!-- less flexible in matching skus, but less chance of a false match -->
-    <fieldtype name="skutype2" class="solr.TextField">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-
-    <!-- less flexible in matching skus, but less chance of a false match -->
-    <fieldtype name="syn" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldtype>
-
-
-    <fieldtype  name="unstored" class="solr.StrField" indexed="true" stored="false"/>
-
-
-    <fieldtype name="textgap" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-
-    <fieldType name="uuid" class="solr.UUIDField" />
-
-    <!-- Try out some point types -->
-    <fieldType name="xy" class="solr.PointType" dimension="2" subFieldType="double"/>
-    <fieldType name="x" class="solr.PointType" dimension="1" subFieldType="double"/>
-    <fieldType name="tenD" class="solr.PointType" dimension="10" subFieldType="double"/>
-    <!-- Use the sub field suffix -->
-    <fieldType name="xyd" class="solr.PointType" dimension="2" subFieldSuffix="_d1"/>
-    <fieldtype name="geohash" class="solr.GeoHashField"/>
-
-
-    <fieldType name="latLon" class="solr.LatLonType" subFieldType="double"/>
-
-    <!--  some per-field similarity examples -->
-
-    <!--  specify a Similarity classname directly -->
-    <!--
-    <fieldType name="sim1" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-      <similarity class="org.apache.lucene.misc.SweetSpotSimilarity"/>
-    </fieldType>
-    -->
-    <!--  specify a Similarity factory -->
-    <!--
-    <fieldType name="sim2" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-      <similarity class="org.apache.solr.search.similarities.CustomSimilarityFactory">
-        <str name="echo">is there an echo?</str>
-      </similarity>
-    </fieldType>
-    -->
-    <!-- don't specify any sim at all: get the default  -->
-    <!--
-    <fieldType name="sim3" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
+  <!-- Field type demonstrating an Analyzer failure -->
+  <fieldtype name="failtype1" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0"
+              catenateNumbers="0" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+
+  <!-- Demonstrating ignoreCaseChange -->
+  <fieldtype name="wdf_nocase" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+
+  <fieldtype name="wdf_preserve" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+
+
+  <fieldtype name="boolean" class="solr.BoolField" sortMissingLast="true"/>
+  <fieldtype name="string" class="solr.StrField" sortMissingLast="true" docValues="true"/>
+
+  <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
+       seconds part (.999) is optional.
     -->
-  </types>
-
-
-  <fields>
-    <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
-    <field name="signatureField" type="string" indexed="true" stored="false"/>
-
-    <field name="s_multi" type="string" indexed="true" stored="true" docValues="true" multiValued="true"/>
-    <field name="i_multi" type="int" indexed="true" stored="true" docValues="true" multiValued="true"/>
-    <field name="f_multi" type="float" indexed="true" stored="true" docValues="true" multiValued="true"/>
-    <field name="l_multi" type="long" indexed="true" stored="true" docValues="true" multiValued="true"/>
-    <field name="d_multi" type="double" indexed="true" stored="true" docValues="true" multiValued="true"/>
-
-    <field name="uuid" type="uuid" stored="true" />
-    <field name="name" type="nametext" indexed="true" stored="true"/>
-    <field name="text" type="text" indexed="true" stored="false"/>
-    <field name="subject" type="text" indexed="true" stored="true"/>
-    <field name="title" type="nametext" indexed="true" stored="true"/>
-    <field name="weight" type="float" indexed="true" stored="true" multiValued="false"/>
-    <field name="bday" type="date" indexed="true" stored="true" multiValued="false"/>
-
-    <field name="title_stemmed" type="text" indexed="true" stored="false"/>
-    <field name="title_lettertok" type="lettertok" indexed="true" stored="false"/>
-
-    <field name="syn" type="syn" indexed="true" stored="true"/>
-
-    <!-- to test property inheritance and overriding -->
-    <field name="shouldbeunstored" type="unstored" />
-    <field name="shouldbestored" type="unstored" stored="true"/>
-    <field name="shouldbeunindexed" type="unstored" indexed="false" stored="true"/>
-
-    <!-- Test points -->
-    <!-- Test points -->
-    <field name="home" type="xy" indexed="true" stored="true" multiValued="false"/>
-    <field name="x" type="x" indexed="true" stored="true" multiValued="false"/>
-    <field name="homed" type="xyd" indexed="true" stored="true" multiValued="false"/>
-    <field name="home_ns" type="xy" indexed="true" stored="false" multiValued="false"/>
-    <field name="work" type="xy" indexed="true" stored="true" multiValued="false"/>
-
-    <field name="home_ll" type="latLon" indexed="true" stored="true" multiValued="false"/>
-    <field name="home_gh" type="geohash" indexed="true" stored="true" multiValued="false"/>
-
-
-    <field name="point10" type="tenD" indexed="true" stored="true" multiValued="false"/>
-
-
-    <!-- test different combinations of indexed and stored -->
-    <field name="bind" type="boolean" indexed="true" stored="false"/>
-    <field name="bsto" type="boolean" indexed="false" stored="true"/>
-    <field name="bindsto" type="boolean" indexed="true" stored="true"/>
-    <field name="isto" type="int" indexed="false" stored="true"/>
-    <field name="iind" type="int" indexed="true" stored="false"/>
-    <field name="ssto" type="string" indexed="false" stored="true"/>
-    <field name="sind" type="string" indexed="true" stored="false"/>
-    <field name="sindsto" type="string" indexed="true" stored="true"/>
-
-    <!-- test combinations of term vector settings -->
-    <field name="test_basictv" type="text" termVectors="true"/>
-    <field name="test_notv" type="text" termVectors="false"/>
-    <field name="test_postv" type="text" termVectors="true" termPositions="true"/>
-    <field name="test_offtv" type="text" termVectors="true" termOffsets="true"/>
-    <field name="test_posofftv" type="text" termVectors="true"
-           termPositions="true" termOffsets="true"/>
-
-    <!-- fields to test individual tokenizers and tokenfilters -->
-    <field name="teststop" type="teststop" indexed="true" stored="true"/>
-    <field name="lowertok" type="lowertok" indexed="true" stored="true"/>
-    <field name="keywordtok" type="keywordtok" indexed="true" stored="true"/>
-    <field name="standardtok" type="standardtok" indexed="true" stored="true"/>
-    <field name="HTMLstandardtok" type="HTMLstandardtok" indexed="true" stored="true"/>
-    <field name="lettertok" type="lettertok" indexed="true" stored="true"/>
-    <field name="whitetok" type="whitetok" indexed="true" stored="true"/>
-    <field name="HTMLwhitetok" type="HTMLwhitetok" indexed="true" stored="true"/>
-    <field name="standardtokfilt" type="standardtokfilt" indexed="true" stored="true"/>
-    <field name="standardfilt" type="standardfilt" indexed="true" stored="true"/>
-    <field name="lowerfilt" type="lowerfilt" indexed="true" stored="true"/>
-    <field name="lowerfilt1" type="lowerfilt" indexed="true" stored="true"/>
-    <field name="lowerfilt1and2" type="lowerfilt" indexed="true" stored="true"/>
-    <field name="patterntok" type="patterntok" indexed="true" stored="true"/>
-    <field name="patternreplacefilt" type="patternreplacefilt" indexed="true" stored="true"/>
-    <field name="porterfilt" type="porterfilt" indexed="true" stored="true"/>
-    <field name="engporterfilt" type="engporterfilt" indexed="true" stored="true"/>
-    <field name="custengporterfilt" type="custengporterfilt" indexed="true" stored="true"/>
-    <field name="stopfilt" type="stopfilt" indexed="true" stored="true"/>
-    <field name="custstopfilt" type="custstopfilt" indexed="true" stored="true"/>
-    <field name="lengthfilt" type="lengthfilt" indexed="true" stored="true"/>
-    <field name="wdf_nocase" type="wdf_nocase" indexed="true" stored="true"/>
-    <field name="wdf_preserve" type="wdf_preserve" indexed="true" stored="true"/>
-
-    <field name="numberpartfail" type="failtype1" indexed="true" stored="true"/>
-
-    <field name="nullfirst" type="string" indexed="true" stored="true" sortMissingFirst="true" multiValued="false"/>
-
-    <field name="subword" type="subword" indexed="true" stored="true"/>
-    <field name="subword_offsets" type="subword" indexed="true" stored="true" termOffsets="true"/>
-    <field name="numericsubword" type="numericsubword" indexed="true" stored="true"/>
-    <field name="protectedsubword" type="protectedsubword" indexed="true" stored="true"/>
-
-    <field name="sku1" type="skutype1" indexed="true" stored="true"/>
-    <field name="sku2" type="skutype2" indexed="true" stored="true"/>
-
-    <field name="textgap" type="textgap" indexed="true" stored="true"/>
-
-    <field name="timestamp" type="date" indexed="true" stored="true" default="NOW" multiValued="false"/>
-    <field name="multiDefault" type="string" indexed="true" stored="true" default="muLti-Default" multiValued="true"/>
-    <field name="intDefault" type="int" indexed="true" stored="true" default="42" multiValued="false"/>
-
-    <!--
-    <field name="sim1text" type="sim1" indexed="true" stored="true"/>
-    <field name="sim2text" type="sim2" indexed="true" stored="true"/>
-    <field name="sim3text" type="sim3" indexed="true" stored="true"/>
+  <fieldtype name="date" class="solr.TrieDateField" precisionStep="0"/>
+  <fieldtype name="tdate" class="solr.TrieDateField" precisionStep="6"/>
+
+
+  <!-- solr.TextField allows the specification of custom
+       text analyzers specified as a tokenizer and a list
+       of token filters.
     -->
+  <fieldtype name="text" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+
+
+  <fieldtype name="nametext" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.core.WhitespaceAnalyzer"/>
+  </fieldtype>
+
+  <fieldtype name="teststop" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LowerCaseTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+
+  <!-- fieldtypes in this section isolate tokenizers and tokenfilters for testing -->
+  <fieldtype name="lowertok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LowerCaseTokenizerFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="keywordtok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="standardtok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="lettertok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LetterTokenizerFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="whitetok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="HTMLstandardtok" class="solr.TextField">
+    <analyzer>
+      <charFilter class="solr.HTMLStripCharFilterFactory"/>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="HTMLwhitetok" class="solr.TextField">
+    <analyzer>
+      <charFilter class="solr.HTMLStripCharFilterFactory"/>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="standardtokfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="standardfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="lowerfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="lowerpunctfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="1" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="patternreplacefilt" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+      <filter class="solr.PatternReplaceFilterFactory"
+              pattern="([^a-zA-Z])" replacement="_" replace="all"
+      />
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="patterntok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.PatternTokenizerFactory" pattern=","/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="porterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+  <!-- fieldtype name="snowballfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SnowballPorterFilterFactory"/>
+    </analyzer>
+  </fieldtype -->
+  <fieldtype name="engporterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="custengporterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="stopfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="custstopfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="lengthfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LengthFilterFactory" min="2" max="5"/>
+    </analyzer>
+  </fieldtype>
+  <fieldType name="charfilthtmlmap" class="solr.TextField">
+    <analyzer>
+      <charFilter class="solr.HTMLStripCharFilterFactory"/>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldtype name="subword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+
+  <fieldtype name="numericsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1"
+              generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1"
+              generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+
+  <fieldtype name="protectedsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1"
+              generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+
+
+  <!-- more flexible in matching skus, but more chance of a false match -->
+  <fieldtype name="skutype1" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+
+  <!-- less flexible in matching skus, but less chance of a false match -->
+  <fieldtype name="skutype2" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+
+  <!-- less flexible in matching skus, but less chance of a false match -->
+  <fieldtype name="syn" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldtype>
+
+
+  <fieldtype name="unstored" class="solr.StrField" indexed="true" stored="false"/>
+
+
+  <fieldtype name="textgap" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+
+  <fieldType name="uuid" class="solr.UUIDField"/>
+
+  <!-- Try out some point types -->
+  <fieldType name="xy" class="solr.PointType" dimension="2" subFieldType="double"/>
+  <fieldType name="x" class="solr.PointType" dimension="1" subFieldType="double"/>
+  <fieldType name="tenD" class="solr.PointType" dimension="10" subFieldType="double"/>
+  <!-- Use the sub field suffix -->
+  <fieldType name="xyd" class="solr.PointType" dimension="2" subFieldSuffix="_d1"/>
+  <fieldtype name="geohash" class="solr.GeoHashField"/>
+
+
+  <fieldType name="latLon" class="solr.LatLonType" subFieldType="double"/>
+
+  <!--  some per-field similarity examples -->
+
+  <!--  specify a Similarity classname directly -->
+  <!--
+  <fieldType name="sim1" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+    <similarity class="org.apache.lucene.misc.SweetSpotSimilarity"/>
+  </fieldType>
+  -->
+  <!--  specify a Similarity factory -->
+  <!--
+  <fieldType name="sim2" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+    <similarity class="org.apache.solr.search.similarities.CustomSimilarityFactory">
+      <str name="echo">is there an echo?</str>
+    </similarity>
+  </fieldType>
+  -->
+  <!-- don't specify any sim at all: get the default  -->
+  <!--
+  <fieldType name="sim3" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  -->
 
-    <field name="tlong" type="tlong" indexed="true" stored="true" />
 
-    <field name="_version_" type="long" indexed="true" docValues="true" stored="true"/>
+  <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="signatureField" type="string" indexed="true" stored="false"/>
+
+  <field name="s_multi" type="string" indexed="true" stored="true" docValues="true" multiValued="true"/>
+  <field name="i_multi" type="int" indexed="true" stored="true" docValues="true" multiValued="true"/>
+  <field name="f_multi" type="float" indexed="true" stored="true" docValues="true" multiValued="true"/>
+  <field name="l_multi" type="long" indexed="true" stored="true" docValues="true" multiValued="true"/>
+  <field name="d_multi" type="double" indexed="true" stored="true" docValues="true" multiValued="true"/>
+
+  <field name="uuid" type="uuid" stored="true"/>
+  <field name="name" type="nametext" indexed="true" stored="true"/>
+  <field name="text" type="text" indexed="true" stored="false"/>
+  <field name="subject" type="text" indexed="true" stored="true"/>
+  <field name="title" type="nametext" indexed="true" stored="true"/>
+  <field name="weight" type="float" indexed="true" stored="true" multiValued="false"/>
+  <field name="bday" type="date" indexed="true" stored="true" multiValued="false"/>
+
+  <field name="title_stemmed" type="text" indexed="true" stored="false"/>
+  <field name="title_lettertok" type="lettertok" indexed="true" stored="false"/>
+
+  <field name="syn" type="syn" indexed="true" stored="true"/>
+
+  <!-- to test property inheritance and overriding -->
+  <field name="shouldbeunstored" type="unstored"/>
+  <field name="shouldbestored" type="unstored" stored="true"/>
+  <field name="shouldbeunindexed" type="unstored" indexed="false" stored="true"/>
+
+  <!-- Test points -->
+  <!-- Test points -->
+  <field name="home" type="xy" indexed="true" stored="true" multiValued="false"/>
+  <field name="x" type="x" indexed="true" stored="true" multiValued="false"/>
+  <field name="homed" type="xyd" indexed="true" stored="true" multiValued="false"/>
+  <field name="home_ns" type="xy" indexed="true" stored="false" multiValued="false"/>
+  <field name="work" type="xy" indexed="true" stored="true" multiValued="false"/>
+
+  <field name="home_ll" type="latLon" indexed="true" stored="true" multiValued="false"/>
+  <field name="home_gh" type="geohash" indexed="true" stored="true" multiValued="false"/>
+
+
+  <field name="point10" type="tenD" indexed="true" stored="true" multiValued="false"/>
+
+
+  <!-- test different combinations of indexed and stored -->
+  <field name="bind" type="boolean" indexed="true" stored="false"/>
+  <field name="bsto" type="boolean" indexed="false" stored="true"/>
+  <field name="bindsto" type="boolean" indexed="true" stored="true"/>
+  <field name="isto" type="int" indexed="false" stored="true"/>
+  <field name="iind" type="int" indexed="true" stored="false"/>
+  <field name="ssto" type="string" indexed="false" stored="true"/>
+  <field name="sind" type="string" indexed="true" stored="false"/>
+  <field name="sindsto" type="string" indexed="true" stored="true"/>
+
+  <!-- test combinations of term vector settings -->
+  <field name="test_basictv" type="text" termVectors="true"/>
+  <field name="test_notv" type="text" termVectors="false"/>
+  <field name="test_postv" type="text" termVectors="true" termPositions="true"/>
+  <field name="test_offtv" type="text" termVectors="true" termOffsets="true"/>
+  <field name="test_posofftv" type="text" termVectors="true"
+         termPositions="true" termOffsets="true"/>
+
+  <!-- fields to test individual tokenizers and tokenfilters -->
+  <field name="teststop" type="teststop" indexed="true" stored="true"/>
+  <field name="lowertok" type="lowertok" indexed="true" stored="true"/>
+  <field name="keywordtok" type="keywordtok" indexed="true" stored="true"/>
+  <field name="standardtok" type="standardtok" indexed="true" stored="true"/>
+  <field name="HTMLstandardtok" type="HTMLstandardtok" indexed="true" stored="true"/>
+  <field name="lettertok" type="lettertok" indexed="true" stored="true"/>
+  <field name="whitetok" type="whitetok" indexed="true" stored="true"/>
+  <field name="HTMLwhitetok" type="HTMLwhitetok" indexed="true" stored="true"/>
+  <field name="standardtokfilt" type="standardtokfilt" indexed="true" stored="true"/>
+  <field name="standardfilt" type="standardfilt" indexed="true" stored="true"/>
+  <field name="lowerfilt" type="lowerfilt" indexed="true" stored="true"/>
+  <field name="lowerfilt1" type="lowerfilt" indexed="true" stored="true"/>
+  <field name="lowerfilt1and2" type="lowerfilt" indexed="true" stored="true"/>
+  <field name="patterntok" type="patterntok" indexed="true" stored="true"/>
+  <field name="patternreplacefilt" type="patternreplacefilt" indexed="true" stored="true"/>
+  <field name="porterfilt" type="porterfilt" indexed="true" stored="true"/>
+  <field name="engporterfilt" type="engporterfilt" indexed="true" stored="true"/>
+  <field name="custengporterfilt" type="custengporterfilt" indexed="true" stored="true"/>
+  <field name="stopfilt" type="stopfilt" indexed="true" stored="true"/>
+  <field name="custstopfilt" type="custstopfilt" indexed="true" stored="true"/>
+  <field name="lengthfilt" type="lengthfilt" indexed="true" stored="true"/>
+  <field name="wdf_nocase" type="wdf_nocase" indexed="true" stored="true"/>
+  <field name="wdf_preserve" type="wdf_preserve" indexed="true" stored="true"/>
+
+  <field name="numberpartfail" type="failtype1" indexed="true" stored="true"/>
+
+  <field name="nullfirst" type="string" indexed="true" stored="true" sortMissingFirst="true" multiValued="false"/>
+
+  <field name="subword" type="subword" indexed="true" stored="true"/>
+  <field name="subword_offsets" type="subword" indexed="true" stored="true" termOffsets="true"/>
+  <field name="numericsubword" type="numericsubword" indexed="true" stored="true"/>
+  <field name="protectedsubword" type="protectedsubword" indexed="true" stored="true"/>
+
+  <field name="sku1" type="skutype1" indexed="true" stored="true"/>
+  <field name="sku2" type="skutype2" indexed="true" stored="true"/>
+
+  <field name="textgap" type="textgap" indexed="true" stored="true"/>
+
+  <field name="timestamp" type="date" indexed="true" stored="true" default="NOW" multiValued="false"/>
+  <field name="multiDefault" type="string" indexed="true" stored="true" default="muLti-Default" multiValued="true"/>
+  <field name="intDefault" type="int" indexed="true" stored="true" default="42" multiValued="false"/>
+
+  <!--
+  <field name="sim1text" type="sim1" indexed="true" stored="true"/>
+  <field name="sim2text" type="sim2" indexed="true" stored="true"/>
+  <field name="sim3text" type="sim3" indexed="true" stored="true"/>
+  -->
 
-    <!-- Dynamic field definitions.  If a field name is not found, dynamicFields
-         will be used if the name matches any of the patterns.
-         RESTRICTION: the glob-like pattern in the name attribute must have
-         a "*" only at the start or the end.
-         EXAMPLE:  name="*_i" will match any field ending in _i (like myid_i, z_i)
-         Longer patterns will be matched first.  if equal size patterns
-         both match, the first appearing in the schema will be used.
-    -->
-    <dynamicField name="*_i"  type="int"    indexed="true"  stored="true"/>
-    <dynamicField name="*_i1"  type="int"    indexed="true" stored="true" multiValued="false"/>
-
-    <dynamicField name="*_s"  type="string"  indexed="true"  stored="true"/>
-    <dynamicField name="*_s1"  type="string"  indexed="true"  stored="true" multiValued="false"/>
-    <dynamicField name="*_l"  type="long"   indexed="true"  stored="true"/>
-    <dynamicField name="*_l1"  type="long"   indexed="true"  stored="true" multiValued="false"/>
-    <dynamicField name="*_t"  type="text"    indexed="true"  stored="true"/>
-    <dynamicField name="*_b"  type="boolean" indexed="true"  stored="true"/>
-    <dynamicField name="*_f"  type="float"  indexed="true"  stored="true"/>
-    <dynamicField name="*_f1"  type="float"  indexed="true"  stored="true" multiValued="false"/>
-    <dynamicField name="*_d"  type="double" indexed="true"  stored="true"/>
-    <dynamicField name="*_d1"  type="double" indexed="true"  stored="true" multiValued="false"/>
-    <dynamicField name="*_dt" type="date"    indexed="true"  stored="true"/>
-    <dynamicField name="*_dt1" type="date"    indexed="true"  stored="true" multiValued="false"/>
-
-    <!-- some trie-coded dynamic fields for faster range queries -->
-    <dynamicField name="*_ti" type="tint"    indexed="true"  stored="true"/>
-    <dynamicField name="*_ti1" type="tint"    indexed="true"  stored="true" multiValued="false"/>
-    <dynamicField name="*_tl" type="tlong"   indexed="true"  stored="true"/>
-    <dynamicField name="*_tl1" type="tlong"   indexed="true"  stored="true" multiValued="false"/>
-    <dynamicField name="*_tf" type="tfloat"  indexed="true"  stored="true"/>
-    <dynamicField name="*_tf1" type="tfloat"  indexed="true"  stored="true" multiValued="false"/>
-    <dynamicField name="*_td" type="tdouble" indexed="true"  stored="true"/>
-    <dynamicField name="*_td1" type="tdouble" indexed="true" stored="true" multiValued="false"/>
-    <dynamicField name="*_tds" type="tdouble" indexed="true" stored="true" multiValued="false"/>
-    <dynamicField name="*_tdt" type="tdate"  indexed="true"  stored="true"/>
-    <dynamicField name="*_tdt1" type="tdate"  indexed="true"  stored="true" multiValued="false"/>
-
-
-
-
-    <dynamicField name="*_sI" type="string"  indexed="true"  stored="false"/>
-    <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
-    <dynamicField name="t_*"  type="text"    indexed="true"  stored="true"/>
-    <dynamicField name="tv_*"  type="text" indexed="true"  stored="true"
-                  termVectors="true" termPositions="true" termOffsets="true"/>
-    <dynamicField name="tv_mv_*"  type="text" indexed="true"  stored="true" multiValued="true"
-                  termVectors="true" termPositions="true" termOffsets="true"/>
-
-    <dynamicField name="*_p"  type="xyd" indexed="true"  stored="true" multiValued="false"/>
-
-    <!-- special fields for dynamic copyField test -->
-    <dynamicField name="dynamic_*" type="string" indexed="true" stored="true"/>
-    <dynamicField name="*_dynamic" type="string" indexed="true" stored="true"/>
-
-    <!-- for testing to ensure that longer patterns are matched first -->
-    <dynamicField name="*aa"  type="string"  indexed="true" stored="true"/>
-
-    <!-- ignored becuase not stored or indexed -->
-    <dynamicField name="*_ignored" type="text" indexed="false" stored="false"/>
-
-    <dynamicField name="*_mfacet" type="string" indexed="true" stored="false" multiValued="true" />
-
-    <!-- make sure custom sims work with dynamic fields -->
-    <!--
-    <dynamicField name="*_sim1" type="sim1" indexed="true" stored="true"/>
-    <dynamicField name="*_sim2" type="sim2" indexed="true" stored="true"/>
-    <dynamicField name="*_sim3" type="sim3" indexed="true" stored="true"/>
-    -->
-  </fields>
+  <field name="tlong" type="tlong" indexed="true" stored="true"/>
+
+  <field name="_version_" type="long" indexed="true" docValues="true" stored="true"/>
+
+  <!-- Dynamic field definitions.  If a field name is not found, dynamicFields
+       will be used if the name matches any of the patterns.
+       RESTRICTION: the glob-like pattern in the name attribute must have
+       a "*" only at the start or the end.
+       EXAMPLE:  name="*_i" will match any field ending in _i (like myid_i, z_i)
+       Longer patterns will be matched first.  if equal size patterns
+       both match, the first appearing in the schema will be used.
+  -->
+  <dynamicField name="*_i" type="int" indexed="true" stored="true"/>
+  <dynamicField name="*_i1" type="int" indexed="true" stored="true" multiValued="false"/>
+
+  <dynamicField name="*_s" type="string" indexed="true" stored="true"/>
+  <dynamicField name="*_s1" type="string" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_l" type="long" indexed="true" stored="true"/>
+  <dynamicField name="*_l1" type="long" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_t" type="text" indexed="true" stored="true"/>
+  <dynamicField name="*_b" type="boolean" indexed="true" stored="true"/>
+  <dynamicField name="*_f" type="float" indexed="true" stored="true"/>
+  <dynamicField name="*_f1" type="float" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_d" type="double" indexed="true" stored="true"/>
+  <dynamicField name="*_d1" type="double" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_dt" type="date" indexed="true" stored="true"/>
+  <dynamicField name="*_dt1" type="date" indexed="true" stored="true" multiValued="false"/>
+
+  <!-- some trie-coded dynamic fields for faster range queries -->
+  <dynamicField name="*_ti" type="tint" indexed="true" stored="true"/>
+  <dynamicField name="*_ti1" type="tint" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_tl" type="tlong" indexed="true" stored="true"/>
+  <dynamicField name="*_tl1" type="tlong" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_tf" type="tfloat" indexed="true" stored="true"/>
+  <dynamicField name="*_tf1" type="tfloat" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_td" type="tdouble" indexed="true" stored="true"/>
+  <dynamicField name="*_td1" type="tdouble" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_tds" type="tdouble" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_tdt" type="tdate" indexed="true" stored="true"/>
+  <dynamicField name="*_tdt1" type="tdate" indexed="true" stored="true" multiValued="false"/>
+
+
+  <dynamicField name="*_sI" type="string" indexed="true" stored="false"/>
+  <dynamicField name="*_sS" type="string" indexed="false" stored="true"/>
+  <dynamicField name="t_*" type="text" indexed="true" stored="true"/>
+  <dynamicField name="tv_*" type="text" indexed="true" stored="true"
+                termVectors="true" termPositions="true" termOffsets="true"/>
+  <dynamicField name="tv_mv_*" type="text" indexed="true" stored="true" multiValued="true"
+                termVectors="true" termPositions="true" termOffsets="true"/>
+
+  <dynamicField name="*_p" type="xyd" indexed="true" stored="true" multiValued="false"/>
+
+  <!-- special fields for dynamic copyField test -->
+  <dynamicField name="dynamic_*" type="string" indexed="true" stored="true"/>
+  <dynamicField name="*_dynamic" type="string" indexed="true" stored="true"/>
+
+  <!-- for testing to ensure that longer patterns are matched first -->
+  <dynamicField name="*aa" type="string" indexed="true" stored="true"/>
+
+  <!-- ignored becuase not stored or indexed -->
+  <dynamicField name="*_ignored" type="text" indexed="false" stored="false"/>
+
+  <dynamicField name="*_mfacet" type="string" indexed="true" stored="false" multiValued="true"/>
+
+  <!-- make sure custom sims work with dynamic fields -->
+  <!--
+  <dynamicField name="*_sim1" type="sim1" indexed="true" stored="true"/>
+  <dynamicField name="*_sim2" type="sim2" indexed="true" stored="true"/>
+  <dynamicField name="*_sim3" type="sim3" indexed="true" stored="true"/>
+  -->
 
   <defaultSearchField>text</defaultSearchField>
   <uniqueKey>id</uniqueKey>
@@ -590,9 +608,6 @@
   <copyField source="*_t" dest="text"/>
 
 
-
-
-
   <!-- dynamic destination -->
   <copyField source="*_dynamic" dest="dynamic_*"/>
 
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-stop-keep.xml b/solr/core/src/test-files/solr/collection1/conf/schema-stop-keep.xml
index db33137..b787c0c 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-stop-keep.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-stop-keep.xml
@@ -23,42 +23,37 @@
   -->
 
 <schema name="test" version="1.0">
-  <types>
 
+  <fieldType name="integer" class="solr.TrieIntField" precisionStep="0"/>
 
-    <fieldType name="integer" class="solr.TrieIntField" precisionStep="0"/>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+  <fieldType name="stop-one" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true"
+              words="stop-1.txt"/>
 
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
-    <fieldType name="stop-one" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true"
-                words="stop-1.txt"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="stop-two" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true"
+              words="stop-1.txt,stop-2.txt"/>
 
-      </analyzer>
-    </fieldType>
-    <fieldType name="stop-two" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true"
-                words="stop-1.txt,stop-2.txt"/>
+    </analyzer>
+  </fieldType>
 
-      </analyzer>
-    </fieldType>
- </types>
 
+  <field name="id" type="integer" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="one" type="stop-one" indexed="true" stored="false"/>
+  <field name="two" type="stop-two" indexed="true" stored="false"/>
 
- <fields>
-   <field name="id" type="integer" indexed="true" stored="true" multiValued="false" required="false"/>
-   <field name="one" type="stop-one" indexed="true" stored="false"/>
-   <field name="two" type="stop-two" indexed="true" stored="false"/>
 
- </fields>
-
- <defaultSearchField>one</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+  <defaultSearchField>one</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-sweetspot.xml b/solr/core/src/test-files/solr/collection1/conf/schema-sweetspot.xml
index 2f84725..a3933a9 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-sweetspot.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-sweetspot.xml
@@ -19,57 +19,52 @@
 <!-- Test schema file for SweetSpotSimilarityFactory -->
 
 <schema name="test" version="1.0">
-  <types>
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    
-    <!-- default parameters -->
-    <fieldType name="text" class="solr.TextField"
-               indexed="true" stored="false">
-      <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
-      <similarity class="solr.SweetSpotSimilarityFactory"/>
-    </fieldType>
-    
-    <!-- using baseline TF -->
-    <fieldType name="text_baseline" class="solr.TextField"
-               indexed="true" stored="false">
-      <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
-      <similarity class="solr.SweetSpotSimilarityFactory">
-        <!-- TF -->
-        <float name="baselineTfMin">6.0</float>
-        <float name="baselineTfBase">1.5</float>
-        <!-- plateau norm -->
-        <int name="lengthNormMin">3</int>
-        <int name="lengthNormMax">5</int>
-        <float name="lengthNormSteepness">0.5</float>
-      </similarity>
-    </fieldType>
-   
-    <!-- using hyperbolic TF -->
-    <fieldType name="text_hyperbolic" class="solr.TextField"
-               indexed="true" stored="false" >
-      <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
-      <similarity class="solr.SweetSpotSimilarityFactory">
-        <float name="hyperbolicTfMin">3.3</float>
-        <float name="hyperbolicTfMax">7.7</float>
-        <double name="hyperbolicTfBase">2.718281828459045</double> <!-- e -->
-        <float name="hyperbolicTfOffset">5.0</float>
-        <!-- plateau norm, shallower slope -->
-        <int name="lengthNormMin">1</int>
-        <int name="lengthNormMax">5</int>
-        <float name="lengthNormSteepness">0.2</float>
-      </similarity>
-    </fieldType>
-   
-  </types>
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
 
-  <fields>
-    <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
-    <field name="text"            type="text" />
-    <field name="text_baseline"   type="text_baseline" />
-    <field name="text_hyperbolic" type="text_hyperbolic" />
-  </fields>
+  <!-- default parameters -->
+  <fieldType name="text" class="solr.TextField"
+             indexed="true" stored="false">
+    <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
+    <similarity class="solr.SweetSpotSimilarityFactory"/>
+  </fieldType>
+
+  <!-- using baseline TF -->
+  <fieldType name="text_baseline" class="solr.TextField"
+             indexed="true" stored="false">
+    <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
+    <similarity class="solr.SweetSpotSimilarityFactory">
+      <!-- TF -->
+      <float name="baselineTfMin">6.0</float>
+      <float name="baselineTfBase">1.5</float>
+      <!-- plateau norm -->
+      <int name="lengthNormMin">3</int>
+      <int name="lengthNormMax">5</int>
+      <float name="lengthNormSteepness">0.5</float>
+    </similarity>
+  </fieldType>
+
+  <!-- using hyperbolic TF -->
+  <fieldType name="text_hyperbolic" class="solr.TextField"
+             indexed="true" stored="false">
+    <analyzer class="org.apache.lucene.analysis.standard.StandardAnalyzer"/>
+    <similarity class="solr.SweetSpotSimilarityFactory">
+      <float name="hyperbolicTfMin">3.3</float>
+      <float name="hyperbolicTfMax">7.7</float>
+      <double name="hyperbolicTfBase">2.718281828459045</double> <!-- e -->
+      <float name="hyperbolicTfOffset">5.0</float>
+      <!-- plateau norm, shallower slope -->
+      <int name="lengthNormMin">1</int>
+      <int name="lengthNormMax">5</int>
+      <float name="lengthNormSteepness">0.2</float>
+    </similarity>
+  </fieldType>
+
+  <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="text" type="text"/>
+  <field name="text_baseline" type="text_baseline"/>
+  <field name="text_hyperbolic" type="text_hyperbolic"/>
 
   <defaultSearchField>text</defaultSearchField>
   <uniqueKey>id</uniqueKey>
-  
+
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-synonym-tokenizer.xml b/solr/core/src/test-files/solr/collection1/conf/schema-synonym-tokenizer.xml
index 0906a13..b443138 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-synonym-tokenizer.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-synonym-tokenizer.xml
@@ -18,25 +18,22 @@
 <!-- Test schema file for SynonymFilterFactory argument "tokenizerFactory" -->
 
 <schema name="synonym-test" version="1.0">
-  <types>
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-
-    <fieldType name="text_synonyms" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="false" tokenizerFactory="solr.StandardTokenizerFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-
-  </types>
-
-  <fields>
-    <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
-    <field name="text" type="text_synonyms" indexed="true" stored="false"/>
-  </fields>
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+
+  <fieldType name="text_synonyms" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="false"
+              tokenizerFactory="solr.StandardTokenizerFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="text" type="text_synonyms" indexed="true" stored="false"/>
 
   <defaultSearchField>text</defaultSearchField>
   <uniqueKey>id</uniqueKey>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-tiny.xml b/solr/core/src/test-files/solr/collection1/conf/schema-tiny.xml
index c69418c..a0d5238 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-tiny.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-tiny.xml
@@ -26,12 +26,10 @@
 
   <uniqueKey>id</uniqueKey>
 
-  <types>
-    <fieldType name="text" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-  </types>
+  <fieldType name="text" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-trie.xml b/solr/core/src/test-files/solr/collection1/conf/schema-trie.xml
index bb2b354..1df0a0f 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-trie.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-trie.xml
@@ -37,277 +37,281 @@
        1.0: multiValued attribute did not exist, all fields are multiValued by nature
        1.1: multiValued attribute introduced, false by default -->
 
-  <types>
-    <!-- field type definitions. The "name" attribute is
-       just a label to be used by field definitions.  The "class"
-       attribute and any other attributes determine the real
-       behavior of the fieldType.
-         Class names starting with "solr" refer to java classes in the
-       org.apache.solr.analysis package.
+  <!-- field type definitions. The "name" attribute is
+     just a label to be used by field definitions.  The "class"
+     attribute and any other attributes determine the real
+     behavior of the fieldType.
+       Class names starting with "solr" refer to java classes in the
+     org.apache.solr.analysis package.
+  -->
+
+  <!-- The StrField type is not analyzed, but indexed/stored verbatim.
+     - StrField and TextField support an optional compressThreshold which
+     limits compression (if enabled in the derived fields) to values which
+     exceed a certain size (in characters).
+  -->
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true" omitNorms="true"/>
+
+  <!-- boolean type: "true" or "false" -->
+  <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true" omitNorms="true"/>
+
+  <!-- The optional sortMissingLast and sortMissingFirst attributes are
+       currently supported on types that are sorted internally as strings.
+     - If sortMissingLast="true", then a sort on this field will cause documents
+       without the field to come after documents with the field,
+       regardless of the requested sort order (asc or desc).
+     - If sortMissingFirst="true", then a sort on this field will cause documents
+       without the field to come before documents with the field,
+       regardless of the requested sort order.
+     - If sortMissingLast="false" and sortMissingFirst="false" (the default),
+       then default lucene sorting will be used which places docs without the
+       field first in an ascending sort and last in a descending sort.
+  -->
+
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+
+  <fieldType name="tint" class="solr.TrieIntField" omitNorms="true" positionIncrementGap="0" indexed="true"
+             stored="false"/>
+  <fieldType name="tfloat" class="solr.TrieFloatField" omitNorms="true" positionIncrementGap="0" indexed="true"
+             stored="false"/>
+  <fieldType name="tlong" class="solr.TrieLongField" omitNorms="true" positionIncrementGap="0" indexed="true"
+             stored="false"/>
+  <fieldType name="tdouble" class="solr.TrieDoubleField" omitNorms="true" positionIncrementGap="0" indexed="true"
+             stored="false"/>
+
+  <fieldType name="tdouble4" class="solr.TrieDoubleField" type="double" precisionStep="4" omitNorms="true"
+             positionIncrementGap="0" indexed="true" stored="false"/>
+
+  <fieldType name="tdate" class="solr.TrieDateField" omitNorms="true" positionIncrementGap="0" indexed="true"
+             stored="false"/>
+
+
+  <!-- The format for this date field is of the form 1995-12-31T23:59:59Z, and
+       is a more restricted form of the canonical representation of dateTime
+       http://www.w3.org/TR/xmlschema-2/#dateTime
+       The trailing "Z" designates UTC time and is mandatory.
+       Optional fractional seconds are allowed: 1995-12-31T23:59:59.999Z
+       All other components are mandatory.
+
+       Expressions can also be used to denote calculations that should be
+       performed relative to "NOW" to determine the value, ie...
+
+             NOW/HOUR
+                ... Round to the start of the current hour
+             NOW-1DAY
+                ... Exactly 1 day prior to now
+             NOW/DAY+6MONTHS+3DAYS
+                ... 6 months and 3 days in the future from the start of
+                    the current day
+
+       Consult the TrieDateField javadocs for more information.
     -->
+  <fieldType name="date" class="solr.TrieDateField" sortMissingLast="true" omitNorms="true"/>
+
+
+  <!-- The "RandomSortField" is not used to store or search any
+       data.  You can declare fields of this type it in your schema
+       to generate psuedo-random orderings of your docs for sorting
+       purposes.  The ordering is generated based on the field name
+       and the version of the index, As long as the index version
+       remains unchanged, and the same field name is reused,
+       the ordering of the docs will be consistent.
+       If you want differend psuedo-random orderings of documents,
+       for the same version of the index, use a dynamicField and
+       change the name
+   -->
+  <fieldType name="random" class="solr.RandomSortField" indexed="true"/>
 
-    <!-- The StrField type is not analyzed, but indexed/stored verbatim.
-       - StrField and TextField support an optional compressThreshold which
-       limits compression (if enabled in the derived fields) to values which
-       exceed a certain size (in characters).
-    -->
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true" omitNorms="true"/>
-
-    <!-- boolean type: "true" or "false" -->
-    <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true" omitNorms="true"/>
-
-    <!-- The optional sortMissingLast and sortMissingFirst attributes are
-         currently supported on types that are sorted internally as strings.
-       - If sortMissingLast="true", then a sort on this field will cause documents
-         without the field to come after documents with the field,
-         regardless of the requested sort order (asc or desc).
-       - If sortMissingFirst="true", then a sort on this field will cause documents
-         without the field to come before documents with the field,
-         regardless of the requested sort order.
-       - If sortMissingLast="false" and sortMissingFirst="false" (the default),
-         then default lucene sorting will be used which places docs without the
-         field first in an ascending sort and last in a descending sort.
-    -->
-
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-
-    <fieldType name="tint" class="solr.TrieIntField" omitNorms="true" positionIncrementGap="0" indexed="true" stored="false" />
-    <fieldType name="tfloat" class="solr.TrieFloatField" omitNorms="true" positionIncrementGap="0" indexed="true" stored="false" />
-    <fieldType name="tlong" class="solr.TrieLongField" omitNorms="true" positionIncrementGap="0" indexed="true" stored="false" />
-    <fieldType name="tdouble" class="solr.TrieDoubleField" omitNorms="true" positionIncrementGap="0" indexed="true" stored="false" />
-
-    <fieldType name="tdouble4" class="solr.TrieDoubleField" type="double" precisionStep="4" omitNorms="true" positionIncrementGap="0" indexed="true" stored="false" />
-
-    <fieldType name="tdate" class="solr.TrieDateField" omitNorms="true" positionIncrementGap="0" indexed="true" stored="false" />
-
-
-    <!-- The format for this date field is of the form 1995-12-31T23:59:59Z, and
-         is a more restricted form of the canonical representation of dateTime
-         http://www.w3.org/TR/xmlschema-2/#dateTime
-         The trailing "Z" designates UTC time and is mandatory.
-         Optional fractional seconds are allowed: 1995-12-31T23:59:59.999Z
-         All other components are mandatory.
+  <!-- solr.TextField allows the specification of custom text analyzers
+       specified as a tokenizer and a list of token filters. Different
+       analyzers may be specified for indexing and querying.
 
-         Expressions can also be used to denote calculations that should be
-         performed relative to "NOW" to determine the value, ie...
+       The optional positionIncrementGap puts space between multiple fields of
+       this type on the same document, with the purpose of preventing false phrase
+       matching across fields.
 
-               NOW/HOUR
-                  ... Round to the start of the current hour
-               NOW-1DAY
-                  ... Exactly 1 day prior to now
-               NOW/DAY+6MONTHS+3DAYS
-                  ... 6 months and 3 days in the future from the start of
-                      the current day
+       For more info on customizing your analyzer chain, please see
+       http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters
+   -->
 
-         Consult the TrieDateField javadocs for more information.
+  <!-- One can also specify an existing Analyzer class that has a
+       default constructor via the class attribute on the analyzer element
+  <fieldType name="text_greek" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.el.GreekAnalyzer"/>
+  </fieldType>
+  -->
+
+  <!-- A text field that only splits on whitespace for exact matching of words -->
+  <fieldType name="text_ws" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- A text field that uses WordDelimiterFilter to enable splitting and matching of
+      words on case-change, alpha numeric boundaries, and non-alphanumeric chars,
+      so that a query of "wifi" or "wi fi" could match a document containing "Wi-Fi".
+      Synonyms and stopwords are customized by external files, and stemming is enabled.
+      Duplicate tokens at the same position (which may result from Stemmed Synonyms or
+      WordDelim parts) are removed.
+      -->
+  <fieldType name="text" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <!-- in this example, we will only use synonyms at query time
+      <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
       -->
-    <fieldType name="date" class="solr.TrieDateField" sortMissingLast="true" omitNorms="true"/>
-
-
-    <!-- The "RandomSortField" is not used to store or search any
-         data.  You can declare fields of this type it in your schema
-         to generate psuedo-random orderings of your docs for sorting
-         purposes.  The ordering is generated based on the field name
-         and the version of the index, As long as the index version
-         remains unchanged, and the same field name is reused,
-         the ordering of the docs will be consistent.
-         If you want differend psuedo-random orderings of documents,
-         for the same version of the index, use a dynamicField and
-         change the name
-     -->
-    <fieldType name="random" class="solr.RandomSortField" indexed="true" />
-
-    <!-- solr.TextField allows the specification of custom text analyzers
-         specified as a tokenizer and a list of token filters. Different
-         analyzers may be specified for indexing and querying.
-
-         The optional positionIncrementGap puts space between multiple fields of
-         this type on the same document, with the purpose of preventing false phrase
-         matching across fields.
-
-         For more info on customizing your analyzer chain, please see
-         http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters
-     -->
-
-    <!-- One can also specify an existing Analyzer class that has a
-         default constructor via the class attribute on the analyzer element
-    <fieldType name="text_greek" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.el.GreekAnalyzer"/>
-    </fieldType>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <!-- Less flexible matching, but less false matches.  Probably not ideal for product names,
+       but may be good for SKUs.  Can insert dashes in the wrong place and still match. -->
+  <fieldType name="textTight" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="false"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.EnglishMinimalStemFilterFactory"/>
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- This is an example of using the KeywordTokenizer along
+       With various TokenFilterFactories to produce a sortable field
+       that does not include some properties of the source text
     -->
-
-    <!-- A text field that only splits on whitespace for exact matching of words -->
-    <fieldType name="text_ws" class="solr.TextField" positionIncrementGap="100">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- A text field that uses WordDelimiterFilter to enable splitting and matching of
-        words on case-change, alpha numeric boundaries, and non-alphanumeric chars,
-        so that a query of "wifi" or "wi fi" could match a document containing "Wi-Fi".
-        Synonyms and stopwords are customized by external files, and stemming is enabled.
-        Duplicate tokens at the same position (which may result from Stemmed Synonyms or
-        WordDelim parts) are removed.
+  <fieldType name="alphaOnlySort" class="solr.TextField" sortMissingLast="true" omitNorms="true">
+    <analyzer>
+      <!-- KeywordTokenizer does no actual tokenizing, so the entire
+           input string is preserved as a single token
         -->
-    <fieldType name="text" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <!-- in this example, we will only use synonyms at query time
-        <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+      <!-- The LowerCase TokenFilter does what you expect, which can be
+           when you want your sorting to be case insensitive
         -->
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <!-- Less flexible matching, but less false matches.  Probably not ideal for product names,
-         but may be good for SKUs.  Can insert dashes in the wrong place and still match. -->
-    <fieldType name="textTight" class="solr.TextField" positionIncrementGap="100" >
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="false"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.EnglishMinimalStemFilterFactory"/>
-        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- This is an example of using the KeywordTokenizer along
-         With various TokenFilterFactories to produce a sortable field
-         that does not include some properties of the source text
-      -->
-    <fieldType name="alphaOnlySort" class="solr.TextField" sortMissingLast="true" omitNorms="true">
-      <analyzer>
-        <!-- KeywordTokenizer does no actual tokenizing, so the entire
-             input string is preserved as a single token
-          -->
-        <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
-        <!-- The LowerCase TokenFilter does what you expect, which can be
-             when you want your sorting to be case insensitive
-          -->
-        <filter class="solr.LowerCaseFilterFactory" />
-        <!-- The TrimFilter removes any leading or trailing whitespace -->
-        <filter class="solr.TrimFilterFactory" />
-        <!-- The PatternReplaceFilter gives you the flexibility to use
-             Java Regular expression to replace any sequence of characters
-             matching a pattern with an arbitrary replacement string,
-             which may include back refrences to portions of the orriginal
-             string matched by the pattern.
-
-             See the Java Regular Expression documentation for more
-             infomation on pattern and replacement string syntax.
-
-             http://docs.oracle.com/javase/8/docs/api/java/util/regex/package-summary.html
-          -->
-        <filter class="solr.PatternReplaceFilterFactory"
-                pattern="([^a-z])" replacement="" replace="all"
-        />
-      </analyzer>
-    </fieldType>
-
-    <!-- since fields of this type are by default not stored or indexed, any data added to
-         them will be ignored outright
-     -->
-    <fieldType name="ignored" stored="false" indexed="false" class="solr.StrField" />
-
-    <fieldType name="file" keyField="id" defVal="1" stored="false" indexed="false" class="solr.ExternalFileField" valType="float"/>
-
-
- </types>
-
-
- <fields>
-   <!-- Valid attributes for fields:
-     name: mandatory - the name for the field
-     type: mandatory - the name of a previously defined type from the <types> section
-     indexed: true if this field should be indexed (searchable or sortable)
-     stored: true if this field should be retrievable
-     multiValued: true if this field may contain multiple values per document
-     omitNorms: (expert) set to true to omit the norms associated with
-       this field (this disables length normalization and index-time
-       boosting for the field, and saves some memory).  Only full-text
-       fields or fields that need an index-time boost need norms.
-     termVectors: [false] set to true to store the term vector for a given field.
-       When using MoreLikeThis, fields used for similarity should be stored for
-       best performance.
-   -->
-
-   <!-- for testing, a type that does a transform to see if it's correctly done everywhere -->
-   <field name="id" type="tfloat" indexed="true" stored="true" required="true" />
-   <field name="text" type="text" indexed="true" stored="false" />
-   <field name="signatureField" type="string" indexed="true" stored="false"/>
-
-   <field name="tint" type="tint" indexed="true" stored="true" />
-   <field name="tfloat" type="tfloat" indexed="true" stored="true" />
-   <field name="tlong" type="tlong" indexed="true" stored="true" />
-   <field name="tdouble" type="tdouble" indexed="true" stored="true" />
-
-   <field name="tdouble4" type="tdouble4" indexed="true" stored="false" />
-
-   <field name="tdate" type="tdate" indexed="true" stored="true" />
-
-   <field name="_version_" type="long" indexed="true" stored="true" multiValued="false" />
-
-   <!-- Dynamic field definitions.  If a field name is not found, dynamicFields
-        will be used if the name matches any of the patterns.
-        RESTRICTION: the glob-like pattern in the name attribute must have
-        a "*" only at the start or the end.
-        EXAMPLE:  name="*_i" will match any field ending in _i (like myid_i, z_i)
-        Longer patterns will be matched first.  if equal size patterns
-        both match, the first appearing in the schema will be used.  -->
-   <dynamicField name="*_s"  type="string"  indexed="true"  stored="true"/>
-   <dynamicField name="*_ss"  type="string"  indexed="true"  stored="true" multiValued="true"/>
-   <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
-   <dynamicField name="*_i"  type="tint"    indexed="true"  stored="true"/>
-   <dynamicField name="*_l"  type="tlong"   indexed="true"  stored="true"/>
-   <dynamicField name="*_f"  type="tfloat"  indexed="true"  stored="true"/>
-   <dynamicField name="*_d"  type="tdouble" indexed="true"  stored="true"/>
-
-   <dynamicField name="*_t"  type="text"    indexed="true"  stored="true"/>
-   <dynamicField name="*_b"  type="boolean" indexed="true"  stored="true"/>
-   <dynamicField name="*_dt" type="date"    indexed="true"  stored="true"/>
-   <dynamicField name="*_ws" type="text_ws" indexed="true"  stored="true"/>
-
-   <dynamicField name="*_extf" type="file"/>
-
-   <dynamicField name="*_random" type="random" />
-
-   <!-- uncomment the following to ignore any fields that don't already match an existing
-        field name or dynamic field, rather than reporting them as an error.
-        alternately, change the type="ignored" to some other type e.g. "text" if you want
-        unknown fields indexed and/or stored by default -->
-   <!--dynamicField name="*" type="ignored" /-->
-
- </fields>
-
- <!-- Field to use to determine and enforce document uniqueness.
-      Unless this field is marked with required="false", it will be a required field
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <!-- The TrimFilter removes any leading or trailing whitespace -->
+      <filter class="solr.TrimFilterFactory"/>
+      <!-- The PatternReplaceFilter gives you the flexibility to use
+           Java Regular expression to replace any sequence of characters
+           matching a pattern with an arbitrary replacement string,
+           which may include back refrences to portions of the orriginal
+           string matched by the pattern.
+
+           See the Java Regular Expression documentation for more
+           infomation on pattern and replacement string syntax.
+
+           http://docs.oracle.com/javase/8/docs/api/java/util/regex/package-summary.html
+        -->
+      <filter class="solr.PatternReplaceFilterFactory"
+              pattern="([^a-z])" replacement="" replace="all"
+      />
+    </analyzer>
+  </fieldType>
+
+  <!-- since fields of this type are by default not stored or indexed, any data added to
+       them will be ignored outright
    -->
- <uniqueKey>id</uniqueKey>
+  <fieldType name="ignored" stored="false" indexed="false" class="solr.StrField"/>
+
+  <fieldType name="file" keyField="id" defVal="1" stored="false" indexed="false" class="solr.ExternalFileField"
+             valType="float"/>
+
+
+  <!-- Valid attributes for fields:
+    name: mandatory - the name for the field
+    type: mandatory - the name of a previously defined type from the <fieldType>s
+    indexed: true if this field should be indexed (searchable or sortable)
+    stored: true if this field should be retrievable
+    multiValued: true if this field may contain multiple values per document
+    omitNorms: (expert) set to true to omit the norms associated with
+      this field (this disables length normalization and index-time
+      boosting for the field, and saves some memory).  Only full-text
+      fields or fields that need an index-time boost need norms.
+    termVectors: [false] set to true to store the term vector for a given field.
+      When using MoreLikeThis, fields used for similarity should be stored for
+      best performance.
+  -->
+
+  <!-- for testing, a type that does a transform to see if it's correctly done everywhere -->
+  <field name="id" type="tfloat" indexed="true" stored="true" required="true"/>
+  <field name="text" type="text" indexed="true" stored="false"/>
+  <field name="signatureField" type="string" indexed="true" stored="false"/>
+
+  <field name="tint" type="tint" indexed="true" stored="true"/>
+  <field name="tfloat" type="tfloat" indexed="true" stored="true"/>
+  <field name="tlong" type="tlong" indexed="true" stored="true"/>
+  <field name="tdouble" type="tdouble" indexed="true" stored="true"/>
+
+  <field name="tdouble4" type="tdouble4" indexed="true" stored="false"/>
+
+  <field name="tdate" type="tdate" indexed="true" stored="true"/>
+
+  <field name="_version_" type="long" indexed="true" stored="true" multiValued="false"/>
+
+  <!-- Dynamic field definitions.  If a field name is not found, dynamicFields
+       will be used if the name matches any of the patterns.
+       RESTRICTION: the glob-like pattern in the name attribute must have
+       a "*" only at the start or the end.
+       EXAMPLE:  name="*_i" will match any field ending in _i (like myid_i, z_i)
+       Longer patterns will be matched first.  if equal size patterns
+       both match, the first appearing in the schema will be used.  -->
+  <dynamicField name="*_s" type="string" indexed="true" stored="true"/>
+  <dynamicField name="*_ss" type="string" indexed="true" stored="true" multiValued="true"/>
+  <dynamicField name="*_sS" type="string" indexed="false" stored="true"/>
+  <dynamicField name="*_i" type="tint" indexed="true" stored="true"/>
+  <dynamicField name="*_l" type="tlong" indexed="true" stored="true"/>
+  <dynamicField name="*_f" type="tfloat" indexed="true" stored="true"/>
+  <dynamicField name="*_d" type="tdouble" indexed="true" stored="true"/>
+
+  <dynamicField name="*_t" type="text" indexed="true" stored="true"/>
+  <dynamicField name="*_b" type="boolean" indexed="true" stored="true"/>
+  <dynamicField name="*_dt" type="date" indexed="true" stored="true"/>
+  <dynamicField name="*_ws" type="text_ws" indexed="true" stored="true"/>
+
+  <dynamicField name="*_extf" type="file"/>
+
+  <dynamicField name="*_random" type="random"/>
+
+  <!-- uncomment the following to ignore any fields that don't already match an existing
+       field name or dynamic field, rather than reporting them as an error.
+       alternately, change the type="ignored" to some other type e.g. "text" if you want
+       unknown fields indexed and/or stored by default -->
+  <!--dynamicField name="*" type="ignored" /-->
+
+
+  <!-- Field to use to determine and enforce document uniqueness.
+       Unless this field is marked with required="false", it will be a required field
+    -->
+  <uniqueKey>id</uniqueKey>
 
- <!-- field for the QueryParser to use when an explicit fieldname is absent -->
- <defaultSearchField>text</defaultSearchField>
+  <!-- field for the QueryParser to use when an explicit fieldname is absent -->
+  <defaultSearchField>text</defaultSearchField>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-version-dv.xml b/solr/core/src/test-files/solr/collection1/conf/schema-version-dv.xml
index c8a2172..773136a 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-version-dv.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-version-dv.xml
@@ -16,22 +16,18 @@
  limitations under the License.
 -->
 <schema name="example" version="1.6">
-  <fields>
-    <field name="_version_" type="long" indexed="false" stored="true" docValues="true"/>
-    <field name="id" type="string" indexed="true" stored="true" required="true" multiValued="false"/>
-    <field name="text" type="text_general" indexed="true" stored="false" multiValued="true"/>
-    <field name="signatureField" type="string" indexed="true" stored="false"/>
-    <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
-  </fields>
+  <field name="_version_" type="long" indexed="false" stored="true" docValues="true"/>
+  <field name="id" type="string" indexed="true" stored="true" required="true" multiValued="false"/>
+  <field name="text" type="text_general" indexed="true" stored="false" multiValued="true"/>
+  <field name="signatureField" type="string" indexed="true" stored="false"/>
+  <dynamicField name="*_sS" type="string" indexed="false" stored="true"/>
   <uniqueKey>id</uniqueKey>
-  <types>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="text_general" class="solr.TextField" positionIncrementGap="100">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-  </types>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="text_general" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-version-indexed.xml b/solr/core/src/test-files/solr/collection1/conf/schema-version-indexed.xml
index 214b486..c77d9ec 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-version-indexed.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-version-indexed.xml
@@ -16,22 +16,18 @@
  limitations under the License.
 -->
 <schema name="example" version="1.6">
-  <fields>
-    <field name="_version_" type="long" indexed="true" stored="true"/>
-    <field name="id" type="string" indexed="true" stored="true" required="true" multiValued="false"/>
-    <field name="text" type="text_general" indexed="true" stored="false" multiValued="true"/>
-    <field name="signatureField" type="string" indexed="true" stored="false"/>
-    <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
-  </fields>
+  <field name="_version_" type="long" indexed="true" stored="true"/>
+  <field name="id" type="string" indexed="true" stored="true" required="true" multiValued="false"/>
+  <field name="text" type="text_general" indexed="true" stored="false" multiValued="true"/>
+  <field name="signatureField" type="string" indexed="true" stored="false"/>
+  <dynamicField name="*_sS" type="string" indexed="false" stored="true"/>
   <uniqueKey>id</uniqueKey>
-  <types>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="text_general" class="solr.TextField" positionIncrementGap="100">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-  </types>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="text_general" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-xinclude.xml b/solr/core/src/test-files/solr/collection1/conf/schema-xinclude.xml
index e8bb5be..39767ea 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-xinclude.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-xinclude.xml
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8" ?>
 <!DOCTYPE schema [
-        <!ENTITY schema_entity_include SYSTEM "schema-snippet-types.incl">
-]>
+    <!ENTITY schema_entity_include SYSTEM "schema-snippet-types.incl">
+    ]>
 <!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
@@ -19,12 +19,8 @@
  limitations under the License.
 -->
 <schema name="xinclude" version="1.6" xmlns:xi="http://www.w3.org/2001/XInclude">
- <types>
   <fieldType name="string" class="solr.StrField"/>
-  <xi:include href="schema-snippet-type.xml" />
+  <xi:include href="schema-snippet-type.xml"/>
   &schema_entity_include;
- </types>
- <fields>
-   <xi:include href="schema-snippet-field.xml" />
- </fields>
+  <xi:include href="schema-snippet-field.xml"/>
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema.xml b/solr/core/src/test-files/solr/collection1/conf/schema.xml
index 44b3d72..35de166 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema.xml
@@ -26,358 +26,384 @@
   -->
 
 <schema name="test" version="1.0">
-  <types>
-
-    <!-- field type definitions... note that the "name" attribute is
-         just a label to be used by field definitions.  The "class"
-         attribute and any other attributes determine the real type and
-         behavior of the fieldType.
-      -->
-
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-
-
-    <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
-
-    <!-- Field type demonstrating an Analyzer failure -->
-    <fieldType name="failtype1" class="solr.TextField">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- Demonstrating ignoreCaseChange -->
-    <fieldType name="wdf_nocase" class="solr.TextField">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-     <fieldType name="wdf_preserve" class="solr.TextField">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="1"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <!-- HighlitText optimizes storage for (long) columns which will be highlit -->
-    <fieldType name="highlittext" class="solr.TextField" compressThreshold="345" />
-
-    <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
-
-    <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
-         seconds part (.999) is optional.
-      -->
-    <fieldType name="date" class="solr.TrieDateField" precisionStep="0"/>
-    <fieldType name="tdate" class="solr.TrieDateField" precisionStep="6"/>
-    <fieldType name="tdatedv" class="solr.TrieDateField" precisionStep="6" docValues="true"/>
-
-    <fieldType name="dateRange" class="solr.DateRangeField" />
-    <fieldType name="location_rpt" class="solr.SpatialRecursivePrefixTreeFieldType"
-        geo="true" distErrPct="0.025" maxDistErr="0.001" distanceUnits="kilometers" />
-
-    <!-- solr.TextField allows the specification of custom
-         text analyzers specified as a tokenizer and a list
-         of token filters.
-      -->
-    <fieldType name="text" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldtype name="text_payload_tv" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-        <filter class="org.apache.lucene.analysis.payloads.TokenOffsetPayloadTokenFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-
-    <fieldType name="nametext" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.core.WhitespaceAnalyzer"/>
-    </fieldType>
-
-    <fieldType name="teststop" class="solr.TextField">
-      <analyzer type="index">
-        <tokenizer class="solr.LowerCaseTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-        <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.LowerCaseTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- fieldTypes in this section isolate tokenizers and tokenfilters for testing -->
-    <fieldType name="lowertok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.LowerCaseTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="keywordtok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/></analyzer>
-    </fieldType>
-    <fieldType name="standardtok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.StandardTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="lettertok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.LetterTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="whitetok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.MockTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="HTMLstandardtok" class="solr.TextField">
-      <analyzer>
+
+  <!-- field type definitions... note that the "name" attribute is
+       just a label to be used by field definitions.  The "class"
+       attribute and any other attributes determine the real type and
+       behavior of the fieldType.
+    -->
+
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+
+
+  <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+
+  <!-- Field type demonstrating an Analyzer failure -->
+  <fieldType name="failtype1" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0"
+              catenateNumbers="0" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Demonstrating ignoreCaseChange -->
+  <fieldType name="wdf_nocase" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="wdf_preserve" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <!-- HighlitText optimizes storage for (long) columns which will be highlit -->
+  <fieldType name="highlittext" class="solr.TextField" compressThreshold="345"/>
+
+  <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+
+  <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
+       seconds part (.999) is optional.
+    -->
+  <fieldType name="date" class="solr.TrieDateField" precisionStep="0"/>
+  <fieldType name="tdate" class="solr.TrieDateField" precisionStep="6"/>
+  <fieldType name="tdatedv" class="solr.TrieDateField" precisionStep="6" docValues="true"/>
+
+  <fieldType name="dateRange" class="solr.DateRangeField"/>
+  <fieldType name="location_rpt" class="solr.SpatialRecursivePrefixTreeFieldType"
+             geo="true" distErrPct="0.025" maxDistErr="0.001" distanceUnits="kilometers"/>
+
+  <!-- solr.TextField allows the specification of custom
+       text analyzers specified as a tokenizer and a list
+       of token filters.
+    -->
+  <fieldType name="text" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldtype name="text_payload_tv" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+      <filter class="org.apache.lucene.analysis.payloads.TokenOffsetPayloadTokenFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+
+  <fieldType name="nametext" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.core.WhitespaceAnalyzer"/>
+  </fieldType>
+
+  <fieldType name="teststop" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.LowerCaseTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+      <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.LowerCaseTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- fieldTypes in this section isolate tokenizers and tokenfilters for testing -->
+  <fieldType name="lowertok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LowerCaseTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="keywordtok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="standardtok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="lettertok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LetterTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="whitetok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="HTMLstandardtok" class="solr.TextField">
+    <analyzer>
       <charFilter class="solr.HTMLStripCharFilterFactory"/>
       <tokenizer class="solr.StandardTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="HTMLwhitetok" class="solr.TextField">
-      <analyzer>
+    </analyzer>
+  </fieldType>
+  <fieldType name="HTMLwhitetok" class="solr.TextField">
+    <analyzer>
       <charFilter class="solr.HTMLStripCharFilterFactory"/>
       <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="standardtokfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="standardfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="lowerfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="lowerpunctfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" expand="true"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="1" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="patternreplacefilt" class="solr.TextField">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
-        <filter class="solr.PatternReplaceFilterFactory"
-                pattern="([^a-zA-Z])" replacement="_" replace="all"
-        />
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="patterntok" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.PatternTokenizerFactory" pattern=","/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="porterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <!-- fieldType name="snowballfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.SnowballPorterFilterFactory"/>
-      </analyzer>
-    </fieldType -->
-    <fieldType name="engporterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="custengporterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="stopfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="custstopfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="lengthfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LengthFilterFactory" min="2" max="5"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="charfilthtmlmap" class="solr.TextField">
-      <analyzer>
-        <charFilter class="solr.HTMLStripCharFilterFactory"/>
-        <charFilter class="solr.MappingCharFilterFactory" mapping="mapping-ISOLatin1Accent.txt"/>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="subword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.StopFilterFactory"/>
-          <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.StopFilterFactory"/>
-          <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="numericsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-          <filter class="solr.StopFilterFactory"/>
-          <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.StopFilterFactory"/>
-          <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="protectedsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <!-- more flexible in matching skus, but more chance of a false match -->
-    <fieldType name="skutype1" class="solr.TextField">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- less flexible in matching skus, but less chance of a false match -->
-    <fieldType name="skutype2" class="solr.TextField">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- less flexible in matching skus, but less chance of a false match -->
-    <fieldType name="syn" class="solr.TextField">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.SynonymFilterFactory" synonyms="old_synonyms.txt"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- Demonstrates How RemoveDuplicatesTokenFilter makes stemmed
-         synonyms "better"
-      -->
-    <fieldType name="dedup" class="solr.TextField">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.SynonymFilterFactory"
-                  synonyms="old_synonyms.txt" expand="true" />
-          <filter class="solr.PorterStemFilterFactory"/>
-          <filter class="solr.RemoveDuplicatesTokenFilterFactory" />
-      </analyzer>
-    </fieldType>
-
-    <fieldType  name="unstored" class="solr.StrField" indexed="true" stored="false"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="standardtokfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="standardfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="lowerfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="lowerpunctfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" expand="true"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="1" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="patternreplacefilt" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+      <filter class="solr.PatternReplaceFilterFactory"
+              pattern="([^a-zA-Z])" replacement="_" replace="all"
+      />
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="patterntok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.PatternTokenizerFactory" pattern=","/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="porterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <!-- fieldType name="snowballfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SnowballPorterFilterFactory"/>
+    </analyzer>
+  </fieldType -->
+  <fieldType name="engporterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="custengporterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="stopfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="custstopfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="lengthfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LengthFilterFactory" min="2" max="5"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="charfilthtmlmap" class="solr.TextField">
+    <analyzer>
+      <charFilter class="solr.HTMLStripCharFilterFactory"/>
+      <charFilter class="solr.MappingCharFilterFactory" mapping="mapping-ISOLatin1Accent.txt"/>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="subword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="numericsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0"
+              splitOnCaseChange="0" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0"
+              catenateAll="0"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0"
+              splitOnCaseChange="0" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1"
+              catenateAll="0"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="protectedsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0"
+              splitOnCaseChange="0" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0"
+              catenateAll="0"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <!-- more flexible in matching skus, but more chance of a false match -->
+  <fieldType name="skutype1" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- less flexible in matching skus, but less chance of a false match -->
+  <fieldType name="skutype2" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- less flexible in matching skus, but less chance of a false match -->
+  <fieldType name="syn" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="old_synonyms.txt"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Demonstrates How RemoveDuplicatesTokenFilter makes stemmed
+       synonyms "better"
+    -->
+  <fieldType name="dedup" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory"
+              synonyms="old_synonyms.txt" expand="true"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="unstored" class="solr.StrField" indexed="true" stored="false"/>
 
 
   <fieldType name="textgap" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
   </fieldType>
 
-  <fieldType name="uuid" class="solr.UUIDField" />
+  <fieldType name="uuid" class="solr.UUIDField"/>
 
-    <!-- Try out some point types -->
+  <!-- Try out some point types -->
   <fieldType name="xy" class="solr.PointType" dimension="2" subFieldType="double"/>
   <fieldType name="x" class="solr.PointType" dimension="1" subFieldType="double"/>
   <fieldType name="tenD" class="solr.PointType" dimension="10" subFieldType="double"/>
-    <!-- Use the sub field suffix -->
+  <!-- Use the sub field suffix -->
   <fieldType name="xyd" class="solr.PointType" dimension="2" subFieldSuffix="_d1"/>
-    <fieldType name="geohash" class="solr.GeoHashField"/>
+  <fieldType name="geohash" class="solr.GeoHashField"/>
 
 
   <fieldType name="latLon" class="solr.LatLonType" subFieldType="double"/>
 
   <!-- Currency type -->
-  <fieldType name="currency" class="solr.CurrencyField" currencyConfig="currency.xml" multiValued="false" />
-  <fieldType name="mock_currency" class="solr.CurrencyField" providerClass="solr.MockExchangeRateProvider" foo="bar" multiValued="false" />
-  <fieldType name="oer_currency" 
-             class="solr.CurrencyField" 
+  <fieldType name="currency" class="solr.CurrencyField" currencyConfig="currency.xml" multiValued="false"/>
+  <fieldType name="mock_currency" class="solr.CurrencyField" providerClass="solr.MockExchangeRateProvider" foo="bar"
+             multiValued="false"/>
+  <fieldType name="oer_currency"
+             class="solr.CurrencyField"
              multiValued="false"
              providerClass="solr.OpenExchangeRatesOrgProvider"
-             ratesFileLocation="open-exchange-rates.json" />
+             ratesFileLocation="open-exchange-rates.json"/>
 
   <!-- omitPositions example -->
   <fieldType name="nopositions" class="solr.TextField" omitPositions="true">
@@ -385,19 +411,19 @@
       <tokenizer class="solr.MockTokenizerFactory"/>
     </analyzer>
   </fieldType>
-  
+
   <fieldType name="location" class="solr.LatLonType" subFieldSuffix="_coordinate"/>
-  
+
   <!-- 
     Example of using PathHierarchyTokenizerFactory at index time, so
     queries for paths match documents at that path, or in descendent paths
   -->
   <fieldType name="path" class="solr.TextField">
     <analyzer type="index">
-      <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
+      <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/"/>
     </analyzer>
     <analyzer type="query">
-      <tokenizer class="solr.KeywordTokenizerFactory" />
+      <tokenizer class="solr.KeywordTokenizerFactory"/>
     </analyzer>
   </fieldType>
   <!-- 
@@ -406,309 +432,313 @@
   -->
   <fieldType name="ancestor_path" class="solr.TextField">
     <analyzer type="index">
-      <tokenizer class="solr.KeywordTokenizerFactory" />
+      <tokenizer class="solr.KeywordTokenizerFactory"/>
     </analyzer>
     <analyzer type="query">
-      <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
+      <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/"/>
     </analyzer>
   </fieldType>
 
   <fieldType name="payloadDelimited" class="solr.TextField">
     <analyzer type="index">
-      <tokenizer class="solr.WhitespaceTokenizerFactory" />
-      <filter class="solr.DelimitedPayloadTokenFilterFactory" encoder="integer" />
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.DelimitedPayloadTokenFilterFactory" encoder="integer"/>
     </analyzer>
     <analyzer type="query">
-      <tokenizer class="solr.WhitespaceTokenizerFactory" />
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
     </analyzer>
   </fieldType>
   <fieldType name="severityType" class="solr.EnumField" enumsConfig="enumsConfig.xml" enumName="severity"/>
 
-</types>
-
-
- <fields>
-   <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
-   <field name="_root_" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
-
-   <field name="signatureField" type="string" indexed="true" stored="false"/>
-   <field name="uuid" type="uuid" stored="true" />
-   <field name="name" type="nametext" indexed="true" stored="true"/>
-   <field name="text" type="text" indexed="true" stored="false"/>
-   <field name="subject" type="text" indexed="true" stored="true"/>
-   <field name="title" type="nametext" indexed="true" stored="true"/>
-   <field name="weight" type="float" indexed="true" stored="true" multiValued="false"/>
-   <field name="bday" type="date" indexed="true" stored="true" multiValued="false"/>
-
-   <field name="title_stemmed" type="text" indexed="true" stored="false"/>
-   <field name="title_lettertok" type="lettertok" indexed="true" stored="false"/>
-
-   <field name="syn" type="syn" indexed="true" stored="true"/>
-
-   <!-- to test property inheritance and overriding -->
-   <field name="shouldbeunstored" type="unstored" />
-   <field name="shouldbestored" type="unstored" stored="true"/>
-   <field name="shouldbeunindexed" type="unstored" indexed="false" stored="true"/>
-
-   <!-- Test points -->
-      <!-- Test points -->
-   <field name="home" type="xy" indexed="true" stored="true" multiValued="false"/>
-   <field name="x" type="x" indexed="true" stored="true" multiValued="false"/>
-   <field name="homed" type="xyd" indexed="true" stored="true" multiValued="false"/>
-   <field name="home_ns" type="xy" indexed="true" stored="false" multiValued="false"/>
-   <field name="work" type="xy" indexed="true" stored="true" multiValued="false"/>
-
-   <field name="home_ll" type="latLon" indexed="true" stored="true" multiValued="false"/>
-   <field name="work_ll" type="latLon" indexed="true" stored="true" multiValued="false"/>
-   
-   <field name="home_gh" type="geohash" indexed="true" stored="true" multiValued="false"/>
-
-
-   <field name="point10" type="tenD" indexed="true" stored="true" multiValued="false"/>
-
-   <!-- Test currency -->
-   <field name="amount" type="currency" indexed="true" stored="true" multiValued="false"/>
-   <field name="mock_amount" type="mock_currency" indexed="true" stored="true"/>
-   <field name="oer_amount" type="oer_currency" indexed="true" stored="true"/>
-
-   <!-- test different combinations of indexed and stored -->
-   <field name="bind" type="boolean" indexed="true" stored="false"/>
-   <field name="bsto" type="boolean" indexed="false" stored="true"/>
-   <field name="bindsto" type="boolean" indexed="true" stored="true"/>
-   <field name="isto" type="int" indexed="false" stored="true"/>
-   <field name="iind" type="int" indexed="true" stored="false"/>
-   <field name="ssto" type="string" indexed="false" stored="true"/>
-   <field name="sind" type="string" indexed="true" stored="false"/>
-   <field name="sindsto" type="string" indexed="true" stored="true"/>
-
-   <!-- test combinations of term vector settings -->
-   <field name="test_basictv" type="text" termVectors="true"/>
-   <field name="test_notv" type="text" termVectors="false"/>
-   <field name="test_postv" type="text" termVectors="true" termPositions="true"/>
-   <field name="test_offtv" type="text" termVectors="true" termOffsets="true"/>
-   <field name="test_posofftv" type="text" termVectors="true"
-     termPositions="true" termOffsets="true"/>
-   <field name="test_posoffpaytv" type="text_payload_tv" termVectors="true" 
-     termPositions="true" termOffsets="true" termPayloads="true"/>
-
-   <!-- test highlit field settings -->
-   <field name="test_hlt" type="highlittext" indexed="true"/>
-   <field name="test_hlt_off" type="highlittext" indexed="true"/>
-
-   <!-- fields to test individual tokenizers and tokenfilters -->
-   <field name="teststop" type="teststop" indexed="true" stored="true"/>
-   <field name="lowertok" type="lowertok" indexed="true" stored="true"/>
-   <field name="keywordtok" type="keywordtok" indexed="true" stored="true"/>
-   <field name="standardtok" type="standardtok" indexed="true" stored="true"/>
-   <field name="HTMLstandardtok" type="HTMLstandardtok" indexed="true" stored="true"/>
-   <field name="lettertok" type="lettertok" indexed="true" stored="true"/>
-   <field name="whitetok" type="whitetok" indexed="true" stored="true"/>
-   <field name="HTMLwhitetok" type="HTMLwhitetok" indexed="true" stored="true"/>
-   <field name="standardtokfilt" type="standardtokfilt" indexed="true" stored="true"/>
-   <field name="standardfilt" type="standardfilt" indexed="true" stored="true"/>
-   <field name="lowerfilt" type="lowerfilt" indexed="true" stored="true"/>
-   <field name="lowerfilt1" type="lowerfilt" indexed="true" stored="true"/>
-   <field name="lowerfilt1and2" type="lowerfilt" indexed="true" stored="true"/>
-   <field name="patterntok" type="patterntok" indexed="true" stored="true"/>
-   <field name="patternreplacefilt" type="patternreplacefilt" indexed="true" stored="true"/>
-   <field name="porterfilt" type="porterfilt" indexed="true" stored="true"/>
-   <field name="engporterfilt" type="engporterfilt" indexed="true" stored="true"/>
-   <field name="custengporterfilt" type="custengporterfilt" indexed="true" stored="true"/>
-   <field name="stopfilt" type="stopfilt" indexed="true" stored="true"/>
-   <field name="custstopfilt" type="custstopfilt" indexed="true" stored="true"/>
-   <field name="lengthfilt" type="lengthfilt" indexed="true" stored="true"/>
-   <field name="dedup" type="dedup" indexed="true" stored="true"/>
-   <field name="wdf_nocase" type="wdf_nocase" indexed="true" stored="true"/>
-   <field name="wdf_preserve" type="wdf_preserve" indexed="true" stored="true"/>
-
-   <field name="numberpartfail" type="failtype1" indexed="true" stored="true"/>
-
-   <field name="nullfirst" type="string" indexed="true" stored="true" sortMissingFirst="true" multiValued="false"/>
-
-   <field name="dateRange" type="dateRange" multiValued="true" />
-
-   <field name="cat" type="string" indexed="true" stored="true" multiValued="true"/>
-   <field name="price"  type="float" indexed="true" stored="true" multiValued="false"/>
-   <field name="inStock" type="boolean" indexed="true" stored="true" />
-
-   <field name="subword" type="subword" indexed="true" stored="true"/>
-   <field name="subword_offsets" type="subword" indexed="true" stored="true" termVectors="true" termOffsets="true"/>
-   <field name="numericsubword" type="numericsubword" indexed="true" stored="true"/>
-   <field name="protectedsubword" type="protectedsubword" indexed="true" stored="true"/>
-
-   <field name="sku1" type="skutype1" indexed="true" stored="true"/>
-   <field name="sku2" type="skutype2" indexed="true" stored="true"/>
-
-   <field name="textgap" type="textgap" indexed="true" stored="true"/>
-
-   <field name="timestamp" type="date" indexed="true" stored="true" docValues="true" default="NOW" multiValued="false"/>
-   <field name="multiDefault" type="string" indexed="true" stored="true" default="muLti-Default" multiValued="true"/>
-   <field name="intDefault" type="int" indexed="true" stored="true" default="42" multiValued="false"/>
-   <field name="intRemove" type="int" indexed="true" stored="true" multiValued="true"/>
-   <field name="dateRemove" type="date" indexed="true" stored="true" multiValued="true"/>
-   <field name="floatRemove" type="float" indexed="true" stored="true" multiValued="true"/>
-
-   <field name="nopositionstext" type="nopositions" indexed="true" stored="true"/>
-
-   <field name="tlong" type="tlong" indexed="true" stored="true" />
-   
-   <field name="_version_" type="long" indexed="true" stored="true" multiValued="false"/>
-   
-   <field name="title_stringNoNorms" type="string" omitNorms="true" indexed="true" stored="true"/>
-   
-   <field name="store" type="location" indexed="true" stored="true" omitNorms="false"/>
-
-   <field name="lower" type="lowertok" indexed="false" stored="true" multiValued="true" />
-   <field name="_route_" type="string" indexed="true" stored="true" multiValued="false" />
-
-   <field name="payloadDelimited" type="payloadDelimited" />
-
-   <!-- EnumType -->
-   <field name="severity" type="severityType" indexed="true" stored="true" multiValued="false"/>
-
-
-   <!-- Dynamic field definitions.  If a field name is not found, dynamicFields
-        will be used if the name matches any of the patterns.
-        RESTRICTION: the glob-like pattern in the name attribute must have
-        a "*" only at the start or the end.
-        EXAMPLE:  name="*_i" will match any field ending in _i (like myid_i, z_i)
-        Longer patterns will be matched first.  if equal size patterns
-        both match, the first appearing in the schema will be used.
-   -->
-   <dynamicField name="*_i"  type="int"    indexed="true"  stored="true"/>
-   <dynamicField name="*_i1"  type="int"    indexed="true" stored="true" multiValued="false" sortMissingLast="true"/>
-   <dynamicField name="*_idv"  type="int"    indexed="true"  stored="true" docValues="true" multiValued="false" />
-
-                 
-   <dynamicField name="*_s"  type="string"  indexed="true"  stored="true"/>
-   <dynamicField name="*_s1"  type="string"  indexed="true"  stored="true" multiValued="false"/>
-   <dynamicField name="*_l"  type="long"   indexed="true"  stored="true"/>
-   <dynamicField name="*_l1"  type="long"   indexed="true"  stored="true" multiValued="false"/>
-   <dynamicField name="*_t"  type="text"    indexed="true"  stored="true"/>
-   <dynamicField name="*_b"  type="boolean" indexed="true"  stored="true"/>
-   <dynamicField name="*_b1" type="boolean" indexed="true"  stored="true" multiValued="false"/>
-   <dynamicField name="*_f"  type="float"  indexed="true"  stored="true"/>
-   <dynamicField name="*_f1"  type="float"  indexed="true"  stored="true" multiValued="false"/>
-   <dynamicField name="*_d"  type="double" indexed="true"  stored="true"/>
-   <dynamicField name="*_d1"  type="double" indexed="true"  stored="true" multiValued="false"/>
-   <dynamicField name="*_dt" type="date"    indexed="true"  stored="true"/>
-   <dynamicField name="*_dt1" type="date"    indexed="true"  stored="true" multiValued="false"/>
-
-
-      <!-- some trie-coded dynamic fields for faster range queries -->
-   <dynamicField name="*_ti" type="tint"    indexed="true"  stored="true"/>
-   <dynamicField name="*_ti1" type="tint"    indexed="true"  stored="true" multiValued="false"/>
-   <dynamicField name="*_tl" type="tlong"   indexed="true"  stored="true"/>
-   <dynamicField name="*_tl1" type="tlong"   indexed="true"  stored="true" multiValued="false"/>
-   <dynamicField name="*_tf" type="tfloat"  indexed="true"  stored="true"/>
-   <dynamicField name="*_tf1" type="tfloat"  indexed="true"  stored="true" multiValued="false"/>
-   <dynamicField name="*_td" type="tdouble" indexed="true"  stored="true"/>
-   <dynamicField name="*_td1" type="tdouble" indexed="true" stored="true" multiValued="false"/>
-   <dynamicField name="*_tds" type="tdouble" indexed="true" stored="true" multiValued="false"/>
-   <dynamicField name="*_tdt" type="tdate"  indexed="true"  stored="true"/>
-   <dynamicField name="*_tdt1" type="tdate"  indexed="true"  stored="true" multiValued="false"/>
-   <dynamicField name="*_tdtdv" type="tdatedv"  indexed="true"  stored="true"/>
-   <dynamicField name="*_tdtdv1" type="tdatedv"  indexed="true"  stored="true" multiValued="false"/>
-   <dynamicField name="*_drf" type="dateRange"  indexed="true"  stored="true"/>
-
-   <dynamicField name="*_tdts" type="tdate"    indexed="true"  stored="true" multiValued="true"/>
-   <dynamicField name="*_tdtdvs" type="tdatedv"  indexed="true"  stored="true"/>
-
-   <dynamicField name="*_sI" type="string"  indexed="true"  stored="false"/>
-   <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
-   <dynamicField name="t_*"  type="text"    indexed="true"  stored="true"/>
-   <dynamicField name="tv_*"  type="text" indexed="true"  stored="true"
-      termVectors="true" termPositions="true" termOffsets="true"/>
-   <dynamicField name="tv_mv_*"  type="text" indexed="true"  stored="true" multiValued="true"
-      termVectors="true" termPositions="true" termOffsets="true"/>
-   <dynamicField name="tv_no_off_*" type="text" indexed="true" stored="true"
-      termVectors="true" termPositions="true"/>
-
-   <dynamicField name="*_p"  type="xyd" indexed="true"  stored="true" multiValued="false"/>
-
-   <!-- special fields for dynamic copyField test -->
-   <dynamicField name="dynamic_*" type="string" indexed="true" stored="true"/>
-   <dynamicField name="*_dynamic" type="string" indexed="true" stored="true"/>
-
-   <!-- for testing to ensure that longer patterns are matched first -->
-   <dynamicField name="*aa"  type="string"  indexed="true" stored="true"/>
-   <dynamicField name="*aaa" type="int" indexed="false" stored="true"/>
-
-   <!-- ignored becuase not stored or indexed -->
-   <dynamicField name="*_ignored" type="text" indexed="false" stored="false"/>
-
-   <dynamicField name="*_mfacet" type="string" indexed="true" stored="false" multiValued="true" />
-
-   <!-- Type used to index the lat and lon components for the "location" FieldType -->
-   <dynamicField name="*_coordinate"  type="tdouble" indexed="true"  stored="false" omitNorms="true" />
-
-   <dynamicField name="*_path"  type="path" indexed="true" stored="true" omitNorms="true" multiValued="true" />
-   <dynamicField name="*_ancestor"  type="ancestor_path" indexed="true" stored="true" omitNorms="true" multiValued="true" />
-
-   <dynamicField name="*_sev_enum" type="severityType" indexed="true" stored="true" docValues="true" multiValued="true" />
-   
-   <!-- With DocValues=true -->
-   <dynamicField name="*_i_dv"  type="int"    indexed="true"  stored="true" docValues="true" />
-   <dynamicField name="*_l_dv"  type="long"    indexed="true"  stored="true" docValues="true" />
-   <dynamicField name="*_f_dv"  type="float"    indexed="true"  stored="true" docValues="true" />
-   <dynamicField name="*_d_dv"  type="double"    indexed="true"  stored="true" docValues="true" />
-   <dynamicField name="*_dt_dv"  type="date"    indexed="true"  stored="true" docValues="true" />
-   <dynamicField name="*_f1_dv"  type="float"    indexed="true"  stored="true" docValues="true" multiValued="false" />
-
-   <!--  Non-stored, DocValues=true -->
-   <dynamicField name="*_i_dvo" multiValued="false" type="int"    docValues="true" indexed="true" stored="false" useDocValuesAsStored="true" />
-   <dynamicField name="*_d_dvo" multiValued="false" type="double" docValues="true" indexed="true" stored="false" useDocValuesAsStored="true" />
-   <dynamicField name="*_s_dvo" multiValued="false" type="string" docValues="true" indexed="true" stored="false" useDocValuesAsStored="true" />
-   <dynamicField name="*_ii_dvo" multiValued="true" type="int"    docValues="true" indexed="true" stored="false" useDocValuesAsStored="true" />
-   <dynamicField name="*_dd_dvo" multiValued="true" type="double" docValues="true" indexed="true" stored="false" useDocValuesAsStored="true" />
-
-   <!--  Non-stored, DocValues=true, useDocValuesAsStored=false -->
-   <field name="single_i_dvn" multiValued="false" type="int"    indexed="true" stored="true" />
-   <field name="single_d_dvn" multiValued="false" type="double" indexed="true" stored="true" />
-   <field name="single_s_dvn" multiValued="false" type="string" indexed="true" stored="true" />
-   <field name="copy_single_i_dvn" multiValued="false" type="int"    docValues="true" indexed="true" stored="false" useDocValuesAsStored="false" />
-   <field name="copy_single_d_dvn" multiValued="false" type="double" docValues="true" indexed="true" stored="false" useDocValuesAsStored="false" />
-   <field name="copy_single_s_dvn" multiValued="false" type="string" docValues="true" indexed="true" stored="false" useDocValuesAsStored="false" />
-   <copyField source="single_i_dvn" dest="copy_single_i_dvn" />
-   <copyField source="single_d_dvn" dest="copy_single_d_dvn" />
-   <copyField source="single_s_dvn" dest="copy_single_s_dvn" />
- </fields>
-
- <defaultSearchField>text</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+  <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="_root_" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
+
+  <field name="signatureField" type="string" indexed="true" stored="false"/>
+  <field name="uuid" type="uuid" stored="true"/>
+  <field name="name" type="nametext" indexed="true" stored="true"/>
+  <field name="text" type="text" indexed="true" stored="false"/>
+  <field name="subject" type="text" indexed="true" stored="true"/>
+  <field name="title" type="nametext" indexed="true" stored="true"/>
+  <field name="weight" type="float" indexed="true" stored="true" multiValued="false"/>
+  <field name="bday" type="date" indexed="true" stored="true" multiValued="false"/>
+
+  <field name="title_stemmed" type="text" indexed="true" stored="false"/>
+  <field name="title_lettertok" type="lettertok" indexed="true" stored="false"/>
+
+  <field name="syn" type="syn" indexed="true" stored="true"/>
+
+  <!-- to test property inheritance and overriding -->
+  <field name="shouldbeunstored" type="unstored"/>
+  <field name="shouldbestored" type="unstored" stored="true"/>
+  <field name="shouldbeunindexed" type="unstored" indexed="false" stored="true"/>
+
+  <!-- Test points -->
+  <!-- Test points -->
+  <field name="home" type="xy" indexed="true" stored="true" multiValued="false"/>
+  <field name="x" type="x" indexed="true" stored="true" multiValued="false"/>
+  <field name="homed" type="xyd" indexed="true" stored="true" multiValued="false"/>
+  <field name="home_ns" type="xy" indexed="true" stored="false" multiValued="false"/>
+  <field name="work" type="xy" indexed="true" stored="true" multiValued="false"/>
+
+  <field name="home_ll" type="latLon" indexed="true" stored="true" multiValued="false"/>
+  <field name="work_ll" type="latLon" indexed="true" stored="true" multiValued="false"/>
+
+  <field name="home_gh" type="geohash" indexed="true" stored="true" multiValued="false"/>
+
+
+  <field name="point10" type="tenD" indexed="true" stored="true" multiValued="false"/>
+
+  <!-- Test currency -->
+  <field name="amount" type="currency" indexed="true" stored="true" multiValued="false"/>
+  <field name="mock_amount" type="mock_currency" indexed="true" stored="true"/>
+  <field name="oer_amount" type="oer_currency" indexed="true" stored="true"/>
+
+  <!-- test different combinations of indexed and stored -->
+  <field name="bind" type="boolean" indexed="true" stored="false"/>
+  <field name="bsto" type="boolean" indexed="false" stored="true"/>
+  <field name="bindsto" type="boolean" indexed="true" stored="true"/>
+  <field name="isto" type="int" indexed="false" stored="true"/>
+  <field name="iind" type="int" indexed="true" stored="false"/>
+  <field name="ssto" type="string" indexed="false" stored="true"/>
+  <field name="sind" type="string" indexed="true" stored="false"/>
+  <field name="sindsto" type="string" indexed="true" stored="true"/>
+
+  <!-- test combinations of term vector settings -->
+  <field name="test_basictv" type="text" termVectors="true"/>
+  <field name="test_notv" type="text" termVectors="false"/>
+  <field name="test_postv" type="text" termVectors="true" termPositions="true"/>
+  <field name="test_offtv" type="text" termVectors="true" termOffsets="true"/>
+  <field name="test_posofftv" type="text" termVectors="true"
+         termPositions="true" termOffsets="true"/>
+  <field name="test_posoffpaytv" type="text_payload_tv" termVectors="true"
+         termPositions="true" termOffsets="true" termPayloads="true"/>
+
+  <!-- test highlit field settings -->
+  <field name="test_hlt" type="highlittext" indexed="true"/>
+  <field name="test_hlt_off" type="highlittext" indexed="true"/>
+
+  <!-- fields to test individual tokenizers and tokenfilters -->
+  <field name="teststop" type="teststop" indexed="true" stored="true"/>
+  <field name="lowertok" type="lowertok" indexed="true" stored="true"/>
+  <field name="keywordtok" type="keywordtok" indexed="true" stored="true"/>
+  <field name="standardtok" type="standardtok" indexed="true" stored="true"/>
+  <field name="HTMLstandardtok" type="HTMLstandardtok" indexed="true" stored="true"/>
+  <field name="lettertok" type="lettertok" indexed="true" stored="true"/>
+  <field name="whitetok" type="whitetok" indexed="true" stored="true"/>
+  <field name="HTMLwhitetok" type="HTMLwhitetok" indexed="true" stored="true"/>
+  <field name="standardtokfilt" type="standardtokfilt" indexed="true" stored="true"/>
+  <field name="standardfilt" type="standardfilt" indexed="true" stored="true"/>
+  <field name="lowerfilt" type="lowerfilt" indexed="true" stored="true"/>
+  <field name="lowerfilt1" type="lowerfilt" indexed="true" stored="true"/>
+  <field name="lowerfilt1and2" type="lowerfilt" indexed="true" stored="true"/>
+  <field name="patterntok" type="patterntok" indexed="true" stored="true"/>
+  <field name="patternreplacefilt" type="patternreplacefilt" indexed="true" stored="true"/>
+  <field name="porterfilt" type="porterfilt" indexed="true" stored="true"/>
+  <field name="engporterfilt" type="engporterfilt" indexed="true" stored="true"/>
+  <field name="custengporterfilt" type="custengporterfilt" indexed="true" stored="true"/>
+  <field name="stopfilt" type="stopfilt" indexed="true" stored="true"/>
+  <field name="custstopfilt" type="custstopfilt" indexed="true" stored="true"/>
+  <field name="lengthfilt" type="lengthfilt" indexed="true" stored="true"/>
+  <field name="dedup" type="dedup" indexed="true" stored="true"/>
+  <field name="wdf_nocase" type="wdf_nocase" indexed="true" stored="true"/>
+  <field name="wdf_preserve" type="wdf_preserve" indexed="true" stored="true"/>
+
+  <field name="numberpartfail" type="failtype1" indexed="true" stored="true"/>
+
+  <field name="nullfirst" type="string" indexed="true" stored="true" sortMissingFirst="true" multiValued="false"/>
+
+  <field name="dateRange" type="dateRange" multiValued="true"/>
+
+  <field name="cat" type="string" indexed="true" stored="true" multiValued="true"/>
+  <field name="price" type="float" indexed="true" stored="true" multiValued="false"/>
+  <field name="inStock" type="boolean" indexed="true" stored="true"/>
+
+  <field name="subword" type="subword" indexed="true" stored="true"/>
+  <field name="subword_offsets" type="subword" indexed="true" stored="true" termVectors="true" termOffsets="true"/>
+  <field name="numericsubword" type="numericsubword" indexed="true" stored="true"/>
+  <field name="protectedsubword" type="protectedsubword" indexed="true" stored="true"/>
+
+  <field name="sku1" type="skutype1" indexed="true" stored="true"/>
+  <field name="sku2" type="skutype2" indexed="true" stored="true"/>
+
+  <field name="textgap" type="textgap" indexed="true" stored="true"/>
+
+  <field name="timestamp" type="date" indexed="true" stored="true" docValues="true" default="NOW" multiValued="false"/>
+  <field name="multiDefault" type="string" indexed="true" stored="true" default="muLti-Default" multiValued="true"/>
+  <field name="intDefault" type="int" indexed="true" stored="true" default="42" multiValued="false"/>
+  <field name="intRemove" type="int" indexed="true" stored="true" multiValued="true"/>
+  <field name="dateRemove" type="date" indexed="true" stored="true" multiValued="true"/>
+  <field name="floatRemove" type="float" indexed="true" stored="true" multiValued="true"/>
+
+  <field name="nopositionstext" type="nopositions" indexed="true" stored="true"/>
+
+  <field name="tlong" type="tlong" indexed="true" stored="true"/>
+
+  <field name="_version_" type="long" indexed="true" stored="true" multiValued="false"/>
+
+  <field name="title_stringNoNorms" type="string" omitNorms="true" indexed="true" stored="true"/>
+
+  <field name="store" type="location" indexed="true" stored="true" omitNorms="false"/>
+
+  <field name="lower" type="lowertok" indexed="false" stored="true" multiValued="true"/>
+  <field name="_route_" type="string" indexed="true" stored="true" multiValued="false"/>
+
+  <field name="payloadDelimited" type="payloadDelimited"/>
+
+  <!-- EnumType -->
+  <field name="severity" type="severityType" indexed="true" stored="true" multiValued="false"/>
+
+
+  <!-- Dynamic field definitions.  If a field name is not found, dynamicFields
+       will be used if the name matches any of the patterns.
+       RESTRICTION: the glob-like pattern in the name attribute must have
+       a "*" only at the start or the end.
+       EXAMPLE:  name="*_i" will match any field ending in _i (like myid_i, z_i)
+       Longer patterns will be matched first.  if equal size patterns
+       both match, the first appearing in the schema will be used.
+  -->
+  <dynamicField name="*_i" type="int" indexed="true" stored="true"/>
+  <dynamicField name="*_i1" type="int" indexed="true" stored="true" multiValued="false" sortMissingLast="true"/>
+  <dynamicField name="*_idv" type="int" indexed="true" stored="true" docValues="true" multiValued="false"/>
+
+
+  <dynamicField name="*_s" type="string" indexed="true" stored="true"/>
+  <dynamicField name="*_s1" type="string" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_l" type="long" indexed="true" stored="true"/>
+  <dynamicField name="*_l1" type="long" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_t" type="text" indexed="true" stored="true"/>
+  <dynamicField name="*_b" type="boolean" indexed="true" stored="true"/>
+  <dynamicField name="*_b1" type="boolean" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_f" type="float" indexed="true" stored="true"/>
+  <dynamicField name="*_f1" type="float" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_d" type="double" indexed="true" stored="true"/>
+  <dynamicField name="*_d1" type="double" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_dt" type="date" indexed="true" stored="true"/>
+  <dynamicField name="*_dt1" type="date" indexed="true" stored="true" multiValued="false"/>
+
+
+  <!-- some trie-coded dynamic fields for faster range queries -->
+  <dynamicField name="*_ti" type="tint" indexed="true" stored="true"/>
+  <dynamicField name="*_ti1" type="tint" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_tl" type="tlong" indexed="true" stored="true"/>
+  <dynamicField name="*_tl1" type="tlong" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_tf" type="tfloat" indexed="true" stored="true"/>
+  <dynamicField name="*_tf1" type="tfloat" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_td" type="tdouble" indexed="true" stored="true"/>
+  <dynamicField name="*_td1" type="tdouble" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_tds" type="tdouble" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_tdt" type="tdate" indexed="true" stored="true"/>
+  <dynamicField name="*_tdt1" type="tdate" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_tdtdv" type="tdatedv" indexed="true" stored="true"/>
+  <dynamicField name="*_tdtdv1" type="tdatedv" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_drf" type="dateRange" indexed="true" stored="true"/>
+
+  <dynamicField name="*_tdts" type="tdate" indexed="true" stored="true" multiValued="true"/>
+  <dynamicField name="*_tdtdvs" type="tdatedv" indexed="true" stored="true"/>
+
+  <dynamicField name="*_sI" type="string" indexed="true" stored="false"/>
+  <dynamicField name="*_sS" type="string" indexed="false" stored="true"/>
+  <dynamicField name="t_*" type="text" indexed="true" stored="true"/>
+  <dynamicField name="tv_*" type="text" indexed="true" stored="true"
+                termVectors="true" termPositions="true" termOffsets="true"/>
+  <dynamicField name="tv_mv_*" type="text" indexed="true" stored="true" multiValued="true"
+                termVectors="true" termPositions="true" termOffsets="true"/>
+  <dynamicField name="tv_no_off_*" type="text" indexed="true" stored="true"
+                termVectors="true" termPositions="true"/>
+
+  <dynamicField name="*_p" type="xyd" indexed="true" stored="true" multiValued="false"/>
+
+  <!-- special fields for dynamic copyField test -->
+  <dynamicField name="dynamic_*" type="string" indexed="true" stored="true"/>
+  <dynamicField name="*_dynamic" type="string" indexed="true" stored="true"/>
+
+  <!-- for testing to ensure that longer patterns are matched first -->
+  <dynamicField name="*aa" type="string" indexed="true" stored="true"/>
+  <dynamicField name="*aaa" type="int" indexed="false" stored="true"/>
+
+  <!-- ignored becuase not stored or indexed -->
+  <dynamicField name="*_ignored" type="text" indexed="false" stored="false"/>
+
+  <dynamicField name="*_mfacet" type="string" indexed="true" stored="false" multiValued="true"/>
+
+  <!-- Type used to index the lat and lon components for the "location" FieldType -->
+  <dynamicField name="*_coordinate" type="tdouble" indexed="true" stored="false" omitNorms="true"/>
+
+  <dynamicField name="*_path" type="path" indexed="true" stored="true" omitNorms="true" multiValued="true"/>
+  <dynamicField name="*_ancestor" type="ancestor_path" indexed="true" stored="true" omitNorms="true"
+                multiValued="true"/>
+
+  <dynamicField name="*_sev_enum" type="severityType" indexed="true" stored="true" docValues="true" multiValued="true"/>
+
+  <!-- With DocValues=true -->
+  <dynamicField name="*_i_dv" type="int" indexed="true" stored="true" docValues="true"/>
+  <dynamicField name="*_l_dv" type="long" indexed="true" stored="true" docValues="true"/>
+  <dynamicField name="*_f_dv" type="float" indexed="true" stored="true" docValues="true"/>
+  <dynamicField name="*_d_dv" type="double" indexed="true" stored="true" docValues="true"/>
+  <dynamicField name="*_dt_dv" type="date" indexed="true" stored="true" docValues="true"/>
+  <dynamicField name="*_f1_dv" type="float" indexed="true" stored="true" docValues="true" multiValued="false"/>
+
+  <!--  Non-stored, DocValues=true -->
+  <dynamicField name="*_i_dvo" multiValued="false" type="int" docValues="true" indexed="true" stored="false"
+                useDocValuesAsStored="true"/>
+  <dynamicField name="*_d_dvo" multiValued="false" type="double" docValues="true" indexed="true" stored="false"
+                useDocValuesAsStored="true"/>
+  <dynamicField name="*_s_dvo" multiValued="false" type="string" docValues="true" indexed="true" stored="false"
+                useDocValuesAsStored="true"/>
+  <dynamicField name="*_ii_dvo" multiValued="true" type="int" docValues="true" indexed="true" stored="false"
+                useDocValuesAsStored="true"/>
+  <dynamicField name="*_dd_dvo" multiValued="true" type="double" docValues="true" indexed="true" stored="false"
+                useDocValuesAsStored="true"/>
+
+  <!--  Non-stored, DocValues=true, useDocValuesAsStored=false -->
+  <field name="single_i_dvn" multiValued="false" type="int" indexed="true" stored="true"/>
+  <field name="single_d_dvn" multiValued="false" type="double" indexed="true" stored="true"/>
+  <field name="single_s_dvn" multiValued="false" type="string" indexed="true" stored="true"/>
+  <field name="copy_single_i_dvn" multiValued="false" type="int" docValues="true" indexed="true" stored="false"
+         useDocValuesAsStored="false"/>
+  <field name="copy_single_d_dvn" multiValued="false" type="double" docValues="true" indexed="true" stored="false"
+         useDocValuesAsStored="false"/>
+  <field name="copy_single_s_dvn" multiValued="false" type="string" docValues="true" indexed="true" stored="false"
+         useDocValuesAsStored="false"/>
+  <copyField source="single_i_dvn" dest="copy_single_i_dvn"/>
+  <copyField source="single_d_dvn" dest="copy_single_d_dvn"/>
+  <copyField source="single_s_dvn" dest="copy_single_s_dvn"/>
+
+  <defaultSearchField>text</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 
   <!-- copyField commands copy one field to another at the time a document
         is added to the index.  It's used either to index the same field different
         ways, or to add multiple fields to the same field for easier/faster searching.
    -->
-   <copyField source="title" dest="title_stemmed"/>
-   <copyField source="title" dest="title_lettertok"/>
-   <copyField source="title" dest="title_stringNoNorms"/>
-
-   <copyField source="title" dest="text"/>
-   <copyField source="subject" dest="text"/>
-
-   <copyField source="lowerfilt1" dest="lowerfilt1and2"/>
-   <copyField source="lowerfilt" dest="lowerfilt1and2"/>
-
-   <copyField source="*_t" dest="text"/>
-
-   <copyField source="id"            dest="range_facet_l"/>
-   <copyField source="range_facet_f" dest="range_facet_d"/>
-   <copyField source="range_facet_f1" dest="range_facet_f1_dv"/>
-   
-   <copyField source="id"            dest="range_facet_l_dv"/>
-   <copyField source="id"            dest="range_facet_i_dv"/>
-   <copyField source="range_facet_f" dest="range_facet_f_dv"/>
-   <copyField source="range_facet_f" dest="range_facet_d_dv"/>
-   <copyField source="bday" dest="range_facet_dt_dv"/>
-
-   <!-- dynamic destination -->
-   <copyField source="*_dynamic" dest="dynamic_*"/>
-   <copyField source="*_path" dest="*_ancestor"/>
-
- <!-- example of a custom similarity -->
- <similarity class="solr.CustomSimilarityFactory">
-   <str name="echo">I am your default sim</str>
- </similarity>
+  <copyField source="title" dest="title_stemmed"/>
+  <copyField source="title" dest="title_lettertok"/>
+  <copyField source="title" dest="title_stringNoNorms"/>
+
+  <copyField source="title" dest="text"/>
+  <copyField source="subject" dest="text"/>
+
+  <copyField source="lowerfilt1" dest="lowerfilt1and2"/>
+  <copyField source="lowerfilt" dest="lowerfilt1and2"/>
+
+  <copyField source="*_t" dest="text"/>
+
+  <copyField source="id" dest="range_facet_l"/>
+  <copyField source="range_facet_f" dest="range_facet_d"/>
+  <copyField source="range_facet_f1" dest="range_facet_f1_dv"/>
+
+  <copyField source="id" dest="range_facet_l_dv"/>
+  <copyField source="id" dest="range_facet_i_dv"/>
+  <copyField source="range_facet_f" dest="range_facet_f_dv"/>
+  <copyField source="range_facet_f" dest="range_facet_d_dv"/>
+  <copyField source="bday" dest="range_facet_dt_dv"/>
+
+  <!-- dynamic destination -->
+  <copyField source="*_dynamic" dest="dynamic_*"/>
+  <copyField source="*_path" dest="*_ancestor"/>
+
+  <!-- example of a custom similarity -->
+  <similarity class="solr.CustomSimilarityFactory">
+    <str name="echo">I am your default sim</str>
+  </similarity>
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema11.xml b/solr/core/src/test-files/solr/collection1/conf/schema11.xml
index 478f3fc..e5b9233 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema11.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema11.xml
@@ -288,7 +288,7 @@ valued. -->
 
    <!-- Valid attributes for fields:
      name: mandatory - the name for the field
-     type: mandatory - the name of a previously defined type from the <types> section
+     type: mandatory - the name of a previously defined type from a fieldType
      indexed: true if this field should be indexed (searchable or sortable)
      stored: true if this field should be retrievable
      multiValued: true if this field may contain multiple values per document
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema12.xml b/solr/core/src/test-files/solr/collection1/conf/schema12.xml
index df4da0b..0de219a 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema12.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema12.xml
@@ -26,551 +26,576 @@
   -->
 
 <schema name="test" version="1.4">
-  <types>
 
-    <!-- field type definitions... note that the "name" attribute is
-         just a label to be used by field definitions.  The "class"
-         attribute and any other attributes determine the real type and
-         behavior of the fieldType.
-      -->
+  <!-- field type definitions... note that the "name" attribute is
+       just a label to be used by field definitions.  The "class"
+       attribute and any other attributes determine the real type and
+       behavior of the fieldType.
+    -->
+
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+
+  <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+
+  <!-- Field type demonstrating an Analyzer failure -->
+  <fieldType name="failtype1" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0"
+              catenateNumbers="0" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
 
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>  
-
-    <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
-
-    <!-- Field type demonstrating an Analyzer failure -->
-    <fieldType name="failtype1" class="solr.TextField">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- Demonstrating ignoreCaseChange -->
-    <fieldType name="wdf_nocase" class="solr.TextField">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    
-     <fieldType name="wdf_preserve" class="solr.TextField">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="1"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <!-- HighlitText optimizes storage for (long) columns which will be highlit -->
-    <fieldType name="highlittext" class="solr.TextField"/>
-
-    <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
-
-    <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
-         seconds part (.999) is optional.
-      -->
-    <fieldType name="date" class="solr.TrieDateField" sortMissingLast="true"/>
-    <fieldType name="tdate" class="solr.TrieDateField" sortMissingLast="true" precisionStep="6"/>
-
-  <fieldType name="text" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true" >
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="stopwords.txt"
-                />
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="stopwords.txt"
-                />
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <!-- field type that doesn't generate phrases from unquoted multiple tokens per analysis unit -->
-   <fieldType name="text_np" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="stopwords.txt"
-                />
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="stopwords.txt"
-                />
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="nametext" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.core.WhitespaceAnalyzer"/>
-    </fieldType>
-
-    <fieldType name="teststop" class="solr.TextField">
-       <analyzer>
-        <tokenizer class="solr.LowerCaseTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-        <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- fieldTypes in this section isolate tokenizers and tokenfilters for testing -->
-    <fieldType name="lowertok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.LowerCaseTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="keywordtok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/></analyzer>
-    </fieldType>
-    <fieldType name="standardtok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.StandardTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="lettertok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.LetterTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="whitetok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.MockTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="HTMLstandardtok" class="solr.TextField">
-      <analyzer>
+  <!-- Demonstrating ignoreCaseChange -->
+  <fieldType name="wdf_nocase" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="wdf_preserve" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <!-- HighlitText optimizes storage for (long) columns which will be highlit -->
+  <fieldType name="highlittext" class="solr.TextField"/>
+
+  <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+
+  <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
+       seconds part (.999) is optional.
+    -->
+  <fieldType name="date" class="solr.TrieDateField" sortMissingLast="true"/>
+  <fieldType name="tdate" class="solr.TrieDateField" sortMissingLast="true" precisionStep="6"/>
+
+  <fieldType name="text" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="stopwords.txt"
+      />
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="stopwords.txt"
+      />
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <!-- field type that doesn't generate phrases from unquoted multiple tokens per analysis unit -->
+  <fieldType name="text_np" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="stopwords.txt"
+      />
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="stopwords.txt"
+      />
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="nametext" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.core.WhitespaceAnalyzer"/>
+  </fieldType>
+
+  <fieldType name="teststop" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LowerCaseTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+      <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- fieldTypes in this section isolate tokenizers and tokenfilters for testing -->
+  <fieldType name="lowertok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LowerCaseTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="keywordtok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="standardtok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="lettertok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LetterTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="whitetok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="HTMLstandardtok" class="solr.TextField">
+    <analyzer>
       <charFilter class="solr.HTMLStripCharFilterFactory"/>
       <tokenizer class="solr.StandardTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="HTMLwhitetok" class="solr.TextField">
-      <analyzer>
+    </analyzer>
+  </fieldType>
+  <fieldType name="HTMLwhitetok" class="solr.TextField">
+    <analyzer>
       <charFilter class="solr.HTMLStripCharFilterFactory"/>
       <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="standardtokfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="standardfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="lowerfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="patternreplacefilt" class="solr.TextField">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
-        <filter class="solr.PatternReplaceFilterFactory"
-                pattern="([^a-zA-Z])" replacement="_" replace="all"
-        />
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="porterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="engporterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="custengporterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="stopfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="custstopfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="lengthfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LengthFilterFactory" min="2" max="5"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="subword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.StopFilterFactory"/>
-          <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.StopFilterFactory"/>
-          <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="numericsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-          <filter class="solr.StopFilterFactory"/>
-          <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.StopFilterFactory"/>
-          <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="protectedsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <!-- more flexible in matching skus, but more chance of a false match -->
-    <fieldType name="skutype1" class="solr.TextField">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- less flexible in matching skus, but less chance of a false match -->
-    <fieldType name="skutype2" class="solr.TextField">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- less flexible in matching skus, but less chance of a false match -->
-    <fieldType name="syn" class="solr.TextField">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- a text field with the stop filter only on the query analyzer 
-     -->
-    <fieldType name="text_sw" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <!-- in this example, we will only use synonyms at query time
-        <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
-        -->
-        <!--<filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>-->
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
-                catenateNumbers="1" catenateAll="0" splitOnCaseChange="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
-                catenateNumbers="0" catenateAll="0" splitOnCaseChange="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    
-    <!-- Demonstrates How RemoveDuplicatesTokenFilter makes stemmed
-         synonyms "better"
+    </analyzer>
+  </fieldType>
+  <fieldType name="standardtokfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="standardfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="lowerfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="patternreplacefilt" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+      <filter class="solr.PatternReplaceFilterFactory"
+              pattern="([^a-zA-Z])" replacement="_" replace="all"
+      />
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="porterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="engporterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="custengporterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="stopfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="custstopfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="lengthfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LengthFilterFactory" min="2" max="5"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="subword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="numericsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0"
+              splitOnCaseChange="0" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0"
+              catenateAll="0"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0"
+              splitOnCaseChange="0" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1"
+              catenateAll="0"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="protectedsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0"
+              splitOnCaseChange="0" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0"
+              catenateAll="0"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <!-- more flexible in matching skus, but more chance of a false match -->
+  <fieldType name="skutype1" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- less flexible in matching skus, but less chance of a false match -->
+  <fieldType name="skutype2" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- less flexible in matching skus, but less chance of a false match -->
+  <fieldType name="syn" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- a text field with the stop filter only on the query analyzer 
+   -->
+  <fieldType name="text_sw" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <!-- in this example, we will only use synonyms at query time
+      <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
       -->
-    <fieldType name="dedup" class="solr.TextField">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.SynonymFilterFactory"
-                  synonyms="synonyms.txt" expand="true" />
-          <filter class="solr.PorterStemFilterFactory"/>
-          <filter class="solr.RemoveDuplicatesTokenFilterFactory" />
-      </analyzer>
-    </fieldType>
+      <!--<filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>-->
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0" splitOnCaseChange="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
 
-    <fieldType  name="unstored" class="solr.StrField" indexed="true" stored="false"/>
+
+  <!-- Demonstrates How RemoveDuplicatesTokenFilter makes stemmed
+       synonyms "better"
+    -->
+  <fieldType name="dedup" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory"
+              synonyms="synonyms.txt" expand="true"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="unstored" class="solr.StrField" indexed="true" stored="false"/>
 
 
   <fieldType name="textgap" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-  </fieldType>
-
-  <fieldType name="uuid" class="solr.UUIDField" />
-  <fieldType name="ignored" class="solr.StrField" indexed="false" stored="false" />
-
-
-  <fieldType name="random" class="solr.RandomSortField" indexed="true" />  
-  
-    <!-- Poly field -->
-    <fieldType name="xy" class="solr.PointType" dimension="2" subFieldType="double"/>
-    <fieldType name="xyd" class="solr.PointType" dimension="2" subFieldSuffix="*_d"/>
-    <fieldType name="geohash" class="solr.GeoHashField"/>
-
-   <fieldType name="point" class="solr.PointType" dimension="2" subFieldSuffix="_d"/>
-    <!-- A specialized field for geospatial search. If indexed, this fieldType must not be multivalued. -->
-    <fieldType name="location" class="solr.LatLonType" subFieldSuffix="_coordinate"/>
-    <!-- sub-centimeter accuracy for RPT; distance calcs -->
-    <fieldType name="location_rpt" class="solr.SpatialRecursivePrefixTreeFieldType"
-               geo="true" distErrPct="0.025" maxDistErr="0.00001" distanceUnits="kilometers" />
-
-  <fieldType name="currency" class="solr.CurrencyField" currencyConfig="currency.xml" multiValued="false" />
- </types>
-
-
- <fields>
-   <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="true"/>
-   <field name="signatureField" type="string" indexed="true" stored="false"/>
-   <field name="uuid" type="uuid" stored="true" />
-   <field name="name" type="nametext" indexed="true" stored="true"/>
-   <field name="text" type="text" indexed="true" stored="false"/>
-   <field name="subject" type="text" indexed="true" stored="true"/>
-   <field name="title" type="nametext" indexed="true" stored="true"/>
-   <field name="weight" type="float" indexed="true" stored="true"/>
-   <field name="bday" type="date" indexed="true" stored="true"/>
-
-   <field name="text_np" type="text_np" indexed="true" stored="false"/>
-
-   <field name="title_stemmed" type="text" indexed="true" stored="false"/>
-   <field name="title_lettertok" type="lettertok" indexed="true" stored="false"/>
-
-   <field name="syn" type="syn" indexed="true" stored="true"/>
-
-   <!-- to test property inheritance and overriding -->
-   <field name="shouldbeunstored" type="unstored" />
-   <field name="shouldbestored" type="unstored" stored="true"/>
-   <field name="shouldbeunindexed" type="unstored" indexed="false" stored="true"/>
-
-
-   <!-- test different combinations of indexed and stored -->
-   <field name="bind" type="boolean" indexed="true" stored="false"/>
-   <field name="bsto" type="boolean" indexed="false" stored="true"/>
-   <field name="bindsto" type="boolean" indexed="true" stored="true"/>
-   <field name="isto" type="int" indexed="false" stored="true"/>
-   <field name="iind" type="int" indexed="true" stored="false"/>
-   <field name="ssto" type="string" indexed="false" stored="true"/>
-   <field name="sind" type="string" indexed="true" stored="false"/>
-   <field name="sindsto" type="string" indexed="true" stored="true"/>
-
-   <!-- test combinations of term vector settings -->
-   <field name="test_basictv" type="text" termVectors="true"/>
-   <field name="test_notv" type="text" termVectors="false"/>
-   <field name="test_postv" type="text" termVectors="true" termPositions="true"/>
-   <field name="test_offtv" type="text" termVectors="true" termOffsets="true"/>
-   <field name="test_posofftv" type="text" termVectors="true" 
-     termPositions="true" termOffsets="true"/>
-
-   <!-- test highlit field settings -->
-   <field name="test_hlt" type="highlittext" indexed="true"/>
-   <field name="test_hlt_off" type="highlittext" indexed="true"/>
-
-   <!-- fields to test individual tokenizers and tokenfilters -->
-   <field name="teststop" type="teststop" indexed="true" stored="true"/>
-   <field name="lowertok" type="lowertok" indexed="true" stored="true"/>
-   <field name="keywordtok" type="keywordtok" indexed="true" stored="true"/>
-   <field name="standardtok" type="standardtok" indexed="true" stored="true"/>
-   <field name="HTMLstandardtok" type="HTMLstandardtok" indexed="true" stored="true"/>
-   <field name="lettertok" type="lettertok" indexed="true" stored="true"/>
-   <field name="whitetok" type="whitetok" indexed="true" stored="true"/>
-   <field name="HTMLwhitetok" type="HTMLwhitetok" indexed="true" stored="true"/>
-   <field name="standardtokfilt" type="standardtokfilt" indexed="true" stored="true"/>
-   <field name="standardfilt" type="standardfilt" indexed="true" stored="true"/>
-   <field name="lowerfilt" type="lowerfilt" indexed="true" stored="true"/>
-   <field name="patternreplacefilt" type="patternreplacefilt" indexed="true" stored="true"/>
-   <field name="porterfilt" type="porterfilt" indexed="true" stored="true"/>
-   <field name="engporterfilt" type="engporterfilt" indexed="true" stored="true"/>
-   <field name="custengporterfilt" type="custengporterfilt" indexed="true" stored="true"/>
-   <field name="stopfilt" type="stopfilt" indexed="true" stored="true"/>
-   <field name="custstopfilt" type="custstopfilt" indexed="true" stored="true"/>
-   <field name="lengthfilt" type="lengthfilt" indexed="true" stored="true"/>
-   <field name="dedup" type="dedup" indexed="true" stored="true"/>
-   <field name="wdf_nocase" type="wdf_nocase" indexed="true" stored="true"/>
-   <field name="wdf_preserve" type="wdf_preserve" indexed="true" stored="true"/>
-
-   <field name="numberpartfail" type="failtype1" indexed="true" stored="true"/>
-
-   <field name="nullfirst" type="string" indexed="true" stored="true" sortMissingFirst="true"/>
-
-   <field name="subword" type="subword" indexed="true" stored="true"/>
-   <field name="numericsubword" type="numericsubword" indexed="true" stored="true"/>
-   <field name="protectedsubword" type="protectedsubword" indexed="true" stored="true"/>
-
-   <field name="sku1" type="skutype1" indexed="true" stored="true"/>
-   <field name="sku2" type="skutype2" indexed="true" stored="true"/>
-
-   <field name="textgap" type="textgap" indexed="true" stored="true"/>
-   
-   <!--
-   <field name="timestamp" type="date" indexed="true" stored="true" default="NOW"/>
-   -->
-   <field name="timestamp" type="date" indexed="true" stored="true"/>
-
-   <!-- Test a point field for distances -->
-   <field name="point" type="xy" indexed="true" stored="true" multiValued="false"/>
-   <field name="pointD" type="xyd" indexed="true" stored="true" multiValued="false"/>
-   <field name="point_hash" type="geohash" indexed="true" stored="true" multiValued="false"/>
-   <field name="store" type="location" indexed="true" stored="true"/>
-   <field name="store_rpt" type="location_rpt" indexed="true" stored="false" />
-   
-   <!-- Test currency field -->
-   <field name="amount_c" type="currency" indexed="true" stored="true" multiValued="false"/>
-   <!-- to test uniq fields -->   
-   <field name="uniq" type="string" indexed="true" stored="true" multiValued="true"/>
-   <field name="uniq2" type="string" indexed="true" stored="true" multiValued="true"/>
-   <field name="uniq3" type="string" indexed="true" stored="true"/>
-   <field name="nouniq" type="string" indexed="true" stored="true" multiValued="true"/>
-
-
-   <!--
-      DO NOT INCLUDE _version_ in this schema file
-      We explicitly want tests using this file to *NOT* have this field
-      so we can verify that Solr behaves correctly w/o it in those sitautions
-     -->
-   <!-- <field name="_version_" type="long" indexed="true" stored="true"/> -->
-
-   <dynamicField name="*_coordinate"  type="tdouble" indexed="true"  stored="false"/>
-
-   <dynamicField name="*_sI" type="string"  indexed="true"  stored="false"/>
-   <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
-   <dynamicField name="t_*"  type="text"    indexed="true"  stored="true"/>
-   <dynamicField name="tv_*"  type="text" indexed="true"  stored="true" 
-      termVectors="true" termPositions="true" termOffsets="true"/>
-   <dynamicField name="tv_mv_*"  type="text" indexed="true"  stored="true" multiValued="true"
-      termVectors="true" termPositions="true" termOffsets="true"/>
-
-   <dynamicField name="*_mfacet" type="string" indexed="true" stored="false" multiValued="true" />
-
-   <dynamicField name="*_sw" type="text_sw" indexed="true" stored="true" multiValued="true"/>
-
-   <dynamicField name="*_i"  type="int"    indexed="true"  stored="true"/>
-   <dynamicField name="*_is"  type="int"    indexed="true"  stored="true" multiValued="true"/>
-   <dynamicField name="*_idv"  type="int"    indexed="true"  stored="true" docValues="true" multiValued="false" />
-   <dynamicField name="*_s1"  type="string"  indexed="true" stored="true" multiValued="false"/>
-   <!-- :TODO: why are these identical?!?!?! -->
-   <dynamicField name="*_s"  type="string"  indexed="true"  stored="true" multiValued="true"/>
-   <dynamicField name="*_ss"  type="string"  indexed="true"  stored="true" multiValued="true"/>
-   <dynamicField name="*_l"  type="long"   indexed="true"  stored="true"/>
-   <dynamicField name="*_t"  type="text"    indexed="true"  stored="true"/>
-   <dynamicField name="*_tt"  type="text"    indexed="true"  stored="true"/>
-   <dynamicField name="*_b"  type="boolean" indexed="true"  stored="true"/>
-   <dynamicField name="*_f"  type="float"  indexed="true"  stored="true"/>
-   <dynamicField name="*_d"  type="double" indexed="true"  stored="true"/>
-   <dynamicField name="*_dt" type="date"    indexed="true"  stored="true"/>
-
-   <!-- some trie-coded dynamic fields for faster range queries -->
-   <dynamicField name="*_ti" type="tint"    indexed="true"  stored="true"/>
-   <dynamicField name="*_tl" type="tlong"   indexed="true"  stored="true"/>
-   <dynamicField name="*_tf" type="tfloat"  indexed="true"  stored="true"/>
-   <dynamicField name="*_td" type="tdouble" indexed="true"  stored="true"/>
-   <dynamicField name="*_tdt" type="tdate"  indexed="true"  stored="true"/>
-
-   <dynamicField name="ignored_*" type="ignored" multiValued="true"/>
-   <dynamicField name="attr_*" type="text" indexed="true" stored="true" multiValued="true"/>
-
-   <dynamicField name="random_*" type="random" />
-
-   <!-- unused, for testing luke copyFields -->
-   <dynamicField name="foo_copysource_*" type="ignored" multiValued="true"/>
-   <dynamicField name="bar_copydest_*" type="ignored" multiValued="true"/>
-   <dynamicField name="*_es"  type="text"    indexed="true"  stored="true"/>
-
-   <!-- for testing if score psuedofield is erroneously treated as multivalued
-        when a matching dynamic field exists 
-   -->
-   <dynamicField name="*core" type="ignored" multiValued="true" />
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="uuid" class="solr.UUIDField"/>
+  <fieldType name="ignored" class="solr.StrField" indexed="false" stored="false"/>
+
+
+  <fieldType name="random" class="solr.RandomSortField" indexed="true"/>
+
+  <!-- Poly field -->
+  <fieldType name="xy" class="solr.PointType" dimension="2" subFieldType="double"/>
+  <fieldType name="xyd" class="solr.PointType" dimension="2" subFieldSuffix="*_d"/>
+  <fieldType name="geohash" class="solr.GeoHashField"/>
+
+  <fieldType name="point" class="solr.PointType" dimension="2" subFieldSuffix="_d"/>
+  <!-- A specialized field for geospatial search. If indexed, this fieldType must not be multivalued. -->
+  <fieldType name="location" class="solr.LatLonType" subFieldSuffix="_coordinate"/>
+  <!-- sub-centimeter accuracy for RPT; distance calcs -->
+  <fieldType name="location_rpt" class="solr.SpatialRecursivePrefixTreeFieldType"
+             geo="true" distErrPct="0.025" maxDistErr="0.00001" distanceUnits="kilometers"/>
+
+  <fieldType name="currency" class="solr.CurrencyField" currencyConfig="currency.xml" multiValued="false"/>
+
+
+  <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="true"/>
+  <field name="signatureField" type="string" indexed="true" stored="false"/>
+  <field name="uuid" type="uuid" stored="true"/>
+  <field name="name" type="nametext" indexed="true" stored="true"/>
+  <field name="text" type="text" indexed="true" stored="false"/>
+  <field name="subject" type="text" indexed="true" stored="true"/>
+  <field name="title" type="nametext" indexed="true" stored="true"/>
+  <field name="weight" type="float" indexed="true" stored="true"/>
+  <field name="bday" type="date" indexed="true" stored="true"/>
+
+  <field name="text_np" type="text_np" indexed="true" stored="false"/>
+
+  <field name="title_stemmed" type="text" indexed="true" stored="false"/>
+  <field name="title_lettertok" type="lettertok" indexed="true" stored="false"/>
+
+  <field name="syn" type="syn" indexed="true" stored="true"/>
+
+  <!-- to test property inheritance and overriding -->
+  <field name="shouldbeunstored" type="unstored"/>
+  <field name="shouldbestored" type="unstored" stored="true"/>
+  <field name="shouldbeunindexed" type="unstored" indexed="false" stored="true"/>
+
+
+  <!-- test different combinations of indexed and stored -->
+  <field name="bind" type="boolean" indexed="true" stored="false"/>
+  <field name="bsto" type="boolean" indexed="false" stored="true"/>
+  <field name="bindsto" type="boolean" indexed="true" stored="true"/>
+  <field name="isto" type="int" indexed="false" stored="true"/>
+  <field name="iind" type="int" indexed="true" stored="false"/>
+  <field name="ssto" type="string" indexed="false" stored="true"/>
+  <field name="sind" type="string" indexed="true" stored="false"/>
+  <field name="sindsto" type="string" indexed="true" stored="true"/>
+
+  <!-- test combinations of term vector settings -->
+  <field name="test_basictv" type="text" termVectors="true"/>
+  <field name="test_notv" type="text" termVectors="false"/>
+  <field name="test_postv" type="text" termVectors="true" termPositions="true"/>
+  <field name="test_offtv" type="text" termVectors="true" termOffsets="true"/>
+  <field name="test_posofftv" type="text" termVectors="true"
+         termPositions="true" termOffsets="true"/>
+
+  <!-- test highlit field settings -->
+  <field name="test_hlt" type="highlittext" indexed="true"/>
+  <field name="test_hlt_off" type="highlittext" indexed="true"/>
+
+  <!-- fields to test individual tokenizers and tokenfilters -->
+  <field name="teststop" type="teststop" indexed="true" stored="true"/>
+  <field name="lowertok" type="lowertok" indexed="true" stored="true"/>
+  <field name="keywordtok" type="keywordtok" indexed="true" stored="true"/>
+  <field name="standardtok" type="standardtok" indexed="true" stored="true"/>
+  <field name="HTMLstandardtok" type="HTMLstandardtok" indexed="true" stored="true"/>
+  <field name="lettertok" type="lettertok" indexed="true" stored="true"/>
+  <field name="whitetok" type="whitetok" indexed="true" stored="true"/>
+  <field name="HTMLwhitetok" type="HTMLwhitetok" indexed="true" stored="true"/>
+  <field name="standardtokfilt" type="standardtokfilt" indexed="true" stored="true"/>
+  <field name="standardfilt" type="standardfilt" indexed="true" stored="true"/>
+  <field name="lowerfilt" type="lowerfilt" indexed="true" stored="true"/>
+  <field name="patternreplacefilt" type="patternreplacefilt" indexed="true" stored="true"/>
+  <field name="porterfilt" type="porterfilt" indexed="true" stored="true"/>
+  <field name="engporterfilt" type="engporterfilt" indexed="true" stored="true"/>
+  <field name="custengporterfilt" type="custengporterfilt" indexed="true" stored="true"/>
+  <field name="stopfilt" type="stopfilt" indexed="true" stored="true"/>
+  <field name="custstopfilt" type="custstopfilt" indexed="true" stored="true"/>
+  <field name="lengthfilt" type="lengthfilt" indexed="true" stored="true"/>
+  <field name="dedup" type="dedup" indexed="true" stored="true"/>
+  <field name="wdf_nocase" type="wdf_nocase" indexed="true" stored="true"/>
+  <field name="wdf_preserve" type="wdf_preserve" indexed="true" stored="true"/>
+
+  <field name="numberpartfail" type="failtype1" indexed="true" stored="true"/>
+
+  <field name="nullfirst" type="string" indexed="true" stored="true" sortMissingFirst="true"/>
+
+  <field name="subword" type="subword" indexed="true" stored="true"/>
+  <field name="numericsubword" type="numericsubword" indexed="true" stored="true"/>
+  <field name="protectedsubword" type="protectedsubword" indexed="true" stored="true"/>
+
+  <field name="sku1" type="skutype1" indexed="true" stored="true"/>
+  <field name="sku2" type="skutype2" indexed="true" stored="true"/>
+
+  <field name="textgap" type="textgap" indexed="true" stored="true"/>
+
+  <!--
+  <field name="timestamp" type="date" indexed="true" stored="true" default="NOW"/>
+  -->
+  <field name="timestamp" type="date" indexed="true" stored="true"/>
+
+  <!-- Test a point field for distances -->
+  <field name="point" type="xy" indexed="true" stored="true" multiValued="false"/>
+  <field name="pointD" type="xyd" indexed="true" stored="true" multiValued="false"/>
+  <field name="point_hash" type="geohash" indexed="true" stored="true" multiValued="false"/>
+  <field name="store" type="location" indexed="true" stored="true"/>
+  <field name="store_rpt" type="location_rpt" indexed="true" stored="false"/>
+
+  <!-- Test currency field -->
+  <field name="amount_c" type="currency" indexed="true" stored="true" multiValued="false"/>
+  <!-- to test uniq fields -->
+  <field name="uniq" type="string" indexed="true" stored="true" multiValued="true"/>
+  <field name="uniq2" type="string" indexed="true" stored="true" multiValued="true"/>
+  <field name="uniq3" type="string" indexed="true" stored="true"/>
+  <field name="nouniq" type="string" indexed="true" stored="true" multiValued="true"/>
+
+
+  <!--
+     DO NOT INCLUDE _version_ in this schema file
+     We explicitly want tests using this file to *NOT* have this field
+     so we can verify that Solr behaves correctly w/o it in those sitautions
+    -->
+  <!-- <field name="_version_" type="long" indexed="true" stored="true"/> -->
+
+  <dynamicField name="*_coordinate" type="tdouble" indexed="true" stored="false"/>
+
+  <dynamicField name="*_sI" type="string" indexed="true" stored="false"/>
+  <dynamicField name="*_sS" type="string" indexed="false" stored="true"/>
+  <dynamicField name="t_*" type="text" indexed="true" stored="true"/>
+  <dynamicField name="tv_*" type="text" indexed="true" stored="true"
+                termVectors="true" termPositions="true" termOffsets="true"/>
+  <dynamicField name="tv_mv_*" type="text" indexed="true" stored="true" multiValued="true"
+                termVectors="true" termPositions="true" termOffsets="true"/>
+
+  <dynamicField name="*_mfacet" type="string" indexed="true" stored="false" multiValued="true"/>
+
+  <dynamicField name="*_sw" type="text_sw" indexed="true" stored="true" multiValued="true"/>
+
+  <dynamicField name="*_i" type="int" indexed="true" stored="true"/>
+  <dynamicField name="*_is" type="int" indexed="true" stored="true" multiValued="true"/>
+  <dynamicField name="*_idv" type="int" indexed="true" stored="true" docValues="true" multiValued="false"/>
+  <dynamicField name="*_s1" type="string" indexed="true" stored="true" multiValued="false"/>
+  <!-- :TODO: why are these identical?!?!?! -->
+  <dynamicField name="*_s" type="string" indexed="true" stored="true" multiValued="true"/>
+  <dynamicField name="*_ss" type="string" indexed="true" stored="true" multiValued="true"/>
+  <dynamicField name="*_l" type="long" indexed="true" stored="true"/>
+  <dynamicField name="*_t" type="text" indexed="true" stored="true"/>
+  <dynamicField name="*_tt" type="text" indexed="true" stored="true"/>
+  <dynamicField name="*_b" type="boolean" indexed="true" stored="true"/>
+  <dynamicField name="*_f" type="float" indexed="true" stored="true"/>
+  <dynamicField name="*_d" type="double" indexed="true" stored="true"/>
+  <dynamicField name="*_dt" type="date" indexed="true" stored="true"/>
+
+  <!-- some trie-coded dynamic fields for faster range queries -->
+  <dynamicField name="*_ti" type="tint" indexed="true" stored="true"/>
+  <dynamicField name="*_tl" type="tlong" indexed="true" stored="true"/>
+  <dynamicField name="*_tf" type="tfloat" indexed="true" stored="true"/>
+  <dynamicField name="*_td" type="tdouble" indexed="true" stored="true"/>
+  <dynamicField name="*_tdt" type="tdate" indexed="true" stored="true"/>
+
+  <dynamicField name="ignored_*" type="ignored" multiValued="true"/>
+  <dynamicField name="attr_*" type="text" indexed="true" stored="true" multiValued="true"/>
+
+  <dynamicField name="random_*" type="random"/>
+
+  <!-- unused, for testing luke copyFields -->
+  <dynamicField name="foo_copysource_*" type="ignored" multiValued="true"/>
+  <dynamicField name="bar_copydest_*" type="ignored" multiValued="true"/>
+  <dynamicField name="*_es" type="text" indexed="true" stored="true"/>
+
+  <!-- for testing if score psuedofield is erroneously treated as multivalued
+       when a matching dynamic field exists 
+  -->
+  <dynamicField name="*core" type="ignored" multiValued="true"/>
+
 
- </fields>
+  <defaultSearchField>text</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 
- <defaultSearchField>text</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+  <copyField source="title" dest="title_stemmed"/>
+  <copyField source="title" dest="title_lettertok"/>
 
-   <copyField source="title" dest="title_stemmed"/>
-   <copyField source="title" dest="title_lettertok"/>
+  <copyField source="title" dest="text"/>
+  <copyField source="subject" dest="text"/>
 
-   <copyField source="title" dest="text"/>
-   <copyField source="subject" dest="text"/>
+  <copyField source="foo_copysource_*" dest="bar_copydest_*"/>
+  <copyField source="store" dest="store_rpt"/>
 
-   <copyField source="foo_copysource_*" dest="bar_copydest_*" />
-   <copyField source="store" dest="store_rpt" />
- 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema15.xml b/solr/core/src/test-files/solr/collection1/conf/schema15.xml
index 55ec3f1..82faa6a 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema15.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema15.xml
@@ -31,538 +31,563 @@
        1.5: omitNorms defaults to true for primitive field types (int, float, boolean, string...)
        1.6: useDocValuesAsStored defaults to true.
      -->
-  <types>
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>  
-
-    <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="currency" class="solr.CurrencyField" currencyConfig="currency.xml" multiValued="false" />
-
-    <!-- Field type demonstrating an Analyzer failure -->
-    <fieldType name="failtype1" class="solr.TextField">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- Demonstrating ignoreCaseChange -->
-    <fieldType name="wdf_nocase" class="solr.TextField">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    
-     <fieldType name="wdf_preserve" class="solr.TextField">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="1"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <!-- HighlitText optimizes storage for (long) columns which will be highlit -->
-    <fieldType name="highlittext" class="solr.TextField"/>
-
-    <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
-
-    <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
-         seconds part (.999) is optional.
-      -->
-    <fieldType name="date" class="solr.TrieDateField" sortMissingLast="true"/>
-    <fieldType name="tdate" class="solr.TrieDateField" sortMissingLast="true" precisionStep="6"/>
-
-  <fieldType name="text" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true" >
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="stopwords.txt"
-                />
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="stopwords.txt"
-                />
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <!-- field type that doesn't generate phrases from unquoted multiple tokens per analysis unit -->
-   <fieldType name="text_np" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="stopwords.txt"
-                />
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="stopwords.txt"
-                />
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="nametext" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.core.WhitespaceAnalyzer"/>
-    </fieldType>
-
-    <fieldType name="teststop" class="solr.TextField">
-       <analyzer>
-        <tokenizer class="solr.LowerCaseTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-        <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- fieldTypes in this section isolate tokenizers and tokenfilters for testing -->
-    <fieldType name="lowertok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.LowerCaseTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="keywordtok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/></analyzer>
-    </fieldType>
-    <fieldType name="standardtok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.StandardTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="lettertok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.LetterTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="whitetok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.MockTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="HTMLstandardtok" class="solr.TextField">
-      <analyzer>
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
+
+  <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="currency" class="solr.CurrencyField" currencyConfig="currency.xml" multiValued="false"/>
+
+  <!-- Field type demonstrating an Analyzer failure -->
+  <fieldType name="failtype1" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0"
+              catenateNumbers="0" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Demonstrating ignoreCaseChange -->
+  <fieldType name="wdf_nocase" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="wdf_preserve" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <!-- HighlitText optimizes storage for (long) columns which will be highlit -->
+  <fieldType name="highlittext" class="solr.TextField"/>
+
+  <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+
+  <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
+       seconds part (.999) is optional.
+    -->
+  <fieldType name="date" class="solr.TrieDateField" sortMissingLast="true"/>
+  <fieldType name="tdate" class="solr.TrieDateField" sortMissingLast="true" precisionStep="6"/>
+
+  <fieldType name="text" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="stopwords.txt"
+      />
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="stopwords.txt"
+      />
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <!-- field type that doesn't generate phrases from unquoted multiple tokens per analysis unit -->
+  <fieldType name="text_np" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="stopwords.txt"
+      />
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="stopwords.txt"
+      />
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="nametext" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.core.WhitespaceAnalyzer"/>
+  </fieldType>
+
+  <fieldType name="teststop" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LowerCaseTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+      <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- fieldTypes in this section isolate tokenizers and tokenfilters for testing -->
+  <fieldType name="lowertok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LowerCaseTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="keywordtok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="standardtok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="lettertok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LetterTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="whitetok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="HTMLstandardtok" class="solr.TextField">
+    <analyzer>
       <charFilter class="solr.HTMLStripCharFilterFactory"/>
       <tokenizer class="solr.StandardTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="HTMLwhitetok" class="solr.TextField">
-      <analyzer>
+    </analyzer>
+  </fieldType>
+  <fieldType name="HTMLwhitetok" class="solr.TextField">
+    <analyzer>
       <charFilter class="solr.HTMLStripCharFilterFactory"/>
       <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="standardtokfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="standardfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="lowerfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="patternreplacefilt" class="solr.TextField">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
-        <filter class="solr.PatternReplaceFilterFactory"
-                pattern="([^a-zA-Z])" replacement="_" replace="all"
-        />
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="porterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="engporterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="custengporterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="stopfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="custstopfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="lengthfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LengthFilterFactory" min="2" max="5"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="limitfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LimitTokenCountFilterFactory" maxTokenCount="100" />
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="subword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.StopFilterFactory"/>
-          <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.StopFilterFactory"/>
-          <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="numericsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-          <filter class="solr.StopFilterFactory"/>
-          <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.StopFilterFactory"/>
-          <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="protectedsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <!-- more flexible in matching skus, but more chance of a false match -->
-    <fieldType name="skutype1" class="solr.TextField">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- less flexible in matching skus, but less chance of a false match -->
-    <fieldType name="skutype2" class="solr.TextField">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- less flexible in matching skus, but less chance of a false match -->
-    <fieldType name="syn" class="solr.TextField">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- a text field with the stop filter only on the query analyzer 
-     -->
-    <fieldType name="text_sw" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <!-- in this example, we will only use synonyms at query time
-        <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
-        -->
-        <!--<filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>-->
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
-                catenateNumbers="1" catenateAll="0" splitOnCaseChange="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
-                catenateNumbers="0" catenateAll="0" splitOnCaseChange="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    
-    <!-- Demonstrates How RemoveDuplicatesTokenFilter makes stemmed
-         synonyms "better"
+    </analyzer>
+  </fieldType>
+  <fieldType name="standardtokfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="standardfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="lowerfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="patternreplacefilt" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+      <filter class="solr.PatternReplaceFilterFactory"
+              pattern="([^a-zA-Z])" replacement="_" replace="all"
+      />
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="porterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="engporterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="custengporterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="stopfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="custstopfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="lengthfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LengthFilterFactory" min="2" max="5"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="limitfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LimitTokenCountFilterFactory" maxTokenCount="100"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="subword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="numericsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0"
+              splitOnCaseChange="0" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0"
+              catenateAll="0"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0"
+              splitOnCaseChange="0" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1"
+              catenateAll="0"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="protectedsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0"
+              splitOnCaseChange="0" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0"
+              catenateAll="0"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <!-- more flexible in matching skus, but more chance of a false match -->
+  <fieldType name="skutype1" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- less flexible in matching skus, but less chance of a false match -->
+  <fieldType name="skutype2" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- less flexible in matching skus, but less chance of a false match -->
+  <fieldType name="syn" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- a text field with the stop filter only on the query analyzer 
+   -->
+  <fieldType name="text_sw" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <!-- in this example, we will only use synonyms at query time
+      <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
       -->
-    <fieldType name="dedup" class="solr.TextField">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.SynonymFilterFactory"
-                  synonyms="synonyms.txt" expand="true" />
-          <filter class="solr.PorterStemFilterFactory"/>
-          <filter class="solr.RemoveDuplicatesTokenFilterFactory" />
-      </analyzer>
-    </fieldType>
+      <!--<filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>-->
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0" splitOnCaseChange="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <!-- Demonstrates How RemoveDuplicatesTokenFilter makes stemmed
+       synonyms "better"
+    -->
+  <fieldType name="dedup" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory"
+              synonyms="synonyms.txt" expand="true"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+  </fieldType>
 
-    <fieldType  name="unstored" class="solr.StrField" indexed="true" stored="false"/>
+  <fieldType name="unstored" class="solr.StrField" indexed="true" stored="false"/>
 
 
   <fieldType name="textgap" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-  </fieldType>
-
-  <fieldType name="uuid" class="solr.UUIDField" />
-  <fieldType name="ignored" class="solr.StrField" indexed="false" stored="false" />
-
-
-  <fieldType name="random" class="solr.RandomSortField" indexed="true" />  
-  
-    <!-- Poly field -->
-    <fieldType name="xy" class="solr.PointType" dimension="2" subFieldType="double"/>
-    <fieldType name="xyd" class="solr.PointType" dimension="2" subFieldSuffix="*_d"/>
-    <fieldType name="geohash" class="solr.GeoHashField"/>
-
-   <fieldType name="point" class="solr.PointType" dimension="2" subFieldSuffix="_d"/>
-    <!-- A specialized field for geospatial search. If indexed, this fieldType must not be multivalued. -->
-    <fieldType name="location" class="solr.LatLonType" subFieldSuffix="_coordinate"/>
-
- </types>
-
-
- <fields>
-   <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="true"/>
-   <field name="signatureField" type="string" indexed="true" stored="false"/>
-   <field name="uuid" type="uuid" stored="true" />
-   <field name="name" type="nametext" indexed="true" stored="true"/>
-   <field name="text" type="text" indexed="true" stored="false" multiValued="true" />
-   <field name="subject" type="text" indexed="true" stored="true"/>
-   <field name="title" type="nametext" indexed="true" stored="true"/>
-   <field name="weight" type="float" indexed="true" stored="true"/>
-   <field name="bday" type="date" indexed="true" stored="true"/>
-
-   <field name="text_np" type="text_np" indexed="true" stored="false"/>
-
-   <field name="title_stemmed" type="text" indexed="true" stored="false"/>
-   <field name="title_lettertok" type="lettertok" indexed="true" stored="false"/>
-
-   <field name="syn" type="syn" indexed="true" stored="true"/>
-
-   <!-- to test property inheritance and overriding -->
-   <field name="shouldbeunstored" type="unstored" />
-   <field name="shouldbestored" type="unstored" stored="true"/>
-   <field name="shouldbeunindexed" type="unstored" indexed="false" stored="true"/>
-
-
-   <!-- test different combinations of indexed and stored -->
-   <field name="bind" type="boolean" indexed="true" stored="false"/>
-   <field name="bsto" type="boolean" indexed="false" stored="true"/>
-   <field name="bindsto" type="boolean" indexed="true" stored="true"/>
-   <field name="isto" type="int" indexed="false" stored="true"/>
-   <field name="iind" type="int" indexed="true" stored="false"/>
-   <field name="ssto" type="string" indexed="false" stored="true"/>
-   <field name="sind" type="string" indexed="true" stored="false"/>
-   <field name="sindsto" type="string" indexed="true" stored="true"/>
-
-   <!-- test combinations of term vector settings -->
-   <field name="test_basictv" type="text" termVectors="true"/>
-   <field name="test_notv" type="text" termVectors="false"/>
-   <field name="test_postv" type="text" termVectors="true" termPositions="true"/>
-   <field name="test_offtv" type="text" termVectors="true" termOffsets="true"/>
-   <field name="test_posofftv" type="text" termVectors="true" 
-     termPositions="true" termOffsets="true"/>
-
-   <!-- test highlit field settings -->
-   <field name="test_hlt" type="highlittext" indexed="true"/>
-   <field name="test_hlt_off" type="highlittext" indexed="true"/>
-
-   <!-- fields to test individual tokenizers and tokenfilters -->
-   <field name="teststop" type="teststop" indexed="true" stored="true"/>
-   <field name="lowertok" type="lowertok" indexed="true" stored="true"/>
-   <field name="keywordtok" type="keywordtok" indexed="true" stored="true"/>
-   <field name="standardtok" type="standardtok" indexed="true" stored="true"/>
-   <field name="HTMLstandardtok" type="HTMLstandardtok" indexed="true" stored="true"/>
-   <field name="lettertok" type="lettertok" indexed="true" stored="true"/>
-   <field name="whitetok" type="whitetok" indexed="true" stored="true"/>
-   <field name="HTMLwhitetok" type="HTMLwhitetok" indexed="true" stored="true"/>
-   <field name="standardtokfilt" type="standardtokfilt" indexed="true" stored="true"/>
-   <field name="standardfilt" type="standardfilt" indexed="true" stored="true"/>
-   <field name="lowerfilt" type="lowerfilt" indexed="true" stored="true"/>
-   <field name="patternreplacefilt" type="patternreplacefilt" indexed="true" stored="true"/>
-   <field name="porterfilt" type="porterfilt" indexed="true" stored="true"/>
-   <field name="engporterfilt" type="engporterfilt" indexed="true" stored="true"/>
-   <field name="custengporterfilt" type="custengporterfilt" indexed="true" stored="true"/>
-   <field name="stopfilt" type="stopfilt" indexed="true" stored="true"/>
-   <field name="custstopfilt" type="custstopfilt" indexed="true" stored="true"/>
-   <field name="lengthfilt" type="lengthfilt" indexed="true" stored="true"/>
-   <field name="dedup" type="dedup" indexed="true" stored="true"/>
-   <field name="wdf_nocase" type="wdf_nocase" indexed="true" stored="true"/>
-   <field name="wdf_preserve" type="wdf_preserve" indexed="true" stored="true"/>
-
-   <field name="numberpartfail" type="failtype1" indexed="true" stored="true"/>
-
-   <field name="nullfirst" type="string" indexed="true" stored="true" sortMissingFirst="true"/>
-
-   <field name="subword" type="subword" indexed="true" stored="true"/>
-   <field name="numericsubword" type="numericsubword" indexed="true" stored="true"/>
-   <field name="protectedsubword" type="protectedsubword" indexed="true" stored="true"/>
-
-   <field name="sku1" type="skutype1" indexed="true" stored="true"/>
-   <field name="sku2" type="skutype2" indexed="true" stored="true"/>
-
-   <field name="textgap" type="textgap" indexed="true" stored="true"/>
-   
-   <!--
-   <field name="timestamp" type="date" indexed="true" stored="true" default="NOW"/>
-   -->
-   <field name="timestamp" type="date" indexed="true" stored="true"/>
-
-   <!-- Test a point field for distances -->
-   <field name="point" type="xy" indexed="true" stored="true" multiValued="false"/>
-   <field name="pointD" type="xyd" indexed="true" stored="true" multiValued="false"/>
-   <field name="point_hash" type="geohash" indexed="true" stored="true" multiValued="false"/>
-   <field name="store" type="location" indexed="true" stored="true"/>
-   <field name="amount" type="currency" indexed="true" stored="true" multiValued="false"/>
-   
-   <!-- to test uniq fields -->   
-   <field name="uniq" type="string" indexed="true" stored="true" multiValued="true"/>
-   <field name="uniq2" type="string" indexed="true" stored="true" multiValued="true"/>
-   <field name="uniq3" type="string" indexed="true" stored="true"/>
-   <field name="nouniq" type="string" indexed="true" stored="true" multiValued="true"/>
-
-   
-   <field name="copyfield_source" type="string" indexed="true" stored="true" multiValued="true"/>
-
-   <!-- for versioning -->
-   <field name="_version_" type="long" indexed="true" stored="true"/>
-   <!-- points to the root document of a block of nested documents -->
-   <field name="_root_" type="string" indexed="true" stored="true"/>
-
-   <field name="multi_int_with_docvals" type="tint" multiValued="true" docValues="true" indexed="false" />
-
-   <dynamicField name="*_coordinate"  type="tdouble" indexed="true"  stored="false"/>
-
-   <dynamicField name="*_sI" type="string"  indexed="true"  stored="false"/>
-   <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
-   <dynamicField name="t_*"  type="text"    indexed="true"  stored="true"/>
-   <dynamicField name="tv_*"  type="text" indexed="true"  stored="true" 
-      termVectors="true" termPositions="true" termOffsets="true"/>
-   <dynamicField name="tv_mv_*"  type="text" indexed="true"  stored="true" multiValued="true"
-      termVectors="true" termPositions="true" termOffsets="true"/>
-
-   <dynamicField name="*_mfacet" type="string" indexed="true" stored="false" multiValued="true" />
-
-   <dynamicField name="*_sw" type="text_sw" indexed="true" stored="true" multiValued="true"/>
-
-   <dynamicField name="*_i"  type="int"    indexed="true"  stored="true"/>
-   <dynamicField name="*_is"  type="int"    indexed="true"  stored="true" multiValued="true"/>
-   <dynamicField name="*_s1"  type="string"  indexed="true" stored="true" multiValued="false"/>
-   <!-- :TODO: why are these identical?!?!?! -->
-   <dynamicField name="*_s"  type="string"  indexed="true"  stored="true" multiValued="true"/>
-   <dynamicField name="*_ss"  type="string"  indexed="true"  stored="true" multiValued="true"/>
-   <dynamicField name="*_l"  type="long"   indexed="true"  stored="true"/>
-   <dynamicField name="*_ll" type="long"   indexed="true"  stored="true"  multiValued="true"/>
-   <dynamicField name="*_t"  type="text"    indexed="true"  stored="true"/>
-   <dynamicField name="*_tt"  type="text"    indexed="true"  stored="true"/>
-   <dynamicField name="*_ws"  type="nametext" indexed="true" stored="true"/>
-   <dynamicField name="*_b"  type="boolean" indexed="true"  stored="true"/>
-   <dynamicField name="*_f"  type="float"  indexed="true"  stored="true"/>
-   <dynamicField name="*_d"  type="double" indexed="true"  stored="true"/>
-   <dynamicField name="*_dt" type="date"    indexed="true"  stored="true"/>
-
-   <!-- some trie-coded dynamic fields for faster range queries -->
-   <dynamicField name="*_ti" type="tint"    indexed="true"  stored="true"/>
-   <dynamicField name="*_tl" type="tlong"   indexed="true"  stored="true"/>
-   <dynamicField name="*_tf" type="tfloat"  indexed="true"  stored="true"/>
-   <dynamicField name="*_td" type="tdouble" indexed="true"  stored="true"/>
-   <dynamicField name="*_tdt" type="tdate"  indexed="true"  stored="true"/>
-
-   <dynamicField name="ignored_*" type="ignored" multiValued="true"/>
-   <dynamicField name="attr_*" type="text" indexed="true" stored="true" multiValued="true"/>
-
-   <dynamicField name="random_*" type="random" />
-
- </fields>
-
- <defaultSearchField>text</defaultSearchField>
- <uniqueKey>id</uniqueKey>
-
-   <copyField source="title" dest="title_stemmed"/>
-   <copyField source="title" dest="title_lettertok"/>
-
-   <copyField source="title" dest="text"/>
-   <copyField source="subject" dest="text"/>
-
-   <copyField source="copyfield_source" dest="text"/>
-   <copyField source="copyfield_source" dest="copyfield_dest_ss"/>  <!-- copyField into another stored copyField - not best practice --> 
- 
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="uuid" class="solr.UUIDField"/>
+  <fieldType name="ignored" class="solr.StrField" indexed="false" stored="false"/>
+
+
+  <fieldType name="random" class="solr.RandomSortField" indexed="true"/>
+
+  <!-- Poly field -->
+  <fieldType name="xy" class="solr.PointType" dimension="2" subFieldType="double"/>
+  <fieldType name="xyd" class="solr.PointType" dimension="2" subFieldSuffix="*_d"/>
+  <fieldType name="geohash" class="solr.GeoHashField"/>
+
+  <fieldType name="point" class="solr.PointType" dimension="2" subFieldSuffix="_d"/>
+  <!-- A specialized field for geospatial search. If indexed, this fieldType must not be multivalued. -->
+  <fieldType name="location" class="solr.LatLonType" subFieldSuffix="_coordinate"/>
+
+
+  <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="true"/>
+  <field name="signatureField" type="string" indexed="true" stored="false"/>
+  <field name="uuid" type="uuid" stored="true"/>
+  <field name="name" type="nametext" indexed="true" stored="true"/>
+  <field name="text" type="text" indexed="true" stored="false" multiValued="true"/>
+  <field name="subject" type="text" indexed="true" stored="true"/>
+  <field name="title" type="nametext" indexed="true" stored="true"/>
+  <field name="weight" type="float" indexed="true" stored="true"/>
+  <field name="bday" type="date" indexed="true" stored="true"/>
+
+  <field name="text_np" type="text_np" indexed="true" stored="false"/>
+
+  <field name="title_stemmed" type="text" indexed="true" stored="false"/>
+  <field name="title_lettertok" type="lettertok" indexed="true" stored="false"/>
+
+  <field name="syn" type="syn" indexed="true" stored="true"/>
+
+  <!-- to test property inheritance and overriding -->
+  <field name="shouldbeunstored" type="unstored"/>
+  <field name="shouldbestored" type="unstored" stored="true"/>
+  <field name="shouldbeunindexed" type="unstored" indexed="false" stored="true"/>
+
+
+  <!-- test different combinations of indexed and stored -->
+  <field name="bind" type="boolean" indexed="true" stored="false"/>
+  <field name="bsto" type="boolean" indexed="false" stored="true"/>
+  <field name="bindsto" type="boolean" indexed="true" stored="true"/>
+  <field name="isto" type="int" indexed="false" stored="true"/>
+  <field name="iind" type="int" indexed="true" stored="false"/>
+  <field name="ssto" type="string" indexed="false" stored="true"/>
+  <field name="sind" type="string" indexed="true" stored="false"/>
+  <field name="sindsto" type="string" indexed="true" stored="true"/>
+
+  <!-- test combinations of term vector settings -->
+  <field name="test_basictv" type="text" termVectors="true"/>
+  <field name="test_notv" type="text" termVectors="false"/>
+  <field name="test_postv" type="text" termVectors="true" termPositions="true"/>
+  <field name="test_offtv" type="text" termVectors="true" termOffsets="true"/>
+  <field name="test_posofftv" type="text" termVectors="true"
+         termPositions="true" termOffsets="true"/>
+
+  <!-- test highlit field settings -->
+  <field name="test_hlt" type="highlittext" indexed="true"/>
+  <field name="test_hlt_off" type="highlittext" indexed="true"/>
+
+  <!-- fields to test individual tokenizers and tokenfilters -->
+  <field name="teststop" type="teststop" indexed="true" stored="true"/>
+  <field name="lowertok" type="lowertok" indexed="true" stored="true"/>
+  <field name="keywordtok" type="keywordtok" indexed="true" stored="true"/>
+  <field name="standardtok" type="standardtok" indexed="true" stored="true"/>
+  <field name="HTMLstandardtok" type="HTMLstandardtok" indexed="true" stored="true"/>
+  <field name="lettertok" type="lettertok" indexed="true" stored="true"/>
+  <field name="whitetok" type="whitetok" indexed="true" stored="true"/>
+  <field name="HTMLwhitetok" type="HTMLwhitetok" indexed="true" stored="true"/>
+  <field name="standardtokfilt" type="standardtokfilt" indexed="true" stored="true"/>
+  <field name="standardfilt" type="standardfilt" indexed="true" stored="true"/>
+  <field name="lowerfilt" type="lowerfilt" indexed="true" stored="true"/>
+  <field name="patternreplacefilt" type="patternreplacefilt" indexed="true" stored="true"/>
+  <field name="porterfilt" type="porterfilt" indexed="true" stored="true"/>
+  <field name="engporterfilt" type="engporterfilt" indexed="true" stored="true"/>
+  <field name="custengporterfilt" type="custengporterfilt" indexed="true" stored="true"/>
+  <field name="stopfilt" type="stopfilt" indexed="true" stored="true"/>
+  <field name="custstopfilt" type="custstopfilt" indexed="true" stored="true"/>
+  <field name="lengthfilt" type="lengthfilt" indexed="true" stored="true"/>
+  <field name="dedup" type="dedup" indexed="true" stored="true"/>
+  <field name="wdf_nocase" type="wdf_nocase" indexed="true" stored="true"/>
+  <field name="wdf_preserve" type="wdf_preserve" indexed="true" stored="true"/>
+
+  <field name="numberpartfail" type="failtype1" indexed="true" stored="true"/>
+
+  <field name="nullfirst" type="string" indexed="true" stored="true" sortMissingFirst="true"/>
+
+  <field name="subword" type="subword" indexed="true" stored="true"/>
+  <field name="numericsubword" type="numericsubword" indexed="true" stored="true"/>
+  <field name="protectedsubword" type="protectedsubword" indexed="true" stored="true"/>
+
+  <field name="sku1" type="skutype1" indexed="true" stored="true"/>
+  <field name="sku2" type="skutype2" indexed="true" stored="true"/>
+
+  <field name="textgap" type="textgap" indexed="true" stored="true"/>
+
+  <!--
+  <field name="timestamp" type="date" indexed="true" stored="true" default="NOW"/>
+  -->
+  <field name="timestamp" type="date" indexed="true" stored="true"/>
+
+  <!-- Test a point field for distances -->
+  <field name="point" type="xy" indexed="true" stored="true" multiValued="false"/>
+  <field name="pointD" type="xyd" indexed="true" stored="true" multiValued="false"/>
+  <field name="point_hash" type="geohash" indexed="true" stored="true" multiValued="false"/>
+  <field name="store" type="location" indexed="true" stored="true"/>
+  <field name="amount" type="currency" indexed="true" stored="true" multiValued="false"/>
+
+  <!-- to test uniq fields -->
+  <field name="uniq" type="string" indexed="true" stored="true" multiValued="true"/>
+  <field name="uniq2" type="string" indexed="true" stored="true" multiValued="true"/>
+  <field name="uniq3" type="string" indexed="true" stored="true"/>
+  <field name="nouniq" type="string" indexed="true" stored="true" multiValued="true"/>
+
+
+  <field name="copyfield_source" type="string" indexed="true" stored="true" multiValued="true"/>
+
+  <!-- for versioning -->
+  <field name="_version_" type="long" indexed="true" stored="true"/>
+  <!-- points to the root document of a block of nested documents -->
+  <field name="_root_" type="string" indexed="true" stored="true"/>
+
+  <field name="multi_int_with_docvals" type="tint" multiValued="true" docValues="true" indexed="false"/>
+
+  <dynamicField name="*_coordinate" type="tdouble" indexed="true" stored="false"/>
+
+  <dynamicField name="*_sI" type="string" indexed="true" stored="false"/>
+  <dynamicField name="*_sS" type="string" indexed="false" stored="true"/>
+  <dynamicField name="t_*" type="text" indexed="true" stored="true"/>
+  <dynamicField name="tv_*" type="text" indexed="true" stored="true"
+                termVectors="true" termPositions="true" termOffsets="true"/>
+  <dynamicField name="tv_mv_*" type="text" indexed="true" stored="true" multiValued="true"
+                termVectors="true" termPositions="true" termOffsets="true"/>
+
+  <dynamicField name="*_mfacet" type="string" indexed="true" stored="false" multiValued="true"/>
+
+  <dynamicField name="*_sw" type="text_sw" indexed="true" stored="true" multiValued="true"/>
+
+  <dynamicField name="*_i" type="int" indexed="true" stored="true"/>
+  <dynamicField name="*_is" type="int" indexed="true" stored="true" multiValued="true"/>
+  <dynamicField name="*_s1" type="string" indexed="true" stored="true" multiValued="false"/>
+  <!-- :TODO: why are these identical?!?!?! -->
+  <dynamicField name="*_s" type="string" indexed="true" stored="true" multiValued="true"/>
+  <dynamicField name="*_ss" type="string" indexed="true" stored="true" multiValued="true"/>
+  <dynamicField name="*_l" type="long" indexed="true" stored="true"/>
+  <dynamicField name="*_ll" type="long" indexed="true" stored="true" multiValued="true"/>
+  <dynamicField name="*_t" type="text" indexed="true" stored="true"/>
+  <dynamicField name="*_tt" type="text" indexed="true" stored="true"/>
+  <dynamicField name="*_ws" type="nametext" indexed="true" stored="true"/>
+  <dynamicField name="*_b" type="boolean" indexed="true" stored="true"/>
+  <dynamicField name="*_f" type="float" indexed="true" stored="true"/>
+  <dynamicField name="*_d" type="double" indexed="true" stored="true"/>
+  <dynamicField name="*_dt" type="date" indexed="true" stored="true"/>
+
+  <!-- some trie-coded dynamic fields for faster range queries -->
+  <dynamicField name="*_ti" type="tint" indexed="true" stored="true"/>
+  <dynamicField name="*_tl" type="tlong" indexed="true" stored="true"/>
+  <dynamicField name="*_tf" type="tfloat" indexed="true" stored="true"/>
+  <dynamicField name="*_td" type="tdouble" indexed="true" stored="true"/>
+  <dynamicField name="*_tdt" type="tdate" indexed="true" stored="true"/>
+
+  <dynamicField name="ignored_*" type="ignored" multiValued="true"/>
+  <dynamicField name="attr_*" type="text" indexed="true" stored="true" multiValued="true"/>
+
+  <dynamicField name="random_*" type="random"/>
+
+
+  <defaultSearchField>text</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
+
+  <copyField source="title" dest="title_stemmed"/>
+  <copyField source="title" dest="title_lettertok"/>
+
+  <copyField source="title" dest="text"/>
+  <copyField source="subject" dest="text"/>
+
+  <copyField source="copyfield_source" dest="text"/>
+  <copyField source="copyfield_source"
+             dest="copyfield_dest_ss"/>  <!-- copyField into another stored copyField - not best practice -->
+
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema_codec.xml b/solr/core/src/test-files/solr/collection1/conf/schema_codec.xml
index 289125c..629396a 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema_codec.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema_codec.xml
@@ -16,46 +16,43 @@
  limitations under the License.
 -->
 <schema name="codec" version="1.2">
- <types>
   <fieldType name="string_direct" class="solr.StrField" postingsFormat="Direct"/>
   <fieldType name="string_simpletext" class="solr.StrField" postingsFormat="SimpleText"/>
   <fieldType name="string_standard" class="solr.StrField" postingsFormat="Lucene50"/>
 
-  <fieldType name="string_disk" class="solr.StrField" docValuesFormat="Lucene54" />
-  <fieldType name="string_memory" class="solr.StrField" docValuesFormat="Memory" />
+  <fieldType name="string_disk" class="solr.StrField" docValuesFormat="Lucene54"/>
+  <fieldType name="string_memory" class="solr.StrField" docValuesFormat="Memory"/>
+
+  <fieldType name="string" class="solr.StrField"/>
 
-  <fieldType name="string" class="solr.StrField" />
-  
   <fieldType name="text_general" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
+    <analyzer type="index">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
   </fieldType>
 
- </types>
- <fields>
-   <field name="string_direct_f" type="string_direct" indexed="true" stored="true" />
-   <field name="string_simpletext_f" type="string_simpletext" indexed="true" stored="true" />
-   <field name="string_standard_f" type="string_standard" indexed="true" stored="true" />
+  <field name="string_direct_f" type="string_direct" indexed="true" stored="true"/>
+  <field name="string_simpletext_f" type="string_simpletext" indexed="true" stored="true"/>
+  <field name="string_standard_f" type="string_standard" indexed="true" stored="true"/>
+
+  <field name="string_disk_f" type="string_disk" indexed="false" stored="false" docValues="true" default=""/>
+  <field name="string_memory_f" type="string_memory" indexed="false" stored="false" docValues="true" default=""/>
 
-   <field name="string_disk_f" type="string_disk" indexed="false" stored="false" docValues="true" default="" />
-   <field name="string_memory_f" type="string_memory" indexed="false" stored="false" docValues="true" default="" />
+  <field name="string_f" type="string" indexed="true" stored="true" docValues="true" required="true"/>
+  <field name="text" type="text_general" indexed="true" stored="true"/>
 
-   <field name="string_f" type="string" indexed="true" stored="true" docValues="true" required="true"/>
-   <field name="text" type="text_general" indexed="true" stored="true"/>
+  <dynamicField name="*_simple" type="string_simpletext" indexed="true" stored="true"/>
+  <dynamicField name="*_direct" type="string_direct" indexed="true" stored="true"/>
+  <dynamicField name="*_standard" type="string_standard" indexed="true" stored="true"/>
 
-   <dynamicField name="*_simple" type="string_simpletext"  indexed="true" stored="true"/>
-   <dynamicField name="*_direct" type="string_direct"  indexed="true" stored="true"/>
-   <dynamicField name="*_standard" type="string_standard"  indexed="true" stored="true"/>
+  <dynamicField name="*_disk" type="string_disk" indexed="false" stored="false" docValues="true"/>
+  <dynamicField name="*_memory" type="string_memory" indexed="false" stored="false" docValues="true"/>
 
-   <dynamicField name="*_disk" type="string_disk" indexed="false" stored="false" docValues="true" />
-   <dynamicField name="*_memory" type="string_memory" indexed="false" stored="false" docValues="true" />
- </fields>
   <defaultSearchField>string_f</defaultSearchField>
- <uniqueKey>string_f</uniqueKey>
+  <uniqueKey>string_f</uniqueKey>
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema_latest.xml b/solr/core/src/test-files/solr/collection1/conf/schema_latest.xml
index cae373c..280fd34 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema_latest.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema_latest.xml
@@ -64,699 +64,699 @@
        1.6: useDocValuesAsStored defaults to true.
      -->
 
-<fields>
-   <!-- Valid attributes for fields:
-     name: mandatory - the name for the field
-     type: mandatory - the name of a field type from the 
-       <types> fieldType section
-     indexed: true if this field should be indexed (searchable or sortable)
-     stored: true if this field should be retrievable
-     docValues: true if this field should have doc values. Doc values are
-       useful for faceting, grouping, sorting and function queries. Although not
-       required, doc values will make the index faster to load, more
-       NRT-friendly and more memory-efficient. They however come with some
-       limitations: they are currently only supported by StrField, UUIDField
-       and all Trie*Fields, and depending on the field type, they might
-       require the field to be single-valued, be required or have a default
-       value (check the documentation of the field type you're interested in
-       for more information)
-     multiValued: true if this field may contain multiple values per document
-     omitNorms: (expert) set to true to omit the norms associated with
-       this field (this disables length normalization and index-time
-       boosting for the field, and saves some memory).  Only full-text
-       fields or fields that need an index-time boost need norms.
-       Norms are omitted for primitive (non-analyzed) types by default.
-     termVectors: [false] set to true to store the term vector for a
-       given field.
-       When using MoreLikeThis, fields used for similarity should be
-       stored for best performance.
-     termPositions: Store position information with the term vector.  
-       This will increase storage costs.
-     termOffsets: Store offset information with the term vector. This 
-       will increase storage costs.
-     required: The field is required.  It will throw an error if the
-       value does not exist
-     default: a value that should be used if no value is specified
-       when adding a document.
-   -->
+  <!-- Valid attributes for fields:
+    name: mandatory - the name for the field
+    type: mandatory - the name of a field type from the 
+      fieldTypes
+    indexed: true if this field should be indexed (searchable or sortable)
+    stored: true if this field should be retrievable
+    docValues: true if this field should have doc values. Doc values are
+      useful for faceting, grouping, sorting and function queries. Although not
+      required, doc values will make the index faster to load, more
+      NRT-friendly and more memory-efficient. They however come with some
+      limitations: they are currently only supported by StrField, UUIDField
+      and all Trie*Fields, and depending on the field type, they might
+      require the field to be single-valued, be required or have a default
+      value (check the documentation of the field type you're interested in
+      for more information)
+    multiValued: true if this field may contain multiple values per document
+    omitNorms: (expert) set to true to omit the norms associated with
+      this field (this disables length normalization and index-time
+      boosting for the field, and saves some memory).  Only full-text
+      fields or fields that need an index-time boost need norms.
+      Norms are omitted for primitive (non-analyzed) types by default.
+    termVectors: [false] set to true to store the term vector for a
+      given field.
+      When using MoreLikeThis, fields used for similarity should be
+      stored for best performance.
+    termPositions: Store position information with the term vector.  
+      This will increase storage costs.
+    termOffsets: Store offset information with the term vector. This 
+      will increase storage costs.
+    required: The field is required.  It will throw an error if the
+      value does not exist
+    default: a value that should be used if no value is specified
+      when adding a document.
+  -->
 
-   <!-- field names should consist of alphanumeric or underscore characters only and
-      not start with a digit.  This is not currently strictly enforced,
-      but other field names will not have first class support from all components
-      and back compatibility is not guaranteed.  Names with both leading and
-      trailing underscores (e.g. _version_) are reserved.
-   -->
+  <!-- field names should consist of alphanumeric or underscore characters only and
+     not start with a digit.  This is not currently strictly enforced,
+     but other field names will not have first class support from all components
+     and back compatibility is not guaranteed.  Names with both leading and
+     trailing underscores (e.g. _version_) are reserved.
+  -->
 
-   <!-- If you remove this field, you must _also_ disable the update log in solrconfig.xml
-      or Solr won't start. _version_ and update log are required for SolrCloud
-   --> 
-   <field name="_version_" type="long" indexed="false" stored="false" docValues="true" />
-   
-   <!-- points to the root document of a block of nested documents. Required for nested
-      document support, may be removed otherwise
-   -->
-   <field name="_root_" type="string" indexed="true" stored="false"/>
-
-   <!-- Only remove the "id" field if you have a very good reason to. While not strictly
-     required, it is highly recommended. A <uniqueKey> is present in almost all Solr 
-     installations. See the <uniqueKey> declaration below where <uniqueKey> is set to "id".
-   -->   
-   <field name="id" type="string" indexed="true" stored="true" required="true" multiValued="false" /> 
-        
-   <field name="sku" type="text_en_splitting_tight" indexed="true" stored="true" omitNorms="true"/>
-   <field name="name" type="text_general" indexed="true" stored="true"/>
-   <field name="manu" type="text_general" indexed="true" stored="true" omitNorms="true"/>
-   <field name="cat" type="string" indexed="true" stored="true" multiValued="true"/>
-   <field name="features" type="text_general" indexed="true" stored="true" multiValued="true"/>
-   <field name="includes" type="text_general" indexed="true" stored="true" termVectors="true" termPositions="true" termOffsets="true" />
-
-   <field name="weight" type="float" indexed="true" stored="true"/>
-   <field name="price"  type="float" indexed="true" stored="true"/>
-   <field name="popularity" type="int" indexed="true" stored="true" />
-   <field name="inStock" type="boolean" indexed="true" stored="true" />
-
-   <field name="store" type="location" indexed="true" stored="true"/>
-
-   <!-- Common metadata fields, named specifically to match up with
-     SolrCell metadata when parsing rich documents such as Word, PDF.
-     Some fields are multiValued only because Tika currently may return
-     multiple values for them. Some metadata is parsed from the documents,
-     but there are some which come from the client context:
-       "content_type": From the HTTP headers of incoming stream
-       "resourcename": From SolrCell request param resource.name
-   -->
-   <field name="title" type="text_general" indexed="true" stored="true" multiValued="true"/>
-   <field name="subject" type="text_general" indexed="true" stored="true"/>
-   <field name="description" type="text_general" indexed="true" stored="true"/>
-   <field name="comments" type="text_general" indexed="true" stored="true"/>
-   <field name="author" type="text_general" indexed="true" stored="true"/>
-   <field name="keywords" type="text_general" indexed="true" stored="true"/>
-   <field name="category" type="text_general" indexed="true" stored="true"/>
-   <field name="resourcename" type="text_general" indexed="true" stored="true"/>
-   <field name="url" type="text_general" indexed="true" stored="true"/>
-   <field name="content_type" type="string" indexed="true" stored="true" multiValued="true"/>
-   <field name="last_modified" type="date" indexed="true" stored="true"/>
-   <field name="links" type="string" indexed="true" stored="true" multiValued="true"/>
-
-   <!-- Main body of document extracted by SolrCell.
-        NOTE: This field is not indexed by default, since it is also copied to "text"
-        using copyField below. This is to save space. Use this field for returning and
-        highlighting document content. Use the "text" field to search the content. -->
-   <field name="content" type="text_general" indexed="false" stored="true" multiValued="true"/>
-   
-
-   <!-- catchall field, containing all other searchable text fields (implemented
-        via copyField further on in this schema  -->
-   <field name="text" type="text_general" indexed="true" stored="false" multiValued="true"/>
-
-   <!-- catchall text field that indexes tokens both normally and in reverse for efficient
-        leading wildcard queries. -->
-   <field name="text_rev" type="text_general_rev" indexed="true" stored="false" multiValued="true"/>
-
-   <!-- non-tokenized version of manufacturer to make it easier to sort or group
-        results by manufacturer.  copied from "manu" via copyField -->
-   <field name="manu_exact" type="string" indexed="true" stored="false"/>
-
-   <field name="payloads" type="payloads" indexed="true" stored="true"/>
-
-
-   <!--
-     Some fields such as popularity and manu_exact could be modified to
-     leverage doc values:
-     <field name="popularity" type="int" indexed="true" stored="true" docValues="true" />
-     <field name="manu_exact" type="string" indexed="false" stored="false" docValues="true" />
-     <field name="cat" type="string" indexed="true" stored="true" docValues="true" multiValued="true"/>
-
-
-     Although it would make indexing slightly slower and the index bigger, it
-     would also make the index faster to load, more memory-efficient and more
-     NRT-friendly.
-     -->
+  <!-- If you remove this field, you must _also_ disable the update log in solrconfig.xml
+     or Solr won't start. _version_ and update log are required for SolrCloud
+  -->
+  <field name="_version_" type="long" indexed="false" stored="false" docValues="true"/>
 
-   <!-- Dynamic field definitions allow using convention over configuration
-       for fields via the specification of patterns to match field names. 
-       EXAMPLE:  name="*_i" will match any field ending in _i (like myid_i, z_i)
-       RESTRICTION: the glob-like pattern in the name attribute must have
-       a "*" only at the start or the end.  -->
-   
-   <!-- docvalues and stored are exclusive -->
-   <dynamicField name="*_i"  type="int"    indexed="true"  stored="true"/>
-   <dynamicField name="*_is" type="int"    indexed="true"  stored="true"  multiValued="true"/>
-   <dynamicField name="*_id"  type="int"    indexed="true"  stored="false"                        docValues="true" />
-   <dynamicField name="*_ids" type="int"    indexed="true"  stored="false"  multiValued="true"    docValues="true" />
-   <dynamicField name="*_s"  type="string"  indexed="true"  stored="true" />
-   <dynamicField name="*_s1"  type="string"  indexed="true"  stored="true" />
-   <dynamicField name="*_ss" type="string"  indexed="true"  stored="true" multiValued="true"/>
-   <dynamicField name="*_sd"  type="string"  indexed="true"  stored="false"                       docValues="true" />
-   <dynamicField name="*_sds" type="string"  indexed="true"  stored="false" multiValued="true"    docValues="true" />
-   <dynamicField name="*_l"  type="long"   indexed="true"  stored="true"/>
-   <dynamicField name="*_ls" type="long"   indexed="true"  stored="true"  multiValued="true"/>
-   <dynamicField name="*_ld"  type="long"   indexed="true"  stored="false"                        docValues="true" />
-   <dynamicField name="*_lds" type="long"   indexed="true"  stored="false"  multiValued="true"    docValues="true" />
-   <dynamicField name="*_f"  type="float"  indexed="true"  stored="true"/>
-   <dynamicField name="*_fs" type="float"  indexed="true"  stored="true"  multiValued="true"/>
-   <dynamicField name="*_fd"  type="float"  indexed="true"  stored="false"                        docValues="true" />
-   <dynamicField name="*_fds" type="float"  indexed="true"  stored="false"  multiValued="true"    docValues="true" />
-   <dynamicField name="*_d"  type="double" indexed="true"  stored="true"/>
-   <dynamicField name="*_ds" type="double" indexed="true"  stored="true"  multiValued="true"/>
-   <dynamicField name="*_dd"  type="double" indexed="true"  stored="false"                        docValues="true" />
-   <dynamicField name="*_dds" type="double" indexed="true"  stored="false"  multiValued="true"    docValues="true" />
-   <dynamicField name="*_dt"   type="date"   indexed="true"  stored="true"/>
-   <dynamicField name="*_dts"  type="date"   indexed="true"  stored="true" multiValued="true"/>
-   <dynamicField name="*_dtd"  type="date"   indexed="true"  stored="false"                       docValues="true" />
-   <dynamicField name="*_dtds" type="date"   indexed="true"  stored="false" multiValued="true"    docValues="true" />
- 
-   <!-- docvalues and stored (S suffix) -->
-   <dynamicField name="*_idS"  type="int"    indexed="true"  stored="true"                        docValues="true" />
-   <dynamicField name="*_idsS" type="int"    indexed="true"  stored="true"  multiValued="true"    docValues="true" />
-   <dynamicField name="*_sdS"  type="string"  indexed="true"  stored="true"                       docValues="true" />
-   <dynamicField name="*_sdsS" type="string"  indexed="true"  stored="true" multiValued="true"    docValues="true" />
-   <dynamicField name="*_ldS"  type="long"   indexed="true"  stored="true"                        docValues="true" />
-   <dynamicField name="*_ldsS" type="long"   indexed="true"  stored="true"  multiValued="true"    docValues="true" />
-   <dynamicField name="*_fdS"  type="float"  indexed="true"  stored="true"                        docValues="true" />
-   <dynamicField name="*_fdsS" type="float"  indexed="true"  stored="true"  multiValued="true"    docValues="true" />
-   <dynamicField name="*_ddS"  type="double" indexed="true"  stored="true"                        docValues="true" />
-   <dynamicField name="*_ddsS" type="double" indexed="true"  stored="true"  multiValued="true"    docValues="true" />
-   <dynamicField name="*_dtdS"  type="date"   indexed="true"  stored="true"                       docValues="true" />
-   <dynamicField name="*_dtdsS" type="date"   indexed="true"  stored="true" multiValued="true"    docValues="true" />
-
-
-   <dynamicField name="*_b"  type="boolean" indexed="true" stored="true"/>
-   <dynamicField name="*_bs" type="boolean" indexed="true" stored="true"  multiValued="true"/>
-
-   <dynamicField name="*_t"  type="text_general"    indexed="true"  stored="true"/>
-   <dynamicField name="*_txt" type="text_general"   indexed="true"  stored="true" multiValued="true"/>
-   <dynamicField name="*_en"  type="text_en"    indexed="true"  stored="true" multiValued="true"/>
- 
-   <!-- Type used to index the lat and lon components for the "location" FieldType -->
-   <dynamicField name="*_coordinate"  type="tdouble" indexed="true"  stored="false" />
-
-   <dynamicField name="*_p"  type="location" indexed="true" stored="true"/>
-
-   <!-- some trie-coded dynamic fields for faster range queries -->
-   <dynamicField name="*_ti" type="tint"    indexed="true"  stored="true"/>
-   <dynamicField name="*_tl" type="tlong"   indexed="true"  stored="true"/>
-   <dynamicField name="*_tf" type="tfloat"  indexed="true"  stored="true"/>
-   <dynamicField name="*_td" type="tdouble" indexed="true"  stored="true"/>
-   <dynamicField name="*_tdt" type="tdate"  indexed="true"  stored="true"/>
-
-   <dynamicField name="*_c"   type="currency" indexed="true"  stored="true"/>
-
-   <dynamicField name="ignored_*" type="ignored" multiValued="true"/>
-   <dynamicField name="attr_*" type="text_general" indexed="true" stored="true" multiValued="true"/>
-
-   <dynamicField name="random_*" type="random" />
-
-   <!-- uncomment the following to ignore any fields that don't already match an existing 
-        field name or dynamic field, rather than reporting them as an error. 
-        alternately, change the type="ignored" to some other type e.g. "text" if you want 
-        unknown fields indexed and/or stored by default --> 
-   <!--dynamicField name="*" type="ignored" multiValued="true" /-->
-   
-
-   <!-- needed by dedup config -->
-   <field name="signatureField" type="string" indexed="true" stored="false"/>
-   <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
-
-
- </fields>
-
-
- <!-- Field to use to determine and enforce document uniqueness. 
-      Unless this field is marked with required="false", it will be a required field
-   -->
- <uniqueKey>id</uniqueKey>
-
- <!-- DEPRECATED: The defaultSearchField is consulted by various query parsers when
-  parsing a query string that isn't explicit about the field.  Machine (non-user)
-  generated queries are best made explicit, or they can use the "df" request parameter
-  which takes precedence over this.
-  Note: Un-commenting defaultSearchField will be insufficient if your request handler
-  in solrconfig.xml defines "df", which takes precedence. That would need to be removed.
- <defaultSearchField>text</defaultSearchField> -->
-
- <!-- DEPRECATED: The defaultOperator (AND|OR) is consulted by various query parsers
-  when parsing a query string to determine if a clause of the query should be marked as
-  required or optional, assuming the clause isn't already marked by some operator.
-  The default is OR, which is generally assumed so it is not a good idea to change it
-  globally here.  The "q.op" request parameter takes precedence over this.
- <solrQueryParser defaultOperator="OR"/> -->
+  <!-- points to the root document of a block of nested documents. Required for nested
+     document support, may be removed otherwise
+  -->
+  <field name="_root_" type="string" indexed="true" stored="false"/>
+
+  <!-- Only remove the "id" field if you have a very good reason to. While not strictly
+    required, it is highly recommended. A <uniqueKey> is present in almost all Solr 
+    installations. See the <uniqueKey> declaration below where <uniqueKey> is set to "id".
+  -->
+  <field name="id" type="string" indexed="true" stored="true" required="true" multiValued="false"/>
+
+  <field name="sku" type="text_en_splitting_tight" indexed="true" stored="true" omitNorms="true"/>
+  <field name="name" type="text_general" indexed="true" stored="true"/>
+  <field name="manu" type="text_general" indexed="true" stored="true" omitNorms="true"/>
+  <field name="cat" type="string" indexed="true" stored="true" multiValued="true"/>
+  <field name="features" type="text_general" indexed="true" stored="true" multiValued="true"/>
+  <field name="includes" type="text_general" indexed="true" stored="true" termVectors="true" termPositions="true"
+         termOffsets="true"/>
+
+  <field name="weight" type="float" indexed="true" stored="true"/>
+  <field name="price" type="float" indexed="true" stored="true"/>
+  <field name="popularity" type="int" indexed="true" stored="true"/>
+  <field name="inStock" type="boolean" indexed="true" stored="true"/>
+
+  <field name="store" type="location" indexed="true" stored="true"/>
+
+  <!-- Common metadata fields, named specifically to match up with
+    SolrCell metadata when parsing rich documents such as Word, PDF.
+    Some fields are multiValued only because Tika currently may return
+    multiple values for them. Some metadata is parsed from the documents,
+    but there are some which come from the client context:
+      "content_type": From the HTTP headers of incoming stream
+      "resourcename": From SolrCell request param resource.name
+  -->
+  <field name="title" type="text_general" indexed="true" stored="true" multiValued="true"/>
+  <field name="subject" type="text_general" indexed="true" stored="true"/>
+  <field name="description" type="text_general" indexed="true" stored="true"/>
+  <field name="comments" type="text_general" indexed="true" stored="true"/>
+  <field name="author" type="text_general" indexed="true" stored="true"/>
+  <field name="keywords" type="text_general" indexed="true" stored="true"/>
+  <field name="category" type="text_general" indexed="true" stored="true"/>
+  <field name="resourcename" type="text_general" indexed="true" stored="true"/>
+  <field name="url" type="text_general" indexed="true" stored="true"/>
+  <field name="content_type" type="string" indexed="true" stored="true" multiValued="true"/>
+  <field name="last_modified" type="date" indexed="true" stored="true"/>
+  <field name="links" type="string" indexed="true" stored="true" multiValued="true"/>
+
+  <!-- Main body of document extracted by SolrCell.
+       NOTE: This field is not indexed by default, since it is also copied to "text"
+       using copyField below. This is to save space. Use this field for returning and
+       highlighting document content. Use the "text" field to search the content. -->
+  <field name="content" type="text_general" indexed="false" stored="true" multiValued="true"/>
+
+
+  <!-- catchall field, containing all other searchable text fields (implemented
+       via copyField further on in this schema  -->
+  <field name="text" type="text_general" indexed="true" stored="false" multiValued="true"/>
+
+  <!-- catchall text field that indexes tokens both normally and in reverse for efficient
+       leading wildcard queries. -->
+  <field name="text_rev" type="text_general_rev" indexed="true" stored="false" multiValued="true"/>
+
+  <!-- non-tokenized version of manufacturer to make it easier to sort or group
+       results by manufacturer.  copied from "manu" via copyField -->
+  <field name="manu_exact" type="string" indexed="true" stored="false"/>
+
+  <field name="payloads" type="payloads" indexed="true" stored="true"/>
+
+
+  <!--
+    Some fields such as popularity and manu_exact could be modified to
+    leverage doc values:
+    <field name="popularity" type="int" indexed="true" stored="true" docValues="true" />
+    <field name="manu_exact" type="string" indexed="false" stored="false" docValues="true" />
+    <field name="cat" type="string" indexed="true" stored="true" docValues="true" multiValued="true"/>
+
+
+    Although it would make indexing slightly slower and the index bigger, it
+    would also make the index faster to load, more memory-efficient and more
+    NRT-friendly.
+    -->
+
+  <!-- Dynamic field definitions allow using convention over configuration
+      for fields via the specification of patterns to match field names. 
+      EXAMPLE:  name="*_i" will match any field ending in _i (like myid_i, z_i)
+      RESTRICTION: the glob-like pattern in the name attribute must have
+      a "*" only at the start or the end.  -->
+
+  <!-- docvalues and stored are exclusive -->
+  <dynamicField name="*_i" type="int" indexed="true" stored="true"/>
+  <dynamicField name="*_is" type="int" indexed="true" stored="true" multiValued="true"/>
+  <dynamicField name="*_id" type="int" indexed="true" stored="false" docValues="true"/>
+  <dynamicField name="*_ids" type="int" indexed="true" stored="false" multiValued="true" docValues="true"/>
+  <dynamicField name="*_s" type="string" indexed="true" stored="true"/>
+  <dynamicField name="*_s1" type="string" indexed="true" stored="true"/>
+  <dynamicField name="*_ss" type="string" indexed="true" stored="true" multiValued="true"/>
+  <dynamicField name="*_sd" type="string" indexed="true" stored="false" docValues="true"/>
+  <dynamicField name="*_sds" type="string" indexed="true" stored="false" multiValued="true" docValues="true"/>
+  <dynamicField name="*_l" type="long" indexed="true" stored="true"/>
+  <dynamicField name="*_ls" type="long" indexed="true" stored="true" multiValued="true"/>
+  <dynamicField name="*_ld" type="long" indexed="true" stored="false" docValues="true"/>
+  <dynamicField name="*_lds" type="long" indexed="true" stored="false" multiValued="true" docValues="true"/>
+  <dynamicField name="*_f" type="float" indexed="true" stored="true"/>
+  <dynamicField name="*_fs" type="float" indexed="true" stored="true" multiValued="true"/>
+  <dynamicField name="*_fd" type="float" indexed="true" stored="false" docValues="true"/>
+  <dynamicField name="*_fds" type="float" indexed="true" stored="false" multiValued="true" docValues="true"/>
+  <dynamicField name="*_d" type="double" indexed="true" stored="true"/>
+  <dynamicField name="*_ds" type="double" indexed="true" stored="true" multiValued="true"/>
+  <dynamicField name="*_dd" type="double" indexed="true" stored="false" docValues="true"/>
+  <dynamicField name="*_dds" type="double" indexed="true" stored="false" multiValued="true" docValues="true"/>
+  <dynamicField name="*_dt" type="date" indexed="true" stored="true"/>
+  <dynamicField name="*_dts" type="date" indexed="true" stored="true" multiValued="true"/>
+  <dynamicField name="*_dtd" type="date" indexed="true" stored="false" docValues="true"/>
+  <dynamicField name="*_dtds" type="date" indexed="true" stored="false" multiValued="true" docValues="true"/>
+
+  <!-- docvalues and stored (S suffix) -->
+  <dynamicField name="*_idS" type="int" indexed="true" stored="true" docValues="true"/>
+  <dynamicField name="*_idsS" type="int" indexed="true" stored="true" multiValued="true" docValues="true"/>
+  <dynamicField name="*_sdS" type="string" indexed="true" stored="true" docValues="true"/>
+  <dynamicField name="*_sdsS" type="string" indexed="true" stored="true" multiValued="true" docValues="true"/>
+  <dynamicField name="*_ldS" type="long" indexed="true" stored="true" docValues="true"/>
+  <dynamicField name="*_ldsS" type="long" indexed="true" stored="true" multiValued="true" docValues="true"/>
+  <dynamicField name="*_fdS" type="float" indexed="true" stored="true" docValues="true"/>
+  <dynamicField name="*_fdsS" type="float" indexed="true" stored="true" multiValued="true" docValues="true"/>
+  <dynamicField name="*_ddS" type="double" indexed="true" stored="true" docValues="true"/>
+  <dynamicField name="*_ddsS" type="double" indexed="true" stored="true" multiValued="true" docValues="true"/>
+  <dynamicField name="*_dtdS" type="date" indexed="true" stored="true" docValues="true"/>
+  <dynamicField name="*_dtdsS" type="date" indexed="true" stored="true" multiValued="true" docValues="true"/>
+
+
+  <dynamicField name="*_b" type="boolean" indexed="true" stored="true"/>
+  <dynamicField name="*_bs" type="boolean" indexed="true" stored="true" multiValued="true"/>
+
+  <dynamicField name="*_t" type="text_general" indexed="true" stored="true"/>
+  <dynamicField name="*_txt" type="text_general" indexed="true" stored="true" multiValued="true"/>
+  <dynamicField name="*_en" type="text_en" indexed="true" stored="true" multiValued="true"/>
+
+  <!-- Type used to index the lat and lon components for the "location" FieldType -->
+  <dynamicField name="*_coordinate" type="tdouble" indexed="true" stored="false"/>
+
+  <dynamicField name="*_p" type="location" indexed="true" stored="true"/>
+
+  <!-- some trie-coded dynamic fields for faster range queries -->
+  <dynamicField name="*_ti" type="tint" indexed="true" stored="true"/>
+  <dynamicField name="*_tl" type="tlong" indexed="true" stored="true"/>
+  <dynamicField name="*_tf" type="tfloat" indexed="true" stored="true"/>
+  <dynamicField name="*_td" type="tdouble" indexed="true" stored="true"/>
+  <dynamicField name="*_tdt" type="tdate" indexed="true" stored="true"/>
+
+  <dynamicField name="*_c" type="currency" indexed="true" stored="true"/>
+
+  <dynamicField name="ignored_*" type="ignored" multiValued="true"/>
+  <dynamicField name="attr_*" type="text_general" indexed="true" stored="true" multiValued="true"/>
+
+  <dynamicField name="random_*" type="random"/>
+
+  <!-- uncomment the following to ignore any fields that don't already match an existing 
+       field name or dynamic field, rather than reporting them as an error. 
+       alternately, change the type="ignored" to some other type e.g. "text" if you want 
+       unknown fields indexed and/or stored by default -->
+  <!--dynamicField name="*" type="ignored" multiValued="true" /-->
+
+
+  <!-- needed by dedup config -->
+  <field name="signatureField" type="string" indexed="true" stored="false"/>
+  <dynamicField name="*_sS" type="string" indexed="false" stored="true"/>
+
+
+  <!-- Field to use to determine and enforce document uniqueness. 
+       Unless this field is marked with required="false", it will be a required field
+    -->
+  <uniqueKey>id</uniqueKey>
+
+  <!-- DEPRECATED: The defaultSearchField is consulted by various query parsers when
+   parsing a query string that isn't explicit about the field.  Machine (non-user)
+   generated queries are best made explicit, or they can use the "df" request parameter
+   which takes precedence over this.
+   Note: Un-commenting defaultSearchField will be insufficient if your request handler
+   in solrconfig.xml defines "df", which takes precedence. That would need to be removed.
+  <defaultSearchField>text</defaultSearchField> -->
+
+  <!-- DEPRECATED: The defaultOperator (AND|OR) is consulted by various query parsers
+   when parsing a query string to determine if a clause of the query should be marked as
+   required or optional, assuming the clause isn't already marked by some operator.
+   The default is OR, which is generally assumed so it is not a good idea to change it
+   globally here.  The "q.op" request parameter takes precedence over this.
+  <solrQueryParser defaultOperator="OR"/> -->
 
   <!-- copyField commands copy one field to another at the time a document
         is added to the index.  It's used either to index the same field differently,
         or to add multiple fields to the same field for easier/faster searching.  -->
 
-   <copyField source="cat" dest="text"/>
-   <copyField source="name" dest="text"/>
-   <copyField source="manu" dest="text"/>
-   <copyField source="features" dest="text"/>
-   <copyField source="includes" dest="text"/>
-   <copyField source="manu" dest="manu_exact"/>
-
-   <!-- Copy the price into a currency enabled field (default USD) -->
-   <copyField source="price" dest="price_c"/>
-
-   <!-- Text fields from SolrCell to search by default in our catch-all field -->
-   <copyField source="title" dest="text"/>
-   <copyField source="author" dest="text"/>
-   <copyField source="description" dest="text"/>
-   <copyField source="keywords" dest="text"/>
-   <copyField source="content" dest="text"/>
-   <copyField source="content_type" dest="text"/>
-   <copyField source="resourcename" dest="text"/>
-   <copyField source="url" dest="text"/>
-
-   <!-- Create a string version of author for faceting -->
-   <copyField source="author" dest="author_s"/>
-  
-   <!-- Above, multiple source fields are copied to the [text] field. 
-    Another way to map multiple source fields to the same 
-    destination field is to use the dynamic field syntax. 
-    copyField also supports a maxChars to copy setting.  -->
-     
-   <!-- <copyField source="*_t" dest="text" maxChars="3000"/> -->
-
-   <!-- copy name to alphaNameSort, a field designed for sorting by name -->
-   <!-- <copyField source="name" dest="alphaNameSort"/> -->
- 
-  <types>
-    <!-- field type definitions. The "name" attribute is
-       just a label to be used by field definitions.  The "class"
-       attribute and any other attributes determine the real
-       behavior of the fieldType.
-         Class names starting with "solr" refer to java classes in a
-       standard package such as org.apache.solr.analysis
-    -->
+  <copyField source="cat" dest="text"/>
+  <copyField source="name" dest="text"/>
+  <copyField source="manu" dest="text"/>
+  <copyField source="features" dest="text"/>
+  <copyField source="includes" dest="text"/>
+  <copyField source="manu" dest="manu_exact"/>
+
+  <!-- Copy the price into a currency enabled field (default USD) -->
+  <copyField source="price" dest="price_c"/>
+
+  <!-- Text fields from SolrCell to search by default in our catch-all field -->
+  <copyField source="title" dest="text"/>
+  <copyField source="author" dest="text"/>
+  <copyField source="description" dest="text"/>
+  <copyField source="keywords" dest="text"/>
+  <copyField source="content" dest="text"/>
+  <copyField source="content_type" dest="text"/>
+  <copyField source="resourcename" dest="text"/>
+  <copyField source="url" dest="text"/>
+
+  <!-- Create a string version of author for faceting -->
+  <copyField source="author" dest="author_s"/>
+
+  <!-- Above, multiple source fields are copied to the [text] field. 
+   Another way to map multiple source fields to the same 
+   destination field is to use the dynamic field syntax. 
+   copyField also supports a maxChars to copy setting.  -->
+
+  <!-- <copyField source="*_t" dest="text" maxChars="3000"/> -->
+
+  <!-- copy name to alphaNameSort, a field designed for sorting by name -->
+  <!-- <copyField source="name" dest="alphaNameSort"/> -->
+
+  <!-- field type definitions. The "name" attribute is
+     just a label to be used by field definitions.  The "class"
+     attribute and any other attributes determine the real
+     behavior of the fieldType.
+       Class names starting with "solr" refer to java classes in a
+     standard package such as org.apache.solr.analysis
+  -->
 
-    <!-- The StrField type is not analyzed, but indexed/stored verbatim.
-       It supports doc values but in that case the field needs to be
-       single-valued and either required or have a default value.
-      -->
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true" />
-
-    <!-- boolean type: "true" or "false" -->
-    <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
-
-    <!-- sortMissingLast and sortMissingFirst attributes are optional attributes are
-         currently supported on types that are sorted internally as strings
-         and on numeric types.
-       This includes "string","boolean", and, as of 3.5 (and 4.x),
-       int, float, long, date, double, including the "Trie" variants.
-       - If sortMissingLast="true", then a sort on this field will cause documents
-         without the field to come after documents with the field,
-         regardless of the requested sort order (asc or desc).
-       - If sortMissingFirst="true", then a sort on this field will cause documents
-         without the field to come before documents with the field,
-         regardless of the requested sort order.
-       - If sortMissingLast="false" and sortMissingFirst="false" (the default),
-         then default lucene sorting will be used which places docs without the
-         field first in an ascending sort and last in a descending sort.
-    -->    
-
-    <!--
-      Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
-
-      These fields support doc values, but they require the field to be
-      single-valued and either be required or have a default value.
+  <!-- The StrField type is not analyzed, but indexed/stored verbatim.
+     It supports doc values but in that case the field needs to be
+     single-valued and either required or have a default value.
     -->
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
-    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
-
-    <!--
-     Numeric field types that index each value at various levels of precision
-     to accelerate range queries when the number of values between the range
-     endpoints is large. See the javadoc for LegacyNumericRangeQuery for internal
-     implementation details.
-
-     Smaller precisionStep values (specified in bits) will lead to more tokens
-     indexed per value, slightly larger index size, and faster range queries.
-     A precisionStep of 0 disables indexing at different precision levels.
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+
+  <!-- boolean type: "true" or "false" -->
+  <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
+
+  <!-- sortMissingLast and sortMissingFirst attributes are optional attributes are
+       currently supported on types that are sorted internally as strings
+       and on numeric types.
+     This includes "string","boolean", and, as of 3.5 (and 4.x),
+     int, float, long, date, double, including the "Trie" variants.
+     - If sortMissingLast="true", then a sort on this field will cause documents
+       without the field to come after documents with the field,
+       regardless of the requested sort order (asc or desc).
+     - If sortMissingFirst="true", then a sort on this field will cause documents
+       without the field to come before documents with the field,
+       regardless of the requested sort order.
+     - If sortMissingLast="false" and sortMissingFirst="false" (the default),
+       then default lucene sorting will be used which places docs without the
+       field first in an ascending sort and last in a descending sort.
+  -->
+
+  <!--
+    Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
+
+    These fields support doc values, but they require the field to be
+    single-valued and either be required or have a default value.
+  -->
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
+
+  <!--
+   Numeric field types that index each value at various levels of precision
+   to accelerate range queries when the number of values between the range
+   endpoints is large. See the javadoc for LegacyNumericRangeQuery for internal
+   implementation details.
+
+   Smaller precisionStep values (specified in bits) will lead to more tokens
+   indexed per value, slightly larger index size, and faster range queries.
+   A precisionStep of 0 disables indexing at different precision levels.
+  -->
+  <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
+  <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
+
+  <!-- The format for this date field is of the form 1995-12-31T23:59:59Z, and
+       is a more restricted form of the canonical representation of dateTime
+       http://www.w3.org/TR/xmlschema-2/#dateTime    
+       The trailing "Z" designates UTC time and is mandatory.
+       Optional fractional seconds are allowed: 1995-12-31T23:59:59.999Z
+       All other components are mandatory.
+
+       Expressions can also be used to denote calculations that should be
+       performed relative to "NOW" to determine the value, ie...
+
+             NOW/HOUR
+                ... Round to the start of the current hour
+             NOW-1DAY
+                ... Exactly 1 day prior to now
+             NOW/DAY+6MONTHS+3DAYS
+                ... 6 months and 3 days in the future from the start of
+                    the current day
+                    
+       Consult the DateField javadocs for more information.
+
+       Note: For faster range queries, consider the tdate type
     -->
-    <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
-    <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
-
-    <!-- The format for this date field is of the form 1995-12-31T23:59:59Z, and
-         is a more restricted form of the canonical representation of dateTime
-         http://www.w3.org/TR/xmlschema-2/#dateTime    
-         The trailing "Z" designates UTC time and is mandatory.
-         Optional fractional seconds are allowed: 1995-12-31T23:59:59.999Z
-         All other components are mandatory.
-
-         Expressions can also be used to denote calculations that should be
-         performed relative to "NOW" to determine the value, ie...
-
-               NOW/HOUR
-                  ... Round to the start of the current hour
-               NOW-1DAY
-                  ... Exactly 1 day prior to now
-               NOW/DAY+6MONTHS+3DAYS
-                  ... 6 months and 3 days in the future from the start of
-                      the current day
-                      
-         Consult the DateField javadocs for more information.
-
-         Note: For faster range queries, consider the tdate type
-      -->
-    <fieldType name="date" class="solr.TrieDateField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="date" class="solr.TrieDateField" precisionStep="0" positionIncrementGap="0"/>
 
-    <!-- A Trie based date field for faster date range queries and date faceting. -->
-    <fieldType name="tdate" class="solr.TrieDateField" precisionStep="6" positionIncrementGap="0"/>
+  <!-- A Trie based date field for faster date range queries and date faceting. -->
+  <fieldType name="tdate" class="solr.TrieDateField" precisionStep="6" positionIncrementGap="0"/>
 
 
-    <!--Binary data type. The data should be sent/retrieved in as Base64 encoded Strings -->
-    <fieldtype name="binary" class="solr.BinaryField"/>
+  <!--Binary data type. The data should be sent/retrieved in as Base64 encoded Strings -->
+  <fieldtype name="binary" class="solr.BinaryField"/>
 
-    <!-- The "RandomSortField" is not used to store or search any
-         data.  You can declare fields of this type it in your schema
-         to generate pseudo-random orderings of your docs for sorting 
-         or function purposes.  The ordering is generated based on the field
-         name and the version of the index. As long as the index version
-         remains unchanged, and the same field name is reused,
-         the ordering of the docs will be consistent.  
-         If you want different psuedo-random orderings of documents,
-         for the same version of the index, use a dynamicField and
-         change the field name in the request.
-     -->
-    <fieldType name="random" class="solr.RandomSortField" indexed="true" />
+  <!-- The "RandomSortField" is not used to store or search any
+       data.  You can declare fields of this type it in your schema
+       to generate pseudo-random orderings of your docs for sorting 
+       or function purposes.  The ordering is generated based on the field
+       name and the version of the index. As long as the index version
+       remains unchanged, and the same field name is reused,
+       the ordering of the docs will be consistent.  
+       If you want different psuedo-random orderings of documents,
+       for the same version of the index, use a dynamicField and
+       change the field name in the request.
+   -->
+  <fieldType name="random" class="solr.RandomSortField" indexed="true"/>
 
-    <!-- solr.TextField allows the specification of custom text analyzers
-         specified as a tokenizer and a list of token filters. Different
-         analyzers may be specified for indexing and querying.
+  <!-- solr.TextField allows the specification of custom text analyzers
+       specified as a tokenizer and a list of token filters. Different
+       analyzers may be specified for indexing and querying.
 
-         The optional positionIncrementGap puts space between multiple fields of
-         this type on the same document, with the purpose of preventing false phrase
-         matching across fields.
+       The optional positionIncrementGap puts space between multiple fields of
+       this type on the same document, with the purpose of preventing false phrase
+       matching across fields.
 
-         For more info on customizing your analyzer chain, please see
-         http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters
-     -->
+       For more info on customizing your analyzer chain, please see
+       http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters
+   -->
 
-    <!-- One can also specify an existing Analyzer class that has a
-         default constructor via the class attribute on the analyzer element.
-         Example:
-    <fieldType name="text_greek" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.el.GreekAnalyzer"/>
-    </fieldType>
-    -->
+  <!-- One can also specify an existing Analyzer class that has a
+       default constructor via the class attribute on the analyzer element.
+       Example:
+  <fieldType name="text_greek" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.el.GreekAnalyzer"/>
+  </fieldType>
+  -->
 
-    <!-- A text field that only splits on whitespace for exact matching of words -->
-    <fieldType name="text_ws" class="solr.TextField" positionIncrementGap="100">
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- A general text field that has reasonable, generic
-         cross-language defaults: it tokenizes with StandardTokenizer,
-   removes stop words from case-insensitive "stopwords.txt"
-   (empty by default), and down cases.  At query time only, it
-   also applies synonyms. -->
-    <fieldType name="text_general" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt" />
-        <!-- in this example, we will only use synonyms at query time
-        <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
+  <!-- A text field that only splits on whitespace for exact matching of words -->
+  <fieldType name="text_ws" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- A general text field that has reasonable, generic
+       cross-language defaults: it tokenizes with StandardTokenizer,
+ removes stop words from case-insensitive "stopwords.txt"
+ (empty by default), and down cases.  At query time only, it
+ also applies synonyms. -->
+  <fieldType name="text_general" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+      <!-- in this example, we will only use synonyms at query time
+      <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
+      -->
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- A text field with defaults appropriate for English: it
+       tokenizes with StandardTokenizer, removes English stop words
+       (stopwords.txt), down cases, protects words from protwords.txt, and
+       finally applies Porter's stemming.  The query time analyzer
+       also applies synonyms from synonyms.txt. -->
+  <fieldType name="text_en" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <!-- in this example, we will only use synonyms at query time
+      <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
+      -->
+      <!-- Case insensitive stop word removal.
+      -->
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="stopwords.txt"
+      />
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.EnglishPossessiveFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+            <filter class="solr.EnglishMinimalStemFilterFactory"/>
+      -->
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="stopwords.txt"
+      />
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.EnglishPossessiveFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+            <filter class="solr.EnglishMinimalStemFilterFactory"/>
+      -->
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- A text field with defaults appropriate for English, plus
+ aggressive word-splitting and autophrase features enabled.
+ This field is just like text_en, except it adds
+ WordDelimiterFilter to enable splitting and matching of
+ words on case-change, alpha numeric boundaries, and
+ non-alphanumeric chars.  This means certain compound word
+ cases will work, for example query "wi fi" will match
+ document "WiFi" or "wi-fi".
+      -->
+  <fieldType name="text_en_splitting" class="solr.TextField" positionIncrementGap="100"
+             autoGeneratePhraseQueries="true">
+    <analyzer type="index">
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <!-- in this example, we will only use synonyms at query time
+      <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
+      -->
+      <!-- Case insensitive stop word removal.
+      -->
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="stopwords.txt"
+      />
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="stopwords.txt"
+      />
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Less flexible matching, but less false matches.  Probably not ideal for product names,
+       but may be good for SKUs.  Can insert dashes in the wrong place and still match. -->
+  <fieldType name="text_en_splitting_tight" class="solr.TextField" positionIncrementGap="100"
+             autoGeneratePhraseQueries="true">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="false"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.EnglishMinimalStemFilterFactory"/>
+      <!-- this filter can remove any duplicate tokens that appear at the same position - sometimes
+           possible with WordDelimiterFilter in conjuncton with stemming. -->
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Just like text_general except it reverses the characters of
+ each token, to enable more efficient leading wildcard queries. -->
+  <fieldType name="text_general_rev" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.ReversedWildcardFilterFactory" withOriginal="true"
+              maxPosAsterisk="3" maxPosQuestion="2" maxFractionAsterisk="0.33"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- charFilter + WhitespaceTokenizer  -->
+  <!--
+  <fieldType name="text_char_norm" class="solr.TextField" positionIncrementGap="100" >
+    <analyzer>
+      <charFilter class="solr.MappingCharFilterFactory" mapping="mapping-ISOLatin1Accent.txt"/>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  -->
+
+  <!-- This is an example of using the KeywordTokenizer along
+       With various TokenFilterFactories to produce a sortable field
+       that does not include some properties of the source text
+    -->
+  <fieldType name="alphaOnlySort" class="solr.TextField" sortMissingLast="true" omitNorms="true">
+    <analyzer>
+      <!-- KeywordTokenizer does no actual tokenizing, so the entire
+           input string is preserved as a single token
         -->
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt" />
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- A text field with defaults appropriate for English: it
-         tokenizes with StandardTokenizer, removes English stop words
-         (stopwords.txt), down cases, protects words from protwords.txt, and
-         finally applies Porter's stemming.  The query time analyzer
-         also applies synonyms from synonyms.txt. -->
-    <fieldType name="text_en" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <!-- in this example, we will only use synonyms at query time
-        <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
+      <tokenizer class="solr.KeywordTokenizerFactory"/>
+      <!-- The LowerCase TokenFilter does what you expect, which can be
+           when you want your sorting to be case insensitive
         -->
-        <!-- Case insensitive stop word removal.
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <!-- The TrimFilter removes any leading or trailing whitespace -->
+      <filter class="solr.TrimFilterFactory"/>
+      <!-- The PatternReplaceFilter gives you the flexibility to use
+           Java Regular expression to replace any sequence of characters
+           matching a pattern with an arbitrary replacement string, 
+           which may include back references to portions of the original
+           string matched by the pattern.
+           
+           See the Java Regular Expression documentation for more
+           information on pattern and replacement string syntax.
+           
+           http://docs.oracle.com/javase/7/docs/api/java/util/regex/package-summary.html
         -->
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="stopwords.txt"
-                />
-        <filter class="solr.LowerCaseFilterFactory"/>
-  <filter class="solr.EnglishPossessiveFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
-        <filter class="solr.EnglishMinimalStemFilterFactory"/>
+      <filter class="solr.PatternReplaceFilterFactory"
+              pattern="([^a-z])" replacement="" replace="all"
+      />
+    </analyzer>
+  </fieldType>
+
+  <fieldtype name="phonetic" stored="false" indexed="true" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.DoubleMetaphoneFilterFactory" inject="false"/>
+    </analyzer>
+  </fieldtype>
+
+  <fieldtype name="payloads" stored="false" indexed="true" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      <!--
+      The DelimitedPayloadTokenFilter can put payloads on tokens... for example,
+      a token of "foo|1.4"  would be indexed as "foo" with a payload of 1.4f
+      Attributes of the DelimitedPayloadTokenFilterFactory : 
+       "delimiter" - a one character delimiter. Default is | (pipe)
+ "encoder" - how to encode the following value into a playload
+    float -> org.apache.lucene.analysis.payloads.FloatEncoder,
+    integer -> o.a.l.a.p.IntegerEncoder
+    identity -> o.a.l.a.p.IdentityEncoder
+          Fully Qualified class name implementing PayloadEncoder, Encoder must have a no arg constructor.
+       -->
+      <filter class="solr.DelimitedPayloadTokenFilterFactory" encoder="float"/>
+    </analyzer>
+  </fieldtype>
+
+  <!-- lowercases the entire field value, keeping it as a single token.  -->
+  <fieldType name="lowercase" class="solr.TextField" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.KeywordTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- 
+    Example of using PathHierarchyTokenizerFactory at index time, so
+    queries for paths match documents at that path, or in descendent paths
   -->
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="stopwords.txt"
-                />
-        <filter class="solr.LowerCaseFilterFactory"/>
-  <filter class="solr.EnglishPossessiveFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
-        <filter class="solr.EnglishMinimalStemFilterFactory"/>
+  <fieldType name="descendent_path" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.KeywordTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <!-- 
+    Example of using PathHierarchyTokenizerFactory at query time, so
+    queries for paths match documents at that path, or in ancestor paths
   -->
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- A text field with defaults appropriate for English, plus
-   aggressive word-splitting and autophrase features enabled.
-   This field is just like text_en, except it adds
-   WordDelimiterFilter to enable splitting and matching of
-   words on case-change, alpha numeric boundaries, and
-   non-alphanumeric chars.  This means certain compound word
-   cases will work, for example query "wi fi" will match
-   document "WiFi" or "wi-fi".
-        -->
-    <fieldType name="text_en_splitting" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true">
-      <analyzer type="index">
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <!-- in this example, we will only use synonyms at query time
-        <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
-        -->
-        <!-- Case insensitive stop word removal.
-        -->
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="stopwords.txt"
-                />
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="stopwords.txt"
-                />
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- Less flexible matching, but less false matches.  Probably not ideal for product names,
-         but may be good for SKUs.  Can insert dashes in the wrong place and still match. -->
-    <fieldType name="text_en_splitting_tight" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true">
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="false"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.EnglishMinimalStemFilterFactory"/>
-        <!-- this filter can remove any duplicate tokens that appear at the same position - sometimes
-             possible with WordDelimiterFilter in conjuncton with stemming. -->
-        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- Just like text_general except it reverses the characters of
-   each token, to enable more efficient leading wildcard queries. -->
-    <fieldType name="text_general_rev" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt" />
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.ReversedWildcardFilterFactory" withOriginal="true"
-           maxPosAsterisk="3" maxPosQuestion="2" maxFractionAsterisk="0.33"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt" />
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- charFilter + WhitespaceTokenizer  -->
-    <!--
-    <fieldType name="text_char_norm" class="solr.TextField" positionIncrementGap="100" >
-      <analyzer>
-        <charFilter class="solr.MappingCharFilterFactory" mapping="mapping-ISOLatin1Accent.txt"/>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-    -->
+  <fieldType name="ancestor_path" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.KeywordTokenizerFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- since fields of this type are by default not stored or indexed,
+       any data added to them will be ignored outright.  -->
+  <fieldtype name="ignored" stored="false" indexed="false" docValues="false" multiValued="true" class="solr.StrField"/>
+
+  <!-- This point type indexes the coordinates as separate fields (subFields)
+    If subFieldType is defined, it references a type, and a dynamic field
+    definition is created matching *___<typename>.  Alternately, if 
+    subFieldSuffix is defined, that is used to create the subFields.
+    Example: if subFieldType="double", then the coordinates would be
+      indexed in fields myloc_0___double,myloc_1___double.
+    Example: if subFieldSuffix="_d" then the coordinates would be indexed
+      in fields myloc_0_d,myloc_1_d
+    The subFields are an implementation detail of the fieldType, and end
+    users normally should not need to know about them.
+   -->
+  <fieldType name="point" class="solr.PointType" dimension="2" subFieldSuffix="_d"/>
 
-    <!-- This is an example of using the KeywordTokenizer along
-         With various TokenFilterFactories to produce a sortable field
-         that does not include some properties of the source text
-      -->
-    <fieldType name="alphaOnlySort" class="solr.TextField" sortMissingLast="true" omitNorms="true">
-      <analyzer>
-        <!-- KeywordTokenizer does no actual tokenizing, so the entire
-             input string is preserved as a single token
-          -->
-        <tokenizer class="solr.KeywordTokenizerFactory"/>
-        <!-- The LowerCase TokenFilter does what you expect, which can be
-             when you want your sorting to be case insensitive
-          -->
-        <filter class="solr.LowerCaseFilterFactory" />
-        <!-- The TrimFilter removes any leading or trailing whitespace -->
-        <filter class="solr.TrimFilterFactory" />
-        <!-- The PatternReplaceFilter gives you the flexibility to use
-             Java Regular expression to replace any sequence of characters
-             matching a pattern with an arbitrary replacement string, 
-             which may include back references to portions of the original
-             string matched by the pattern.
-             
-             See the Java Regular Expression documentation for more
-             information on pattern and replacement string syntax.
-             
-             http://docs.oracle.com/javase/7/docs/api/java/util/regex/package-summary.html
-          -->
-        <filter class="solr.PatternReplaceFilterFactory"
-                pattern="([^a-z])" replacement="" replace="all"
-        />
-      </analyzer>
-    </fieldType>
-    
-    <fieldtype name="phonetic" stored="false" indexed="true" class="solr.TextField" >
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.DoubleMetaphoneFilterFactory" inject="false"/>
-      </analyzer>
-    </fieldtype>
-
-    <fieldtype name="payloads" stored="false" indexed="true" class="solr.TextField" >
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <!--
-        The DelimitedPayloadTokenFilter can put payloads on tokens... for example,
-        a token of "foo|1.4"  would be indexed as "foo" with a payload of 1.4f
-        Attributes of the DelimitedPayloadTokenFilterFactory : 
-         "delimiter" - a one character delimiter. Default is | (pipe)
-   "encoder" - how to encode the following value into a playload
-      float -> org.apache.lucene.analysis.payloads.FloatEncoder,
-      integer -> o.a.l.a.p.IntegerEncoder
-      identity -> o.a.l.a.p.IdentityEncoder
-            Fully Qualified class name implementing PayloadEncoder, Encoder must have a no arg constructor.
-         -->
-        <filter class="solr.DelimitedPayloadTokenFilterFactory" encoder="float"/>
-      </analyzer>
-    </fieldtype>
-
-    <!-- lowercases the entire field value, keeping it as a single token.  -->
-    <fieldType name="lowercase" class="solr.TextField" positionIncrementGap="100">
-      <analyzer>
-        <tokenizer class="solr.KeywordTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory" />
-      </analyzer>
-    </fieldType>
-
-    <!-- 
-      Example of using PathHierarchyTokenizerFactory at index time, so
-      queries for paths match documents at that path, or in descendent paths
-    -->
-    <fieldType name="descendent_path" class="solr.TextField">
-      <analyzer type="index">
-  <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
-      </analyzer>
-      <analyzer type="query">
-  <tokenizer class="solr.KeywordTokenizerFactory" />
-      </analyzer>
-    </fieldType>
-    <!-- 
-      Example of using PathHierarchyTokenizerFactory at query time, so
-      queries for paths match documents at that path, or in ancestor paths
-    -->
-    <fieldType name="ancestor_path" class="solr.TextField">
-      <analyzer type="index">
-  <tokenizer class="solr.KeywordTokenizerFactory" />
-      </analyzer>
-      <analyzer type="query">
-  <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
-      </analyzer>
-    </fieldType>
-
-    <!-- since fields of this type are by default not stored or indexed,
-         any data added to them will be ignored outright.  --> 
-    <fieldtype name="ignored" stored="false" indexed="false" docValues="false" multiValued="true" class="solr.StrField" />
-
-    <!-- This point type indexes the coordinates as separate fields (subFields)
-      If subFieldType is defined, it references a type, and a dynamic field
-      definition is created matching *___<typename>.  Alternately, if 
-      subFieldSuffix is defined, that is used to create the subFields.
-      Example: if subFieldType="double", then the coordinates would be
-        indexed in fields myloc_0___double,myloc_1___double.
-      Example: if subFieldSuffix="_d" then the coordinates would be indexed
-        in fields myloc_0_d,myloc_1_d
-      The subFields are an implementation detail of the fieldType, and end
-      users normally should not need to know about them.
-     -->
-    <fieldType name="point" class="solr.PointType" dimension="2" subFieldSuffix="_d"/>
+  <!-- A specialized field for geospatial search. If indexed, this fieldType must not be multivalued. -->
+  <fieldType name="location" class="solr.LatLonType" subFieldSuffix="_coordinate"/>
 
-    <!-- A specialized field for geospatial search. If indexed, this fieldType must not be multivalued. -->
-    <fieldType name="location" class="solr.LatLonType" subFieldSuffix="_coordinate"/>
+  <!-- An alternative geospatial field type new to Solr 4.  It supports multiValued and polygon shapes.
+    For more information about this and other Spatial fields new to Solr 4, see:
+    http://wiki.apache.org/solr/SolrAdaptersForLuceneSpatial4
+  -->
+  <fieldType name="location_rpt" class="solr.SpatialRecursivePrefixTreeFieldType"
+             geo="true" distErrPct="0.025" maxDistErr="0.001" distanceUnits="kilometers"/>
+
+  <!-- Money/currency field type. See http://wiki.apache.org/solr/MoneyFieldType
+       Parameters:
+         defaultCurrency: Specifies the default currency if none specified. Defaults to "USD"
+         precisionStep:   Specifies the precisionStep for the TrieLong field used for the amount
+         providerClass:   Lets you plug in other exchange provider backend:
+                          solr.FileExchangeRateProvider is the default and takes one parameter:
+                            currencyConfig: name of an xml file holding exchange rates
+                          solr.OpenExchangeRatesOrgProvider uses rates from openexchangerates.org:
+                            ratesFileLocation: URL or path to rates JSON file (default latest.json on the web)
+                            refreshInterval: Number of minutes between each rates fetch (default: 1440, min: 60)
+  -->
+  <fieldType name="currency" class="solr.CurrencyField" precisionStep="8" defaultCurrency="USD"
+             currencyConfig="currency.xml"/>
 
-    <!-- An alternative geospatial field type new to Solr 4.  It supports multiValued and polygon shapes.
-      For more information about this and other Spatial fields new to Solr 4, see:
-      http://wiki.apache.org/solr/SolrAdaptersForLuceneSpatial4
-    -->
-    <fieldType name="location_rpt" class="solr.SpatialRecursivePrefixTreeFieldType"
-        geo="true" distErrPct="0.025" maxDistErr="0.001" distanceUnits="kilometers" />
-
-   <!-- Money/currency field type. See http://wiki.apache.org/solr/MoneyFieldType
-        Parameters:
-          defaultCurrency: Specifies the default currency if none specified. Defaults to "USD"
-          precisionStep:   Specifies the precisionStep for the TrieLong field used for the amount
-          providerClass:   Lets you plug in other exchange provider backend:
-                           solr.FileExchangeRateProvider is the default and takes one parameter:
-                             currencyConfig: name of an xml file holding exchange rates
-                           solr.OpenExchangeRatesOrgProvider uses rates from openexchangerates.org:
-                             ratesFileLocation: URL or path to rates JSON file (default latest.json on the web)
-                             refreshInterval: Number of minutes between each rates fetch (default: 1440, min: 60)
-   -->
-    <fieldType name="currency" class="solr.CurrencyField" precisionStep="8" defaultCurrency="USD" currencyConfig="currency.xml" />
-             
 
+  <!-- some examples for different languages (generally ordered by ISO code) -->
+  <!-- REMOVED.  these reference things not in the test config, like lang/stopwords_en.txt -->
 
-   <!-- some examples for different languages (generally ordered by ISO code) -->
-   <!-- REMOVED.  these reference things not in the test config, like lang/stopwords_en.txt -->
 
- </types>
-  
   <!-- Similarity is the scoring routine for each document vs. a query.
        A custom Similarity or SimilarityFactory may be specified here, but 
        the default is fine for most applications.  
diff --git a/solr/core/src/test-files/solr/collection1/conf/schemasurround.xml b/solr/core/src/test-files/solr/collection1/conf/schemasurround.xml
index b274aff..e22eb2b 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schemasurround.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schemasurround.xml
@@ -26,540 +26,565 @@
   -->
 
 <schema name="test" version="1.4">
-  <types>
 
-    <!-- field type definitions... note that the "name" attribute is
-         just a label to be used by field definitions.  The "class"
-         attribute and any other attributes determine the real type and
-         behavior of the fieldType.
-      -->
+  <!-- field type definitions... note that the "name" attribute is
+       just a label to be used by field definitions.  The "class"
+       attribute and any other attributes determine the real type and
+       behavior of the fieldType.
+    -->
+
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+
+  <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+
+  <!-- Field type demonstrating an Analyzer failure -->
+  <fieldType name="failtype1" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0"
+              catenateNumbers="0" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
 
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>  
-
-    <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
-
-    <!-- Field type demonstrating an Analyzer failure -->
-    <fieldType name="failtype1" class="solr.TextField">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- Demonstrating ignoreCaseChange -->
-    <fieldType name="wdf_nocase" class="solr.TextField">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    
-     <fieldType name="wdf_preserve" class="solr.TextField">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="1"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <!-- HighlitText optimizes storage for (long) columns which will be highlit -->
-    <fieldType name="highlittext" class="solr.TextField"/>
-
-    <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
-
-    <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
-         seconds part (.999) is optional.
-      -->
-    <fieldType name="date" class="solr.TrieDateField" sortMissingLast="true"/>
-    <fieldType name="tdate" class="solr.TrieDateField" sortMissingLast="true" precisionStep="6"/>
-
-  <fieldType name="text" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true" >
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="stopwords.txt"
-                />
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="stopwords.txt"
-                />
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <!-- field type that doesn't generate phrases from unquoted multiple tokens per analysis unit -->
-   <fieldType name="text_np" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="stopwords.txt"
-                />
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.StopFilterFactory"
-                ignoreCase="true"
-                words="stopwords.txt"
-                />
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="nametext" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.core.WhitespaceAnalyzer"/>
-    </fieldType>
-
-    <fieldType name="teststop" class="solr.TextField">
-       <analyzer>
-        <tokenizer class="solr.LowerCaseTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-        <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- fieldTypes in this section isolate tokenizers and tokenfilters for testing -->
-    <fieldType name="lowertok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.LowerCaseTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="keywordtok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/></analyzer>
-    </fieldType>
-    <fieldType name="standardtok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.StandardTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="lettertok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.LetterTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="whitetok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.MockTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="HTMLstandardtok" class="solr.TextField">
-      <analyzer>
+  <!-- Demonstrating ignoreCaseChange -->
+  <fieldType name="wdf_nocase" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="wdf_preserve" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <!-- HighlitText optimizes storage for (long) columns which will be highlit -->
+  <fieldType name="highlittext" class="solr.TextField"/>
+
+  <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+
+  <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
+       seconds part (.999) is optional.
+    -->
+  <fieldType name="date" class="solr.TrieDateField" sortMissingLast="true"/>
+  <fieldType name="tdate" class="solr.TrieDateField" sortMissingLast="true" precisionStep="6"/>
+
+  <fieldType name="text" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="stopwords.txt"
+      />
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="stopwords.txt"
+      />
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <!-- field type that doesn't generate phrases from unquoted multiple tokens per analysis unit -->
+  <fieldType name="text_np" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="stopwords.txt"
+      />
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.StopFilterFactory"
+              ignoreCase="true"
+              words="stopwords.txt"
+      />
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="nametext" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.core.WhitespaceAnalyzer"/>
+  </fieldType>
+
+  <fieldType name="teststop" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LowerCaseTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+      <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- fieldTypes in this section isolate tokenizers and tokenfilters for testing -->
+  <fieldType name="lowertok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LowerCaseTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="keywordtok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="standardtok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="lettertok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LetterTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="whitetok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="HTMLstandardtok" class="solr.TextField">
+    <analyzer>
       <charFilter class="solr.HTMLStripCharFilterFactory"/>
       <tokenizer class="solr.StandardTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="HTMLwhitetok" class="solr.TextField">
-      <analyzer>
+    </analyzer>
+  </fieldType>
+  <fieldType name="HTMLwhitetok" class="solr.TextField">
+    <analyzer>
       <charFilter class="solr.HTMLStripCharFilterFactory"/>
       <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="standardtokfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="standardfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="lowerfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="patternreplacefilt" class="solr.TextField">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
-        <filter class="solr.PatternReplaceFilterFactory"
-                pattern="([^a-zA-Z])" replacement="_" replace="all"
-        />
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="porterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="engporterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="custengporterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="stopfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="custstopfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="lengthfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LengthFilterFactory" min="2" max="5"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="subword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.StopFilterFactory"/>
-          <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.StopFilterFactory"/>
-          <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="numericsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-          <filter class="solr.StopFilterFactory"/>
-          <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.StopFilterFactory"/>
-          <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="protectedsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <!-- more flexible in matching skus, but more chance of a false match -->
-    <fieldType name="skutype1" class="solr.TextField">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- less flexible in matching skus, but less chance of a false match -->
-    <fieldType name="skutype2" class="solr.TextField">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- less flexible in matching skus, but less chance of a false match -->
-    <fieldType name="syn" class="solr.TextField">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- a text field with the stop filter only on the query analyzer 
-     -->
-    <fieldType name="text_sw" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <!-- in this example, we will only use synonyms at query time
-        <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
-        -->
-        <!--<filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>-->
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
-                catenateNumbers="1" catenateAll="0" splitOnCaseChange="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
-                catenateNumbers="0" catenateAll="0" splitOnCaseChange="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- A general minimally stemmed textfield -->
-    <fieldType name="textgen" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0" splitOnCaseChange="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.EnglishMinimalStemFilterFactory" />
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.EnglishMinimalStemFilterFactory" />
-      </analyzer>
-    </fieldType>
-    
-    <!-- Demonstrates How RemoveDuplicatesTokenFilter makes stemmed
-         synonyms "better"
+    </analyzer>
+  </fieldType>
+  <fieldType name="standardtokfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="standardfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="lowerfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="patternreplacefilt" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+      <filter class="solr.PatternReplaceFilterFactory"
+              pattern="([^a-zA-Z])" replacement="_" replace="all"
+      />
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="porterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="engporterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="custengporterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="stopfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="custstopfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" words="stopwords.txt"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="lengthfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LengthFilterFactory" min="2" max="5"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="subword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="numericsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0"
+              splitOnCaseChange="0" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0"
+              catenateAll="0"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0"
+              splitOnCaseChange="0" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1"
+              catenateAll="0"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="protectedsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" protected="protwords.txt" splitOnNumerics="0"
+              splitOnCaseChange="0" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0"
+              catenateAll="0"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <!-- more flexible in matching skus, but more chance of a false match -->
+  <fieldType name="skutype1" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- less flexible in matching skus, but less chance of a false match -->
+  <fieldType name="skutype2" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- less flexible in matching skus, but less chance of a false match -->
+  <fieldType name="syn" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- a text field with the stop filter only on the query analyzer 
+   -->
+  <fieldType name="text_sw" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <!-- in this example, we will only use synonyms at query time
+      <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
       -->
-    <fieldType name="dedup" class="solr.TextField">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.SynonymFilterFactory"
-                  synonyms="synonyms.txt" expand="true" />
-          <filter class="solr.PorterStemFilterFactory"/>
-          <filter class="solr.RemoveDuplicatesTokenFilterFactory" />
-      </analyzer>
-    </fieldType>
+      <!--<filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>-->
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0" splitOnCaseChange="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
 
-    <fieldType  name="unstored" class="solr.StrField" indexed="true" stored="false"/>
+  <!-- A general minimally stemmed textfield -->
+  <fieldType name="textgen" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0" splitOnCaseChange="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.EnglishMinimalStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.EnglishMinimalStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Demonstrates How RemoveDuplicatesTokenFilter makes stemmed
+       synonyms "better"
+    -->
+  <fieldType name="dedup" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory"
+              synonyms="synonyms.txt" expand="true"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="unstored" class="solr.StrField" indexed="true" stored="false"/>
 
 
   <fieldType name="textgap" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-  </fieldType>
-
-  <fieldType name="uuid" class="solr.UUIDField" />
-  <fieldType name="ignored" class="solr.StrField" indexed="false" stored="false" />
-
-
-  <fieldType name="random" class="solr.RandomSortField" indexed="true" />  
-  
-    <!-- Poly field -->
-    <fieldType name="xy" class="solr.PointType" dimension="2" subFieldType="double"/>
-    <fieldType name="xyd" class="solr.PointType" dimension="2" subFieldSuffix="*_d"/>
-    <fieldType name="geohash" class="solr.GeoHashField"/>
-
-   <fieldType name="point" class="solr.PointType" dimension="2" subFieldSuffix="_d"/>
-    <!-- A specialized field for geospatial search. If indexed, this fieldType must not be multivalued. -->
-    <fieldType name="location" class="solr.LatLonType" subFieldSuffix="_coordinate"/>
-
- </types>
-
-
- <fields>
-   <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="true"/>
-   <field name="signatureField" type="string" indexed="true" stored="false"/>
-   <field name="uuid" type="uuid" stored="true" />
-   <field name="name" type="nametext" indexed="true" stored="true"/>
-   <field name="text" type="textgen" indexed="true" stored="false"/>
-   <field name="subject" type="text" indexed="true" stored="true"/>
-   <field name="title" type="nametext" indexed="true" stored="true"/>
-   <field name="weight" type="float" indexed="true" stored="true"/>
-   <field name="bday" type="date" indexed="true" stored="true"/>
-
-   <field name="text_np" type="text_np" indexed="true" stored="false"/>
-
-   <field name="title_stemmed" type="text" indexed="true" stored="false"/>
-   <field name="title_lettertok" type="lettertok" indexed="true" stored="false"/>
-
-   <field name="syn" type="syn" indexed="true" stored="true"/>
-
-   <!-- to test property inheritance and overriding -->
-   <field name="shouldbeunstored" type="unstored" />
-   <field name="shouldbestored" type="unstored" stored="true"/>
-   <field name="shouldbeunindexed" type="unstored" indexed="false" stored="true"/>
-
-
-   <!-- test different combinations of indexed and stored -->
-   <field name="bind" type="boolean" indexed="true" stored="false"/>
-   <field name="bsto" type="boolean" indexed="false" stored="true"/>
-   <field name="bindsto" type="boolean" indexed="true" stored="true"/>
-   <field name="isto" type="int" indexed="false" stored="true"/>
-   <field name="iind" type="int" indexed="true" stored="false"/>
-   <field name="ssto" type="string" indexed="false" stored="true"/>
-   <field name="sind" type="string" indexed="true" stored="false"/>
-   <field name="sindsto" type="string" indexed="true" stored="true"/>
-
-   <!-- test combinations of term vector settings -->
-   <field name="test_basictv" type="text" termVectors="true"/>
-   <field name="test_notv" type="text" termVectors="false"/>
-   <field name="test_postv" type="text" termVectors="true" termPositions="true"/>
-   <field name="test_offtv" type="text" termVectors="true" termOffsets="true"/>
-   <field name="test_posofftv" type="text" termVectors="true" 
-     termPositions="true" termOffsets="true"/>
-
-   <!-- test highlit field settings -->
-   <field name="test_hlt" type="highlittext" indexed="true"/>
-   <field name="test_hlt_off" type="highlittext" indexed="true"/>
-
-   <!-- fields to test individual tokenizers and tokenfilters -->
-   <field name="teststop" type="teststop" indexed="true" stored="true"/>
-   <field name="lowertok" type="lowertok" indexed="true" stored="true"/>
-   <field name="keywordtok" type="keywordtok" indexed="true" stored="true"/>
-   <field name="standardtok" type="standardtok" indexed="true" stored="true"/>
-   <field name="HTMLstandardtok" type="HTMLstandardtok" indexed="true" stored="true"/>
-   <field name="lettertok" type="lettertok" indexed="true" stored="true"/>
-   <field name="whitetok" type="whitetok" indexed="true" stored="true"/>
-   <field name="HTMLwhitetok" type="HTMLwhitetok" indexed="true" stored="true"/>
-   <field name="standardtokfilt" type="standardtokfilt" indexed="true" stored="true"/>
-   <field name="standardfilt" type="standardfilt" indexed="true" stored="true"/>
-   <field name="lowerfilt" type="lowerfilt" indexed="true" stored="true"/>
-   <field name="patternreplacefilt" type="patternreplacefilt" indexed="true" stored="true"/>
-   <field name="porterfilt" type="porterfilt" indexed="true" stored="true"/>
-   <field name="engporterfilt" type="engporterfilt" indexed="true" stored="true"/>
-   <field name="custengporterfilt" type="custengporterfilt" indexed="true" stored="true"/>
-   <field name="stopfilt" type="stopfilt" indexed="true" stored="true"/>
-   <field name="custstopfilt" type="custstopfilt" indexed="true" stored="true"/>
-   <field name="lengthfilt" type="lengthfilt" indexed="true" stored="true"/>
-   <field name="dedup" type="dedup" indexed="true" stored="true"/>
-   <field name="wdf_nocase" type="wdf_nocase" indexed="true" stored="true"/>
-   <field name="wdf_preserve" type="wdf_preserve" indexed="true" stored="true"/>
-
-   <field name="numberpartfail" type="failtype1" indexed="true" stored="true"/>
-
-   <field name="nullfirst" type="string" indexed="true" stored="true" sortMissingFirst="true"/>
-
-   <field name="subword" type="subword" indexed="true" stored="true"/>
-   <field name="numericsubword" type="numericsubword" indexed="true" stored="true"/>
-   <field name="protectedsubword" type="protectedsubword" indexed="true" stored="true"/>
-
-   <field name="sku1" type="skutype1" indexed="true" stored="true"/>
-   <field name="sku2" type="skutype2" indexed="true" stored="true"/>
-
-   <field name="textgap" type="textgap" indexed="true" stored="true"/>
-   
-   <!--
-   <field name="timestamp" type="date" indexed="true" stored="true" default="NOW"/>
-   -->
-   <field name="timestamp" type="date" indexed="true" stored="true"/>
-
-   <!-- Test a point field for distances -->
-   <field name="point" type="xy" indexed="true" stored="true" multiValued="false"/>
-   <field name="pointD" type="xyd" indexed="true" stored="true" multiValued="false"/>
-   <field name="point_hash" type="geohash" indexed="true" stored="true" multiValued="false"/>
-   <field name="store" type="location" indexed="true" stored="true"/>
-   
-   <!-- to test uniq fields -->   
-   <field name="uniq" type="string" indexed="true" stored="true" multiValued="true"/>
-   <field name="uniq2" type="string" indexed="true" stored="true" multiValued="true"/>
-   <field name="uniq3" type="string" indexed="true" stored="true"/>
-   <field name="nouniq" type="string" indexed="true" stored="true" multiValued="true"/>
-
-   <field name="_version_" type="long" indexed="true" stored="true" multiValued="false" />
-
-   <dynamicField name="*_coordinate"  type="tdouble" indexed="true"  stored="false"/>
-
-   <dynamicField name="*_sI" type="string"  indexed="true"  stored="false"/>
-   <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
-   <dynamicField name="t_*"  type="text"    indexed="true"  stored="true"/>
-   <dynamicField name="tv_*"  type="text" indexed="true"  stored="true" 
-      termVectors="true" termPositions="true" termOffsets="true"/>
-   <dynamicField name="tv_mv_*"  type="text" indexed="true"  stored="true" multiValued="true"
-      termVectors="true" termPositions="true" termOffsets="true"/>
-
-   <dynamicField name="*_mfacet" type="string" indexed="true" stored="false" multiValued="true" />
-
-   <dynamicField name="*_sw" type="text_sw" indexed="true" stored="true" multiValued="true"/>
-
-   <dynamicField name="*_i"  type="int"    indexed="true"  stored="true"/>
-   <dynamicField name="*_is"  type="int"    indexed="true"  stored="true" multiValued="true"/>
-   <dynamicField name="*_s1"  type="string"  indexed="true" stored="true" multiValued="false"/>
-   <!-- :TODO: why are these identical?!?!?! -->
-   <dynamicField name="*_s"  type="string"  indexed="true"  stored="true" multiValued="true"/>
-   <dynamicField name="*_ss"  type="string"  indexed="true"  stored="true" multiValued="true"/>
-   <dynamicField name="*_l"  type="long"   indexed="true"  stored="true"/>
-   <dynamicField name="*_t"  type="text"    indexed="true"  stored="true"/>
-   <dynamicField name="*_tt"  type="text"    indexed="true"  stored="true"/>
-   <dynamicField name="*_b"  type="boolean" indexed="true"  stored="true"/>
-   <dynamicField name="*_f"  type="float"  indexed="true"  stored="true"/>
-   <dynamicField name="*_d"  type="double" indexed="true"  stored="true"/>
-   <dynamicField name="*_dt" type="date"    indexed="true"  stored="true"/>
-
-   <!-- some trie-coded dynamic fields for faster range queries -->
-   <dynamicField name="*_ti" type="tint"    indexed="true"  stored="true"/>
-   <dynamicField name="*_tl" type="tlong"   indexed="true"  stored="true"/>
-   <dynamicField name="*_tf" type="tfloat"  indexed="true"  stored="true"/>
-   <dynamicField name="*_td" type="tdouble" indexed="true"  stored="true"/>
-   <dynamicField name="*_tdt" type="tdate"  indexed="true"  stored="true"/>
-
-   <dynamicField name="ignored_*" type="ignored" multiValued="true"/>
-   <dynamicField name="attr_*" type="text" indexed="true" stored="true" multiValued="true"/>
-
-   <dynamicField name="random_*" type="random" />
-
- </fields>
-
- <defaultSearchField>text</defaultSearchField>
- <uniqueKey>id</uniqueKey>
-
-   <copyField source="title" dest="title_stemmed"/>
-   <copyField source="title" dest="title_lettertok"/>
-
-   <copyField source="title" dest="text"/>
-   <copyField source="subject" dest="text"/>
- 
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="uuid" class="solr.UUIDField"/>
+  <fieldType name="ignored" class="solr.StrField" indexed="false" stored="false"/>
+
+
+  <fieldType name="random" class="solr.RandomSortField" indexed="true"/>
+
+  <!-- Poly field -->
+  <fieldType name="xy" class="solr.PointType" dimension="2" subFieldType="double"/>
+  <fieldType name="xyd" class="solr.PointType" dimension="2" subFieldSuffix="*_d"/>
+  <fieldType name="geohash" class="solr.GeoHashField"/>
+
+  <fieldType name="point" class="solr.PointType" dimension="2" subFieldSuffix="_d"/>
+  <!-- A specialized field for geospatial search. If indexed, this fieldType must not be multivalued. -->
+  <fieldType name="location" class="solr.LatLonType" subFieldSuffix="_coordinate"/>
+
+  <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="true"/>
+  <field name="signatureField" type="string" indexed="true" stored="false"/>
+  <field name="uuid" type="uuid" stored="true"/>
+  <field name="name" type="nametext" indexed="true" stored="true"/>
+  <field name="text" type="textgen" indexed="true" stored="false"/>
+  <field name="subject" type="text" indexed="true" stored="true"/>
+  <field name="title" type="nametext" indexed="true" stored="true"/>
+  <field name="weight" type="float" indexed="true" stored="true"/>
+  <field name="bday" type="date" indexed="true" stored="true"/>
+
+  <field name="text_np" type="text_np" indexed="true" stored="false"/>
+
+  <field name="title_stemmed" type="text" indexed="true" stored="false"/>
+  <field name="title_lettertok" type="lettertok" indexed="true" stored="false"/>
+
+  <field name="syn" type="syn" indexed="true" stored="true"/>
+
+  <!-- to test property inheritance and overriding -->
+  <field name="shouldbeunstored" type="unstored"/>
+  <field name="shouldbestored" type="unstored" stored="true"/>
+  <field name="shouldbeunindexed" type="unstored" indexed="false" stored="true"/>
+
+
+  <!-- test different combinations of indexed and stored -->
+  <field name="bind" type="boolean" indexed="true" stored="false"/>
+  <field name="bsto" type="boolean" indexed="false" stored="true"/>
+  <field name="bindsto" type="boolean" indexed="true" stored="true"/>
+  <field name="isto" type="int" indexed="false" stored="true"/>
+  <field name="iind" type="int" indexed="true" stored="false"/>
+  <field name="ssto" type="string" indexed="false" stored="true"/>
+  <field name="sind" type="string" indexed="true" stored="false"/>
+  <field name="sindsto" type="string" indexed="true" stored="true"/>
+
+  <!-- test combinations of term vector settings -->
+  <field name="test_basictv" type="text" termVectors="true"/>
+  <field name="test_notv" type="text" termVectors="false"/>
+  <field name="test_postv" type="text" termVectors="true" termPositions="true"/>
+  <field name="test_offtv" type="text" termVectors="true" termOffsets="true"/>
+  <field name="test_posofftv" type="text" termVectors="true"
+         termPositions="true" termOffsets="true"/>
+
+  <!-- test highlit field settings -->
+  <field name="test_hlt" type="highlittext" indexed="true"/>
+  <field name="test_hlt_off" type="highlittext" indexed="true"/>
+
+  <!-- fields to test individual tokenizers and tokenfilters -->
+  <field name="teststop" type="teststop" indexed="true" stored="true"/>
+  <field name="lowertok" type="lowertok" indexed="true" stored="true"/>
+  <field name="keywordtok" type="keywordtok" indexed="true" stored="true"/>
+  <field name="standardtok" type="standardtok" indexed="true" stored="true"/>
+  <field name="HTMLstandardtok" type="HTMLstandardtok" indexed="true" stored="true"/>
+  <field name="lettertok" type="lettertok" indexed="true" stored="true"/>
+  <field name="whitetok" type="whitetok" indexed="true" stored="true"/>
+  <field name="HTMLwhitetok" type="HTMLwhitetok" indexed="true" stored="true"/>
+  <field name="standardtokfilt" type="standardtokfilt" indexed="true" stored="true"/>
+  <field name="standardfilt" type="standardfilt" indexed="true" stored="true"/>
+  <field name="lowerfilt" type="lowerfilt" indexed="true" stored="true"/>
+  <field name="patternreplacefilt" type="patternreplacefilt" indexed="true" stored="true"/>
+  <field name="porterfilt" type="porterfilt" indexed="true" stored="true"/>
+  <field name="engporterfilt" type="engporterfilt" indexed="true" stored="true"/>
+  <field name="custengporterfilt" type="custengporterfilt" indexed="true" stored="true"/>
+  <field name="stopfilt" type="stopfilt" indexed="true" stored="true"/>
+  <field name="custstopfilt" type="custstopfilt" indexed="true" stored="true"/>
+  <field name="lengthfilt" type="lengthfilt" indexed="true" stored="true"/>
+  <field name="dedup" type="dedup" indexed="true" stored="true"/>
+  <field name="wdf_nocase" type="wdf_nocase" indexed="true" stored="true"/>
+  <field name="wdf_preserve" type="wdf_preserve" indexed="true" stored="true"/>
+
+  <field name="numberpartfail" type="failtype1" indexed="true" stored="true"/>
+
+  <field name="nullfirst" type="string" indexed="true" stored="true" sortMissingFirst="true"/>
+
+  <field name="subword" type="subword" indexed="true" stored="true"/>
+  <field name="numericsubword" type="numericsubword" indexed="true" stored="true"/>
+  <field name="protectedsubword" type="protectedsubword" indexed="true" stored="true"/>
+
+  <field name="sku1" type="skutype1" indexed="true" stored="true"/>
+  <field name="sku2" type="skutype2" indexed="true" stored="true"/>
+
+  <field name="textgap" type="textgap" indexed="true" stored="true"/>
+
+  <!--
+  <field name="timestamp" type="date" indexed="true" stored="true" default="NOW"/>
+  -->
+  <field name="timestamp" type="date" indexed="true" stored="true"/>
+
+  <!-- Test a point field for distances -->
+  <field name="point" type="xy" indexed="true" stored="true" multiValued="false"/>
+  <field name="pointD" type="xyd" indexed="true" stored="true" multiValued="false"/>
+  <field name="point_hash" type="geohash" indexed="true" stored="true" multiValued="false"/>
+  <field name="store" type="location" indexed="true" stored="true"/>
+
+  <!-- to test uniq fields -->
+  <field name="uniq" type="string" indexed="true" stored="true" multiValued="true"/>
+  <field name="uniq2" type="string" indexed="true" stored="true" multiValued="true"/>
+  <field name="uniq3" type="string" indexed="true" stored="true"/>
+  <field name="nouniq" type="string" indexed="true" stored="true" multiValued="true"/>
+
+  <field name="_version_" type="long" indexed="true" stored="true" multiValued="false"/>
+
+  <dynamicField name="*_coordinate" type="tdouble" indexed="true" stored="false"/>
+
+  <dynamicField name="*_sI" type="string" indexed="true" stored="false"/>
+  <dynamicField name="*_sS" type="string" indexed="false" stored="true"/>
+  <dynamicField name="t_*" type="text" indexed="true" stored="true"/>
+  <dynamicField name="tv_*" type="text" indexed="true" stored="true"
+                termVectors="true" termPositions="true" termOffsets="true"/>
+  <dynamicField name="tv_mv_*" type="text" indexed="true" stored="true" multiValued="true"
+                termVectors="true" termPositions="true" termOffsets="true"/>
+
+  <dynamicField name="*_mfacet" type="string" indexed="true" stored="false" multiValued="true"/>
+
+  <dynamicField name="*_sw" type="text_sw" indexed="true" stored="true" multiValued="true"/>
+
+  <dynamicField name="*_i" type="int" indexed="true" stored="true"/>
+  <dynamicField name="*_is" type="int" indexed="true" stored="true" multiValued="true"/>
+  <dynamicField name="*_s1" type="string" indexed="true" stored="true" multiValued="false"/>
+  <!-- :TODO: why are these identical?!?!?! -->
+  <dynamicField name="*_s" type="string" indexed="true" stored="true" multiValued="true"/>
+  <dynamicField name="*_ss" type="string" indexed="true" stored="true" multiValued="true"/>
+  <dynamicField name="*_l" type="long" indexed="true" stored="true"/>
+  <dynamicField name="*_t" type="text" indexed="true" stored="true"/>
+  <dynamicField name="*_tt" type="text" indexed="true" stored="true"/>
+  <dynamicField name="*_b" type="boolean" indexed="true" stored="true"/>
+  <dynamicField name="*_f" type="float" indexed="true" stored="true"/>
+  <dynamicField name="*_d" type="double" indexed="true" stored="true"/>
+  <dynamicField name="*_dt" type="date" indexed="true" stored="true"/>
+
+  <!-- some trie-coded dynamic fields for faster range queries -->
+  <dynamicField name="*_ti" type="tint" indexed="true" stored="true"/>
+  <dynamicField name="*_tl" type="tlong" indexed="true" stored="true"/>
+  <dynamicField name="*_tf" type="tfloat" indexed="true" stored="true"/>
+  <dynamicField name="*_td" type="tdouble" indexed="true" stored="true"/>
+  <dynamicField name="*_tdt" type="tdate" indexed="true" stored="true"/>
+
+  <dynamicField name="ignored_*" type="ignored" multiValued="true"/>
+  <dynamicField name="attr_*" type="text" indexed="true" stored="true" multiValued="true"/>
+
+  <dynamicField name="random_*" type="random"/>
+
+
+  <defaultSearchField>text</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
+
+  <copyField source="title" dest="title_stemmed"/>
+  <copyField source="title" dest="title_lettertok"/>
+
+  <copyField source="title" dest="text"/>
+  <copyField source="subject" dest="text"/>
+
 </schema>
diff --git a/solr/core/src/test-files/solr/configsets/bad-mergepolicy/conf/schema.xml b/solr/core/src/test-files/solr/configsets/bad-mergepolicy/conf/schema.xml
index 9e2f947..287d4fe 100644
--- a/solr/core/src/test-files/solr/configsets/bad-mergepolicy/conf/schema.xml
+++ b/solr/core/src/test-files/solr/configsets/bad-mergepolicy/conf/schema.xml
@@ -16,10 +16,6 @@
  limitations under the License.
 -->
 <schema name="minimal" version="1.1">
- <types>
   <fieldType name="string" class="solr.StrField"/>
- </types>
- <fields>
-   <dynamicField name="*" type="string" indexed="true" stored="true" />
- </fields>
+  <dynamicField name="*" type="string" indexed="true" stored="true"/>
 </schema>
diff --git a/solr/core/src/test-files/solr/configsets/cloud-managed/conf/managed-schema b/solr/core/src/test-files/solr/configsets/cloud-managed/conf/managed-schema
index fd7be83..b9f09f9 100644
--- a/solr/core/src/test-files/solr/configsets/cloud-managed/conf/managed-schema
+++ b/solr/core/src/test-files/solr/configsets/cloud-managed/conf/managed-schema
@@ -16,16 +16,12 @@
  limitations under the License.
 -->
 <schema name="minimal" version="1.1">
- <types>
   <fieldType name="string" class="solr.StrField"/>
   <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
   <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
- </types>
- <fields>
   <!-- for versioning -->
   <field name="_version_" type="long" indexed="true" stored="true"/>
   <field name="_root_" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
   <field name="id" type="string" indexed="true" stored="true"/>
- </fields>
- <uniqueKey>id</uniqueKey>
+  <uniqueKey>id</uniqueKey>
 </schema>
diff --git a/solr/core/src/test-files/solr/configsets/cloud-minimal/conf/schema.xml b/solr/core/src/test-files/solr/configsets/cloud-minimal/conf/schema.xml
index 2a276af..aab5e81 100644
--- a/solr/core/src/test-files/solr/configsets/cloud-minimal/conf/schema.xml
+++ b/solr/core/src/test-files/solr/configsets/cloud-minimal/conf/schema.xml
@@ -16,17 +16,13 @@
  limitations under the License.
 -->
 <schema name="minimal" version="1.1">
- <types>
   <fieldType name="string" class="solr.StrField"/>
   <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
   <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
- </types>
- <fields>
-  <dynamicField name="*" type="string" indexed="true" stored="true" />
+  <dynamicField name="*" type="string" indexed="true" stored="true"/>
   <!-- for versioning -->
   <field name="_version_" type="long" indexed="true" stored="true"/>
   <field name="_root_" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
   <field name="id" type="string" indexed="true" stored="true"/>
- </fields>
- <uniqueKey>id</uniqueKey>
+  <uniqueKey>id</uniqueKey>
 </schema>
diff --git a/solr/core/src/test-files/solr/configsets/configset-2/conf/schema.xml b/solr/core/src/test-files/solr/configsets/configset-2/conf/schema.xml
index 78172ef..981e522 100644
--- a/solr/core/src/test-files/solr/configsets/configset-2/conf/schema.xml
+++ b/solr/core/src/test-files/solr/configsets/configset-2/conf/schema.xml
@@ -16,14 +16,10 @@
  limitations under the License.
 -->
 <schema name="minimal" version="1.1">
- <types>
   <fieldType name="string" class="solr.StrField"/>
   <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
- </types>
- <fields>
-   <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
-   <field name="_root_" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
-   <dynamicField name="*" type="string" indexed="true" stored="true" />
- </fields>
- <uniqueKey>id</uniqueKey>
+  <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="_root_" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
+  <dynamicField name="*" type="string" indexed="true" stored="true"/>
+  <uniqueKey>id</uniqueKey>
 </schema>
diff --git a/solr/core/src/test-files/solr/configsets/minimal/conf/schema.xml b/solr/core/src/test-files/solr/configsets/minimal/conf/schema.xml
index 9e2f947..287d4fe 100644
--- a/solr/core/src/test-files/solr/configsets/minimal/conf/schema.xml
+++ b/solr/core/src/test-files/solr/configsets/minimal/conf/schema.xml
@@ -16,10 +16,6 @@
  limitations under the License.
 -->
 <schema name="minimal" version="1.1">
- <types>
   <fieldType name="string" class="solr.StrField"/>
- </types>
- <fields>
-   <dynamicField name="*" type="string" indexed="true" stored="true" />
- </fields>
+  <dynamicField name="*" type="string" indexed="true" stored="true"/>
 </schema>
diff --git a/solr/core/src/test-files/solr/configsets/resource-sharing/schema.xml b/solr/core/src/test-files/solr/configsets/resource-sharing/schema.xml
index 1288cf4..287d4fe 100644
--- a/solr/core/src/test-files/solr/configsets/resource-sharing/schema.xml
+++ b/solr/core/src/test-files/solr/configsets/resource-sharing/schema.xml
@@ -16,10 +16,6 @@
  limitations under the License.
 -->
 <schema name="minimal" version="1.1">
- <types>
   <fieldType name="string" class="solr.StrField"/>
- </types>
- <fields>
-  <dynamicField name="*" type="string" indexed="true" stored="true" />
- </fields>
+  <dynamicField name="*" type="string" indexed="true" stored="true"/>
 </schema>
diff --git a/solr/core/src/test/org/apache/solr/schema/ChangedSchemaMergeTest.java b/solr/core/src/test/org/apache/solr/schema/ChangedSchemaMergeTest.java
index 683dbe8..70fcc69 100644
--- a/solr/core/src/test/org/apache/solr/schema/ChangedSchemaMergeTest.java
+++ b/solr/core/src/test/org/apache/solr/schema/ChangedSchemaMergeTest.java
@@ -164,14 +164,11 @@ public class ChangedSchemaMergeTest extends SolrTestCaseJ4 {
   }
 
   private static String withWhich = "<schema name=\"tiny\" version=\"1.1\">\n" +
-      "  <fields>\n" +
       "    <field name=\"id\" type=\"string\" indexed=\"true\" stored=\"true\" required=\"true\"/>\n" +
       "    <field name=\"text\" type=\"text\" indexed=\"true\" stored=\"true\"/>\n" +
       "    <field name=\"which\" type=\"int\" indexed=\"true\" stored=\"true\"/>\n" +
-      "  </fields>\n" +
       "  <uniqueKey>id</uniqueKey>\n" +
       "\n" +
-      "  <types>\n" +
       "    <fieldtype name=\"text\" class=\"solr.TextField\">\n" +
       "      <analyzer>\n" +
       "        <tokenizer class=\"solr.WhitespaceTokenizerFactory\"/>\n" +
@@ -181,18 +178,14 @@ public class ChangedSchemaMergeTest extends SolrTestCaseJ4 {
       "    </fieldtype>\n" +
       "    <fieldType name=\"string\" class=\"solr.StrField\"/>\n" +
       "    <fieldType name=\"int\" class=\"solr.TrieIntField\" precisionStep=\"0\" positionIncrementGap=\"0\"/>" +
-      "  </types>\n" +
       "  <similarity class=\"${solr.test.simfac1}\"/> " +
       "</schema>";
 
   private static String withoutWhich = "<schema name=\"tiny\" version=\"1.1\">\n" +
-      "  <fields>\n" +
       "    <field name=\"id\" type=\"string\" indexed=\"true\" stored=\"true\" required=\"true\"/>\n" +
       "    <field name=\"text\" type=\"text\" indexed=\"true\" stored=\"true\"/>\n" +
-      "  </fields>\n" +
       "  <uniqueKey>id</uniqueKey>\n" +
       "\n" +
-      "  <types>\n" +
       "    <fieldtype name=\"text\" class=\"solr.TextField\">\n" +
       "      <analyzer>\n" +
       "        <tokenizer class=\"solr.WhitespaceTokenizerFactory\"/>\n" +
@@ -201,7 +194,6 @@ public class ChangedSchemaMergeTest extends SolrTestCaseJ4 {
       "    </fieldtype>\n" +
       "    <fieldType name=\"string\" class=\"solr.StrField\"/>\n" +
       "    <fieldType name=\"int\" class=\"solr.TrieIntField\" precisionStep=\"0\" positionIncrementGap=\"0\"/>" +
-      "  </types>\n" +
       "  <similarity class=\"${solr.test.simfac2}\"/> " +
       "</schema>";
 
diff --git a/solr/example/example-DIH/solr/db/conf/managed-schema b/solr/example/example-DIH/solr/db/conf/managed-schema
index 156c776..eead56f 100644
--- a/solr/example/example-DIH/solr/db/conf/managed-schema
+++ b/solr/example/example-DIH/solr/db/conf/managed-schema
@@ -68,7 +68,7 @@
    <!-- Valid attributes for fields:
      name: mandatory - the name for the field
      type: mandatory - the name of a field type from the 
-       <types> fieldType section
+       fieldTypes
      indexed: true if this field should be indexed (searchable or sortable)
      stored: true if this field should be retrievable
      docValues: true if this field should have doc values. Doc values are
diff --git a/solr/example/example-DIH/solr/mail/conf/managed-schema b/solr/example/example-DIH/solr/mail/conf/managed-schema
index dc1ec6c..076f83f 100644
--- a/solr/example/example-DIH/solr/mail/conf/managed-schema
+++ b/solr/example/example-DIH/solr/mail/conf/managed-schema
@@ -68,7 +68,7 @@
    <!-- Valid attributes for fields:
      name: mandatory - the name for the field
      type: mandatory - the name of a field type from the 
-       <types> fieldType section
+       fieldTypes
      indexed: true if this field should be indexed (searchable or sortable)
      stored: true if this field should be retrievable
      docValues: true if this field should have doc values. Doc values are
diff --git a/solr/example/example-DIH/solr/rss/conf/managed-schema b/solr/example/example-DIH/solr/rss/conf/managed-schema
index 790e97a..e35f49d 100644
--- a/solr/example/example-DIH/solr/rss/conf/managed-schema
+++ b/solr/example/example-DIH/solr/rss/conf/managed-schema
@@ -68,7 +68,7 @@
    <!-- Valid attributes for fields:
      name: mandatory - the name for the field
      type: mandatory - the name of a field type from the 
-       <types> fieldType section
+       fieldTypes
      indexed: true if this field should be indexed (searchable or sortable)
      stored: true if this field should be retrievable
      docValues: true if this field should have doc values. Doc values are
diff --git a/solr/example/example-DIH/solr/solr/conf/managed-schema b/solr/example/example-DIH/solr/solr/conf/managed-schema
index a714be5..6be0ad9 100644
--- a/solr/example/example-DIH/solr/solr/conf/managed-schema
+++ b/solr/example/example-DIH/solr/solr/conf/managed-schema
@@ -68,7 +68,7 @@
    <!-- Valid attributes for fields:
      name: mandatory - the name for the field
      type: mandatory - the name of a field type from the 
-       <types> fieldType section
+       fieldTypes
      indexed: true if this field should be indexed (searchable or sortable)
      stored: true if this field should be retrievable
      docValues: true if this field should have doc values. Doc values are
diff --git a/solr/example/example-DIH/solr/tika/conf/managed-schema b/solr/example/example-DIH/solr/tika/conf/managed-schema
index daf08c7..c4dccb2 100644
--- a/solr/example/example-DIH/solr/tika/conf/managed-schema
+++ b/solr/example/example-DIH/solr/tika/conf/managed-schema
@@ -68,7 +68,7 @@
    <!-- Valid attributes for fields:
      name: mandatory - the name for the field
      type: mandatory - the name of a field type from the 
-       <types> fieldType section
+       fieldTypes
      indexed: true if this field should be indexed (searchable or sortable)
      stored: true if this field should be retrievable
      docValues: true if this field should have doc values. Doc values are
diff --git a/solr/server/solr/configsets/basic_configs/conf/managed-schema b/solr/server/solr/configsets/basic_configs/conf/managed-schema
index 3ce6b73..ba24bf1 100644
--- a/solr/server/solr/configsets/basic_configs/conf/managed-schema
+++ b/solr/server/solr/configsets/basic_configs/conf/managed-schema
@@ -52,7 +52,7 @@
    <!-- Valid attributes for fields:
      name: mandatory - the name for the field
      type: mandatory - the name of a field type from the 
-       <types> fieldType section
+       fieldTypes
      indexed: true if this field should be indexed (searchable or sortable)
      stored: true if this field should be retrievable
      docValues: true if this field should have doc values. Doc values are
diff --git a/solr/server/solr/configsets/data_driven_schema_configs/conf/managed-schema b/solr/server/solr/configsets/data_driven_schema_configs/conf/managed-schema
index fa9429f..cf2b873 100644
--- a/solr/server/solr/configsets/data_driven_schema_configs/conf/managed-schema
+++ b/solr/server/solr/configsets/data_driven_schema_configs/conf/managed-schema
@@ -67,7 +67,7 @@
     <!-- Valid attributes for fields:
      name: mandatory - the name for the field
      type: mandatory - the name of a field type from the 
-       <types> fieldType section
+       fieldTypes section
      indexed: true if this field should be indexed (searchable or sortable)
      stored: true if this field should be retrievable
      docValues: true if this field should have doc values. Doc values are
diff --git a/solr/server/solr/configsets/sample_techproducts_configs/conf/managed-schema b/solr/server/solr/configsets/sample_techproducts_configs/conf/managed-schema
index 1000d9a..87b84df 100644
--- a/solr/server/solr/configsets/sample_techproducts_configs/conf/managed-schema
+++ b/solr/server/solr/configsets/sample_techproducts_configs/conf/managed-schema
@@ -68,7 +68,7 @@
    <!-- Valid attributes for fields:
      name: mandatory - the name for the field
      type: mandatory - the name of a field type from the 
-       <types> fieldType section
+       fieldTypes
      indexed: true if this field should be indexed (searchable or sortable)
      stored: true if this field should be retrievable
      docValues: true if this field should have doc values. Doc values are
diff --git a/solr/solrj/src/test-files/solrj/solr/collection1/conf/schema-replication1.xml b/solr/solrj/src/test-files/solrj/solr/collection1/conf/schema-replication1.xml
index 6a2184f..b647fa2 100644
--- a/solr/solrj/src/test-files/solrj/solr/collection1/conf/schema-replication1.xml
+++ b/solr/solrj/src/test-files/solrj/solr/collection1/conf/schema-replication1.xml
@@ -26,20 +26,13 @@
   -->
 
 <schema name="test" version="1.2">
-  <types>
 
-    <fieldType name="integer" class="solr.TrieIntField" precisionStep="0"/>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+  <fieldType name="integer" class="solr.TrieIntField" precisionStep="0"/>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
 
+  <field name="id" type="integer" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="name" type="string" indexed="true" stored="true"/>
 
-  </types>
-
-
-  <fields>
-    <field name="id" type="integer" indexed="true" stored="true" multiValued="false" required="false"/>
-    <field name="name" type="string" indexed="true" stored="true"/>
-
-  </fields>
 
   <uniqueKey>id</uniqueKey>
 
diff --git a/solr/solrj/src/test-files/solrj/solr/collection1/conf/schema-sql.xml b/solr/solrj/src/test-files/solrj/solr/collection1/conf/schema-sql.xml
index 25a9bc0..579fda3 100644
--- a/solr/solrj/src/test-files/solrj/solr/collection1/conf/schema-sql.xml
+++ b/solr/solrj/src/test-files/solrj/solr/collection1/conf/schema-sql.xml
@@ -26,550 +26,568 @@
   -->
 
 <schema name="test" version="1.6">
-  <types>
-
-    <!-- field type definitions... note that the "name" attribute is
-         just a label to be used by field definitions.  The "class"
-         attribute and any other attributes determine the real type and
-         behavior of the fieldtype.
-      -->
-
-    <!-- numeric field types that store and index the text
-         value verbatim (and hence don't sort correctly or support range queries.)
-         These are provided more for backward compatability, allowing one
-         to create a schema that matches an existing lucene index.
+
+  <!-- field type definitions... note that the "name" attribute is
+       just a label to be used by field definitions.  The "class"
+       attribute and any other attributes determine the real type and
+       behavior of the fieldtype.
     -->
 
+  <!-- numeric field types that store and index the text
+       value verbatim (and hence don't sort correctly or support range queries.)
+       These are provided more for backward compatability, allowing one
+       to create a schema that matches an existing lucene index.
+  -->
 
-    <fieldType name="int" docValues="true" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="float" docValues="true" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-
-    <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
-
-    <!-- numeric field types that manipulate the value into
-       a string value that isn't human readable in it's internal form,
-       but sorts correctly and supports range queries.
-
-         If sortMissingLast="true" then a sort on this field will cause documents
-       without the field to come after documents with the field,
-       regardless of the requested sort order.
-         If sortMissingFirst="true" then a sort on this field will cause documents
-       without the field to come before documents with the field,
-       regardless of the requested sort order.
-         If sortMissingLast="false" and sortMissingFirst="false" (the default),
-       then default lucene sorting will be used which places docs without the field
-       first in an ascending sort and last in a descending sort.
-    -->
 
+  <fieldType name="int" docValues="true" class="solr.TrieIntField" precisionStep="0" omitNorms="true"
+             positionIncrementGap="0"/>
+  <fieldType name="float" docValues="true" class="solr.TrieFloatField" precisionStep="0" omitNorms="true"
+             positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+
+  <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+
+  <!-- numeric field types that manipulate the value into
+     a string value that isn't human readable in it's internal form,
+     but sorts correctly and supports range queries.
+
+       If sortMissingLast="true" then a sort on this field will cause documents
+     without the field to come after documents with the field,
+     regardless of the requested sort order.
+       If sortMissingFirst="true" then a sort on this field will cause documents
+     without the field to come before documents with the field,
+     regardless of the requested sort order.
+       If sortMissingLast="false" and sortMissingFirst="false" (the default),
+     then default lucene sorting will be used which places docs without the field
+     first in an ascending sort and last in a descending sort.
+  -->
 
 
-    <!-- Field type demonstrating an Analyzer failure -->
-    <fieldtype name="failtype1" class="solr.TextField">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-
-    <!-- Demonstrating ignoreCaseChange -->
-    <fieldtype name="wdf_nocase" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-
-    <fieldtype name="wdf_preserve" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-
-
-    <fieldtype name="boolean" class="solr.BoolField" sortMissingLast="true"/>
-    <fieldtype name="string" class="solr.StrField" sortMissingLast="true" docValues="true"/>
-
-    <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
-         seconds part (.999) is optional.
-      -->
-    <fieldtype name="date" class="solr.TrieDateField" precisionStep="0"/>
-    <fieldtype name="tdate" class="solr.TrieDateField" precisionStep="6"/>
-
-
-    <!-- solr.TextField allows the specification of custom
-         text analyzers specified as a tokenizer and a list
-         of token filters.
-      -->
-    <fieldtype name="text" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-
-
-    <fieldtype name="nametext" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.core.WhitespaceAnalyzer"/>
-    </fieldtype>
-
-    <fieldtype name="teststop" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.LowerCaseTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-
-    <!-- fieldtypes in this section isolate tokenizers and tokenfilters for testing -->
-    <fieldtype name="lowertok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.LowerCaseTokenizerFactory"/></analyzer>
-    </fieldtype>
-    <fieldtype name="keywordtok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/></analyzer>
-    </fieldtype>
-    <fieldtype name="standardtok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.StandardTokenizerFactory"/></analyzer>
-    </fieldtype>
-    <fieldtype name="lettertok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.LetterTokenizerFactory"/></analyzer>
-    </fieldtype>
-    <fieldtype name="whitetok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.MockTokenizerFactory"/></analyzer>
-    </fieldtype>
-    <fieldtype name="HTMLstandardtok" class="solr.TextField">
-      <analyzer>
-        <charFilter class="solr.HTMLStripCharFilterFactory"/>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="HTMLwhitetok" class="solr.TextField">
-      <analyzer>
-        <charFilter class="solr.HTMLStripCharFilterFactory"/>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="standardtokfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="standardfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="lowerfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="lowerpunctfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="1" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="patternreplacefilt" class="solr.TextField">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
-        <filter class="solr.PatternReplaceFilterFactory"
-                pattern="([^a-zA-Z])" replacement="_" replace="all"
-            />
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="patterntok" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.PatternTokenizerFactory" pattern=","/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="porterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-    <!-- fieldtype name="snowballfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.SnowballPorterFilterFactory"/>
-      </analyzer>
-    </fieldtype -->
-    <fieldtype name="engporterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="custengporterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="stopfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true"/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="custstopfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldtype>
-    <fieldtype name="lengthfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LengthFilterFactory" min="2" max="5"/>
-      </analyzer>
-    </fieldtype>
-    <fieldType name="charfilthtmlmap" class="solr.TextField">
-      <analyzer>
-        <charFilter class="solr.HTMLStripCharFilterFactory"/>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldtype name="subword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-
-    <fieldtype name="numericsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-        <filter class="solr.StopFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-        <filter class="solr.StopFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-
-    <fieldtype name="protectedsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory"  splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-
-
-    <!-- more flexible in matching skus, but more chance of a false match -->
-    <fieldtype name="skutype1" class="solr.TextField">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-
-    <!-- less flexible in matching skus, but less chance of a false match -->
-    <fieldtype name="skutype2" class="solr.TextField">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-
-    <!-- less flexible in matching skus, but less chance of a false match -->
-    <fieldtype name="syn" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldtype>
-
-
-    <fieldtype  name="unstored" class="solr.StrField" indexed="true" stored="false"/>
-
-
-    <fieldtype name="textgap" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldtype>
-
-    <fieldType name="uuid" class="solr.UUIDField" />
-
-    <!-- Try out some point types -->
-    <fieldType name="xy" class="solr.PointType" dimension="2" subFieldType="double"/>
-    <fieldType name="x" class="solr.PointType" dimension="1" subFieldType="double"/>
-    <fieldType name="tenD" class="solr.PointType" dimension="10" subFieldType="double"/>
-    <!-- Use the sub field suffix -->
-    <fieldType name="xyd" class="solr.PointType" dimension="2" subFieldSuffix="_d1"/>
-    <fieldtype name="geohash" class="solr.GeoHashField"/>
-
-
-    <fieldType name="latLon" class="solr.LatLonType" subFieldType="double"/>
-
-    <!--  some per-field similarity examples -->
-
-    <!--  specify a Similarity classname directly -->
-    <!--
-    <fieldType name="sim1" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-      <similarity class="org.apache.lucene.misc.SweetSpotSimilarity"/>
-    </fieldType>
-    -->
-    <!--  specify a Similarity factory -->
-    <!--
-    <fieldType name="sim2" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-      <similarity class="org.apache.solr.search.similarities.CustomSimilarityFactory">
-        <str name="echo">is there an echo?</str>
-      </similarity>
-    </fieldType>
-    -->
-    <!-- don't specify any sim at all: get the default  -->
-    <!--
-    <fieldType name="sim3" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
+  <!-- Field type demonstrating an Analyzer failure -->
+  <fieldtype name="failtype1" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0"
+              catenateNumbers="0" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+
+  <!-- Demonstrating ignoreCaseChange -->
+  <fieldtype name="wdf_nocase" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+
+  <fieldtype name="wdf_preserve" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+
+
+  <fieldtype name="boolean" class="solr.BoolField" sortMissingLast="true"/>
+  <fieldtype name="string" class="solr.StrField" sortMissingLast="true" docValues="true"/>
+
+  <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
+       seconds part (.999) is optional.
     -->
-  </types>
-
-
-  <fields>
-    <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
-    <field name="signatureField" type="string" indexed="true" stored="false"/>
-
-    <field name="s_multi" type="string" indexed="true" stored="true" docValues="true" multiValued="true"/>
-    <field name="i_multi" type="int" indexed="true" stored="true" docValues="true" multiValued="true"/>
-    <field name="f_multi" type="float" indexed="true" stored="true" docValues="true" multiValued="true"/>
-    <field name="l_multi" type="long" indexed="true" stored="true" docValues="true" multiValued="true"/>
-    <field name="d_multi" type="double" indexed="true" stored="true" docValues="true" multiValued="true"/>
-
-    <field name="uuid" type="uuid" stored="true" />
-    <field name="name" type="nametext" indexed="true" stored="true"/>
-    <field name="text" type="text" indexed="true" stored="false"/>
-    <field name="subject" type="text" indexed="true" stored="true"/>
-    <field name="title" type="nametext" indexed="true" stored="true"/>
-    <field name="weight" type="float" indexed="true" stored="true" multiValued="false"/>
-    <field name="bday" type="date" indexed="true" stored="true" multiValued="false"/>
-
-    <field name="title_stemmed" type="text" indexed="true" stored="false"/>
-    <field name="title_lettertok" type="lettertok" indexed="true" stored="false"/>
-
-    <field name="syn" type="syn" indexed="true" stored="true"/>
-
-    <!-- to test property inheritance and overriding -->
-    <field name="shouldbeunstored" type="unstored" />
-    <field name="shouldbestored" type="unstored" stored="true"/>
-    <field name="shouldbeunindexed" type="unstored" indexed="false" stored="true"/>
-
-    <!-- Test points -->
-    <!-- Test points -->
-    <field name="home" type="xy" indexed="true" stored="true" multiValued="false"/>
-    <field name="x" type="x" indexed="true" stored="true" multiValued="false"/>
-    <field name="homed" type="xyd" indexed="true" stored="true" multiValued="false"/>
-    <field name="home_ns" type="xy" indexed="true" stored="false" multiValued="false"/>
-    <field name="work" type="xy" indexed="true" stored="true" multiValued="false"/>
-
-    <field name="home_ll" type="latLon" indexed="true" stored="true" multiValued="false"/>
-    <field name="home_gh" type="geohash" indexed="true" stored="true" multiValued="false"/>
-
-
-    <field name="point10" type="tenD" indexed="true" stored="true" multiValued="false"/>
-
-
-    <!-- test different combinations of indexed and stored -->
-    <field name="bind" type="boolean" indexed="true" stored="false"/>
-    <field name="bsto" type="boolean" indexed="false" stored="true"/>
-    <field name="bindsto" type="boolean" indexed="true" stored="true"/>
-    <field name="isto" type="int" indexed="false" stored="true"/>
-    <field name="iind" type="int" indexed="true" stored="false"/>
-    <field name="ssto" type="string" indexed="false" stored="true"/>
-    <field name="sind" type="string" indexed="true" stored="false"/>
-    <field name="sindsto" type="string" indexed="true" stored="true"/>
-
-    <!-- test combinations of term vector settings -->
-    <field name="test_basictv" type="text" termVectors="true"/>
-    <field name="test_notv" type="text" termVectors="false"/>
-    <field name="test_postv" type="text" termVectors="true" termPositions="true"/>
-    <field name="test_offtv" type="text" termVectors="true" termOffsets="true"/>
-    <field name="test_posofftv" type="text" termVectors="true"
-           termPositions="true" termOffsets="true"/>
-
-    <!-- fields to test individual tokenizers and tokenfilters -->
-    <field name="teststop" type="teststop" indexed="true" stored="true"/>
-    <field name="lowertok" type="lowertok" indexed="true" stored="true"/>
-    <field name="keywordtok" type="keywordtok" indexed="true" stored="true"/>
-    <field name="standardtok" type="standardtok" indexed="true" stored="true"/>
-    <field name="HTMLstandardtok" type="HTMLstandardtok" indexed="true" stored="true"/>
-    <field name="lettertok" type="lettertok" indexed="true" stored="true"/>
-    <field name="whitetok" type="whitetok" indexed="true" stored="true"/>
-    <field name="HTMLwhitetok" type="HTMLwhitetok" indexed="true" stored="true"/>
-    <field name="standardtokfilt" type="standardtokfilt" indexed="true" stored="true"/>
-    <field name="standardfilt" type="standardfilt" indexed="true" stored="true"/>
-    <field name="lowerfilt" type="lowerfilt" indexed="true" stored="true"/>
-    <field name="lowerfilt1" type="lowerfilt" indexed="true" stored="true"/>
-    <field name="lowerfilt1and2" type="lowerfilt" indexed="true" stored="true"/>
-    <field name="patterntok" type="patterntok" indexed="true" stored="true"/>
-    <field name="patternreplacefilt" type="patternreplacefilt" indexed="true" stored="true"/>
-    <field name="porterfilt" type="porterfilt" indexed="true" stored="true"/>
-    <field name="engporterfilt" type="engporterfilt" indexed="true" stored="true"/>
-    <field name="custengporterfilt" type="custengporterfilt" indexed="true" stored="true"/>
-    <field name="stopfilt" type="stopfilt" indexed="true" stored="true"/>
-    <field name="custstopfilt" type="custstopfilt" indexed="true" stored="true"/>
-    <field name="lengthfilt" type="lengthfilt" indexed="true" stored="true"/>
-    <field name="wdf_nocase" type="wdf_nocase" indexed="true" stored="true"/>
-    <field name="wdf_preserve" type="wdf_preserve" indexed="true" stored="true"/>
-
-    <field name="numberpartfail" type="failtype1" indexed="true" stored="true"/>
-
-    <field name="nullfirst" type="string" indexed="true" stored="true" sortMissingFirst="true" multiValued="false"/>
-
-    <field name="subword" type="subword" indexed="true" stored="true"/>
-    <field name="subword_offsets" type="subword" indexed="true" stored="true" termOffsets="true"/>
-    <field name="numericsubword" type="numericsubword" indexed="true" stored="true"/>
-    <field name="protectedsubword" type="protectedsubword" indexed="true" stored="true"/>
-
-    <field name="sku1" type="skutype1" indexed="true" stored="true"/>
-    <field name="sku2" type="skutype2" indexed="true" stored="true"/>
-
-    <field name="textgap" type="textgap" indexed="true" stored="true"/>
-
-    <field name="timestamp" type="date" indexed="true" stored="true" default="NOW" multiValued="false"/>
-    <field name="multiDefault" type="string" indexed="true" stored="true" default="muLti-Default" multiValued="true"/>
-    <field name="intDefault" type="int" indexed="true" stored="true" default="42" multiValued="false"/>
-
-    <!--
-    <field name="sim1text" type="sim1" indexed="true" stored="true"/>
-    <field name="sim2text" type="sim2" indexed="true" stored="true"/>
-    <field name="sim3text" type="sim3" indexed="true" stored="true"/>
+  <fieldtype name="date" class="solr.TrieDateField" precisionStep="0"/>
+  <fieldtype name="tdate" class="solr.TrieDateField" precisionStep="6"/>
+
+
+  <!-- solr.TextField allows the specification of custom
+       text analyzers specified as a tokenizer and a list
+       of token filters.
     -->
+  <fieldtype name="text" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+
+
+  <fieldtype name="nametext" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.core.WhitespaceAnalyzer"/>
+  </fieldtype>
+
+  <fieldtype name="teststop" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LowerCaseTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+
+  <!-- fieldtypes in this section isolate tokenizers and tokenfilters for testing -->
+  <fieldtype name="lowertok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LowerCaseTokenizerFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="keywordtok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="standardtok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="lettertok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LetterTokenizerFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="whitetok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="HTMLstandardtok" class="solr.TextField">
+    <analyzer>
+      <charFilter class="solr.HTMLStripCharFilterFactory"/>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="HTMLwhitetok" class="solr.TextField">
+    <analyzer>
+      <charFilter class="solr.HTMLStripCharFilterFactory"/>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="standardtokfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="standardfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="lowerfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="lowerpunctfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="1" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="patternreplacefilt" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+      <filter class="solr.PatternReplaceFilterFactory"
+              pattern="([^a-zA-Z])" replacement="_" replace="all"
+      />
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="patterntok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.PatternTokenizerFactory" pattern=","/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="porterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+  <!-- fieldtype name="snowballfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SnowballPorterFilterFactory"/>
+    </analyzer>
+  </fieldtype -->
+  <fieldtype name="engporterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="custengporterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="stopfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="custstopfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldtype>
+  <fieldtype name="lengthfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LengthFilterFactory" min="2" max="5"/>
+    </analyzer>
+  </fieldtype>
+  <fieldType name="charfilthtmlmap" class="solr.TextField">
+    <analyzer>
+      <charFilter class="solr.HTMLStripCharFilterFactory"/>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldtype name="subword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+
+  <fieldtype name="numericsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1"
+              generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1"
+              generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+
+  <fieldtype name="protectedsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1"
+              generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+
+
+  <!-- more flexible in matching skus, but more chance of a false match -->
+  <fieldtype name="skutype1" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+
+  <!-- less flexible in matching skus, but less chance of a false match -->
+  <fieldtype name="skutype2" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+
+  <!-- less flexible in matching skus, but less chance of a false match -->
+  <fieldtype name="syn" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldtype>
+
+
+  <fieldtype name="unstored" class="solr.StrField" indexed="true" stored="false"/>
+
+
+  <fieldtype name="textgap" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldtype>
+
+  <fieldType name="uuid" class="solr.UUIDField"/>
+
+  <!-- Try out some point types -->
+  <fieldType name="xy" class="solr.PointType" dimension="2" subFieldType="double"/>
+  <fieldType name="x" class="solr.PointType" dimension="1" subFieldType="double"/>
+  <fieldType name="tenD" class="solr.PointType" dimension="10" subFieldType="double"/>
+  <!-- Use the sub field suffix -->
+  <fieldType name="xyd" class="solr.PointType" dimension="2" subFieldSuffix="_d1"/>
+  <fieldtype name="geohash" class="solr.GeoHashField"/>
+
+
+  <fieldType name="latLon" class="solr.LatLonType" subFieldType="double"/>
+
+  <!--  some per-field similarity examples -->
+
+  <!--  specify a Similarity classname directly -->
+  <!--
+  <fieldType name="sim1" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+    <similarity class="org.apache.lucene.misc.SweetSpotSimilarity"/>
+  </fieldType>
+  -->
+  <!--  specify a Similarity factory -->
+  <!--
+  <fieldType name="sim2" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+    <similarity class="org.apache.solr.search.similarities.CustomSimilarityFactory">
+      <str name="echo">is there an echo?</str>
+    </similarity>
+  </fieldType>
+  -->
+  <!-- don't specify any sim at all: get the default  -->
+  <!--
+  <fieldType name="sim3" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  -->
 
-    <field name="tlong" type="tlong" indexed="true" stored="true" />
 
-    <field name="_version_" type="long" indexed="true" stored="true"/>
+  <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="signatureField" type="string" indexed="true" stored="false"/>
+
+  <field name="s_multi" type="string" indexed="true" stored="true" docValues="true" multiValued="true"/>
+  <field name="i_multi" type="int" indexed="true" stored="true" docValues="true" multiValued="true"/>
+  <field name="f_multi" type="float" indexed="true" stored="true" docValues="true" multiValued="true"/>
+  <field name="l_multi" type="long" indexed="true" stored="true" docValues="true" multiValued="true"/>
+  <field name="d_multi" type="double" indexed="true" stored="true" docValues="true" multiValued="true"/>
+
+  <field name="uuid" type="uuid" stored="true"/>
+  <field name="name" type="nametext" indexed="true" stored="true"/>
+  <field name="text" type="text" indexed="true" stored="false"/>
+  <field name="subject" type="text" indexed="true" stored="true"/>
+  <field name="title" type="nametext" indexed="true" stored="true"/>
+  <field name="weight" type="float" indexed="true" stored="true" multiValued="false"/>
+  <field name="bday" type="date" indexed="true" stored="true" multiValued="false"/>
+
+  <field name="title_stemmed" type="text" indexed="true" stored="false"/>
+  <field name="title_lettertok" type="lettertok" indexed="true" stored="false"/>
+
+  <field name="syn" type="syn" indexed="true" stored="true"/>
+
+  <!-- to test property inheritance and overriding -->
+  <field name="shouldbeunstored" type="unstored"/>
+  <field name="shouldbestored" type="unstored" stored="true"/>
+  <field name="shouldbeunindexed" type="unstored" indexed="false" stored="true"/>
+
+  <!-- Test points -->
+  <!-- Test points -->
+  <field name="home" type="xy" indexed="true" stored="true" multiValued="false"/>
+  <field name="x" type="x" indexed="true" stored="true" multiValued="false"/>
+  <field name="homed" type="xyd" indexed="true" stored="true" multiValued="false"/>
+  <field name="home_ns" type="xy" indexed="true" stored="false" multiValued="false"/>
+  <field name="work" type="xy" indexed="true" stored="true" multiValued="false"/>
+
+  <field name="home_ll" type="latLon" indexed="true" stored="true" multiValued="false"/>
+  <field name="home_gh" type="geohash" indexed="true" stored="true" multiValued="false"/>
+
+
+  <field name="point10" type="tenD" indexed="true" stored="true" multiValued="false"/>
+
+
+  <!-- test different combinations of indexed and stored -->
+  <field name="bind" type="boolean" indexed="true" stored="false"/>
+  <field name="bsto" type="boolean" indexed="false" stored="true"/>
+  <field name="bindsto" type="boolean" indexed="true" stored="true"/>
+  <field name="isto" type="int" indexed="false" stored="true"/>
+  <field name="iind" type="int" indexed="true" stored="false"/>
+  <field name="ssto" type="string" indexed="false" stored="true"/>
+  <field name="sind" type="string" indexed="true" stored="false"/>
+  <field name="sindsto" type="string" indexed="true" stored="true"/>
+
+  <!-- test combinations of term vector settings -->
+  <field name="test_basictv" type="text" termVectors="true"/>
+  <field name="test_notv" type="text" termVectors="false"/>
+  <field name="test_postv" type="text" termVectors="true" termPositions="true"/>
+  <field name="test_offtv" type="text" termVectors="true" termOffsets="true"/>
+  <field name="test_posofftv" type="text" termVectors="true"
+         termPositions="true" termOffsets="true"/>
+
+  <!-- fields to test individual tokenizers and tokenfilters -->
+  <field name="teststop" type="teststop" indexed="true" stored="true"/>
+  <field name="lowertok" type="lowertok" indexed="true" stored="true"/>
+  <field name="keywordtok" type="keywordtok" indexed="true" stored="true"/>
+  <field name="standardtok" type="standardtok" indexed="true" stored="true"/>
+  <field name="HTMLstandardtok" type="HTMLstandardtok" indexed="true" stored="true"/>
+  <field name="lettertok" type="lettertok" indexed="true" stored="true"/>
+  <field name="whitetok" type="whitetok" indexed="true" stored="true"/>
+  <field name="HTMLwhitetok" type="HTMLwhitetok" indexed="true" stored="true"/>
+  <field name="standardtokfilt" type="standardtokfilt" indexed="true" stored="true"/>
+  <field name="standardfilt" type="standardfilt" indexed="true" stored="true"/>
+  <field name="lowerfilt" type="lowerfilt" indexed="true" stored="true"/>
+  <field name="lowerfilt1" type="lowerfilt" indexed="true" stored="true"/>
+  <field name="lowerfilt1and2" type="lowerfilt" indexed="true" stored="true"/>
+  <field name="patterntok" type="patterntok" indexed="true" stored="true"/>
+  <field name="patternreplacefilt" type="patternreplacefilt" indexed="true" stored="true"/>
+  <field name="porterfilt" type="porterfilt" indexed="true" stored="true"/>
+  <field name="engporterfilt" type="engporterfilt" indexed="true" stored="true"/>
+  <field name="custengporterfilt" type="custengporterfilt" indexed="true" stored="true"/>
+  <field name="stopfilt" type="stopfilt" indexed="true" stored="true"/>
+  <field name="custstopfilt" type="custstopfilt" indexed="true" stored="true"/>
+  <field name="lengthfilt" type="lengthfilt" indexed="true" stored="true"/>
+  <field name="wdf_nocase" type="wdf_nocase" indexed="true" stored="true"/>
+  <field name="wdf_preserve" type="wdf_preserve" indexed="true" stored="true"/>
+
+  <field name="numberpartfail" type="failtype1" indexed="true" stored="true"/>
+
+  <field name="nullfirst" type="string" indexed="true" stored="true" sortMissingFirst="true" multiValued="false"/>
+
+  <field name="subword" type="subword" indexed="true" stored="true"/>
+  <field name="subword_offsets" type="subword" indexed="true" stored="true" termOffsets="true"/>
+  <field name="numericsubword" type="numericsubword" indexed="true" stored="true"/>
+  <field name="protectedsubword" type="protectedsubword" indexed="true" stored="true"/>
+
+  <field name="sku1" type="skutype1" indexed="true" stored="true"/>
+  <field name="sku2" type="skutype2" indexed="true" stored="true"/>
+
+  <field name="textgap" type="textgap" indexed="true" stored="true"/>
+
+  <field name="timestamp" type="date" indexed="true" stored="true" default="NOW" multiValued="false"/>
+  <field name="multiDefault" type="string" indexed="true" stored="true" default="muLti-Default" multiValued="true"/>
+  <field name="intDefault" type="int" indexed="true" stored="true" default="42" multiValued="false"/>
+
+  <!--
+  <field name="sim1text" type="sim1" indexed="true" stored="true"/>
+  <field name="sim2text" type="sim2" indexed="true" stored="true"/>
+  <field name="sim3text" type="sim3" indexed="true" stored="true"/>
+  -->
 
-    <!-- Dynamic field definitions.  If a field name is not found, dynamicFields
-         will be used if the name matches any of the patterns.
-         RESTRICTION: the glob-like pattern in the name attribute must have
-         a "*" only at the start or the end.
-         EXAMPLE:  name="*_i" will match any field ending in _i (like myid_i, z_i)
-         Longer patterns will be matched first.  if equal size patterns
-         both match, the first appearing in the schema will be used.
-    -->
-    <dynamicField name="*_i"  type="int"    indexed="true"  stored="true"/>
-    <dynamicField name="*_i1"  type="int"    indexed="true" stored="true" multiValued="false"/>
-
-    <dynamicField name="*_s"  type="string"  indexed="true"  stored="true"/>
-    <dynamicField name="*_s1"  type="string"  indexed="true"  stored="true" multiValued="false"/>
-    <dynamicField name="*_l"  type="long"   indexed="true"  stored="true"/>
-    <dynamicField name="*_l1"  type="long"   indexed="true"  stored="true" multiValued="false"/>
-    <dynamicField name="*_t"  type="text"    indexed="true"  stored="true"/>
-    <dynamicField name="*_b"  type="boolean" indexed="true"  stored="true"/>
-    <dynamicField name="*_f"  type="float"  indexed="true"  stored="true"/>
-    <dynamicField name="*_f1"  type="float"  indexed="true"  stored="true" multiValued="false"/>
-    <dynamicField name="*_d"  type="double" indexed="true"  stored="true"/>
-    <dynamicField name="*_d1"  type="double" indexed="true"  stored="true" multiValued="false"/>
-    <dynamicField name="*_dt" type="date"    indexed="true"  stored="true"/>
-    <dynamicField name="*_dt1" type="date"    indexed="true"  stored="true" multiValued="false"/>
-
-    <!-- some trie-coded dynamic fields for faster range queries -->
-    <dynamicField name="*_ti" type="tint"    indexed="true"  stored="true"/>
-    <dynamicField name="*_ti1" type="tint"    indexed="true"  stored="true" multiValued="false"/>
-    <dynamicField name="*_tl" type="tlong"   indexed="true"  stored="true"/>
-    <dynamicField name="*_tl1" type="tlong"   indexed="true"  stored="true" multiValued="false"/>
-    <dynamicField name="*_tf" type="tfloat"  indexed="true"  stored="true"/>
-    <dynamicField name="*_tf1" type="tfloat"  indexed="true"  stored="true" multiValued="false"/>
-    <dynamicField name="*_td" type="tdouble" indexed="true"  stored="true"/>
-    <dynamicField name="*_td1" type="tdouble" indexed="true" stored="true" multiValued="false"/>
-    <dynamicField name="*_tds" type="tdouble" indexed="true" stored="true" multiValued="false"/>
-    <dynamicField name="*_tdt" type="tdate"  indexed="true"  stored="true"/>
-    <dynamicField name="*_tdt1" type="tdate"  indexed="true"  stored="true" multiValued="false"/>
-
-
-
-
-    <dynamicField name="*_sI" type="string"  indexed="true"  stored="false"/>
-    <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
-    <dynamicField name="t_*"  type="text"    indexed="true"  stored="true"/>
-    <dynamicField name="tv_*"  type="text" indexed="true"  stored="true"
-                  termVectors="true" termPositions="true" termOffsets="true"/>
-    <dynamicField name="tv_mv_*"  type="text" indexed="true"  stored="true" multiValued="true"
-                  termVectors="true" termPositions="true" termOffsets="true"/>
-
-    <dynamicField name="*_p"  type="xyd" indexed="true"  stored="true" multiValued="false"/>
-
-    <!-- special fields for dynamic copyField test -->
-    <dynamicField name="dynamic_*" type="string" indexed="true" stored="true"/>
-    <dynamicField name="*_dynamic" type="string" indexed="true" stored="true"/>
-
-    <!-- for testing to ensure that longer patterns are matched first -->
-    <dynamicField name="*aa"  type="string"  indexed="true" stored="true"/>
-
-    <!-- ignored becuase not stored or indexed -->
-    <dynamicField name="*_ignored" type="text" indexed="false" stored="false"/>
-
-    <dynamicField name="*_mfacet" type="string" indexed="true" stored="false" multiValued="true" />
-
-    <!-- make sure custom sims work with dynamic fields -->
-    <!--
-    <dynamicField name="*_sim1" type="sim1" indexed="true" stored="true"/>
-    <dynamicField name="*_sim2" type="sim2" indexed="true" stored="true"/>
-    <dynamicField name="*_sim3" type="sim3" indexed="true" stored="true"/>
-    -->
-  </fields>
+  <field name="tlong" type="tlong" indexed="true" stored="true"/>
+
+  <field name="_version_" type="long" indexed="true" stored="true"/>
+
+  <!-- Dynamic field definitions.  If a field name is not found, dynamicFields
+       will be used if the name matches any of the patterns.
+       RESTRICTION: the glob-like pattern in the name attribute must have
+       a "*" only at the start or the end.
+       EXAMPLE:  name="*_i" will match any field ending in _i (like myid_i, z_i)
+       Longer patterns will be matched first.  if equal size patterns
+       both match, the first appearing in the schema will be used.
+  -->
+  <dynamicField name="*_i" type="int" indexed="true" stored="true"/>
+  <dynamicField name="*_i1" type="int" indexed="true" stored="true" multiValued="false"/>
+
+  <dynamicField name="*_s" type="string" indexed="true" stored="true"/>
+  <dynamicField name="*_s1" type="string" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_l" type="long" indexed="true" stored="true"/>
+  <dynamicField name="*_l1" type="long" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_t" type="text" indexed="true" stored="true"/>
+  <dynamicField name="*_b" type="boolean" indexed="true" stored="true"/>
+  <dynamicField name="*_f" type="float" indexed="true" stored="true"/>
+  <dynamicField name="*_f1" type="float" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_d" type="double" indexed="true" stored="true"/>
+  <dynamicField name="*_d1" type="double" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_dt" type="date" indexed="true" stored="true"/>
+  <dynamicField name="*_dt1" type="date" indexed="true" stored="true" multiValued="false"/>
+
+  <!-- some trie-coded dynamic fields for faster range queries -->
+  <dynamicField name="*_ti" type="tint" indexed="true" stored="true"/>
+  <dynamicField name="*_ti1" type="tint" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_tl" type="tlong" indexed="true" stored="true"/>
+  <dynamicField name="*_tl1" type="tlong" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_tf" type="tfloat" indexed="true" stored="true"/>
+  <dynamicField name="*_tf1" type="tfloat" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_td" type="tdouble" indexed="true" stored="true"/>
+  <dynamicField name="*_td1" type="tdouble" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_tds" type="tdouble" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_tdt" type="tdate" indexed="true" stored="true"/>
+  <dynamicField name="*_tdt1" type="tdate" indexed="true" stored="true" multiValued="false"/>
+
+
+  <dynamicField name="*_sI" type="string" indexed="true" stored="false"/>
+  <dynamicField name="*_sS" type="string" indexed="false" stored="true"/>
+  <dynamicField name="t_*" type="text" indexed="true" stored="true"/>
+  <dynamicField name="tv_*" type="text" indexed="true" stored="true"
+                termVectors="true" termPositions="true" termOffsets="true"/>
+  <dynamicField name="tv_mv_*" type="text" indexed="true" stored="true" multiValued="true"
+                termVectors="true" termPositions="true" termOffsets="true"/>
+
+  <dynamicField name="*_p" type="xyd" indexed="true" stored="true" multiValued="false"/>
+
+  <!-- special fields for dynamic copyField test -->
+  <dynamicField name="dynamic_*" type="string" indexed="true" stored="true"/>
+  <dynamicField name="*_dynamic" type="string" indexed="true" stored="true"/>
+
+  <!-- for testing to ensure that longer patterns are matched first -->
+  <dynamicField name="*aa" type="string" indexed="true" stored="true"/>
+
+  <!-- ignored becuase not stored or indexed -->
+  <dynamicField name="*_ignored" type="text" indexed="false" stored="false"/>
+
+  <dynamicField name="*_mfacet" type="string" indexed="true" stored="false" multiValued="true"/>
+
+  <!-- make sure custom sims work with dynamic fields -->
+  <!--
+  <dynamicField name="*_sim1" type="sim1" indexed="true" stored="true"/>
+  <dynamicField name="*_sim2" type="sim2" indexed="true" stored="true"/>
+  <dynamicField name="*_sim3" type="sim3" indexed="true" stored="true"/>
+  -->
 
   <defaultSearchField>text</defaultSearchField>
   <uniqueKey>id</uniqueKey>
@@ -590,9 +608,6 @@
   <copyField source="*_t" dest="text"/>
 
 
-
-
-
   <!-- dynamic destination -->
   <copyField source="*_dynamic" dest="dynamic_*"/>
 
diff --git a/solr/solrj/src/test-files/solrj/solr/collection1/conf/schema.xml b/solr/solrj/src/test-files/solrj/solr/collection1/conf/schema.xml
index a63a620..49f08b8 100644
--- a/solr/solrj/src/test-files/solrj/solr/collection1/conf/schema.xml
+++ b/solr/solrj/src/test-files/solrj/solr/collection1/conf/schema.xml
@@ -26,312 +26,334 @@
   -->
 
 <schema name="test" version="1.6">
-  <types>
-
-    <!-- field type definitions... note that the "name" attribute is
-         just a label to be used by field definitions.  The "class"
-         attribute and any other attributes determine the real type and
-         behavior of the fieldType.
-      -->
-
-    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
-
-    <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
-    <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
-
-    <!-- Field type demonstrating an Analyzer failure -->
-    <fieldType name="failtype1" class="solr.TextField">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- Demonstrating ignoreCaseChange -->
-    <fieldType name="wdf_nocase" class="solr.TextField">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-     <fieldType name="wdf_preserve" class="solr.TextField">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="1"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
-
-    <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
-         seconds part (.999) is optional.
-      -->
-    <fieldType name="date" class="solr.TrieDateField" precisionStep="0"/>
-    <fieldType name="tdate" class="solr.TrieDateField" precisionStep="6"/>
-
-
-    <!-- solr.TextField allows the specification of custom
-         text analyzers specified as a tokenizer and a list
-         of token filters.
-      -->
-    <fieldType name="text" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.StopFilterFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <fieldType name="nametext" class="solr.TextField">
-      <analyzer class="org.apache.lucene.analysis.core.WhitespaceAnalyzer"/>
-    </fieldType>
-
-    <fieldType name="teststop" class="solr.TextField">
-       <analyzer>
-        <tokenizer class="solr.LowerCaseTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- fieldTypes in this section isolate tokenizers and tokenfilters for testing -->
-    <fieldType name="lowertok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.LowerCaseTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="keywordtok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/></analyzer>
-    </fieldType>
-    <fieldType name="standardtok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.StandardTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="lettertok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.LetterTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="whitetok" class="solr.TextField">
-      <analyzer><tokenizer class="solr.MockTokenizerFactory"/></analyzer>
-    </fieldType>
-    <fieldType name="HTMLstandardtok" class="solr.TextField">
-      <analyzer>
+
+  <!-- field type definitions... note that the "name" attribute is
+       just a label to be used by field definitions.  The "class"
+       attribute and any other attributes determine the real type and
+       behavior of the fieldType.
+    -->
+
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+
+  <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+  <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
+
+  <!-- Field type demonstrating an Analyzer failure -->
+  <fieldType name="failtype1" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0"
+              catenateNumbers="0" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- Demonstrating ignoreCaseChange -->
+  <fieldType name="wdf_nocase" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="0" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="wdf_preserve" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" preserveOriginal="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
+
+  <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
+       seconds part (.999) is optional.
+    -->
+  <fieldType name="date" class="solr.TrieDateField" precisionStep="0"/>
+  <fieldType name="tdate" class="solr.TrieDateField" precisionStep="6"/>
+
+
+  <!-- solr.TextField allows the specification of custom
+       text analyzers specified as a tokenizer and a list
+       of token filters.
+    -->
+  <fieldType name="text" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <fieldType name="nametext" class="solr.TextField">
+    <analyzer class="org.apache.lucene.analysis.core.WhitespaceAnalyzer"/>
+  </fieldType>
+
+  <fieldType name="teststop" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LowerCaseTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- fieldTypes in this section isolate tokenizers and tokenfilters for testing -->
+  <fieldType name="lowertok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LowerCaseTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="keywordtok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="standardtok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="lettertok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.LetterTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="whitetok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="HTMLstandardtok" class="solr.TextField">
+    <analyzer>
       <charFilter class="solr.HTMLStripCharFilterFactory"/>
       <tokenizer class="solr.StandardTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="HTMLwhitetok" class="solr.TextField">
-      <analyzer>
+    </analyzer>
+  </fieldType>
+  <fieldType name="HTMLwhitetok" class="solr.TextField">
+    <analyzer>
+      <charFilter class="solr.HTMLStripCharFilterFactory"/>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="standardtokfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="standardfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StandardFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="lowerfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="lowerpunctfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="1" splitOnCaseChange="1"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="patternreplacefilt" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+      <filter class="solr.PatternReplaceFilterFactory"
+              pattern="([^a-zA-Z])" replacement="_" replace="all"
+      />
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="patterntok" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.PatternTokenizerFactory" pattern=","/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="porterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <!-- fieldType name="snowballfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.SnowballPorterFilterFactory"/>
+    </analyzer>
+  </fieldType -->
+  <fieldType name="engporterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="custengporterfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="stopfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="custstopfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="lengthfilt" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LengthFilterFactory" min="2" max="5"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="charfilthtmlmap" class="solr.TextField">
+    <analyzer>
       <charFilter class="solr.HTMLStripCharFilterFactory"/>
       <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="standardtokfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="standardfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StandardFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="lowerfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="lowerpunctfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="1" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="patternreplacefilt" class="solr.TextField">
-      <analyzer type="index">
-        <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
-        <filter class="solr.PatternReplaceFilterFactory"
-                pattern="([^a-zA-Z])" replacement="_" replace="all"
-        />
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.MockTokenizerFactory" pattern="keyword"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="patterntok" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.PatternTokenizerFactory" pattern=","/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="porterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <!-- fieldType name="snowballfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.SnowballPorterFilterFactory"/>
-      </analyzer>
-    </fieldType -->
-    <fieldType name="engporterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="custengporterfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="stopfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="custstopfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="lengthfilt" class="solr.TextField">
-      <analyzer>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-        <filter class="solr.LengthFilterFactory" min="2" max="5"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="charfilthtmlmap" class="solr.TextField">
-      <analyzer>
-        <charFilter class="solr.HTMLStripCharFilterFactory"/>
-        <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="subword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.StopFilterFactory"/>
-          <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.StopFilterFactory"/>
-          <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="numericsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1" generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-          <filter class="solr.StopFilterFactory"/>
-          <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.StopFilterFactory"/>
-          <filter class="solr.PorterStemFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <fieldType name="protectedsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory"  splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <!-- more flexible in matching skus, but more chance of a false match -->
-    <fieldType name="skutype1" class="solr.TextField">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- less flexible in matching skus, but less chance of a false match -->
-    <fieldType name="skutype2" class="solr.TextField">
-      <analyzer type="index">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
-    </fieldType>
-
-    <!-- less flexible in matching skus, but less chance of a false match -->
-    <fieldType name="syn" class="solr.TextField">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-
-
-    <fieldType  name="unstored" class="solr.StrField" indexed="true" stored="false"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="subword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0"
+              catenateNumbers="0" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="numericsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1"
+              generateNumberParts="0" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1"
+              generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.StopFilterFactory"/>
+      <filter class="solr.PorterStemFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <fieldType name="protectedsubword" class="solr.TextField" multiValued="true" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" splitOnNumerics="0" splitOnCaseChange="0" generateWordParts="1"
+              generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <!-- more flexible in matching skus, but more chance of a false match -->
+  <fieldType name="skutype1" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- less flexible in matching skus, but less chance of a false match -->
+  <fieldType name="skutype2" class="solr.TextField">
+    <analyzer type="index">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1"
+              catenateNumbers="1" catenateAll="0"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
+  </fieldType>
+
+  <!-- less flexible in matching skus, but less chance of a false match -->
+  <fieldType name="syn" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+    </analyzer>
+  </fieldType>
+
+
+  <fieldType name="unstored" class="solr.StrField" indexed="true" stored="false"/>
 
 
   <fieldType name="textgap" class="solr.TextField" multiValued="true" positionIncrementGap="100">
-      <analyzer>
-          <tokenizer class="solr.MockTokenizerFactory"/>
-          <filter class="solr.LowerCaseFilterFactory"/>
-      </analyzer>
+    <analyzer>
+      <tokenizer class="solr.MockTokenizerFactory"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+    </analyzer>
   </fieldType>
 
-  <fieldType name="uuid" class="solr.UUIDField" />
+  <fieldType name="uuid" class="solr.UUIDField"/>
 
-    <!-- Try out some point types -->
+  <!-- Try out some point types -->
   <fieldType name="xy" class="solr.PointType" dimension="2" subFieldType="double"/>
   <fieldType name="x" class="solr.PointType" dimension="1" subFieldType="double"/>
   <fieldType name="tenD" class="solr.PointType" dimension="10" subFieldType="double"/>
-    <!-- Use the sub field suffix -->
+  <!-- Use the sub field suffix -->
   <fieldType name="xyd" class="solr.PointType" dimension="2" subFieldSuffix="_d1"/>
-    <fieldType name="geohash" class="solr.GeoHashField"/>
+  <fieldType name="geohash" class="solr.GeoHashField"/>
 
 
   <fieldType name="latLon" class="solr.LatLonType" subFieldType="double"/>
 
   <!--  some per-field similarity examples -->
-  
+
   <!--  specify a Similarity classname directly -->
   <!--
   <fieldType name="sim1" class="solr.TextField">
@@ -341,7 +363,7 @@
     <similarity class="org.apache.lucene.misc.SweetSpotSimilarity"/>
   </fieldType>
   -->
-  <!--  specify a Similarity factory -->  
+  <!--  specify a Similarity factory -->
   <!--
   <fieldType name="sim2" class="solr.TextField">
     <analyzer>
@@ -360,206 +382,203 @@
     </analyzer>
   </fieldType>
   -->
- </types>
-
-
- <fields>
-   <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
-   <field name="signatureField" type="string" indexed="true" stored="false"/>
-   <field name="uuid" type="uuid" stored="true" />
-   <field name="name" type="nametext" indexed="true" stored="true"/>
-   <field name="text" type="text" indexed="true" stored="false"/>
-   <field name="subject" type="text" indexed="true" stored="true"/>
-   <field name="title" type="nametext" indexed="true" stored="true"/>
-   <field name="weight" type="float" indexed="true" stored="true" multiValued="false"/>
-   <field name="bday" type="date" indexed="true" stored="true" multiValued="false"/>
-
-   <field name="title_stemmed" type="text" indexed="true" stored="false"/>
-   <field name="title_lettertok" type="lettertok" indexed="true" stored="false"/>
-
-   <field name="syn" type="syn" indexed="true" stored="true"/>
-
-   <!-- to test property inheritance and overriding -->
-   <field name="shouldbeunstored" type="unstored" />
-   <field name="shouldbestored" type="unstored" stored="true"/>
-   <field name="shouldbeunindexed" type="unstored" indexed="false" stored="true"/>
-
-   <!-- Test points -->
-      <!-- Test points -->
-   <field name="home" type="xy" indexed="true" stored="true" multiValued="false"/>
-   <field name="x" type="x" indexed="true" stored="true" multiValued="false"/>
-   <field name="homed" type="xyd" indexed="true" stored="true" multiValued="false"/>
-   <field name="home_ns" type="xy" indexed="true" stored="false" multiValued="false"/>
-   <field name="work" type="xy" indexed="true" stored="true" multiValued="false"/>
-
-   <field name="home_ll" type="latLon" indexed="true" stored="true" multiValued="false"/>
-   <field name="home_gh" type="geohash" indexed="true" stored="true" multiValued="false"/>
-
-
-   <field name="point10" type="tenD" indexed="true" stored="true" multiValued="false"/>
-
-
-   <!-- test different combinations of indexed and stored -->
-   <field name="bind" type="boolean" indexed="true" stored="false"/>
-   <field name="bsto" type="boolean" indexed="false" stored="true"/>
-   <field name="bindsto" type="boolean" indexed="true" stored="true"/>
-   <field name="isto" type="int" indexed="false" stored="true"/>
-   <field name="iind" type="int" indexed="true" stored="false"/>
-   <field name="ssto" type="string" indexed="false" stored="true"/>
-   <field name="sind" type="string" indexed="true" stored="false"/>
-   <field name="sindsto" type="string" indexed="true" stored="true"/>
-
-   <!-- test combinations of term vector settings -->
-   <field name="test_basictv" type="text" termVectors="true"/>
-   <field name="test_notv" type="text" termVectors="false"/>
-   <field name="test_postv" type="text" termVectors="true" termPositions="true"/>
-   <field name="test_offtv" type="text" termVectors="true" termOffsets="true"/>
-   <field name="test_posofftv" type="text" termVectors="true"
-     termPositions="true" termOffsets="true"/>
-
-   <!-- fields to test individual tokenizers and tokenfilters -->
-   <field name="teststop" type="teststop" indexed="true" stored="true"/>
-   <field name="lowertok" type="lowertok" indexed="true" stored="true"/>
-   <field name="keywordtok" type="keywordtok" indexed="true" stored="true"/>
-   <field name="standardtok" type="standardtok" indexed="true" stored="true"/>
-   <field name="HTMLstandardtok" type="HTMLstandardtok" indexed="true" stored="true"/>
-   <field name="lettertok" type="lettertok" indexed="true" stored="true"/>
-   <field name="whitetok" type="whitetok" indexed="true" stored="true"/>
-   <field name="HTMLwhitetok" type="HTMLwhitetok" indexed="true" stored="true"/>
-   <field name="standardtokfilt" type="standardtokfilt" indexed="true" stored="true"/>
-   <field name="standardfilt" type="standardfilt" indexed="true" stored="true"/>
-   <field name="lowerfilt" type="lowerfilt" indexed="true" stored="true"/>
-   <field name="lowerfilt1" type="lowerfilt" indexed="true" stored="true"/>
-   <field name="lowerfilt1and2" type="lowerfilt" indexed="true" stored="true"/>
-   <field name="patterntok" type="patterntok" indexed="true" stored="true"/>
-   <field name="patternreplacefilt" type="patternreplacefilt" indexed="true" stored="true"/>
-   <field name="porterfilt" type="porterfilt" indexed="true" stored="true"/>
-   <field name="engporterfilt" type="engporterfilt" indexed="true" stored="true"/>
-   <field name="custengporterfilt" type="custengporterfilt" indexed="true" stored="true"/>
-   <field name="stopfilt" type="stopfilt" indexed="true" stored="true"/>
-   <field name="custstopfilt" type="custstopfilt" indexed="true" stored="true"/>
-   <field name="lengthfilt" type="lengthfilt" indexed="true" stored="true"/>
-   <field name="wdf_nocase" type="wdf_nocase" indexed="true" stored="true"/>
-   <field name="wdf_preserve" type="wdf_preserve" indexed="true" stored="true"/>
-
-   <field name="numberpartfail" type="failtype1" indexed="true" stored="true"/>
-
-   <field name="nullfirst" type="string" indexed="true" stored="true" sortMissingFirst="true" multiValued="false"/>
-
-   <field name="subword" type="subword" indexed="true" stored="true"/>
-   <field name="subword_offsets" type="subword" indexed="true" stored="true" termOffsets="true"/>
-   <field name="numericsubword" type="numericsubword" indexed="true" stored="true"/>
-   <field name="protectedsubword" type="protectedsubword" indexed="true" stored="true"/>
-
-   <field name="sku1" type="skutype1" indexed="true" stored="true"/>
-   <field name="sku2" type="skutype2" indexed="true" stored="true"/>
-
-   <field name="textgap" type="textgap" indexed="true" stored="true"/>
-
-   <field name="timestamp" type="date" indexed="true" stored="true" default="NOW" multiValued="false"/>
-   <field name="multiDefault" type="string" indexed="true" stored="true" default="muLti-Default" multiValued="true"/>
-   <field name="intDefault" type="int" indexed="true" stored="true" default="42" multiValued="false"/>
-
-   <!--
-   <field name="sim1text" type="sim1" indexed="true" stored="true"/>
-   <field name="sim2text" type="sim2" indexed="true" stored="true"/>
-   <field name="sim3text" type="sim3" indexed="true" stored="true"/>
-   -->
-   
-   <field name="tlong" type="tlong" indexed="true" stored="true" />
-   
-   <field name="_version_" type="long" indexed="true" stored="true"/>
-
-   <!-- Dynamic field definitions.  If a field name is not found, dynamicFields
-        will be used if the name matches any of the patterns.
-        RESTRICTION: the glob-like pattern in the name attribute must have
-        a "*" only at the start or the end.
-        EXAMPLE:  name="*_i" will match any field ending in _i (like myid_i, z_i)
-        Longer patterns will be matched first.  if equal size patterns
-        both match, the first appearing in the schema will be used.
-   -->
-   <dynamicField name="*_i"  type="int"    indexed="true"  stored="true"/>
-   <dynamicField name="*_i1"  type="int"    indexed="true" stored="true" multiValued="false"/>
-                 
-   <dynamicField name="*_s"  type="string"  indexed="true"  stored="true"/>
-   <dynamicField name="*_s1"  type="string"  indexed="true"  stored="true" multiValued="false"/>
-   <dynamicField name="*_l"  type="long"   indexed="true"  stored="true"/>
-   <dynamicField name="*_l1"  type="long"   indexed="true"  stored="true" multiValued="false"/>
-   <dynamicField name="*_t"  type="text"    indexed="true"  stored="true"/>
-   <dynamicField name="*_b"  type="boolean" indexed="true"  stored="true"/>
-   <dynamicField name="*_f"  type="float"  indexed="true"  stored="true"/>
-   <dynamicField name="*_f1"  type="float"  indexed="true"  stored="true" multiValued="false"/>
-   <dynamicField name="*_d"  type="double" indexed="true"  stored="true"/>
-   <dynamicField name="*_d1"  type="double" indexed="true"  stored="true" multiValued="false"/>
-   <dynamicField name="*_dt" type="date"    indexed="true"  stored="true"/>
-   <dynamicField name="*_dt1" type="date"    indexed="true"  stored="true" multiValued="false"/>
-
-      <!-- some trie-coded dynamic fields for faster range queries -->
-   <dynamicField name="*_ti" type="tint"    indexed="true"  stored="true"/>
-   <dynamicField name="*_ti1" type="tint"    indexed="true"  stored="true" multiValued="false"/>
-   <dynamicField name="*_tl" type="tlong"   indexed="true"  stored="true"/>
-   <dynamicField name="*_tl1" type="tlong"   indexed="true"  stored="true" multiValued="false"/>
-   <dynamicField name="*_tf" type="tfloat"  indexed="true"  stored="true"/>
-   <dynamicField name="*_tf1" type="tfloat"  indexed="true"  stored="true" multiValued="false"/>
-   <dynamicField name="*_td" type="tdouble" indexed="true"  stored="true"/>
-   <dynamicField name="*_td1" type="tdouble" indexed="true" stored="true" multiValued="false"/>
-   <dynamicField name="*_tds" type="tdouble" indexed="true" stored="true" multiValued="false"/>
-   <dynamicField name="*_tdt" type="tdate"  indexed="true"  stored="true"/>
-   <dynamicField name="*_tdt1" type="tdate"  indexed="true"  stored="true" multiValued="false"/>
-
-   <dynamicField name="*_sI" type="string"  indexed="true"  stored="false"/>
-   <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
-   <dynamicField name="t_*"  type="text"    indexed="true"  stored="true"/>
-   <dynamicField name="tv_*"  type="text" indexed="true"  stored="true"
-      termVectors="true" termPositions="true" termOffsets="true"/>
-   <dynamicField name="tv_mv_*"  type="text" indexed="true"  stored="true" multiValued="true"
-      termVectors="true" termPositions="true" termOffsets="true"/>
-
-   <dynamicField name="*_p"  type="xyd" indexed="true"  stored="true" multiValued="false"/>
-
-   <!-- special fields for dynamic copyField test -->
-   <dynamicField name="dynamic_*" type="string" indexed="true" stored="true"/>
-   <dynamicField name="*_dynamic" type="string" indexed="true" stored="true"/>
-
-   <!-- for testing to ensure that longer patterns are matched first -->
-   <dynamicField name="*aa"  type="string"  indexed="true" stored="true"/>
-   <dynamicField name="*aaa" type="int" indexed="false" stored="true"/>
-
-   <!-- ignored becuase not stored or indexed -->
-   <dynamicField name="*_ignored" type="text" indexed="false" stored="false"/>
-
-   <dynamicField name="*_mfacet" type="string" indexed="true" stored="false" multiValued="true" />
-
-   <!-- make sure custom sims work with dynamic fields -->
-   <!--
-   <dynamicField name="*_sim1" type="sim1" indexed="true" stored="true"/>
-   <dynamicField name="*_sim2" type="sim2" indexed="true" stored="true"/>
-   <dynamicField name="*_sim3" type="sim3" indexed="true" stored="true"/>
-   -->
- </fields>
 
- <defaultSearchField>text</defaultSearchField>
- <uniqueKey>id</uniqueKey>
+
+  <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
+  <field name="signatureField" type="string" indexed="true" stored="false"/>
+  <field name="uuid" type="uuid" stored="true"/>
+  <field name="name" type="nametext" indexed="true" stored="true"/>
+  <field name="text" type="text" indexed="true" stored="false"/>
+  <field name="subject" type="text" indexed="true" stored="true"/>
+  <field name="title" type="nametext" indexed="true" stored="true"/>
+  <field name="weight" type="float" indexed="true" stored="true" multiValued="false"/>
+  <field name="bday" type="date" indexed="true" stored="true" multiValued="false"/>
+
+  <field name="title_stemmed" type="text" indexed="true" stored="false"/>
+  <field name="title_lettertok" type="lettertok" indexed="true" stored="false"/>
+
+  <field name="syn" type="syn" indexed="true" stored="true"/>
+
+  <!-- to test property inheritance and overriding -->
+  <field name="shouldbeunstored" type="unstored"/>
+  <field name="shouldbestored" type="unstored" stored="true"/>
+  <field name="shouldbeunindexed" type="unstored" indexed="false" stored="true"/>
+
+  <!-- Test points -->
+  <!-- Test points -->
+  <field name="home" type="xy" indexed="true" stored="true" multiValued="false"/>
+  <field name="x" type="x" indexed="true" stored="true" multiValued="false"/>
+  <field name="homed" type="xyd" indexed="true" stored="true" multiValued="false"/>
+  <field name="home_ns" type="xy" indexed="true" stored="false" multiValued="false"/>
+  <field name="work" type="xy" indexed="true" stored="true" multiValued="false"/>
+
+  <field name="home_ll" type="latLon" indexed="true" stored="true" multiValued="false"/>
+  <field name="home_gh" type="geohash" indexed="true" stored="true" multiValued="false"/>
+
+
+  <field name="point10" type="tenD" indexed="true" stored="true" multiValued="false"/>
+
+
+  <!-- test different combinations of indexed and stored -->
+  <field name="bind" type="boolean" indexed="true" stored="false"/>
+  <field name="bsto" type="boolean" indexed="false" stored="true"/>
+  <field name="bindsto" type="boolean" indexed="true" stored="true"/>
+  <field name="isto" type="int" indexed="false" stored="true"/>
+  <field name="iind" type="int" indexed="true" stored="false"/>
+  <field name="ssto" type="string" indexed="false" stored="true"/>
+  <field name="sind" type="string" indexed="true" stored="false"/>
+  <field name="sindsto" type="string" indexed="true" stored="true"/>
+
+  <!-- test combinations of term vector settings -->
+  <field name="test_basictv" type="text" termVectors="true"/>
+  <field name="test_notv" type="text" termVectors="false"/>
+  <field name="test_postv" type="text" termVectors="true" termPositions="true"/>
+  <field name="test_offtv" type="text" termVectors="true" termOffsets="true"/>
+  <field name="test_posofftv" type="text" termVectors="true"
+         termPositions="true" termOffsets="true"/>
+
+  <!-- fields to test individual tokenizers and tokenfilters -->
+  <field name="teststop" type="teststop" indexed="true" stored="true"/>
+  <field name="lowertok" type="lowertok" indexed="true" stored="true"/>
+  <field name="keywordtok" type="keywordtok" indexed="true" stored="true"/>
+  <field name="standardtok" type="standardtok" indexed="true" stored="true"/>
+  <field name="HTMLstandardtok" type="HTMLstandardtok" indexed="true" stored="true"/>
+  <field name="lettertok" type="lettertok" indexed="true" stored="true"/>
+  <field name="whitetok" type="whitetok" indexed="true" stored="true"/>
+  <field name="HTMLwhitetok" type="HTMLwhitetok" indexed="true" stored="true"/>
+  <field name="standardtokfilt" type="standardtokfilt" indexed="true" stored="true"/>
+  <field name="standardfilt" type="standardfilt" indexed="true" stored="true"/>
+  <field name="lowerfilt" type="lowerfilt" indexed="true" stored="true"/>
+  <field name="lowerfilt1" type="lowerfilt" indexed="true" stored="true"/>
+  <field name="lowerfilt1and2" type="lowerfilt" indexed="true" stored="true"/>
+  <field name="patterntok" type="patterntok" indexed="true" stored="true"/>
+  <field name="patternreplacefilt" type="patternreplacefilt" indexed="true" stored="true"/>
+  <field name="porterfilt" type="porterfilt" indexed="true" stored="true"/>
+  <field name="engporterfilt" type="engporterfilt" indexed="true" stored="true"/>
+  <field name="custengporterfilt" type="custengporterfilt" indexed="true" stored="true"/>
+  <field name="stopfilt" type="stopfilt" indexed="true" stored="true"/>
+  <field name="custstopfilt" type="custstopfilt" indexed="true" stored="true"/>
+  <field name="lengthfilt" type="lengthfilt" indexed="true" stored="true"/>
+  <field name="wdf_nocase" type="wdf_nocase" indexed="true" stored="true"/>
+  <field name="wdf_preserve" type="wdf_preserve" indexed="true" stored="true"/>
+
+  <field name="numberpartfail" type="failtype1" indexed="true" stored="true"/>
+
+  <field name="nullfirst" type="string" indexed="true" stored="true" sortMissingFirst="true" multiValued="false"/>
+
+  <field name="subword" type="subword" indexed="true" stored="true"/>
+  <field name="subword_offsets" type="subword" indexed="true" stored="true" termOffsets="true"/>
+  <field name="numericsubword" type="numericsubword" indexed="true" stored="true"/>
+  <field name="protectedsubword" type="protectedsubword" indexed="true" stored="true"/>
+
+  <field name="sku1" type="skutype1" indexed="true" stored="true"/>
+  <field name="sku2" type="skutype2" indexed="true" stored="true"/>
+
+  <field name="textgap" type="textgap" indexed="true" stored="true"/>
+
+  <field name="timestamp" type="date" indexed="true" stored="true" default="NOW" multiValued="false"/>
+  <field name="multiDefault" type="string" indexed="true" stored="true" default="muLti-Default" multiValued="true"/>
+  <field name="intDefault" type="int" indexed="true" stored="true" default="42" multiValued="false"/>
+
+  <!--
+  <field name="sim1text" type="sim1" indexed="true" stored="true"/>
+  <field name="sim2text" type="sim2" indexed="true" stored="true"/>
+  <field name="sim3text" type="sim3" indexed="true" stored="true"/>
+  -->
+
+  <field name="tlong" type="tlong" indexed="true" stored="true"/>
+
+  <field name="_version_" type="long" indexed="true" stored="true"/>
+
+  <!-- Dynamic field definitions.  If a field name is not found, dynamicFields
+       will be used if the name matches any of the patterns.
+       RESTRICTION: the glob-like pattern in the name attribute must have
+       a "*" only at the start or the end.
+       EXAMPLE:  name="*_i" will match any field ending in _i (like myid_i, z_i)
+       Longer patterns will be matched first.  if equal size patterns
+       both match, the first appearing in the schema will be used.
+  -->
+  <dynamicField name="*_i" type="int" indexed="true" stored="true"/>
+  <dynamicField name="*_i1" type="int" indexed="true" stored="true" multiValued="false"/>
+
+  <dynamicField name="*_s" type="string" indexed="true" stored="true"/>
+  <dynamicField name="*_s1" type="string" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_l" type="long" indexed="true" stored="true"/>
+  <dynamicField name="*_l1" type="long" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_t" type="text" indexed="true" stored="true"/>
+  <dynamicField name="*_b" type="boolean" indexed="true" stored="true"/>
+  <dynamicField name="*_f" type="float" indexed="true" stored="true"/>
+  <dynamicField name="*_f1" type="float" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_d" type="double" indexed="true" stored="true"/>
+  <dynamicField name="*_d1" type="double" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_dt" type="date" indexed="true" stored="true"/>
+  <dynamicField name="*_dt1" type="date" indexed="true" stored="true" multiValued="false"/>
+
+  <!-- some trie-coded dynamic fields for faster range queries -->
+  <dynamicField name="*_ti" type="tint" indexed="true" stored="true"/>
+  <dynamicField name="*_ti1" type="tint" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_tl" type="tlong" indexed="true" stored="true"/>
+  <dynamicField name="*_tl1" type="tlong" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_tf" type="tfloat" indexed="true" stored="true"/>
+  <dynamicField name="*_tf1" type="tfloat" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_td" type="tdouble" indexed="true" stored="true"/>
+  <dynamicField name="*_td1" type="tdouble" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_tds" type="tdouble" indexed="true" stored="true" multiValued="false"/>
+  <dynamicField name="*_tdt" type="tdate" indexed="true" stored="true"/>
+  <dynamicField name="*_tdt1" type="tdate" indexed="true" stored="true" multiValued="false"/>
+
+  <dynamicField name="*_sI" type="string" indexed="true" stored="false"/>
+  <dynamicField name="*_sS" type="string" indexed="false" stored="true"/>
+  <dynamicField name="t_*" type="text" indexed="true" stored="true"/>
+  <dynamicField name="tv_*" type="text" indexed="true" stored="true"
+                termVectors="true" termPositions="true" termOffsets="true"/>
+  <dynamicField name="tv_mv_*" type="text" indexed="true" stored="true" multiValued="true"
+                termVectors="true" termPositions="true" termOffsets="true"/>
+
+  <dynamicField name="*_p" type="xyd" indexed="true" stored="true" multiValued="false"/>
+
+  <!-- special fields for dynamic copyField test -->
+  <dynamicField name="dynamic_*" type="string" indexed="true" stored="true"/>
+  <dynamicField name="*_dynamic" type="string" indexed="true" stored="true"/>
+
+  <!-- for testing to ensure that longer patterns are matched first -->
+  <dynamicField name="*aa" type="string" indexed="true" stored="true"/>
+  <dynamicField name="*aaa" type="int" indexed="false" stored="true"/>
+
+  <!-- ignored becuase not stored or indexed -->
+  <dynamicField name="*_ignored" type="text" indexed="false" stored="false"/>
+
+  <dynamicField name="*_mfacet" type="string" indexed="true" stored="false" multiValued="true"/>
+
+  <!-- make sure custom sims work with dynamic fields -->
+  <!--
+  <dynamicField name="*_sim1" type="sim1" indexed="true" stored="true"/>
+  <dynamicField name="*_sim2" type="sim2" indexed="true" stored="true"/>
+  <dynamicField name="*_sim3" type="sim3" indexed="true" stored="true"/>
+  -->
+
+  <defaultSearchField>text</defaultSearchField>
+  <uniqueKey>id</uniqueKey>
 
   <!-- copyField commands copy one field to another at the time a document
         is added to the index.  It's used either to index the same field different
         ways, or to add multiple fields to the same field for easier/faster searching.
    -->
-   <copyField source="title" dest="title_stemmed"/>
-   <copyField source="title" dest="title_lettertok"/>
+  <copyField source="title" dest="title_stemmed"/>
+  <copyField source="title" dest="title_lettertok"/>
 
-   <copyField source="title" dest="text"/>
-   <copyField source="subject" dest="text"/>
+  <copyField source="title" dest="text"/>
+  <copyField source="subject" dest="text"/>
 
-   <copyField source="lowerfilt1" dest="lowerfilt1and2"/>
-   <copyField source="lowerfilt" dest="lowerfilt1and2"/>
+  <copyField source="lowerfilt1" dest="lowerfilt1and2"/>
+  <copyField source="lowerfilt" dest="lowerfilt1and2"/>
 
-   <copyField source="*_t" dest="text"/>
+  <copyField source="*_t" dest="text"/>
 
-   <copyField source="id"            dest="range_facet_l"/>
-   <copyField source="range_facet_f" dest="range_facet_d"/>
+  <copyField source="id" dest="range_facet_l"/>
+  <copyField source="range_facet_f" dest="range_facet_d"/>
 
-   <!-- dynamic destination -->
-   <copyField source="*_dynamic" dest="dynamic_*"/>
+  <!-- dynamic destination -->
+  <copyField source="*_dynamic" dest="dynamic_*"/>
 
 </schema>
diff --git a/solr/solrj/src/test-files/solrj/solr/configsets/configset-1/conf/schema-minimal.xml b/solr/solrj/src/test-files/solrj/solr/configsets/configset-1/conf/schema-minimal.xml
index 9e2f947..287d4fe 100644
--- a/solr/solrj/src/test-files/solrj/solr/configsets/configset-1/conf/schema-minimal.xml
+++ b/solr/solrj/src/test-files/solrj/solr/configsets/configset-1/conf/schema-minimal.xml
@@ -16,10 +16,6 @@
  limitations under the License.
 -->
 <schema name="minimal" version="1.1">
- <types>
   <fieldType name="string" class="solr.StrField"/>
- </types>
- <fields>
-   <dynamicField name="*" type="string" indexed="true" stored="true" />
- </fields>
+  <dynamicField name="*" type="string" indexed="true" stored="true"/>
 </schema>
diff --git a/solr/solrj/src/test-files/solrj/solr/configsets/configset-2/conf/schema.xml b/solr/solrj/src/test-files/solrj/solr/configsets/configset-2/conf/schema.xml
index 9e2f947..287d4fe 100644
--- a/solr/solrj/src/test-files/solrj/solr/configsets/configset-2/conf/schema.xml
+++ b/solr/solrj/src/test-files/solrj/solr/configsets/configset-2/conf/schema.xml
@@ -16,10 +16,6 @@
  limitations under the License.
 -->
 <schema name="minimal" version="1.1">
- <types>
   <fieldType name="string" class="solr.StrField"/>
- </types>
- <fields>
-   <dynamicField name="*" type="string" indexed="true" stored="true" />
- </fields>
+  <dynamicField name="*" type="string" indexed="true" stored="true"/>
 </schema>
diff --git a/solr/solrj/src/test-files/solrj/solr/configsets/shared/conf/schema.xml b/solr/solrj/src/test-files/solrj/solr/configsets/shared/conf/schema.xml
index 82e4012..fc286c2 100644
--- a/solr/solrj/src/test-files/solrj/solr/configsets/shared/conf/schema.xml
+++ b/solr/solrj/src/test-files/solrj/solr/configsets/shared/conf/schema.xml
@@ -17,47 +17,43 @@
 -->
 
 <schema name="example core ${l10n:}" version="1.1">
-  <types>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true" omitNorms="true"/>
-    <fieldType name="text-FR" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords-fr.txt"/>
-        <filter class="solr.StandardFilterFactory"/>
-        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords-fr.txt"/>
-        <filter class="solr.StandardFilterFactory"/>
-        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="text-EN" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords-en.txt"/>
-        <filter class="solr.StandardFilterFactory"/>
-        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.StandardTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords-en.txt"/>
-        <filter class="solr.StandardFilterFactory"/>
-        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
-  </types>
+  <fieldType name="string" class="solr.StrField" sortMissingLast="true" omitNorms="true"/>
+  <fieldType name="text-FR" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords-fr.txt"/>
+      <filter class="solr.StandardFilterFactory"/>
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords-fr.txt"/>
+      <filter class="solr.StandardFilterFactory"/>
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="text-EN" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords-en.txt"/>
+      <filter class="solr.StandardFilterFactory"/>
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords-en.txt"/>
+      <filter class="solr.StandardFilterFactory"/>
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
 
-  <fields>
-    <!-- general -->
-    <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="true"/>
-    <field name="type" type="string" indexed="true" stored="true" multiValued="false"/>
-    <field name="name" type="string" indexed="true" stored="true" multiValued="false"/>
-    <field name="${ctlField:}" type="text-${l10n:EN}" indexed="true" stored="true" multiValued="true"/>
-    <field name="_version_" type="long"     indexed="true"  stored="true"/>
-  </fields>
+  <!-- general -->
+  <field name="id" type="string" indexed="true" stored="true" multiValued="false" required="true"/>
+  <field name="type" type="string" indexed="true" stored="true" multiValued="false"/>
+  <field name="name" type="string" indexed="true" stored="true" multiValued="false"/>
+  <field name="${ctlField:}" type="text-${l10n:EN}" indexed="true" stored="true" multiValued="true"/>
+  <field name="_version_" type="long" indexed="true" stored="true"/>
 
   <!-- field to use to determine and enforce document uniqueness. -->
   <uniqueKey>id</uniqueKey>
diff --git a/solr/solrj/src/test-files/solrj/solr/configsets/streaming/conf/schema.xml b/solr/solrj/src/test-files/solrj/solr/configsets/streaming/conf/schema.xml
index 575b622..c10f6cf 100644
--- a/solr/solrj/src/test-files/solrj/solr/configsets/streaming/conf/schema.xml
+++ b/solr/solrj/src/test-files/solrj/solr/configsets/streaming/conf/schema.xml
@@ -26,7 +26,6 @@
   -->
 
 <schema name="test" version="1.6">
-  <types>
 
     <!-- field type definitions... note that the "name" attribute is
          just a label to be used by field definitions.  The "class"
@@ -386,10 +385,8 @@
       </analyzer>
     </fieldType>
     -->
-  </types>
 
 
-  <fields>
     <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
     <field name="signatureField" type="string" indexed="true" stored="false"/>
 
@@ -575,7 +572,6 @@
     <dynamicField name="*_sim2" type="sim2" indexed="true" stored="true"/>
     <dynamicField name="*_sim3" type="sim3" indexed="true" stored="true"/>
     -->
-  </fields>
 
   <defaultSearchField>text</defaultSearchField>
   <uniqueKey>id</uniqueKey>
diff --git a/solr/solrj/src/test-files/solrj/solr/crazy-path-to-schema.xml b/solr/solrj/src/test-files/solrj/solr/crazy-path-to-schema.xml
index 7d06ff9..2404361 100644
--- a/solr/solrj/src/test-files/solrj/solr/crazy-path-to-schema.xml
+++ b/solr/solrj/src/test-files/solrj/solr/crazy-path-to-schema.xml
@@ -21,8 +21,13 @@
 
   -->
 
+<!--
+See comments from Yonik on SOLR-9083. It costs us nothing to leave these in given the parsing pattern for the schema
+that just finds leaf <fieldType> and <field> nodes and there's no reason to break schemas for people who leave
+<fields> and <types> tags in their schema for no good purpose.
+-->
 <schema name="test" version="1.0">
-  <types>
+  <types>  <!-- Intentionally left in. see comment above -->
     <fieldType name="int" class="solr.TrieIntField" precisionStep="0"/>
     <fieldType name="text" class="solr.TextField">
       <analyzer>
@@ -36,7 +41,7 @@
  </types>
 
 
- <fields>
+ <fields>  <!-- Intentionally left in. see comment above -->
    <field name="id" type="int" indexed="true" stored="true" multiValued="false"/>
    <field name="subject" type="text" indexed="true" stored="true"/>
  </fields>

