GitDiffStart: d5932e1149efaf7ae03283ae7867dc5ff988e124 | Sun Jan 1 11:41:30 2012 +0000
diff --git a/modules/facet/build.xml b/modules/facet/build.xml
index 751331f..63788ec 100644
--- a/modules/facet/build.xml
+++ b/modules/facet/build.xml
@@ -73,23 +73,5 @@
   <target name="compile-core" depends="jar-analyzers-common,common.compile-core,compile-examples" description="Compiles facet classes" />
 
   <target name="jar-core" depends="common.jar-core,jar-examples" />
-
-  <target name="javadocs" depends="compile-core">
-	<sequential>
-      <mkdir dir="${javadoc.dir}/contrib-${name}"/>
-      <copy todir="${javadoc.dir}/contrib-${name}" file="docs/userguide.html" />
-      <!-- javadoc core classes -->
-      <invoke-javadoc
-        destdir="${javadoc.dir}/contrib-${name}"
-        title="${Name} ${version} contrib-${name} API">
-        <sources>
-          <link href=""/>
-          <packageset dir="${src.dir}"/>
-          <packageset dir="${examples.dir}"/>
-        </sources>
-      </invoke-javadoc>
-      <jarify basedir="${javadoc.dir}/contrib-${name}" destfile="${build.dir}/${final.name}-javadoc.jar"/>
-    </sequential>
-  </target>
     
 </project>
diff --git a/modules/facet/docs/prettify.css b/modules/facet/docs/prettify.css
deleted file mode 100755
index d44b3a2..0000000
--- a/modules/facet/docs/prettify.css
+++ /dev/null
@@ -1 +0,0 @@
-.pln{color:#000}@media screen{.str{color:#080}.kwd{color:#008}.com{color:#800}.typ{color:#606}.lit{color:#066}.pun,.opn,.clo{color:#660}.tag{color:#008}.atn{color:#606}.atv{color:#080}.dec,.var{color:#606}.fun{color:red}}@media print,projection{.str{color:#060}.kwd{color:#006;font-weight:bold}.com{color:#600;font-style:italic}.typ{color:#404;font-weight:bold}.lit{color:#044}.pun,.opn,.clo{color:#440}.tag{color:#006;font-weight:bold}.atn{color:#404}.atv{color:#060}}pre.prettyprint{padding:2px;border:1px solid #888}ol.linenums{margin-top:0;margin-bottom:0}li.L0,li.L1,li.L2,li.L3,li.L5,li.L6,li.L7,li.L8{list-style-type:none}li.L1,li.L3,li.L5,li.L7,li.L9{background:#eee}
\ No newline at end of file
diff --git a/modules/facet/docs/prettify.js b/modules/facet/docs/prettify.js
deleted file mode 100755
index eef5ad7..0000000
--- a/modules/facet/docs/prettify.js
+++ /dev/null
@@ -1,28 +0,0 @@
-var q=null;window.PR_SHOULD_USE_CONTINUATION=!0;
-(function(){function L(a){function m(a){var f=a.charCodeAt(0);if(f!==92)return f;var b=a.charAt(1);return(f=r[b])?f:"0"<=b&&b<="7"?parseInt(a.substring(1),8):b==="u"||b==="x"?parseInt(a.substring(2),16):a.charCodeAt(1)}function e(a){if(a<32)return(a<16?"\\x0":"\\x")+a.toString(16);a=String.fromCharCode(a);if(a==="\\"||a==="-"||a==="["||a==="]")a="\\"+a;return a}function h(a){for(var f=a.substring(1,a.length-1).match(/\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\[0-3][0-7]{0,2}|\\[0-7]{1,2}|\\[\S\s]|[^\\]/g),a=
-[],b=[],o=f[0]==="^",c=o?1:0,i=f.length;c<i;++c){var j=f[c];if(/\\[bdsw]/i.test(j))a.push(j);else{var j=m(j),d;c+2<i&&"-"===f[c+1]?(d=m(f[c+2]),c+=2):d=j;b.push([j,d]);d<65||j>122||(d<65||j>90||b.push([Math.max(65,j)|32,Math.min(d,90)|32]),d<97||j>122||b.push([Math.max(97,j)&-33,Math.min(d,122)&-33]))}}b.sort(function(a,f){return a[0]-f[0]||f[1]-a[1]});f=[];j=[NaN,NaN];for(c=0;c<b.length;++c)i=b[c],i[0]<=j[1]+1?j[1]=Math.max(j[1],i[1]):f.push(j=i);b=["["];o&&b.push("^");b.push.apply(b,a);for(c=0;c<
-f.length;++c)i=f[c],b.push(e(i[0])),i[1]>i[0]&&(i[1]+1>i[0]&&b.push("-"),b.push(e(i[1])));b.push("]");return b.join("")}function y(a){for(var f=a.source.match(/\[(?:[^\\\]]|\\[\S\s])*]|\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\\d+|\\[^\dux]|\(\?[!:=]|[()^]|[^()[\\^]+/g),b=f.length,d=[],c=0,i=0;c<b;++c){var j=f[c];j==="("?++i:"\\"===j.charAt(0)&&(j=+j.substring(1))&&j<=i&&(d[j]=-1)}for(c=1;c<d.length;++c)-1===d[c]&&(d[c]=++t);for(i=c=0;c<b;++c)j=f[c],j==="("?(++i,d[i]===void 0&&(f[c]="(?:")):"\\"===j.charAt(0)&&
-(j=+j.substring(1))&&j<=i&&(f[c]="\\"+d[i]);for(i=c=0;c<b;++c)"^"===f[c]&&"^"!==f[c+1]&&(f[c]="");if(a.ignoreCase&&s)for(c=0;c<b;++c)j=f[c],a=j.charAt(0),j.length>=2&&a==="["?f[c]=h(j):a!=="\\"&&(f[c]=j.replace(/[A-Za-z]/g,function(a){a=a.charCodeAt(0);return"["+String.fromCharCode(a&-33,a|32)+"]"}));return f.join("")}for(var t=0,s=!1,l=!1,p=0,d=a.length;p<d;++p){var g=a[p];if(g.ignoreCase)l=!0;else if(/[a-z]/i.test(g.source.replace(/\\u[\da-f]{4}|\\x[\da-f]{2}|\\[^UXux]/gi,""))){s=!0;l=!1;break}}for(var r=
-{b:8,t:9,n:10,v:11,f:12,r:13},n=[],p=0,d=a.length;p<d;++p){g=a[p];if(g.global||g.multiline)throw Error(""+g);n.push("(?:"+y(g)+")")}return RegExp(n.join("|"),l?"gi":"g")}function M(a){function m(a){switch(a.nodeType){case 1:if(e.test(a.className))break;for(var g=a.firstChild;g;g=g.nextSibling)m(g);g=a.nodeName;if("BR"===g||"LI"===g)h[s]="\n",t[s<<1]=y++,t[s++<<1|1]=a;break;case 3:case 4:g=a.nodeValue,g.length&&(g=p?g.replace(/\r\n?/g,"\n"):g.replace(/[\t\n\r ]+/g," "),h[s]=g,t[s<<1]=y,y+=g.length,
-t[s++<<1|1]=a)}}var e=/(?:^|\s)nocode(?:\s|$)/,h=[],y=0,t=[],s=0,l;a.currentStyle?l=a.currentStyle.whiteSpace:window.getComputedStyle&&(l=document.defaultView.getComputedStyle(a,q).getPropertyValue("white-space"));var p=l&&"pre"===l.substring(0,3);m(a);return{a:h.join("").replace(/\n$/,""),c:t}}function B(a,m,e,h){m&&(a={a:m,d:a},e(a),h.push.apply(h,a.e))}function x(a,m){function e(a){for(var l=a.d,p=[l,"pln"],d=0,g=a.a.match(y)||[],r={},n=0,z=g.length;n<z;++n){var f=g[n],b=r[f],o=void 0,c;if(typeof b===
-"string")c=!1;else{var i=h[f.charAt(0)];if(i)o=f.match(i[1]),b=i[0];else{for(c=0;c<t;++c)if(i=m[c],o=f.match(i[1])){b=i[0];break}o||(b="pln")}if((c=b.length>=5&&"lang-"===b.substring(0,5))&&!(o&&typeof o[1]==="string"))c=!1,b="src";c||(r[f]=b)}i=d;d+=f.length;if(c){c=o[1];var j=f.indexOf(c),k=j+c.length;o[2]&&(k=f.length-o[2].length,j=k-c.length);b=b.substring(5);B(l+i,f.substring(0,j),e,p);B(l+i+j,c,C(b,c),p);B(l+i+k,f.substring(k),e,p)}else p.push(l+i,b)}a.e=p}var h={},y;(function(){for(var e=a.concat(m),
-l=[],p={},d=0,g=e.length;d<g;++d){var r=e[d],n=r[3];if(n)for(var k=n.length;--k>=0;)h[n.charAt(k)]=r;r=r[1];n=""+r;p.hasOwnProperty(n)||(l.push(r),p[n]=q)}l.push(/[\S\s]/);y=L(l)})();var t=m.length;return e}function u(a){var m=[],e=[];a.tripleQuotedStrings?m.push(["str",/^(?:'''(?:[^'\\]|\\[\S\s]|''?(?=[^']))*(?:'''|$)|"""(?:[^"\\]|\\[\S\s]|""?(?=[^"]))*(?:"""|$)|'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$))/,q,"'\""]):a.multiLineStrings?m.push(["str",/^(?:'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$)|`(?:[^\\`]|\\[\S\s])*(?:`|$))/,
-q,"'\"`"]):m.push(["str",/^(?:'(?:[^\n\r'\\]|\\.)*(?:'|$)|"(?:[^\n\r"\\]|\\.)*(?:"|$))/,q,"\"'"]);a.verbatimStrings&&e.push(["str",/^@"(?:[^"]|"")*(?:"|$)/,q]);var h=a.hashComments;h&&(a.cStyleComments?(h>1?m.push(["com",/^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/,q,"#"]):m.push(["com",/^#(?:(?:define|elif|else|endif|error|ifdef|include|ifndef|line|pragma|undef|warning)\b|[^\n\r]*)/,q,"#"]),e.push(["str",/^<(?:(?:(?:\.\.\/)*|\/?)(?:[\w-]+(?:\/[\w-]+)+)?[\w-]+\.h|[a-z]\w*)>/,q])):m.push(["com",/^#[^\n\r]*/,
-q,"#"]));a.cStyleComments&&(e.push(["com",/^\/\/[^\n\r]*/,q]),e.push(["com",/^\/\*[\S\s]*?(?:\*\/|$)/,q]));a.regexLiterals&&e.push(["lang-regex",/^(?:^^\.?|[!+-]|!=|!==|#|%|%=|&|&&|&&=|&=|\(|\*|\*=|\+=|,|-=|->|\/|\/=|:|::|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|[?@[^]|\^=|\^\^|\^\^=|{|\||\|=|\|\||\|\|=|~|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\s*(\/(?=[^*/])(?:[^/[\\]|\\[\S\s]|\[(?:[^\\\]]|\\[\S\s])*(?:]|$))+\/)/]);(h=a.types)&&e.push(["typ",h]);a=(""+a.keywords).replace(/^ | $/g,
-"");a.length&&e.push(["kwd",RegExp("^(?:"+a.replace(/[\s,]+/g,"|")+")\\b"),q]);m.push(["pln",/^\s+/,q," \r\n\t\xa0"]);e.push(["lit",/^@[$_a-z][\w$@]*/i,q],["typ",/^(?:[@_]?[A-Z]+[a-z][\w$@]*|\w+_t\b)/,q],["pln",/^[$_a-z][\w$@]*/i,q],["lit",/^(?:0x[\da-f]+|(?:\d(?:_\d+)*\d*(?:\.\d*)?|\.\d\+)(?:e[+-]?\d+)?)[a-z]*/i,q,"0123456789"],["pln",/^\\[\S\s]?/,q],["pun",/^.[^\s\w"-$'./@\\`]*/,q]);return x(m,e)}function D(a,m){function e(a){switch(a.nodeType){case 1:if(k.test(a.className))break;if("BR"===a.nodeName)h(a),
-a.parentNode&&a.parentNode.removeChild(a);else for(a=a.firstChild;a;a=a.nextSibling)e(a);break;case 3:case 4:if(p){var b=a.nodeValue,d=b.match(t);if(d){var c=b.substring(0,d.index);a.nodeValue=c;(b=b.substring(d.index+d[0].length))&&a.parentNode.insertBefore(s.createTextNode(b),a.nextSibling);h(a);c||a.parentNode.removeChild(a)}}}}function h(a){function b(a,d){var e=d?a.cloneNode(!1):a,f=a.parentNode;if(f){var f=b(f,1),g=a.nextSibling;f.appendChild(e);for(var h=g;h;h=g)g=h.nextSibling,f.appendChild(h)}return e}
-for(;!a.nextSibling;)if(a=a.parentNode,!a)return;for(var a=b(a.nextSibling,0),e;(e=a.parentNode)&&e.nodeType===1;)a=e;d.push(a)}var k=/(?:^|\s)nocode(?:\s|$)/,t=/\r\n?|\n/,s=a.ownerDocument,l;a.currentStyle?l=a.currentStyle.whiteSpace:window.getComputedStyle&&(l=s.defaultView.getComputedStyle(a,q).getPropertyValue("white-space"));var p=l&&"pre"===l.substring(0,3);for(l=s.createElement("LI");a.firstChild;)l.appendChild(a.firstChild);for(var d=[l],g=0;g<d.length;++g)e(d[g]);m===(m|0)&&d[0].setAttribute("value",
-m);var r=s.createElement("OL");r.className="linenums";for(var n=Math.max(0,m-1|0)||0,g=0,z=d.length;g<z;++g)l=d[g],l.className="L"+(g+n)%10,l.firstChild||l.appendChild(s.createTextNode("\xa0")),r.appendChild(l);a.appendChild(r)}function k(a,m){for(var e=m.length;--e>=0;){var h=m[e];A.hasOwnProperty(h)?window.console&&console.warn("cannot override language handler %s",h):A[h]=a}}function C(a,m){if(!a||!A.hasOwnProperty(a))a=/^\s*</.test(m)?"default-markup":"default-code";return A[a]}function E(a){var m=
-a.g;try{var e=M(a.h),h=e.a;a.a=h;a.c=e.c;a.d=0;C(m,h)(a);var k=/\bMSIE\b/.test(navigator.userAgent),m=/\n/g,t=a.a,s=t.length,e=0,l=a.c,p=l.length,h=0,d=a.e,g=d.length,a=0;d[g]=s;var r,n;for(n=r=0;n<g;)d[n]!==d[n+2]?(d[r++]=d[n++],d[r++]=d[n++]):n+=2;g=r;for(n=r=0;n<g;){for(var z=d[n],f=d[n+1],b=n+2;b+2<=g&&d[b+1]===f;)b+=2;d[r++]=z;d[r++]=f;n=b}for(d.length=r;h<p;){var o=l[h+2]||s,c=d[a+2]||s,b=Math.min(o,c),i=l[h+1],j;if(i.nodeType!==1&&(j=t.substring(e,b))){k&&(j=j.replace(m,"\r"));i.nodeValue=
-j;var u=i.ownerDocument,v=u.createElement("SPAN");v.className=d[a+1];var x=i.parentNode;x.replaceChild(v,i);v.appendChild(i);e<o&&(l[h+1]=i=u.createTextNode(t.substring(b,o)),x.insertBefore(i,v.nextSibling))}e=b;e>=o&&(h+=2);e>=c&&(a+=2)}}catch(w){"console"in window&&console.log(w&&w.stack?w.stack:w)}}var v=["break,continue,do,else,for,if,return,while"],w=[[v,"auto,case,char,const,default,double,enum,extern,float,goto,int,long,register,short,signed,sizeof,static,struct,switch,typedef,union,unsigned,void,volatile"],
-"catch,class,delete,false,import,new,operator,private,protected,public,this,throw,true,try,typeof"],F=[w,"alignof,align_union,asm,axiom,bool,concept,concept_map,const_cast,constexpr,decltype,dynamic_cast,explicit,export,friend,inline,late_check,mutable,namespace,nullptr,reinterpret_cast,static_assert,static_cast,template,typeid,typename,using,virtual,where"],G=[w,"abstract,boolean,byte,extends,final,finally,implements,import,instanceof,null,native,package,strictfp,super,synchronized,throws,transient"],
-H=[G,"as,base,by,checked,decimal,delegate,descending,dynamic,event,fixed,foreach,from,group,implicit,in,interface,internal,into,is,lock,object,out,override,orderby,params,partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,var"],w=[w,"debugger,eval,export,function,get,null,set,undefined,var,with,Infinity,NaN"],I=[v,"and,as,assert,class,def,del,elif,except,exec,finally,from,global,import,in,is,lambda,nonlocal,not,or,pass,print,raise,try,with,yield,False,True,None"],
-J=[v,"alias,and,begin,case,class,def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,rescue,retry,self,super,then,true,undef,unless,until,when,yield,BEGIN,END"],v=[v,"case,done,elif,esac,eval,fi,function,in,local,set,then,until"],K=/^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\d*)/,N=/\S/,O=u({keywords:[F,H,w,"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END"+
-I,J,v],hashComments:!0,cStyleComments:!0,multiLineStrings:!0,regexLiterals:!0}),A={};k(O,["default-code"]);k(x([],[["pln",/^[^<?]+/],["dec",/^<!\w[^>]*(?:>|$)/],["com",/^<\!--[\S\s]*?(?:--\>|$)/],["lang-",/^<\?([\S\s]+?)(?:\?>|$)/],["lang-",/^<%([\S\s]+?)(?:%>|$)/],["pun",/^(?:<[%?]|[%?]>)/],["lang-",/^<xmp\b[^>]*>([\S\s]+?)<\/xmp\b[^>]*>/i],["lang-js",/^<script\b[^>]*>([\S\s]*?)(<\/script\b[^>]*>)/i],["lang-css",/^<style\b[^>]*>([\S\s]*?)(<\/style\b[^>]*>)/i],["lang-in.tag",/^(<\/?[a-z][^<>]*>)/i]]),
-["default-markup","htm","html","mxml","xhtml","xml","xsl"]);k(x([["pln",/^\s+/,q," \t\r\n"],["atv",/^(?:"[^"]*"?|'[^']*'?)/,q,"\"'"]],[["tag",/^^<\/?[a-z](?:[\w-.:]*\w)?|\/?>$/i],["atn",/^(?!style[\s=]|on)[a-z](?:[\w:-]*\w)?/i],["lang-uq.val",/^=\s*([^\s"'>]*(?:[^\s"'/>]|\/(?=\s)))/],["pun",/^[/<->]+/],["lang-js",/^on\w+\s*=\s*"([^"]+)"/i],["lang-js",/^on\w+\s*=\s*'([^']+)'/i],["lang-js",/^on\w+\s*=\s*([^\s"'>]+)/i],["lang-css",/^style\s*=\s*"([^"]+)"/i],["lang-css",/^style\s*=\s*'([^']+)'/i],["lang-css",
-/^style\s*=\s*([^\s"'>]+)/i]]),["in.tag"]);k(x([],[["atv",/^[\S\s]+/]]),["uq.val"]);k(u({keywords:F,hashComments:!0,cStyleComments:!0,types:K}),["c","cc","cpp","cxx","cyc","m"]);k(u({keywords:"null,true,false"}),["json"]);k(u({keywords:H,hashComments:!0,cStyleComments:!0,verbatimStrings:!0,types:K}),["cs"]);k(u({keywords:G,cStyleComments:!0}),["java"]);k(u({keywords:v,hashComments:!0,multiLineStrings:!0}),["bsh","csh","sh"]);k(u({keywords:I,hashComments:!0,multiLineStrings:!0,tripleQuotedStrings:!0}),
-["cv","py"]);k(u({keywords:"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",hashComments:!0,multiLineStrings:!0,regexLiterals:!0}),["perl","pl","pm"]);k(u({keywords:J,hashComments:!0,multiLineStrings:!0,regexLiterals:!0}),["rb"]);k(u({keywords:w,cStyleComments:!0,regexLiterals:!0}),["js"]);k(u({keywords:"all,and,by,catch,class,else,extends,false,finally,for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,true,try,unless,until,when,while,yes",
-hashComments:3,cStyleComments:!0,multilineStrings:!0,tripleQuotedStrings:!0,regexLiterals:!0}),["coffee"]);k(x([],[["str",/^[\S\s]+/]]),["regex"]);window.prettyPrintOne=function(a,m,e){var h=document.createElement("PRE");h.innerHTML=a;e&&D(h,e);E({g:m,i:e,h:h});return h.innerHTML};window.prettyPrint=function(a){function m(){for(var e=window.PR_SHOULD_USE_CONTINUATION?l.now()+250:Infinity;p<h.length&&l.now()<e;p++){var n=h[p],k=n.className;if(k.indexOf("prettyprint")>=0){var k=k.match(g),f,b;if(b=
-!k){b=n;for(var o=void 0,c=b.firstChild;c;c=c.nextSibling)var i=c.nodeType,o=i===1?o?b:c:i===3?N.test(c.nodeValue)?b:o:o;b=(f=o===b?void 0:o)&&"CODE"===f.tagName}b&&(k=f.className.match(g));k&&(k=k[1]);b=!1;for(o=n.parentNode;o;o=o.parentNode)if((o.tagName==="pre"||o.tagName==="code"||o.tagName==="xmp")&&o.className&&o.className.indexOf("prettyprint")>=0){b=!0;break}b||((b=(b=n.className.match(/\blinenums\b(?::(\d+))?/))?b[1]&&b[1].length?+b[1]:!0:!1)&&D(n,b),d={g:k,h:n,i:b},E(d))}}p<h.length?setTimeout(m,
-250):a&&a()}for(var e=[document.getElementsByTagName("pre"),document.getElementsByTagName("code"),document.getElementsByTagName("xmp")],h=[],k=0;k<e.length;++k)for(var t=0,s=e[k].length;t<s;++t)h.push(e[k][t]);var e=q,l=Date;l.now||(l={now:function(){return+new Date}});var p=0,d,g=/\blang(?:uage)?-([\w.]+)(?!\S)/;m()};window.PR={createSimpleLexer:x,registerLangHandler:k,sourceDecorator:u,PR_ATTRIB_NAME:"atn",PR_ATTRIB_VALUE:"atv",PR_COMMENT:"com",PR_DECLARATION:"dec",PR_KEYWORD:"kwd",PR_LITERAL:"lit",
-PR_NOCODE:"nocode",PR_PLAIN:"pln",PR_PUNCTUATION:"pun",PR_SOURCE:"src",PR_STRING:"str",PR_TAG:"tag",PR_TYPE:"typ"}})();
diff --git a/modules/facet/docs/userguide.html b/modules/facet/docs/userguide.html
deleted file mode 100644
index 8bc1790..0000000
--- a/modules/facet/docs/userguide.html
+++ /dev/null
@@ -1,786 +0,0 @@
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-<title>Facet Userguide</title>
-
-<!-- load stylesheet + javascript in distribution mode -->
-<link rel="stylesheet" type="text/css" href="prettify.css">
-<script src="prettify.js" type="text/javascript"></script>
-
-<script language="javascript">
-	window.onload=function() {
-		prettyPrint();
-	}
-</script>
-
-<style>
-body {
-  margin-left: 20%;
-  width: 60%;
-  counter-reset: section;
-  text-align: left;
-}
-
-h1.title {
-  text-align: center;
-  margin-top: 30px;
-  font-size: 5em;
-  line-height: 150%;
-}
-
-h1.section {
-  margin-top: 50px;
-  font-size: 2.5em;
-  counter-reset: subsection;
-  border: 1px solid black;
-  background-color: #D8D8D8;
-  padding-left: 5px;
-}
-
-h2.subsection {
-  font-size: 2em;
-  border: 1px solid black;
-  background-color: #D8D8D8;
-  padding-left: 5px;
-}
-
-/* auto-generated heading numbers */
-h1.section:before {
-counter-increment: section;
-content: counter(section) ". ";
-}
-
-h2.subsection:before  {
-counter-increment: subsection;
-content: counter(section) "." counter(subsection) " ";
-}
-
-/* override from prettify.css - add shadow, padding etc. */
-pre.prettyprint {
-  margin-left: 2%;
-  width: 80%;
-  padding: 5px 3px 5px 3px;
-  /* shadow */
-  -moz-box-shadow: 5px 5px 2px #888;
-  -webkit-box-shadow: 5px 5px 2px #888;
-  box-shadow: 5px 5px 2px #888;
-}
-
-/* override from prettify.css - make keywords appear in bold */
-span.kwd {
-  font-weight: bold;
-}
-
-ol.toc a {
-  text-decoration: none;
-  color: blue;
-}
-
-li.toc_first {
-  // margin-top: 10px;
-  font-size: 16px;
-  color: blue;
-}
-
-li.toc_second {
-  font-size: 14px;
-  margin-left: 15px;
-  color: blue;
-}
-
-/* reset style from prettify.css, so that line numbers appear in each line */
-li.L0,li.L1,li.L2,li.L3,li.L5,li.L6,li.L7,li.L8 {
-  list-style-type:decimal
-}
-
-table.code_description td {
-  vertical-align: top;
-}
-
-</style>
-
-<body>
-<h1 class="title">
-	Apache Lucene<br>
-	Faceted Search<br>
-	User's Guide</h1>
-
-<div class="toc">
-<h1 class="toc">Table of Contents</h1>
-<ol class="toc">
-<li class="toc_first"><a href="#intro">Introduction</a></li>
-<li class="toc_first"><a href="#facet_features">Facet Features</a></li>
-<li class="toc_first"><a href="#facet_indexing">Indexing Categories Illustrated</a></li>
-<li class="toc_first"><a href="#facet_accumulation">Accumulating Facets Illustrated</a></li>
-<li class="toc_first"><a href="#indexed_facet_info">Indexed Facet Information</a></li>
-<li class="toc_first"><a href="#taxonomy_index">Taxonomy Index</a></li>
-<li class="toc_first"><a href="#facet_params">Facet Parameters</a></li>
-<li class="toc_first"><a href="#advanced">Advanced Faceted Examples</a></li>
-<li class="toc_first"><a href="#optimizations">Optimizations</a></li>
-<li class="toc_first"><a href="#concurrent_indexing_search">Concurrent Indexing and Search</a></li>
-</ol>
-
-<h1 class="section"><a name="intro">Introduction</a></h1>
-<p>
-A category is an aspect of indexed documents which can be used to classify the
-documents. For example, in a collection of books at an online bookstore, categories of
-a book can be its price, author, publication date, binding type, and so on.
-<p>
-In faceted search, in addition to the standard set of search results, we also get facet
-results, which are lists of subcategories for certain categories. For example, for the
-price facet, we get a list of relevant price ranges; for the author facet, we get a list of
-relevant authors; and so on. In most UIs, when users click one of these subcategories,
-the search is narrowed, or drilled down, and a new search limited to this subcategory
-(e.g., to a specific price range or author) is performed.
-<p>
-Note that faceted search is more than just the ordinary fielded search. In fielded
-search, users can add search keywords like price:10 or author:"Mark
-Twain" to the query to narrow the search, but this requires knowledge of which
-fields are available, and which values are worth trying. This is where faceted search
-comes in: it provides a list of useful subcategories, which ensures that the user only
-drills down into useful subcategories and never into a category for which there are no
-results. In essence, faceted search makes it easy to navigate through the search results.
-The list of subcategories provided for each facet is also useful to the user in itself,
-even when the user never drills down. This list allows the user to see at one glance
-some statistics on the search results, e.g., what price ranges and which authors are
-most relevant to the given query.
-<p>
-In recent years, faceted search has become a very common UI feature in search
-engines, especially in e-commerce websites. Faceted search makes it easy for
-untrained users to find the specific item they are interested in, whereas manually
-adding search keywords (as in the examples above) proved too cumbersome for
-ordinary users, and required too much guesswork, trial-and-error, or the reading of
-lengthy help pages.
-<p>
-See <a href="http://en.wikipedia.org/wiki/Faceted_search">http://en.wikipedia.org/wiki/Faceted_search</a> for more information on faceted
-search.
-
-<h1 class="section"><a name="facet_features">Facet Features</a></h1>
-First and main faceted search capability that comes to mind is counting, but in fact
-faceted search is more than facet counting. We now briefly discuss the available
-faceted search features.
-
-<h2 class="subsection">Facet Counting</h2>
-<p>
-Which of the available subcategories of a facet should a UI display? A query in a
-book store might yield books by a hundred different authors, but normally we'd want
-do display only, say, ten of those.
-<p>
-Most available faceted search implementations use counts to determine the
-importance of each subcategory. These implementations go over all search results for
-the given query, and count how many results are in each subcategory. Finally, the
-subcategories with the most results can be displayed. So the user sees the price ranges,
-authors, and so on, for which there are most results. Often, the count is displayed next
-to the subcategory name, in parentheses, telling the user how many results he can
-expect to see if he drills down into this subcategory.
-<p>
-The main API for obtaining facet counting is <code>CountFacetRequest</code>, as in the
-following code snippet:
-<pre class="prettyprint lang-java">
-new CountFacetRequest(new CategoryPath("author"), 10));
-</pre>
-A detailed code example using count facet requests is shown below - see
-<a href="#facet_accumulation">Accumulating Facets</a>.
-
-<h2 class="subsection"><a name="facet_association">Facet Associations</a></h2>
-<p>
-So far we've discussed categories as binary features, where a document either belongs
-to a category, or not.
-<p>
-While counts are useful in most situations, they are sometimes not sufficiently
-informative for the user, with respect to deciding which subcategory is more
-important to display.
-<p>
-For this, the facets package allows to associate a value with a category. The search
-time interpretation of the associated value is application dependent. For example, a
-possible interpretation is as a <i>match level</i> (e.g., confidence level). This value can
-then be used so that a document that is very weakly associated with a certain category
-will only contribute little to this category's aggregated weight.
-
-<h2 class="subsection"><a name="multiple_requests">Multiple Facet Requests</a></h2>
-<p>
-A single faceted accumulation is capable of servicing multiple facet requests.
-Programmatic, this is quite simple - wrap all the facet requests of interest into the
-facet-search-parameters which are passed to a facets accumulator/collector (more on
-these objects below). The results would be comprised of as many facet results as there
-were facet requests.
-<p>
-However there is a delicate <b>limitation</b>: all facets maintained in the same location in
-the index are required to be treated the same. See the section on <a href="#indexing_params">Indexing Parameters</a>
-for an explanation on maintaining certain facets at certain locations.
-
-<h2 class="subsection"><a name="facet_labels">Facet Labels at Search Time</a></h2>
-<p>
-Facets results always contain the facet (internal) ID and (accumulated) value. Some of
-the results also contain the facet label, AKA the category name. We mention this here
-since computing the label is a time consuming task, and hence applications can
-specify with a facet request to return top 1000 facets but to compute the label only for
-the top 10 facets. In order to compute labels for more of the facet results it is not
-required to perform accumulation again.
-<p>
-See <code>FacetRequest.getNumResults()</code>, <code>FacetRequest.getNumLabel()</code> and
-<code>FacetResultNode.getLabel(TaxonomyReader)</code>.
-
-<h1 class="section"><a name="facet_indexing">Indexing Categories Illustrated</a></h1>
-<p>
-In order to find facets at search time they must first be added to the index at indexing
-time. Recall that Lucene documents are made of fields for textual search. The addition
-of categories is performed by an appropriate <code>DocumentBuilder</code> - or
-<code>CategoryDocumentBuilder</code> in our case.
-<p>
-Indexing therefore usually goes like this:
-<ul>
-<li>For each input document:
-<ul>
-<li>Create a fresh (empty) Lucene Document</li>
-<li>Parse input text and add appropriate text search fields</li>
-<li><b>Gather all input categories associated with the document and create
-a CategoryDocumentBuilder with the list of categories</b></li>
-<li><b>Build the document - this actually adds the categories to the
-Lucene document.</b></li>
-<li>Add the document to the index</li>
-</ul></li>
-</ul>
-Following is a code snippet for indexing categories. The complete example can be
-found in package <code>org.apache.lucene.facet.example.simple.SimpleIndexer</code>.
-<pre class="prettyprint lang-java linenums">
-IndexWriter writer = ...
-TaxonomyWriter taxo = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE);
-...
-Document doc = new Document();
-doc.add(new Field("title", titleText, Store.YES, Index.ANALYZED));
-...
-List&lt;CategoryPath&gt; categories = new ArrayList&lt;CategoryPath&gt;();
-categories.add(new CategoryPath("author", "Mark Twain"));
-categories.add(new CategoryPath("year", "2010"));
-...
-DocumentBuilder categoryDocBuilder = new CategoryDocumentBuilder(taxo);
-categoryDocBuilder.setCategoryPaths(categories);
-categoryDocBuilder.build(doc);
-writer.addDocument(doc);
-</pre>
-<p>
-We now explain the steps above, following the code line numbers:
-<table class="code_description">
-<tr>
-	<td>(4)</td>
-	<td>Document contains not only text search fields but also facet search
-information.</td>
-</tr>
-<tr>
-	<td>(7)</td>
-	<td>Prepare a container for document categories.</td>
-</tr>
-<tr>
-	<td>(8)</td>
-	<td>Categories that should be added to the document are accumulated in the
-categories list.</td>
-</tr>
-<tr>
-	<td>(11)</td>
-	<td>A <code>CategoryDocumentBuilder</code> is created, set with the appropriate list
-of categories, and invoked to build - that is, to populate the document
-with categories. It is in this step that the taxonomy is updated to contain the
-newly added categories (if not already there) - see more on this in the
-section about the <a href="#taxonomy_index">Taxonomy Index</a> below. This line could be made more
-compact: one can create a single <code>CategoryDocumentBuilder cBuilder</code> and reuse it like this:
-<pre class="prettyprint lang-java linenums">
-DocumentBuilder cBuilder = new CategoryDocumentBuilder(taxo);
-cBuilder.setCategoryPaths(categories).build(doc);
-</pre>
-	</td>
-</tr>
-<tr>
-	<td>(14)</td>
-	<td>Add the document to the index. As a result, category info is saved also in
-the regular search index, for supporting facet aggregation at search time
-(e.g. facet counting) as well as facet drill-down. For more information on
-indexed facet information see below the section <a href="#indexed_facet_info">Indexed Facet Information</a>.</td>
-</tr>
-</table>
-
-<h1 class="section"><a name="facet_accumulation">Accumulating Facets Illustrated</a></h1>
-<p>
-Facets accumulation reflects a set of documents over some facet requests:
-<ul>
-<li><code>Document set</code> - a subset of the index documents, usually documents
-matching a user query.</li>
-<li><code>Facet requests</code> - facet accumulation specification, e.g. count a certain facet
-<i>dimension</i>.</li>
-</ul>
-<p>
-<code>FacetRequest</code> is a basic component in faceted search - it describes the facet
-information need. Every facet <b>request</b> is made of at least two fields:
-<ul>
-<li><code>CategoryPath</code> - root category of the facet request. The categories that
-are returned as a result of the request will all be descendants of this root</li>
-<li><code>Number of Results</code> - number of sub-categories to return (at most).</li>
-</ul>
-<p>
-There are other parameters to a facet request, such as -how many facet results to
-label-, -how <b>deep</b> to go from the request root when serving the facet request- and
-more - see the API Javadocs for <code>FacetRequest</code> and its subclasses for more
-information on these parameters. For labels in particular, see the section <a href="#facet_labels">Facet Labels
-at Search Time</a>.
-<p>
-<code>FacetRequest</code> in an abstract class, open for extensions, and users may add their
-own requests. The most often used request is <code>CountFacetRequest</code> - used for
-counting facets.
-<p>
-Facets accumulation is - not surprisingly - driven by a <code>FacetsAccumulator</code>. The
-most used one is <code>StandardFacetsAccumulator</code>, however there are also accumulators
-that support sampling - to be used in huge collections, and there's an adaptive facets
-accumulator which applies sampling conditionally on the statistics of the data. While
-facets accumulators are very extendible and powerful, they might be too
-overwhelming for beginners. For this reason, the code offers a higher level interface
-for facets accumulating: the <code>FacetsCollector</code>. It extends <code>Collector</code>, and as such
-can be passed to the search() method of Lucene's <code>IndexSearcher</code>. In case the
-application also needs to collect documents (in addition to accumulating/collecting
-facets), it can wrap multiple collectors with <code>MultiCollector</code>. Most code samples
-below use <code>FacetsCollector</code> due to its simple interface. It is quite likely that
-<code>FacetsCollector</code> should suffice the needs of most applications, therefore we
-recommend to start with it, and only when needing more flexibility turn to directly
-use facets accumulators.
-<p>
-Following is a code snippet from the example code - the complete example can be
-found under <code>org.apache.lucene.facet.example.simple.Searcher</code>:
-<pre class="prettyprint lang-java linenums">
-IndexReader indexReader = IndexReader.open(indexDir);
-Searcher searcher = new IndexSearcher(indexReader);
-TaxonomyReader taxo = new DirectoryTaxonomyReader(taxoDir);
-...
-Query q = new TermQuery(new Term(SimpleUtils.TEXT, "white"));
-TopScoreDocCollector tdc = TopScoreDocCollector.create(10, true);
-...
-FacetSearchParams facetSearchParams = new FacetSearchParams();
-facetSearchParams.addFacetRequest(new CountFacetRequest(
-    new CategoryPath("author"), 10));
-...
-FacetsCollector facetsCollector = new FacetsCollector(facetSearchParams, indexReader, taxo);
-searcher.search(q, MultiCollector.wrap(topDocsCollector, facetsCollector));
-List&lt;FacetResult&gt; res = facetsCollector.getFacetResults();
-</pre>
-<p>
-We now explain the steps above, following the code line numbers:
-<table class="code_description">
-<tr>
-	<td>(1)</td>
-	<td>Index reader and Searcher are initialized as usual.</td>
-</tr>
-<tr>
-	<td>(3)</td>
-	<td>A taxonomy reader is opened - it provides access to the facet information
-which was stored by the Taxonomy Writer at indexing time.</td>
-</tr>
-<tr>
-	<td>(5)</td>
-	<td>Regular text query is created to find the documents matching user need, and
-a collector for collecting the top matching documents is created.</td>
-</tr>
-<tr>
-	<td>(8)</td>
-	<td>Facet-search-params is a container for facet requests.</td>
-</tr>
-<tr>
-	<td>(10)</td>
-	<td>A single facet-request - namely a count facet request - is created and added
-to the facet search params. The request should return top 10 Author
-subcategory counts.</td>
-</tr>
-<tr>
-	<td>(12)</td>
-	<td>Facets-Collector is the simplest interface for facets accumulation (counting
-in this example).</td>
-</tr>
-<tr>
-	<td>(13)</td>
-	<td>Lucene search takes both collectors - facets-collector and top-doccollector,
-both wrapped by a multi-collector. This way, a single search
-operation finds both top documents and top facets. Note however that facets
-aggregation takes place not only over the top documents, but rather over all
-documents matching the query.</td>
-</tr>
-<tr>
-	<td>(14)</td>
-	<td>Once search completes, facet-results can be obtained from the facetscollector.</td>
-</tr>
-</table>
-
-<p>
-Returned facet results are organized in a list, conveniently ordered the same as the
-facet-requests in the facet-search-params. Each result however contains the request
-for which it was created.</li>
-<p>
-Here is the (recursive) structure of the facet result:
-<ul>
-<li><b>Facet Result</b>
-<ul>
-<li><b>Facet Request</b> - the request for which this result was obtained.</li>
-<li><b>Valid Descendants</b> - how many valid descendants were encountered
-over the set of matching documents (some of which might have been
-filtered out because e.g. only top 10 results were requested).</li>
-<li><b>Root Result Node</b> - root facet result for the request
-<ul>
-<li><b>Ordinal</b> - unique internal ID of the facet</li>
-<li><b>Label</b> - full label of the facet (possibly null)</li>
-<li><b>Value</b> - facet value, e.g. count</li>
-<li><b>Sub-results-nodes</b> - child result nodes (possibly null)</li>
-</ul></li>
-</ul></li>
-</ul>
-<p>
-Note that not always there would be sub result nodes - this depends on the
-requested result mode:
-<ul>
-<li><b>PER_NODE_IN_TREE</b> - a tree, and so there may be sub results.</li>
-<li><b>GLOBAL_FLAT</b> - here the results tree would be rather flat, with only (at
-most) leaves below the root result node.</li>
-</ul>
-
-<h1 class="section"><a name="indexed_facet_info">Indexed Facet Information</a></h1>
-<p>
-When indexing a document to which categories were added, information on these
-categories is added to the search index, in two locations:
-<ul>
-<li><i>Category Tokens</i> are added to the document for each category attached to
-that document. These categories can be used at search time for drill-down.</li>
-<li>A special <i>Category List Token</i> is added to each document containing
-information on all the categories that were added to this document. This can
-be used at search time for facet accumulation, e.g. facet counting.</li>
-</ul>
-<p>
-When a category is added to the index (that is, when a document containing a
-category is indexed), all its parent categories are added as well. For example, indexing
-a document with the category <code>&lt;<span style="color: blue">"author"</span>, 
-<span style="color: blue">"American-</span>, <span style="color: blue">"Mark Twain"</span>&gt;</code> results in
-creating three tokens: <code>"/author"</code>, <code>"/author/American"</code>, and
-<code>"/author/American/Mark Twain"</code> (the character <code>'/'</code> here is just a human
-readable separator - there's no such element in the actual index). This allows drilling down
-and counting any category in the taxonomy, and not just leaf nodes, enabling a
-UI application to show either how many books have authors, or how many books
-have American authors, or how many books have Mark Twain as their (American)
-author.
-<p>
-Similarly, Drill-down capabilities are this way possible also for node categories.
-<p>
-In order to keep the counting list compact, it is built using category ordinal - an
-ordinal is an integer number attached to a category when it is added for the first time
-into the taxonomy.
-<p>
-For ways to further alter facet index see the section below on <a href="#indexing_params">Facet Indexing
-Parameters</a>.
-
-<h1 class="section"><a name="taxonomy_index">Taxonomy Index</a></h1>
-<p>
-The taxonomy is an auxiliary data-structure maintained side-by-side with the regular
-index to support faceted search operations. It contains information about all the
-categories that ever existed in any document in the index. Its API is open and allows
-simple usage, or more advanced for the interested users.
-<p>
-When a category is added to a document, a corresponding node is added to the
-taxonomy (unless already there). In fact, sometimes more than one node is added -
-each parent category is added as well, so that the taxonomy is maintained as a Tree,
-with a virtual root.
-<p>
-So, for the above example, adding the category the category <code>&lt;<span style="color: blue">"author"</span>, 
-<span style="color: blue">"American-</span>, <span style="color: blue">"Mark Twain"</span>&gt;</code> 
-actually added three nodes: one for <code>"/author"</code>, one for <code>"/author/American"</code> and one for 
-<code>"/author/American/Mark Twain"</code>.
-<p>
-An integer number - called ordinal is attached to each category the first time the
-category is added to the taxonomy. This allows for a compact representation of
-category list tokens in the index, for facets accumulation.
-<p>
-One interesting fact about the taxonomy index is worth knowing: once a category
-is added to the taxonomy, it is never removed, even if all related documents are
-removed. This differs from a regular index, where if all documents containing a
-certain term are removed, and their segments are merged, the term will also be
-removed. This might cause a performance issue: large taxonomy means large ordinal
-numbers for categories, and hence large categories values arrays would be maintained
-during accumulation. It is probably not a real problem for most applications, but be
-aware of this. If, for example, an application at a certain point in time removes an
-index entirely in order to recreate it, or, if it removed all the documents from the index
-in order to re-populate it, it also makes sense in this opportunity to remove the
-taxonomy index and create a new, fresh one, without the unused categories.
-
-<h1 class="section"><a name="facet_params">Facet Parameters</a></h1>
-<p>
-Facet parameters control how categories and facets are indexed and searched. Apart
-from specifying facet requests within facet search parameters, under default settings it
-is not required to provide any parameters, as there are ready to use working defaults
-for everything.
-<p>
-However many aspects are configurable and can be modified by providing altered
-facet parameters for either search or indexing.
-
-<h2 class="subsection"><a name="indexing_params">Facet Indexing Parameters</a></h2>
-<p>
-Facet Indexing Parameters are consulted with during indexing. Among several
-parameters it defines, the following two are likely to interest many applications:
-<ul>
-<li><b>Category list definitions</b> - in the index, facets are maintained in two
-forms: category-tokens (for drill-down) and category-list-tokens (for
-accumulation). This parameter allows to specify, for each category, the
-Lucene term used for maintaining the category-list-tokens for that category.
-The default implementation in <code>DefaultFacetIndexingParams</code> maintains
-this information for all categories under the same special dedicated term.
-One case where it is needed to maintain two categories in separate category
-lists, is when it is known that at search time it would be required to use
-different types of accumulation logic for each, but at the same accumulation
-call.</li>
-<li><b>Partition size</b> - category lists can be maintained in a partitioned way. If,
-for example, the partition size is set to 1000, a distinct sub-term is used for
-maintaining each 1000 categories, e.g. term1 for categories 0 to 999, term2
-for categories 1000 to 1999, etc. The default implementation in
-<code>DefaultFacetIndexingParams</code> maintains category lists in a single
-partition, hence it defines the partition size as <code>Integer.MAX_VALUE</code>. The
-importance of this parameter is on allowing to handle very large
-taxonomies without exhausting RAM resources. This is because at facet
-accumulation time, facet values arrays are maintained in the size of the
-partition. With a single partition, the size of these arrays is as the size of the
-taxonomy, which might be OK for most applications. Limited partition
-sizes allow to perform the accumulation with less RAM, but with some
-runtime overhead, as the matching documents are processed for each of the
-partitions.</li>
-</ul>
-<p>
-See the API Javadocs of <code>FacetIndexingParams</code> for additional configuration
-capabilities which were not discussed here.
-
-<h2 class="subsection"><a name="search_params">Facet Search Parameters</a></h2>
-<p>
-Facet Search Parameters, consulted at search time (during facets accumulation) are
-rather plain, providing the following:
-<ul>
-<li><b>Facet indexing parameters</b> - which were in effect at indexing time -
-allowing facets accumulation to understand how facets are maintained in
-the index.</li>
-<li><b>Container of facet requests</b> - the requests which should be accumulated.</li>
-</ul>
-
-<h2 class="subsection"><a name="category_lists_multiple_dimensions">Category Lists, Multiple Dimensions</a></h2>
-<p>
-Category list parameters which are accessible through the facet indexing parameters
-provide the information about:
-<ul>
-<li>Lucene Term under which category information is maintained in the index.</li>
-<li>Encoding (and decoding) used for writing and reading the categories
-information in the index.</li>
-</ul>
-<p>
-For cases when certain categories should be maintained in different location than
-others, use <code>PerDimensionIndexingParams</code>, which returns a different
-<code>CategoryListParams</code> object for each <i>dimension</i>. This is a good opportunity to
-explain about dimensions. This is just a notion: the top element - or first element - in
-a category path is denoted as the dimension of that category. Indeed, the dimension
-stands out as a top important part of the category path, such as <code>"Location"</code> for the
-category <code>"Location/Europe/France/Paris"</code>.
-
-<h1 class="section"><a name="advanced">Advanced Faceted Examples</a></h1>
-<p>
-We now provide examples for more advanced facet indexing and search, such as
-drilling-down on facet values and multiple category lists.
-
-<h2 class="subsection"><a name="drill_down">Drill-Down with Regular Facets</a></h2>
-<p>
-Drill-down allows users to focus on part of the results. Assume a commercial sport
-equipment site where a user is searching for a tennis racquet. The user issues the
-query <i>tennis racquet</i> and as result is shown a page with 10 tennis racquets, by
-various providers, of various types and prices. In addition, the site UI shows to the
-user a break down of all available racquets by price and make. The user now decides
-to focus on racquets made by <i>Head</i>, and will now be shown a new page, with 10
-Head racquets, and new break down of the results into racquet types and prices.
-Additionally, the application can choose to display a new breakdown, by racquet
-weights. This step of moving from results (and facet statistics) of the entire (or larger)
-data set into a portion of it by specifying a certain category, is what we call <i>Drilldown</i>.
-We now show the required code lines for implementing such a drill-down.
-<pre class="prettyprint lang-java linenums">
-Query baseQuery = queryParser.parse("tennis racquet");
-Query q2 = DrillDown.query(baseQuery, new CategoryPath("make", "head"), 10));
-</pre>
-<p>
-In line 1 the original user query is created and then used to obtain information on
-all tennis racquets.
-<p>
-In line 2, a specific category from within the facet results was selected by the user,
-and is hence used for creating the drill-down query.
-<p>
-Please refer to <code>SimpleSearcher.searchWithDrillDown()</code> for a more detailed
-code example performing drill-down.
-
-<h2 class="subsection"><a name="multi-category_list">Multiple Category Lists</a></h2>
-<p>
-The default is to maintain all categories information in a single list. While this will
-suit most applications, in some situations an application may wish to use multiple
-category lists, for example, when the distribution of some category values is different
-than that of other categories and calls for using a different encoding, more efficient
-for the specific distribution. Another example is when most facets are rarely used
-while some facets are used very heavily, so an application may opt to maintain the
-latter in memory - and in order to keep memory footprint lower it is useful to
-maintain only those heavily used facets in a separate category list.
-<p>
-First we define indexing parameters with multiple category lists:
-<pre class="prettyprint lang-java linenums">
-PerDimensionIndexingParams iParams = new PerDimensionIndexingParams();
-iParams.addCategoryListParams(new CategoryPath("Author"), 
-    new CategoryListParams(new Term("$RarelyUsed", "Facets")));
-iParams.addCategoryListParams(new CategoryPath("Language"),
-    new CategoryListParams(new Term("$HeavilyUsed", "Ones")));
-</pre>
-<p>
-This will cause the Language categories to be maintained in one category list, and
-Author facets to be maintained in a another category list. Note that any other category,
-if encountered, will still be maintained in the default category list.
-<p>
-These non-default indexing parameters should now be used both at indexing and
-search time. As depicted below, at indexing time this is done when creating the
-category document builder, while at search time this is done when creating the search
-parameters. Other than that the faceted search code is unmodified.
-<pre class="prettyprint lang-java linenums">
-DocumentBuilder categoryDocBuilder = new CategoryDocumentBuilder(taxo, iParams);
-...
-FacetSearchParams facetSearchParams = new FacetSearchParams(iParams);
-</pre>
-<p>
-A complete simple example can be found in package <code>org.apache.lucene.facet.example.multiCL</code> 
-under the example code.
-
-<h1 class="section"><a name="optimizations">Optimizations</a></h1>
-<p>
-Faceted search through a large collection of documents with large numbers of facets
-altogether and/or large numbers of facets per document is challenging performance
-wise, either in CPU, RAM, or both. A few ready to use optimizations exist to tackle
-these challenges.
-
-<h2 class="subsection"><a name="sampling">Sampling</a></h2>
-<p>
-Facet sampling allows to accumulate facets over a sample of the matching
-documents set. In many cases, once top facets are found over the sample set, exact
-accumulations are computed for those facets only, this time over the entire matching
-document set.
-<p>
-Two kinds of sampling exist: complete support and wrapping support. The
-complete support is through <code>SamplingAccumulator</code> and is tied to an extension of the
-<code>StandardFacetsAccumulator</code> and has the benefit of automatically applying other
-optimizations, such as <a href="#complements">Complements</a>. The wrapping support is through
-<code>SamplingWrapper</code> and can wrap any accumulator, and as such, provides more
-freedom for applications.
-
-<h2 class="subsection"><a name="complements">Complements</a></h2>
-<p>
-When accumulating facets over a very large matching documents set, possibly
-almost as large as the entire collection, it is possible to speed up accumulation by
-looking at the complement set of documents, and then obtaining the actual results by
-subtracting from the total results. It should be noted that this is available only for
-count requests, and that the first invocation that involves this optimization might take
-longer because the total counts have to be computed.
-<p>
-This optimization is applied automatically by <code>StandardFacetsAccumulator</code>.
-
-<h2 class="subsection"><a name="partitions">Partitions</a></h2>
-<p>
-Partitions are also discussed in the section about <a href="#indexing_params">Facet Indexing parameters.</a>
-<p>
-Facets are internally accumulated by first accumulating all facets and later on
-extracting the results for the requested facets. During this process, accumulation
-arrays are maintained in the size of the taxonomy. For a very large taxonomy, with
-multiple simultaneous faceted search operations, this might lead to excessive memory
-footprint. Partitioning the faceted information allows to relax the memory usage, by
-maintaining the category lists in several partitions, and by processing one partition at
-a time. This is automatically done by <code>StandardFacetsAccumulator</code>. However the
-default partition size is <code>Integer.MAX_VALUE</code>, practically setting to a single partition,
-i.e. no partitions at all.
-<p>
-Decision to override this behavior and use multiple partitions must be taken at
-indexing time. Once the index is created and already contains category lists it is too
-late to modify this.
-<p>
-See <code>FacetIndexingParams.getPartitionSize()</code> for API to alter this default
-behavior.
-
-<h1 class="section"><a name="concurrent_indexing_search">Concurrent Indexing and Search</a></h1>
-<p>
-Sometimes, indexing is done once, and when the index is fully prepared, searching
-starts. However, in most real applications indexing is <i>incremental</i> (new data comes in
-once in a while, and needs to be indexed), and indexing often needs to happen while
-searching is continuing at full steam.
-<p>
-Luckily, Lucene supports multiprocessing - one process writing to an index while
-another is reading from it. One of the key insights behind how Lucene allows multiprocessing 
-is <i>Point In Time</i> semantics. The idea is that when an <code>IndexReader</code> is opened, 
-it gets a view of the index at the <i>point in time</i> it was opened. If an <code>IndexWriter</code> 
-in a different process or thread modifies the index, the reader does not know about it until a new 
-<code>IndexReader</code> is opened (or the reopen() method of an existing <code>IndexReader</code> is called).
-<p>
-In faceted search, we complicate things somewhat by adding a second index - the
-taxonomy index. The taxonomy API also follows point-in-time semantics, but this is
-not quite enough. Some attention must be paid by the user to keep those two indexes
-consistently in sync:
-<p>
-The main index refers to category numbers defined in the taxonomy index.
-Therefore, it is important that we open the <code>TaxonomyReader</code> <i>after</i> opening the
-IndexReader. Moreover, every time an IndexReader is reopen()ed, the
-TaxonomyReader needs to be refresh()'ed as well.
-<p>
-But there is one extra caution: whenever the application deems it has written
-enough information worthy a commit, it must <b>first</b> call commit() for the
-<code>TaxonomyWriter</code> and only <b>after</b> that call commit() for the <code>IndexWriter</code>. 
-Closing the indices should also be done in this order - <b>first</b> close the taxonomy, and only <b>after</b>
-that close the index.
-<p>
-To summarize, if you're writing a faceted search application where searching and
-indexing happens concurrently, please follow these guidelines (in addition to the usual
-guidelines on how to use Lucene correctly in the concurrent case):
-<ul>
-<li>In the indexing process:
-<ol>
-<li>Before a writer commit()s the IndexWriter, it must commit() the
-TaxonomyWriter. Nothing should be added to the index between these
-two commit()s.</li>
-<li>Similarly, before a writer close()s the IndexWriter, it must close() the
-TaxonomyWriter.</li>
-</ol></li>
-<li>In the searching process:
-<ol>
-<li>Open the IndexReader first, and then the TaxonomyReader.</li>
-<li>After a reopen() on the IndexReader, refresh() the TaxonomyReader.
-No search should be performed on the new IndexReader until refresh()
-has finished.</li>
-</ol></li>
-</ul>
-<p>
-Note that the above discussion assumes that the underlying file-system on which
-the index and the taxonomy are stored respects ordering: if index A is written before
-index B, then any reader finding a modified index B will also see a modified index A.
-<p>
-<b>Note:</b> <code>TaxonomyReader</code>'s refresh() is simpler than <code>IndexReader</code>'s reopen(). 
-While the latter keeps both the old and new reader open, the former keeps only the new reader. The reason 
-is that a new <code>IndexReader</code> might have modified old information (old documents deleted, for 
-example) so a thread which is in the middle of a search needs to continue using the old information. With 
-<code>TaxonomyReader</code>, however, we are guaranteed that existing categories are never deleted or modified - 
-the only thing that can happen is that new categories are added. Since search threads do not care if new categories 
-are added in the middle of a search, there is no reason to keep around the old object, and the new one suffices.
-<br><b>However</b>, if the taxonomy index was recreated since the <code>TaxonomyReader</code> was opened or
-refreshed, this assumption (that categories are forevr) no longer holds, and <code>refresh()</code> will 
-throw an <code>InconsistentTaxonomyException</code>, guiding the application to open 
-a new <code>TaxonomyReader</code> for up-to-date taxonomy data. (Old one can
-be closed as soon as it is no more used.)
-
-
-</body>
-</html>
diff --git a/modules/facet/src/java/org/apache/lucene/facet/doc-files/prettify.css b/modules/facet/src/java/org/apache/lucene/facet/doc-files/prettify.css
new file mode 100755
index 0000000..d44b3a2
--- /dev/null
+++ b/modules/facet/src/java/org/apache/lucene/facet/doc-files/prettify.css
@@ -0,0 +1 @@
+.pln{color:#000}@media screen{.str{color:#080}.kwd{color:#008}.com{color:#800}.typ{color:#606}.lit{color:#066}.pun,.opn,.clo{color:#660}.tag{color:#008}.atn{color:#606}.atv{color:#080}.dec,.var{color:#606}.fun{color:red}}@media print,projection{.str{color:#060}.kwd{color:#006;font-weight:bold}.com{color:#600;font-style:italic}.typ{color:#404;font-weight:bold}.lit{color:#044}.pun,.opn,.clo{color:#440}.tag{color:#006;font-weight:bold}.atn{color:#404}.atv{color:#060}}pre.prettyprint{padding:2px;border:1px solid #888}ol.linenums{margin-top:0;margin-bottom:0}li.L0,li.L1,li.L2,li.L3,li.L5,li.L6,li.L7,li.L8{list-style-type:none}li.L1,li.L3,li.L5,li.L7,li.L9{background:#eee}
\ No newline at end of file
diff --git a/modules/facet/src/java/org/apache/lucene/facet/doc-files/prettify.js b/modules/facet/src/java/org/apache/lucene/facet/doc-files/prettify.js
new file mode 100755
index 0000000..eef5ad7
--- /dev/null
+++ b/modules/facet/src/java/org/apache/lucene/facet/doc-files/prettify.js
@@ -0,0 +1,28 @@
+var q=null;window.PR_SHOULD_USE_CONTINUATION=!0;
+(function(){function L(a){function m(a){var f=a.charCodeAt(0);if(f!==92)return f;var b=a.charAt(1);return(f=r[b])?f:"0"<=b&&b<="7"?parseInt(a.substring(1),8):b==="u"||b==="x"?parseInt(a.substring(2),16):a.charCodeAt(1)}function e(a){if(a<32)return(a<16?"\\x0":"\\x")+a.toString(16);a=String.fromCharCode(a);if(a==="\\"||a==="-"||a==="["||a==="]")a="\\"+a;return a}function h(a){for(var f=a.substring(1,a.length-1).match(/\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\[0-3][0-7]{0,2}|\\[0-7]{1,2}|\\[\S\s]|[^\\]/g),a=
+[],b=[],o=f[0]==="^",c=o?1:0,i=f.length;c<i;++c){var j=f[c];if(/\\[bdsw]/i.test(j))a.push(j);else{var j=m(j),d;c+2<i&&"-"===f[c+1]?(d=m(f[c+2]),c+=2):d=j;b.push([j,d]);d<65||j>122||(d<65||j>90||b.push([Math.max(65,j)|32,Math.min(d,90)|32]),d<97||j>122||b.push([Math.max(97,j)&-33,Math.min(d,122)&-33]))}}b.sort(function(a,f){return a[0]-f[0]||f[1]-a[1]});f=[];j=[NaN,NaN];for(c=0;c<b.length;++c)i=b[c],i[0]<=j[1]+1?j[1]=Math.max(j[1],i[1]):f.push(j=i);b=["["];o&&b.push("^");b.push.apply(b,a);for(c=0;c<
+f.length;++c)i=f[c],b.push(e(i[0])),i[1]>i[0]&&(i[1]+1>i[0]&&b.push("-"),b.push(e(i[1])));b.push("]");return b.join("")}function y(a){for(var f=a.source.match(/\[(?:[^\\\]]|\\[\S\s])*]|\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\\d+|\\[^\dux]|\(\?[!:=]|[()^]|[^()[\\^]+/g),b=f.length,d=[],c=0,i=0;c<b;++c){var j=f[c];j==="("?++i:"\\"===j.charAt(0)&&(j=+j.substring(1))&&j<=i&&(d[j]=-1)}for(c=1;c<d.length;++c)-1===d[c]&&(d[c]=++t);for(i=c=0;c<b;++c)j=f[c],j==="("?(++i,d[i]===void 0&&(f[c]="(?:")):"\\"===j.charAt(0)&&
+(j=+j.substring(1))&&j<=i&&(f[c]="\\"+d[i]);for(i=c=0;c<b;++c)"^"===f[c]&&"^"!==f[c+1]&&(f[c]="");if(a.ignoreCase&&s)for(c=0;c<b;++c)j=f[c],a=j.charAt(0),j.length>=2&&a==="["?f[c]=h(j):a!=="\\"&&(f[c]=j.replace(/[A-Za-z]/g,function(a){a=a.charCodeAt(0);return"["+String.fromCharCode(a&-33,a|32)+"]"}));return f.join("")}for(var t=0,s=!1,l=!1,p=0,d=a.length;p<d;++p){var g=a[p];if(g.ignoreCase)l=!0;else if(/[a-z]/i.test(g.source.replace(/\\u[\da-f]{4}|\\x[\da-f]{2}|\\[^UXux]/gi,""))){s=!0;l=!1;break}}for(var r=
+{b:8,t:9,n:10,v:11,f:12,r:13},n=[],p=0,d=a.length;p<d;++p){g=a[p];if(g.global||g.multiline)throw Error(""+g);n.push("(?:"+y(g)+")")}return RegExp(n.join("|"),l?"gi":"g")}function M(a){function m(a){switch(a.nodeType){case 1:if(e.test(a.className))break;for(var g=a.firstChild;g;g=g.nextSibling)m(g);g=a.nodeName;if("BR"===g||"LI"===g)h[s]="\n",t[s<<1]=y++,t[s++<<1|1]=a;break;case 3:case 4:g=a.nodeValue,g.length&&(g=p?g.replace(/\r\n?/g,"\n"):g.replace(/[\t\n\r ]+/g," "),h[s]=g,t[s<<1]=y,y+=g.length,
+t[s++<<1|1]=a)}}var e=/(?:^|\s)nocode(?:\s|$)/,h=[],y=0,t=[],s=0,l;a.currentStyle?l=a.currentStyle.whiteSpace:window.getComputedStyle&&(l=document.defaultView.getComputedStyle(a,q).getPropertyValue("white-space"));var p=l&&"pre"===l.substring(0,3);m(a);return{a:h.join("").replace(/\n$/,""),c:t}}function B(a,m,e,h){m&&(a={a:m,d:a},e(a),h.push.apply(h,a.e))}function x(a,m){function e(a){for(var l=a.d,p=[l,"pln"],d=0,g=a.a.match(y)||[],r={},n=0,z=g.length;n<z;++n){var f=g[n],b=r[f],o=void 0,c;if(typeof b===
+"string")c=!1;else{var i=h[f.charAt(0)];if(i)o=f.match(i[1]),b=i[0];else{for(c=0;c<t;++c)if(i=m[c],o=f.match(i[1])){b=i[0];break}o||(b="pln")}if((c=b.length>=5&&"lang-"===b.substring(0,5))&&!(o&&typeof o[1]==="string"))c=!1,b="src";c||(r[f]=b)}i=d;d+=f.length;if(c){c=o[1];var j=f.indexOf(c),k=j+c.length;o[2]&&(k=f.length-o[2].length,j=k-c.length);b=b.substring(5);B(l+i,f.substring(0,j),e,p);B(l+i+j,c,C(b,c),p);B(l+i+k,f.substring(k),e,p)}else p.push(l+i,b)}a.e=p}var h={},y;(function(){for(var e=a.concat(m),
+l=[],p={},d=0,g=e.length;d<g;++d){var r=e[d],n=r[3];if(n)for(var k=n.length;--k>=0;)h[n.charAt(k)]=r;r=r[1];n=""+r;p.hasOwnProperty(n)||(l.push(r),p[n]=q)}l.push(/[\S\s]/);y=L(l)})();var t=m.length;return e}function u(a){var m=[],e=[];a.tripleQuotedStrings?m.push(["str",/^(?:'''(?:[^'\\]|\\[\S\s]|''?(?=[^']))*(?:'''|$)|"""(?:[^"\\]|\\[\S\s]|""?(?=[^"]))*(?:"""|$)|'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$))/,q,"'\""]):a.multiLineStrings?m.push(["str",/^(?:'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$)|`(?:[^\\`]|\\[\S\s])*(?:`|$))/,
+q,"'\"`"]):m.push(["str",/^(?:'(?:[^\n\r'\\]|\\.)*(?:'|$)|"(?:[^\n\r"\\]|\\.)*(?:"|$))/,q,"\"'"]);a.verbatimStrings&&e.push(["str",/^@"(?:[^"]|"")*(?:"|$)/,q]);var h=a.hashComments;h&&(a.cStyleComments?(h>1?m.push(["com",/^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/,q,"#"]):m.push(["com",/^#(?:(?:define|elif|else|endif|error|ifdef|include|ifndef|line|pragma|undef|warning)\b|[^\n\r]*)/,q,"#"]),e.push(["str",/^<(?:(?:(?:\.\.\/)*|\/?)(?:[\w-]+(?:\/[\w-]+)+)?[\w-]+\.h|[a-z]\w*)>/,q])):m.push(["com",/^#[^\n\r]*/,
+q,"#"]));a.cStyleComments&&(e.push(["com",/^\/\/[^\n\r]*/,q]),e.push(["com",/^\/\*[\S\s]*?(?:\*\/|$)/,q]));a.regexLiterals&&e.push(["lang-regex",/^(?:^^\.?|[!+-]|!=|!==|#|%|%=|&|&&|&&=|&=|\(|\*|\*=|\+=|,|-=|->|\/|\/=|:|::|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|[?@[^]|\^=|\^\^|\^\^=|{|\||\|=|\|\||\|\|=|~|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\s*(\/(?=[^*/])(?:[^/[\\]|\\[\S\s]|\[(?:[^\\\]]|\\[\S\s])*(?:]|$))+\/)/]);(h=a.types)&&e.push(["typ",h]);a=(""+a.keywords).replace(/^ | $/g,
+"");a.length&&e.push(["kwd",RegExp("^(?:"+a.replace(/[\s,]+/g,"|")+")\\b"),q]);m.push(["pln",/^\s+/,q," \r\n\t\xa0"]);e.push(["lit",/^@[$_a-z][\w$@]*/i,q],["typ",/^(?:[@_]?[A-Z]+[a-z][\w$@]*|\w+_t\b)/,q],["pln",/^[$_a-z][\w$@]*/i,q],["lit",/^(?:0x[\da-f]+|(?:\d(?:_\d+)*\d*(?:\.\d*)?|\.\d\+)(?:e[+-]?\d+)?)[a-z]*/i,q,"0123456789"],["pln",/^\\[\S\s]?/,q],["pun",/^.[^\s\w"-$'./@\\`]*/,q]);return x(m,e)}function D(a,m){function e(a){switch(a.nodeType){case 1:if(k.test(a.className))break;if("BR"===a.nodeName)h(a),
+a.parentNode&&a.parentNode.removeChild(a);else for(a=a.firstChild;a;a=a.nextSibling)e(a);break;case 3:case 4:if(p){var b=a.nodeValue,d=b.match(t);if(d){var c=b.substring(0,d.index);a.nodeValue=c;(b=b.substring(d.index+d[0].length))&&a.parentNode.insertBefore(s.createTextNode(b),a.nextSibling);h(a);c||a.parentNode.removeChild(a)}}}}function h(a){function b(a,d){var e=d?a.cloneNode(!1):a,f=a.parentNode;if(f){var f=b(f,1),g=a.nextSibling;f.appendChild(e);for(var h=g;h;h=g)g=h.nextSibling,f.appendChild(h)}return e}
+for(;!a.nextSibling;)if(a=a.parentNode,!a)return;for(var a=b(a.nextSibling,0),e;(e=a.parentNode)&&e.nodeType===1;)a=e;d.push(a)}var k=/(?:^|\s)nocode(?:\s|$)/,t=/\r\n?|\n/,s=a.ownerDocument,l;a.currentStyle?l=a.currentStyle.whiteSpace:window.getComputedStyle&&(l=s.defaultView.getComputedStyle(a,q).getPropertyValue("white-space"));var p=l&&"pre"===l.substring(0,3);for(l=s.createElement("LI");a.firstChild;)l.appendChild(a.firstChild);for(var d=[l],g=0;g<d.length;++g)e(d[g]);m===(m|0)&&d[0].setAttribute("value",
+m);var r=s.createElement("OL");r.className="linenums";for(var n=Math.max(0,m-1|0)||0,g=0,z=d.length;g<z;++g)l=d[g],l.className="L"+(g+n)%10,l.firstChild||l.appendChild(s.createTextNode("\xa0")),r.appendChild(l);a.appendChild(r)}function k(a,m){for(var e=m.length;--e>=0;){var h=m[e];A.hasOwnProperty(h)?window.console&&console.warn("cannot override language handler %s",h):A[h]=a}}function C(a,m){if(!a||!A.hasOwnProperty(a))a=/^\s*</.test(m)?"default-markup":"default-code";return A[a]}function E(a){var m=
+a.g;try{var e=M(a.h),h=e.a;a.a=h;a.c=e.c;a.d=0;C(m,h)(a);var k=/\bMSIE\b/.test(navigator.userAgent),m=/\n/g,t=a.a,s=t.length,e=0,l=a.c,p=l.length,h=0,d=a.e,g=d.length,a=0;d[g]=s;var r,n;for(n=r=0;n<g;)d[n]!==d[n+2]?(d[r++]=d[n++],d[r++]=d[n++]):n+=2;g=r;for(n=r=0;n<g;){for(var z=d[n],f=d[n+1],b=n+2;b+2<=g&&d[b+1]===f;)b+=2;d[r++]=z;d[r++]=f;n=b}for(d.length=r;h<p;){var o=l[h+2]||s,c=d[a+2]||s,b=Math.min(o,c),i=l[h+1],j;if(i.nodeType!==1&&(j=t.substring(e,b))){k&&(j=j.replace(m,"\r"));i.nodeValue=
+j;var u=i.ownerDocument,v=u.createElement("SPAN");v.className=d[a+1];var x=i.parentNode;x.replaceChild(v,i);v.appendChild(i);e<o&&(l[h+1]=i=u.createTextNode(t.substring(b,o)),x.insertBefore(i,v.nextSibling))}e=b;e>=o&&(h+=2);e>=c&&(a+=2)}}catch(w){"console"in window&&console.log(w&&w.stack?w.stack:w)}}var v=["break,continue,do,else,for,if,return,while"],w=[[v,"auto,case,char,const,default,double,enum,extern,float,goto,int,long,register,short,signed,sizeof,static,struct,switch,typedef,union,unsigned,void,volatile"],
+"catch,class,delete,false,import,new,operator,private,protected,public,this,throw,true,try,typeof"],F=[w,"alignof,align_union,asm,axiom,bool,concept,concept_map,const_cast,constexpr,decltype,dynamic_cast,explicit,export,friend,inline,late_check,mutable,namespace,nullptr,reinterpret_cast,static_assert,static_cast,template,typeid,typename,using,virtual,where"],G=[w,"abstract,boolean,byte,extends,final,finally,implements,import,instanceof,null,native,package,strictfp,super,synchronized,throws,transient"],
+H=[G,"as,base,by,checked,decimal,delegate,descending,dynamic,event,fixed,foreach,from,group,implicit,in,interface,internal,into,is,lock,object,out,override,orderby,params,partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,var"],w=[w,"debugger,eval,export,function,get,null,set,undefined,var,with,Infinity,NaN"],I=[v,"and,as,assert,class,def,del,elif,except,exec,finally,from,global,import,in,is,lambda,nonlocal,not,or,pass,print,raise,try,with,yield,False,True,None"],
+J=[v,"alias,and,begin,case,class,def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,rescue,retry,self,super,then,true,undef,unless,until,when,yield,BEGIN,END"],v=[v,"case,done,elif,esac,eval,fi,function,in,local,set,then,until"],K=/^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\d*)/,N=/\S/,O=u({keywords:[F,H,w,"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END"+
+I,J,v],hashComments:!0,cStyleComments:!0,multiLineStrings:!0,regexLiterals:!0}),A={};k(O,["default-code"]);k(x([],[["pln",/^[^<?]+/],["dec",/^<!\w[^>]*(?:>|$)/],["com",/^<\!--[\S\s]*?(?:--\>|$)/],["lang-",/^<\?([\S\s]+?)(?:\?>|$)/],["lang-",/^<%([\S\s]+?)(?:%>|$)/],["pun",/^(?:<[%?]|[%?]>)/],["lang-",/^<xmp\b[^>]*>([\S\s]+?)<\/xmp\b[^>]*>/i],["lang-js",/^<script\b[^>]*>([\S\s]*?)(<\/script\b[^>]*>)/i],["lang-css",/^<style\b[^>]*>([\S\s]*?)(<\/style\b[^>]*>)/i],["lang-in.tag",/^(<\/?[a-z][^<>]*>)/i]]),
+["default-markup","htm","html","mxml","xhtml","xml","xsl"]);k(x([["pln",/^\s+/,q," \t\r\n"],["atv",/^(?:"[^"]*"?|'[^']*'?)/,q,"\"'"]],[["tag",/^^<\/?[a-z](?:[\w-.:]*\w)?|\/?>$/i],["atn",/^(?!style[\s=]|on)[a-z](?:[\w:-]*\w)?/i],["lang-uq.val",/^=\s*([^\s"'>]*(?:[^\s"'/>]|\/(?=\s)))/],["pun",/^[/<->]+/],["lang-js",/^on\w+\s*=\s*"([^"]+)"/i],["lang-js",/^on\w+\s*=\s*'([^']+)'/i],["lang-js",/^on\w+\s*=\s*([^\s"'>]+)/i],["lang-css",/^style\s*=\s*"([^"]+)"/i],["lang-css",/^style\s*=\s*'([^']+)'/i],["lang-css",
+/^style\s*=\s*([^\s"'>]+)/i]]),["in.tag"]);k(x([],[["atv",/^[\S\s]+/]]),["uq.val"]);k(u({keywords:F,hashComments:!0,cStyleComments:!0,types:K}),["c","cc","cpp","cxx","cyc","m"]);k(u({keywords:"null,true,false"}),["json"]);k(u({keywords:H,hashComments:!0,cStyleComments:!0,verbatimStrings:!0,types:K}),["cs"]);k(u({keywords:G,cStyleComments:!0}),["java"]);k(u({keywords:v,hashComments:!0,multiLineStrings:!0}),["bsh","csh","sh"]);k(u({keywords:I,hashComments:!0,multiLineStrings:!0,tripleQuotedStrings:!0}),
+["cv","py"]);k(u({keywords:"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",hashComments:!0,multiLineStrings:!0,regexLiterals:!0}),["perl","pl","pm"]);k(u({keywords:J,hashComments:!0,multiLineStrings:!0,regexLiterals:!0}),["rb"]);k(u({keywords:w,cStyleComments:!0,regexLiterals:!0}),["js"]);k(u({keywords:"all,and,by,catch,class,else,extends,false,finally,for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,true,try,unless,until,when,while,yes",
+hashComments:3,cStyleComments:!0,multilineStrings:!0,tripleQuotedStrings:!0,regexLiterals:!0}),["coffee"]);k(x([],[["str",/^[\S\s]+/]]),["regex"]);window.prettyPrintOne=function(a,m,e){var h=document.createElement("PRE");h.innerHTML=a;e&&D(h,e);E({g:m,i:e,h:h});return h.innerHTML};window.prettyPrint=function(a){function m(){for(var e=window.PR_SHOULD_USE_CONTINUATION?l.now()+250:Infinity;p<h.length&&l.now()<e;p++){var n=h[p],k=n.className;if(k.indexOf("prettyprint")>=0){var k=k.match(g),f,b;if(b=
+!k){b=n;for(var o=void 0,c=b.firstChild;c;c=c.nextSibling)var i=c.nodeType,o=i===1?o?b:c:i===3?N.test(c.nodeValue)?b:o:o;b=(f=o===b?void 0:o)&&"CODE"===f.tagName}b&&(k=f.className.match(g));k&&(k=k[1]);b=!1;for(o=n.parentNode;o;o=o.parentNode)if((o.tagName==="pre"||o.tagName==="code"||o.tagName==="xmp")&&o.className&&o.className.indexOf("prettyprint")>=0){b=!0;break}b||((b=(b=n.className.match(/\blinenums\b(?::(\d+))?/))?b[1]&&b[1].length?+b[1]:!0:!1)&&D(n,b),d={g:k,h:n,i:b},E(d))}}p<h.length?setTimeout(m,
+250):a&&a()}for(var e=[document.getElementsByTagName("pre"),document.getElementsByTagName("code"),document.getElementsByTagName("xmp")],h=[],k=0;k<e.length;++k)for(var t=0,s=e[k].length;t<s;++t)h.push(e[k][t]);var e=q,l=Date;l.now||(l={now:function(){return+new Date}});var p=0,d,g=/\blang(?:uage)?-([\w.]+)(?!\S)/;m()};window.PR={createSimpleLexer:x,registerLangHandler:k,sourceDecorator:u,PR_ATTRIB_NAME:"atn",PR_ATTRIB_VALUE:"atv",PR_COMMENT:"com",PR_DECLARATION:"dec",PR_KEYWORD:"kwd",PR_LITERAL:"lit",
+PR_NOCODE:"nocode",PR_PLAIN:"pln",PR_PUNCTUATION:"pun",PR_SOURCE:"src",PR_STRING:"str",PR_TAG:"tag",PR_TYPE:"typ"}})();
diff --git a/modules/facet/src/java/org/apache/lucene/facet/doc-files/userguide.html b/modules/facet/src/java/org/apache/lucene/facet/doc-files/userguide.html
new file mode 100755
index 0000000..8bc1790
--- /dev/null
+++ b/modules/facet/src/java/org/apache/lucene/facet/doc-files/userguide.html
@@ -0,0 +1,786 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<html>
+<title>Facet Userguide</title>
+
+<!-- load stylesheet + javascript in distribution mode -->
+<link rel="stylesheet" type="text/css" href="prettify.css">
+<script src="prettify.js" type="text/javascript"></script>
+
+<script language="javascript">
+	window.onload=function() {
+		prettyPrint();
+	}
+</script>
+
+<style>
+body {
+  margin-left: 20%;
+  width: 60%;
+  counter-reset: section;
+  text-align: left;
+}
+
+h1.title {
+  text-align: center;
+  margin-top: 30px;
+  font-size: 5em;
+  line-height: 150%;
+}
+
+h1.section {
+  margin-top: 50px;
+  font-size: 2.5em;
+  counter-reset: subsection;
+  border: 1px solid black;
+  background-color: #D8D8D8;
+  padding-left: 5px;
+}
+
+h2.subsection {
+  font-size: 2em;
+  border: 1px solid black;
+  background-color: #D8D8D8;
+  padding-left: 5px;
+}
+
+/* auto-generated heading numbers */
+h1.section:before {
+counter-increment: section;
+content: counter(section) ". ";
+}
+
+h2.subsection:before  {
+counter-increment: subsection;
+content: counter(section) "." counter(subsection) " ";
+}
+
+/* override from prettify.css - add shadow, padding etc. */
+pre.prettyprint {
+  margin-left: 2%;
+  width: 80%;
+  padding: 5px 3px 5px 3px;
+  /* shadow */
+  -moz-box-shadow: 5px 5px 2px #888;
+  -webkit-box-shadow: 5px 5px 2px #888;
+  box-shadow: 5px 5px 2px #888;
+}
+
+/* override from prettify.css - make keywords appear in bold */
+span.kwd {
+  font-weight: bold;
+}
+
+ol.toc a {
+  text-decoration: none;
+  color: blue;
+}
+
+li.toc_first {
+  // margin-top: 10px;
+  font-size: 16px;
+  color: blue;
+}
+
+li.toc_second {
+  font-size: 14px;
+  margin-left: 15px;
+  color: blue;
+}
+
+/* reset style from prettify.css, so that line numbers appear in each line */
+li.L0,li.L1,li.L2,li.L3,li.L5,li.L6,li.L7,li.L8 {
+  list-style-type:decimal
+}
+
+table.code_description td {
+  vertical-align: top;
+}
+
+</style>
+
+<body>
+<h1 class="title">
+	Apache Lucene<br>
+	Faceted Search<br>
+	User's Guide</h1>
+
+<div class="toc">
+<h1 class="toc">Table of Contents</h1>
+<ol class="toc">
+<li class="toc_first"><a href="#intro">Introduction</a></li>
+<li class="toc_first"><a href="#facet_features">Facet Features</a></li>
+<li class="toc_first"><a href="#facet_indexing">Indexing Categories Illustrated</a></li>
+<li class="toc_first"><a href="#facet_accumulation">Accumulating Facets Illustrated</a></li>
+<li class="toc_first"><a href="#indexed_facet_info">Indexed Facet Information</a></li>
+<li class="toc_first"><a href="#taxonomy_index">Taxonomy Index</a></li>
+<li class="toc_first"><a href="#facet_params">Facet Parameters</a></li>
+<li class="toc_first"><a href="#advanced">Advanced Faceted Examples</a></li>
+<li class="toc_first"><a href="#optimizations">Optimizations</a></li>
+<li class="toc_first"><a href="#concurrent_indexing_search">Concurrent Indexing and Search</a></li>
+</ol>
+
+<h1 class="section"><a name="intro">Introduction</a></h1>
+<p>
+A category is an aspect of indexed documents which can be used to classify the
+documents. For example, in a collection of books at an online bookstore, categories of
+a book can be its price, author, publication date, binding type, and so on.
+<p>
+In faceted search, in addition to the standard set of search results, we also get facet
+results, which are lists of subcategories for certain categories. For example, for the
+price facet, we get a list of relevant price ranges; for the author facet, we get a list of
+relevant authors; and so on. In most UIs, when users click one of these subcategories,
+the search is narrowed, or drilled down, and a new search limited to this subcategory
+(e.g., to a specific price range or author) is performed.
+<p>
+Note that faceted search is more than just the ordinary fielded search. In fielded
+search, users can add search keywords like price:10 or author:"Mark
+Twain" to the query to narrow the search, but this requires knowledge of which
+fields are available, and which values are worth trying. This is where faceted search
+comes in: it provides a list of useful subcategories, which ensures that the user only
+drills down into useful subcategories and never into a category for which there are no
+results. In essence, faceted search makes it easy to navigate through the search results.
+The list of subcategories provided for each facet is also useful to the user in itself,
+even when the user never drills down. This list allows the user to see at one glance
+some statistics on the search results, e.g., what price ranges and which authors are
+most relevant to the given query.
+<p>
+In recent years, faceted search has become a very common UI feature in search
+engines, especially in e-commerce websites. Faceted search makes it easy for
+untrained users to find the specific item they are interested in, whereas manually
+adding search keywords (as in the examples above) proved too cumbersome for
+ordinary users, and required too much guesswork, trial-and-error, or the reading of
+lengthy help pages.
+<p>
+See <a href="http://en.wikipedia.org/wiki/Faceted_search">http://en.wikipedia.org/wiki/Faceted_search</a> for more information on faceted
+search.
+
+<h1 class="section"><a name="facet_features">Facet Features</a></h1>
+First and main faceted search capability that comes to mind is counting, but in fact
+faceted search is more than facet counting. We now briefly discuss the available
+faceted search features.
+
+<h2 class="subsection">Facet Counting</h2>
+<p>
+Which of the available subcategories of a facet should a UI display? A query in a
+book store might yield books by a hundred different authors, but normally we'd want
+do display only, say, ten of those.
+<p>
+Most available faceted search implementations use counts to determine the
+importance of each subcategory. These implementations go over all search results for
+the given query, and count how many results are in each subcategory. Finally, the
+subcategories with the most results can be displayed. So the user sees the price ranges,
+authors, and so on, for which there are most results. Often, the count is displayed next
+to the subcategory name, in parentheses, telling the user how many results he can
+expect to see if he drills down into this subcategory.
+<p>
+The main API for obtaining facet counting is <code>CountFacetRequest</code>, as in the
+following code snippet:
+<pre class="prettyprint lang-java">
+new CountFacetRequest(new CategoryPath("author"), 10));
+</pre>
+A detailed code example using count facet requests is shown below - see
+<a href="#facet_accumulation">Accumulating Facets</a>.
+
+<h2 class="subsection"><a name="facet_association">Facet Associations</a></h2>
+<p>
+So far we've discussed categories as binary features, where a document either belongs
+to a category, or not.
+<p>
+While counts are useful in most situations, they are sometimes not sufficiently
+informative for the user, with respect to deciding which subcategory is more
+important to display.
+<p>
+For this, the facets package allows to associate a value with a category. The search
+time interpretation of the associated value is application dependent. For example, a
+possible interpretation is as a <i>match level</i> (e.g., confidence level). This value can
+then be used so that a document that is very weakly associated with a certain category
+will only contribute little to this category's aggregated weight.
+
+<h2 class="subsection"><a name="multiple_requests">Multiple Facet Requests</a></h2>
+<p>
+A single faceted accumulation is capable of servicing multiple facet requests.
+Programmatic, this is quite simple - wrap all the facet requests of interest into the
+facet-search-parameters which are passed to a facets accumulator/collector (more on
+these objects below). The results would be comprised of as many facet results as there
+were facet requests.
+<p>
+However there is a delicate <b>limitation</b>: all facets maintained in the same location in
+the index are required to be treated the same. See the section on <a href="#indexing_params">Indexing Parameters</a>
+for an explanation on maintaining certain facets at certain locations.
+
+<h2 class="subsection"><a name="facet_labels">Facet Labels at Search Time</a></h2>
+<p>
+Facets results always contain the facet (internal) ID and (accumulated) value. Some of
+the results also contain the facet label, AKA the category name. We mention this here
+since computing the label is a time consuming task, and hence applications can
+specify with a facet request to return top 1000 facets but to compute the label only for
+the top 10 facets. In order to compute labels for more of the facet results it is not
+required to perform accumulation again.
+<p>
+See <code>FacetRequest.getNumResults()</code>, <code>FacetRequest.getNumLabel()</code> and
+<code>FacetResultNode.getLabel(TaxonomyReader)</code>.
+
+<h1 class="section"><a name="facet_indexing">Indexing Categories Illustrated</a></h1>
+<p>
+In order to find facets at search time they must first be added to the index at indexing
+time. Recall that Lucene documents are made of fields for textual search. The addition
+of categories is performed by an appropriate <code>DocumentBuilder</code> - or
+<code>CategoryDocumentBuilder</code> in our case.
+<p>
+Indexing therefore usually goes like this:
+<ul>
+<li>For each input document:
+<ul>
+<li>Create a fresh (empty) Lucene Document</li>
+<li>Parse input text and add appropriate text search fields</li>
+<li><b>Gather all input categories associated with the document and create
+a CategoryDocumentBuilder with the list of categories</b></li>
+<li><b>Build the document - this actually adds the categories to the
+Lucene document.</b></li>
+<li>Add the document to the index</li>
+</ul></li>
+</ul>
+Following is a code snippet for indexing categories. The complete example can be
+found in package <code>org.apache.lucene.facet.example.simple.SimpleIndexer</code>.
+<pre class="prettyprint lang-java linenums">
+IndexWriter writer = ...
+TaxonomyWriter taxo = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE);
+...
+Document doc = new Document();
+doc.add(new Field("title", titleText, Store.YES, Index.ANALYZED));
+...
+List&lt;CategoryPath&gt; categories = new ArrayList&lt;CategoryPath&gt;();
+categories.add(new CategoryPath("author", "Mark Twain"));
+categories.add(new CategoryPath("year", "2010"));
+...
+DocumentBuilder categoryDocBuilder = new CategoryDocumentBuilder(taxo);
+categoryDocBuilder.setCategoryPaths(categories);
+categoryDocBuilder.build(doc);
+writer.addDocument(doc);
+</pre>
+<p>
+We now explain the steps above, following the code line numbers:
+<table class="code_description">
+<tr>
+	<td>(4)</td>
+	<td>Document contains not only text search fields but also facet search
+information.</td>
+</tr>
+<tr>
+	<td>(7)</td>
+	<td>Prepare a container for document categories.</td>
+</tr>
+<tr>
+	<td>(8)</td>
+	<td>Categories that should be added to the document are accumulated in the
+categories list.</td>
+</tr>
+<tr>
+	<td>(11)</td>
+	<td>A <code>CategoryDocumentBuilder</code> is created, set with the appropriate list
+of categories, and invoked to build - that is, to populate the document
+with categories. It is in this step that the taxonomy is updated to contain the
+newly added categories (if not already there) - see more on this in the
+section about the <a href="#taxonomy_index">Taxonomy Index</a> below. This line could be made more
+compact: one can create a single <code>CategoryDocumentBuilder cBuilder</code> and reuse it like this:
+<pre class="prettyprint lang-java linenums">
+DocumentBuilder cBuilder = new CategoryDocumentBuilder(taxo);
+cBuilder.setCategoryPaths(categories).build(doc);
+</pre>
+	</td>
+</tr>
+<tr>
+	<td>(14)</td>
+	<td>Add the document to the index. As a result, category info is saved also in
+the regular search index, for supporting facet aggregation at search time
+(e.g. facet counting) as well as facet drill-down. For more information on
+indexed facet information see below the section <a href="#indexed_facet_info">Indexed Facet Information</a>.</td>
+</tr>
+</table>
+
+<h1 class="section"><a name="facet_accumulation">Accumulating Facets Illustrated</a></h1>
+<p>
+Facets accumulation reflects a set of documents over some facet requests:
+<ul>
+<li><code>Document set</code> - a subset of the index documents, usually documents
+matching a user query.</li>
+<li><code>Facet requests</code> - facet accumulation specification, e.g. count a certain facet
+<i>dimension</i>.</li>
+</ul>
+<p>
+<code>FacetRequest</code> is a basic component in faceted search - it describes the facet
+information need. Every facet <b>request</b> is made of at least two fields:
+<ul>
+<li><code>CategoryPath</code> - root category of the facet request. The categories that
+are returned as a result of the request will all be descendants of this root</li>
+<li><code>Number of Results</code> - number of sub-categories to return (at most).</li>
+</ul>
+<p>
+There are other parameters to a facet request, such as -how many facet results to
+label-, -how <b>deep</b> to go from the request root when serving the facet request- and
+more - see the API Javadocs for <code>FacetRequest</code> and its subclasses for more
+information on these parameters. For labels in particular, see the section <a href="#facet_labels">Facet Labels
+at Search Time</a>.
+<p>
+<code>FacetRequest</code> in an abstract class, open for extensions, and users may add their
+own requests. The most often used request is <code>CountFacetRequest</code> - used for
+counting facets.
+<p>
+Facets accumulation is - not surprisingly - driven by a <code>FacetsAccumulator</code>. The
+most used one is <code>StandardFacetsAccumulator</code>, however there are also accumulators
+that support sampling - to be used in huge collections, and there's an adaptive facets
+accumulator which applies sampling conditionally on the statistics of the data. While
+facets accumulators are very extendible and powerful, they might be too
+overwhelming for beginners. For this reason, the code offers a higher level interface
+for facets accumulating: the <code>FacetsCollector</code>. It extends <code>Collector</code>, and as such
+can be passed to the search() method of Lucene's <code>IndexSearcher</code>. In case the
+application also needs to collect documents (in addition to accumulating/collecting
+facets), it can wrap multiple collectors with <code>MultiCollector</code>. Most code samples
+below use <code>FacetsCollector</code> due to its simple interface. It is quite likely that
+<code>FacetsCollector</code> should suffice the needs of most applications, therefore we
+recommend to start with it, and only when needing more flexibility turn to directly
+use facets accumulators.
+<p>
+Following is a code snippet from the example code - the complete example can be
+found under <code>org.apache.lucene.facet.example.simple.Searcher</code>:
+<pre class="prettyprint lang-java linenums">
+IndexReader indexReader = IndexReader.open(indexDir);
+Searcher searcher = new IndexSearcher(indexReader);
+TaxonomyReader taxo = new DirectoryTaxonomyReader(taxoDir);
+...
+Query q = new TermQuery(new Term(SimpleUtils.TEXT, "white"));
+TopScoreDocCollector tdc = TopScoreDocCollector.create(10, true);
+...
+FacetSearchParams facetSearchParams = new FacetSearchParams();
+facetSearchParams.addFacetRequest(new CountFacetRequest(
+    new CategoryPath("author"), 10));
+...
+FacetsCollector facetsCollector = new FacetsCollector(facetSearchParams, indexReader, taxo);
+searcher.search(q, MultiCollector.wrap(topDocsCollector, facetsCollector));
+List&lt;FacetResult&gt; res = facetsCollector.getFacetResults();
+</pre>
+<p>
+We now explain the steps above, following the code line numbers:
+<table class="code_description">
+<tr>
+	<td>(1)</td>
+	<td>Index reader and Searcher are initialized as usual.</td>
+</tr>
+<tr>
+	<td>(3)</td>
+	<td>A taxonomy reader is opened - it provides access to the facet information
+which was stored by the Taxonomy Writer at indexing time.</td>
+</tr>
+<tr>
+	<td>(5)</td>
+	<td>Regular text query is created to find the documents matching user need, and
+a collector for collecting the top matching documents is created.</td>
+</tr>
+<tr>
+	<td>(8)</td>
+	<td>Facet-search-params is a container for facet requests.</td>
+</tr>
+<tr>
+	<td>(10)</td>
+	<td>A single facet-request - namely a count facet request - is created and added
+to the facet search params. The request should return top 10 Author
+subcategory counts.</td>
+</tr>
+<tr>
+	<td>(12)</td>
+	<td>Facets-Collector is the simplest interface for facets accumulation (counting
+in this example).</td>
+</tr>
+<tr>
+	<td>(13)</td>
+	<td>Lucene search takes both collectors - facets-collector and top-doccollector,
+both wrapped by a multi-collector. This way, a single search
+operation finds both top documents and top facets. Note however that facets
+aggregation takes place not only over the top documents, but rather over all
+documents matching the query.</td>
+</tr>
+<tr>
+	<td>(14)</td>
+	<td>Once search completes, facet-results can be obtained from the facetscollector.</td>
+</tr>
+</table>
+
+<p>
+Returned facet results are organized in a list, conveniently ordered the same as the
+facet-requests in the facet-search-params. Each result however contains the request
+for which it was created.</li>
+<p>
+Here is the (recursive) structure of the facet result:
+<ul>
+<li><b>Facet Result</b>
+<ul>
+<li><b>Facet Request</b> - the request for which this result was obtained.</li>
+<li><b>Valid Descendants</b> - how many valid descendants were encountered
+over the set of matching documents (some of which might have been
+filtered out because e.g. only top 10 results were requested).</li>
+<li><b>Root Result Node</b> - root facet result for the request
+<ul>
+<li><b>Ordinal</b> - unique internal ID of the facet</li>
+<li><b>Label</b> - full label of the facet (possibly null)</li>
+<li><b>Value</b> - facet value, e.g. count</li>
+<li><b>Sub-results-nodes</b> - child result nodes (possibly null)</li>
+</ul></li>
+</ul></li>
+</ul>
+<p>
+Note that not always there would be sub result nodes - this depends on the
+requested result mode:
+<ul>
+<li><b>PER_NODE_IN_TREE</b> - a tree, and so there may be sub results.</li>
+<li><b>GLOBAL_FLAT</b> - here the results tree would be rather flat, with only (at
+most) leaves below the root result node.</li>
+</ul>
+
+<h1 class="section"><a name="indexed_facet_info">Indexed Facet Information</a></h1>
+<p>
+When indexing a document to which categories were added, information on these
+categories is added to the search index, in two locations:
+<ul>
+<li><i>Category Tokens</i> are added to the document for each category attached to
+that document. These categories can be used at search time for drill-down.</li>
+<li>A special <i>Category List Token</i> is added to each document containing
+information on all the categories that were added to this document. This can
+be used at search time for facet accumulation, e.g. facet counting.</li>
+</ul>
+<p>
+When a category is added to the index (that is, when a document containing a
+category is indexed), all its parent categories are added as well. For example, indexing
+a document with the category <code>&lt;<span style="color: blue">"author"</span>, 
+<span style="color: blue">"American-</span>, <span style="color: blue">"Mark Twain"</span>&gt;</code> results in
+creating three tokens: <code>"/author"</code>, <code>"/author/American"</code>, and
+<code>"/author/American/Mark Twain"</code> (the character <code>'/'</code> here is just a human
+readable separator - there's no such element in the actual index). This allows drilling down
+and counting any category in the taxonomy, and not just leaf nodes, enabling a
+UI application to show either how many books have authors, or how many books
+have American authors, or how many books have Mark Twain as their (American)
+author.
+<p>
+Similarly, Drill-down capabilities are this way possible also for node categories.
+<p>
+In order to keep the counting list compact, it is built using category ordinal - an
+ordinal is an integer number attached to a category when it is added for the first time
+into the taxonomy.
+<p>
+For ways to further alter facet index see the section below on <a href="#indexing_params">Facet Indexing
+Parameters</a>.
+
+<h1 class="section"><a name="taxonomy_index">Taxonomy Index</a></h1>
+<p>
+The taxonomy is an auxiliary data-structure maintained side-by-side with the regular
+index to support faceted search operations. It contains information about all the
+categories that ever existed in any document in the index. Its API is open and allows
+simple usage, or more advanced for the interested users.
+<p>
+When a category is added to a document, a corresponding node is added to the
+taxonomy (unless already there). In fact, sometimes more than one node is added -
+each parent category is added as well, so that the taxonomy is maintained as a Tree,
+with a virtual root.
+<p>
+So, for the above example, adding the category the category <code>&lt;<span style="color: blue">"author"</span>, 
+<span style="color: blue">"American-</span>, <span style="color: blue">"Mark Twain"</span>&gt;</code> 
+actually added three nodes: one for <code>"/author"</code>, one for <code>"/author/American"</code> and one for 
+<code>"/author/American/Mark Twain"</code>.
+<p>
+An integer number - called ordinal is attached to each category the first time the
+category is added to the taxonomy. This allows for a compact representation of
+category list tokens in the index, for facets accumulation.
+<p>
+One interesting fact about the taxonomy index is worth knowing: once a category
+is added to the taxonomy, it is never removed, even if all related documents are
+removed. This differs from a regular index, where if all documents containing a
+certain term are removed, and their segments are merged, the term will also be
+removed. This might cause a performance issue: large taxonomy means large ordinal
+numbers for categories, and hence large categories values arrays would be maintained
+during accumulation. It is probably not a real problem for most applications, but be
+aware of this. If, for example, an application at a certain point in time removes an
+index entirely in order to recreate it, or, if it removed all the documents from the index
+in order to re-populate it, it also makes sense in this opportunity to remove the
+taxonomy index and create a new, fresh one, without the unused categories.
+
+<h1 class="section"><a name="facet_params">Facet Parameters</a></h1>
+<p>
+Facet parameters control how categories and facets are indexed and searched. Apart
+from specifying facet requests within facet search parameters, under default settings it
+is not required to provide any parameters, as there are ready to use working defaults
+for everything.
+<p>
+However many aspects are configurable and can be modified by providing altered
+facet parameters for either search or indexing.
+
+<h2 class="subsection"><a name="indexing_params">Facet Indexing Parameters</a></h2>
+<p>
+Facet Indexing Parameters are consulted with during indexing. Among several
+parameters it defines, the following two are likely to interest many applications:
+<ul>
+<li><b>Category list definitions</b> - in the index, facets are maintained in two
+forms: category-tokens (for drill-down) and category-list-tokens (for
+accumulation). This parameter allows to specify, for each category, the
+Lucene term used for maintaining the category-list-tokens for that category.
+The default implementation in <code>DefaultFacetIndexingParams</code> maintains
+this information for all categories under the same special dedicated term.
+One case where it is needed to maintain two categories in separate category
+lists, is when it is known that at search time it would be required to use
+different types of accumulation logic for each, but at the same accumulation
+call.</li>
+<li><b>Partition size</b> - category lists can be maintained in a partitioned way. If,
+for example, the partition size is set to 1000, a distinct sub-term is used for
+maintaining each 1000 categories, e.g. term1 for categories 0 to 999, term2
+for categories 1000 to 1999, etc. The default implementation in
+<code>DefaultFacetIndexingParams</code> maintains category lists in a single
+partition, hence it defines the partition size as <code>Integer.MAX_VALUE</code>. The
+importance of this parameter is on allowing to handle very large
+taxonomies without exhausting RAM resources. This is because at facet
+accumulation time, facet values arrays are maintained in the size of the
+partition. With a single partition, the size of these arrays is as the size of the
+taxonomy, which might be OK for most applications. Limited partition
+sizes allow to perform the accumulation with less RAM, but with some
+runtime overhead, as the matching documents are processed for each of the
+partitions.</li>
+</ul>
+<p>
+See the API Javadocs of <code>FacetIndexingParams</code> for additional configuration
+capabilities which were not discussed here.
+
+<h2 class="subsection"><a name="search_params">Facet Search Parameters</a></h2>
+<p>
+Facet Search Parameters, consulted at search time (during facets accumulation) are
+rather plain, providing the following:
+<ul>
+<li><b>Facet indexing parameters</b> - which were in effect at indexing time -
+allowing facets accumulation to understand how facets are maintained in
+the index.</li>
+<li><b>Container of facet requests</b> - the requests which should be accumulated.</li>
+</ul>
+
+<h2 class="subsection"><a name="category_lists_multiple_dimensions">Category Lists, Multiple Dimensions</a></h2>
+<p>
+Category list parameters which are accessible through the facet indexing parameters
+provide the information about:
+<ul>
+<li>Lucene Term under which category information is maintained in the index.</li>
+<li>Encoding (and decoding) used for writing and reading the categories
+information in the index.</li>
+</ul>
+<p>
+For cases when certain categories should be maintained in different location than
+others, use <code>PerDimensionIndexingParams</code>, which returns a different
+<code>CategoryListParams</code> object for each <i>dimension</i>. This is a good opportunity to
+explain about dimensions. This is just a notion: the top element - or first element - in
+a category path is denoted as the dimension of that category. Indeed, the dimension
+stands out as a top important part of the category path, such as <code>"Location"</code> for the
+category <code>"Location/Europe/France/Paris"</code>.
+
+<h1 class="section"><a name="advanced">Advanced Faceted Examples</a></h1>
+<p>
+We now provide examples for more advanced facet indexing and search, such as
+drilling-down on facet values and multiple category lists.
+
+<h2 class="subsection"><a name="drill_down">Drill-Down with Regular Facets</a></h2>
+<p>
+Drill-down allows users to focus on part of the results. Assume a commercial sport
+equipment site where a user is searching for a tennis racquet. The user issues the
+query <i>tennis racquet</i> and as result is shown a page with 10 tennis racquets, by
+various providers, of various types and prices. In addition, the site UI shows to the
+user a break down of all available racquets by price and make. The user now decides
+to focus on racquets made by <i>Head</i>, and will now be shown a new page, with 10
+Head racquets, and new break down of the results into racquet types and prices.
+Additionally, the application can choose to display a new breakdown, by racquet
+weights. This step of moving from results (and facet statistics) of the entire (or larger)
+data set into a portion of it by specifying a certain category, is what we call <i>Drilldown</i>.
+We now show the required code lines for implementing such a drill-down.
+<pre class="prettyprint lang-java linenums">
+Query baseQuery = queryParser.parse("tennis racquet");
+Query q2 = DrillDown.query(baseQuery, new CategoryPath("make", "head"), 10));
+</pre>
+<p>
+In line 1 the original user query is created and then used to obtain information on
+all tennis racquets.
+<p>
+In line 2, a specific category from within the facet results was selected by the user,
+and is hence used for creating the drill-down query.
+<p>
+Please refer to <code>SimpleSearcher.searchWithDrillDown()</code> for a more detailed
+code example performing drill-down.
+
+<h2 class="subsection"><a name="multi-category_list">Multiple Category Lists</a></h2>
+<p>
+The default is to maintain all categories information in a single list. While this will
+suit most applications, in some situations an application may wish to use multiple
+category lists, for example, when the distribution of some category values is different
+than that of other categories and calls for using a different encoding, more efficient
+for the specific distribution. Another example is when most facets are rarely used
+while some facets are used very heavily, so an application may opt to maintain the
+latter in memory - and in order to keep memory footprint lower it is useful to
+maintain only those heavily used facets in a separate category list.
+<p>
+First we define indexing parameters with multiple category lists:
+<pre class="prettyprint lang-java linenums">
+PerDimensionIndexingParams iParams = new PerDimensionIndexingParams();
+iParams.addCategoryListParams(new CategoryPath("Author"), 
+    new CategoryListParams(new Term("$RarelyUsed", "Facets")));
+iParams.addCategoryListParams(new CategoryPath("Language"),
+    new CategoryListParams(new Term("$HeavilyUsed", "Ones")));
+</pre>
+<p>
+This will cause the Language categories to be maintained in one category list, and
+Author facets to be maintained in a another category list. Note that any other category,
+if encountered, will still be maintained in the default category list.
+<p>
+These non-default indexing parameters should now be used both at indexing and
+search time. As depicted below, at indexing time this is done when creating the
+category document builder, while at search time this is done when creating the search
+parameters. Other than that the faceted search code is unmodified.
+<pre class="prettyprint lang-java linenums">
+DocumentBuilder categoryDocBuilder = new CategoryDocumentBuilder(taxo, iParams);
+...
+FacetSearchParams facetSearchParams = new FacetSearchParams(iParams);
+</pre>
+<p>
+A complete simple example can be found in package <code>org.apache.lucene.facet.example.multiCL</code> 
+under the example code.
+
+<h1 class="section"><a name="optimizations">Optimizations</a></h1>
+<p>
+Faceted search through a large collection of documents with large numbers of facets
+altogether and/or large numbers of facets per document is challenging performance
+wise, either in CPU, RAM, or both. A few ready to use optimizations exist to tackle
+these challenges.
+
+<h2 class="subsection"><a name="sampling">Sampling</a></h2>
+<p>
+Facet sampling allows to accumulate facets over a sample of the matching
+documents set. In many cases, once top facets are found over the sample set, exact
+accumulations are computed for those facets only, this time over the entire matching
+document set.
+<p>
+Two kinds of sampling exist: complete support and wrapping support. The
+complete support is through <code>SamplingAccumulator</code> and is tied to an extension of the
+<code>StandardFacetsAccumulator</code> and has the benefit of automatically applying other
+optimizations, such as <a href="#complements">Complements</a>. The wrapping support is through
+<code>SamplingWrapper</code> and can wrap any accumulator, and as such, provides more
+freedom for applications.
+
+<h2 class="subsection"><a name="complements">Complements</a></h2>
+<p>
+When accumulating facets over a very large matching documents set, possibly
+almost as large as the entire collection, it is possible to speed up accumulation by
+looking at the complement set of documents, and then obtaining the actual results by
+subtracting from the total results. It should be noted that this is available only for
+count requests, and that the first invocation that involves this optimization might take
+longer because the total counts have to be computed.
+<p>
+This optimization is applied automatically by <code>StandardFacetsAccumulator</code>.
+
+<h2 class="subsection"><a name="partitions">Partitions</a></h2>
+<p>
+Partitions are also discussed in the section about <a href="#indexing_params">Facet Indexing parameters.</a>
+<p>
+Facets are internally accumulated by first accumulating all facets and later on
+extracting the results for the requested facets. During this process, accumulation
+arrays are maintained in the size of the taxonomy. For a very large taxonomy, with
+multiple simultaneous faceted search operations, this might lead to excessive memory
+footprint. Partitioning the faceted information allows to relax the memory usage, by
+maintaining the category lists in several partitions, and by processing one partition at
+a time. This is automatically done by <code>StandardFacetsAccumulator</code>. However the
+default partition size is <code>Integer.MAX_VALUE</code>, practically setting to a single partition,
+i.e. no partitions at all.
+<p>
+Decision to override this behavior and use multiple partitions must be taken at
+indexing time. Once the index is created and already contains category lists it is too
+late to modify this.
+<p>
+See <code>FacetIndexingParams.getPartitionSize()</code> for API to alter this default
+behavior.
+
+<h1 class="section"><a name="concurrent_indexing_search">Concurrent Indexing and Search</a></h1>
+<p>
+Sometimes, indexing is done once, and when the index is fully prepared, searching
+starts. However, in most real applications indexing is <i>incremental</i> (new data comes in
+once in a while, and needs to be indexed), and indexing often needs to happen while
+searching is continuing at full steam.
+<p>
+Luckily, Lucene supports multiprocessing - one process writing to an index while
+another is reading from it. One of the key insights behind how Lucene allows multiprocessing 
+is <i>Point In Time</i> semantics. The idea is that when an <code>IndexReader</code> is opened, 
+it gets a view of the index at the <i>point in time</i> it was opened. If an <code>IndexWriter</code> 
+in a different process or thread modifies the index, the reader does not know about it until a new 
+<code>IndexReader</code> is opened (or the reopen() method of an existing <code>IndexReader</code> is called).
+<p>
+In faceted search, we complicate things somewhat by adding a second index - the
+taxonomy index. The taxonomy API also follows point-in-time semantics, but this is
+not quite enough. Some attention must be paid by the user to keep those two indexes
+consistently in sync:
+<p>
+The main index refers to category numbers defined in the taxonomy index.
+Therefore, it is important that we open the <code>TaxonomyReader</code> <i>after</i> opening the
+IndexReader. Moreover, every time an IndexReader is reopen()ed, the
+TaxonomyReader needs to be refresh()'ed as well.
+<p>
+But there is one extra caution: whenever the application deems it has written
+enough information worthy a commit, it must <b>first</b> call commit() for the
+<code>TaxonomyWriter</code> and only <b>after</b> that call commit() for the <code>IndexWriter</code>. 
+Closing the indices should also be done in this order - <b>first</b> close the taxonomy, and only <b>after</b>
+that close the index.
+<p>
+To summarize, if you're writing a faceted search application where searching and
+indexing happens concurrently, please follow these guidelines (in addition to the usual
+guidelines on how to use Lucene correctly in the concurrent case):
+<ul>
+<li>In the indexing process:
+<ol>
+<li>Before a writer commit()s the IndexWriter, it must commit() the
+TaxonomyWriter. Nothing should be added to the index between these
+two commit()s.</li>
+<li>Similarly, before a writer close()s the IndexWriter, it must close() the
+TaxonomyWriter.</li>
+</ol></li>
+<li>In the searching process:
+<ol>
+<li>Open the IndexReader first, and then the TaxonomyReader.</li>
+<li>After a reopen() on the IndexReader, refresh() the TaxonomyReader.
+No search should be performed on the new IndexReader until refresh()
+has finished.</li>
+</ol></li>
+</ul>
+<p>
+Note that the above discussion assumes that the underlying file-system on which
+the index and the taxonomy are stored respects ordering: if index A is written before
+index B, then any reader finding a modified index B will also see a modified index A.
+<p>
+<b>Note:</b> <code>TaxonomyReader</code>'s refresh() is simpler than <code>IndexReader</code>'s reopen(). 
+While the latter keeps both the old and new reader open, the former keeps only the new reader. The reason 
+is that a new <code>IndexReader</code> might have modified old information (old documents deleted, for 
+example) so a thread which is in the middle of a search needs to continue using the old information. With 
+<code>TaxonomyReader</code>, however, we are guaranteed that existing categories are never deleted or modified - 
+the only thing that can happen is that new categories are added. Since search threads do not care if new categories 
+are added in the middle of a search, there is no reason to keep around the old object, and the new one suffices.
+<br><b>However</b>, if the taxonomy index was recreated since the <code>TaxonomyReader</code> was opened or
+refreshed, this assumption (that categories are forevr) no longer holds, and <code>refresh()</code> will 
+throw an <code>InconsistentTaxonomyException</code>, guiding the application to open 
+a new <code>TaxonomyReader</code> for up-to-date taxonomy data. (Old one can
+be closed as soon as it is no more used.)
+
+
+</body>
+</html>
diff --git a/modules/facet/src/java/org/apache/lucene/facet/package.html b/modules/facet/src/java/org/apache/lucene/facet/package.html
index ad84e3d..938b6c6 100644
--- a/modules/facet/src/java/org/apache/lucene/facet/package.html
+++ b/modules/facet/src/java/org/apache/lucene/facet/package.html
@@ -3,6 +3,7 @@
     <title>Faceted Indexing and Search</title>
   </head>
   <body>
-    Provides faceted indexing and search capabilities. The <a href="../../../../userguide.html">userguide</a> is recommended for a start.  
+    <!-- NOTE: if you update the userguide link, also update the one in src/java/overview.html -->
+    Provides faceted indexing and search capabilities. The <a href="doc-files/userguide.html">userguide</a> is recommended for a start.  
   </body>
-</html>
\ No newline at end of file
+</html>
diff --git a/modules/facet/src/java/overview.html b/modules/facet/src/java/overview.html
index c338be6..ab505e3 100644
--- a/modules/facet/src/java/overview.html
+++ b/modules/facet/src/java/overview.html
@@ -21,6 +21,7 @@
     </title>
   </head>
   <body>
-  Provides faceted indexing and search capabilities (checkout the <a href="userguide.html">userguide</a>).
+  <!-- NOTE: if you update the userguide link, also update the one in o.a.l.facet/package.html -->
+  Provides faceted indexing and search capabilities (checkout the <a href="org/apache/lucene/facet/doc-files/userguide.html">userguide</a>).
   </body>
-</html>
\ No newline at end of file
+</html>

