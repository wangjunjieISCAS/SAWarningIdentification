GitDiffStart: be3cca1e444005621daed6bd3e501eea6f422396 | Mon Jun 16 22:23:11 2014 +0000
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary.java
index 6f0d31d..0651e4d 100644
--- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary.java
+++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary.java
@@ -447,7 +447,7 @@ public class Dictionary {
           throw new UnsupportedOperationException("Too many patterns, please report this to dev@lucene.apache.org");          
         }
         seenPatterns.put(regex, patternIndex);
-        CharacterRunAutomaton pattern = new CharacterRunAutomaton(new RegExp(regex, RegExp.NONE).toLightAutomaton());
+        CharacterRunAutomaton pattern = new CharacterRunAutomaton(new RegExp(regex, RegExp.NONE).toAutomaton());
         patterns.add(pattern);
       }
       
diff --git a/lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestDuelingAnalyzers.java b/lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestDuelingAnalyzers.java
index 5e82b54..8d97f33 100644
--- a/lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestDuelingAnalyzers.java
+++ b/lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestDuelingAnalyzers.java
@@ -31,9 +31,9 @@ import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.analysis.tokenattributes.OffsetAttribute;
 import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
 import org.apache.lucene.util.TestUtil;
-import org.apache.lucene.util.automaton.BasicOperations;
+import org.apache.lucene.util.automaton.Operations;
 import org.apache.lucene.util.automaton.CharacterRunAutomaton;
-import org.apache.lucene.util.automaton.LightAutomaton;
+import org.apache.lucene.util.automaton.Automaton;
 
 /**
  * Compares MockTokenizer (which is simple with no optimizations) with equivalent 
@@ -48,7 +48,7 @@ public class TestDuelingAnalyzers extends BaseTokenStreamTestCase {
   @Override
   public void setUp() throws Exception {
     super.setUp();
-    LightAutomaton single = new LightAutomaton();
+    Automaton single = new Automaton();
     int initial = single.createState();
     int accept = single.createState();
     single.setAccept(accept, true);
@@ -59,7 +59,7 @@ public class TestDuelingAnalyzers extends BaseTokenStreamTestCase {
         single.addTransition(initial, accept, i);
       }
     }
-    LightAutomaton repeat = BasicOperations.repeatLight(single);
+    Automaton repeat = Operations.repeat(single);
     jvmLetter = new CharacterRunAutomaton(repeat);
   }
   
diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.java b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.java
index 7d115ed..806939d 100644
--- a/lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.java
+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.java
@@ -46,7 +46,7 @@ import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.RamUsageEstimator;
 import org.apache.lucene.util.automaton.CompiledAutomaton;
-import org.apache.lucene.util.automaton.LightAutomaton;
+import org.apache.lucene.util.automaton.Automaton;
 import org.apache.lucene.util.automaton.RunAutomaton;
 import org.apache.lucene.util.automaton.Transition;
 
@@ -946,8 +946,8 @@ public final class DirectPostingsFormat extends PostingsFormat {
         states[0] = new State();
         states[0].changeOrd = terms.length;
         states[0].state = runAutomaton.getInitialState();
-        states[0].transitionCount = compiledAutomaton.lightAutomaton.getNumTransitions(states[0].state);
-        compiledAutomaton.lightAutomaton.initTransition(states[0].state, states[0].transition);
+        states[0].transitionCount = compiledAutomaton.automaton.getNumTransitions(states[0].state);
+        compiledAutomaton.automaton.initTransition(states[0].state, states[0].transition);
         states[0].transitionUpto = -1;
         states[0].transitionMax = -1;
 
@@ -969,7 +969,7 @@ public final class DirectPostingsFormat extends PostingsFormat {
               while (label > states[i].transitionMax) {
                 states[i].transitionUpto++;
                 assert states[i].transitionUpto < states[i].transitionCount;
-                compiledAutomaton.lightAutomaton.getNextTransition(states[i].transition);
+                compiledAutomaton.automaton.getNextTransition(states[i].transition);
                 states[i].transitionMin = states[i].transition.min;
                 states[i].transitionMax = states[i].transition.max;
                 assert states[i].transitionMin >= 0;
@@ -1028,8 +1028,8 @@ public final class DirectPostingsFormat extends PostingsFormat {
                     stateUpto++;
                     states[stateUpto].changeOrd = skips[skipOffset + skipUpto++];
                     states[stateUpto].state = nextState;
-                    states[stateUpto].transitionCount = compiledAutomaton.lightAutomaton.getNumTransitions(nextState);
-                    compiledAutomaton.lightAutomaton.initTransition(states[stateUpto].state, states[stateUpto].transition);
+                    states[stateUpto].transitionCount = compiledAutomaton.automaton.getNumTransitions(nextState);
+                    compiledAutomaton.automaton.initTransition(states[stateUpto].state, states[stateUpto].transition);
                     states[stateUpto].transitionUpto = -1;
                     states[stateUpto].transitionMax = -1;
                     //System.out.println("  push " + states[stateUpto].transitions.length + " trans");
@@ -1202,7 +1202,7 @@ public final class DirectPostingsFormat extends PostingsFormat {
               }
               continue nextTerm;
             }
-            compiledAutomaton.lightAutomaton.getNextTransition(state.transition);
+            compiledAutomaton.automaton.getNextTransition(state.transition);
             assert state.transitionUpto < state.transitionCount: " state.transitionUpto=" + state.transitionUpto + " vs " + state.transitionCount;
             state.transitionMin = state.transition.min;
             state.transitionMax = state.transition.max;
@@ -1303,8 +1303,8 @@ public final class DirectPostingsFormat extends PostingsFormat {
             stateUpto++;
             states[stateUpto].state = nextState;
             states[stateUpto].changeOrd = skips[skipOffset + skipUpto++];
-            states[stateUpto].transitionCount = compiledAutomaton.lightAutomaton.getNumTransitions(nextState);
-            compiledAutomaton.lightAutomaton.initTransition(nextState, states[stateUpto].transition);
+            states[stateUpto].transitionCount = compiledAutomaton.automaton.getNumTransitions(nextState);
+            compiledAutomaton.automaton.initTransition(nextState, states[stateUpto].transition);
             states[stateUpto].transitionUpto = -1;
             states[stateUpto].transitionMax = -1;
             
diff --git a/lucene/core/src/java/org/apache/lucene/analysis/TokenStreamToAutomaton.java b/lucene/core/src/java/org/apache/lucene/analysis/TokenStreamToAutomaton.java
index 5e3edd5..aedaa43 100644
--- a/lucene/core/src/java/org/apache/lucene/analysis/TokenStreamToAutomaton.java
+++ b/lucene/core/src/java/org/apache/lucene/analysis/TokenStreamToAutomaton.java
@@ -25,7 +25,7 @@ import org.apache.lucene.analysis.tokenattributes.PositionLengthAttribute;
 import org.apache.lucene.analysis.tokenattributes.TermToBytesRefAttribute;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.RollingBuffer;
-import org.apache.lucene.util.automaton.LightAutomaton;
+import org.apache.lucene.util.automaton.Automaton;
 
 // TODO: maybe also toFST?  then we can translate atts into FST outputs/weights
 
@@ -96,8 +96,8 @@ public class TokenStreamToAutomaton {
    *  TokenStream}, and creates the corresponding
    *  automaton where arcs are bytes (or Unicode code points 
    *  if unicodeArcs = true) from each term. */
-  public LightAutomaton toAutomaton(TokenStream in) throws IOException {
-    final LightAutomaton.Builder builder = new LightAutomaton.Builder();
+  public Automaton toAutomaton(TokenStream in) throws IOException {
+    final Automaton.Builder builder = new Automaton.Builder();
     builder.createState();
 
     final TermToBytesRefAttribute termBytesAtt = in.addAttribute(TermToBytesRefAttribute.class);
@@ -228,7 +228,7 @@ public class TokenStreamToAutomaton {
   }
   */
 
-  private static void addHoles(LightAutomaton.Builder builder, RollingBuffer<Position> positions, int pos) {
+  private static void addHoles(Automaton.Builder builder, RollingBuffer<Position> positions, int pos) {
     Position posData = positions.get(pos);
     Position prevPosData = positions.get(pos-1);
 
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum.java b/lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum.java
index 43c43f8..a7a569b 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum.java
@@ -359,7 +359,7 @@ final class IntersectTermsEnum extends TermsEnum {
             continue nextTerm;
           }
           currentFrame.transitionIndex++;
-          compiledAutomaton.lightAutomaton.getNextTransition(currentFrame.transition);
+          compiledAutomaton.automaton.getNextTransition(currentFrame.transition);
           currentFrame.curTransitionMax = currentFrame.transition.max;
           //if (DEBUG) System.out.println("      next trans=" + currentFrame.transitions[currentFrame.transitionIndex]);
         }
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnumFrame.java b/lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnumFrame.java
index eb1780e..dcdc78c 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnumFrame.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnumFrame.java
@@ -24,7 +24,7 @@ import org.apache.lucene.index.FieldInfo.IndexOptions;
 import org.apache.lucene.store.ByteArrayDataInput;
 import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.automaton.LightAutomaton;
+import org.apache.lucene.util.automaton.Automaton;
 import org.apache.lucene.util.automaton.Transition;
 import org.apache.lucene.util.fst.FST;
 
@@ -122,10 +122,10 @@ final class IntersectTermsEnumFrame {
   public void setState(int state) {
     this.state = state;
     transitionIndex = 0;
-    transitionCount = ite.compiledAutomaton.lightAutomaton.getNumTransitions(state);
+    transitionCount = ite.compiledAutomaton.automaton.getNumTransitions(state);
     if (transitionCount != 0) {
-      ite.compiledAutomaton.lightAutomaton.initTransition(state, transition);
-      ite.compiledAutomaton.lightAutomaton.getNextTransition(transition);
+      ite.compiledAutomaton.automaton.initTransition(state, transition);
+      ite.compiledAutomaton.automaton.getNextTransition(transition);
       curTransitionMax = transition.max;
     } else {
       curTransitionMax = -1;
diff --git a/lucene/core/src/java/org/apache/lucene/index/AutomatonTermsEnum.java b/lucene/core/src/java/org/apache/lucene/index/AutomatonTermsEnum.java
index 15914c5..dcae44f 100644
--- a/lucene/core/src/java/org/apache/lucene/index/AutomatonTermsEnum.java
+++ b/lucene/core/src/java/org/apache/lucene/index/AutomatonTermsEnum.java
@@ -24,7 +24,7 @@ import org.apache.lucene.util.IntsRef;
 import org.apache.lucene.util.StringHelper;
 import org.apache.lucene.util.automaton.ByteRunAutomaton;
 import org.apache.lucene.util.automaton.CompiledAutomaton;
-import org.apache.lucene.util.automaton.LightAutomaton;
+import org.apache.lucene.util.automaton.Automaton;
 import org.apache.lucene.util.automaton.Transition;
 
 /**
@@ -52,7 +52,7 @@ class AutomatonTermsEnum extends FilteredTermsEnum {
   // true if the automaton accepts a finite language
   private final boolean finite;
   // array of sorted transitions for each state, indexed by state number
-  private final LightAutomaton lightAutomaton;
+  private final Automaton automaton;
   // for path tracking: each long records gen when we last
   // visited the state; we use gens to avoid having to clear
   private final long[] visited;
@@ -80,7 +80,7 @@ class AutomatonTermsEnum extends FilteredTermsEnum {
     this.runAutomaton = compiled.runAutomaton;
     assert this.runAutomaton != null;
     this.commonSuffixRef = compiled.commonSuffixRef;
-    this.lightAutomaton = compiled.lightAutomaton;
+    this.automaton = compiled.automaton;
 
     // used for path tracking, where each bit is a numbered state.
     visited = new long[runAutomaton.getSize()];
@@ -143,10 +143,10 @@ class AutomatonTermsEnum extends FilteredTermsEnum {
       state = runAutomaton.step(state, seekBytesRef.bytes[i] & 0xff);
       assert state >= 0: "state=" + state;
     }
-    final int numTransitions = lightAutomaton.getNumTransitions(state);
-    lightAutomaton.initTransition(state, transition);
+    final int numTransitions = automaton.getNumTransitions(state);
+    automaton.initTransition(state, transition);
     for (int i = 0; i < numTransitions; i++) {
-      lightAutomaton.getNextTransition(transition);
+      automaton.getNextTransition(transition);
       if (transition.min <= (seekBytesRef.bytes[position] & 0xff) && 
           (seekBytesRef.bytes[position] & 0xff) <= transition.max) {
         maxInterval = transition.max;
@@ -257,12 +257,12 @@ class AutomatonTermsEnum extends FilteredTermsEnum {
     seekBytesRef.length = position;
     visited[state] = curGen;
 
-    final int numTransitions = lightAutomaton.getNumTransitions(state);
-    lightAutomaton.initTransition(state, transition);
+    final int numTransitions = automaton.getNumTransitions(state);
+    automaton.initTransition(state, transition);
     // find the minimal path (lexicographic order) that is >= c
     
     for (int i = 0; i < numTransitions; i++) {
-      lightAutomaton.getNextTransition(transition);
+      automaton.getNextTransition(transition);
       if (transition.max >= c) {
         int nextChar = Math.max(c, transition.min);
         // append either the next sequential char, or the minimum transition
@@ -281,8 +281,8 @@ class AutomatonTermsEnum extends FilteredTermsEnum {
            * so the below is ok, if it is not an accept state,
            * then there MUST be at least one transition.
            */
-          lightAutomaton.initTransition(state, transition);
-          lightAutomaton.getNextTransition(transition);
+          automaton.initTransition(state, transition);
+          automaton.getNextTransition(transition);
           state = transition.dest;
           
           // append the minimum transition
diff --git a/lucene/core/src/java/org/apache/lucene/search/AutomatonQuery.java b/lucene/core/src/java/org/apache/lucene/search/AutomatonQuery.java
index 6f2b3b5..080810d 100644
--- a/lucene/core/src/java/org/apache/lucene/search/AutomatonQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/AutomatonQuery.java
@@ -25,7 +25,7 @@ import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.util.AttributeSource;
 import org.apache.lucene.util.ToStringUtils;
 import org.apache.lucene.util.automaton.CompiledAutomaton;
-import org.apache.lucene.util.automaton.LightAutomaton;
+import org.apache.lucene.util.automaton.Automaton;
 
 /**
  * A {@link Query} that will match terms against a finite-state machine.
@@ -47,7 +47,7 @@ import org.apache.lucene.util.automaton.LightAutomaton;
  */
 public class AutomatonQuery extends MultiTermQuery {
   /** the automaton to match index terms against */
-  protected final LightAutomaton lightAutomaton;
+  protected final Automaton automaton;
   protected final CompiledAutomaton compiled;
   /** term containing the field, and possibly some pattern structure */
   protected final Term term;
@@ -60,10 +60,10 @@ public class AutomatonQuery extends MultiTermQuery {
    * @param automaton Automaton to run, terms that are accepted are considered a
    *        match.
    */
-  public AutomatonQuery(final Term term, LightAutomaton automaton) {
+  public AutomatonQuery(final Term term, Automaton automaton) {
     super(term.field());
     this.term = term;
-    this.lightAutomaton = automaton;
+    this.automaton = automaton;
     this.compiled = new CompiledAutomaton(automaton);
   }
 
@@ -110,14 +110,14 @@ public class AutomatonQuery extends MultiTermQuery {
     buffer.append(getClass().getSimpleName());
     buffer.append(" {");
     buffer.append('\n');
-    buffer.append(lightAutomaton.toString());
+    buffer.append(automaton.toString());
     buffer.append("}");
     buffer.append(ToStringUtils.boost(getBoost()));
     return buffer.toString();
   }
   
   /** Returns the light automaton used to create this query */
-  public LightAutomaton getLightAutomaton() {
-    return lightAutomaton;
+  public Automaton getAutomaton() {
+    return automaton;
   }
 }
diff --git a/lucene/core/src/java/org/apache/lucene/search/FuzzyTermsEnum.java b/lucene/core/src/java/org/apache/lucene/search/FuzzyTermsEnum.java
index 0dc2c27..30e7e1a 100644
--- a/lucene/core/src/java/org/apache/lucene/search/FuzzyTermsEnum.java
+++ b/lucene/core/src/java/org/apache/lucene/search/FuzzyTermsEnum.java
@@ -38,7 +38,7 @@ import org.apache.lucene.util.UnicodeUtil;
 import org.apache.lucene.util.automaton.ByteRunAutomaton;
 import org.apache.lucene.util.automaton.CompiledAutomaton;
 import org.apache.lucene.util.automaton.LevenshteinAutomata;
-import org.apache.lucene.util.automaton.LightAutomaton;
+import org.apache.lucene.util.automaton.Automaton;
 
 /** Subclass of TermsEnum for enumerating all terms that are similar
  * to the specified filter term.
@@ -170,7 +170,7 @@ public class FuzzyTermsEnum extends TermsEnum {
 
       String prefix = UnicodeUtil.newString(termText, 0, realPrefixLength);
       for (int i = runAutomata.size(); i <= maxDistance; i++) {
-        LightAutomaton a = builder.toAutomaton(i, prefix);
+        Automaton a = builder.toAutomaton(i, prefix);
         //System.out.println("compute automaton n=" + i);
         runAutomata.add(new CompiledAutomaton(a, true, false));
       }
diff --git a/lucene/core/src/java/org/apache/lucene/search/RegexpQuery.java b/lucene/core/src/java/org/apache/lucene/search/RegexpQuery.java
index adf7c87..2aba28c 100644
--- a/lucene/core/src/java/org/apache/lucene/search/RegexpQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/RegexpQuery.java
@@ -2,8 +2,8 @@ package org.apache.lucene.search;
 
 import org.apache.lucene.index.Term;
 import org.apache.lucene.util.ToStringUtils;
-import org.apache.lucene.util.automaton.LightAutomaton;
-import org.apache.lucene.util.automaton.LightAutomatonProvider;
+import org.apache.lucene.util.automaton.Automaton;
+import org.apache.lucene.util.automaton.AutomatonProvider;
 import org.apache.lucene.util.automaton.RegExp;
 
 /*
@@ -49,9 +49,9 @@ public class RegexpQuery extends AutomatonQuery {
   /**
    * A provider that provides no named automata
    */
-  private static LightAutomatonProvider defaultProvider = new LightAutomatonProvider() {
+  private static AutomatonProvider defaultProvider = new AutomatonProvider() {
     @Override
-    public LightAutomaton getAutomaton(String name) {
+    public Automaton getAutomaton(String name) {
       return null;
     }
   };
@@ -85,8 +85,8 @@ public class RegexpQuery extends AutomatonQuery {
    * @param flags optional RegExp features from {@link RegExp}
    * @param provider custom AutomatonProvider for named automata
    */
-  public RegexpQuery(Term term, int flags, LightAutomatonProvider provider) {
-    super(term, new RegExp(term.text(), flags).toLightAutomaton(provider));
+  public RegexpQuery(Term term, int flags, AutomatonProvider provider) {
+    super(term, new RegExp(term.text(), flags).toAutomaton(provider));
   }
   
   /** Prints a user-readable version of this query. */
diff --git a/lucene/core/src/java/org/apache/lucene/search/WildcardQuery.java b/lucene/core/src/java/org/apache/lucene/search/WildcardQuery.java
index 388f525..91b473e 100644
--- a/lucene/core/src/java/org/apache/lucene/search/WildcardQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/WildcardQuery.java
@@ -22,9 +22,9 @@ import java.util.List;
 
 import org.apache.lucene.index.Term;
 import org.apache.lucene.util.ToStringUtils;
-import org.apache.lucene.util.automaton.BasicAutomata;
-import org.apache.lucene.util.automaton.BasicOperations;
-import org.apache.lucene.util.automaton.LightAutomaton;
+import org.apache.lucene.util.automaton.Automata;
+import org.apache.lucene.util.automaton.Operations;
+import org.apache.lucene.util.automaton.Automaton;
 
 /** Implements the wildcard search query. Supported wildcards are <code>*</code>, which
  * matches any character sequence (including the empty one), and <code>?</code>,
@@ -62,8 +62,8 @@ public class WildcardQuery extends AutomatonQuery {
    * @lucene.internal
    */
   @SuppressWarnings("fallthrough")
-  public static LightAutomaton toAutomaton(Term wildcardquery) {
-    List<LightAutomaton> automata = new ArrayList<>();
+  public static Automaton toAutomaton(Term wildcardquery) {
+    List<Automaton> automata = new ArrayList<>();
     
     String wildcardText = wildcardquery.text();
     
@@ -72,26 +72,26 @@ public class WildcardQuery extends AutomatonQuery {
       int length = Character.charCount(c);
       switch(c) {
         case WILDCARD_STRING: 
-          automata.add(BasicAutomata.makeAnyStringLight());
+          automata.add(Automata.makeAnyString());
           break;
         case WILDCARD_CHAR:
-          automata.add(BasicAutomata.makeAnyCharLight());
+          automata.add(Automata.makeAnyChar());
           break;
         case WILDCARD_ESCAPE:
           // add the next codepoint instead, if it exists
           if (i + length < wildcardText.length()) {
             final int nextChar = wildcardText.codePointAt(i + length);
             length += Character.charCount(nextChar);
-            automata.add(BasicAutomata.makeCharLight(nextChar));
+            automata.add(Automata.makeChar(nextChar));
             break;
           } // else fallthru, lenient parsing with a trailing \
         default:
-          automata.add(BasicAutomata.makeCharLight(c));
+          automata.add(Automata.makeChar(c));
       }
       i += length;
     }
     
-    return BasicOperations.concatenateLight(automata);
+    return Operations.concatenate(automata);
   }
   
   /**
diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/Automata.java b/lucene/core/src/java/org/apache/lucene/util/automaton/Automata.java
new file mode 100644
index 0000000..09bf266
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/util/automaton/Automata.java
@@ -0,0 +1,328 @@
+/*
+ * dk.brics.automaton
+ * 
+ * Copyright (c) 2001-2009 Anders Moeller
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package org.apache.lucene.util.automaton;
+
+import java.util.*;
+
+import org.apache.lucene.util.BytesRef;
+
+/**
+ * Construction of basic automata.
+ * 
+ * @lucene.experimental
+ */
+final public class Automata {
+  
+  private Automata() {}
+  
+  /**
+   * Returns a new (deterministic) automaton with the empty language.
+   */
+  public static Automaton makeEmpty() {
+    Automaton a = new Automaton();
+    a.finishState();
+    return a;
+  }
+  
+  /**
+   * Returns a new (deterministic) automaton that accepts only the empty string.
+   */
+  public static Automaton makeEmptyString() {
+    Automaton a = new Automaton();
+    a.createState();
+    a.setAccept(0, true);
+    return a;
+  }
+  
+  /**
+   * Returns a new (deterministic) automaton that accepts all strings.
+   */
+  public static Automaton makeAnyString() {
+    Automaton a = new Automaton();
+    int s = a.createState();
+    a.setAccept(s, true);
+    a.addTransition(s, s, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);
+    a.finishState();
+    return a;
+  }
+  
+  /**
+   * Returns a new (deterministic) automaton that accepts any single codepoint.
+   */
+  public static Automaton makeAnyChar() {
+    return makeCharRange(Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);
+  }
+  
+  public static int appendAnyChar(Automaton a, int state) {
+    int newState = a.createState();
+    a.addTransition(state, newState, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);
+    return newState;
+  }
+
+  /**
+   * Returns a new (deterministic) automaton that accepts a single codepoint of
+   * the given value.
+   */
+  public static Automaton makeChar(int c) {
+    return makeCharRange(c, c);
+  }
+  
+  public static int appendChar(Automaton a, int state, int c) {
+    int newState = a.createState();
+    a.addTransition(state, newState, c, c);
+    return newState;
+  }
+
+  /**
+   * Returns a new (deterministic) automaton that accepts a single codepoint whose
+   * value is in the given interval (including both end points).
+   */
+  public static Automaton makeCharRange(int min, int max) {
+    if (min > max) {
+      return makeEmpty();
+    }
+    Automaton a = new Automaton();
+    int s1 = a.createState();
+    int s2 = a.createState();
+    a.setAccept(s2, true);
+    a.addTransition(s1, s2, min, max);
+    a.finishState();
+    return a;
+  }
+  
+  /**
+   * Constructs sub-automaton corresponding to decimal numbers of length
+   * x.substring(n).length().
+   */
+  private static int anyOfRightLength(Automaton.Builder builder, String x, int n) {
+    int s = builder.createState();
+    if (x.length() == n) {
+      builder.setAccept(s, true);
+    } else {
+      builder.addTransition(s, anyOfRightLength(builder, x, n + 1), '0', '9');
+    }
+    return s;
+  }
+  
+  /**
+   * Constructs sub-automaton corresponding to decimal numbers of value at least
+   * x.substring(n) and length x.substring(n).length().
+   */
+  private static int atLeast(Automaton.Builder builder, String x, int n, Collection<Integer> initials,
+      boolean zeros) {
+    int s = builder.createState();
+    if (x.length() == n) {
+      builder.setAccept(s, true);
+    } else {
+      if (zeros) {
+        initials.add(s);
+      }
+      char c = x.charAt(n);
+      builder.addTransition(s, atLeast(builder, x, n + 1, initials, zeros && c == '0'), c);
+      if (c < '9') {
+        builder.addTransition(s, anyOfRightLength(builder, x, n + 1), (char) (c + 1), '9');
+      }
+    }
+    return s;
+  }
+  
+  /**
+   * Constructs sub-automaton corresponding to decimal numbers of value at most
+   * x.substring(n) and length x.substring(n).length().
+   */
+  private static int atMost(Automaton.Builder builder, String x, int n) {
+    int s = builder.createState();
+    if (x.length() == n) {
+      builder.setAccept(s, true);
+    } else {
+      char c = x.charAt(n);
+      builder.addTransition(s, atMost(builder, x, (char) n + 1), c);
+      if (c > '0') {
+        builder.addTransition(s, anyOfRightLength(builder, x, n + 1), '0', (char) (c - 1));
+      }
+    }
+    return s;
+  }
+  
+  /**
+   * Constructs sub-automaton corresponding to decimal numbers of value between
+   * x.substring(n) and y.substring(n) and of length x.substring(n).length()
+   * (which must be equal to y.substring(n).length()).
+   */
+  private static int between(Automaton.Builder builder,
+      String x, String y, int n,
+      Collection<Integer> initials, boolean zeros) {
+    int s = builder.createState();
+    if (x.length() == n) {
+      builder.setAccept(s, true);
+    } else {
+      if (zeros) {
+        initials.add(s);
+      }
+      char cx = x.charAt(n);
+      char cy = y.charAt(n);
+      if (cx == cy) {
+        builder.addTransition(s, between(builder, x, y, n + 1, initials, zeros && cx == '0'), cx);
+      } else { // cx<cy
+        builder.addTransition(s, atLeast(builder, x, n + 1, initials, zeros && cx == '0'), cx);
+        builder.addTransition(s, atMost(builder, y, n + 1), cy);
+        if (cx + 1 < cy) {
+          builder.addTransition(s, anyOfRightLength(builder, x, n+1), (char) (cx + 1), (char) (cy - 1));
+        }
+      }
+    }
+
+    return s;
+  }
+
+  /**
+   * Returns a new automaton that accepts strings representing decimal
+   * non-negative integers in the given interval.
+   * 
+   * @param min minimal value of interval
+   * @param max maximal value of interval (both end points are included in the
+   *          interval)
+   * @param digits if >0, use fixed number of digits (strings must be prefixed
+   *          by 0's to obtain the right length) - otherwise, the number of
+   *          digits is not fixed
+   * @exception IllegalArgumentException if min>max or if numbers in the
+   *              interval cannot be expressed with the given fixed number of
+   *              digits
+   */
+  public static Automaton makeInterval(int min, int max, int digits)
+      throws IllegalArgumentException {
+    String x = Integer.toString(min);
+    String y = Integer.toString(max);
+    if (min > max || (digits > 0 && y.length() > digits)) {
+      throw new IllegalArgumentException();
+    }
+    int d;
+    if (digits > 0) d = digits;
+    else d = y.length();
+    StringBuilder bx = new StringBuilder();
+    for (int i = x.length(); i < d; i++) {
+      bx.append('0');
+    }
+    bx.append(x);
+    x = bx.toString();
+    StringBuilder by = new StringBuilder();
+    for (int i = y.length(); i < d; i++) {
+      by.append('0');
+    }
+    by.append(y);
+    y = by.toString();
+
+    Automaton.Builder builder = new Automaton.Builder();
+
+    if (digits <= 0) {
+      // Reserve the "real" initial state:
+      builder.createState();
+    }
+
+    Collection<Integer> initials = new ArrayList<>();
+
+    between(builder, x, y, 0, initials, digits <= 0);
+
+    Automaton a1 = builder.finish();
+
+    if (digits <= 0) {
+      a1.addTransition(0, 0, '0');
+      for (int p : initials) {
+        a1.addEpsilon(0, p);
+      }
+      a1.finishState();
+    }
+
+    return a1;
+  }
+  
+  /**
+   * Returns a new (deterministic) automaton that accepts the single given
+   * string.
+   */
+  public static Automaton makeString(String s) {
+    Automaton a = new Automaton();
+    int lastState = a.createState();
+    for (int i = 0, cp = 0; i < s.length(); i += Character.charCount(cp)) {
+      int state = a.createState();
+      cp = s.codePointAt(i);
+      a.addTransition(lastState, state, cp, cp);
+      lastState = state;
+    }
+
+    a.setAccept(lastState, true);
+    a.finishState();
+
+    assert a.isDeterministic();
+    assert Operations.hasDeadStates(a) == false;
+
+    return a;
+  }
+  
+  /**
+   * Returns a new (deterministic) automaton that accepts the single given
+   * string from the specified unicode code points.
+   */
+  public static Automaton makeString(int[] word, int offset, int length) {
+    Automaton a = new Automaton();
+    a.createState();
+    int s = 0;
+    for (int i = offset; i < offset+length; i++) {
+      int s2 = a.createState();
+      a.addTransition(s, s2, word[i]);
+      s = s2;
+    }
+    a.setAccept(s, true);
+    a.finishState();
+
+    return a;
+  }
+
+  /**
+   * Returns a new (deterministic and minimal) automaton that accepts the union
+   * of the given collection of {@link BytesRef}s representing UTF-8 encoded
+   * strings.
+   * 
+   * @param utf8Strings
+   *          The input strings, UTF-8 encoded. The collection must be in sorted
+   *          order.
+   * 
+   * @return An {@link Automaton} accepting all input strings. The resulting
+   *         automaton is codepoint based (full unicode codepoints on
+   *         transitions).
+   */
+  public static Automaton makeStringUnion(Collection<BytesRef> utf8Strings) {
+    if (utf8Strings.isEmpty()) {
+      return makeEmpty();
+    } else {
+      return DaciukMihovAutomatonBuilder.build(utf8Strings);
+    }
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/Automaton.java b/lucene/core/src/java/org/apache/lucene/util/automaton/Automaton.java
new file mode 100644
index 0000000..997185b
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/util/automaton/Automaton.java
@@ -0,0 +1,808 @@
+package org.apache.lucene.util.automaton;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//import java.io.IOException;
+//import java.io.PrintWriter;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Set;
+
+import org.apache.lucene.util.ArrayUtil;
+import org.apache.lucene.util.InPlaceMergeSorter;
+import org.apache.lucene.util.Sorter;
+
+
+// TODO
+//   - could use packed int arrays instead
+//   - could encode dest w/ delta from to?
+
+/** Uses only int[]s to represent the automaton, but requires that all
+ *  transitions for each state are added at once.  If this is too restrictive,
+ *  use {@link #Builder} instead.  State 0 is always the
+ *  initial state.
+ *
+ * @lucene.experimental */
+
+public class Automaton {
+  private int nextState;
+
+  /** Where we next write to in int[] transitions; this
+   *  increments by 3 for each added transition because we
+   *  pack min, max, dest in sequence. */
+  private int nextTransition;
+
+  /** Current state we are adding transitions to; the caller
+   *  must add all transitions for this state before moving
+   *  onto another state. */
+  private int curState = -1;
+
+  /** Index in the transitions array, where this states
+   *  leaving transitions are stored, or -1 if this state
+   *  has not added any transitions yet, followed by number
+   *  of transitions. */
+  private int[] states = new int[4];
+
+  /** Holds toState, min, max for each transition: */
+  private int[] transitions = new int[6];
+
+  private final Set<Integer> finalStates = new HashSet<Integer>();
+
+  /** True if no state has two transitions leaving with the same label. */
+  private boolean deterministic = true;
+
+  public int createState() {
+    growStates();
+    int state = nextState/2;
+    states[nextState] = -1;
+    nextState += 2;
+    return state;
+  }
+
+  /** Mark this state as an accept state. */
+  public void setAccept(int state, boolean isAccept) {
+    if (state >= getNumStates()) {
+      throw new IllegalArgumentException("state=" + state + " is out of bounds (numStates=" + getNumStates() + ")");
+    }
+    if (isAccept) {
+      finalStates.add(state);
+    } else {
+      finalStates.remove(state);
+    }
+  }
+
+  /** Sugar, but object-heavy; it's better to iterate instead. */
+  public Transition[][] getSortedTransitions() {
+    int numStates = getNumStates();
+    Transition[][] transitions = new Transition[numStates][];
+    for(int s=0;s<numStates;s++) {
+      int numTransitions = getNumTransitions(s);
+      transitions[s] = new Transition[numTransitions];
+      for(int t=0;t<numTransitions;t++) {
+        Transition transition = new Transition();
+        getTransition(s, t, transition);
+        transitions[s][t] = transition;
+      }
+    }
+
+    return transitions;
+  }
+
+  public Set<Integer> getAcceptStates() {
+    return finalStates;
+  }
+
+  /** Returns true if this state is an accept state. */
+  public boolean isAccept(int state) {
+    return finalStates.contains(state);
+  }
+
+  public void addTransition(int source, int dest, int label) {
+    addTransition(source, dest, label, label);
+  }
+
+  public void addTransition(int source, int dest, int min, int max) {
+    assert nextTransition%3 == 0;
+
+    if (source >= nextState/2) {
+      throw new IllegalArgumentException("source=" + source + " is out of bounds (maxState is " + (nextState/2-1) + ")");
+    }
+    if (dest >= nextState/2) {
+      throw new IllegalArgumentException("dest=" + dest + " is out of bounds (max state is " + (nextState/2-1) + ")");
+    }
+
+    //System.out.println("  addTransition nextTransition=" + nextTransition + " source=" + source + " dest=" + dest + " min=" + min + " max=" + max);
+    growTransitions();
+    if (curState != source) {
+      //System.out.println("    newstate");
+      if (curState != -1) {
+        finishCurrentState();
+      }
+
+      // Move to next source:
+      curState = source;
+      if (states[2*curState] != -1) {
+        throw new IllegalStateException("from state (" + source + ") already had transitions added");
+      }
+      assert states[2*curState+1] == 0;
+      states[2*curState] = nextTransition;
+    }
+
+    transitions[nextTransition++] = dest;
+    transitions[nextTransition++] = min;
+    transitions[nextTransition++] = max;
+
+    // Increment transition count for this state
+    states[2*curState+1]++;
+  }
+
+  public void addEpsilon(int source, int dest) {
+    Transition t = new Transition();
+    int count = initTransition(dest, t);
+    for(int i=0;i<count;i++) {
+      getNextTransition(t);
+      addTransition(source, t.dest, t.min, t.max);
+    }
+    if (isAccept(dest)) {
+      setAccept(source, true);
+    }
+  }
+
+  /** Copies over all states/transitions from other.  The states numbers
+   *  are sequentially assigned (appended). */
+  public void copy(Automaton other) {
+
+    int offset = getNumStates();
+    /*
+    int otherNumStates = other.getNumStates();
+    for(int s=0;s<otherNumStates;s++) {
+      createState();
+      setAccept(offset+s, other.isAccept(s));
+    }
+    Transition t = new Transition();
+    for(int s=0;s<otherNumStates;s++) {
+      int count = other.initTransition(s, t);
+      for(int i=0;i<count;i++) {
+        other.getNextTransition(t);
+        addTransition(offset + s, offset + t.dest, t.min, t.max);
+      }
+    }
+    */
+
+    // Bulk copy and then fixup the state pointers:
+    int stateOffset = getNumStates();
+    states = ArrayUtil.grow(states, nextState + other.nextState);
+    System.arraycopy(other.states, 0, states, nextState, other.nextState);
+    for(int i=0;i<other.nextState;i += 2) {
+      if (states[nextState+i] != -1) {
+        states[nextState+i] += nextTransition;
+      }
+      int state = i/2;
+    }
+    nextState += other.nextState;
+
+    for(int s : other.getAcceptStates()) {
+      setAccept(stateOffset+s, true);
+    }
+
+    // Bulk copy and then fixup dest for each transition:
+    transitions = ArrayUtil.grow(transitions, nextTransition + other.nextTransition);
+    System.arraycopy(other.transitions, 0, transitions, nextTransition, other.nextTransition);
+    for(int i=0;i<other.nextTransition;i += 3) {
+      transitions[nextTransition+i] += stateOffset;
+    }
+    nextTransition += other.nextTransition;
+
+    if (other.deterministic == false) {
+      deterministic = false;
+    }
+  }
+
+  /** Freezes the last state, reducing and sorting its transitions. */
+  private void finishCurrentState() {
+    int numTransitions = states[2*curState+1];
+    assert numTransitions > 0;
+
+    //System.out.println("finish curState=" + curState + " numTransitions=" + numTransitions);
+    int offset = states[2*curState];
+    int start = offset/3;
+    destMinMaxSorter.sort(start, start+numTransitions);
+
+    /*
+    for(int i=0;i<numTransitions;i++) {
+      System.out.println("  " + i + ": dest=" + transitions[offset+3*i] + " (accept?=" + isAccept(transitions[offset+3*i]) + ") min=" + transitions[offset+3*i+1] + " max=" + transitions[offset+3*i+2]);
+    }
+    */
+
+    // Reduce any "adjacent" transitions:
+    int upto = 0;
+    int min = -1;
+    int max = -1;
+    int dest = -1;
+
+    for(int i=0;i<numTransitions;i++) {
+      int tDest = transitions[offset+3*i];
+      int tMin = transitions[offset+3*i+1];
+      int tMax = transitions[offset+3*i+2];
+
+      if (dest == tDest) {
+        if (tMin <= max+1) {
+          if (tMax > max) {
+            max = tMax;
+          }
+        } else {
+          if (dest != -1) {
+            transitions[offset+3*upto] = dest;
+            transitions[offset+3*upto+1] = min;
+            transitions[offset+3*upto+2] = max;
+            upto++;
+          }
+          min = tMin;
+          max = tMax;
+        }
+      } else {
+        if (dest != -1) {
+          transitions[offset+3*upto] = dest;
+          transitions[offset+3*upto+1] = min;
+          transitions[offset+3*upto+2] = max;
+          upto++;
+        }
+        dest = tDest;
+        min = tMin;
+        max = tMax;
+      }
+    }
+
+    if (dest != -1) {
+      // Last transition
+      transitions[offset+3*upto] = dest;
+      transitions[offset+3*upto+1] = min;
+      transitions[offset+3*upto+2] = max;
+      upto++;
+    }
+
+    nextTransition -= (numTransitions-upto)*3;
+    states[2*curState+1] = upto;
+
+    // Sort transitions by min/max/dest:
+    minMaxDestSorter.sort(start, start+upto);
+
+    if (deterministic && upto > 1) {
+      int lastMax = transitions[offset+2];
+      for(int i=1;i<upto;i++) {
+        min = transitions[offset + 3*i + 1];
+        if (min <= lastMax) {
+          deterministic = false;
+          break;
+        }
+        lastMax = transitions[offset + 3*i + 2];
+      }
+    }
+
+    /*
+    System.out.println("after finish: reduce collapsed " + (numTransitions-upto) + " transitions");
+    for(int i=0;i<upto;i++) {
+      System.out.println("  " + i + ": dest=" + transitions[offset+3*i] + " (accept?=" + isAccept(transitions[offset+3*i]) + ") min=" + transitions[offset+3*i+1] + " max=" + transitions[offset+3*i+2]);
+    }
+    */
+  }
+
+  public boolean isDeterministic() {
+    return deterministic;
+  }
+
+  /** Finishes the current state; call this once you are done adding transitions for a state. */
+  public void finishState() {
+    if (curState != -1) {
+      //System.out.println("finish: finish current state " + curState);
+      finishCurrentState();
+      curState = -1;
+    }
+  }
+
+  // TODO: add finish() to shrink wrap the arrays?
+
+  public int getNumStates() {
+    return nextState/2;
+  }
+
+  public int getNumTransitions(int state) {
+    int count = states[2*state+1];
+    if (count == -1) {
+      return 0;
+    } else {
+      return count;
+    }
+  }
+
+  public int getDest(int state, int transitionIndex) {
+    return transitions[states[2*state]];
+  }
+
+  public int getMin(int state, int transitionIndex) {
+    return transitions[states[2*state]+1];
+  }
+
+  public int getMax(int state, int transitionIndex) {
+    return transitions[states[2*state]+2];
+  }
+
+  private void growStates() {
+    if (nextState+2 >= states.length) {
+      states = ArrayUtil.grow(states, nextState+2);
+    }
+  }
+
+  private void growTransitions() {
+    if (nextTransition+3 >= transitions.length) {
+      transitions = ArrayUtil.grow(transitions, nextTransition+3);
+    }
+  }
+
+  /** Sorts transitions by dest, ascending, then min label ascending, then max label ascending */
+  private final Sorter destMinMaxSorter = new InPlaceMergeSorter() {
+
+      private void swapOne(int i, int j) {
+        int x = transitions[i];
+        transitions[i] = transitions[j];
+        transitions[j] = x;
+      }
+
+      @Override
+      protected void swap(int i, int j) {
+        int iStart = 3*i;
+        int jStart = 3*j;
+        swapOne(iStart, jStart);
+        swapOne(iStart+1, jStart+1);
+        swapOne(iStart+2, jStart+2);
+      };
+
+      @Override
+      protected int compare(int i, int j) {
+        int iStart = 3*i;
+        int jStart = 3*j;
+
+        // First dest:
+        int iDest = transitions[iStart];
+        int jDest = transitions[jStart];
+        if (iDest < jDest) {
+          return -1;
+        } else if (iDest > jDest) {
+          return 1;
+        }
+
+        // Then min:
+        int iMin = transitions[iStart+1];
+        int jMin = transitions[jStart+1];
+        if (iMin < jMin) {
+          return -1;
+        } else if (iMin > jMin) {
+          return 1;
+        }
+
+        // Then max:
+        int iMax = transitions[iStart+2];
+        int jMax = transitions[jStart+2];
+        if (iMax < jMax) {
+          return -1;
+        } else if (iMax > jMax) {
+          return 1;
+        }
+
+        return 0;
+      }
+    };
+
+  /** Sorts transitions by min label, ascending, then max label ascending, then dest ascending */
+  private final Sorter minMaxDestSorter = new InPlaceMergeSorter() {
+
+      private void swapOne(int i, int j) {
+        int x = transitions[i];
+        transitions[i] = transitions[j];
+        transitions[j] = x;
+      }
+
+      @Override
+      protected void swap(int i, int j) {
+        int iStart = 3*i;
+        int jStart = 3*j;
+        swapOne(iStart, jStart);
+        swapOne(iStart+1, jStart+1);
+        swapOne(iStart+2, jStart+2);
+      };
+
+      @Override
+      protected int compare(int i, int j) {
+        int iStart = 3*i;
+        int jStart = 3*j;
+
+        // First min:
+        int iMin = transitions[iStart+1];
+        int jMin = transitions[jStart+1];
+        if (iMin < jMin) {
+          return -1;
+        } else if (iMin > jMin) {
+          return 1;
+        }
+
+        // Then max:
+        int iMax = transitions[iStart+2];
+        int jMax = transitions[jStart+2];
+        if (iMax < jMax) {
+          return -1;
+        } else if (iMax > jMax) {
+          return 1;
+        }
+
+        // Then dest:
+        int iDest = transitions[iStart];
+        int jDest = transitions[jStart];
+        if (iDest < jDest) {
+          return -1;
+        } else if (iDest > jDest) {
+          return 1;
+        }
+
+        return 0;
+      }
+    };
+
+  /** Initialize the provided Transition to iterate through all transitions
+   *  leaving the specified state.  You must call {@link #getNextTransition} to
+   *  get each transition.  Returns the number of transitions
+   *  leaving this state. */
+  public int initTransition(int state, Transition t) {
+    assert state < nextState/2: "state=" + state + " nextState=" + nextState;
+    t.source = state;
+    t.transitionUpto = states[2*state];
+    return getNumTransitions(state);
+  }
+
+  /** Iterate to the next transition after the provided one */
+  public void getNextTransition(Transition t) {
+    // Make sure there is still a transition left:
+    assert (t.transitionUpto+3 - states[2*t.source]) <= 3*states[2*t.source+1];
+    t.dest = transitions[t.transitionUpto++];
+    t.min = transitions[t.transitionUpto++];
+    t.max = transitions[t.transitionUpto++];
+  }
+
+  /** Fill the provided {@link Transition} with the index'th
+   *  transition leaving the specified state. */
+  public void getTransition(int state, int index, Transition t) {
+    int i = states[2*state] + 3*index;
+    t.source = state;
+    t.dest = transitions[i++];
+    t.min = transitions[i++];
+    t.max = transitions[i++];
+  }
+
+  static void appendCharString(int c, StringBuilder b) {
+    if (c >= 0x21 && c <= 0x7e && c != '\\' && c != '"') b.appendCodePoint(c);
+    else {
+      b.append("\\\\U");
+      String s = Integer.toHexString(c);
+      if (c < 0x10) b.append("0000000").append(s);
+      else if (c < 0x100) b.append("000000").append(s);
+      else if (c < 0x1000) b.append("00000").append(s);
+      else if (c < 0x10000) b.append("0000").append(s);
+      else if (c < 0x100000) b.append("000").append(s);
+      else if (c < 0x1000000) b.append("00").append(s);
+      else if (c < 0x10000000) b.append("0").append(s);
+      else b.append(s);
+    }
+  }
+
+  // nocommit move to Operations
+  public Automaton totalize() {
+    Automaton result = new Automaton();
+    int numStates = getNumStates();
+    for(int i=0;i<numStates;i++) {
+      result.createState();
+      result.setAccept(i, isAccept(i));
+    }
+
+    int deadState = result.createState();
+    result.addTransition(deadState, deadState, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);
+
+    Transition t = new Transition();
+    for(int i=0;i<numStates;i++) {
+      int maxi = Character.MIN_CODE_POINT;
+      int count = initTransition(i, t);
+      for(int j=0;j<count;j++) {
+        getNextTransition(t);
+        result.addTransition(i, t.dest, t.min, t.max);
+        if (t.min > maxi) {
+          result.addTransition(i, deadState, maxi, t.min-1);
+        }
+        if (t.max + 1 > maxi) {
+          maxi = t.max + 1;
+        }
+      }
+
+      if (maxi <= Character.MAX_CODE_POINT) {
+        result.addTransition(i, deadState, maxi, Character.MAX_CODE_POINT);
+      }
+    }
+    result.finishState();
+    return result;
+  }
+
+  // nocommit
+  /*
+  public void writeDot(String fileName) {
+    if (fileName.indexOf('/') == -1) {
+      fileName = "/l/la/lucene/core/" + fileName + ".dot";
+    }
+    try {
+      PrintWriter pw = new PrintWriter(fileName);
+      pw.println(toDot());
+      pw.close();
+    } catch (IOException ioe) {
+      throw new RuntimeException(ioe);
+    }
+  }
+  */
+
+  public String toDot() {
+    // TODO: breadth first search so we can see get layered output...
+
+    StringBuilder b = new StringBuilder();
+    b.append("digraph Automaton {\n");
+    b.append("  rankdir = LR\n");
+    final int numStates = getNumStates();
+    if (numStates > 0) {
+      b.append("  initial [shape=plaintext,label=\"0\"]\n");
+      b.append("  initial -> 0\n");
+    }
+
+    Transition t = new Transition();
+
+    for(int state=0;state<numStates;state++) {
+      b.append("  ");
+      b.append(state);
+      if (isAccept(state)) {
+        b.append(" [shape=doublecircle,label=\"" + state + "\"]\n");
+      } else {
+        b.append(" [shape=circle,label=\"" + state + "\"]\n");
+      }
+      int numTransitions = getNumTransitions(state);
+      initTransition(state, t);
+      //System.out.println("toDot: state " + state + " has " + numTransitions + " transitions; t.nextTrans=" + t.transitionUpto);
+      for(int i=0;i<numTransitions;i++) {
+        getNextTransition(t);
+        //System.out.println("  t.nextTrans=" + t.transitionUpto);
+        assert t.max >= t.min;
+        b.append("  ");
+        b.append(state);
+        b.append(" -> ");
+        b.append(t.dest);
+        b.append(" [label=\"");
+        appendCharString(t.min, b);
+        if (t.max != t.min) {
+          b.append('-');
+          appendCharString(t.max, b);
+        }
+        b.append("\"]\n");
+        //System.out.println("  t=" + t);
+      }
+    }
+    b.append('}');
+    return b.toString();
+  }
+
+  /**
+   * Returns sorted array of all interval start points.
+   */
+  int[] getStartPoints() {
+    Set<Integer> pointset = new HashSet<>();
+    pointset.add(Character.MIN_CODE_POINT);
+    //System.out.println("getStartPoints");
+    for (int s=0;s<nextState;s+=2) {
+      int trans = states[s];
+      int limit = trans+3*states[s+1];
+      //System.out.println("  state=" + (s/2) + " trans=" + trans + " limit=" + limit);
+      while (trans < limit) {
+        int min = transitions[trans+1];
+        int max = transitions[trans+2];
+        //System.out.println("    min=" + min);
+        pointset.add(min);
+        if (max < Character.MAX_CODE_POINT) {
+          pointset.add(max + 1);
+        }
+        trans += 3;
+      }
+    }
+    int[] points = new int[pointset.size()];
+    int n = 0;
+    for (Integer m : pointset) {
+      points[n++] = m;
+    }
+    Arrays.sort(points);
+    return points;
+  }
+
+  /**
+   * Performs lookup in transitions, assuming determinism.
+   * 
+   * @param c codepoint to look up
+   * @return destination state, -1 if no matching outgoing transition
+   * @see #step(int, Collection)
+   */
+  public int step(int state, int label) {
+    assert state >= 0;
+    assert label >= 0;
+    int trans = states[2*state];
+    int limit = trans + 3*states[2*state+1];
+    // TODO: we could do bin search; transitions are sorted
+    while (trans < limit) {
+      int dest = transitions[trans];
+      int min = transitions[trans+1];
+      int max = transitions[trans+2];
+      if (min <= label && label <= max) {
+        return dest;
+      }
+      trans += 3;
+    }
+
+    return -1;
+  }
+
+  /** Records new states and transitions and then {@link
+   *  #finish} creates the {@link Automaton}.  Use this
+   *  when it's too restrictive to have to add all transitions
+   *  leaving each state at once. */
+  public static class Builder {
+    private int[] transitions = new int[4];
+    private int nextTransition;
+    private final Automaton a = new Automaton();
+
+    public void addTransition(int from, int to, int label) {
+      addTransition(from, to, label, label);
+    }
+
+    public void addTransition(int from, int to, int min, int max) {
+      if (transitions.length < nextTransition+4) {
+        transitions = ArrayUtil.grow(transitions, nextTransition+4);
+      }
+      transitions[nextTransition++] = from;
+      transitions[nextTransition++] = to;
+      transitions[nextTransition++] = min;
+      transitions[nextTransition++] = max;
+    }
+
+    /** Sorts transitions first then min label ascending, then
+     *  max label ascending, then dest ascending */
+    private final Sorter sorter = new InPlaceMergeSorter() {
+
+        private void swapOne(int i, int j) {
+          int x = transitions[i];
+          transitions[i] = transitions[j];
+          transitions[j] = x;
+        }
+
+        @Override
+        protected void swap(int i, int j) {
+          int iStart = 4*i;
+          int jStart = 4*j;
+          swapOne(iStart, jStart);
+          swapOne(iStart+1, jStart+1);
+          swapOne(iStart+2, jStart+2);
+          swapOne(iStart+3, jStart+3);
+        };
+
+        @Override
+        protected int compare(int i, int j) {
+          int iStart = 4*i;
+          int jStart = 4*j;
+
+          // First src:
+          int iSrc = transitions[iStart];
+          int jSrc = transitions[jStart];
+          if (iSrc < jSrc) {
+            return -1;
+          } else if (iSrc > jSrc) {
+            return 1;
+          }
+
+          // Then min:
+          int iMin = transitions[iStart+2];
+          int jMin = transitions[jStart+2];
+          if (iMin < jMin) {
+            return -1;
+          } else if (iMin > jMin) {
+            return 1;
+          }
+
+          // Then max:
+          int iMax = transitions[iStart+3];
+          int jMax = transitions[jStart+3];
+          if (iMax < jMax) {
+            return -1;
+          } else if (iMax > jMax) {
+            return 1;
+          }
+
+          // First dest:
+          int iDest = transitions[iStart+1];
+          int jDest = transitions[jStart+1];
+          if (iDest < jDest) {
+            return -1;
+          } else if (iDest > jDest) {
+            return 1;
+          }
+
+          return 0;
+        }
+      };
+
+    public Automaton finish() {
+      //System.out.println("LA.Builder.finish: count=" + (nextTransition/4));
+      // nocommit: we could make this more efficient,
+      // e.g. somehow xfer the int[] to the automaton, or
+      // alloc exactly the right size from the automaton
+      //System.out.println("finish pending");
+      sorter.sort(0, nextTransition/4);
+      int upto = 0;
+      while (upto < nextTransition) {
+        a.addTransition(transitions[upto],
+                        transitions[upto+1],
+                        transitions[upto+2],
+                        transitions[upto+3]);
+        upto += 4;
+      }
+
+      a.finishState();
+      return a;
+    }
+
+    public int createState() {
+      return a.createState();
+    }
+
+    public void setAccept(int state, boolean accept) {
+      a.setAccept(state, accept);
+    }
+
+    public boolean isAccept(int state) {
+      return a.isAccept(state);
+    }
+
+    public int getNumStates() {
+      return a.getNumStates();
+    }
+
+    /** Copies over all states/transitions from other. */
+    public void copy(Automaton other) {
+      int offset = getNumStates();
+      int otherNumStates = other.getNumStates();
+      for(int s=0;s<otherNumStates;s++) {
+        int newState = createState();
+        setAccept(newState, other.isAccept(s));
+      }
+      Transition t = new Transition();
+      for(int s=0;s<otherNumStates;s++) {
+        int count = other.initTransition(s, t);
+        for(int i=0;i<count;i++) {
+          other.getNextTransition(t);
+          addTransition(offset + s, offset + t.dest, t.min, t.max);
+        }
+      }
+    }
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/AutomatonProvider.java b/lucene/core/src/java/org/apache/lucene/util/automaton/AutomatonProvider.java
new file mode 100644
index 0000000..26812d0
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/util/automaton/AutomatonProvider.java
@@ -0,0 +1,50 @@
+/*
+ * dk.brics.automaton
+ * 
+ * Copyright (c) 2001-2009 Anders Moeller
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package org.apache.lucene.util.automaton;
+
+import java.io.IOException;
+
+/**
+ * Automaton provider for <code>RegExp.</code>
+ * {@link RegExp#toAutomaton(AutomatonProvider)}
+ * 
+ * @lucene.experimental
+ */
+public interface AutomatonProvider {
+  
+  /**
+   * Returns automaton of the given name.
+   * 
+   * @param name automaton name
+   * @return automaton
+   * @throws IOException if errors occur
+   */
+  public Automaton getAutomaton(String name) throws IOException;
+}
diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/BasicAutomata.java b/lucene/core/src/java/org/apache/lucene/util/automaton/BasicAutomata.java
deleted file mode 100644
index d29178a..0000000
--- a/lucene/core/src/java/org/apache/lucene/util/automaton/BasicAutomata.java
+++ /dev/null
@@ -1,328 +0,0 @@
-/*
- * dk.brics.automaton
- * 
- * Copyright (c) 2001-2009 Anders Moeller
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package org.apache.lucene.util.automaton;
-
-import java.util.*;
-
-import org.apache.lucene.util.BytesRef;
-
-/**
- * Construction of basic automata.
- * 
- * @lucene.experimental
- */
-final public class BasicAutomata {
-  
-  private BasicAutomata() {}
-  
-  /**
-   * Returns a new (deterministic) automaton with the empty language.
-   */
-  public static LightAutomaton makeEmptyLight() {
-    LightAutomaton a = new LightAutomaton();
-    a.finishState();
-    return a;
-  }
-  
-  /**
-   * Returns a new (deterministic) automaton that accepts only the empty string.
-   */
-  public static LightAutomaton makeEmptyStringLight() {
-    LightAutomaton a = new LightAutomaton();
-    a.createState();
-    a.setAccept(0, true);
-    return a;
-  }
-  
-  /**
-   * Returns a new (deterministic) automaton that accepts all strings.
-   */
-  public static LightAutomaton makeAnyStringLight() {
-    LightAutomaton a = new LightAutomaton();
-    int s = a.createState();
-    a.setAccept(s, true);
-    a.addTransition(s, s, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);
-    a.finishState();
-    return a;
-  }
-  
-  /**
-   * Returns a new (deterministic) automaton that accepts any single codepoint.
-   */
-  public static LightAutomaton makeAnyCharLight() {
-    return makeCharRangeLight(Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);
-  }
-  
-  public static int appendAnyChar(LightAutomaton a, int state) {
-    int newState = a.createState();
-    a.addTransition(state, newState, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);
-    return newState;
-  }
-
-  /**
-   * Returns a new (deterministic) automaton that accepts a single codepoint of
-   * the given value.
-   */
-  public static LightAutomaton makeCharLight(int c) {
-    return makeCharRangeLight(c, c);
-  }
-  
-  public static int appendChar(LightAutomaton a, int state, int c) {
-    int newState = a.createState();
-    a.addTransition(state, newState, c, c);
-    return newState;
-  }
-
-  /**
-   * Returns a new (deterministic) automaton that accepts a single codepoint whose
-   * value is in the given interval (including both end points).
-   */
-  public static LightAutomaton makeCharRangeLight(int min, int max) {
-    if (min > max) {
-      return makeEmptyLight();
-    }
-    LightAutomaton a = new LightAutomaton();
-    int s1 = a.createState();
-    int s2 = a.createState();
-    a.setAccept(s2, true);
-    a.addTransition(s1, s2, min, max);
-    a.finishState();
-    return a;
-  }
-  
-  /**
-   * Constructs sub-automaton corresponding to decimal numbers of length
-   * x.substring(n).length().
-   */
-  private static int anyOfRightLengthLight(LightAutomaton.Builder builder, String x, int n) {
-    int s = builder.createState();
-    if (x.length() == n) {
-      builder.setAccept(s, true);
-    } else {
-      builder.addTransition(s, anyOfRightLengthLight(builder, x, n + 1), '0', '9');
-    }
-    return s;
-  }
-  
-  /**
-   * Constructs sub-automaton corresponding to decimal numbers of value at least
-   * x.substring(n) and length x.substring(n).length().
-   */
-  private static int atLeastLight(LightAutomaton.Builder builder, String x, int n, Collection<Integer> initials,
-      boolean zeros) {
-    int s = builder.createState();
-    if (x.length() == n) {
-      builder.setAccept(s, true);
-    } else {
-      if (zeros) {
-        initials.add(s);
-      }
-      char c = x.charAt(n);
-      builder.addTransition(s, atLeastLight(builder, x, n + 1, initials, zeros && c == '0'), c);
-      if (c < '9') {
-        builder.addTransition(s, anyOfRightLengthLight(builder, x, n + 1), (char) (c + 1), '9');
-      }
-    }
-    return s;
-  }
-  
-  /**
-   * Constructs sub-automaton corresponding to decimal numbers of value at most
-   * x.substring(n) and length x.substring(n).length().
-   */
-  private static int atMostLight(LightAutomaton.Builder builder, String x, int n) {
-    int s = builder.createState();
-    if (x.length() == n) {
-      builder.setAccept(s, true);
-    } else {
-      char c = x.charAt(n);
-      builder.addTransition(s, atMostLight(builder, x, (char) n + 1), c);
-      if (c > '0') {
-        builder.addTransition(s, anyOfRightLengthLight(builder, x, n + 1), '0', (char) (c - 1));
-      }
-    }
-    return s;
-  }
-  
-  /**
-   * Constructs sub-automaton corresponding to decimal numbers of value between
-   * x.substring(n) and y.substring(n) and of length x.substring(n).length()
-   * (which must be equal to y.substring(n).length()).
-   */
-  private static int betweenLight(LightAutomaton.Builder builder,
-      String x, String y, int n,
-      Collection<Integer> initials, boolean zeros) {
-    int s = builder.createState();
-    if (x.length() == n) {
-      builder.setAccept(s, true);
-    } else {
-      if (zeros) {
-        initials.add(s);
-      }
-      char cx = x.charAt(n);
-      char cy = y.charAt(n);
-      if (cx == cy) {
-        builder.addTransition(s, betweenLight(builder, x, y, n + 1, initials, zeros && cx == '0'), cx);
-      } else { // cx<cy
-        builder.addTransition(s, atLeastLight(builder, x, n + 1, initials, zeros && cx == '0'), cx);
-        builder.addTransition(s, atMostLight(builder, y, n + 1), cy);
-        if (cx + 1 < cy) {
-          builder.addTransition(s, anyOfRightLengthLight(builder, x, n+1), (char) (cx + 1), (char) (cy - 1));
-        }
-      }
-    }
-
-    return s;
-  }
-
-  /**
-   * Returns a new automaton that accepts strings representing decimal
-   * non-negative integers in the given interval.
-   * 
-   * @param min minimal value of interval
-   * @param max maximal value of interval (both end points are included in the
-   *          interval)
-   * @param digits if >0, use fixed number of digits (strings must be prefixed
-   *          by 0's to obtain the right length) - otherwise, the number of
-   *          digits is not fixed
-   * @exception IllegalArgumentException if min>max or if numbers in the
-   *              interval cannot be expressed with the given fixed number of
-   *              digits
-   */
-  public static LightAutomaton makeIntervalLight(int min, int max, int digits)
-      throws IllegalArgumentException {
-    String x = Integer.toString(min);
-    String y = Integer.toString(max);
-    if (min > max || (digits > 0 && y.length() > digits)) {
-      throw new IllegalArgumentException();
-    }
-    int d;
-    if (digits > 0) d = digits;
-    else d = y.length();
-    StringBuilder bx = new StringBuilder();
-    for (int i = x.length(); i < d; i++) {
-      bx.append('0');
-    }
-    bx.append(x);
-    x = bx.toString();
-    StringBuilder by = new StringBuilder();
-    for (int i = y.length(); i < d; i++) {
-      by.append('0');
-    }
-    by.append(y);
-    y = by.toString();
-
-    LightAutomaton.Builder builder = new LightAutomaton.Builder();
-
-    if (digits <= 0) {
-      // Reserve the "real" initial state:
-      builder.createState();
-    }
-
-    Collection<Integer> initials = new ArrayList<>();
-
-    betweenLight(builder, x, y, 0, initials, digits <= 0);
-
-    LightAutomaton a1 = builder.finish();
-
-    if (digits <= 0) {
-      a1.addTransition(0, 0, '0');
-      for (int p : initials) {
-        a1.addEpsilon(0, p);
-      }
-      a1.finishState();
-    }
-
-    return a1;
-  }
-  
-  /**
-   * Returns a new (deterministic) automaton that accepts the single given
-   * string.
-   */
-  public static LightAutomaton makeStringLight(String s) {
-    LightAutomaton a = new LightAutomaton();
-    int lastState = a.createState();
-    for (int i = 0, cp = 0; i < s.length(); i += Character.charCount(cp)) {
-      int state = a.createState();
-      cp = s.codePointAt(i);
-      a.addTransition(lastState, state, cp, cp);
-      lastState = state;
-    }
-
-    a.setAccept(lastState, true);
-    a.finishState();
-
-    assert a.isDeterministic();
-    assert BasicOperations.hasDeadStates(a) == false;
-
-    return a;
-  }
-  
-  /**
-   * Returns a new (deterministic) automaton that accepts the single given
-   * string from the specified unicode code points.
-   */
-  public static LightAutomaton makeStringLight(int[] word, int offset, int length) {
-    LightAutomaton a = new LightAutomaton();
-    a.createState();
-    int s = 0;
-    for (int i = offset; i < offset+length; i++) {
-      int s2 = a.createState();
-      a.addTransition(s, s2, word[i]);
-      s = s2;
-    }
-    a.setAccept(s, true);
-    a.finishState();
-
-    return a;
-  }
-
-  /**
-   * Returns a new (deterministic and minimal) automaton that accepts the union
-   * of the given collection of {@link BytesRef}s representing UTF-8 encoded
-   * strings.
-   * 
-   * @param utf8Strings
-   *          The input strings, UTF-8 encoded. The collection must be in sorted
-   *          order.
-   * 
-   * @return An {@link Automaton} accepting all input strings. The resulting
-   *         automaton is codepoint based (full unicode codepoints on
-   *         transitions).
-   */
-  public static LightAutomaton makeStringUnionLight(Collection<BytesRef> utf8Strings) {
-    if (utf8Strings.isEmpty()) {
-      return makeEmptyLight();
-    } else {
-      return DaciukMihovAutomatonBuilderLight.build(utf8Strings);
-    }
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/BasicOperations.java b/lucene/core/src/java/org/apache/lucene/util/automaton/BasicOperations.java
deleted file mode 100644
index 5c9fe98..0000000
--- a/lucene/core/src/java/org/apache/lucene/util/automaton/BasicOperations.java
+++ /dev/null
@@ -1,967 +0,0 @@
-/*
- * dk.brics.automaton
- * 
- * Copyright (c) 2001-2009 Anders Moeller
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package org.apache.lucene.util.automaton;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.BitSet;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import org.apache.lucene.util.ArrayUtil;
-import org.apache.lucene.util.IntsRef;
-import org.apache.lucene.util.RamUsageEstimator;
-
-/**
- * Basic automata operations.
- * 
- * @lucene.experimental
- */
-final public class BasicOperations {
-  
-  private BasicOperations() {}
-
-  /**
-   * Returns an automaton that accepts the concatenation of the languages of the
-   * given automata.
-   * <p>
-   * Complexity: linear in total number of states.
-   */
-  static public LightAutomaton concatenateLight(LightAutomaton a1, LightAutomaton a2) {
-    return concatenateLight(Arrays.asList(a1, a2));
-  }
-
-  /**
-   * Returns an automaton that accepts the concatenation of the languages of the
-   * given automata.
-   * <p>
-   * Complexity: linear in total number of states.
-   */
-  static public LightAutomaton concatenateLight(List<LightAutomaton> l) {
-    LightAutomaton result = new LightAutomaton();
-
-    // First pass: create all states
-    for(LightAutomaton a : l) {
-      if (a.getNumStates() == 0) {
-        result.finishState();
-        return result;
-      }
-      int numStates = a.getNumStates();
-      for(int s=0;s<numStates;s++) {
-        result.createState();
-      }
-    }
-
-    // Second pass: add transitions, carefully linking accept
-    // states of A to init state of next A:
-    int stateOffset = 0;
-    Transition t = new Transition();
-    for(int i=0;i<l.size();i++) {
-      LightAutomaton a = l.get(i);
-      int numStates = a.getNumStates();
-
-      LightAutomaton nextA = (i == l.size()-1) ? null : l.get(i+1);
-
-      for(int s=0;s<numStates;s++) {
-        int numTransitions = a.initTransition(s, t);
-        for(int j=0;j<numTransitions;j++) {
-          a.getNextTransition(t);
-          result.addTransition(stateOffset + s, stateOffset + t.dest, t.min, t.max);
-        }
-
-        if (a.isAccept(s)) {
-          LightAutomaton followA = nextA;
-          int followOffset = stateOffset;
-          int upto = i+1;
-          while (true) {
-            if (followA != null) {
-              // Adds a "virtual" epsilon transition:
-              numTransitions = followA.initTransition(0, t);
-              for(int j=0;j<numTransitions;j++) {
-                followA.getNextTransition(t);
-                result.addTransition(stateOffset + s, followOffset + numStates + t.dest, t.min, t.max);
-              }
-              if (followA.isAccept(0)) {
-                // Keep chaining if followA accepts empty string
-                followOffset += followA.getNumStates();
-                followA = (upto == l.size()-1) ? null : l.get(upto+1);
-                upto++;
-              } else {
-                break;
-              }
-            } else {
-              result.setAccept(stateOffset + s, true);
-              break;
-            }
-          }
-        }
-      }
-
-      stateOffset += numStates;
-    }
-
-    if (result.getNumStates() == 0) {
-      result.createState();
-    }
-
-    result.finishState();
-
-    return result;
-  }
-
-  /**
-   * Returns an automaton that accepts the union of the empty string and the
-   * language of the given automaton.
-   * <p>
-   * Complexity: linear in number of states.
-   */
-  static public LightAutomaton optionalLight(LightAutomaton a) {
-    LightAutomaton result = new LightAutomaton();
-    result.createState();
-    result.setAccept(0, true);
-    if (a.getNumStates() > 0) {
-      result.copy(a);
-      result.addEpsilon(0, 1);
-    }
-    result.finishState();
-    return result;
-  }
-  
-  /**
-   * Returns an automaton that accepts the Kleene star (zero or more
-   * concatenated repetitions) of the language of the given automaton. Never
-   * modifies the input automaton language.
-   * <p>
-   * Complexity: linear in number of states.
-   */
-  static public LightAutomaton repeatLight(LightAutomaton a) {
-    LightAutomaton.Builder builder = new LightAutomaton.Builder();
-    builder.createState();
-    builder.setAccept(0, true);
-    builder.copy(a);
-
-    Transition t = new Transition();
-    int count = a.initTransition(0, t);
-    for(int i=0;i<count;i++) {
-      a.getNextTransition(t);
-      builder.addTransition(0, t.dest+1, t.min, t.max);
-    }
-
-    int numStates = a.getNumStates();
-    for(int s=0;s<numStates;s++) {
-      if (a.isAccept(s)) {
-        count = a.initTransition(0, t);
-        for(int i=0;i<count;i++) {
-          a.getNextTransition(t);
-          builder.addTransition(s+1, t.dest+1, t.min, t.max);
-        }
-      }
-    }
-
-    return builder.finish();
-  }
-
-  /**
-   * Returns an automaton that accepts <code>min</code> or more concatenated
-   * repetitions of the language of the given automaton.
-   * <p>
-   * Complexity: linear in number of states and in <code>min</code>.
-   */
-  static public LightAutomaton repeatLight(LightAutomaton a, int min) {
-    if (min == 0) {
-      return repeatLight(a);
-    }
-    List<LightAutomaton> as = new ArrayList<>();
-    while (min-- > 0) {
-      as.add(a);
-    }
-    as.add(repeatLight(a));
-    return concatenateLight(as);
-  }
-  
-  /**
-   * Returns an automaton that accepts between <code>min</code> and
-   * <code>max</code> (including both) concatenated repetitions of the language
-   * of the given automaton.
-   * <p>
-   * Complexity: linear in number of states and in <code>min</code> and
-   * <code>max</code>.
-   */
-  static public LightAutomaton repeatLight(LightAutomaton a, int min, int max) {
-    if (min > max) {
-      return BasicAutomata.makeEmptyLight();
-    }
-
-    LightAutomaton b;
-    if (min == 0) {
-      b = BasicAutomata.makeEmptyStringLight();
-    } else if (min == 1) {
-      b = new LightAutomaton();
-      b.copy(a);
-    } else {
-      List<LightAutomaton> as = new ArrayList<>();
-      for(int i=0;i<min;i++) {
-        as.add(a);
-      }
-      b = concatenateLight(as);
-    }
-
-    Set<Integer> prevAcceptStates = new HashSet<>(b.getAcceptStates());
-
-    for(int i=min;i<max;i++) {
-      int numStates = b.getNumStates();
-      b.copy(a);
-      for(int s : prevAcceptStates) {
-        b.addEpsilon(s, numStates);
-      }
-      prevAcceptStates.clear();
-      for(int s : a.getAcceptStates()) {
-        prevAcceptStates.add(numStates+s);
-      }
-    }
-
-    b.finishState();
-
-    return b;
-  }
-  
-  /**
-   * Returns a (deterministic) automaton that accepts the complement of the
-   * language of the given automaton.
-   * <p>
-   * Complexity: linear in number of states (if already deterministic).
-   */
-  static public LightAutomaton complementLight(LightAutomaton a) {
-    a = determinize(a).totalize();
-    int numStates = a.getNumStates();
-    for (int p=0;p<numStates;p++) {
-      a.setAccept(p, !a.isAccept(p));
-    }
-    return removeDeadStates(a);
-  }
-  
-  /**
-   * Returns a (deterministic) automaton that accepts the intersection of the
-   * language of <code>a1</code> and the complement of the language of
-   * <code>a2</code>. As a side-effect, the automata may be determinized, if not
-   * already deterministic.
-   * <p>
-   * Complexity: quadratic in number of states (if already deterministic).
-   */
-  static public LightAutomaton minusLight(LightAutomaton a1, LightAutomaton a2) {
-    if (BasicOperations.isEmpty(a1) || a1 == a2) {
-      return BasicAutomata.makeEmptyLight();
-    }
-    if (BasicOperations.isEmpty(a2)) {
-      return a1;
-    }
-    return intersectionLight(a1, complementLight(a2));
-  }
-  
-  /**
-   * Returns an automaton that accepts the intersection of the languages of the
-   * given automata. Never modifies the input automata languages.
-   * <p>
-   * Complexity: quadratic in number of states.
-   */
-  static public LightAutomaton intersectionLight(LightAutomaton a1, LightAutomaton a2) {
-    if (a1 == a2) {
-      return a1;
-    }
-    if (a1.getNumStates() == 0) {
-      return a1;
-    }
-    if (a2.getNumStates() == 0) {
-      return a2;
-    }
-    Transition[][] transitions1 = a1.getSortedTransitions();
-    Transition[][] transitions2 = a2.getSortedTransitions();
-    LightAutomaton c = new LightAutomaton();
-    c.createState();
-    LinkedList<LightStatePair> worklist = new LinkedList<>();
-    HashMap<LightStatePair,LightStatePair> newstates = new HashMap<>();
-    LightStatePair p = new LightStatePair(0, 0, 0);
-    worklist.add(p);
-    newstates.put(p, p);
-    while (worklist.size() > 0) {
-      p = worklist.removeFirst();
-      c.setAccept(p.s, a1.isAccept(p.s1) && a2.isAccept(p.s2));
-      Transition[] t1 = transitions1[p.s1];
-      Transition[] t2 = transitions2[p.s2];
-      for (int n1 = 0, b2 = 0; n1 < t1.length; n1++) {
-        while (b2 < t2.length && t2[b2].max < t1[n1].min)
-          b2++;
-        for (int n2 = b2; n2 < t2.length && t1[n1].max >= t2[n2].min; n2++)
-          if (t2[n2].max >= t1[n1].min) {
-            LightStatePair q = new LightStatePair(t1[n1].dest, t2[n2].dest);
-            LightStatePair r = newstates.get(q);
-            if (r == null) {
-              q.s = c.createState();
-              worklist.add(q);
-              newstates.put(q, q);
-              r = q;
-            }
-            int min = t1[n1].min > t2[n2].min ? t1[n1].min : t2[n2].min;
-            int max = t1[n1].max < t2[n2].max ? t1[n1].max : t2[n2].max;
-            c.addTransition(p.s, r.s, min, max);
-          }
-      }
-    }
-    c.finishState();
-
-    return removeDeadStates(c);
-  }
-
-  /** Returns true if these two automata accept exactly the
-   *  same language.  This is a costly computation!  Note
-   *  also that a1 and a2 will be determinized as a side
-   *  effect.  Both automata must be determinized and have
-   *  no dead states! */
-  public static boolean sameLanguage(LightAutomaton a1, LightAutomaton a2) {
-    if (a1 == a2) {
-      return true;
-    }
-    return subsetOf(a2, a1) && subsetOf(a1, a2);
-  }
-
-  // TODO: move to test-framework?
-  /** Returns true if this automaton has any states that cannot
-   *  be reached from the initial state or cannot reach an accept state.
-   *  Cost is O(numTransitions+numStates). */
-  public static boolean hasDeadStates(LightAutomaton a) {
-    BitSet liveStates = getLiveStates(a);
-    int numLive = liveStates.cardinality();
-    int numStates = a.getNumStates();
-    assert numLive <= numStates: "numLive=" + numLive + " numStates=" + numStates + " " + liveStates;
-    return numLive < numStates;
-  }
-
-  // TODO: move to test-framework?
-  /** Returns true if there are dead states reachable from an initial state. */
-  public static boolean hasDeadStatesFromInitial(LightAutomaton a) {
-    BitSet reachableFromInitial = getLiveStatesFromInitial(a);
-    BitSet reachableFromAccept = getLiveStatesToAccept(a);
-    reachableFromInitial.andNot(reachableFromAccept);
-    return reachableFromInitial.isEmpty() == false;
-  }
-
-  // TODO: move to test-framework?
-  /** Returns true if there are dead states that reach an accept state. */
-  public static boolean hasDeadStatesToAccept(LightAutomaton a) {
-    BitSet reachableFromInitial = getLiveStatesFromInitial(a);
-    BitSet reachableFromAccept = getLiveStatesToAccept(a);
-    reachableFromAccept.andNot(reachableFromInitial);
-    return reachableFromAccept.isEmpty() == false;
-  }
-
-  /**
-   * Returns true if the language of <code>a1</code> is a subset of the language
-   * of <code>a2</code>. Both automata must be determinized and must have no dead
-   * states.
-   * <p>
-   * Complexity: quadratic in number of states.
-   */
-  public static boolean subsetOf(LightAutomaton a1, LightAutomaton a2) {
-    if (a1.isDeterministic() == false) {
-      throw new IllegalArgumentException("a1 must be deterministic");
-    }
-    if (a2.isDeterministic() == false) {
-      throw new IllegalArgumentException("a2 must be deterministic");
-    }
-    assert hasDeadStatesFromInitial(a1) == false;
-    assert hasDeadStatesFromInitial(a2) == false;
-    if (a1.getNumStates() == 0) {
-      // Empty language is alwyas a subset of any other language
-      return true;
-    } else if (a2.getNumStates() == 0) {
-      return isEmpty(a1);
-    }
-
-    // TODO: cutover to iterators instead
-    Transition[][] transitions1 = a1.getSortedTransitions();
-    Transition[][] transitions2 = a2.getSortedTransitions();
-    LinkedList<LightStatePair> worklist = new LinkedList<>();
-    HashSet<LightStatePair> visited = new HashSet<>();
-    LightStatePair p = new LightStatePair(0, 0);
-    worklist.add(p);
-    visited.add(p);
-    while (worklist.size() > 0) {
-      p = worklist.removeFirst();
-      if (a1.isAccept(p.s1) && a2.isAccept(p.s2) == false) {
-        return false;
-      }
-      Transition[] t1 = transitions1[p.s1];
-      Transition[] t2 = transitions2[p.s2];
-      for (int n1 = 0, b2 = 0; n1 < t1.length; n1++) {
-        while (b2 < t2.length && t2[b2].max < t1[n1].min) {
-          b2++;
-        }
-        int min1 = t1[n1].min, max1 = t1[n1].max;
-
-        for (int n2 = b2; n2 < t2.length && t1[n1].max >= t2[n2].min; n2++) {
-          if (t2[n2].min > min1) {
-            return false;
-          }
-          if (t2[n2].max < Character.MAX_CODE_POINT) {
-            min1 = t2[n2].max + 1;
-          } else {
-            min1 = Character.MAX_CODE_POINT;
-            max1 = Character.MIN_CODE_POINT;
-          }
-          LightStatePair q = new LightStatePair(t1[n1].dest, t2[n2].dest);
-          if (!visited.contains(q)) {
-            worklist.add(q);
-            visited.add(q);
-          }
-        }
-        if (min1 <= max1) {
-          return false;
-        }
-      }
-    }
-    return true;
-  }
-
-  /**
-   * Returns an automaton that accepts the union of the languages of the given
-   * automata.
-   * <p>
-   * Complexity: linear in number of states.
-   */
-  public static LightAutomaton unionLight(LightAutomaton a1, LightAutomaton a2) {
-    return unionLight(Arrays.asList(a1, a2));
-  }
-
-  public static LightAutomaton unionLight(Collection<LightAutomaton> l) {
-    LightAutomaton result = new LightAutomaton();
-
-    // Create initial state:
-    result.createState();
-
-    // Copy over all automata
-    Transition t = new Transition();
-    for(LightAutomaton a : l) {
-      result.copy(a);
-    }
-    
-    // Add epsilon transition from new initial state
-    int stateOffset = 1;
-    for(LightAutomaton a : l) {
-      if (a.getNumStates() == 0) {
-        continue;
-      }
-      result.addEpsilon(0, stateOffset);
-      stateOffset += a.getNumStates();
-    }
-
-    result.finishState();
-
-    return result;
-  }
-
-  // Simple custom ArrayList<Transition>
-  private final static class TransitionListLight {
-    // dest, min, max
-    int[] transitions = new int[3];
-    int next;
-
-    public void add(Transition t) {
-      if (transitions.length < next+3) {
-        transitions = ArrayUtil.grow(transitions, next+3);
-      }
-      transitions[next] = t.dest;
-      transitions[next+1] = t.min;
-      transitions[next+2] = t.max;
-      next += 3;
-    }
-  }
-
-  // Holds all transitions that start on this int point, or
-  // end at this point-1
-  private final static class PointTransitionsLight implements Comparable<PointTransitionsLight> {
-    int point;
-    final TransitionListLight ends = new TransitionListLight();
-    final TransitionListLight starts = new TransitionListLight();
-
-    @Override
-    public int compareTo(PointTransitionsLight other) {
-      return point - other.point;
-    }
-
-    public void reset(int point) {
-      this.point = point;
-      ends.next = 0;
-      starts.next = 0;
-    }
-
-    @Override
-    public boolean equals(Object other) {
-      return ((PointTransitionsLight) other).point == point;
-    }
-
-    @Override
-    public int hashCode() {
-      return point;
-    }
-  }
-
-  private final static class PointTransitionSetLight {
-    int count;
-    PointTransitionsLight[] points = new PointTransitionsLight[5];
-
-    private final static int HASHMAP_CUTOVER = 30;
-    private final HashMap<Integer,PointTransitionsLight> map = new HashMap<>();
-    private boolean useHash = false;
-
-    private PointTransitionsLight next(int point) {
-      // 1st time we are seeing this point
-      if (count == points.length) {
-        final PointTransitionsLight[] newArray = new PointTransitionsLight[ArrayUtil.oversize(1+count, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];
-        System.arraycopy(points, 0, newArray, 0, count);
-        points = newArray;
-      }
-      PointTransitionsLight points0 = points[count];
-      if (points0 == null) {
-        points0 = points[count] = new PointTransitionsLight();
-      }
-      points0.reset(point);
-      count++;
-      return points0;
-    }
-
-    private PointTransitionsLight find(int point) {
-      if (useHash) {
-        final Integer pi = point;
-        PointTransitionsLight p = map.get(pi);
-        if (p == null) {
-          p = next(point);
-          map.put(pi, p);
-        }
-        return p;
-      } else {
-        for(int i=0;i<count;i++) {
-          if (points[i].point == point) {
-            return points[i];
-          }
-        }
-
-        final PointTransitionsLight p = next(point);
-        if (count == HASHMAP_CUTOVER) {
-          // switch to HashMap on the fly
-          assert map.size() == 0;
-          for(int i=0;i<count;i++) {
-            map.put(points[i].point, points[i]);
-          }
-          useHash = true;
-        }
-        return p;
-      }
-    }
-
-    public void reset() {
-      if (useHash) {
-        map.clear();
-        useHash = false;
-      }
-      count = 0;
-    }
-
-    public void sort() {
-      // Tim sort performs well on already sorted arrays:
-      if (count > 1) ArrayUtil.timSort(points, 0, count);
-    }
-
-    public void add(Transition t) {
-      find(t.min).starts.add(t);
-      find(1+t.max).ends.add(t);
-    }
-
-    @Override
-    public String toString() {
-      StringBuilder s = new StringBuilder();
-      for(int i=0;i<count;i++) {
-        if (i > 0) {
-          s.append(' ');
-        }
-        s.append(points[i].point).append(':').append(points[i].starts.next/3).append(',').append(points[i].ends.next/3);
-      }
-      return s.toString();
-    }
-  }
-
-  /**
-   * Determinizes the given automaton.
-   * <p>
-   * Worst case complexity: exponential in number of states.
-   */
-  public static LightAutomaton determinize(LightAutomaton a) {
-    if (a.isDeterministic()) {
-      // Already determinized
-      return a;
-    }
-    if (a.getNumStates() <= 1) {
-      // Already determinized
-      return a;
-    }
-
-    // subset construction
-    LightAutomaton.Builder b = new LightAutomaton.Builder();
-
-    //System.out.println("DET:");
-    //a.writeDot("/l/la/lucene/core/detin.dot");
-
-    SortedIntSetLight.FrozenIntSetLight initialset = new SortedIntSetLight.FrozenIntSetLight(0, 0);
-
-    // Create state 0:
-    b.createState();
-
-    LinkedList<SortedIntSetLight.FrozenIntSetLight> worklist = new LinkedList<>();
-    Map<SortedIntSetLight.FrozenIntSetLight,Integer> newstate = new HashMap<>();
-
-    worklist.add(initialset);
-
-    b.setAccept(0, a.isAccept(0));
-    newstate.put(initialset, 0);
-
-    int newStateUpto = 0;
-    int[] newStatesArray = new int[5];
-    newStatesArray[newStateUpto] = 0;
-    newStateUpto++;
-
-    // like Set<Integer,PointTransitions>
-    final PointTransitionSetLight points = new PointTransitionSetLight();
-
-    // like SortedMap<Integer,Integer>
-    final SortedIntSetLight statesSet = new SortedIntSetLight(5);
-
-    Transition t = new Transition();
-
-    while (worklist.size() > 0) {
-      SortedIntSetLight.FrozenIntSetLight s = worklist.removeFirst();
-      //System.out.println("det: pop set=" + s);
-
-      // Collate all outgoing transitions by min/1+max:
-      for(int i=0;i<s.values.length;i++) {
-        final int s0 = s.values[i];
-        int numTransitions = a.getNumTransitions(s0);
-        a.initTransition(s0, t);
-        for(int j=0;j<numTransitions;j++) {
-          a.getNextTransition(t);
-          points.add(t);
-        }
-      }
-
-      if (points.count == 0) {
-        // No outgoing transitions -- skip it
-        continue;
-      }
-
-      points.sort();
-
-      int lastPoint = -1;
-      int accCount = 0;
-
-      final int r = s.state;
-
-      for(int i=0;i<points.count;i++) {
-
-        final int point = points.points[i].point;
-
-        if (statesSet.upto > 0) {
-          assert lastPoint != -1;
-
-          statesSet.computeHash();
-          
-          Integer q = newstate.get(statesSet);
-          if (q == null) {
-            q = b.createState();
-            final SortedIntSetLight.FrozenIntSetLight p = statesSet.freeze(q);
-            //System.out.println("  make new state=" + q + " -> " + p + " accCount=" + accCount);
-            worklist.add(p);
-            b.setAccept(q, accCount > 0);
-            newstate.put(p, q);
-          } else {
-            assert (accCount > 0 ? true:false) == b.isAccept(q): "accCount=" + accCount + " vs existing accept=" +
-              b.isAccept(q) + " states=" + statesSet;
-          }
-
-          // System.out.println("  add trans src=" + r + " dest=" + q + " min=" + lastPoint + " max=" + (point-1));
-
-          b.addTransition(r, q, lastPoint, point-1);
-        }
-
-        // process transitions that end on this point
-        // (closes an overlapping interval)
-        int[] transitions = points.points[i].ends.transitions;
-        int limit = points.points[i].ends.next;
-        for(int j=0;j<limit;j+=3) {
-          int dest = transitions[j];
-          statesSet.decr(dest);
-          accCount -= a.isAccept(dest) ? 1:0;
-        }
-        points.points[i].ends.next = 0;
-
-        // process transitions that start on this point
-        // (opens a new interval)
-        transitions = points.points[i].starts.transitions;
-        limit = points.points[i].starts.next;
-        for(int j=0;j<limit;j+=3) {
-          int dest = transitions[j];
-          statesSet.incr(dest);
-          accCount += a.isAccept(dest) ? 1:0;
-        }
-        lastPoint = point;
-        points.points[i].starts.next = 0;
-      }
-      points.reset();
-      assert statesSet.upto == 0: "upto=" + statesSet.upto;
-    }
-
-    LightAutomaton result = b.finish();
-    assert result.isDeterministic();
-    return result;
-  }
-
-  /**
-   * Returns true if the given automaton accepts no strings.
-   */
-  public static boolean isEmpty(LightAutomaton a) {
-    if (a.getNumStates() == 0) {
-      // Common case: no states
-      return true;
-    }
-    if (a.isAccept(0) == false && a.getNumTransitions(0) == 0) {
-      // Common case: just one initial state
-      return true;
-    }
-    if (a.isAccept(0) == true) {
-      // Apparently common case: it accepts the damned empty string
-      return false;
-    }
-    
-    LinkedList<Integer> workList = new LinkedList<>();
-    BitSet seen = new BitSet(a.getNumStates());
-    workList.add(0);
-    seen.set(0);
-
-    Transition t = new Transition();
-    while (workList.isEmpty() == false) {
-      int state = workList.removeFirst();
-      if (a.isAccept(state)) {
-        return false;
-      }
-      int count = a.initTransition(state, t);
-      for(int i=0;i<count;i++) {
-        a.getNextTransition(t);
-        if (seen.get(t.dest) == false) {
-          workList.add(t.dest);
-          seen.set(t.dest);
-        }
-      }
-    }
-
-    return true;
-  }
-  
-  /**
-   * Returns true if the given automaton accepts all strings.  The automaton must be minimized.
-   */
-  public static boolean isTotal(LightAutomaton a) {
-    if (a.isAccept(0) && a.getNumTransitions(0) == 1) {
-      Transition t = new Transition();
-      a.getTransition(0, 0, t);
-      return t.dest == 0 && t.min == Character.MIN_CODE_POINT
-          && t.max == Character.MAX_CODE_POINT;
-    }
-    return false;
-  }
-  
-  /**
-   * Returns true if the given string is accepted by the automaton.  The input must be deterministic.
-   * <p>
-   * Complexity: linear in the length of the string.
-   * <p>
-   * <b>Note:</b> for full performance, use the {@link RunAutomaton} class.
-   */
-  public static boolean run(LightAutomaton a, String s) {
-    assert a.isDeterministic();
-    int state = 0;
-    for (int i = 0, cp = 0; i < s.length(); i += Character.charCount(cp)) {
-      int nextState = a.step(state, cp = s.codePointAt(i));
-      if (nextState == -1) {
-        return false;
-      }
-      state = nextState;
-    }
-    return a.isAccept(state);
-  }
-
-  /**
-   * Returns true if the given string (expressed as unicode codepoints) is accepted by the automaton.  The input must be deterministic.
-   * <p>
-   * Complexity: linear in the length of the string.
-   * <p>
-   * <b>Note:</b> for full performance, use the {@link RunAutomaton} class.
-   */
-  public static boolean run(LightAutomaton a, IntsRef s) {
-    assert a.isDeterministic();
-    int state = 0;
-    for (int i=0;i<s.length;i++) {
-      int nextState = a.step(state, s.ints[s.offset+i]);
-      if (nextState == -1) {
-        return false;
-      }
-      state = nextState;
-    }
-    return a.isAccept(state);
-  }
-
-  /**
-   * Returns the set of live states. A state is "live" if an accept state is
-   * reachable from it and if it is reachable from the initial state.
-   */
-  private static BitSet getLiveStates(LightAutomaton a) {
-    BitSet live = getLiveStatesFromInitial(a);
-    live.and(getLiveStatesToAccept(a));
-    return live;
-  }
-
-  /** Returns bitset marking states reachable from the initial state. */
-  private static BitSet getLiveStatesFromInitial(LightAutomaton a) {
-    int numStates = a.getNumStates();
-    BitSet live = new BitSet(numStates);
-    if (numStates == 0) {
-      return live;
-    }
-    LinkedList<Integer> workList = new LinkedList<>();
-    live.set(0);
-    workList.add(0);
-
-    Transition t = new Transition();
-    while (workList.isEmpty() == false) {
-      int s = workList.removeFirst();
-      int count = a.initTransition(s, t);
-      for(int i=0;i<count;i++) {
-        a.getNextTransition(t);
-        if (live.get(t.dest) == false) {
-          live.set(t.dest);
-          workList.add(t.dest);
-        }
-      }
-    }
-
-    return live;
-  }
-
-  /** Returns bitset marking states that can reach an accept state. */
-  private static BitSet getLiveStatesToAccept(LightAutomaton a) {
-    LightAutomaton.Builder builder = new LightAutomaton.Builder();
-
-    // NOTE: not quite the same thing as what SpecialOperations.reverse does:
-    Transition t = new Transition();
-    int numStates = a.getNumStates();
-    for(int s=0;s<numStates;s++) {
-      builder.createState();
-    }
-    for(int s=0;s<numStates;s++) {
-      int count = a.initTransition(s, t);
-      for(int i=0;i<count;i++) {
-        a.getNextTransition(t);
-        builder.addTransition(t.dest, s, t.min, t.max);
-      }
-    }
-    LightAutomaton a2 = builder.finish();
-
-    LinkedList<Integer> workList = new LinkedList<>();
-    BitSet live = new BitSet(numStates);
-    for (int s : a.getAcceptStates()) {
-      live.set(s);
-      workList.add(s);
-    }
-
-    while (workList.isEmpty() == false) {
-      int s = workList.removeFirst();
-      int count = a2.initTransition(s, t);
-      for(int i=0;i<count;i++) {
-        a2.getNextTransition(t);
-        if (live.get(t.dest) == false) {
-          live.set(t.dest);
-          workList.add(t.dest);
-        }
-      }
-    }
-
-    return live;
-  }
-
-  /**
-   * Removes transitions to dead states (a state is "dead" if it is not
-   * reachable from the initial state or no accept state is reachable from it.)
-   */
-  public static LightAutomaton removeDeadStates(LightAutomaton a) {
-    int numStates = a.getNumStates();
-    BitSet liveSet = getLiveStates(a);
-
-    int[] map = new int[numStates];
-
-    LightAutomaton result = new LightAutomaton();
-    //System.out.println("liveSet: " + liveSet + " numStates=" + numStates);
-    for(int i=0;i<numStates;i++) {
-      if (liveSet.get(i)) {
-        map[i] = result.createState();
-        result.setAccept(map[i], a.isAccept(i));
-      }
-    }
-
-    Transition t = new Transition();
-
-    for (int i=0;i<numStates;i++) {
-      if (liveSet.get(i)) {
-        int numTransitions = a.initTransition(i, t);
-        // filter out transitions to dead states:
-        for(int j=0;j<numTransitions;j++) {
-          a.getNextTransition(t);
-          if (liveSet.get(t.dest)) {
-            result.addTransition(map[i], map[t.dest], t.min, t.max);
-          }
-        }
-      }
-    }
-
-    result.finishState();
-    assert hasDeadStates(result) == false;
-    return result;
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/ByteRunAutomaton.java b/lucene/core/src/java/org/apache/lucene/util/automaton/ByteRunAutomaton.java
index 8d0e2d2..5804ef1 100644
--- a/lucene/core/src/java/org/apache/lucene/util/automaton/ByteRunAutomaton.java
+++ b/lucene/core/src/java/org/apache/lucene/util/automaton/ByteRunAutomaton.java
@@ -23,13 +23,13 @@ package org.apache.lucene.util.automaton;
 public class ByteRunAutomaton extends RunAutomaton {
 
   /** Converts incoming automaton to byte-based (UTF32ToUTF8) first */
-  public ByteRunAutomaton(LightAutomaton a) {
+  public ByteRunAutomaton(Automaton a) {
     this(a, false);
   }
   
   /** expert: if utf8 is true, the input is already byte-based */
-  public ByteRunAutomaton(LightAutomaton a, boolean utf8) {
-    super(utf8 ? a : new UTF32ToUTF8Light().convert(a), 256, true);
+  public ByteRunAutomaton(Automaton a, boolean utf8) {
+    super(utf8 ? a : new UTF32ToUTF8().convert(a), 256, true);
   }
 
   /**
diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/CharacterRunAutomaton.java b/lucene/core/src/java/org/apache/lucene/util/automaton/CharacterRunAutomaton.java
index f98dbf0..8582870 100644
--- a/lucene/core/src/java/org/apache/lucene/util/automaton/CharacterRunAutomaton.java
+++ b/lucene/core/src/java/org/apache/lucene/util/automaton/CharacterRunAutomaton.java
@@ -23,7 +23,7 @@ package org.apache.lucene.util.automaton;
 public class CharacterRunAutomaton extends RunAutomaton {
 
   /** Sole constructor. */
-  public CharacterRunAutomaton(LightAutomaton a) {
+  public CharacterRunAutomaton(Automaton a) {
     super(a, Character.MAX_CODE_POINT, false);
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton.java b/lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton.java
index 066fbaf..0e934d8 100644
--- a/lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton.java
+++ b/lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton.java
@@ -71,13 +71,15 @@ public class CompiledAutomaton {
    * {@link #runAutomaton}. 
    * Only valid for {@link AUTOMATON_TYPE#NORMAL}.
    */
-  public final LightAutomaton lightAutomaton;
+  public final Automaton automaton;
+
   /**
    * Shared common suffix accepted by the automaton. Only valid
    * for {@link AUTOMATON_TYPE#NORMAL}, and only when the
    * automaton accepts an infinite language.
    */
   public final BytesRef commonSuffixRef;
+
   /**
    * Indicates if the automaton accepts a finite set of strings.
    * Null if this was not computed.
@@ -85,11 +87,11 @@ public class CompiledAutomaton {
    */
   public final Boolean finite;
 
-  public CompiledAutomaton(LightAutomaton automaton) {
+  public CompiledAutomaton(Automaton automaton) {
     this(automaton, null, true);
   }
 
-  public CompiledAutomaton(LightAutomaton automaton, Boolean finite, boolean simplify) {
+  public CompiledAutomaton(Automaton automaton, Boolean finite, boolean simplify) {
 
     if (simplify) {
 
@@ -97,33 +99,33 @@ public class CompiledAutomaton {
       // if so, don't create a runAutomaton.  Note that on a
       // large automaton these tests could be costly:
 
-      if (BasicOperations.isEmpty(automaton)) {
+      if (Operations.isEmpty(automaton)) {
         // matches nothing
         type = AUTOMATON_TYPE.NONE;
         term = null;
         commonSuffixRef = null;
         runAutomaton = null;
-        lightAutomaton = null;
+        this.automaton = null;
         this.finite = null;
         return;
       // NOTE: only approximate, because automaton may not be minimal:
-      } else if (BasicOperations.isTotal(automaton)) {
+      } else if (Operations.isTotal(automaton)) {
         // matches all possible strings
         type = AUTOMATON_TYPE.ALL;
         term = null;
         commonSuffixRef = null;
         runAutomaton = null;
-        lightAutomaton = null;
+        this.automaton = null;
         this.finite = null;
         return;
       } else {
 
-        automaton = BasicOperations.determinize(automaton);
+        automaton = Operations.determinize(automaton);
 
-        final String commonPrefix = SpecialOperations.getCommonPrefix(automaton);
+        final String commonPrefix = Operations.getCommonPrefix(automaton);
         final String singleton;
 
-        if (commonPrefix.length() > 0 && BasicOperations.sameLanguage(automaton, BasicAutomata.makeStringLight(commonPrefix))) {
+        if (commonPrefix.length() > 0 && Operations.sameLanguage(automaton, Automata.makeString(commonPrefix))) {
           singleton = commonPrefix;
         } else {
           singleton = null;
@@ -135,20 +137,20 @@ public class CompiledAutomaton {
           term = new BytesRef(singleton);
           commonSuffixRef = null;
           runAutomaton = null;
-          lightAutomaton = null;
+          this.automaton = null;
           this.finite = null;
           return;
         } else if (commonPrefix.length() > 0) {
-          LightAutomaton other = BasicOperations.concatenateLight(BasicAutomata.makeStringLight(commonPrefix), BasicAutomata.makeAnyStringLight());
-          other = BasicOperations.determinize(other);
-          assert BasicOperations.hasDeadStates(other) == false;
-          if (BasicOperations.sameLanguage(automaton, other)) {
+          Automaton other = Operations.concatenate(Automata.makeString(commonPrefix), Automata.makeAnyString());
+          other = Operations.determinize(other);
+          assert Operations.hasDeadStates(other) == false;
+          if (Operations.sameLanguage(automaton, other)) {
             // matches a constant prefix
             type = AUTOMATON_TYPE.PREFIX;
             term = new BytesRef(commonPrefix);
             commonSuffixRef = null;
             runAutomaton = null;
-            lightAutomaton = null;
+            this.automaton = null;
             this.finite = null;
             return;
           }
@@ -160,20 +162,20 @@ public class CompiledAutomaton {
     term = null;
 
     if (finite == null) {
-      this.finite = SpecialOperations.isFinite(automaton);
+      this.finite = Operations.isFinite(automaton);
     } else {
       this.finite = finite;
     }
 
-    LightAutomaton utf8 = new UTF32ToUTF8Light().convert(automaton);
+    Automaton utf8 = new UTF32ToUTF8().convert(automaton);
     if (this.finite) {
       commonSuffixRef = null;
     } else {
-      commonSuffixRef = SpecialOperations.getCommonSuffixBytesRef(utf8);
+      commonSuffixRef = Operations.getCommonSuffixBytesRef(utf8);
     }
     runAutomaton = new ByteRunAutomaton(utf8, true);
 
-    lightAutomaton = runAutomaton.automaton;
+    this.automaton = runAutomaton.automaton;
   }
 
   private Transition transition = new Transition();
@@ -182,13 +184,13 @@ public class CompiledAutomaton {
 
   private BytesRef addTail(int state, BytesRef term, int idx, int leadLabel) {
     //System.out.println("addTail state=" + state + " term=" + term.utf8ToString() + " idx=" + idx + " leadLabel=" + (char) leadLabel);
-    //System.out.println(lightAutomaton.toDot());
+    //System.out.println(automaton.toDot());
     // Find biggest transition that's < label
     // TODO: use binary search here
     int maxIndex = -1;
-    int numTransitions = lightAutomaton.initTransition(state, transition);
+    int numTransitions = automaton.initTransition(state, transition);
     for(int i=0;i<numTransitions;i++) {
-      lightAutomaton.getNextTransition(transition);
+      automaton.getNextTransition(transition);
       if (transition.min < leadLabel) {
         maxIndex = i;
       } else {
@@ -200,7 +202,7 @@ public class CompiledAutomaton {
     //System.out.println("  maxIndex=" + maxIndex);
 
     assert maxIndex != -1;
-    lightAutomaton.getTransition(state, maxIndex, transition);
+    automaton.getTransition(state, maxIndex, transition);
 
     // Append floorLabel
     final int floorLabel;
@@ -222,7 +224,7 @@ public class CompiledAutomaton {
 
     // Push down to last accept state
     while (true) {
-      numTransitions = lightAutomaton.getNumTransitions(state);
+      numTransitions = automaton.getNumTransitions(state);
       if (numTransitions == 0) {
         //System.out.println("state=" + state + " 0 trans");
         assert runAutomaton.isAccept(state);
@@ -233,7 +235,7 @@ public class CompiledAutomaton {
         // We are pushing "top" -- so get last label of
         // last transition:
         //System.out.println("get state=" + state + " numTrans=" + numTransitions);
-        lightAutomaton.getTransition(state, numTransitions-1, transition);
+        automaton.getTransition(state, numTransitions-1, transition);
         if (idx >= term.bytes.length) {
           term.grow(1+idx);
         }
@@ -321,14 +323,14 @@ public class CompiledAutomaton {
         // Pop back to a state that has a transition
         // <= our label:
         while (true) {
-          int numTransitions = lightAutomaton.getNumTransitions(state);
+          int numTransitions = automaton.getNumTransitions(state);
           if (numTransitions == 0) {
             assert runAutomaton.isAccept(state);
             output.length = idx;
             //if (DEBUG) System.out.println("  return " + output.utf8ToString());
             return output;
           } else {
-            lightAutomaton.getTransition(state, 0, transition);
+            automaton.getTransition(state, 0, transition);
 
             if (label-1 < transition.min) {
 
@@ -374,15 +376,15 @@ public class CompiledAutomaton {
     StringBuilder b = new StringBuilder("digraph CompiledAutomaton {\n");
     b.append("  rankdir = LR;\n");
     int initial = 0;
-    for (int i = 0; i < lightAutomaton.getNumStates(); i++) {
+    for (int i = 0; i < automaton.getNumStates(); i++) {
       b.append("  ").append(i);
-      if (lightAutomaton.isAccept(i)) b.append(" [shape=doublecircle,label=\"\"];\n");
+      if (automaton.isAccept(i)) b.append(" [shape=doublecircle,label=\"\"];\n");
       else b.append(" [shape=circle,label=\"\"];\n");
       if (i == 0) {
         b.append("  initial [shape=plaintext,label=\"\"];\n");
         b.append("  initial -> ").append(i).append("\n");
       }
-      int numTransitions = lightAutomaton.initTransition(i, transition);
+      int numTransitions = automaton.initTransition(i, transition);
       for (int j = 0; j < numTransitions; j++) {
         b.append("  ").append(i);
         b.append(" -> ");
@@ -392,7 +394,7 @@ public class CompiledAutomaton {
           b.append("-");
           b.append(transition.max);
         }
-        lightAutomaton.getNextTransition(transition);
+        automaton.getNextTransition(transition);
       }
     }
     return b.append("}\n").toString();
diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/DaciukMihovAutomatonBuilder.java b/lucene/core/src/java/org/apache/lucene/util/automaton/DaciukMihovAutomatonBuilder.java
new file mode 100644
index 0000000..ce07d83
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/util/automaton/DaciukMihovAutomatonBuilder.java
@@ -0,0 +1,334 @@
+package org.apache.lucene.util.automaton;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.*;
+
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.CharsRef;
+import org.apache.lucene.util.UnicodeUtil;
+
+/**
+ * Builds a minimal, deterministic {@link Automaton} that accepts a set of 
+ * strings. The algorithm requires sorted input data, but is very fast 
+ * (nearly linear with the input size).
+ * 
+ * @see #build(Collection)
+ * @see BasicAutomata#makeStringUnion(Collection)
+ */
+final class DaciukMihovAutomatonBuilder {
+  /**
+   * DFSA state with <code>char</code> labels on transitions.
+   */
+  private final static class State {
+    
+    /** An empty set of labels. */
+    private final static int[] NO_LABELS = new int[0];
+    
+    /** An empty set of states. */
+    private final static State[] NO_STATES = new State[0];
+    
+    /**
+     * Labels of outgoing transitions. Indexed identically to {@link #states}.
+     * Labels must be sorted lexicographically.
+     */
+    int[] labels = NO_LABELS;
+    
+    /**
+     * States reachable from outgoing transitions. Indexed identically to
+     * {@link #labels}.
+     */
+    State[] states = NO_STATES;
+    
+    /**
+     * <code>true</code> if this state corresponds to the end of at least one
+     * input sequence.
+     */
+    boolean is_final;
+    
+    /**
+     * Returns the target state of a transition leaving this state and labeled
+     * with <code>label</code>. If no such transition exists, returns
+     * <code>null</code>.
+     */
+    State getState(int label) {
+      final int index = Arrays.binarySearch(labels, label);
+      return index >= 0 ? states[index] : null;
+    }
+    
+    /**
+     * Two states are equal if:
+     * <ul>
+     * <li>they have an identical number of outgoing transitions, labeled with
+     * the same labels</li>
+     * <li>corresponding outgoing transitions lead to the same states (to states
+     * with an identical right-language).
+     * </ul>
+     */
+    @Override
+    public boolean equals(Object obj) {
+      final State other = (State) obj;
+      return is_final == other.is_final
+          && Arrays.equals(this.labels, other.labels)
+          && referenceEquals(this.states, other.states);
+    }
+    
+    /**
+     * Compute the hash code of the <i>current</i> status of this state.
+     */
+    @Override
+    public int hashCode() {
+      int hash = is_final ? 1 : 0;
+      
+      hash ^= hash * 31 + this.labels.length;
+      for (int c : this.labels)
+        hash ^= hash * 31 + c;
+      
+      /*
+       * Compare the right-language of this state using reference-identity of
+       * outgoing states. This is possible because states are interned (stored
+       * in registry) and traversed in post-order, so any outgoing transitions
+       * are already interned.
+       */
+      for (State s : this.states) {
+        hash ^= System.identityHashCode(s);
+      }
+      
+      return hash;
+    }
+    
+    /**
+     * Return <code>true</code> if this state has any children (outgoing
+     * transitions).
+     */
+    boolean hasChildren() {
+      return labels.length > 0;
+    }
+
+    /**
+     * Create a new outgoing transition labeled <code>label</code> and return
+     * the newly created target state for this transition.
+     */
+    State newState(int label) {
+      assert Arrays.binarySearch(labels, label) < 0 : "State already has transition labeled: "
+          + label;
+      
+      labels = Arrays.copyOf(labels, labels.length + 1);
+      states = Arrays.copyOf(states, states.length + 1);
+
+      labels[labels.length - 1] = label;
+      return states[states.length - 1] = new State();
+    }
+    
+    /**
+     * Return the most recent transitions's target state.
+     */
+    State lastChild() {
+      assert hasChildren() : "No outgoing transitions.";
+      return states[states.length - 1];
+    }
+    
+    /**
+     * Return the associated state if the most recent transition is labeled with
+     * <code>label</code>.
+     */
+    State lastChild(int label) {
+      final int index = labels.length - 1;
+      State s = null;
+      if (index >= 0 && labels[index] == label) {
+        s = states[index];
+      }
+      assert s == getState(label);
+      return s;
+    }
+    
+    /**
+     * Replace the last added outgoing transition's target state with the given
+     * state.
+     */
+    void replaceLastChild(State state) {
+      assert hasChildren() : "No outgoing transitions.";
+      states[states.length - 1] = state;
+    }
+    
+    /**
+     * Compare two lists of objects for reference-equality.
+     */
+    private static boolean referenceEquals(Object[] a1, Object[] a2) {
+      if (a1.length != a2.length) { 
+        return false;
+      }
+
+      for (int i = 0; i < a1.length; i++) {
+        if (a1[i] != a2[i]) { 
+          return false;
+        }
+      }
+
+      return true;
+    }
+  }
+  
+  /**
+   * A "registry" for state interning.
+   */
+  private HashMap<State,State> stateRegistry = new HashMap<>();
+  
+  /**
+   * Root automaton state.
+   */
+  private State root = new State();
+  
+  /**
+   * Previous sequence added to the automaton in {@link #add(CharsRef)}.
+   */
+  private CharsRef previous;
+
+  /**
+   * A comparator used for enforcing sorted UTF8 order, used in assertions only.
+   */
+  @SuppressWarnings("deprecation")
+  private static final Comparator<CharsRef> comparator = CharsRef.getUTF16SortedAsUTF8Comparator();
+
+  /**
+   * Add another character sequence to this automaton. The sequence must be
+   * lexicographically larger or equal compared to any previous sequences added
+   * to this automaton (the input must be sorted).
+   */
+  public void add(CharsRef current) {
+    assert stateRegistry != null : "Automaton already built.";
+    assert previous == null
+        || comparator.compare(previous, current) <= 0 : "Input must be in sorted UTF-8 order: "
+        + previous + " >= " + current;
+    assert setPrevious(current);
+
+    // Descend in the automaton (find matching prefix).
+    int pos = 0, max = current.length();
+    State next, state = root;
+    while (pos < max && (next = state.lastChild(Character.codePointAt(current, pos))) != null) {
+      state = next;
+      // todo, optimize me
+      pos += Character.charCount(Character.codePointAt(current, pos));
+    }
+    
+    if (state.hasChildren()) replaceOrRegister(state);
+    
+    addSuffix(state, current, pos);
+  }
+  
+  /**
+   * Finalize the automaton and return the root state. No more strings can be
+   * added to the builder after this call.
+   * 
+   * @return Root automaton state.
+   */
+  public State complete() {
+    if (this.stateRegistry == null) throw new IllegalStateException();
+    
+    if (root.hasChildren()) replaceOrRegister(root);
+    
+    stateRegistry = null;
+    return root;
+  }
+  
+  /**
+   * Internal recursive traversal for conversion.
+   */
+  private static int convert(Automaton.Builder a, State s,
+      IdentityHashMap<State,Integer> visited) {
+
+    Integer converted = visited.get(s);
+    if (converted != null) {
+      return converted;
+    }
+    
+    converted = a.createState();
+    a.setAccept(converted, s.is_final);
+    
+    visited.put(s, converted);
+    int i = 0;
+    int[] labels = s.labels;
+    for (DaciukMihovAutomatonBuilder.State target : s.states) {
+      a.addTransition(converted, convert(a, target, visited), labels[i++]);
+    }
+    
+    return converted;
+  }
+
+  /**
+   * Build a minimal, deterministic automaton from a sorted list of {@link BytesRef} representing
+   * strings in UTF-8. These strings must be binary-sorted.
+   */
+  public static Automaton build(Collection<BytesRef> input) {
+    final DaciukMihovAutomatonBuilder builder = new DaciukMihovAutomatonBuilder();
+    
+    CharsRef scratch = new CharsRef();
+    for (BytesRef b : input) {
+      UnicodeUtil.UTF8toUTF16(b, scratch);
+      builder.add(scratch);
+    }
+    
+    Automaton.Builder a = new Automaton.Builder();
+    convert(a,
+        builder.complete(), 
+        new IdentityHashMap<State,Integer>());
+
+    return a.finish();
+  }
+
+  /**
+   * Copy <code>current</code> into an internal buffer.
+   */
+  private boolean setPrevious(CharsRef current) {
+    // don't need to copy, once we fix https://issues.apache.org/jira/browse/LUCENE-3277
+    // still, called only from assert
+    previous = CharsRef.deepCopyOf(current);
+    return true;
+  }
+  
+  /**
+   * Replace last child of <code>state</code> with an already registered state
+   * or stateRegistry the last child state.
+   */
+  private void replaceOrRegister(State state) {
+    final State child = state.lastChild();
+    
+    if (child.hasChildren()) replaceOrRegister(child);
+    
+    final State registered = stateRegistry.get(child);
+    if (registered != null) {
+      state.replaceLastChild(registered);
+    } else {
+      stateRegistry.put(child, child);
+    }
+  }
+
+  /**
+   * Add a suffix of <code>current</code> starting at <code>fromIndex</code>
+   * (inclusive) to state <code>state</code>.
+   */
+  private void addSuffix(State state, CharSequence current, int fromIndex) {
+    final int len = current.length();
+    while (fromIndex < len) {
+      int cp = Character.codePointAt(current, fromIndex);
+      state = state.newState(cp);
+      fromIndex += Character.charCount(cp);
+    }
+    state.is_final = true;
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/DaciukMihovAutomatonBuilderLight.java b/lucene/core/src/java/org/apache/lucene/util/automaton/DaciukMihovAutomatonBuilderLight.java
deleted file mode 100644
index 7af2eb5..0000000
--- a/lucene/core/src/java/org/apache/lucene/util/automaton/DaciukMihovAutomatonBuilderLight.java
+++ /dev/null
@@ -1,334 +0,0 @@
-package org.apache.lucene.util.automaton;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.*;
-
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.CharsRef;
-import org.apache.lucene.util.UnicodeUtil;
-
-/**
- * Builds a minimal, deterministic {@link Automaton} that accepts a set of 
- * strings. The algorithm requires sorted input data, but is very fast 
- * (nearly linear with the input size).
- * 
- * @see #build(Collection)
- * @see BasicAutomata#makeStringUnion(Collection)
- */
-final class DaciukMihovAutomatonBuilderLight {
-  /**
-   * DFSA state with <code>char</code> labels on transitions.
-   */
-  private final static class State {
-    
-    /** An empty set of labels. */
-    private final static int[] NO_LABELS = new int[0];
-    
-    /** An empty set of states. */
-    private final static State[] NO_STATES = new State[0];
-    
-    /**
-     * Labels of outgoing transitions. Indexed identically to {@link #states}.
-     * Labels must be sorted lexicographically.
-     */
-    int[] labels = NO_LABELS;
-    
-    /**
-     * States reachable from outgoing transitions. Indexed identically to
-     * {@link #labels}.
-     */
-    State[] states = NO_STATES;
-    
-    /**
-     * <code>true</code> if this state corresponds to the end of at least one
-     * input sequence.
-     */
-    boolean is_final;
-    
-    /**
-     * Returns the target state of a transition leaving this state and labeled
-     * with <code>label</code>. If no such transition exists, returns
-     * <code>null</code>.
-     */
-    State getState(int label) {
-      final int index = Arrays.binarySearch(labels, label);
-      return index >= 0 ? states[index] : null;
-    }
-    
-    /**
-     * Two states are equal if:
-     * <ul>
-     * <li>they have an identical number of outgoing transitions, labeled with
-     * the same labels</li>
-     * <li>corresponding outgoing transitions lead to the same states (to states
-     * with an identical right-language).
-     * </ul>
-     */
-    @Override
-    public boolean equals(Object obj) {
-      final State other = (State) obj;
-      return is_final == other.is_final
-          && Arrays.equals(this.labels, other.labels)
-          && referenceEquals(this.states, other.states);
-    }
-    
-    /**
-     * Compute the hash code of the <i>current</i> status of this state.
-     */
-    @Override
-    public int hashCode() {
-      int hash = is_final ? 1 : 0;
-      
-      hash ^= hash * 31 + this.labels.length;
-      for (int c : this.labels)
-        hash ^= hash * 31 + c;
-      
-      /*
-       * Compare the right-language of this state using reference-identity of
-       * outgoing states. This is possible because states are interned (stored
-       * in registry) and traversed in post-order, so any outgoing transitions
-       * are already interned.
-       */
-      for (State s : this.states) {
-        hash ^= System.identityHashCode(s);
-      }
-      
-      return hash;
-    }
-    
-    /**
-     * Return <code>true</code> if this state has any children (outgoing
-     * transitions).
-     */
-    boolean hasChildren() {
-      return labels.length > 0;
-    }
-
-    /**
-     * Create a new outgoing transition labeled <code>label</code> and return
-     * the newly created target state for this transition.
-     */
-    State newState(int label) {
-      assert Arrays.binarySearch(labels, label) < 0 : "State already has transition labeled: "
-          + label;
-      
-      labels = Arrays.copyOf(labels, labels.length + 1);
-      states = Arrays.copyOf(states, states.length + 1);
-
-      labels[labels.length - 1] = label;
-      return states[states.length - 1] = new State();
-    }
-    
-    /**
-     * Return the most recent transitions's target state.
-     */
-    State lastChild() {
-      assert hasChildren() : "No outgoing transitions.";
-      return states[states.length - 1];
-    }
-    
-    /**
-     * Return the associated state if the most recent transition is labeled with
-     * <code>label</code>.
-     */
-    State lastChild(int label) {
-      final int index = labels.length - 1;
-      State s = null;
-      if (index >= 0 && labels[index] == label) {
-        s = states[index];
-      }
-      assert s == getState(label);
-      return s;
-    }
-    
-    /**
-     * Replace the last added outgoing transition's target state with the given
-     * state.
-     */
-    void replaceLastChild(State state) {
-      assert hasChildren() : "No outgoing transitions.";
-      states[states.length - 1] = state;
-    }
-    
-    /**
-     * Compare two lists of objects for reference-equality.
-     */
-    private static boolean referenceEquals(Object[] a1, Object[] a2) {
-      if (a1.length != a2.length) { 
-        return false;
-      }
-
-      for (int i = 0; i < a1.length; i++) {
-        if (a1[i] != a2[i]) { 
-          return false;
-        }
-      }
-
-      return true;
-    }
-  }
-  
-  /**
-   * A "registry" for state interning.
-   */
-  private HashMap<State,State> stateRegistry = new HashMap<>();
-  
-  /**
-   * Root automaton state.
-   */
-  private State root = new State();
-  
-  /**
-   * Previous sequence added to the automaton in {@link #add(CharsRef)}.
-   */
-  private CharsRef previous;
-
-  /**
-   * A comparator used for enforcing sorted UTF8 order, used in assertions only.
-   */
-  @SuppressWarnings("deprecation")
-  private static final Comparator<CharsRef> comparator = CharsRef.getUTF16SortedAsUTF8Comparator();
-
-  /**
-   * Add another character sequence to this automaton. The sequence must be
-   * lexicographically larger or equal compared to any previous sequences added
-   * to this automaton (the input must be sorted).
-   */
-  public void add(CharsRef current) {
-    assert stateRegistry != null : "Automaton already built.";
-    assert previous == null
-        || comparator.compare(previous, current) <= 0 : "Input must be in sorted UTF-8 order: "
-        + previous + " >= " + current;
-    assert setPrevious(current);
-
-    // Descend in the automaton (find matching prefix).
-    int pos = 0, max = current.length();
-    State next, state = root;
-    while (pos < max && (next = state.lastChild(Character.codePointAt(current, pos))) != null) {
-      state = next;
-      // todo, optimize me
-      pos += Character.charCount(Character.codePointAt(current, pos));
-    }
-    
-    if (state.hasChildren()) replaceOrRegister(state);
-    
-    addSuffix(state, current, pos);
-  }
-  
-  /**
-   * Finalize the automaton and return the root state. No more strings can be
-   * added to the builder after this call.
-   * 
-   * @return Root automaton state.
-   */
-  public State complete() {
-    if (this.stateRegistry == null) throw new IllegalStateException();
-    
-    if (root.hasChildren()) replaceOrRegister(root);
-    
-    stateRegistry = null;
-    return root;
-  }
-  
-  /**
-   * Internal recursive traversal for conversion.
-   */
-  private static int convert(LightAutomaton.Builder a, State s,
-      IdentityHashMap<State,Integer> visited) {
-
-    Integer converted = visited.get(s);
-    if (converted != null) {
-      return converted;
-    }
-    
-    converted = a.createState();
-    a.setAccept(converted, s.is_final);
-    
-    visited.put(s, converted);
-    int i = 0;
-    int[] labels = s.labels;
-    for (DaciukMihovAutomatonBuilderLight.State target : s.states) {
-      a.addTransition(converted, convert(a, target, visited), labels[i++]);
-    }
-    
-    return converted;
-  }
-
-  /**
-   * Build a minimal, deterministic automaton from a sorted list of {@link BytesRef} representing
-   * strings in UTF-8. These strings must be binary-sorted.
-   */
-  public static LightAutomaton build(Collection<BytesRef> input) {
-    final DaciukMihovAutomatonBuilderLight builder = new DaciukMihovAutomatonBuilderLight();
-    
-    CharsRef scratch = new CharsRef();
-    for (BytesRef b : input) {
-      UnicodeUtil.UTF8toUTF16(b, scratch);
-      builder.add(scratch);
-    }
-    
-    LightAutomaton.Builder a = new LightAutomaton.Builder();
-    convert(a,
-        builder.complete(), 
-        new IdentityHashMap<State,Integer>());
-
-    return a.finish();
-  }
-
-  /**
-   * Copy <code>current</code> into an internal buffer.
-   */
-  private boolean setPrevious(CharsRef current) {
-    // don't need to copy, once we fix https://issues.apache.org/jira/browse/LUCENE-3277
-    // still, called only from assert
-    previous = CharsRef.deepCopyOf(current);
-    return true;
-  }
-  
-  /**
-   * Replace last child of <code>state</code> with an already registered state
-   * or stateRegistry the last child state.
-   */
-  private void replaceOrRegister(State state) {
-    final State child = state.lastChild();
-    
-    if (child.hasChildren()) replaceOrRegister(child);
-    
-    final State registered = stateRegistry.get(child);
-    if (registered != null) {
-      state.replaceLastChild(registered);
-    } else {
-      stateRegistry.put(child, child);
-    }
-  }
-
-  /**
-   * Add a suffix of <code>current</code> starting at <code>fromIndex</code>
-   * (inclusive) to state <code>state</code>.
-   */
-  private void addSuffix(State state, CharSequence current, int fromIndex) {
-    final int len = current.length();
-    while (fromIndex < len) {
-      int cp = Character.codePointAt(current, fromIndex);
-      state = state.newState(cp);
-      fromIndex += Character.charCount(cp);
-    }
-    state.is_final = true;
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata.java b/lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata.java
index fb26eaf..afb52aa 100644
--- a/lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata.java
+++ b/lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata.java
@@ -126,14 +126,14 @@ public class LevenshteinAutomata {
    * </ul>
    * </p>
    */
-  public LightAutomaton toAutomaton(int n) {
+  public Automaton toAutomaton(int n) {
     return toAutomaton(n, "");
   }
 
-  public LightAutomaton toAutomaton(int n, String prefix) {
+  public Automaton toAutomaton(int n, String prefix) {
     assert prefix != null;
     if (n == 0) {
-      return BasicAutomata.makeStringLight(prefix + UnicodeUtil.newString(word, 0, word.length));
+      return Automata.makeString(prefix + UnicodeUtil.newString(word, 0, word.length));
     }
     
     if (n >= descriptions.length)
@@ -144,7 +144,7 @@ public class LevenshteinAutomata {
     // the number of states is based on the length of the word and n
     int numStates = description.size();
 
-    LightAutomaton a = new LightAutomaton();
+    Automaton a = new Automaton();
     int lastState;
     if (prefix != null) {
       // Insert prefix
diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/LightAutomaton.java b/lucene/core/src/java/org/apache/lucene/util/automaton/LightAutomaton.java
deleted file mode 100644
index 1be9227..0000000
--- a/lucene/core/src/java/org/apache/lucene/util/automaton/LightAutomaton.java
+++ /dev/null
@@ -1,810 +0,0 @@
-package org.apache.lucene.util.automaton;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-//import java.io.IOException;
-//import java.io.PrintWriter;
-import java.util.Arrays;
-import java.util.HashSet;
-import java.util.Set;
-
-import org.apache.lucene.util.ArrayUtil;
-import org.apache.lucene.util.InPlaceMergeSorter;
-import org.apache.lucene.util.Sorter;
-
-// nocommit make tests that do the same ops w/ old and new and assertSameLang
-
-// TODO
-//   - could use packed int arrays instead
-//   - could encode dest w/ delta from to?
-
-/** Uses only int[]s to represent the automaton, but requires that all
- *  transitions for each state are added at once.  If this is too restrictive,
- *  use {@link #Builder} instead.  State 0 is always the
- *  initial state.
- *
- * @lucene.experimental */
-
-// nocommit rename to Automaton once everything is cutover
-
-public class LightAutomaton {
-  private int nextState;
-
-  /** Where we next write to in int[] transitions; this
-   *  increments by 3 for each added transition because we
-   *  pack min, max, dest in sequence. */
-  private int nextTransition;
-
-  /** Current state we are adding transitions to; the caller
-   *  must add all transitions for this state before moving
-   *  onto another state. */
-  private int curState = -1;
-
-  /** Index in the transitions array, where this states
-   *  leaving transitions are stored, or -1 if this state
-   *  has not added any transitions yet, followed by number
-   *  of transitions. */
-  private int[] states = new int[4];
-
-  /** Holds toState, min, max for each transition: */
-  private int[] transitions = new int[6];
-
-  private final Set<Integer> finalStates = new HashSet<Integer>();
-
-  /** True if no state has two transitions leaving with the same label. */
-  private boolean deterministic = true;
-
-  public int createState() {
-    growStates();
-    int state = nextState/2;
-    states[nextState] = -1;
-    nextState += 2;
-    return state;
-  }
-
-  /** Mark this state as an accept state. */
-  public void setAccept(int state, boolean isAccept) {
-    if (state >= getNumStates()) {
-      throw new IllegalArgumentException("state=" + state + " is out of bounds (numStates=" + getNumStates() + ")");
-    }
-    if (isAccept) {
-      finalStates.add(state);
-    } else {
-      finalStates.remove(state);
-    }
-  }
-
-  /** Sugar, but object-heavy; it's better to iterate instead. */
-  public Transition[][] getSortedTransitions() {
-    int numStates = getNumStates();
-    Transition[][] transitions = new Transition[numStates][];
-    for(int s=0;s<numStates;s++) {
-      int numTransitions = getNumTransitions(s);
-      transitions[s] = new Transition[numTransitions];
-      for(int t=0;t<numTransitions;t++) {
-        Transition transition = new Transition();
-        getTransition(s, t, transition);
-        transitions[s][t] = transition;
-      }
-    }
-
-    return transitions;
-  }
-
-  public Set<Integer> getAcceptStates() {
-    return finalStates;
-  }
-
-  /** Returns true if this state is an accept state. */
-  public boolean isAccept(int state) {
-    return finalStates.contains(state);
-  }
-
-  public void addTransition(int source, int dest, int label) {
-    addTransition(source, dest, label, label);
-  }
-
-  public void addTransition(int source, int dest, int min, int max) {
-    assert nextTransition%3 == 0;
-
-    if (source >= nextState/2) {
-      throw new IllegalArgumentException("source=" + source + " is out of bounds (maxState is " + (nextState/2-1) + ")");
-    }
-    if (dest >= nextState/2) {
-      throw new IllegalArgumentException("dest=" + dest + " is out of bounds (max state is " + (nextState/2-1) + ")");
-    }
-
-    //System.out.println("  addTransition nextTransition=" + nextTransition + " source=" + source + " dest=" + dest + " min=" + min + " max=" + max);
-    growTransitions();
-    if (curState != source) {
-      //System.out.println("    newstate");
-      if (curState != -1) {
-        finishCurrentState();
-      }
-
-      // Move to next source:
-      curState = source;
-      if (states[2*curState] != -1) {
-        throw new IllegalStateException("from state (" + source + ") already had transitions added");
-      }
-      assert states[2*curState+1] == 0;
-      states[2*curState] = nextTransition;
-    }
-
-    transitions[nextTransition++] = dest;
-    transitions[nextTransition++] = min;
-    transitions[nextTransition++] = max;
-
-    // Increment transition count for this state
-    states[2*curState+1]++;
-  }
-
-  public void addEpsilon(int source, int dest) {
-    Transition t = new Transition();
-    int count = initTransition(dest, t);
-    for(int i=0;i<count;i++) {
-      getNextTransition(t);
-      addTransition(source, t.dest, t.min, t.max);
-    }
-    if (isAccept(dest)) {
-      setAccept(source, true);
-    }
-  }
-
-  /** Copies over all states/transitions from other.  The states numbers
-   *  are sequentially assigned (appended). */
-  public void copy(LightAutomaton other) {
-
-    int offset = getNumStates();
-    /*
-    int otherNumStates = other.getNumStates();
-    for(int s=0;s<otherNumStates;s++) {
-      createState();
-      setAccept(offset+s, other.isAccept(s));
-    }
-    Transition t = new Transition();
-    for(int s=0;s<otherNumStates;s++) {
-      int count = other.initTransition(s, t);
-      for(int i=0;i<count;i++) {
-        other.getNextTransition(t);
-        addTransition(offset + s, offset + t.dest, t.min, t.max);
-      }
-    }
-    */
-
-    // Bulk copy and then fixup the state pointers:
-    int stateOffset = getNumStates();
-    states = ArrayUtil.grow(states, nextState + other.nextState);
-    System.arraycopy(other.states, 0, states, nextState, other.nextState);
-    for(int i=0;i<other.nextState;i += 2) {
-      if (states[nextState+i] != -1) {
-        states[nextState+i] += nextTransition;
-      }
-      int state = i/2;
-    }
-    nextState += other.nextState;
-
-    for(int s : other.getAcceptStates()) {
-      setAccept(stateOffset+s, true);
-    }
-
-    // Bulk copy and then fixup dest for each transition:
-    transitions = ArrayUtil.grow(transitions, nextTransition + other.nextTransition);
-    System.arraycopy(other.transitions, 0, transitions, nextTransition, other.nextTransition);
-    for(int i=0;i<other.nextTransition;i += 3) {
-      transitions[nextTransition+i] += stateOffset;
-    }
-    nextTransition += other.nextTransition;
-
-    if (other.deterministic == false) {
-      deterministic = false;
-    }
-  }
-
-  /** Freezes the last state, reducing and sorting its transitions. */
-  private void finishCurrentState() {
-    int numTransitions = states[2*curState+1];
-    assert numTransitions > 0;
-
-    //System.out.println("finish curState=" + curState + " numTransitions=" + numTransitions);
-    int offset = states[2*curState];
-    int start = offset/3;
-    destMinMaxSorter.sort(start, start+numTransitions);
-
-    /*
-    for(int i=0;i<numTransitions;i++) {
-      System.out.println("  " + i + ": dest=" + transitions[offset+3*i] + " (accept?=" + isAccept(transitions[offset+3*i]) + ") min=" + transitions[offset+3*i+1] + " max=" + transitions[offset+3*i+2]);
-    }
-    */
-
-    // Reduce any "adjacent" transitions:
-    int upto = 0;
-    int min = -1;
-    int max = -1;
-    int dest = -1;
-
-    for(int i=0;i<numTransitions;i++) {
-      int tDest = transitions[offset+3*i];
-      int tMin = transitions[offset+3*i+1];
-      int tMax = transitions[offset+3*i+2];
-
-      if (dest == tDest) {
-        if (tMin <= max+1) {
-          if (tMax > max) {
-            max = tMax;
-          }
-        } else {
-          if (dest != -1) {
-            transitions[offset+3*upto] = dest;
-            transitions[offset+3*upto+1] = min;
-            transitions[offset+3*upto+2] = max;
-            upto++;
-          }
-          min = tMin;
-          max = tMax;
-        }
-      } else {
-        if (dest != -1) {
-          transitions[offset+3*upto] = dest;
-          transitions[offset+3*upto+1] = min;
-          transitions[offset+3*upto+2] = max;
-          upto++;
-        }
-        dest = tDest;
-        min = tMin;
-        max = tMax;
-      }
-    }
-
-    if (dest != -1) {
-      // Last transition
-      transitions[offset+3*upto] = dest;
-      transitions[offset+3*upto+1] = min;
-      transitions[offset+3*upto+2] = max;
-      upto++;
-    }
-
-    nextTransition -= (numTransitions-upto)*3;
-    states[2*curState+1] = upto;
-
-    // Sort transitions by min/max/dest:
-    minMaxDestSorter.sort(start, start+upto);
-
-    if (deterministic && upto > 1) {
-      int lastMax = transitions[offset+2];
-      for(int i=1;i<upto;i++) {
-        min = transitions[offset + 3*i + 1];
-        if (min <= lastMax) {
-          deterministic = false;
-          break;
-        }
-        lastMax = transitions[offset + 3*i + 2];
-      }
-    }
-
-    /*
-    System.out.println("after finish: reduce collapsed " + (numTransitions-upto) + " transitions");
-    for(int i=0;i<upto;i++) {
-      System.out.println("  " + i + ": dest=" + transitions[offset+3*i] + " (accept?=" + isAccept(transitions[offset+3*i]) + ") min=" + transitions[offset+3*i+1] + " max=" + transitions[offset+3*i+2]);
-    }
-    */
-  }
-
-  public boolean isDeterministic() {
-    return deterministic;
-  }
-
-  /** Finishes the current state; call this once you are done adding transitions for a state. */
-  public void finishState() {
-    if (curState != -1) {
-      //System.out.println("finish: finish current state " + curState);
-      finishCurrentState();
-      curState = -1;
-    }
-    // nocommit downsize the arrays?
-    //assert getNumStates() > 0;
-  }
-
-  public int getNumStates() {
-    return nextState/2;
-  }
-
-  public int getNumTransitions(int state) {
-    int count = states[2*state+1];
-    if (count == -1) {
-      return 0;
-    } else {
-      return count;
-    }
-  }
-
-  public int getDest(int state, int transitionIndex) {
-    return transitions[states[2*state]];
-  }
-
-  public int getMin(int state, int transitionIndex) {
-    return transitions[states[2*state]+1];
-  }
-
-  public int getMax(int state, int transitionIndex) {
-    return transitions[states[2*state]+2];
-  }
-
-  private void growStates() {
-    if (nextState+2 >= states.length) {
-      states = ArrayUtil.grow(states, nextState+2);
-    }
-  }
-
-  private void growTransitions() {
-    if (nextTransition+3 >= transitions.length) {
-      transitions = ArrayUtil.grow(transitions, nextTransition+3);
-    }
-  }
-
-  /** Sorts transitions by dest, ascending, then min label ascending, then max label ascending */
-  private final Sorter destMinMaxSorter = new InPlaceMergeSorter() {
-
-      private void swapOne(int i, int j) {
-        int x = transitions[i];
-        transitions[i] = transitions[j];
-        transitions[j] = x;
-      }
-
-      @Override
-      protected void swap(int i, int j) {
-        int iStart = 3*i;
-        int jStart = 3*j;
-        swapOne(iStart, jStart);
-        swapOne(iStart+1, jStart+1);
-        swapOne(iStart+2, jStart+2);
-      };
-
-      @Override
-      protected int compare(int i, int j) {
-        int iStart = 3*i;
-        int jStart = 3*j;
-
-        // First dest:
-        int iDest = transitions[iStart];
-        int jDest = transitions[jStart];
-        if (iDest < jDest) {
-          return -1;
-        } else if (iDest > jDest) {
-          return 1;
-        }
-
-        // Then min:
-        int iMin = transitions[iStart+1];
-        int jMin = transitions[jStart+1];
-        if (iMin < jMin) {
-          return -1;
-        } else if (iMin > jMin) {
-          return 1;
-        }
-
-        // Then max:
-        int iMax = transitions[iStart+2];
-        int jMax = transitions[jStart+2];
-        if (iMax < jMax) {
-          return -1;
-        } else if (iMax > jMax) {
-          return 1;
-        }
-
-        return 0;
-      }
-    };
-
-  /** Sorts transitions by min label, ascending, then max label ascending, then dest ascending */
-  private final Sorter minMaxDestSorter = new InPlaceMergeSorter() {
-
-      private void swapOne(int i, int j) {
-        int x = transitions[i];
-        transitions[i] = transitions[j];
-        transitions[j] = x;
-      }
-
-      @Override
-      protected void swap(int i, int j) {
-        int iStart = 3*i;
-        int jStart = 3*j;
-        swapOne(iStart, jStart);
-        swapOne(iStart+1, jStart+1);
-        swapOne(iStart+2, jStart+2);
-      };
-
-      @Override
-      protected int compare(int i, int j) {
-        int iStart = 3*i;
-        int jStart = 3*j;
-
-        // First min:
-        int iMin = transitions[iStart+1];
-        int jMin = transitions[jStart+1];
-        if (iMin < jMin) {
-          return -1;
-        } else if (iMin > jMin) {
-          return 1;
-        }
-
-        // Then max:
-        int iMax = transitions[iStart+2];
-        int jMax = transitions[jStart+2];
-        if (iMax < jMax) {
-          return -1;
-        } else if (iMax > jMax) {
-          return 1;
-        }
-
-        // Then dest:
-        int iDest = transitions[iStart];
-        int jDest = transitions[jStart];
-        if (iDest < jDest) {
-          return -1;
-        } else if (iDest > jDest) {
-          return 1;
-        }
-
-        return 0;
-      }
-    };
-
-  /** Initialize the provided Transition to iterate through all transitions
-   *  leaving the specified state.  You must call {@link #getNextTransition} to
-   *  get each transition.  Returns the number of transitions
-   *  leaving this state. */
-  public int initTransition(int state, Transition t) {
-    assert state < nextState/2: "state=" + state + " nextState=" + nextState;
-    t.source = state;
-    t.transitionUpto = states[2*state];
-    return getNumTransitions(state);
-  }
-
-  /** Iterate to the next transition after the provided one */
-  public void getNextTransition(Transition t) {
-    // Make sure there is still a transition left:
-    assert (t.transitionUpto+3 - states[2*t.source]) <= 3*states[2*t.source+1];
-    t.dest = transitions[t.transitionUpto++];
-    t.min = transitions[t.transitionUpto++];
-    t.max = transitions[t.transitionUpto++];
-  }
-
-  /** Fill the provided {@link Transition} with the index'th
-   *  transition leaving the specified state. */
-  public void getTransition(int state, int index, Transition t) {
-    int i = states[2*state] + 3*index;
-    t.source = state;
-    t.dest = transitions[i++];
-    t.min = transitions[i++];
-    t.max = transitions[i++];
-  }
-
-  static void appendCharString(int c, StringBuilder b) {
-    if (c >= 0x21 && c <= 0x7e && c != '\\' && c != '"') b.appendCodePoint(c);
-    else {
-      b.append("\\\\U");
-      String s = Integer.toHexString(c);
-      if (c < 0x10) b.append("0000000").append(s);
-      else if (c < 0x100) b.append("000000").append(s);
-      else if (c < 0x1000) b.append("00000").append(s);
-      else if (c < 0x10000) b.append("0000").append(s);
-      else if (c < 0x100000) b.append("000").append(s);
-      else if (c < 0x1000000) b.append("00").append(s);
-      else if (c < 0x10000000) b.append("0").append(s);
-      else b.append(s);
-    }
-  }
-
-  public LightAutomaton totalize() {
-    LightAutomaton result = new LightAutomaton();
-    int numStates = getNumStates();
-    for(int i=0;i<numStates;i++) {
-      result.createState();
-      result.setAccept(i, isAccept(i));
-    }
-
-    int deadState = result.createState();
-    result.addTransition(deadState, deadState, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);
-
-    Transition t = new Transition();
-    for(int i=0;i<numStates;i++) {
-      int maxi = Character.MIN_CODE_POINT;
-      int count = initTransition(i, t);
-      for(int j=0;j<count;j++) {
-        getNextTransition(t);
-        result.addTransition(i, t.dest, t.min, t.max);
-        if (t.min > maxi) {
-          result.addTransition(i, deadState, maxi, t.min-1);
-        }
-        if (t.max + 1 > maxi) {
-          maxi = t.max + 1;
-        }
-      }
-
-      if (maxi <= Character.MAX_CODE_POINT) {
-        result.addTransition(i, deadState, maxi, Character.MAX_CODE_POINT);
-      }
-    }
-    result.finishState();
-    return result;
-  }
-
-  // nocommit
-  /*
-  public void writeDot(String fileName) {
-    if (fileName.indexOf('/') == -1) {
-      fileName = "/l/la/lucene/core/" + fileName + ".dot";
-    }
-    try {
-      PrintWriter pw = new PrintWriter(fileName);
-      pw.println(toDot());
-      pw.close();
-    } catch (IOException ioe) {
-      throw new RuntimeException(ioe);
-    }
-  }
-  */
-
-  public String toDot() {
-    // TODO: breadth first search so we can see get layered output...
-
-    StringBuilder b = new StringBuilder();
-    b.append("digraph Automaton {\n");
-    b.append("  rankdir = LR\n");
-    final int numStates = getNumStates();
-    if (numStates > 0) {
-      b.append("  initial [shape=plaintext,label=\"0\"]\n");
-      b.append("  initial -> 0\n");
-    }
-
-    Transition t = new Transition();
-
-    for(int state=0;state<numStates;state++) {
-      b.append("  ");
-      b.append(state);
-      if (isAccept(state)) {
-        b.append(" [shape=doublecircle,label=\"" + state + "\"]\n");
-      } else {
-        b.append(" [shape=circle,label=\"" + state + "\"]\n");
-      }
-      int numTransitions = getNumTransitions(state);
-      initTransition(state, t);
-      //System.out.println("toDot: state " + state + " has " + numTransitions + " transitions; t.nextTrans=" + t.transitionUpto);
-      for(int i=0;i<numTransitions;i++) {
-        getNextTransition(t);
-        //System.out.println("  t.nextTrans=" + t.transitionUpto);
-        assert t.max >= t.min;
-        b.append("  ");
-        b.append(state);
-        b.append(" -> ");
-        b.append(t.dest);
-        b.append(" [label=\"");
-        appendCharString(t.min, b);
-        if (t.max != t.min) {
-          b.append('-');
-          appendCharString(t.max, b);
-        }
-        b.append("\"]\n");
-        //System.out.println("  t=" + t);
-      }
-    }
-    b.append('}');
-    return b.toString();
-  }
-
-  /**
-   * Returns sorted array of all interval start points.
-   */
-  int[] getStartPoints() {
-    Set<Integer> pointset = new HashSet<>();
-    pointset.add(Character.MIN_CODE_POINT);
-    //System.out.println("getStartPoints");
-    for (int s=0;s<nextState;s+=2) {
-      int trans = states[s];
-      int limit = trans+3*states[s+1];
-      //System.out.println("  state=" + (s/2) + " trans=" + trans + " limit=" + limit);
-      while (trans < limit) {
-        int min = transitions[trans+1];
-        int max = transitions[trans+2];
-        //System.out.println("    min=" + min);
-        pointset.add(min);
-        if (max < Character.MAX_CODE_POINT) {
-          pointset.add(max + 1);
-        }
-        trans += 3;
-      }
-    }
-    int[] points = new int[pointset.size()];
-    int n = 0;
-    for (Integer m : pointset) {
-      points[n++] = m;
-    }
-    Arrays.sort(points);
-    return points;
-  }
-
-  /**
-   * Performs lookup in transitions, assuming determinism.
-   * 
-   * @param c codepoint to look up
-   * @return destination state, -1 if no matching outgoing transition
-   * @see #step(int, Collection)
-   */
-  public int step(int state, int label) {
-    assert state >= 0;
-    assert label >= 0;
-    int trans = states[2*state];
-    int limit = trans + 3*states[2*state+1];
-    // TODO: we could do bin search; transitions are sorted
-    while (trans < limit) {
-      int dest = transitions[trans];
-      int min = transitions[trans+1];
-      int max = transitions[trans+2];
-      if (min <= label && label <= max) {
-        return dest;
-      }
-      trans += 3;
-    }
-
-    return -1;
-  }
-
-  /** Records new states and transitions and then {@link
-   *  #finish} creates the {@link LightAutomaton}.  Use this
-   *  when it's too restrictive to have to add all transitions
-   *  leaving each state at once. */
-  public static class Builder {
-    private int[] transitions = new int[4];
-    private int nextTransition;
-    private final LightAutomaton a = new LightAutomaton();
-
-    public void addTransition(int from, int to, int label) {
-      addTransition(from, to, label, label);
-    }
-
-    public void addTransition(int from, int to, int min, int max) {
-      if (transitions.length < nextTransition+4) {
-        transitions = ArrayUtil.grow(transitions, nextTransition+4);
-      }
-      transitions[nextTransition++] = from;
-      transitions[nextTransition++] = to;
-      transitions[nextTransition++] = min;
-      transitions[nextTransition++] = max;
-    }
-
-    /** Sorts transitions first then min label ascending, then
-     *  max label ascending, then dest ascending */
-    private final Sorter sorter = new InPlaceMergeSorter() {
-
-        private void swapOne(int i, int j) {
-          int x = transitions[i];
-          transitions[i] = transitions[j];
-          transitions[j] = x;
-        }
-
-        @Override
-        protected void swap(int i, int j) {
-          int iStart = 4*i;
-          int jStart = 4*j;
-          swapOne(iStart, jStart);
-          swapOne(iStart+1, jStart+1);
-          swapOne(iStart+2, jStart+2);
-          swapOne(iStart+3, jStart+3);
-        };
-
-        @Override
-        protected int compare(int i, int j) {
-          int iStart = 4*i;
-          int jStart = 4*j;
-
-          // First src:
-          int iSrc = transitions[iStart];
-          int jSrc = transitions[jStart];
-          if (iSrc < jSrc) {
-            return -1;
-          } else if (iSrc > jSrc) {
-            return 1;
-          }
-
-          // Then min:
-          int iMin = transitions[iStart+2];
-          int jMin = transitions[jStart+2];
-          if (iMin < jMin) {
-            return -1;
-          } else if (iMin > jMin) {
-            return 1;
-          }
-
-          // Then max:
-          int iMax = transitions[iStart+3];
-          int jMax = transitions[jStart+3];
-          if (iMax < jMax) {
-            return -1;
-          } else if (iMax > jMax) {
-            return 1;
-          }
-
-          // First dest:
-          int iDest = transitions[iStart+1];
-          int jDest = transitions[jStart+1];
-          if (iDest < jDest) {
-            return -1;
-          } else if (iDest > jDest) {
-            return 1;
-          }
-
-          return 0;
-        }
-      };
-
-    public LightAutomaton finish() {
-      //System.out.println("LA.Builder.finish: count=" + (nextTransition/4));
-      // nocommit: we could make this more efficient,
-      // e.g. somehow xfer the int[] to the automaton, or
-      // alloc exactly the right size from the automaton
-      //System.out.println("finish pending");
-      sorter.sort(0, nextTransition/4);
-      int upto = 0;
-      while (upto < nextTransition) {
-        a.addTransition(transitions[upto],
-                        transitions[upto+1],
-                        transitions[upto+2],
-                        transitions[upto+3]);
-        upto += 4;
-      }
-
-      a.finishState();
-      return a;
-    }
-
-    public int createState() {
-      return a.createState();
-    }
-
-    public void setAccept(int state, boolean accept) {
-      a.setAccept(state, accept);
-    }
-
-    public boolean isAccept(int state) {
-      return a.isAccept(state);
-    }
-
-    public int getNumStates() {
-      return a.getNumStates();
-    }
-
-    /** Copies over all states/transitions from other. */
-    public void copy(LightAutomaton other) {
-      int offset = getNumStates();
-      int otherNumStates = other.getNumStates();
-      for(int s=0;s<otherNumStates;s++) {
-        int newState = createState();
-        setAccept(newState, other.isAccept(s));
-      }
-      Transition t = new Transition();
-      for(int s=0;s<otherNumStates;s++) {
-        int count = other.initTransition(s, t);
-        for(int i=0;i<count;i++) {
-          other.getNextTransition(t);
-          addTransition(offset + s, offset + t.dest, t.min, t.max);
-        }
-      }
-    }
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/LightAutomatonProvider.java b/lucene/core/src/java/org/apache/lucene/util/automaton/LightAutomatonProvider.java
deleted file mode 100644
index ad557f4..0000000
--- a/lucene/core/src/java/org/apache/lucene/util/automaton/LightAutomatonProvider.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * dk.brics.automaton
- * 
- * Copyright (c) 2001-2009 Anders Moeller
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package org.apache.lucene.util.automaton;
-
-import java.io.IOException;
-
-/**
- * Automaton provider for <code>RegExp.</code>
- * {@link RegExp#toAutomaton(AutomatonProvider)}
- * 
- * @lucene.experimental
- */
-public interface LightAutomatonProvider {
-  
-  /**
-   * Returns automaton of the given name.
-   * 
-   * @param name automaton name
-   * @return automaton
-   * @throws IOException if errors occur
-   */
-  public LightAutomaton getAutomaton(String name) throws IOException;
-}
diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/LightStatePair.java b/lucene/core/src/java/org/apache/lucene/util/automaton/LightStatePair.java
deleted file mode 100644
index 46b717c..0000000
--- a/lucene/core/src/java/org/apache/lucene/util/automaton/LightStatePair.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- * dk.brics.automaton
- * 
- * Copyright (c) 2001-2009 Anders Moeller
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package org.apache.lucene.util.automaton;
-
-/**
- * Pair of states.
- * 
- * @lucene.experimental
- */
-public class LightStatePair {
-  int s;
-  int s1;
-  int s2;
-  
-  LightStatePair(int s, int s1, int s2) {
-    this.s = s;
-    this.s1 = s1;
-    this.s2 = s2;
-  }
-  
-  /**
-   * Constructs a new state pair.
-   * 
-   * @param s1 first state
-   * @param s2 second state
-   */
-  public LightStatePair(int s1, int s2) {
-    this.s1 = s1;
-    this.s2 = s2;
-    this.s = -1;
-  }
-  
-  /**
-   * Checks for equality.
-   * 
-   * @param obj object to compare with
-   * @return true if <tt>obj</tt> represents the same pair of states as this
-   *         pair
-   */
-  @Override
-  public boolean equals(Object obj) {
-    if (obj instanceof LightStatePair) {
-      LightStatePair p = (LightStatePair) obj;
-      return p.s1 == s1 && p.s2 == s2;
-    } else return false;
-  }
-  
-  /**
-   * Returns hash code.
-   * 
-   * @return hash code
-   */
-  @Override
-  public int hashCode() {
-    return s1 ^ s2;
-  }
-
-  @Override
-  public String toString() {
-    return "LightStatePair(s1=" + s1 + " s2=" + s2 + ")";
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperations.java b/lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperations.java
new file mode 100644
index 0000000..609796e
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperations.java
@@ -0,0 +1,308 @@
+/*
+ * dk.brics.automaton
+ * 
+ * Copyright (c) 2001-2009 Anders Moeller
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package org.apache.lucene.util.automaton;
+
+import java.util.BitSet;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.LinkedList;
+
+/**
+ * Operations for minimizing automata.
+ * 
+ * @lucene.experimental
+ */
+final public class MinimizationOperations {
+  
+  private MinimizationOperations() {}
+
+  /**
+   * Minimizes (and determinizes if not already deterministic) the given
+   * automaton.
+   * 
+   * @see Automaton#setMinimization(int)
+   */
+  public static Automaton minimize(Automaton a) {
+    return minimizeHopcroft(a);
+  }
+  
+  /**
+   * Minimizes the given automaton using Hopcroft's algorithm.
+   */
+  public static Automaton minimizeHopcroft(Automaton a) {
+    if (a.getNumStates() == 0 || (a.isAccept(0) == false && a.getNumTransitions(0) == 0)) {
+      // Fastmatch for common case
+      return new Automaton();
+    }
+    a = Operations.determinize(a);
+    //a.writeDot("adet");
+    if (a.getNumTransitions(0) == 1) {
+      Transition t = new Transition();
+      a.getTransition(0, 0, t);
+      if (t.dest == 0 && t.min == Character.MIN_CODE_POINT
+          && t.max == Character.MAX_CODE_POINT) {
+        // Accepts all strings
+        return a;
+      }
+    }
+    a = a.totalize();
+    //a.writeDot("atot");
+
+    // initialize data structures
+    final int[] sigma = a.getStartPoints();
+    final int sigmaLen = sigma.length, statesLen = a.getNumStates();
+
+    @SuppressWarnings({"rawtypes","unchecked"}) final ArrayList<Integer>[][] reverse =
+      (ArrayList<Integer>[][]) new ArrayList[statesLen][sigmaLen];
+    @SuppressWarnings({"rawtypes","unchecked"}) final HashSet<Integer>[] partition =
+      (HashSet<Integer>[]) new HashSet[statesLen];
+    @SuppressWarnings({"rawtypes","unchecked"}) final ArrayList<Integer>[] splitblock =
+      (ArrayList<Integer>[]) new ArrayList[statesLen];
+    final int[] block = new int[statesLen];
+    final StateList[][] active = new StateList[statesLen][sigmaLen];
+    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];
+    final LinkedList<IntPair> pending = new LinkedList<>();
+    final BitSet pending2 = new BitSet(sigmaLen*statesLen);
+    final BitSet split = new BitSet(statesLen), 
+      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);
+    for (int q = 0; q < statesLen; q++) {
+      splitblock[q] = new ArrayList<>();
+      partition[q] = new HashSet<>();
+      for (int x = 0; x < sigmaLen; x++) {
+        active[q][x] = new StateList();
+      }
+    }
+    // find initial partition and reverse edges
+    for (int q = 0; q < statesLen; q++) {
+      final int j = a.isAccept(q) ? 0 : 1;
+      partition[j].add(q);
+      block[q] = j;
+      for (int x = 0; x < sigmaLen; x++) {
+        final ArrayList<Integer>[] r = reverse[a.step(q, sigma[x])];
+        if (r[x] == null) {
+          r[x] = new ArrayList<>();
+        }
+        r[x].add(q);
+      }
+    }
+    // initialize active sets
+    for (int j = 0; j <= 1; j++) {
+      for (int x = 0; x < sigmaLen; x++) {
+        for (int q : partition[j]) {
+          if (reverse[q][x] != null) {
+            active2[q][x] = active[j][x].add(q);
+          }
+        }
+      }
+    }
+
+    // initialize pending
+    for (int x = 0; x < sigmaLen; x++) {
+      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;
+      pending.add(new IntPair(j, x));
+      pending2.set(x*statesLen + j);
+    }
+
+    // process pending until fixed point
+    int k = 2;
+    //System.out.println("start min");
+    while (!pending.isEmpty()) {
+      //System.out.println("  cycle pending");
+      final IntPair ip = pending.removeFirst();
+      final int p = ip.n1;
+      final int x = ip.n2;
+      //System.out.println("    pop n1=" + ip.n1 + " n2=" + ip.n2);
+      pending2.clear(x*statesLen + p);
+      // find states that need to be split off their blocks
+      for (StateListNode m = active[p][x].first; m != null; m = m.next) {
+        final ArrayList<Integer> r = reverse[m.q][x];
+        if (r != null) {
+          for (int i : r) {
+            if (!split.get(i)) {
+              split.set(i);
+              final int j = block[i];
+              splitblock[j].add(i);
+              if (!refine2.get(j)) {
+                refine2.set(j);
+                refine.set(j);
+              }
+            }
+          }
+        }
+      }
+
+      // refine blocks
+      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {
+        final ArrayList<Integer> sb = splitblock[j];
+        if (sb.size() < partition[j].size()) {
+          final HashSet<Integer> b1 = partition[j];
+          final HashSet<Integer> b2 = partition[k];
+          for (int s : sb) {
+            b1.remove(s);
+            b2.add(s);
+            block[s] = k;
+            for (int c = 0; c < sigmaLen; c++) {
+              final StateListNode sn = active2[s][c];
+              if (sn != null && sn.sl == active[j][c]) {
+                sn.remove();
+                active2[s][c] = active[k][c].add(s);
+              }
+            }
+          }
+          // update pending
+          for (int c = 0; c < sigmaLen; c++) {
+            final int aj = active[j][c].size,
+              ak = active[k][c].size,
+              ofs = c*statesLen;
+            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {
+              pending2.set(ofs + j);
+              pending.add(new IntPair(j, c));
+            } else {
+              pending2.set(ofs + k);
+              pending.add(new IntPair(k, c));
+            }
+          }
+          k++;
+        }
+        refine2.clear(j);
+        for (int s : sb) {
+          split.clear(s);
+        }
+        sb.clear();
+      }
+      refine.clear();
+    }
+
+    Automaton result = new Automaton();
+
+    Transition t = new Transition();
+
+    //System.out.println("  k=" + k);
+
+    // make a new state for each equivalence class, set initial state
+    int[] stateMap = new int[statesLen];
+    int[] stateRep = new int[k];
+
+    result.createState();
+
+    //System.out.println("min: k=" + k);
+    for (int n = 0; n < k; n++) {
+      //System.out.println("    n=" + n);
+
+      boolean isInitial = false;
+      for (int q : partition[n]) {
+        if (q == 0) {
+          isInitial = true;
+          //System.out.println("    isInitial!");
+          break;
+        }
+      }
+
+      int newState;
+      if (isInitial) {
+        newState = 0;
+      } else {
+        newState = result.createState();
+      }
+
+      //System.out.println("  newState=" + newState);
+
+      for (int q : partition[n]) {
+        stateMap[q] = newState;
+        //System.out.println("      q=" + q + " isAccept?=" + a.isAccept(q));
+        result.setAccept(newState, a.isAccept(q));
+        stateRep[newState] = q;   // select representative
+      }
+    }
+
+    // build transitions and set acceptance
+    for (int n = 0; n < k; n++) {
+      int numTransitions = a.initTransition(stateRep[n], t);
+      for(int i=0;i<numTransitions;i++) {
+        a.getNextTransition(t);
+        //System.out.println("  add trans");
+        result.addTransition(n, stateMap[t.dest], t.min, t.max);
+      }
+    }
+    result.finishState();
+    //System.out.println(result.getNumStates() + " states");
+
+    return Operations.removeDeadStates(result);
+  }
+  
+  static final class IntPair {
+    
+    final int n1, n2;
+    
+    IntPair(int n1, int n2) {
+      this.n1 = n1;
+      this.n2 = n2;
+    }
+  }
+  
+  static final class StateList {
+    
+    int size;
+    
+    StateListNode first, last;
+    
+    StateListNode add(int q) {
+      return new StateListNode(q, this);
+    }
+  }
+  
+  static final class StateListNode {
+    
+    final int q;
+    
+    StateListNode next, prev;
+    
+    final StateList sl;
+    
+    StateListNode(int q, StateList sl) {
+      this.q = q;
+      this.sl = sl;
+      if (sl.size++ == 0) sl.first = sl.last = this;
+      else {
+        sl.last.next = this;
+        prev = sl.last;
+        sl.last = this;
+      }
+    }
+    
+    void remove() {
+      sl.size--;
+      if (sl.first == this) sl.first = next;
+      else prev.next = next;
+      if (sl.last == this) sl.last = prev;
+      else next.prev = prev;
+    }
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperationsLight.java b/lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperationsLight.java
deleted file mode 100644
index 76d90e6..0000000
--- a/lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperationsLight.java
+++ /dev/null
@@ -1,308 +0,0 @@
-/*
- * dk.brics.automaton
- * 
- * Copyright (c) 2001-2009 Anders Moeller
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package org.apache.lucene.util.automaton;
-
-import java.util.BitSet;
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.LinkedList;
-
-/**
- * Operations for minimizing automata.
- * 
- * @lucene.experimental
- */
-final public class MinimizationOperationsLight {
-  
-  private MinimizationOperationsLight() {}
-
-  /**
-   * Minimizes (and determinizes if not already deterministic) the given
-   * automaton.
-   * 
-   * @see Automaton#setMinimization(int)
-   */
-  public static LightAutomaton minimize(LightAutomaton a) {
-    return minimizeHopcroft(a);
-  }
-  
-  /**
-   * Minimizes the given automaton using Hopcroft's algorithm.
-   */
-  public static LightAutomaton minimizeHopcroft(LightAutomaton a) {
-    if (a.getNumStates() == 0 || (a.isAccept(0) == false && a.getNumTransitions(0) == 0)) {
-      // Fastmatch for common case
-      return new LightAutomaton();
-    }
-    a = BasicOperations.determinize(a);
-    //a.writeDot("adet");
-    if (a.getNumTransitions(0) == 1) {
-      Transition t = new Transition();
-      a.getTransition(0, 0, t);
-      if (t.dest == 0 && t.min == Character.MIN_CODE_POINT
-          && t.max == Character.MAX_CODE_POINT) {
-        // Accepts all strings
-        return a;
-      }
-    }
-    a = a.totalize();
-    //a.writeDot("atot");
-
-    // initialize data structures
-    final int[] sigma = a.getStartPoints();
-    final int sigmaLen = sigma.length, statesLen = a.getNumStates();
-
-    @SuppressWarnings({"rawtypes","unchecked"}) final ArrayList<Integer>[][] reverse =
-      (ArrayList<Integer>[][]) new ArrayList[statesLen][sigmaLen];
-    @SuppressWarnings({"rawtypes","unchecked"}) final HashSet<Integer>[] partition =
-      (HashSet<Integer>[]) new HashSet[statesLen];
-    @SuppressWarnings({"rawtypes","unchecked"}) final ArrayList<Integer>[] splitblock =
-      (ArrayList<Integer>[]) new ArrayList[statesLen];
-    final int[] block = new int[statesLen];
-    final StateList[][] active = new StateList[statesLen][sigmaLen];
-    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];
-    final LinkedList<IntPair> pending = new LinkedList<>();
-    final BitSet pending2 = new BitSet(sigmaLen*statesLen);
-    final BitSet split = new BitSet(statesLen), 
-      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);
-    for (int q = 0; q < statesLen; q++) {
-      splitblock[q] = new ArrayList<>();
-      partition[q] = new HashSet<>();
-      for (int x = 0; x < sigmaLen; x++) {
-        active[q][x] = new StateList();
-      }
-    }
-    // find initial partition and reverse edges
-    for (int q = 0; q < statesLen; q++) {
-      final int j = a.isAccept(q) ? 0 : 1;
-      partition[j].add(q);
-      block[q] = j;
-      for (int x = 0; x < sigmaLen; x++) {
-        final ArrayList<Integer>[] r = reverse[a.step(q, sigma[x])];
-        if (r[x] == null) {
-          r[x] = new ArrayList<>();
-        }
-        r[x].add(q);
-      }
-    }
-    // initialize active sets
-    for (int j = 0; j <= 1; j++) {
-      for (int x = 0; x < sigmaLen; x++) {
-        for (int q : partition[j]) {
-          if (reverse[q][x] != null) {
-            active2[q][x] = active[j][x].add(q);
-          }
-        }
-      }
-    }
-
-    // initialize pending
-    for (int x = 0; x < sigmaLen; x++) {
-      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;
-      pending.add(new IntPair(j, x));
-      pending2.set(x*statesLen + j);
-    }
-
-    // process pending until fixed point
-    int k = 2;
-    //System.out.println("start min");
-    while (!pending.isEmpty()) {
-      //System.out.println("  cycle pending");
-      final IntPair ip = pending.removeFirst();
-      final int p = ip.n1;
-      final int x = ip.n2;
-      //System.out.println("    pop n1=" + ip.n1 + " n2=" + ip.n2);
-      pending2.clear(x*statesLen + p);
-      // find states that need to be split off their blocks
-      for (StateListNode m = active[p][x].first; m != null; m = m.next) {
-        final ArrayList<Integer> r = reverse[m.q][x];
-        if (r != null) {
-          for (int i : r) {
-            if (!split.get(i)) {
-              split.set(i);
-              final int j = block[i];
-              splitblock[j].add(i);
-              if (!refine2.get(j)) {
-                refine2.set(j);
-                refine.set(j);
-              }
-            }
-          }
-        }
-      }
-
-      // refine blocks
-      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {
-        final ArrayList<Integer> sb = splitblock[j];
-        if (sb.size() < partition[j].size()) {
-          final HashSet<Integer> b1 = partition[j];
-          final HashSet<Integer> b2 = partition[k];
-          for (int s : sb) {
-            b1.remove(s);
-            b2.add(s);
-            block[s] = k;
-            for (int c = 0; c < sigmaLen; c++) {
-              final StateListNode sn = active2[s][c];
-              if (sn != null && sn.sl == active[j][c]) {
-                sn.remove();
-                active2[s][c] = active[k][c].add(s);
-              }
-            }
-          }
-          // update pending
-          for (int c = 0; c < sigmaLen; c++) {
-            final int aj = active[j][c].size,
-              ak = active[k][c].size,
-              ofs = c*statesLen;
-            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {
-              pending2.set(ofs + j);
-              pending.add(new IntPair(j, c));
-            } else {
-              pending2.set(ofs + k);
-              pending.add(new IntPair(k, c));
-            }
-          }
-          k++;
-        }
-        refine2.clear(j);
-        for (int s : sb) {
-          split.clear(s);
-        }
-        sb.clear();
-      }
-      refine.clear();
-    }
-
-    LightAutomaton result = new LightAutomaton();
-
-    Transition t = new Transition();
-
-    //System.out.println("  k=" + k);
-
-    // make a new state for each equivalence class, set initial state
-    int[] stateMap = new int[statesLen];
-    int[] stateRep = new int[k];
-
-    result.createState();
-
-    //System.out.println("min: k=" + k);
-    for (int n = 0; n < k; n++) {
-      //System.out.println("    n=" + n);
-
-      boolean isInitial = false;
-      for (int q : partition[n]) {
-        if (q == 0) {
-          isInitial = true;
-          //System.out.println("    isInitial!");
-          break;
-        }
-      }
-
-      int newState;
-      if (isInitial) {
-        newState = 0;
-      } else {
-        newState = result.createState();
-      }
-
-      //System.out.println("  newState=" + newState);
-
-      for (int q : partition[n]) {
-        stateMap[q] = newState;
-        //System.out.println("      q=" + q + " isAccept?=" + a.isAccept(q));
-        result.setAccept(newState, a.isAccept(q));
-        stateRep[newState] = q;   // select representative
-      }
-    }
-
-    // build transitions and set acceptance
-    for (int n = 0; n < k; n++) {
-      int numTransitions = a.initTransition(stateRep[n], t);
-      for(int i=0;i<numTransitions;i++) {
-        a.getNextTransition(t);
-        //System.out.println("  add trans");
-        result.addTransition(n, stateMap[t.dest], t.min, t.max);
-      }
-    }
-    result.finishState();
-    //System.out.println(result.getNumStates() + " states");
-
-    return BasicOperations.removeDeadStates(result);
-  }
-  
-  static final class IntPair {
-    
-    final int n1, n2;
-    
-    IntPair(int n1, int n2) {
-      this.n1 = n1;
-      this.n2 = n2;
-    }
-  }
-  
-  static final class StateList {
-    
-    int size;
-    
-    StateListNode first, last;
-    
-    StateListNode add(int q) {
-      return new StateListNode(q, this);
-    }
-  }
-  
-  static final class StateListNode {
-    
-    final int q;
-    
-    StateListNode next, prev;
-    
-    final StateList sl;
-    
-    StateListNode(int q, StateList sl) {
-      this.q = q;
-      this.sl = sl;
-      if (sl.size++ == 0) sl.first = sl.last = this;
-      else {
-        sl.last.next = this;
-        prev = sl.last;
-        sl.last = this;
-      }
-    }
-    
-    void remove() {
-      sl.size--;
-      if (sl.first == this) sl.first = next;
-      else prev.next = next;
-      if (sl.last == this) sl.last = prev;
-      else next.prev = prev;
-    }
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/Operations.java b/lucene/core/src/java/org/apache/lucene/util/automaton/Operations.java
new file mode 100644
index 0000000..5e1a98c
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/util/automaton/Operations.java
@@ -0,0 +1,1285 @@
+/*
+ * dk.brics.automaton
+ * 
+ * Copyright (c) 2001-2009 Anders Moeller
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package org.apache.lucene.util.automaton;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.BitSet;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import org.apache.lucene.util.ArrayUtil;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.IntsRef;
+import org.apache.lucene.util.RamUsageEstimator;
+
+/**
+ * Automata operations.
+ * 
+ * @lucene.experimental
+ */
+final public class Operations {
+  
+  private Operations() {}
+
+  /**
+   * Returns an automaton that accepts the concatenation of the languages of the
+   * given automata.
+   * <p>
+   * Complexity: linear in total number of states.
+   */
+  static public Automaton concatenate(Automaton a1, Automaton a2) {
+    return concatenate(Arrays.asList(a1, a2));
+  }
+
+  /**
+   * Returns an automaton that accepts the concatenation of the languages of the
+   * given automata.
+   * <p>
+   * Complexity: linear in total number of states.
+   */
+  static public Automaton concatenate(List<Automaton> l) {
+    Automaton result = new Automaton();
+
+    // First pass: create all states
+    for(Automaton a : l) {
+      if (a.getNumStates() == 0) {
+        result.finishState();
+        return result;
+      }
+      int numStates = a.getNumStates();
+      for(int s=0;s<numStates;s++) {
+        result.createState();
+      }
+    }
+
+    // Second pass: add transitions, carefully linking accept
+    // states of A to init state of next A:
+    int stateOffset = 0;
+    Transition t = new Transition();
+    for(int i=0;i<l.size();i++) {
+      Automaton a = l.get(i);
+      int numStates = a.getNumStates();
+
+      Automaton nextA = (i == l.size()-1) ? null : l.get(i+1);
+
+      for(int s=0;s<numStates;s++) {
+        int numTransitions = a.initTransition(s, t);
+        for(int j=0;j<numTransitions;j++) {
+          a.getNextTransition(t);
+          result.addTransition(stateOffset + s, stateOffset + t.dest, t.min, t.max);
+        }
+
+        if (a.isAccept(s)) {
+          Automaton followA = nextA;
+          int followOffset = stateOffset;
+          int upto = i+1;
+          while (true) {
+            if (followA != null) {
+              // Adds a "virtual" epsilon transition:
+              numTransitions = followA.initTransition(0, t);
+              for(int j=0;j<numTransitions;j++) {
+                followA.getNextTransition(t);
+                result.addTransition(stateOffset + s, followOffset + numStates + t.dest, t.min, t.max);
+              }
+              if (followA.isAccept(0)) {
+                // Keep chaining if followA accepts empty string
+                followOffset += followA.getNumStates();
+                followA = (upto == l.size()-1) ? null : l.get(upto+1);
+                upto++;
+              } else {
+                break;
+              }
+            } else {
+              result.setAccept(stateOffset + s, true);
+              break;
+            }
+          }
+        }
+      }
+
+      stateOffset += numStates;
+    }
+
+    if (result.getNumStates() == 0) {
+      result.createState();
+    }
+
+    result.finishState();
+
+    return result;
+  }
+
+  /**
+   * Returns an automaton that accepts the union of the empty string and the
+   * language of the given automaton.
+   * <p>
+   * Complexity: linear in number of states.
+   */
+  static public Automaton optional(Automaton a) {
+    Automaton result = new Automaton();
+    result.createState();
+    result.setAccept(0, true);
+    if (a.getNumStates() > 0) {
+      result.copy(a);
+      result.addEpsilon(0, 1);
+    }
+    result.finishState();
+    return result;
+  }
+  
+  /**
+   * Returns an automaton that accepts the Kleene star (zero or more
+   * concatenated repetitions) of the language of the given automaton. Never
+   * modifies the input automaton language.
+   * <p>
+   * Complexity: linear in number of states.
+   */
+  static public Automaton repeat(Automaton a) {
+    Automaton.Builder builder = new Automaton.Builder();
+    builder.createState();
+    builder.setAccept(0, true);
+    builder.copy(a);
+
+    Transition t = new Transition();
+    int count = a.initTransition(0, t);
+    for(int i=0;i<count;i++) {
+      a.getNextTransition(t);
+      builder.addTransition(0, t.dest+1, t.min, t.max);
+    }
+
+    int numStates = a.getNumStates();
+    for(int s=0;s<numStates;s++) {
+      if (a.isAccept(s)) {
+        count = a.initTransition(0, t);
+        for(int i=0;i<count;i++) {
+          a.getNextTransition(t);
+          builder.addTransition(s+1, t.dest+1, t.min, t.max);
+        }
+      }
+    }
+
+    return builder.finish();
+  }
+
+  /**
+   * Returns an automaton that accepts <code>min</code> or more concatenated
+   * repetitions of the language of the given automaton.
+   * <p>
+   * Complexity: linear in number of states and in <code>min</code>.
+   */
+  static public Automaton repeat(Automaton a, int min) {
+    if (min == 0) {
+      return repeat(a);
+    }
+    List<Automaton> as = new ArrayList<>();
+    while (min-- > 0) {
+      as.add(a);
+    }
+    as.add(repeat(a));
+    return concatenate(as);
+  }
+  
+  /**
+   * Returns an automaton that accepts between <code>min</code> and
+   * <code>max</code> (including both) concatenated repetitions of the language
+   * of the given automaton.
+   * <p>
+   * Complexity: linear in number of states and in <code>min</code> and
+   * <code>max</code>.
+   */
+  static public Automaton repeat(Automaton a, int min, int max) {
+    if (min > max) {
+      return Automata.makeEmpty();
+    }
+
+    Automaton b;
+    if (min == 0) {
+      b = Automata.makeEmptyString();
+    } else if (min == 1) {
+      b = new Automaton();
+      b.copy(a);
+    } else {
+      List<Automaton> as = new ArrayList<>();
+      for(int i=0;i<min;i++) {
+        as.add(a);
+      }
+      b = concatenate(as);
+    }
+
+    Set<Integer> prevAcceptStates = new HashSet<>(b.getAcceptStates());
+
+    for(int i=min;i<max;i++) {
+      int numStates = b.getNumStates();
+      b.copy(a);
+      for(int s : prevAcceptStates) {
+        b.addEpsilon(s, numStates);
+      }
+      prevAcceptStates.clear();
+      for(int s : a.getAcceptStates()) {
+        prevAcceptStates.add(numStates+s);
+      }
+    }
+
+    b.finishState();
+
+    return b;
+  }
+  
+  /**
+   * Returns a (deterministic) automaton that accepts the complement of the
+   * language of the given automaton.
+   * <p>
+   * Complexity: linear in number of states (if already deterministic).
+   */
+  static public Automaton complement(Automaton a) {
+    a = determinize(a).totalize();
+    int numStates = a.getNumStates();
+    for (int p=0;p<numStates;p++) {
+      a.setAccept(p, !a.isAccept(p));
+    }
+    return removeDeadStates(a);
+  }
+  
+  /**
+   * Returns a (deterministic) automaton that accepts the intersection of the
+   * language of <code>a1</code> and the complement of the language of
+   * <code>a2</code>. As a side-effect, the automata may be determinized, if not
+   * already deterministic.
+   * <p>
+   * Complexity: quadratic in number of states (if already deterministic).
+   */
+  static public Automaton minus(Automaton a1, Automaton a2) {
+    if (Operations.isEmpty(a1) || a1 == a2) {
+      return Automata.makeEmpty();
+    }
+    if (Operations.isEmpty(a2)) {
+      return a1;
+    }
+    return intersection(a1, complement(a2));
+  }
+  
+  /**
+   * Returns an automaton that accepts the intersection of the languages of the
+   * given automata. Never modifies the input automata languages.
+   * <p>
+   * Complexity: quadratic in number of states.
+   */
+  static public Automaton intersection(Automaton a1, Automaton a2) {
+    if (a1 == a2) {
+      return a1;
+    }
+    if (a1.getNumStates() == 0) {
+      return a1;
+    }
+    if (a2.getNumStates() == 0) {
+      return a2;
+    }
+    Transition[][] transitions1 = a1.getSortedTransitions();
+    Transition[][] transitions2 = a2.getSortedTransitions();
+    Automaton c = new Automaton();
+    c.createState();
+    LinkedList<StatePair> worklist = new LinkedList<>();
+    HashMap<StatePair,StatePair> newstates = new HashMap<>();
+    StatePair p = new StatePair(0, 0, 0);
+    worklist.add(p);
+    newstates.put(p, p);
+    while (worklist.size() > 0) {
+      p = worklist.removeFirst();
+      c.setAccept(p.s, a1.isAccept(p.s1) && a2.isAccept(p.s2));
+      Transition[] t1 = transitions1[p.s1];
+      Transition[] t2 = transitions2[p.s2];
+      for (int n1 = 0, b2 = 0; n1 < t1.length; n1++) {
+        while (b2 < t2.length && t2[b2].max < t1[n1].min)
+          b2++;
+        for (int n2 = b2; n2 < t2.length && t1[n1].max >= t2[n2].min; n2++)
+          if (t2[n2].max >= t1[n1].min) {
+            StatePair q = new StatePair(t1[n1].dest, t2[n2].dest);
+            StatePair r = newstates.get(q);
+            if (r == null) {
+              q.s = c.createState();
+              worklist.add(q);
+              newstates.put(q, q);
+              r = q;
+            }
+            int min = t1[n1].min > t2[n2].min ? t1[n1].min : t2[n2].min;
+            int max = t1[n1].max < t2[n2].max ? t1[n1].max : t2[n2].max;
+            c.addTransition(p.s, r.s, min, max);
+          }
+      }
+    }
+    c.finishState();
+
+    return removeDeadStates(c);
+  }
+
+  /** Returns true if these two automata accept exactly the
+   *  same language.  This is a costly computation!  Note
+   *  also that a1 and a2 will be determinized as a side
+   *  effect.  Both automata must be determinized and have
+   *  no dead states! */
+  public static boolean sameLanguage(Automaton a1, Automaton a2) {
+    if (a1 == a2) {
+      return true;
+    }
+    return subsetOf(a2, a1) && subsetOf(a1, a2);
+  }
+
+  // TODO: move to test-framework?
+  /** Returns true if this automaton has any states that cannot
+   *  be reached from the initial state or cannot reach an accept state.
+   *  Cost is O(numTransitions+numStates). */
+  public static boolean hasDeadStates(Automaton a) {
+    BitSet liveStates = getLiveStates(a);
+    int numLive = liveStates.cardinality();
+    int numStates = a.getNumStates();
+    assert numLive <= numStates: "numLive=" + numLive + " numStates=" + numStates + " " + liveStates;
+    return numLive < numStates;
+  }
+
+  // TODO: move to test-framework?
+  /** Returns true if there are dead states reachable from an initial state. */
+  public static boolean hasDeadStatesFromInitial(Automaton a) {
+    BitSet reachableFromInitial = getLiveStatesFromInitial(a);
+    BitSet reachableFromAccept = getLiveStatesToAccept(a);
+    reachableFromInitial.andNot(reachableFromAccept);
+    return reachableFromInitial.isEmpty() == false;
+  }
+
+  // TODO: move to test-framework?
+  /** Returns true if there are dead states that reach an accept state. */
+  public static boolean hasDeadStatesToAccept(Automaton a) {
+    BitSet reachableFromInitial = getLiveStatesFromInitial(a);
+    BitSet reachableFromAccept = getLiveStatesToAccept(a);
+    reachableFromAccept.andNot(reachableFromInitial);
+    return reachableFromAccept.isEmpty() == false;
+  }
+
+  /**
+   * Returns true if the language of <code>a1</code> is a subset of the language
+   * of <code>a2</code>. Both automata must be determinized and must have no dead
+   * states.
+   * <p>
+   * Complexity: quadratic in number of states.
+   */
+  public static boolean subsetOf(Automaton a1, Automaton a2) {
+    if (a1.isDeterministic() == false) {
+      throw new IllegalArgumentException("a1 must be deterministic");
+    }
+    if (a2.isDeterministic() == false) {
+      throw new IllegalArgumentException("a2 must be deterministic");
+    }
+    assert hasDeadStatesFromInitial(a1) == false;
+    assert hasDeadStatesFromInitial(a2) == false;
+    if (a1.getNumStates() == 0) {
+      // Empty language is alwyas a subset of any other language
+      return true;
+    } else if (a2.getNumStates() == 0) {
+      return isEmpty(a1);
+    }
+
+    // TODO: cutover to iterators instead
+    Transition[][] transitions1 = a1.getSortedTransitions();
+    Transition[][] transitions2 = a2.getSortedTransitions();
+    LinkedList<StatePair> worklist = new LinkedList<>();
+    HashSet<StatePair> visited = new HashSet<>();
+    StatePair p = new StatePair(0, 0);
+    worklist.add(p);
+    visited.add(p);
+    while (worklist.size() > 0) {
+      p = worklist.removeFirst();
+      if (a1.isAccept(p.s1) && a2.isAccept(p.s2) == false) {
+        return false;
+      }
+      Transition[] t1 = transitions1[p.s1];
+      Transition[] t2 = transitions2[p.s2];
+      for (int n1 = 0, b2 = 0; n1 < t1.length; n1++) {
+        while (b2 < t2.length && t2[b2].max < t1[n1].min) {
+          b2++;
+        }
+        int min1 = t1[n1].min, max1 = t1[n1].max;
+
+        for (int n2 = b2; n2 < t2.length && t1[n1].max >= t2[n2].min; n2++) {
+          if (t2[n2].min > min1) {
+            return false;
+          }
+          if (t2[n2].max < Character.MAX_CODE_POINT) {
+            min1 = t2[n2].max + 1;
+          } else {
+            min1 = Character.MAX_CODE_POINT;
+            max1 = Character.MIN_CODE_POINT;
+          }
+          StatePair q = new StatePair(t1[n1].dest, t2[n2].dest);
+          if (!visited.contains(q)) {
+            worklist.add(q);
+            visited.add(q);
+          }
+        }
+        if (min1 <= max1) {
+          return false;
+        }
+      }
+    }
+    return true;
+  }
+
+  /**
+   * Returns an automaton that accepts the union of the languages of the given
+   * automata.
+   * <p>
+   * Complexity: linear in number of states.
+   */
+  public static Automaton union(Automaton a1, Automaton a2) {
+    return union(Arrays.asList(a1, a2));
+  }
+
+  public static Automaton union(Collection<Automaton> l) {
+    Automaton result = new Automaton();
+
+    // Create initial state:
+    result.createState();
+
+    // Copy over all automata
+    Transition t = new Transition();
+    for(Automaton a : l) {
+      result.copy(a);
+    }
+    
+    // Add epsilon transition from new initial state
+    int stateOffset = 1;
+    for(Automaton a : l) {
+      if (a.getNumStates() == 0) {
+        continue;
+      }
+      result.addEpsilon(0, stateOffset);
+      stateOffset += a.getNumStates();
+    }
+
+    result.finishState();
+
+    return result;
+  }
+
+  // Simple custom ArrayList<Transition>
+  private final static class TransitionList {
+    // dest, min, max
+    int[] transitions = new int[3];
+    int next;
+
+    public void add(Transition t) {
+      if (transitions.length < next+3) {
+        transitions = ArrayUtil.grow(transitions, next+3);
+      }
+      transitions[next] = t.dest;
+      transitions[next+1] = t.min;
+      transitions[next+2] = t.max;
+      next += 3;
+    }
+  }
+
+  // Holds all transitions that start on this int point, or
+  // end at this point-1
+  private final static class PointTransitions implements Comparable<PointTransitions> {
+    int point;
+    final TransitionList ends = new TransitionList();
+    final TransitionList starts = new TransitionList();
+
+    @Override
+    public int compareTo(PointTransitions other) {
+      return point - other.point;
+    }
+
+    public void reset(int point) {
+      this.point = point;
+      ends.next = 0;
+      starts.next = 0;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+      return ((PointTransitions) other).point == point;
+    }
+
+    @Override
+    public int hashCode() {
+      return point;
+    }
+  }
+
+  private final static class PointTransitionSet {
+    int count;
+    PointTransitions[] points = new PointTransitions[5];
+
+    private final static int HASHMAP_CUTOVER = 30;
+    private final HashMap<Integer,PointTransitions> map = new HashMap<>();
+    private boolean useHash = false;
+
+    private PointTransitions next(int point) {
+      // 1st time we are seeing this point
+      if (count == points.length) {
+        final PointTransitions[] newArray = new PointTransitions[ArrayUtil.oversize(1+count, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];
+        System.arraycopy(points, 0, newArray, 0, count);
+        points = newArray;
+      }
+      PointTransitions points0 = points[count];
+      if (points0 == null) {
+        points0 = points[count] = new PointTransitions();
+      }
+      points0.reset(point);
+      count++;
+      return points0;
+    }
+
+    private PointTransitions find(int point) {
+      if (useHash) {
+        final Integer pi = point;
+        PointTransitions p = map.get(pi);
+        if (p == null) {
+          p = next(point);
+          map.put(pi, p);
+        }
+        return p;
+      } else {
+        for(int i=0;i<count;i++) {
+          if (points[i].point == point) {
+            return points[i];
+          }
+        }
+
+        final PointTransitions p = next(point);
+        if (count == HASHMAP_CUTOVER) {
+          // switch to HashMap on the fly
+          assert map.size() == 0;
+          for(int i=0;i<count;i++) {
+            map.put(points[i].point, points[i]);
+          }
+          useHash = true;
+        }
+        return p;
+      }
+    }
+
+    public void reset() {
+      if (useHash) {
+        map.clear();
+        useHash = false;
+      }
+      count = 0;
+    }
+
+    public void sort() {
+      // Tim sort performs well on already sorted arrays:
+      if (count > 1) ArrayUtil.timSort(points, 0, count);
+    }
+
+    public void add(Transition t) {
+      find(t.min).starts.add(t);
+      find(1+t.max).ends.add(t);
+    }
+
+    @Override
+    public String toString() {
+      StringBuilder s = new StringBuilder();
+      for(int i=0;i<count;i++) {
+        if (i > 0) {
+          s.append(' ');
+        }
+        s.append(points[i].point).append(':').append(points[i].starts.next/3).append(',').append(points[i].ends.next/3);
+      }
+      return s.toString();
+    }
+  }
+
+  /**
+   * Determinizes the given automaton.
+   * <p>
+   * Worst case complexity: exponential in number of states.
+   */
+  public static Automaton determinize(Automaton a) {
+    if (a.isDeterministic()) {
+      // Already determinized
+      return a;
+    }
+    if (a.getNumStates() <= 1) {
+      // Already determinized
+      return a;
+    }
+
+    // subset construction
+    Automaton.Builder b = new Automaton.Builder();
+
+    //System.out.println("DET:");
+    //a.writeDot("/l/la/lucene/core/detin.dot");
+
+    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(0, 0);
+
+    // Create state 0:
+    b.createState();
+
+    LinkedList<SortedIntSet.FrozenIntSet> worklist = new LinkedList<>();
+    Map<SortedIntSet.FrozenIntSet,Integer> newstate = new HashMap<>();
+
+    worklist.add(initialset);
+
+    b.setAccept(0, a.isAccept(0));
+    newstate.put(initialset, 0);
+
+    int newStateUpto = 0;
+    int[] newStatesArray = new int[5];
+    newStatesArray[newStateUpto] = 0;
+    newStateUpto++;
+
+    // like Set<Integer,PointTransitions>
+    final PointTransitionSet points = new PointTransitionSet();
+
+    // like SortedMap<Integer,Integer>
+    final SortedIntSet statesSet = new SortedIntSet(5);
+
+    Transition t = new Transition();
+
+    while (worklist.size() > 0) {
+      SortedIntSet.FrozenIntSet s = worklist.removeFirst();
+      //System.out.println("det: pop set=" + s);
+
+      // Collate all outgoing transitions by min/1+max:
+      for(int i=0;i<s.values.length;i++) {
+        final int s0 = s.values[i];
+        int numTransitions = a.getNumTransitions(s0);
+        a.initTransition(s0, t);
+        for(int j=0;j<numTransitions;j++) {
+          a.getNextTransition(t);
+          points.add(t);
+        }
+      }
+
+      if (points.count == 0) {
+        // No outgoing transitions -- skip it
+        continue;
+      }
+
+      points.sort();
+
+      int lastPoint = -1;
+      int accCount = 0;
+
+      final int r = s.state;
+
+      for(int i=0;i<points.count;i++) {
+
+        final int point = points.points[i].point;
+
+        if (statesSet.upto > 0) {
+          assert lastPoint != -1;
+
+          statesSet.computeHash();
+          
+          Integer q = newstate.get(statesSet);
+          if (q == null) {
+            q = b.createState();
+            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);
+            //System.out.println("  make new state=" + q + " -> " + p + " accCount=" + accCount);
+            worklist.add(p);
+            b.setAccept(q, accCount > 0);
+            newstate.put(p, q);
+          } else {
+            assert (accCount > 0 ? true:false) == b.isAccept(q): "accCount=" + accCount + " vs existing accept=" +
+              b.isAccept(q) + " states=" + statesSet;
+          }
+
+          // System.out.println("  add trans src=" + r + " dest=" + q + " min=" + lastPoint + " max=" + (point-1));
+
+          b.addTransition(r, q, lastPoint, point-1);
+        }
+
+        // process transitions that end on this point
+        // (closes an overlapping interval)
+        int[] transitions = points.points[i].ends.transitions;
+        int limit = points.points[i].ends.next;
+        for(int j=0;j<limit;j+=3) {
+          int dest = transitions[j];
+          statesSet.decr(dest);
+          accCount -= a.isAccept(dest) ? 1:0;
+        }
+        points.points[i].ends.next = 0;
+
+        // process transitions that start on this point
+        // (opens a new interval)
+        transitions = points.points[i].starts.transitions;
+        limit = points.points[i].starts.next;
+        for(int j=0;j<limit;j+=3) {
+          int dest = transitions[j];
+          statesSet.incr(dest);
+          accCount += a.isAccept(dest) ? 1:0;
+        }
+        lastPoint = point;
+        points.points[i].starts.next = 0;
+      }
+      points.reset();
+      assert statesSet.upto == 0: "upto=" + statesSet.upto;
+    }
+
+    Automaton result = b.finish();
+    assert result.isDeterministic();
+    return result;
+  }
+
+  /**
+   * Returns true if the given automaton accepts no strings.
+   */
+  public static boolean isEmpty(Automaton a) {
+    if (a.getNumStates() == 0) {
+      // Common case: no states
+      return true;
+    }
+    if (a.isAccept(0) == false && a.getNumTransitions(0) == 0) {
+      // Common case: just one initial state
+      return true;
+    }
+    if (a.isAccept(0) == true) {
+      // Apparently common case: it accepts the damned empty string
+      return false;
+    }
+    
+    LinkedList<Integer> workList = new LinkedList<>();
+    BitSet seen = new BitSet(a.getNumStates());
+    workList.add(0);
+    seen.set(0);
+
+    Transition t = new Transition();
+    while (workList.isEmpty() == false) {
+      int state = workList.removeFirst();
+      if (a.isAccept(state)) {
+        return false;
+      }
+      int count = a.initTransition(state, t);
+      for(int i=0;i<count;i++) {
+        a.getNextTransition(t);
+        if (seen.get(t.dest) == false) {
+          workList.add(t.dest);
+          seen.set(t.dest);
+        }
+      }
+    }
+
+    return true;
+  }
+  
+  /**
+   * Returns true if the given automaton accepts all strings.  The automaton must be minimized.
+   */
+  public static boolean isTotal(Automaton a) {
+    if (a.isAccept(0) && a.getNumTransitions(0) == 1) {
+      Transition t = new Transition();
+      a.getTransition(0, 0, t);
+      return t.dest == 0 && t.min == Character.MIN_CODE_POINT
+          && t.max == Character.MAX_CODE_POINT;
+    }
+    return false;
+  }
+  
+  /**
+   * Returns true if the given string is accepted by the automaton.  The input must be deterministic.
+   * <p>
+   * Complexity: linear in the length of the string.
+   * <p>
+   * <b>Note:</b> for full performance, use the {@link RunAutomaton} class.
+   */
+  public static boolean run(Automaton a, String s) {
+    assert a.isDeterministic();
+    int state = 0;
+    for (int i = 0, cp = 0; i < s.length(); i += Character.charCount(cp)) {
+      int nextState = a.step(state, cp = s.codePointAt(i));
+      if (nextState == -1) {
+        return false;
+      }
+      state = nextState;
+    }
+    return a.isAccept(state);
+  }
+
+  /**
+   * Returns true if the given string (expressed as unicode codepoints) is accepted by the automaton.  The input must be deterministic.
+   * <p>
+   * Complexity: linear in the length of the string.
+   * <p>
+   * <b>Note:</b> for full performance, use the {@link RunAutomaton} class.
+   */
+  public static boolean run(Automaton a, IntsRef s) {
+    assert a.isDeterministic();
+    int state = 0;
+    for (int i=0;i<s.length;i++) {
+      int nextState = a.step(state, s.ints[s.offset+i]);
+      if (nextState == -1) {
+        return false;
+      }
+      state = nextState;
+    }
+    return a.isAccept(state);
+  }
+
+  /**
+   * Returns the set of live states. A state is "live" if an accept state is
+   * reachable from it and if it is reachable from the initial state.
+   */
+  private static BitSet getLiveStates(Automaton a) {
+    BitSet live = getLiveStatesFromInitial(a);
+    live.and(getLiveStatesToAccept(a));
+    return live;
+  }
+
+  /** Returns bitset marking states reachable from the initial state. */
+  private static BitSet getLiveStatesFromInitial(Automaton a) {
+    int numStates = a.getNumStates();
+    BitSet live = new BitSet(numStates);
+    if (numStates == 0) {
+      return live;
+    }
+    LinkedList<Integer> workList = new LinkedList<>();
+    live.set(0);
+    workList.add(0);
+
+    Transition t = new Transition();
+    while (workList.isEmpty() == false) {
+      int s = workList.removeFirst();
+      int count = a.initTransition(s, t);
+      for(int i=0;i<count;i++) {
+        a.getNextTransition(t);
+        if (live.get(t.dest) == false) {
+          live.set(t.dest);
+          workList.add(t.dest);
+        }
+      }
+    }
+
+    return live;
+  }
+
+  /** Returns bitset marking states that can reach an accept state. */
+  private static BitSet getLiveStatesToAccept(Automaton a) {
+    Automaton.Builder builder = new Automaton.Builder();
+
+    // NOTE: not quite the same thing as what SpecialOperations.reverse does:
+    Transition t = new Transition();
+    int numStates = a.getNumStates();
+    for(int s=0;s<numStates;s++) {
+      builder.createState();
+    }
+    for(int s=0;s<numStates;s++) {
+      int count = a.initTransition(s, t);
+      for(int i=0;i<count;i++) {
+        a.getNextTransition(t);
+        builder.addTransition(t.dest, s, t.min, t.max);
+      }
+    }
+    Automaton a2 = builder.finish();
+
+    LinkedList<Integer> workList = new LinkedList<>();
+    BitSet live = new BitSet(numStates);
+    for (int s : a.getAcceptStates()) {
+      live.set(s);
+      workList.add(s);
+    }
+
+    while (workList.isEmpty() == false) {
+      int s = workList.removeFirst();
+      int count = a2.initTransition(s, t);
+      for(int i=0;i<count;i++) {
+        a2.getNextTransition(t);
+        if (live.get(t.dest) == false) {
+          live.set(t.dest);
+          workList.add(t.dest);
+        }
+      }
+    }
+
+    return live;
+  }
+
+  /**
+   * Removes transitions to dead states (a state is "dead" if it is not
+   * reachable from the initial state or no accept state is reachable from it.)
+   */
+  public static Automaton removeDeadStates(Automaton a) {
+    int numStates = a.getNumStates();
+    BitSet liveSet = getLiveStates(a);
+
+    int[] map = new int[numStates];
+
+    Automaton result = new Automaton();
+    //System.out.println("liveSet: " + liveSet + " numStates=" + numStates);
+    for(int i=0;i<numStates;i++) {
+      if (liveSet.get(i)) {
+        map[i] = result.createState();
+        result.setAccept(map[i], a.isAccept(i));
+      }
+    }
+
+    Transition t = new Transition();
+
+    for (int i=0;i<numStates;i++) {
+      if (liveSet.get(i)) {
+        int numTransitions = a.initTransition(i, t);
+        // filter out transitions to dead states:
+        for(int j=0;j<numTransitions;j++) {
+          a.getNextTransition(t);
+          if (liveSet.get(t.dest)) {
+            result.addTransition(map[i], map[t.dest], t.min, t.max);
+          }
+        }
+      }
+    }
+
+    result.finishState();
+    assert hasDeadStates(result) == false;
+    return result;
+  }
+  /**
+   * Finds the largest entry whose value is less than or equal to c, or 0 if
+   * there is no such entry.
+   */
+  static int findIndex(int c, int[] points) {
+    int a = 0;
+    int b = points.length;
+    while (b - a > 1) {
+      int d = (a + b) >>> 1;
+      if (points[d] > c) b = d;
+      else if (points[d] < c) a = d;
+      else return d;
+    }
+    return a;
+  }
+  
+  /**
+   * Returns true if the language of this automaton is finite.
+   */
+  public static boolean isFinite(Automaton a) {
+    if (a.getNumStates() == 0) {
+      return true;
+    }
+    return isFinite(new Transition(), a, 0, new BitSet(a.getNumStates()), new BitSet(a.getNumStates()));
+  }
+  
+  /**
+   * Checks whether there is a loop containing s. (This is sufficient since
+   * there are never transitions to dead states.)
+   */
+  // TODO: not great that this is recursive... in theory a
+  // large automata could exceed java's stack
+  private static boolean isFinite(Transition scratch, Automaton a, int state, BitSet path, BitSet visited) {
+    path.set(state);
+    int numTransitions = a.initTransition(state, scratch);
+    for(int t=0;t<numTransitions;t++) {
+      a.getTransition(state, t, scratch);
+      if (path.get(scratch.dest) || (!visited.get(scratch.dest) && !isFinite(scratch, a, scratch.dest, path, visited))) {
+        return false;
+      }
+    }
+    path.clear(state);
+    visited.set(state);
+    return true;
+  }
+  
+  /**
+   * Returns the longest string that is a prefix of all accepted strings and
+   * visits each state at most once.  The automaton must be deterministic.
+   * 
+   * @return common prefix
+   */
+  public static String getCommonPrefix(Automaton a) {
+    if (a.isDeterministic() == false) {
+      throw new IllegalArgumentException("input automaton must be deterministic");
+    }
+    StringBuilder b = new StringBuilder();
+    HashSet<Integer> visited = new HashSet<>();
+    int s = 0;
+    boolean done;
+    Transition t = new Transition();
+    do {
+      done = true;
+      visited.add(s);
+      if (a.isAccept(s) == false && a.getNumTransitions(s) == 1) {
+        a.getTransition(s, 0, t);
+        if (t.min == t.max && !visited.contains(t.dest)) {
+          b.appendCodePoint(t.min);
+          s = t.dest;
+          done = false;
+        }
+      }
+    } while (!done);
+
+    return b.toString();
+  }
+  
+  public static BytesRef getCommonPrefixBytesRef(Automaton a) {
+    BytesRef ref = new BytesRef(10);
+    HashSet<Integer> visited = new HashSet<>();
+    int s = 0;
+    boolean done;
+    Transition t = new Transition();
+    do {
+      done = true;
+      visited.add(s);
+      if (a.isAccept(s) == false && a.getNumTransitions(s) == 1) {
+        a.getTransition(s, 0, t);
+        if (t.min == t.max && !visited.contains(t.dest)) {
+          ref.grow(++ref.length);
+          ref.bytes[ref.length - 1] = (byte) t.min;
+          s = t.dest;
+          done = false;
+        }
+      }
+    } while (!done);
+
+    return ref;
+  }
+
+  public static BytesRef getCommonSuffixBytesRef(Automaton a) {
+    // reverse the language of the automaton, then reverse its common prefix.
+    Automaton r = Operations.determinize(reverse(a));
+    BytesRef ref = getCommonPrefixBytesRef(r);
+    reverseBytes(ref);
+    return ref;
+  }
+  
+  private static void reverseBytes(BytesRef ref) {
+    if (ref.length <= 1) return;
+    int num = ref.length >> 1;
+    for (int i = ref.offset; i < ( ref.offset + num ); i++) {
+      byte b = ref.bytes[i];
+      ref.bytes[i] = ref.bytes[ref.offset * 2 + ref.length - i - 1];
+      ref.bytes[ref.offset * 2 + ref.length - i - 1] = b;
+    }
+  }
+  
+  public static Automaton reverse(Automaton a) {
+    return reverse(a, null);
+  }
+
+  public static Automaton reverse(Automaton a, Set<Integer> initialStates) {
+
+    if (Operations.isEmpty(a)) {
+      return new Automaton();
+    }
+
+    int numStates = a.getNumStates();
+
+    // Build a new automaton with all edges reversed
+    Automaton.Builder builder = new Automaton.Builder();
+
+    // Initial node; we'll add epsilon transitions in the end:
+    builder.createState();
+
+    for(int s=0;s<numStates;s++) {
+      builder.createState();
+    }
+
+    // Old initial state becomes new accept state:
+    builder.setAccept(1, true);
+
+    Transition t = new Transition();
+    for (int s=0;s<numStates;s++) {
+      int numTransitions = a.getNumTransitions(s);
+      a.initTransition(s, t);
+      for(int i=0;i<numTransitions;i++) {
+        a.getNextTransition(t);
+        builder.addTransition(t.dest+1, s+1, t.min, t.max);
+      }
+    }
+
+    Automaton result = builder.finish();
+
+    for(int s : a.getAcceptStates()) {
+      assert s < numStates;
+      result.addEpsilon(0, s+1);
+      if (initialStates != null) {
+        initialStates.add(s+1);
+      }
+    }
+
+    result.finishState();
+
+    return result;
+  }
+
+  private static class PathNode {
+
+    /** Which state the path node ends on, whose
+     *  transitions we are enumerating. */
+    public int state;
+
+    /** Which state the current transition leads to. */
+    public int to;
+
+    /** Which transition we are on. */
+    public int transition;
+
+    /** Which label we are on, in the min-max range of the
+     *  current Transition */
+    public int label;
+
+    private final Transition t = new Transition();
+
+    public void resetState(Automaton a, int state) {
+      assert a.getNumTransitions(state) != 0;
+      this.state = state;
+      transition = 0;
+      a.getTransition(state, 0, t);
+      label = t.min;
+      to = t.dest;
+    }
+
+    /** Returns next label of current transition, or
+     *  advances to next transition and returns its first
+     *  label, if current one is exhausted.  If there are
+     *  no more transitions, returns -1. */
+    public int nextLabel(Automaton a) {
+      if (label > t.max) {
+        // We've exhaused the current transition's labels;
+        // move to next transitions:
+        transition++;
+        if (transition >= a.getNumTransitions(state)) {
+          // We're done iterating transitions leaving this state
+          return -1;
+        }
+        a.getTransition(state, transition, t);
+        label = t.min;
+        to = t.dest;
+      }
+      return label++;
+    }
+  }
+
+  private static PathNode getNode(PathNode[] nodes, int index) {
+    assert index < nodes.length;
+    if (nodes[index] == null) {
+      nodes[index] = new PathNode();
+    }
+    return nodes[index];
+  }
+
+  // TODO: this is a dangerous method ... Automaton could be
+  // huge ... and it's better in general for caller to
+  // enumerate & process in a single walk:
+
+  /** Returns the set of accepted strings, up to at most
+   *  <code>limit</code> strings. If more than <code>limit</code> 
+   *  strings are accepted, the first limit strings found are returned. If <code>limit</code> == -1, then 
+   *  the limit is infinite.  If the {@link Automaton} has
+   *  cycles then this method might throw {@code
+   *  IllegalArgumentException} but that is not guaranteed
+   *  when the limit is set. */
+  public static Set<IntsRef> getFiniteStrings(Automaton a, int limit) {
+    Set<IntsRef> results = new HashSet<>();
+
+    if (limit == -1 || limit > 0) {
+      // OK
+    } else {
+      throw new IllegalArgumentException("limit must be -1 (which means no limit), or > 0; got: " + limit);
+    }
+
+    if (a.isAccept(0)) {
+      // Special case the empty string, as usual:
+      results.add(new IntsRef());
+    }
+
+    if (a.getNumTransitions(0) > 0 && (limit == -1 || results.size() < limit)) {
+
+      int numStates = a.getNumStates();
+
+      // Tracks which states are in the current path, for
+      // cycle detection:
+      BitSet pathStates = new BitSet(numStates);
+
+      // Stack to hold our current state in the
+      // recursion/iteration:
+      PathNode[] nodes = new PathNode[4];
+
+      pathStates.set(0);
+      PathNode root = getNode(nodes, 0);
+      root.resetState(a, 0);
+
+      IntsRef string = new IntsRef(1);
+      string.length = 1;
+
+      while (string.length > 0) {
+
+        PathNode node = nodes[string.length-1];
+
+        // Get next label leaving the current node:
+        int label = node.nextLabel(a);
+
+        if (label != -1) {
+          string.ints[string.length-1] = label;
+
+          if (a.isAccept(node.to)) {
+            // This transition leads to an accept state,
+            // so we save the current string:
+            results.add(IntsRef.deepCopyOf(string));
+            if (results.size() == limit) {
+              break;
+            }
+          }
+
+          if (a.getNumTransitions(node.to) != 0) {
+            // Now recurse: the destination of this transition has
+            // outgoing transitions:
+            if (pathStates.get(node.to)) {
+              throw new IllegalArgumentException("automaton has cycles");
+            }
+            pathStates.set(node.to);
+
+            // Push node onto stack:
+            if (nodes.length == string.length) {
+              PathNode[] newNodes = new PathNode[ArrayUtil.oversize(nodes.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];
+              System.arraycopy(nodes, 0, newNodes, 0, nodes.length);
+              nodes = newNodes;
+            }
+            getNode(nodes, string.length).resetState(a, node.to);
+            string.length++;
+            string.grow(string.length);
+          }
+        } else {
+          // No more transitions leaving this state,
+          // pop/return back to previous state:
+          assert pathStates.get(node.state);
+          pathStates.clear(node.state);
+          string.length--;
+        }
+      }
+    }
+
+    return results;
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/RegExp.java b/lucene/core/src/java/org/apache/lucene/util/automaton/RegExp.java
index ac2c43f..76a040a 100644
--- a/lucene/core/src/java/org/apache/lucene/util/automaton/RegExp.java
+++ b/lucene/core/src/java/org/apache/lucene/util/automaton/RegExp.java
@@ -422,12 +422,12 @@ public class RegExp {
    * Constructs new <code>Automaton</code> from this <code>RegExp</code>. Same
    * as <code>toAutomaton(null)</code> (empty automaton map).
    */
-  public LightAutomaton toLightAutomaton() {
-    return toLightAutomaton(null, null);
+  public Automaton toAutomaton() {
+    return toAutomaton(null, null);
   }
   
   /**
-   * Constructs new <code>LightAutomaton</code> from this <code>RegExp</code>. The
+   * Constructs new <code>Automaton</code> from this <code>RegExp</code>. The
    * constructed automaton is minimal and deterministic and has no transitions
    * to dead states.
    * 
@@ -435,9 +435,9 @@ public class RegExp {
    * @exception IllegalArgumentException if this regular expression uses a named
    *              identifier that is not available from the automaton provider
    */
-  public LightAutomaton toLightAutomaton(LightAutomatonProvider automaton_provider)
+  public Automaton toAutomaton(AutomatonProvider automaton_provider)
       throws IllegalArgumentException {
-    return toLightAutomaton(null, automaton_provider);
+    return toAutomaton(null, automaton_provider);
   }
   
   /**
@@ -446,26 +446,26 @@ public class RegExp {
    * to dead states.
    * 
    * @param automata a map from automaton identifiers to automata (of type
-   *          <code>LightAutomaton</code>).
+   *          <code>Automaton</code>).
    * @exception IllegalArgumentException if this regular expression uses a named
    *              identifier that does not occur in the automaton map
    */
-  public LightAutomaton toLightAutomaton(Map<String,LightAutomaton> automata)
+  public Automaton toAutomaton(Map<String,Automaton> automata)
       throws IllegalArgumentException {
-    return toLightAutomaton(automata, null);
+    return toAutomaton(automata, null);
   }
 
-  private LightAutomaton toLightAutomaton(Map<String,LightAutomaton> automata,
-      LightAutomatonProvider automaton_provider) throws IllegalArgumentException {
-    List<LightAutomaton> list;
-    LightAutomaton a = null;
+  private Automaton toAutomaton(Map<String,Automaton> automata,
+      AutomatonProvider automaton_provider) throws IllegalArgumentException {
+    List<Automaton> list;
+    Automaton a = null;
     switch (kind) {
       case REGEXP_UNION:
         list = new ArrayList<>();
         findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider);
         findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider);
-        a = BasicOperations.unionLight(list);
-        a = MinimizationOperationsLight.minimize(a);
+        a = Operations.union(list);
+        a = MinimizationOperations.minimize(a);
         break;
       case REGEXP_CONCATENATION:
         list = new ArrayList<>();
@@ -473,55 +473,55 @@ public class RegExp {
             automaton_provider);
         findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,
             automaton_provider);
-        a = BasicOperations.concatenateLight(list);
-        a = MinimizationOperationsLight.minimize(a);
+        a = Operations.concatenate(list);
+        a = MinimizationOperations.minimize(a);
         break;
       case REGEXP_INTERSECTION:
-        a = BasicOperations.intersectionLight(
-            exp1.toLightAutomaton(automata, automaton_provider),
-            exp2.toLightAutomaton(automata, automaton_provider));
-        a = MinimizationOperationsLight.minimize(a);
+        a = Operations.intersection(
+            exp1.toAutomaton(automata, automaton_provider),
+            exp2.toAutomaton(automata, automaton_provider));
+        a = MinimizationOperations.minimize(a);
         break;
       case REGEXP_OPTIONAL:
-        a = BasicOperations.optionalLight(exp1.toLightAutomaton(automata, automaton_provider));
-        a = MinimizationOperationsLight.minimize(a);
+        a = Operations.optional(exp1.toAutomaton(automata, automaton_provider));
+        a = MinimizationOperations.minimize(a);
         break;
       case REGEXP_REPEAT:
-        a = BasicOperations.repeatLight(exp1.toLightAutomaton(automata, automaton_provider));
-        a = MinimizationOperationsLight.minimize(a);
+        a = Operations.repeat(exp1.toAutomaton(automata, automaton_provider));
+        a = MinimizationOperations.minimize(a);
         break;
       case REGEXP_REPEAT_MIN:
-        a = BasicOperations.repeatLight(exp1.toLightAutomaton(automata, automaton_provider), min);
-        a = MinimizationOperationsLight.minimize(a);
+        a = Operations.repeat(exp1.toAutomaton(automata, automaton_provider), min);
+        a = MinimizationOperations.minimize(a);
         break;
       case REGEXP_REPEAT_MINMAX:
-        a = BasicOperations.repeatLight(exp1.toLightAutomaton(automata, automaton_provider), min, max);
-        a = MinimizationOperationsLight.minimize(a);
+        a = Operations.repeat(exp1.toAutomaton(automata, automaton_provider), min, max);
+        a = MinimizationOperations.minimize(a);
         break;
       case REGEXP_COMPLEMENT:
-        a = BasicOperations.complementLight(exp1.toLightAutomaton(automata, automaton_provider));
-        a = MinimizationOperationsLight.minimize(a);
+        a = Operations.complement(exp1.toAutomaton(automata, automaton_provider));
+        a = MinimizationOperations.minimize(a);
         break;
       case REGEXP_CHAR:
-        a = BasicAutomata.makeCharLight(c);
+        a = Automata.makeChar(c);
         break;
       case REGEXP_CHAR_RANGE:
-        a = BasicAutomata.makeCharRangeLight(from, to);
+        a = Automata.makeCharRange(from, to);
         break;
       case REGEXP_ANYCHAR:
-        a = BasicAutomata.makeAnyCharLight();
+        a = Automata.makeAnyChar();
         break;
       case REGEXP_EMPTY:
-        a = BasicAutomata.makeEmptyLight();
+        a = Automata.makeEmpty();
         break;
       case REGEXP_STRING:
-        a = BasicAutomata.makeStringLight(s);
+        a = Automata.makeString(s);
         break;
       case REGEXP_ANYSTRING:
-        a = BasicAutomata.makeAnyStringLight();
+        a = Automata.makeAnyString();
         break;
       case REGEXP_AUTOMATON:
-        LightAutomaton aa = null;
+        Automaton aa = null;
         if (automata != null) {
           aa = automata.get(s);
         }
@@ -538,19 +538,19 @@ public class RegExp {
         a = aa;
         break;
       case REGEXP_INTERVAL:
-        a = BasicAutomata.makeIntervalLight(min, max, digits);
+        a = Automata.makeInterval(min, max, digits);
         break;
     }
     return a;
   }
   
-  private void findLeaves(RegExp exp, Kind kind, List<LightAutomaton> list,
-      Map<String,LightAutomaton> automata, LightAutomatonProvider automaton_provider) {
+  private void findLeaves(RegExp exp, Kind kind, List<Automaton> list,
+      Map<String,Automaton> automata, AutomatonProvider automaton_provider) {
     if (exp.kind == kind) {
       findLeaves(exp.exp1, kind, list, automata, automaton_provider);
       findLeaves(exp.exp2, kind, list, automata, automaton_provider);
     } else {
-      list.add(exp.toLightAutomaton(automata, automaton_provider));
+      list.add(exp.toAutomaton(automata, automaton_provider));
     }
   }
   
diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/RunAutomaton.java b/lucene/core/src/java/org/apache/lucene/util/automaton/RunAutomaton.java
index 454fecc..5ecd990 100644
--- a/lucene/core/src/java/org/apache/lucene/util/automaton/RunAutomaton.java
+++ b/lucene/core/src/java/org/apache/lucene/util/automaton/RunAutomaton.java
@@ -37,7 +37,7 @@ import java.util.Arrays;
  * @lucene.experimental
  */
 public abstract class RunAutomaton {
-  final LightAutomaton automaton;
+  final Automaton automaton;
   final int maxInterval;
   final int size;
   final boolean[] accept;
@@ -66,10 +66,10 @@ public abstract class RunAutomaton {
           if (j + 1 < points.length) max = (points[j + 1] - 1);
           else max = maxInterval;
           b.append(" ");
-          LightAutomaton.appendCharString(min, b);
+          Automaton.appendCharString(min, b);
           if (min != max) {
             b.append("-");
-            LightAutomaton.appendCharString(max, b);
+            Automaton.appendCharString(max, b);
           }
           b.append(" -> ").append(k).append("\n");
         }
@@ -111,7 +111,7 @@ public abstract class RunAutomaton {
    * Gets character class of given codepoint
    */
   final int getCharClass(int c) {
-    return SpecialOperations.findIndex(c, points);
+    return Operations.findIndex(c, points);
   }
 
   /**
@@ -120,10 +120,10 @@ public abstract class RunAutomaton {
    * 
    * @param a an automaton
    */
-  public RunAutomaton(LightAutomaton a, int maxInterval, boolean tableize) {
+  public RunAutomaton(Automaton a, int maxInterval, boolean tableize) {
     this.maxInterval = maxInterval;
     //System.out.println("before det a=" + a.getNumStates());
-    a = BasicOperations.determinize(a);
+    a = Operations.determinize(a);
     this.automaton = a;
     //System.out.println("AFTER DET tableize= " + tableize + ": ");
     //System.out.println(a.toDot());
diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/SortedIntSet.java b/lucene/core/src/java/org/apache/lucene/util/automaton/SortedIntSet.java
new file mode 100644
index 0000000..d66f9de
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/util/automaton/SortedIntSet.java
@@ -0,0 +1,278 @@
+package org.apache.lucene.util.automaton;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.TreeMap;
+import java.util.Map;
+import org.apache.lucene.util.ArrayUtil;
+import org.apache.lucene.util.RamUsageEstimator;
+
+// Just holds a set of int[] states, plus a corresponding
+// int[] count per state.  Used by
+// BasicOperations.determinize
+final class SortedIntSet {
+  int[] values;
+  int[] counts;
+  int upto;
+  private int hashCode;
+
+  // If we hold more than this many states, we switch from
+  // O(N^2) linear ops to O(N log(N)) TreeMap
+  private final static int TREE_MAP_CUTOVER = 30;
+
+  private final Map<Integer,Integer> map = new TreeMap<>();
+
+  private boolean useTreeMap;
+
+  int state;
+
+  public SortedIntSet(int capacity) {
+    values = new int[capacity];
+    counts = new int[capacity];
+  }
+
+  // Adds this state to the set
+  public void incr(int num) {
+    if (useTreeMap) {
+      final Integer key = num;
+      Integer val = map.get(key);
+      if (val == null) {
+        map.put(key, 1);
+      } else {
+        map.put(key, 1+val);
+      }
+      return;
+    }
+
+    if (upto == values.length) {
+      values = ArrayUtil.grow(values, 1+upto);
+      counts = ArrayUtil.grow(counts, 1+upto);
+    }
+
+    for(int i=0;i<upto;i++) {
+      if (values[i] == num) {
+        counts[i]++;
+        return;
+      } else if (num < values[i]) {
+        // insert here
+        int j = upto-1;
+        while (j >= i) {
+          values[1+j] = values[j];
+          counts[1+j] = counts[j];
+          j--;
+        }
+        values[i] = num;
+        counts[i] = 1;
+        upto++;
+        return;
+      }
+    }
+
+    // append
+    values[upto] = num;
+    counts[upto] = 1;
+    upto++;
+
+    if (upto == TREE_MAP_CUTOVER) {
+      useTreeMap = true;
+      for(int i=0;i<upto;i++) {
+        map.put(values[i], counts[i]);
+      }
+    }
+  }
+
+  // Removes this state from the set, if count decrs to 0
+  public void decr(int num) {
+
+    if (useTreeMap) {
+      final int count = map.get(num);
+      if (count == 1) {
+        map.remove(num);
+      } else {
+        map.put(num, count-1);
+      }
+      // Fall back to simple arrays once we touch zero again
+      if (map.size() == 0) {
+        useTreeMap = false;
+        upto = 0;
+      }
+      return;
+    }
+
+    for(int i=0;i<upto;i++) {
+      if (values[i] == num) {
+        counts[i]--;
+        if (counts[i] == 0) {
+          final int limit = upto-1;
+          while(i < limit) {
+            values[i] = values[i+1];
+            counts[i] = counts[i+1];
+            i++;
+          }
+          upto = limit;
+        }
+        return;
+      }
+    }
+    assert false;
+  }
+
+  public void computeHash() {
+    if (useTreeMap) {
+      if (map.size() > values.length) {
+        final int size = ArrayUtil.oversize(map.size(), RamUsageEstimator.NUM_BYTES_INT);
+        values = new int[size];
+        counts = new int[size];
+      }
+      hashCode = map.size();
+      upto = 0;
+      for(int state : map.keySet()) {
+        hashCode = 683*hashCode + state;
+        values[upto++] = state;
+      }
+    } else {
+      hashCode = upto;
+      for(int i=0;i<upto;i++) {
+        hashCode = 683*hashCode + values[i];
+      }
+    }
+  }
+
+  public FrozenIntSet freeze(int state) {
+    final int[] c = new int[upto];
+    System.arraycopy(values, 0, c, 0, upto);
+    return new FrozenIntSet(c, hashCode, state);
+  }
+
+  @Override
+  public int hashCode() {
+    return hashCode;
+  }
+
+  @Override
+  public boolean equals(Object _other) {
+    if (_other == null) {
+      return false;
+    }
+    if (!(_other instanceof FrozenIntSet)) {
+      return false;
+    }
+    FrozenIntSet other = (FrozenIntSet) _other;
+    if (hashCode != other.hashCode) {
+      return false;
+    }
+    if (other.values.length != upto) {
+      return false;
+    }
+    for(int i=0;i<upto;i++) {
+      if (other.values[i] != values[i]) {
+        return false;
+      }
+    }
+
+    return true;
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder sb = new StringBuilder().append('[');
+    for(int i=0;i<upto;i++) {
+      if (i > 0) {
+        sb.append(' ');
+      }
+      sb.append(values[i]).append(':').append(counts[i]);
+    }
+    sb.append(']');
+    return sb.toString();
+  }
+  
+  public final static class FrozenIntSet {
+    final int[] values;
+    final int hashCode;
+    final int state;
+
+    public FrozenIntSet(int[] values, int hashCode, int state) {
+      this.values = values;
+      this.hashCode = hashCode;
+      this.state = state;
+    }
+
+    public FrozenIntSet(int num, int state) {
+      this.values = new int[] {num};
+      this.state = state;
+      this.hashCode = 683+num;
+    }
+
+    @Override
+    public int hashCode() {
+      return hashCode;
+    }
+
+    @Override
+    public boolean equals(Object _other) {
+      if (_other == null) {
+        return false;
+      }
+      if (_other instanceof FrozenIntSet) {
+        FrozenIntSet other = (FrozenIntSet) _other;
+        if (hashCode != other.hashCode) {
+          return false;
+        }
+        if (other.values.length != values.length) {
+          return false;
+        }
+        for(int i=0;i<values.length;i++) {
+          if (other.values[i] != values[i]) {
+            return false;
+          }
+        }
+        return true;
+      } else if (_other instanceof SortedIntSet) {
+        SortedIntSet other = (SortedIntSet) _other;
+        if (hashCode != other.hashCode) {
+          return false;
+        }
+        if (other.values.length != values.length) {
+          return false;
+        }
+        for(int i=0;i<values.length;i++) {
+          if (other.values[i] != values[i]) {
+            return false;
+          }
+        }
+        return true;
+      }
+
+      return false;
+    }
+
+    @Override
+    public String toString() {
+      StringBuilder sb = new StringBuilder().append('[');
+      for(int i=0;i<values.length;i++) {
+        if (i > 0) {
+          sb.append(' ');
+        }
+        sb.append(values[i]);
+      }
+      sb.append(']');
+      return sb.toString();
+    }
+  }
+}
+  
diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/SortedIntSetLight.java b/lucene/core/src/java/org/apache/lucene/util/automaton/SortedIntSetLight.java
deleted file mode 100644
index ac32a6c..0000000
--- a/lucene/core/src/java/org/apache/lucene/util/automaton/SortedIntSetLight.java
+++ /dev/null
@@ -1,278 +0,0 @@
-package org.apache.lucene.util.automaton;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.TreeMap;
-import java.util.Map;
-import org.apache.lucene.util.ArrayUtil;
-import org.apache.lucene.util.RamUsageEstimator;
-
-// Just holds a set of int[] states, plus a corresponding
-// int[] count per state.  Used by
-// BasicOperations.determinize
-final class SortedIntSetLight {
-  int[] values;
-  int[] counts;
-  int upto;
-  private int hashCode;
-
-  // If we hold more than this many states, we switch from
-  // O(N^2) linear ops to O(N log(N)) TreeMap
-  private final static int TREE_MAP_CUTOVER = 30;
-
-  private final Map<Integer,Integer> map = new TreeMap<>();
-
-  private boolean useTreeMap;
-
-  int state;
-
-  public SortedIntSetLight(int capacity) {
-    values = new int[capacity];
-    counts = new int[capacity];
-  }
-
-  // Adds this state to the set
-  public void incr(int num) {
-    if (useTreeMap) {
-      final Integer key = num;
-      Integer val = map.get(key);
-      if (val == null) {
-        map.put(key, 1);
-      } else {
-        map.put(key, 1+val);
-      }
-      return;
-    }
-
-    if (upto == values.length) {
-      values = ArrayUtil.grow(values, 1+upto);
-      counts = ArrayUtil.grow(counts, 1+upto);
-    }
-
-    for(int i=0;i<upto;i++) {
-      if (values[i] == num) {
-        counts[i]++;
-        return;
-      } else if (num < values[i]) {
-        // insert here
-        int j = upto-1;
-        while (j >= i) {
-          values[1+j] = values[j];
-          counts[1+j] = counts[j];
-          j--;
-        }
-        values[i] = num;
-        counts[i] = 1;
-        upto++;
-        return;
-      }
-    }
-
-    // append
-    values[upto] = num;
-    counts[upto] = 1;
-    upto++;
-
-    if (upto == TREE_MAP_CUTOVER) {
-      useTreeMap = true;
-      for(int i=0;i<upto;i++) {
-        map.put(values[i], counts[i]);
-      }
-    }
-  }
-
-  // Removes this state from the set, if count decrs to 0
-  public void decr(int num) {
-
-    if (useTreeMap) {
-      final int count = map.get(num);
-      if (count == 1) {
-        map.remove(num);
-      } else {
-        map.put(num, count-1);
-      }
-      // Fall back to simple arrays once we touch zero again
-      if (map.size() == 0) {
-        useTreeMap = false;
-        upto = 0;
-      }
-      return;
-    }
-
-    for(int i=0;i<upto;i++) {
-      if (values[i] == num) {
-        counts[i]--;
-        if (counts[i] == 0) {
-          final int limit = upto-1;
-          while(i < limit) {
-            values[i] = values[i+1];
-            counts[i] = counts[i+1];
-            i++;
-          }
-          upto = limit;
-        }
-        return;
-      }
-    }
-    assert false;
-  }
-
-  public void computeHash() {
-    if (useTreeMap) {
-      if (map.size() > values.length) {
-        final int size = ArrayUtil.oversize(map.size(), RamUsageEstimator.NUM_BYTES_INT);
-        values = new int[size];
-        counts = new int[size];
-      }
-      hashCode = map.size();
-      upto = 0;
-      for(int state : map.keySet()) {
-        hashCode = 683*hashCode + state;
-        values[upto++] = state;
-      }
-    } else {
-      hashCode = upto;
-      for(int i=0;i<upto;i++) {
-        hashCode = 683*hashCode + values[i];
-      }
-    }
-  }
-
-  public FrozenIntSetLight freeze(int state) {
-    final int[] c = new int[upto];
-    System.arraycopy(values, 0, c, 0, upto);
-    return new FrozenIntSetLight(c, hashCode, state);
-  }
-
-  @Override
-  public int hashCode() {
-    return hashCode;
-  }
-
-  @Override
-  public boolean equals(Object _other) {
-    if (_other == null) {
-      return false;
-    }
-    if (!(_other instanceof FrozenIntSetLight)) {
-      return false;
-    }
-    FrozenIntSetLight other = (FrozenIntSetLight) _other;
-    if (hashCode != other.hashCode) {
-      return false;
-    }
-    if (other.values.length != upto) {
-      return false;
-    }
-    for(int i=0;i<upto;i++) {
-      if (other.values[i] != values[i]) {
-        return false;
-      }
-    }
-
-    return true;
-  }
-
-  @Override
-  public String toString() {
-    StringBuilder sb = new StringBuilder().append('[');
-    for(int i=0;i<upto;i++) {
-      if (i > 0) {
-        sb.append(' ');
-      }
-      sb.append(values[i]).append(':').append(counts[i]);
-    }
-    sb.append(']');
-    return sb.toString();
-  }
-  
-  public final static class FrozenIntSetLight {
-    final int[] values;
-    final int hashCode;
-    final int state;
-
-    public FrozenIntSetLight(int[] values, int hashCode, int state) {
-      this.values = values;
-      this.hashCode = hashCode;
-      this.state = state;
-    }
-
-    public FrozenIntSetLight(int num, int state) {
-      this.values = new int[] {num};
-      this.state = state;
-      this.hashCode = 683+num;
-    }
-
-    @Override
-    public int hashCode() {
-      return hashCode;
-    }
-
-    @Override
-    public boolean equals(Object _other) {
-      if (_other == null) {
-        return false;
-      }
-      if (_other instanceof FrozenIntSetLight) {
-        FrozenIntSetLight other = (FrozenIntSetLight) _other;
-        if (hashCode != other.hashCode) {
-          return false;
-        }
-        if (other.values.length != values.length) {
-          return false;
-        }
-        for(int i=0;i<values.length;i++) {
-          if (other.values[i] != values[i]) {
-            return false;
-          }
-        }
-        return true;
-      } else if (_other instanceof SortedIntSetLight) {
-        SortedIntSetLight other = (SortedIntSetLight) _other;
-        if (hashCode != other.hashCode) {
-          return false;
-        }
-        if (other.values.length != values.length) {
-          return false;
-        }
-        for(int i=0;i<values.length;i++) {
-          if (other.values[i] != values[i]) {
-            return false;
-          }
-        }
-        return true;
-      }
-
-      return false;
-    }
-
-    @Override
-    public String toString() {
-      StringBuilder sb = new StringBuilder().append('[');
-      for(int i=0;i<values.length;i++) {
-        if (i > 0) {
-          sb.append(' ');
-        }
-        sb.append(values[i]);
-      }
-      sb.append(']');
-      return sb.toString();
-    }
-  }
-}
-  
diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/SpecialOperations.java b/lucene/core/src/java/org/apache/lucene/util/automaton/SpecialOperations.java
deleted file mode 100644
index ed7e946..0000000
--- a/lucene/core/src/java/org/apache/lucene/util/automaton/SpecialOperations.java
+++ /dev/null
@@ -1,369 +0,0 @@
-/*
- * dk.brics.automaton
- * 
- * Copyright (c) 2001-2009 Anders Moeller
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package org.apache.lucene.util.automaton;
-
-import java.util.BitSet;
-import java.util.HashSet;
-import java.util.Set;
-
-import org.apache.lucene.util.ArrayUtil;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.IntsRef;
-import org.apache.lucene.util.RamUsageEstimator;
-
-/**
- * Special automata operations.
- * 
- * @lucene.experimental
- */
-final public class SpecialOperations {
-  
-  private SpecialOperations() {}
-  
-  /**
-   * Finds the largest entry whose value is less than or equal to c, or 0 if
-   * there is no such entry.
-   */
-  static int findIndex(int c, int[] points) {
-    int a = 0;
-    int b = points.length;
-    while (b - a > 1) {
-      int d = (a + b) >>> 1;
-      if (points[d] > c) b = d;
-      else if (points[d] < c) a = d;
-      else return d;
-    }
-    return a;
-  }
-  
-  /**
-   * Returns true if the language of this automaton is finite.
-   */
-  public static boolean isFinite(LightAutomaton a) {
-    if (a.getNumStates() == 0) {
-      return true;
-    }
-    return isFinite(new Transition(), a, 0, new BitSet(a.getNumStates()), new BitSet(a.getNumStates()));
-  }
-  
-  /**
-   * Checks whether there is a loop containing s. (This is sufficient since
-   * there are never transitions to dead states.)
-   */
-  // TODO: not great that this is recursive... in theory a
-  // large automata could exceed java's stack
-  private static boolean isFinite(Transition scratch, LightAutomaton a, int state, BitSet path, BitSet visited) {
-    path.set(state);
-    int numTransitions = a.initTransition(state, scratch);
-    for(int t=0;t<numTransitions;t++) {
-      a.getTransition(state, t, scratch);
-      if (path.get(scratch.dest) || (!visited.get(scratch.dest) && !isFinite(scratch, a, scratch.dest, path, visited))) {
-        return false;
-      }
-    }
-    path.clear(state);
-    visited.set(state);
-    return true;
-  }
-  
-  /**
-   * Returns the longest string that is a prefix of all accepted strings and
-   * visits each state at most once.  The automaton must be deterministic.
-   * 
-   * @return common prefix
-   */
-  public static String getCommonPrefix(LightAutomaton a) {
-    if (a.isDeterministic() == false) {
-      throw new IllegalArgumentException("input automaton must be deterministic");
-    }
-    StringBuilder b = new StringBuilder();
-    HashSet<Integer> visited = new HashSet<>();
-    int s = 0;
-    boolean done;
-    Transition t = new Transition();
-    do {
-      done = true;
-      visited.add(s);
-      if (a.isAccept(s) == false && a.getNumTransitions(s) == 1) {
-        a.getTransition(s, 0, t);
-        if (t.min == t.max && !visited.contains(t.dest)) {
-          b.appendCodePoint(t.min);
-          s = t.dest;
-          done = false;
-        }
-      }
-    } while (!done);
-
-    return b.toString();
-  }
-  
-  public static BytesRef getCommonPrefixBytesRef(LightAutomaton a) {
-    BytesRef ref = new BytesRef(10);
-    HashSet<Integer> visited = new HashSet<>();
-    int s = 0;
-    boolean done;
-    Transition t = new Transition();
-    do {
-      done = true;
-      visited.add(s);
-      if (a.isAccept(s) == false && a.getNumTransitions(s) == 1) {
-        a.getTransition(s, 0, t);
-        if (t.min == t.max && !visited.contains(t.dest)) {
-          ref.grow(++ref.length);
-          ref.bytes[ref.length - 1] = (byte) t.min;
-          s = t.dest;
-          done = false;
-        }
-      }
-    } while (!done);
-
-    return ref;
-  }
-
-  public static BytesRef getCommonSuffixBytesRef(LightAutomaton a) {
-    // reverse the language of the automaton, then reverse its common prefix.
-    LightAutomaton r = BasicOperations.determinize(reverse(a));
-    BytesRef ref = getCommonPrefixBytesRef(r);
-    reverseBytes(ref);
-    return ref;
-  }
-  
-  private static void reverseBytes(BytesRef ref) {
-    if (ref.length <= 1) return;
-    int num = ref.length >> 1;
-    for (int i = ref.offset; i < ( ref.offset + num ); i++) {
-      byte b = ref.bytes[i];
-      ref.bytes[i] = ref.bytes[ref.offset * 2 + ref.length - i - 1];
-      ref.bytes[ref.offset * 2 + ref.length - i - 1] = b;
-    }
-  }
-  
-  // nocommit merge Special/Basic operations
-
-  public static LightAutomaton reverse(LightAutomaton a) {
-    return reverse(a, null);
-  }
-
-  public static LightAutomaton reverse(LightAutomaton a, Set<Integer> initialStates) {
-
-    if (BasicOperations.isEmpty(a)) {
-      return new LightAutomaton();
-    }
-
-    int numStates = a.getNumStates();
-
-    // Build a new automaton with all edges reversed
-    LightAutomaton.Builder builder = new LightAutomaton.Builder();
-
-    // Initial node; we'll add epsilon transitions in the end:
-    builder.createState();
-
-    for(int s=0;s<numStates;s++) {
-      builder.createState();
-    }
-
-    // Old initial state becomes new accept state:
-    builder.setAccept(1, true);
-
-    Transition t = new Transition();
-    for (int s=0;s<numStates;s++) {
-      int numTransitions = a.getNumTransitions(s);
-      a.initTransition(s, t);
-      for(int i=0;i<numTransitions;i++) {
-        a.getNextTransition(t);
-        builder.addTransition(t.dest+1, s+1, t.min, t.max);
-      }
-    }
-
-    LightAutomaton result = builder.finish();
-
-    for(int s : a.getAcceptStates()) {
-      assert s < numStates;
-      result.addEpsilon(0, s+1);
-      if (initialStates != null) {
-        initialStates.add(s+1);
-      }
-    }
-
-    result.finishState();
-
-    return result;
-  }
-
-  private static class LightPathNode {
-
-    /** Which state the path node ends on, whose
-     *  transitions we are enumerating. */
-    public int state;
-
-    /** Which state the current transition leads to. */
-    public int to;
-
-    /** Which transition we are on. */
-    public int transition;
-
-    /** Which label we are on, in the min-max range of the
-     *  current Transition */
-    public int label;
-
-    private final Transition t = new Transition();
-
-    public void resetState(LightAutomaton a, int state) {
-      assert a.getNumTransitions(state) != 0;
-      this.state = state;
-      transition = 0;
-      a.getTransition(state, 0, t);
-      label = t.min;
-      to = t.dest;
-    }
-
-    /** Returns next label of current transition, or
-     *  advances to next transition and returns its first
-     *  label, if current one is exhausted.  If there are
-     *  no more transitions, returns -1. */
-    public int nextLabel(LightAutomaton a) {
-      if (label > t.max) {
-        // We've exhaused the current transition's labels;
-        // move to next transitions:
-        transition++;
-        if (transition >= a.getNumTransitions(state)) {
-          // We're done iterating transitions leaving this state
-          return -1;
-        }
-        a.getTransition(state, transition, t);
-        label = t.min;
-        to = t.dest;
-      }
-      return label++;
-    }
-  }
-
-  private static LightPathNode getNode(LightPathNode[] nodes, int index) {
-    assert index < nodes.length;
-    if (nodes[index] == null) {
-      nodes[index] = new LightPathNode();
-    }
-    return nodes[index];
-  }
-
-  // TODO: this is a dangerous method ... Automaton could be
-  // huge ... and it's better in general for caller to
-  // enumerate & process in a single walk:
-
-  /** Returns the set of accepted strings, up to at most
-   *  <code>limit</code> strings. If more than <code>limit</code> 
-   *  strings are accepted, the first limit strings found are returned. If <code>limit</code> == -1, then 
-   *  the limit is infinite.  If the {@link Automaton} has
-   *  cycles then this method might throw {@code
-   *  IllegalArgumentException} but that is not guaranteed
-   *  when the limit is set. */
-  public static Set<IntsRef> getFiniteStrings(LightAutomaton a, int limit) {
-    Set<IntsRef> results = new HashSet<>();
-
-    if (limit == -1 || limit > 0) {
-      // OK
-    } else {
-      throw new IllegalArgumentException("limit must be -1 (which means no limit), or > 0; got: " + limit);
-    }
-
-    if (a.isAccept(0)) {
-      // Special case the empty string, as usual:
-      results.add(new IntsRef());
-    }
-
-    if (a.getNumTransitions(0) > 0 && (limit == -1 || results.size() < limit)) {
-
-      int numStates = a.getNumStates();
-
-      // Tracks which states are in the current path, for
-      // cycle detection:
-      BitSet pathStates = new BitSet(numStates);
-
-      // Stack to hold our current state in the
-      // recursion/iteration:
-      LightPathNode[] nodes = new LightPathNode[4];
-
-      pathStates.set(0);
-      LightPathNode root = getNode(nodes, 0);
-      root.resetState(a, 0);
-
-      IntsRef string = new IntsRef(1);
-      string.length = 1;
-
-      while (string.length > 0) {
-
-        LightPathNode node = nodes[string.length-1];
-
-        // Get next label leaving the current node:
-        int label = node.nextLabel(a);
-
-        if (label != -1) {
-          string.ints[string.length-1] = label;
-
-          if (a.isAccept(node.to)) {
-            // This transition leads to an accept state,
-            // so we save the current string:
-            results.add(IntsRef.deepCopyOf(string));
-            if (results.size() == limit) {
-              break;
-            }
-          }
-
-          if (a.getNumTransitions(node.to) != 0) {
-            // Now recurse: the destination of this transition has
-            // outgoing transitions:
-            if (pathStates.get(node.to)) {
-              throw new IllegalArgumentException("automaton has cycles");
-            }
-            pathStates.set(node.to);
-
-            // Push node onto stack:
-            if (nodes.length == string.length) {
-              LightPathNode[] newNodes = new LightPathNode[ArrayUtil.oversize(nodes.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];
-              System.arraycopy(nodes, 0, newNodes, 0, nodes.length);
-              nodes = newNodes;
-            }
-            getNode(nodes, string.length).resetState(a, node.to);
-            string.length++;
-            string.grow(string.length);
-          }
-        } else {
-          // No more transitions leaving this state,
-          // pop/return back to previous state:
-          assert pathStates.get(node.state);
-          pathStates.clear(node.state);
-          string.length--;
-        }
-      }
-    }
-
-    return results;
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/StatePair.java b/lucene/core/src/java/org/apache/lucene/util/automaton/StatePair.java
new file mode 100644
index 0000000..4ce81ab
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/util/automaton/StatePair.java
@@ -0,0 +1,89 @@
+/*
+ * dk.brics.automaton
+ * 
+ * Copyright (c) 2001-2009 Anders Moeller
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package org.apache.lucene.util.automaton;
+
+/**
+ * Pair of states.
+ * 
+ * @lucene.experimental
+ */
+public class StatePair {
+  int s;
+  int s1;
+  int s2;
+  
+  StatePair(int s, int s1, int s2) {
+    this.s = s;
+    this.s1 = s1;
+    this.s2 = s2;
+  }
+  
+  /**
+   * Constructs a new state pair.
+   * 
+   * @param s1 first state
+   * @param s2 second state
+   */
+  public StatePair(int s1, int s2) {
+    this.s1 = s1;
+    this.s2 = s2;
+    this.s = -1;
+  }
+  
+  /**
+   * Checks for equality.
+   * 
+   * @param obj object to compare with
+   * @return true if <tt>obj</tt> represents the same pair of states as this
+   *         pair
+   */
+  @Override
+  public boolean equals(Object obj) {
+    if (obj instanceof StatePair) {
+      StatePair p = (StatePair) obj;
+      return p.s1 == s1 && p.s2 == s2;
+    } else return false;
+  }
+  
+  /**
+   * Returns hash code.
+   * 
+   * @return hash code
+   */
+  @Override
+  public int hashCode() {
+    return s1 ^ s2;
+  }
+
+  @Override
+  public String toString() {
+    return "StatePair(s1=" + s1 + " s2=" + s2 + ")";
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8.java b/lucene/core/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8.java
new file mode 100644
index 0000000..f803f56
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8.java
@@ -0,0 +1,314 @@
+package org.apache.lucene.util.automaton;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.Arrays;
+import java.util.ArrayList;
+import java.util.List;
+
+// TODO
+//   - do we really need the .bits...?  if not we can make util in UnicodeUtil to convert 1 char into a BytesRef
+
+/** 
+ * Converts UTF-32 automata to the equivalent UTF-8 representation.
+ * @lucene.internal 
+ */
+public final class UTF32ToUTF8 {
+
+  // Unicode boundaries for UTF8 bytes 1,2,3,4
+  private static final int[] startCodes = new int[] {0, 128, 2048, 65536};
+  private static final int[] endCodes = new int[] {127, 2047, 65535, 1114111};
+
+  static int[] MASKS = new int[32];
+  static {
+    int v = 2;
+    for(int i=0;i<32;i++) {
+      MASKS[i] = v-1;
+      v *= 2;
+    }
+  }
+
+  // Represents one of the N utf8 bytes that (in sequence)
+  // define a code point.  value is the byte value; bits is
+  // how many bits are "used" by utf8 at that byte
+  private static class UTF8Byte {
+    int value;                                    // TODO: change to byte
+    byte bits;
+  }
+
+  // Holds a single code point, as a sequence of 1-4 utf8 bytes:
+  // TODO: maybe move to UnicodeUtil?
+  private static class UTF8Sequence {
+    private final UTF8Byte[] bytes;
+    private int len;
+
+    public UTF8Sequence() {
+      bytes = new UTF8Byte[4];
+      for(int i=0;i<4;i++) {
+        bytes[i] = new UTF8Byte();
+      }
+    }
+
+    public int byteAt(int idx) {
+      return bytes[idx].value;
+    }
+
+    public int numBits(int idx) {
+      return bytes[idx].bits;
+    }
+
+    private void set(int code) {
+      if (code < 128) {
+        // 0xxxxxxx
+        bytes[0].value = code;
+        bytes[0].bits = 7;
+        len = 1;
+      } else if (code < 2048) {
+        // 110yyyxx 10xxxxxx
+        bytes[0].value = (6 << 5) | (code >> 6);
+        bytes[0].bits = 5;
+        setRest(code, 1);
+        len = 2;
+      } else if (code < 65536) {
+        // 1110yyyy 10yyyyxx 10xxxxxx
+        bytes[0].value = (14 << 4) | (code >> 12);
+        bytes[0].bits = 4;
+        setRest(code, 2);
+        len = 3;
+      } else {
+        // 11110zzz 10zzyyyy 10yyyyxx 10xxxxxx
+        bytes[0].value = (30 << 3) | (code >> 18);
+        bytes[0].bits = 3;
+        setRest(code, 3);
+        len = 4;
+      }
+    }
+
+    private void setRest(int code, int numBytes) {
+      for(int i=0;i<numBytes;i++) {
+        bytes[numBytes-i].value = 128 | (code & MASKS[5]);
+        bytes[numBytes-i].bits = 6;
+        code = code >> 6;
+      }
+    }
+
+    @Override
+    public String toString() {
+      StringBuilder b = new StringBuilder();
+      for(int i=0;i<len;i++) {
+        if (i > 0) {
+          b.append(' ');
+        }
+        b.append(Integer.toBinaryString(bytes[i].value));
+      }
+      return b.toString();
+    }
+  }
+
+  private final UTF8Sequence startUTF8 = new UTF8Sequence();
+  private final UTF8Sequence endUTF8 = new UTF8Sequence();
+
+  private final UTF8Sequence tmpUTF8a = new UTF8Sequence();
+  private final UTF8Sequence tmpUTF8b = new UTF8Sequence();
+
+  // Builds necessary utf8 edges between start & end
+  void convertOneEdge(int start, int end, int startCodePoint, int endCodePoint) {
+    startUTF8.set(startCodePoint);
+    endUTF8.set(endCodePoint);
+    //System.out.println("start = " + startUTF8);
+    //System.out.println("  end = " + endUTF8);
+    build(start, end, startUTF8, endUTF8, 0);
+  }
+
+  private void build(int start, int end, UTF8Sequence startUTF8, UTF8Sequence endUTF8, int upto) {
+
+    // Break into start, middle, end:
+    if (startUTF8.byteAt(upto) == endUTF8.byteAt(upto)) {
+      // Degen case: lead with the same byte:
+      if (upto == startUTF8.len-1 && upto == endUTF8.len-1) {
+        // Super degen: just single edge, one UTF8 byte:
+        utf8.addTransition(start, end, startUTF8.byteAt(upto), endUTF8.byteAt(upto));
+        return;
+      } else {
+        assert startUTF8.len > upto+1;
+        assert endUTF8.len > upto+1;
+        int n = utf8.createState();
+
+        // Single value leading edge
+        utf8.addTransition(start, n, startUTF8.byteAt(upto));
+        //start.addTransition(new Transition(startUTF8.byteAt(upto), n));  // type=single
+
+        // Recurse for the rest
+        build(n, end, startUTF8, endUTF8, 1+upto);
+      }
+    } else if (startUTF8.len == endUTF8.len) {
+      if (upto == startUTF8.len-1) {
+        //start.addTransition(new Transition(startUTF8.byteAt(upto), endUTF8.byteAt(upto), end));        // type=startend
+        utf8.addTransition(start, end, startUTF8.byteAt(upto), endUTF8.byteAt(upto));
+      } else {
+        start(start, end, startUTF8, upto, false);
+        if (endUTF8.byteAt(upto) - startUTF8.byteAt(upto) > 1) {
+          // There is a middle
+          all(start, end, startUTF8.byteAt(upto)+1, endUTF8.byteAt(upto)-1, startUTF8.len-upto-1);
+        }
+        end(start, end, endUTF8, upto, false);
+      }
+    } else {
+
+      // start
+      start(start, end, startUTF8, upto, true);
+
+      // possibly middle, spanning multiple num bytes
+      int byteCount = 1+startUTF8.len-upto;
+      final int limit = endUTF8.len-upto;
+      while (byteCount < limit) {
+        // wasteful: we only need first byte, and, we should
+        // statically encode this first byte:
+        tmpUTF8a.set(startCodes[byteCount-1]);
+        tmpUTF8b.set(endCodes[byteCount-1]);
+        all(start, end,
+            tmpUTF8a.byteAt(0),
+            tmpUTF8b.byteAt(0),
+            tmpUTF8a.len - 1);
+        byteCount++;
+      }
+
+      // end
+      end(start, end, endUTF8, upto, true);
+    }
+  }
+
+  private void start(int start, int end, UTF8Sequence startUTF8, int upto, boolean doAll) {
+    if (upto == startUTF8.len-1) {
+      // Done recursing
+      utf8.addTransition(start, end, startUTF8.byteAt(upto), startUTF8.byteAt(upto) | MASKS[startUTF8.numBits(upto)-1]); // type=start
+      //start.addTransition(new Transition(startUTF8.byteAt(upto), startUTF8.byteAt(upto) | MASKS[startUTF8.numBits(upto)-1], end));  // type=start
+    } else {
+      int n = utf8.createState();
+      utf8.addTransition(start, n, startUTF8.byteAt(upto));
+      //start.addTransition(new Transition(startUTF8.byteAt(upto), n));  // type=start
+      start(n, end, startUTF8, 1+upto, true);
+      int endCode = startUTF8.byteAt(upto) | MASKS[startUTF8.numBits(upto)-1];
+      if (doAll && startUTF8.byteAt(upto) != endCode) {
+        all(start, end, startUTF8.byteAt(upto)+1, endCode, startUTF8.len-upto-1);
+      }
+    }
+  }
+
+  private void end(int start, int end, UTF8Sequence endUTF8, int upto, boolean doAll) {
+    if (upto == endUTF8.len-1) {
+      // Done recursing
+      //start.addTransition(new Transition(endUTF8.byteAt(upto) & (~MASKS[endUTF8.numBits(upto)-1]), endUTF8.byteAt(upto), end));   // type=end
+      utf8.addTransition(start, end, endUTF8.byteAt(upto) & (~MASKS[endUTF8.numBits(upto)-1]), endUTF8.byteAt(upto));
+    } else {
+      final int startCode;
+      if (endUTF8.numBits(upto) == 5) {
+        // special case -- avoid created unused edges (endUTF8
+        // doesn't accept certain byte sequences) -- there
+        // are other cases we could optimize too:
+        startCode = 194;
+      } else {
+        startCode = endUTF8.byteAt(upto) & (~MASKS[endUTF8.numBits(upto)-1]);
+      }
+      if (doAll && endUTF8.byteAt(upto) != startCode) {
+        all(start, end, startCode, endUTF8.byteAt(upto)-1, endUTF8.len-upto-1);
+      }
+      int n = utf8.createState();
+      //start.addTransition(new Transition(endUTF8.byteAt(upto), n));  // type=end
+      utf8.addTransition(start, n, endUTF8.byteAt(upto));
+      end(n, end, endUTF8, 1+upto, true);
+    }
+  }
+
+  private void all(int start, int end, int startCode, int endCode, int left) {
+    if (left == 0) {
+      //start.addTransition(new Transition(startCode, endCode, end));  // type=all
+      utf8.addTransition(start, end, startCode, endCode);
+    } else {
+      int lastN = utf8.createState();
+      //start.addTransition(new Transition(startCode, endCode, lastN));  // type=all
+      utf8.addTransition(start, lastN, startCode, endCode);
+      while (left > 1) {
+        int n = utf8.createState();
+        //lastN.addTransition(new Transition(128, 191, n));  // type=all*
+        utf8.addTransition(lastN, n, 128, 191); // type=all*
+        left--;
+        lastN = n;
+      }
+      //lastN.addTransition(new Transition(128, 191, end)); // type = all*
+      utf8.addTransition(lastN, end, 128, 191); // type = all*
+    }
+  }
+
+  Automaton.Builder utf8;
+
+  /** Converts an incoming utf32 automaton to an equivalent
+   *  utf8 one.  The incoming automaton need not be
+   *  deterministic.  Note that the returned automaton will
+   *  not in general be deterministic, so you must
+   *  determinize it if that's needed. */
+  public Automaton convert(Automaton utf32) {
+    if (utf32.getNumStates() == 0) {
+      return utf32;
+    }
+
+    int[] map = new int[utf32.getNumStates()];
+    Arrays.fill(map, -1);
+
+    List<Integer> pending = new ArrayList<>();
+    int utf32State = 0;
+    pending.add(utf32State);
+    utf8 = new Automaton.Builder();
+       
+    int utf8State = utf8.createState();
+
+    utf8.setAccept(utf8State, utf32.isAccept(utf32State));
+
+    map[utf32State] = utf8State;
+    
+    Transition scratch = new Transition();
+    
+    while (pending.size() != 0) {
+      utf32State = pending.remove(pending.size()-1);
+      utf8State = map[utf32State];
+      assert utf8State != -1;
+
+      int numTransitions = utf32.getNumTransitions(utf32State);
+      utf32.initTransition(utf32State, scratch);
+      //System.out.println("  convert state=" + utf32State + " numTransitions=" + numTransitions);
+      for(int i=0;i<numTransitions;i++) {
+        utf32.getNextTransition(scratch);
+        int destUTF32 = scratch.dest;
+        int destUTF8 = map[destUTF32];
+        //System.out.println("    transition min=" + scratch.min + " max=" + scratch.max);
+        if (destUTF8 == -1) {
+          destUTF8 = utf8.createState();
+          //System.out.println("      create dest=" + destUTF8 +" accept=" + utf32.isAccept(destUTF32));
+          utf8.setAccept(destUTF8, utf32.isAccept(destUTF32));
+          map[destUTF32] = destUTF8;
+          pending.add(destUTF32);
+        }
+
+        // Writes new transitions into pendingTransitions:
+        convertOneEdge(utf8State, destUTF8, scratch.min, scratch.max);
+      }
+    }
+
+    return utf8.finish();
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8Light.java b/lucene/core/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8Light.java
deleted file mode 100644
index 3e40f63..0000000
--- a/lucene/core/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8Light.java
+++ /dev/null
@@ -1,314 +0,0 @@
-package org.apache.lucene.util.automaton;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.Arrays;
-import java.util.ArrayList;
-import java.util.List;
-
-// TODO
-//   - do we really need the .bits...?  if not we can make util in UnicodeUtil to convert 1 char into a BytesRef
-
-/** 
- * Converts UTF-32 automata to the equivalent UTF-8 representation.
- * @lucene.internal 
- */
-public final class UTF32ToUTF8Light {
-
-  // Unicode boundaries for UTF8 bytes 1,2,3,4
-  private static final int[] startCodes = new int[] {0, 128, 2048, 65536};
-  private static final int[] endCodes = new int[] {127, 2047, 65535, 1114111};
-
-  static int[] MASKS = new int[32];
-  static {
-    int v = 2;
-    for(int i=0;i<32;i++) {
-      MASKS[i] = v-1;
-      v *= 2;
-    }
-  }
-
-  // Represents one of the N utf8 bytes that (in sequence)
-  // define a code point.  value is the byte value; bits is
-  // how many bits are "used" by utf8 at that byte
-  private static class UTF8Byte {
-    int value;                                    // TODO: change to byte
-    byte bits;
-  }
-
-  // Holds a single code point, as a sequence of 1-4 utf8 bytes:
-  // TODO: maybe move to UnicodeUtil?
-  private static class UTF8Sequence {
-    private final UTF8Byte[] bytes;
-    private int len;
-
-    public UTF8Sequence() {
-      bytes = new UTF8Byte[4];
-      for(int i=0;i<4;i++) {
-        bytes[i] = new UTF8Byte();
-      }
-    }
-
-    public int byteAt(int idx) {
-      return bytes[idx].value;
-    }
-
-    public int numBits(int idx) {
-      return bytes[idx].bits;
-    }
-
-    private void set(int code) {
-      if (code < 128) {
-        // 0xxxxxxx
-        bytes[0].value = code;
-        bytes[0].bits = 7;
-        len = 1;
-      } else if (code < 2048) {
-        // 110yyyxx 10xxxxxx
-        bytes[0].value = (6 << 5) | (code >> 6);
-        bytes[0].bits = 5;
-        setRest(code, 1);
-        len = 2;
-      } else if (code < 65536) {
-        // 1110yyyy 10yyyyxx 10xxxxxx
-        bytes[0].value = (14 << 4) | (code >> 12);
-        bytes[0].bits = 4;
-        setRest(code, 2);
-        len = 3;
-      } else {
-        // 11110zzz 10zzyyyy 10yyyyxx 10xxxxxx
-        bytes[0].value = (30 << 3) | (code >> 18);
-        bytes[0].bits = 3;
-        setRest(code, 3);
-        len = 4;
-      }
-    }
-
-    private void setRest(int code, int numBytes) {
-      for(int i=0;i<numBytes;i++) {
-        bytes[numBytes-i].value = 128 | (code & MASKS[5]);
-        bytes[numBytes-i].bits = 6;
-        code = code >> 6;
-      }
-    }
-
-    @Override
-    public String toString() {
-      StringBuilder b = new StringBuilder();
-      for(int i=0;i<len;i++) {
-        if (i > 0) {
-          b.append(' ');
-        }
-        b.append(Integer.toBinaryString(bytes[i].value));
-      }
-      return b.toString();
-    }
-  }
-
-  private final UTF8Sequence startUTF8 = new UTF8Sequence();
-  private final UTF8Sequence endUTF8 = new UTF8Sequence();
-
-  private final UTF8Sequence tmpUTF8a = new UTF8Sequence();
-  private final UTF8Sequence tmpUTF8b = new UTF8Sequence();
-
-  // Builds necessary utf8 edges between start & end
-  void convertOneEdge(int start, int end, int startCodePoint, int endCodePoint) {
-    startUTF8.set(startCodePoint);
-    endUTF8.set(endCodePoint);
-    //System.out.println("start = " + startUTF8);
-    //System.out.println("  end = " + endUTF8);
-    build(start, end, startUTF8, endUTF8, 0);
-  }
-
-  private void build(int start, int end, UTF8Sequence startUTF8, UTF8Sequence endUTF8, int upto) {
-
-    // Break into start, middle, end:
-    if (startUTF8.byteAt(upto) == endUTF8.byteAt(upto)) {
-      // Degen case: lead with the same byte:
-      if (upto == startUTF8.len-1 && upto == endUTF8.len-1) {
-        // Super degen: just single edge, one UTF8 byte:
-        utf8.addTransition(start, end, startUTF8.byteAt(upto), endUTF8.byteAt(upto));
-        return;
-      } else {
-        assert startUTF8.len > upto+1;
-        assert endUTF8.len > upto+1;
-        int n = utf8.createState();
-
-        // Single value leading edge
-        utf8.addTransition(start, n, startUTF8.byteAt(upto));
-        //start.addTransition(new Transition(startUTF8.byteAt(upto), n));  // type=single
-
-        // Recurse for the rest
-        build(n, end, startUTF8, endUTF8, 1+upto);
-      }
-    } else if (startUTF8.len == endUTF8.len) {
-      if (upto == startUTF8.len-1) {
-        //start.addTransition(new Transition(startUTF8.byteAt(upto), endUTF8.byteAt(upto), end));        // type=startend
-        utf8.addTransition(start, end, startUTF8.byteAt(upto), endUTF8.byteAt(upto));
-      } else {
-        start(start, end, startUTF8, upto, false);
-        if (endUTF8.byteAt(upto) - startUTF8.byteAt(upto) > 1) {
-          // There is a middle
-          all(start, end, startUTF8.byteAt(upto)+1, endUTF8.byteAt(upto)-1, startUTF8.len-upto-1);
-        }
-        end(start, end, endUTF8, upto, false);
-      }
-    } else {
-
-      // start
-      start(start, end, startUTF8, upto, true);
-
-      // possibly middle, spanning multiple num bytes
-      int byteCount = 1+startUTF8.len-upto;
-      final int limit = endUTF8.len-upto;
-      while (byteCount < limit) {
-        // wasteful: we only need first byte, and, we should
-        // statically encode this first byte:
-        tmpUTF8a.set(startCodes[byteCount-1]);
-        tmpUTF8b.set(endCodes[byteCount-1]);
-        all(start, end,
-            tmpUTF8a.byteAt(0),
-            tmpUTF8b.byteAt(0),
-            tmpUTF8a.len - 1);
-        byteCount++;
-      }
-
-      // end
-      end(start, end, endUTF8, upto, true);
-    }
-  }
-
-  private void start(int start, int end, UTF8Sequence startUTF8, int upto, boolean doAll) {
-    if (upto == startUTF8.len-1) {
-      // Done recursing
-      utf8.addTransition(start, end, startUTF8.byteAt(upto), startUTF8.byteAt(upto) | MASKS[startUTF8.numBits(upto)-1]); // type=start
-      //start.addTransition(new Transition(startUTF8.byteAt(upto), startUTF8.byteAt(upto) | MASKS[startUTF8.numBits(upto)-1], end));  // type=start
-    } else {
-      int n = utf8.createState();
-      utf8.addTransition(start, n, startUTF8.byteAt(upto));
-      //start.addTransition(new Transition(startUTF8.byteAt(upto), n));  // type=start
-      start(n, end, startUTF8, 1+upto, true);
-      int endCode = startUTF8.byteAt(upto) | MASKS[startUTF8.numBits(upto)-1];
-      if (doAll && startUTF8.byteAt(upto) != endCode) {
-        all(start, end, startUTF8.byteAt(upto)+1, endCode, startUTF8.len-upto-1);
-      }
-    }
-  }
-
-  private void end(int start, int end, UTF8Sequence endUTF8, int upto, boolean doAll) {
-    if (upto == endUTF8.len-1) {
-      // Done recursing
-      //start.addTransition(new Transition(endUTF8.byteAt(upto) & (~MASKS[endUTF8.numBits(upto)-1]), endUTF8.byteAt(upto), end));   // type=end
-      utf8.addTransition(start, end, endUTF8.byteAt(upto) & (~MASKS[endUTF8.numBits(upto)-1]), endUTF8.byteAt(upto));
-    } else {
-      final int startCode;
-      if (endUTF8.numBits(upto) == 5) {
-        // special case -- avoid created unused edges (endUTF8
-        // doesn't accept certain byte sequences) -- there
-        // are other cases we could optimize too:
-        startCode = 194;
-      } else {
-        startCode = endUTF8.byteAt(upto) & (~MASKS[endUTF8.numBits(upto)-1]);
-      }
-      if (doAll && endUTF8.byteAt(upto) != startCode) {
-        all(start, end, startCode, endUTF8.byteAt(upto)-1, endUTF8.len-upto-1);
-      }
-      int n = utf8.createState();
-      //start.addTransition(new Transition(endUTF8.byteAt(upto), n));  // type=end
-      utf8.addTransition(start, n, endUTF8.byteAt(upto));
-      end(n, end, endUTF8, 1+upto, true);
-    }
-  }
-
-  private void all(int start, int end, int startCode, int endCode, int left) {
-    if (left == 0) {
-      //start.addTransition(new Transition(startCode, endCode, end));  // type=all
-      utf8.addTransition(start, end, startCode, endCode);
-    } else {
-      int lastN = utf8.createState();
-      //start.addTransition(new Transition(startCode, endCode, lastN));  // type=all
-      utf8.addTransition(start, lastN, startCode, endCode);
-      while (left > 1) {
-        int n = utf8.createState();
-        //lastN.addTransition(new Transition(128, 191, n));  // type=all*
-        utf8.addTransition(lastN, n, 128, 191); // type=all*
-        left--;
-        lastN = n;
-      }
-      //lastN.addTransition(new Transition(128, 191, end)); // type = all*
-      utf8.addTransition(lastN, end, 128, 191); // type = all*
-    }
-  }
-
-  LightAutomaton.Builder utf8;
-
-  /** Converts an incoming utf32 automaton to an equivalent
-   *  utf8 one.  The incoming automaton need not be
-   *  deterministic.  Note that the returned automaton will
-   *  not in general be deterministic, so you must
-   *  determinize it if that's needed. */
-  public LightAutomaton convert(LightAutomaton utf32) {
-    if (utf32.getNumStates() == 0) {
-      return utf32;
-    }
-
-    int[] map = new int[utf32.getNumStates()];
-    Arrays.fill(map, -1);
-
-    List<Integer> pending = new ArrayList<>();
-    int utf32State = 0;
-    pending.add(utf32State);
-    utf8 = new LightAutomaton.Builder();
-       
-    int utf8State = utf8.createState();
-
-    utf8.setAccept(utf8State, utf32.isAccept(utf32State));
-
-    map[utf32State] = utf8State;
-    
-    Transition scratch = new Transition();
-    
-    while (pending.size() != 0) {
-      utf32State = pending.remove(pending.size()-1);
-      utf8State = map[utf32State];
-      assert utf8State != -1;
-
-      int numTransitions = utf32.getNumTransitions(utf32State);
-      utf32.initTransition(utf32State, scratch);
-      //System.out.println("  convert state=" + utf32State + " numTransitions=" + numTransitions);
-      for(int i=0;i<numTransitions;i++) {
-        utf32.getNextTransition(scratch);
-        int destUTF32 = scratch.dest;
-        int destUTF8 = map[destUTF32];
-        //System.out.println("    transition min=" + scratch.min + " max=" + scratch.max);
-        if (destUTF8 == -1) {
-          destUTF8 = utf8.createState();
-          //System.out.println("      create dest=" + destUTF8 +" accept=" + utf32.isAccept(destUTF32));
-          utf8.setAccept(destUTF8, utf32.isAccept(destUTF32));
-          map[destUTF32] = destUTF8;
-          pending.add(destUTF32);
-        }
-
-        // Writes new transitions into pendingTransitions:
-        convertOneEdge(utf8State, destUTF8, scratch.min, scratch.max);
-      }
-    }
-
-    return utf8.finish();
-  }
-}
diff --git a/lucene/core/src/test/org/apache/lucene/analysis/TestGraphTokenizers.java b/lucene/core/src/test/org/apache/lucene/analysis/TestGraphTokenizers.java
index 26c8573..6802688 100644
--- a/lucene/core/src/test/org/apache/lucene/analysis/TestGraphTokenizers.java
+++ b/lucene/core/src/test/org/apache/lucene/analysis/TestGraphTokenizers.java
@@ -29,9 +29,9 @@ import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.analysis.tokenattributes.OffsetAttribute;
 import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
 import org.apache.lucene.analysis.tokenattributes.PositionLengthAttribute;
-import org.apache.lucene.util.automaton.BasicAutomata;
-import org.apache.lucene.util.automaton.BasicOperations;
-import org.apache.lucene.util.automaton.LightAutomaton;
+import org.apache.lucene.util.automaton.Automata;
+import org.apache.lucene.util.automaton.Operations;
+import org.apache.lucene.util.automaton.Automaton;
 
 public class TestGraphTokenizers extends BaseTokenStreamTestCase {
 
@@ -409,10 +409,10 @@ public class TestGraphTokenizers extends BaseTokenStreamTestCase {
       new Token[] {
         token("abc", 1, 1),
       });
-    final LightAutomaton actual = (new TokenStreamToAutomaton()).toAutomaton(ts);
-    final LightAutomaton expected = s2a("abc");
-    assertTrue(BasicOperations.sameLanguage(BasicOperations.determinize(BasicOperations.removeDeadStates(expected)),
-                                            BasicOperations.determinize(BasicOperations.removeDeadStates(actual))));
+    final Automaton actual = (new TokenStreamToAutomaton()).toAutomaton(ts);
+    final Automaton expected = s2a("abc");
+    assertTrue(Operations.sameLanguage(Operations.determinize(Operations.removeDeadStates(expected)),
+                                       Operations.determinize(Operations.removeDeadStates(actual))));
   }
 
   public void testMultipleHoles() throws Exception {
@@ -421,10 +421,10 @@ public class TestGraphTokenizers extends BaseTokenStreamTestCase {
         token("a", 1, 1),
         token("b", 3, 1),
       });
-    final LightAutomaton actual = (new TokenStreamToAutomaton()).toAutomaton(ts);
-    final LightAutomaton expected = join(s2a("a"), SEP_A, HOLE_A, SEP_A, HOLE_A, SEP_A, s2a("b")); 
-    assertTrue(BasicOperations.sameLanguage(BasicOperations.determinize(BasicOperations.removeDeadStates(expected)),
-                                            BasicOperations.determinize(BasicOperations.removeDeadStates(actual))));
+    final Automaton actual = (new TokenStreamToAutomaton()).toAutomaton(ts);
+    final Automaton expected = join(s2a("a"), SEP_A, HOLE_A, SEP_A, HOLE_A, SEP_A, s2a("b")); 
+    assertTrue(Operations.sameLanguage(Operations.determinize(Operations.removeDeadStates(expected)),
+                                       Operations.determinize(Operations.removeDeadStates(actual))));
   }
 
   public void testSynOverMultipleHoles() throws Exception {
@@ -434,12 +434,12 @@ public class TestGraphTokenizers extends BaseTokenStreamTestCase {
         token("x", 0, 3),
         token("b", 3, 1),
       });
-    final LightAutomaton actual = (new TokenStreamToAutomaton()).toAutomaton(ts);
-    final LightAutomaton a1 = join(s2a("a"), SEP_A, HOLE_A, SEP_A, HOLE_A, SEP_A, s2a("b")); 
-    final LightAutomaton a2 = join(s2a("x"), SEP_A, s2a("b")); 
-    final LightAutomaton expected = BasicOperations.unionLight(a1, a2);
-    assertTrue(BasicOperations.sameLanguage(BasicOperations.determinize(BasicOperations.removeDeadStates(expected)),
-                                            BasicOperations.determinize(BasicOperations.removeDeadStates(actual))));
+    final Automaton actual = (new TokenStreamToAutomaton()).toAutomaton(ts);
+    final Automaton a1 = join(s2a("a"), SEP_A, HOLE_A, SEP_A, HOLE_A, SEP_A, s2a("b")); 
+    final Automaton a2 = join(s2a("x"), SEP_A, s2a("b")); 
+    final Automaton expected = Operations.union(a1, a2);
+    assertTrue(Operations.sameLanguage(Operations.determinize(Operations.removeDeadStates(expected)),
+                                       Operations.determinize(Operations.removeDeadStates(actual))));
   }
 
   // for debugging!
@@ -453,25 +453,25 @@ public class TestGraphTokenizers extends BaseTokenStreamTestCase {
   }
   */
 
-  private static final LightAutomaton SEP_A = BasicAutomata.makeCharLight(TokenStreamToAutomaton.POS_SEP);
-  private static final LightAutomaton HOLE_A = BasicAutomata.makeCharLight(TokenStreamToAutomaton.HOLE);
+  private static final Automaton SEP_A = Automata.makeChar(TokenStreamToAutomaton.POS_SEP);
+  private static final Automaton HOLE_A = Automata.makeChar(TokenStreamToAutomaton.HOLE);
 
-  private LightAutomaton join(String ... strings) {
-    List<LightAutomaton> as = new ArrayList<>();
+  private Automaton join(String ... strings) {
+    List<Automaton> as = new ArrayList<>();
     for(String s : strings) {
       as.add(s2a(s));
       as.add(SEP_A);
     }
     as.remove(as.size()-1);
-    return BasicOperations.concatenateLight(as);
+    return Operations.concatenate(as);
   }
 
-  private LightAutomaton join(LightAutomaton ... as) {
-    return BasicOperations.concatenateLight(Arrays.asList(as));
+  private Automaton join(Automaton ... as) {
+    return Operations.concatenate(Arrays.asList(as));
   }
 
-  private LightAutomaton s2a(String s) {
-    return BasicAutomata.makeStringLight(s);
+  private Automaton s2a(String s) {
+    return Automata.makeString(s);
   }
 
   public void testTwoTokens() throws Exception {
@@ -481,12 +481,12 @@ public class TestGraphTokenizers extends BaseTokenStreamTestCase {
         token("abc", 1, 1),
         token("def", 1, 1),
       });
-    final LightAutomaton actual = (new TokenStreamToAutomaton()).toAutomaton(ts);
-    final LightAutomaton expected =  join("abc", "def");
+    final Automaton actual = (new TokenStreamToAutomaton()).toAutomaton(ts);
+    final Automaton expected =  join("abc", "def");
 
     //toDot(actual);
-    assertTrue(BasicOperations.sameLanguage(BasicOperations.determinize(BasicOperations.removeDeadStates(expected)),
-                                            BasicOperations.determinize(BasicOperations.removeDeadStates(actual))));
+    assertTrue(Operations.sameLanguage(Operations.determinize(Operations.removeDeadStates(expected)),
+                                       Operations.determinize(Operations.removeDeadStates(actual))));
   }
 
   public void testHole() throws Exception {
@@ -496,13 +496,13 @@ public class TestGraphTokenizers extends BaseTokenStreamTestCase {
         token("abc", 1, 1),
         token("def", 2, 1),
       });
-    final LightAutomaton actual = (new TokenStreamToAutomaton()).toAutomaton(ts);
+    final Automaton actual = (new TokenStreamToAutomaton()).toAutomaton(ts);
 
-    final LightAutomaton expected = join(s2a("abc"), SEP_A, HOLE_A, SEP_A, s2a("def"));
+    final Automaton expected = join(s2a("abc"), SEP_A, HOLE_A, SEP_A, s2a("def"));
 
     //toDot(actual);
-    assertTrue(BasicOperations.sameLanguage(BasicOperations.determinize(BasicOperations.removeDeadStates(expected)),
-                                            BasicOperations.determinize(BasicOperations.removeDeadStates(actual))));
+    assertTrue(Operations.sameLanguage(Operations.determinize(Operations.removeDeadStates(expected)),
+                                       Operations.determinize(Operations.removeDeadStates(actual))));
   }
 
   public void testOverlappedTokensSausage() throws Exception {
@@ -513,12 +513,12 @@ public class TestGraphTokenizers extends BaseTokenStreamTestCase {
         token("abc", 1, 1),
         token("xyz", 0, 1)
       });
-    final LightAutomaton actual = (new TokenStreamToAutomaton()).toAutomaton(ts);
-    final LightAutomaton a1 = s2a("abc");
-    final LightAutomaton a2 = s2a("xyz");
-    final LightAutomaton expected = BasicOperations.unionLight(a1, a2);
-    assertTrue(BasicOperations.sameLanguage(BasicOperations.determinize(BasicOperations.removeDeadStates(expected)),
-                                            BasicOperations.determinize(BasicOperations.removeDeadStates(actual))));
+    final Automaton actual = (new TokenStreamToAutomaton()).toAutomaton(ts);
+    final Automaton a1 = s2a("abc");
+    final Automaton a2 = s2a("xyz");
+    final Automaton expected = Operations.union(a1, a2);
+    assertTrue(Operations.sameLanguage(Operations.determinize(Operations.removeDeadStates(expected)),
+                                       Operations.determinize(Operations.removeDeadStates(actual))));
   }
 
   public void testOverlappedTokensLattice() throws Exception {
@@ -529,14 +529,14 @@ public class TestGraphTokenizers extends BaseTokenStreamTestCase {
         token("xyz", 0, 2),
         token("def", 1, 1),
       });
-    final LightAutomaton actual = (new TokenStreamToAutomaton()).toAutomaton(ts);
-    final LightAutomaton a1 = s2a("xyz");
-    final LightAutomaton a2 = join("abc", "def");
+    final Automaton actual = (new TokenStreamToAutomaton()).toAutomaton(ts);
+    final Automaton a1 = s2a("xyz");
+    final Automaton a2 = join("abc", "def");
                                                                    
-    final LightAutomaton expected = BasicOperations.unionLight(a1, a2);
+    final Automaton expected = Operations.union(a1, a2);
     //toDot(actual);
-    assertTrue(BasicOperations.sameLanguage(BasicOperations.determinize(BasicOperations.removeDeadStates(expected)),
-                                            BasicOperations.determinize(BasicOperations.removeDeadStates(actual))));
+    assertTrue(Operations.sameLanguage(Operations.determinize(Operations.removeDeadStates(expected)),
+                                       Operations.determinize(Operations.removeDeadStates(actual))));
   }
 
   public void testSynOverHole() throws Exception {
@@ -547,15 +547,15 @@ public class TestGraphTokenizers extends BaseTokenStreamTestCase {
         token("X", 0, 2),
         token("b", 2, 1),
       });
-    final LightAutomaton actual = (new TokenStreamToAutomaton()).toAutomaton(ts);
-    final LightAutomaton a1 = BasicOperations.unionLight(
+    final Automaton actual = (new TokenStreamToAutomaton()).toAutomaton(ts);
+    final Automaton a1 = Operations.union(
                                                join(s2a("a"), SEP_A, HOLE_A),
                                                s2a("X"));
-    final LightAutomaton expected = BasicOperations.concatenateLight(a1,
+    final Automaton expected = Operations.concatenate(a1,
                                                            join(SEP_A, s2a("b")));
     //toDot(actual);
-    assertTrue(BasicOperations.sameLanguage(BasicOperations.determinize(BasicOperations.removeDeadStates(expected)),
-                                            BasicOperations.determinize(BasicOperations.removeDeadStates(actual))));
+    assertTrue(Operations.sameLanguage(Operations.determinize(Operations.removeDeadStates(expected)),
+                                       Operations.determinize(Operations.removeDeadStates(actual))));
   }
 
   public void testSynOverHole2() throws Exception {
@@ -566,12 +566,12 @@ public class TestGraphTokenizers extends BaseTokenStreamTestCase {
         token("abc", 0, 3),
         token("def", 2, 1),
       });
-    final LightAutomaton actual = (new TokenStreamToAutomaton()).toAutomaton(ts);
-    final LightAutomaton expected = BasicOperations.unionLight(
+    final Automaton actual = (new TokenStreamToAutomaton()).toAutomaton(ts);
+    final Automaton expected = Operations.union(
                                                      join(s2a("xyz"), SEP_A, HOLE_A, SEP_A, s2a("def")),
                                                      s2a("abc"));
-    assertTrue(BasicOperations.sameLanguage(BasicOperations.determinize(BasicOperations.removeDeadStates(expected)),
-                                            BasicOperations.determinize(BasicOperations.removeDeadStates(actual))));
+    assertTrue(Operations.sameLanguage(Operations.determinize(Operations.removeDeadStates(expected)),
+                                       Operations.determinize(Operations.removeDeadStates(actual))));
   }
 
   public void testOverlappedTokensLattice2() throws Exception {
@@ -583,13 +583,13 @@ public class TestGraphTokenizers extends BaseTokenStreamTestCase {
         token("def", 1, 1),
         token("ghi", 1, 1),
       });
-    final LightAutomaton actual = (new TokenStreamToAutomaton()).toAutomaton(ts);
-    final LightAutomaton a1 = s2a("xyz");
-    final LightAutomaton a2 = join("abc", "def", "ghi");
-    final LightAutomaton expected = BasicOperations.unionLight(a1, a2);
+    final Automaton actual = (new TokenStreamToAutomaton()).toAutomaton(ts);
+    final Automaton a1 = s2a("xyz");
+    final Automaton a2 = join("abc", "def", "ghi");
+    final Automaton expected = Operations.union(a1, a2);
     //toDot(actual);
-    assertTrue(BasicOperations.sameLanguage(BasicOperations.determinize(BasicOperations.removeDeadStates(expected)),
-                                            BasicOperations.determinize(BasicOperations.removeDeadStates(actual))));
+    assertTrue(Operations.sameLanguage(Operations.determinize(Operations.removeDeadStates(expected)),
+                                       Operations.determinize(Operations.removeDeadStates(actual))));
   }
 
   public void testToDot() throws Exception {
@@ -604,11 +604,11 @@ public class TestGraphTokenizers extends BaseTokenStreamTestCase {
       new Token[] {
         token("abc", 2, 1),
       });
-    final LightAutomaton actual = (new TokenStreamToAutomaton()).toAutomaton(ts);
-    final LightAutomaton expected = join(HOLE_A, SEP_A, s2a("abc"));
+    final Automaton actual = (new TokenStreamToAutomaton()).toAutomaton(ts);
+    final Automaton expected = join(HOLE_A, SEP_A, s2a("abc"));
     //toDot(actual);
-    assertTrue(BasicOperations.sameLanguage(BasicOperations.determinize(BasicOperations.removeDeadStates(expected)),
-                                            BasicOperations.determinize(BasicOperations.removeDeadStates(actual))));
+    assertTrue(Operations.sameLanguage(Operations.determinize(Operations.removeDeadStates(expected)),
+                                       Operations.determinize(Operations.removeDeadStates(actual))));
   }
 
   // TODO: testEndsWithHole... but we need posInc to set in TS.end()
@@ -619,10 +619,10 @@ public class TestGraphTokenizers extends BaseTokenStreamTestCase {
         token("a", 1, 1),
         token("X", 0, 10),
       });
-    final LightAutomaton actual = (new TokenStreamToAutomaton()).toAutomaton(ts);
-    final LightAutomaton expected = BasicOperations.unionLight(s2a("a"),
+    final Automaton actual = (new TokenStreamToAutomaton()).toAutomaton(ts);
+    final Automaton expected = Operations.union(s2a("a"),
                                                                s2a("X"));
-    assertTrue(BasicOperations.sameLanguage(BasicOperations.determinize(BasicOperations.removeDeadStates(expected)),
-                                            BasicOperations.determinize(BasicOperations.removeDeadStates(actual))));
+    assertTrue(Operations.sameLanguage(Operations.determinize(Operations.removeDeadStates(expected)),
+                                       Operations.determinize(Operations.removeDeadStates(actual))));
   }
 }
diff --git a/lucene/core/src/test/org/apache/lucene/analysis/TestMockAnalyzer.java b/lucene/core/src/test/org/apache/lucene/analysis/TestMockAnalyzer.java
index b1d3443..9d68ea8 100644
--- a/lucene/core/src/test/org/apache/lucene/analysis/TestMockAnalyzer.java
+++ b/lucene/core/src/test/org/apache/lucene/analysis/TestMockAnalyzer.java
@@ -35,8 +35,8 @@ import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.TestUtil;
 import org.apache.lucene.util.automaton.AutomatonTestUtil;
-import org.apache.lucene.util.automaton.BasicAutomata;
-import org.apache.lucene.util.automaton.BasicOperations;
+import org.apache.lucene.util.automaton.Automata;
+import org.apache.lucene.util.automaton.Operations;
 import org.apache.lucene.util.automaton.CharacterRunAutomaton;
 import org.apache.lucene.util.automaton.RegExp;
 
@@ -82,7 +82,7 @@ public class TestMockAnalyzer extends BaseTokenStreamTestCase {
   /** Test a configuration where each character is a term */
   public void testSingleChar() throws Exception {
     CharacterRunAutomaton single =
-        new CharacterRunAutomaton(new RegExp(".").toLightAutomaton());
+        new CharacterRunAutomaton(new RegExp(".").toAutomaton());
     Analyzer a = new MockAnalyzer(random(), single, false);
     assertAnalyzesTo(a, "foobar",
         new String[] { "f", "o", "o", "b", "a", "r" },
@@ -95,7 +95,7 @@ public class TestMockAnalyzer extends BaseTokenStreamTestCase {
   /** Test a configuration where two characters makes a term */
   public void testTwoChars() throws Exception {
     CharacterRunAutomaton single =
-        new CharacterRunAutomaton(new RegExp("..").toLightAutomaton());
+        new CharacterRunAutomaton(new RegExp("..").toAutomaton());
     Analyzer a = new MockAnalyzer(random(), single, false);
     assertAnalyzesTo(a, "foobar",
         new String[] { "fo", "ob", "ar"},
@@ -116,7 +116,7 @@ public class TestMockAnalyzer extends BaseTokenStreamTestCase {
   /** Test a configuration where three characters makes a term */
   public void testThreeChars() throws Exception {
     CharacterRunAutomaton single =
-        new CharacterRunAutomaton(new RegExp("...").toLightAutomaton());
+        new CharacterRunAutomaton(new RegExp("...").toAutomaton());
     Analyzer a = new MockAnalyzer(random(), single, false);
     assertAnalyzesTo(a, "foobar",
         new String[] { "foo", "bar"},
@@ -137,7 +137,7 @@ public class TestMockAnalyzer extends BaseTokenStreamTestCase {
   /** Test a configuration where word starts with one uppercase */
   public void testUppercase() throws Exception {
     CharacterRunAutomaton single =
-        new CharacterRunAutomaton(new RegExp("[A-Z][a-z]*").toLightAutomaton());
+        new CharacterRunAutomaton(new RegExp("[A-Z][a-z]*").toAutomaton());
     Analyzer a = new MockAnalyzer(random(), single, false);
     assertAnalyzesTo(a, "FooBarBAZ",
         new String[] { "Foo", "Bar", "B", "A", "Z"},
@@ -164,9 +164,9 @@ public class TestMockAnalyzer extends BaseTokenStreamTestCase {
   public void testKeep() throws Exception {
     CharacterRunAutomaton keepWords = 
       new CharacterRunAutomaton(
-          BasicOperations.complementLight(
-              BasicOperations.unionLight(
-                  Arrays.asList(BasicAutomata.makeStringLight("foo"), BasicAutomata.makeStringLight("bar")))));
+          Operations.complement(
+              Operations.union(
+                  Arrays.asList(Automata.makeString("foo"), Automata.makeString("bar")))));
     Analyzer a = new MockAnalyzer(random(), MockTokenizer.SIMPLE, true, keepWords);
     assertAnalyzesTo(a, "quick foo brown bar bar fox foo",
         new String[] { "foo", "bar", "bar", "foo" },
@@ -175,7 +175,7 @@ public class TestMockAnalyzer extends BaseTokenStreamTestCase {
   
   /** Test a configuration that behaves a lot like LengthFilter */
   public void testLength() throws Exception {
-    CharacterRunAutomaton length5 = new CharacterRunAutomaton(new RegExp(".{5,}").toLightAutomaton());
+    CharacterRunAutomaton length5 = new CharacterRunAutomaton(new RegExp(".{5,}").toAutomaton());
     Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, true, length5);
     assertAnalyzesTo(a, "ok toolong fine notfine",
         new String[] { "ok", "fine" },
diff --git a/lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3.java b/lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3.java
index da650bf..26c2b06 100644
--- a/lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3.java
+++ b/lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3.java
@@ -183,7 +183,7 @@ public class TestBlockPostingsFormat3 extends LuceneTestCase {
       int numIntersections = atLeast(3);
       for (int i = 0; i < numIntersections; i++) {
         String re = AutomatonTestUtil.randomRegexp(random());
-        CompiledAutomaton automaton = new CompiledAutomaton(new RegExp(re, RegExp.NONE).toLightAutomaton());
+        CompiledAutomaton automaton = new CompiledAutomaton(new RegExp(re, RegExp.NONE).toAutomaton());
         if (automaton.type == CompiledAutomaton.AUTOMATON_TYPE.NORMAL) {
           // TODO: test start term too
           TermsEnum leftIntersection = leftTerms.intersect(automaton, null);
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.java b/lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.java
index c69e3e8..533cc72 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.java
@@ -84,9 +84,9 @@ import org.apache.lucene.util.SetOnce;
 import org.apache.lucene.util.TestUtil;
 import org.apache.lucene.util.ThreadInterruptedException;
 import org.apache.lucene.util.Version;
-import org.apache.lucene.util.automaton.BasicAutomata;
+import org.apache.lucene.util.automaton.Automata;
 import org.apache.lucene.util.automaton.CharacterRunAutomaton;
-import org.apache.lucene.util.automaton.LightAutomaton;
+import org.apache.lucene.util.automaton.Automaton;
 import org.apache.lucene.util.packed.PackedInts;
 import org.junit.Test;
 
@@ -2006,7 +2006,7 @@ public class TestIndexWriter extends LuceneTestCase {
   public void testStopwordsPosIncHole2() throws Exception {
     // use two stopfilters for testing here
     Directory dir = newDirectory();
-    final LightAutomaton secondSet = BasicAutomata.makeStringLight("foobar");
+    final Automaton secondSet = Automata.makeString("foobar");
     Analyzer a = new Analyzer() {
       @Override
       protected TokenStreamComponents createComponents(String fieldName) {
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestTermsEnum.java b/lucene/core/src/test/org/apache/lucene/index/TestTermsEnum.java
index 64a3a8f..9acc4fd 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestTermsEnum.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestTermsEnum.java
@@ -33,9 +33,9 @@ import org.apache.lucene.util.LineFileDocs;
 import org.apache.lucene.util.LuceneTestCase.SuppressCodecs;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.TestUtil;
-import org.apache.lucene.util.automaton.BasicAutomata;
+import org.apache.lucene.util.automaton.Automata;
 import org.apache.lucene.util.automaton.CompiledAutomaton;
-import org.apache.lucene.util.automaton.LightAutomaton;
+import org.apache.lucene.util.automaton.Automaton;
 import org.apache.lucene.util.automaton.RegExp;
 
 @SuppressCodecs({ "SimpleText", "Memory", "Direct" })
@@ -239,12 +239,12 @@ public class TestTermsEnum extends LuceneTestCase {
       final Set<String> acceptTerms = new HashSet<>();
       final TreeSet<BytesRef> sortedAcceptTerms = new TreeSet<>();
       final double keepPct = random().nextDouble();
-      LightAutomaton a;
+      Automaton a;
       if (iter == 0) {
         if (VERBOSE) {
           System.out.println("\nTEST: empty automaton");
         }
-        a = BasicAutomata.makeEmptyLight();
+        a = Automata.makeEmpty();
       } else {
         if (VERBOSE) {
           System.out.println("\nTEST: keepPct=" + keepPct);
@@ -259,7 +259,7 @@ public class TestTermsEnum extends LuceneTestCase {
           acceptTerms.add(s2);
           sortedAcceptTerms.add(new BytesRef(s2));
         }
-        a = BasicAutomata.makeStringUnionLight(sortedAcceptTerms);
+        a = Automata.makeStringUnion(sortedAcceptTerms);
       }
       
       final CompiledAutomaton c = new CompiledAutomaton(a, true, false);
@@ -738,7 +738,7 @@ public class TestTermsEnum extends LuceneTestCase {
     w.shutdown();
     AtomicReader sub = getOnlySegmentReader(r);
     Terms terms = sub.fields().terms("field");
-    LightAutomaton automaton = new RegExp(".*", RegExp.NONE).toLightAutomaton();
+    Automaton automaton = new RegExp(".*", RegExp.NONE).toAutomaton();
     CompiledAutomaton ca = new CompiledAutomaton(automaton, false, false);    
     TermsEnum te = terms.intersect(ca, null);
     assertEquals("aaa", te.next().utf8ToString());
@@ -793,7 +793,7 @@ public class TestTermsEnum extends LuceneTestCase {
     AtomicReader sub = getOnlySegmentReader(r);
     Terms terms = sub.fields().terms("field");
 
-    LightAutomaton automaton = new RegExp(".*d", RegExp.NONE).toLightAutomaton();
+    Automaton automaton = new RegExp(".*d", RegExp.NONE).toAutomaton();
     CompiledAutomaton ca = new CompiledAutomaton(automaton, false, false);    
     TermsEnum te;
     
@@ -847,7 +847,7 @@ public class TestTermsEnum extends LuceneTestCase {
     AtomicReader sub = getOnlySegmentReader(r);
     Terms terms = sub.fields().terms("field");
 
-    LightAutomaton automaton = new RegExp(".*", RegExp.NONE).toLightAutomaton();  // accept ALL
+    Automaton automaton = new RegExp(".*", RegExp.NONE).toAutomaton();  // accept ALL
     CompiledAutomaton ca = new CompiledAutomaton(automaton, false, false);    
 
     TermsEnum te = terms.intersect(ca, null);
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestTermsEnum2.java b/lucene/core/src/test/org/apache/lucene/index/TestTermsEnum2.java
index dfb1d55..f261f16 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestTermsEnum2.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestTermsEnum2.java
@@ -44,7 +44,7 @@ public class TestTermsEnum2 extends LuceneTestCase {
   private IndexReader reader;
   private IndexSearcher searcher;
   private SortedSet<BytesRef> terms; // the terms we put in the index
-  private LightAutomaton termsAutomaton; // automata of the same
+  private Automaton termsAutomaton; // automata of the same
   int numIterations;
 
   @Override
@@ -69,7 +69,7 @@ public class TestTermsEnum2 extends LuceneTestCase {
       writer.addDocument(doc);
     }
     
-    termsAutomaton = BasicAutomata.makeStringUnionLight(terms);
+    termsAutomaton = Automata.makeStringUnion(terms);
     
     reader = writer.getReader();
     searcher = newSearcher(reader);
@@ -88,15 +88,15 @@ public class TestTermsEnum2 extends LuceneTestCase {
 
     for (int i = 0; i < numIterations; i++) {
       String reg = AutomatonTestUtil.randomRegexp(random());
-      LightAutomaton automaton = BasicOperations.determinize(new RegExp(reg, RegExp.NONE).toLightAutomaton());
+      Automaton automaton = Operations.determinize(new RegExp(reg, RegExp.NONE).toAutomaton());
       final List<BytesRef> matchedTerms = new ArrayList<>();
       for(BytesRef t : terms) {
-        if (BasicOperations.run(automaton, t.utf8ToString())) {
+        if (Operations.run(automaton, t.utf8ToString())) {
           matchedTerms.add(t);
         }
       }
 
-      LightAutomaton alternate = BasicAutomata.makeStringUnionLight(matchedTerms);
+      Automaton alternate = Automata.makeStringUnion(matchedTerms);
       //System.out.println("match " + matchedTerms.size() + " " + alternate.getNumberOfStates() + " states, sigma=" + alternate.getStartPoints().length);
       //AutomatonTestUtil.minimizeSimple(alternate);
       //System.out.println("minmize done");
@@ -113,13 +113,13 @@ public class TestTermsEnum2 extends LuceneTestCase {
   public void testSeeking() throws Exception {
     for (int i = 0; i < numIterations; i++) {
       String reg = AutomatonTestUtil.randomRegexp(random());
-      LightAutomaton automaton = BasicOperations.determinize(new RegExp(reg, RegExp.NONE).toLightAutomaton());
+      Automaton automaton = Operations.determinize(new RegExp(reg, RegExp.NONE).toAutomaton());
       TermsEnum te = MultiFields.getTerms(reader, "field").iterator(null);
       ArrayList<BytesRef> unsortedTerms = new ArrayList<>(terms);
       Collections.shuffle(unsortedTerms, random());
 
       for (BytesRef term : unsortedTerms) {
-        if (BasicOperations.run(automaton, term.utf8ToString())) {
+        if (Operations.run(automaton, term.utf8ToString())) {
           // term is accepted
           if (random().nextBoolean()) {
             // seek exact
@@ -157,17 +157,17 @@ public class TestTermsEnum2 extends LuceneTestCase {
   public void testIntersect() throws Exception {
     for (int i = 0; i < numIterations; i++) {
       String reg = AutomatonTestUtil.randomRegexp(random());
-      LightAutomaton automaton = new RegExp(reg, RegExp.NONE).toLightAutomaton();
-      CompiledAutomaton ca = new CompiledAutomaton(automaton, SpecialOperations.isFinite(automaton), false);
+      Automaton automaton = new RegExp(reg, RegExp.NONE).toAutomaton();
+      CompiledAutomaton ca = new CompiledAutomaton(automaton, Operations.isFinite(automaton), false);
       TermsEnum te = MultiFields.getTerms(reader, "field").intersect(ca, null);
-      LightAutomaton expected = BasicOperations.determinize(BasicOperations.intersectionLight(termsAutomaton, automaton));
+      Automaton expected = Operations.determinize(Operations.intersection(termsAutomaton, automaton));
       TreeSet<BytesRef> found = new TreeSet<>();
       while (te.next() != null) {
         found.add(BytesRef.deepCopyOf(te.term()));
       }
       
-      LightAutomaton actual = BasicOperations.determinize(BasicAutomata.makeStringUnionLight(found));
-      assertTrue(BasicOperations.sameLanguage(expected, actual));
+      Automaton actual = Operations.determinize(Automata.makeStringUnion(found));
+      assertTrue(Operations.sameLanguage(expected, actual));
     }
   }
 }
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestAutomatonQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestAutomatonQuery.java
index 06657fa..c1cc032 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestAutomatonQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestAutomatonQuery.java
@@ -34,9 +34,9 @@ import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.Rethrow;
 import org.apache.lucene.util.TestUtil;
 import org.apache.lucene.util.automaton.AutomatonTestUtil;
-import org.apache.lucene.util.automaton.BasicAutomata;
-import org.apache.lucene.util.automaton.BasicOperations;
-import org.apache.lucene.util.automaton.LightAutomaton;
+import org.apache.lucene.util.automaton.Automata;
+import org.apache.lucene.util.automaton.Operations;
+import org.apache.lucene.util.automaton.Automaton;
 
 public class TestAutomatonQuery extends LuceneTestCase {
   private Directory directory;
@@ -86,7 +86,7 @@ public class TestAutomatonQuery extends LuceneTestCase {
     return searcher.search(query, 5).totalHits;
   }
   
-  private void assertAutomatonHits(int expected, LightAutomaton automaton)
+  private void assertAutomatonHits(int expected, Automaton automaton)
       throws IOException {
     AutomatonQuery query = new AutomatonQuery(newTerm("bogus"), automaton);
     
@@ -106,26 +106,24 @@ public class TestAutomatonQuery extends LuceneTestCase {
   /**
    * Test some very simple automata.
    */
-  public void testBasicAutomata() throws IOException {
-    assertAutomatonHits(0, BasicAutomata.makeEmptyLight());
-    assertAutomatonHits(0, BasicAutomata.makeEmptyStringLight());
-    assertAutomatonHits(2, BasicAutomata.makeAnyCharLight());
-    assertAutomatonHits(3, BasicAutomata.makeAnyStringLight());
-    assertAutomatonHits(2, BasicAutomata.makeStringLight("doc"));
-    assertAutomatonHits(1, BasicAutomata.makeCharLight('a'));
-    assertAutomatonHits(2, BasicAutomata.makeCharRangeLight('a', 'b'));
-    assertAutomatonHits(2, BasicAutomata.makeIntervalLight(1233, 2346, 0));
-    assertAutomatonHits(1, BasicAutomata.makeIntervalLight(0, 2000, 0));
-    assertAutomatonHits(2, BasicOperations.unionLight(BasicAutomata.makeCharLight('a'),
-        BasicAutomata.makeCharLight('b')));
-    assertAutomatonHits(0, BasicOperations.intersectionLight(BasicAutomata
-        .makeCharLight('a'), BasicAutomata.makeCharLight('b')));
-    assertAutomatonHits(1, BasicOperations.minusLight(BasicAutomata.makeCharRangeLight('a', 'b'), 
-        BasicAutomata.makeCharLight('a')));
+  public void testAutomata() throws IOException {
+    assertAutomatonHits(0, Automata.makeEmpty());
+    assertAutomatonHits(0, Automata.makeEmptyString());
+    assertAutomatonHits(2, Automata.makeAnyChar());
+    assertAutomatonHits(3, Automata.makeAnyString());
+    assertAutomatonHits(2, Automata.makeString("doc"));
+    assertAutomatonHits(1, Automata.makeChar('a'));
+    assertAutomatonHits(2, Automata.makeCharRange('a', 'b'));
+    assertAutomatonHits(2, Automata.makeInterval(1233, 2346, 0));
+    assertAutomatonHits(1, Automata.makeInterval(0, 2000, 0));
+    assertAutomatonHits(2, Operations.union(Automata.makeChar('a'),
+        Automata.makeChar('b')));
+    assertAutomatonHits(0, Operations.intersection(Automata
+        .makeChar('a'), Automata.makeChar('b')));
+    assertAutomatonHits(1, Operations.minus(Automata.makeCharRange('a', 'b'), 
+        Automata.makeChar('a')));
   }
 
-  // nocommit make a testRandomAutomaton like TestRR2
-  
   /**
    * Test that a nondeterministic automaton works correctly. (It should will be
    * determinized)
@@ -133,27 +131,27 @@ public class TestAutomatonQuery extends LuceneTestCase {
   public void testNFA() throws IOException {
     // accept this or three, the union is an NFA (two transitions for 't' from
     // initial state)
-    LightAutomaton nfa = BasicOperations.unionLight(BasicAutomata.makeStringLight("this"),
-        BasicAutomata.makeStringLight("three"));
+    Automaton nfa = Operations.union(Automata.makeString("this"),
+        Automata.makeString("three"));
     assertAutomatonHits(2, nfa);
   }
   
   public void testEquals() {
-    AutomatonQuery a1 = new AutomatonQuery(newTerm("foobar"), BasicAutomata
-        .makeStringLight("foobar"));
+    AutomatonQuery a1 = new AutomatonQuery(newTerm("foobar"), Automata
+        .makeString("foobar"));
     // reference to a1
     AutomatonQuery a2 = a1;
     // same as a1 (accepts the same language, same term)
     AutomatonQuery a3 = new AutomatonQuery(newTerm("foobar"),
-                            BasicOperations.concatenateLight(
-                                 BasicAutomata.makeStringLight("foo"),
-                                 BasicAutomata.makeStringLight("bar")));
+                            Operations.concatenate(
+                                 Automata.makeString("foo"),
+                                 Automata.makeString("bar")));
     // different than a1 (same term, but different language)
     AutomatonQuery a4 = new AutomatonQuery(newTerm("foobar"),
-                                           BasicAutomata.makeStringLight("different"));
+                                           Automata.makeString("different"));
     // different than a1 (different term, same language)
     AutomatonQuery a5 = new AutomatonQuery(newTerm("blah"),
-                                           BasicAutomata.makeStringLight("foobar"));
+                                           Automata.makeString("foobar"));
     
     assertEquals(a1.hashCode(), a2.hashCode());
     assertEquals(a1, a2);
@@ -179,7 +177,7 @@ public class TestAutomatonQuery extends LuceneTestCase {
    * MultiTermQuery semantics.
    */
   public void testRewriteSingleTerm() throws IOException {
-    AutomatonQuery aq = new AutomatonQuery(newTerm("bogus"), BasicAutomata.makeStringLight("piece"));
+    AutomatonQuery aq = new AutomatonQuery(newTerm("bogus"), Automata.makeString("piece"));
     Terms terms = MultiFields.getTerms(searcher.getIndexReader(), FN);
     assertTrue(aq.getTermsEnum(terms) instanceof SingleTermsEnum);
     assertEquals(1, automatonQueryNrHits(aq));
@@ -190,8 +188,8 @@ public class TestAutomatonQuery extends LuceneTestCase {
    * MultiTermQuery semantics.
    */
   public void testRewritePrefix() throws IOException {
-    LightAutomaton pfx = BasicAutomata.makeStringLight("do");
-    LightAutomaton prefixAutomaton = BasicOperations.concatenateLight(pfx, BasicAutomata.makeAnyStringLight());
+    Automaton pfx = Automata.makeString("do");
+    Automaton prefixAutomaton = Operations.concatenate(pfx, Automata.makeAnyString());
     AutomatonQuery aq = new AutomatonQuery(newTerm("bogus"), prefixAutomaton);
     Terms terms = MultiFields.getTerms(searcher.getIndexReader(), FN);
     assertTrue(aq.getTermsEnum(terms) instanceof PrefixTermsEnum);
@@ -202,7 +200,7 @@ public class TestAutomatonQuery extends LuceneTestCase {
    * Test handling of the empty language
    */
   public void testEmptyOptimization() throws IOException {
-    AutomatonQuery aq = new AutomatonQuery(newTerm("bogus"), BasicAutomata.makeEmptyLight());
+    AutomatonQuery aq = new AutomatonQuery(newTerm("bogus"), Automata.makeEmpty());
     // not yet available: assertTrue(aq.getEnum(searcher.getIndexReader())
     // instanceof EmptyTermEnum);
     Terms terms = MultiFields.getTerms(searcher.getIndexReader(), FN);
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestAutomatonQueryUnicode.java b/lucene/core/src/test/org/apache/lucene/search/TestAutomatonQueryUnicode.java
index 947914e..0d176d8 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestAutomatonQueryUnicode.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestAutomatonQueryUnicode.java
@@ -26,7 +26,7 @@ import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.util.automaton.LightAutomaton;
+import org.apache.lucene.util.automaton.Automaton;
 import org.apache.lucene.util.automaton.RegExp;
 
 /**
@@ -98,7 +98,7 @@ public class TestAutomatonQueryUnicode extends LuceneTestCase {
     return searcher.search(query, 5).totalHits;
   }
 
-  private void assertAutomatonHits(int expected, LightAutomaton automaton)
+  private void assertAutomatonHits(int expected, Automaton automaton)
       throws IOException {
     AutomatonQuery query = new AutomatonQuery(newTerm("bogus"), automaton);
 
@@ -122,7 +122,7 @@ public class TestAutomatonQueryUnicode extends LuceneTestCase {
    * presentation forms block, or a supplementary character.
    */
   public void testSortOrder() throws IOException {
-    LightAutomaton a = new RegExp("((\uD866\uDF05)|\uFB94).*").toLightAutomaton();
+    Automaton a = new RegExp("((\uD866\uDF05)|\uFB94).*").toAutomaton();
     assertAutomatonHits(2, a);
   }
 }
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestRegexpQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestRegexpQuery.java
index 875983e..6ed3140 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestRegexpQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestRegexpQuery.java
@@ -27,10 +27,10 @@ import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.util.automaton.BasicAutomata;
-import org.apache.lucene.util.automaton.BasicOperations;
-import org.apache.lucene.util.automaton.LightAutomaton;
-import org.apache.lucene.util.automaton.LightAutomatonProvider;
+import org.apache.lucene.util.automaton.Automata;
+import org.apache.lucene.util.automaton.Operations;
+import org.apache.lucene.util.automaton.Automaton;
+import org.apache.lucene.util.automaton.AutomatonProvider;
 import org.apache.lucene.util.automaton.RegExp;
 
 /**
@@ -95,15 +95,15 @@ public class TestRegexpQuery extends LuceneTestCase {
   }
   
   public void testCustomProvider() throws IOException {
-    LightAutomatonProvider myProvider = new LightAutomatonProvider() {
+    AutomatonProvider myProvider = new AutomatonProvider() {
       // automaton that matches quick or brown
-      private LightAutomaton quickBrownAutomaton = BasicOperations.unionLight(Arrays
-          .asList(BasicAutomata.makeStringLight("quick"),
-          BasicAutomata.makeStringLight("brown"),
-          BasicAutomata.makeStringLight("bob")));
+      private Automaton quickBrownAutomaton = Operations.union(Arrays
+          .asList(Automata.makeString("quick"),
+          Automata.makeString("brown"),
+          Automata.makeString("bob")));
       
       @Override
-      public LightAutomaton getAutomaton(String name) {
+      public Automaton getAutomaton(String name) {
         if (name.equals("quickBrown")) return quickBrownAutomaton;
         else return null;
       }
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestRegexpRandom2.java b/lucene/core/src/test/org/apache/lucene/search/TestRegexpRandom2.java
index 5db31f7..ead284b 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestRegexpRandom2.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestRegexpRandom2.java
@@ -42,7 +42,7 @@ import org.apache.lucene.util.TestUtil;
 import org.apache.lucene.util.UnicodeUtil;
 import org.apache.lucene.util.automaton.AutomatonTestUtil;
 import org.apache.lucene.util.automaton.CharacterRunAutomaton;
-import org.apache.lucene.util.automaton.LightAutomaton;
+import org.apache.lucene.util.automaton.Automaton;
 import org.apache.lucene.util.automaton.RegExp;
 
 /**
@@ -103,12 +103,12 @@ public class TestRegexpRandom2 extends LuceneTestCase {
   
   /** a stupid regexp query that just blasts thru the terms */
   private class DumbRegexpQuery extends MultiTermQuery {
-    private final LightAutomaton automaton;
+    private final Automaton automaton;
     
     DumbRegexpQuery(Term term, int flags) {
       super(term.field());
       RegExp re = new RegExp(term.text(), flags);
-      automaton = re.toLightAutomaton();
+      automaton = re.toAutomaton();
     }
     
     @Override
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanFirstQuery.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanFirstQuery.java
index fb7a915..9dd2735 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanFirstQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanFirstQuery.java
@@ -36,7 +36,7 @@ public class TestSpanFirstQuery extends LuceneTestCase {
     Directory dir = newDirectory();
     
     // mimic StopAnalyzer
-    CharacterRunAutomaton stopSet = new CharacterRunAutomaton(new RegExp("the|a|of").toLightAutomaton());
+    CharacterRunAutomaton stopSet = new CharacterRunAutomaton(new RegExp("the|a|of").toAutomaton());
     Analyzer analyzer = new MockAnalyzer(random(), MockTokenizer.SIMPLE, true, stopSet);
     
     RandomIndexWriter writer = new RandomIndexWriter(random(), dir, analyzer);
diff --git a/lucene/core/src/test/org/apache/lucene/util/TestQueryBuilder.java b/lucene/core/src/test/org/apache/lucene/util/TestQueryBuilder.java
index 8ebf420..7c0715d 100644
--- a/lucene/core/src/test/org/apache/lucene/util/TestQueryBuilder.java
+++ b/lucene/core/src/test/org/apache/lucene/util/TestQueryBuilder.java
@@ -103,7 +103,7 @@ public class TestQueryBuilder extends LuceneTestCase {
     expected.add(new Term("field", "1"));
     expected.add(new Term("field", "2"), 2);
     
-    CharacterRunAutomaton stopList = new CharacterRunAutomaton(new RegExp("[sS][tT][oO][pP]").toLightAutomaton());
+    CharacterRunAutomaton stopList = new CharacterRunAutomaton(new RegExp("[sS][tT][oO][pP]").toAutomaton());
 
     Analyzer analyzer = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false, stopList);
 
diff --git a/lucene/core/src/test/org/apache/lucene/util/automaton/TestAutomaton.java b/lucene/core/src/test/org/apache/lucene/util/automaton/TestAutomaton.java
new file mode 100644
index 0000000..bff74e6
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/util/automaton/TestAutomaton.java
@@ -0,0 +1,1013 @@
+package org.apache.lucene.util.automaton;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Set;
+
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.IntsRef;
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.TestUtil;
+import org.apache.lucene.util.UnicodeUtil;
+import org.apache.lucene.util.automaton.AutomatonTestUtil.RandomAcceptedStrings;
+import org.apache.lucene.util.fst.Util;
+
+public class TestAutomaton extends LuceneTestCase {
+
+  public void testBasic() throws Exception {
+    Automaton a = new Automaton();
+    int start = a.createState();
+    int x = a.createState();
+    int y = a.createState();
+    int end = a.createState();
+    a.setAccept(end, true);
+
+    a.addTransition(start, x, 'a', 'a');
+    a.addTransition(start, end, 'd', 'd');
+    a.addTransition(x, y, 'b', 'b');
+    a.addTransition(y, end, 'c', 'c');
+    a.finishState();
+  }
+
+  public void testReduceBasic() throws Exception {
+    Automaton a = new Automaton();
+    int start = a.createState();
+    int end = a.createState();
+    a.setAccept(end, true);
+    // Should collapse to a-b:
+    a.addTransition(start, end, 'a', 'a');
+    a.addTransition(start, end, 'b', 'b');
+    a.addTransition(start, end, 'm', 'm');
+    // Should collapse to x-y:
+    a.addTransition(start, end, 'x', 'x');
+    a.addTransition(start, end, 'y', 'y');
+
+    a.finishState();
+    assertEquals(3, a.getNumTransitions(start));
+    Transition scratch = new Transition();
+    a.initTransition(start, scratch);
+    a.getNextTransition(scratch);
+    assertEquals('a', scratch.min);
+    assertEquals('b', scratch.max);
+    a.getNextTransition(scratch);
+    assertEquals('m', scratch.min);
+    assertEquals('m', scratch.max);
+    a.getNextTransition(scratch);
+    assertEquals('x', scratch.min);
+    assertEquals('y', scratch.max);
+  }
+
+  public void testSameLanguage() throws Exception {
+    Automaton a1 = Automata.makeString("foobar");
+    Automaton a2 = Operations.removeDeadStates(Operations.concatenate(
+                            Automata.makeString("foo"),
+                            Automata.makeString("bar")));
+    assertTrue(Operations.sameLanguage(a1, a2));
+  }
+
+  public void testCommonPrefix() throws Exception {
+    Automaton a = Operations.concatenate(
+                            Automata.makeString("foobar"),
+                            Automata.makeAnyString());
+    assertEquals("foobar", Operations.getCommonPrefix(a));
+  }
+
+  public void testConcatenate1() throws Exception {
+    Automaton a = Operations.concatenate(
+                            Automata.makeString("m"),
+                            Automata.makeAnyString());
+    assertTrue(Operations.run(a, "m"));
+    assertTrue(Operations.run(a, "me"));
+    assertTrue(Operations.run(a, "me too"));
+  }
+
+  public void testConcatenate2() throws Exception {
+    Automaton a = Operations.concatenate(Arrays.asList(
+                            Automata.makeString("m"),
+                            Automata.makeAnyString(),
+                            Automata.makeString("n"),
+                            Automata.makeAnyString()));
+    a = Operations.determinize(a);
+    assertTrue(Operations.run(a, "mn"));
+    assertTrue(Operations.run(a, "mone"));
+    assertFalse(Operations.run(a, "m"));
+    assertFalse(Operations.isFinite(a));
+  }
+
+  public void testUnion1() throws Exception {
+    Automaton a = Operations.union(Arrays.asList(
+                            Automata.makeString("foobar"),
+                            Automata.makeString("barbaz")));
+    a = Operations.determinize(a);
+    assertTrue(Operations.run(a, "foobar"));
+    assertTrue(Operations.run(a, "barbaz"));
+
+    assertMatches(a, "foobar", "barbaz");
+  }
+
+  public void testUnion2() throws Exception {
+    Automaton a = Operations.union(Arrays.asList(
+                            Automata.makeString("foobar"),
+                            Automata.makeString(""),
+                            Automata.makeString("barbaz")));
+    a = Operations.determinize(a);
+    assertTrue(Operations.run(a, "foobar"));
+    assertTrue(Operations.run(a, "barbaz"));
+    assertTrue(Operations.run(a, ""));
+
+    assertMatches(a, "", "foobar", "barbaz");
+  }
+
+  public void testMinimizeSimple() throws Exception {
+    Automaton a = Automata.makeString("foobar");
+    Automaton aMin = MinimizationOperations.minimize(a);
+
+    assertTrue(Operations.sameLanguage(a, aMin));
+  }
+
+  public void testMinimize2() throws Exception {
+    Automaton a = Operations.union(Arrays.asList(Automata.makeString("foobar"),
+                                                           Automata.makeString("boobar")));
+    Automaton aMin = MinimizationOperations.minimize(a);
+    assertTrue(Operations.sameLanguage(Operations.determinize(Operations.removeDeadStates(a)), aMin));
+  }
+
+  public void testReverse() throws Exception {
+    Automaton a = Automata.makeString("foobar");
+    Automaton ra = Operations.reverse(a);
+    Automaton a2 = Operations.determinize(Operations.reverse(ra));
+    
+    assertTrue(Operations.sameLanguage(a, a2));
+  }
+
+  public void testOptional() throws Exception {
+    Automaton a = Automata.makeString("foobar");
+    Automaton a2 = Operations.optional(a);
+    a2 = Operations.determinize(a2);
+    
+    assertTrue(Operations.run(a, "foobar"));
+    assertFalse(Operations.run(a, ""));
+    assertTrue(Operations.run(a2, "foobar"));
+    assertTrue(Operations.run(a2, ""));
+  }
+
+  public void testRepeatAny() throws Exception {
+    Automaton a = Automata.makeString("zee");
+    Automaton a2 = Operations.determinize(Operations.repeat(a));
+    assertTrue(Operations.run(a2, ""));
+    assertTrue(Operations.run(a2, "zee"));    
+    assertTrue(Operations.run(a2, "zeezee"));
+    assertTrue(Operations.run(a2, "zeezeezee"));
+  }
+
+  public void testRepeatMin() throws Exception {
+    Automaton a = Automata.makeString("zee");
+    Automaton a2 = Operations.determinize(Operations.repeat(a, 2));
+    assertFalse(Operations.run(a2, ""));
+    assertFalse(Operations.run(a2, "zee"));    
+    assertTrue(Operations.run(a2, "zeezee"));
+    assertTrue(Operations.run(a2, "zeezeezee"));
+  }
+
+  public void testRepeatMinMax1() throws Exception {
+    Automaton a = Automata.makeString("zee");
+    Automaton a2 = Operations.determinize(Operations.repeat(a, 0, 2));
+    assertTrue(Operations.run(a2, ""));
+    assertTrue(Operations.run(a2, "zee"));    
+    assertTrue(Operations.run(a2, "zeezee"));
+    assertFalse(Operations.run(a2, "zeezeezee"));
+  }
+
+  public void testRepeatMinMax2() throws Exception {
+    Automaton a = Automata.makeString("zee");
+    Automaton a2 = Operations.determinize(Operations.repeat(a, 2, 4));
+    assertFalse(Operations.run(a2, ""));
+    assertFalse(Operations.run(a2, "zee"));    
+    assertTrue(Operations.run(a2, "zeezee"));
+    assertTrue(Operations.run(a2, "zeezeezee"));
+    assertTrue(Operations.run(a2, "zeezeezeezee"));
+    assertFalse(Operations.run(a2, "zeezeezeezeezee"));
+  }
+
+  public void testComplement() throws Exception {
+    Automaton a = Automata.makeString("zee");
+    Automaton a2 = Operations.determinize(Operations.complement(a));
+    assertTrue(Operations.run(a2, ""));
+    assertFalse(Operations.run(a2, "zee"));    
+    assertTrue(Operations.run(a2, "zeezee"));
+    assertTrue(Operations.run(a2, "zeezeezee"));
+  }
+
+  public void testInterval() throws Exception {
+    Automaton a = Operations.determinize(Automata.makeInterval(17, 100, 3));
+    assertFalse(Operations.run(a, ""));
+    assertTrue(Operations.run(a, "017"));
+    assertTrue(Operations.run(a, "100"));
+    assertTrue(Operations.run(a, "073"));
+  }
+
+  public void testCommonSuffix() throws Exception {
+    Automaton a = new Automaton();
+    int init = a.createState();
+    int fini = a.createState();
+    a.setAccept(init, true);
+    a.setAccept(fini, true);
+    a.addTransition(init, fini, 'm');
+    a.addTransition(fini, fini, 'm');
+    a.finishState();
+    assertEquals(0, Operations.getCommonSuffixBytesRef(a).length);
+  }
+
+  public void testReverseRandom1() throws Exception {
+    int ITERS = atLeast(100);
+    for(int i=0;i<ITERS;i++) {
+      Automaton a = AutomatonTestUtil.randomAutomaton(random());
+      Automaton ra = Operations.reverse(a);
+      Automaton rra = Operations.reverse(ra);
+      assertTrue(Operations.sameLanguage(Operations.determinize(Operations.removeDeadStates(a)),
+                                              Operations.determinize(Operations.removeDeadStates(rra))));
+    }
+  }
+
+  public void testReverseRandom2() throws Exception {
+    int ITERS = atLeast(100);
+    for(int iter=0;iter<ITERS;iter++) {
+      //System.out.println("TEST: iter=" + iter);
+      Automaton a = AutomatonTestUtil.randomAutomaton(random());
+      if (random().nextBoolean()) {
+        a = Operations.removeDeadStates(a);
+      }
+      Automaton ra = Operations.reverse(a);
+      Automaton rda = Operations.determinize(ra);
+
+      if (Operations.isEmpty(a)) {
+        assertTrue(Operations.isEmpty(rda));
+        continue;
+      }
+
+      RandomAcceptedStrings ras = new RandomAcceptedStrings(a);
+
+      for(int iter2=0;iter2<20;iter2++) {
+        // Find string accepted by original automaton
+        int[] s = ras.getRandomAcceptedString(random());
+
+        // Reverse it
+        for(int j=0;j<s.length/2;j++) {
+          int x = s[j];
+          s[j] = s[s.length-j-1];
+          s[s.length-j-1] = x;
+        }
+        //System.out.println("TEST:   iter2=" + iter2 + " s=" + Arrays.toString(s));
+
+        // Make sure reversed automaton accepts it
+        assertTrue(Operations.run(rda, new IntsRef(s, 0, s.length)));
+      }
+    }
+  }
+
+  public void testAnyStringEmptyString() throws Exception {
+    Automaton a = Operations.determinize(Automata.makeAnyString());
+    assertTrue(Operations.run(a, ""));
+  }
+
+  public void testBasicIsEmpty() throws Exception {
+    Automaton a = new Automaton();
+    a.createState();
+    assertTrue(Operations.isEmpty(a));
+  }
+
+  public void testRemoveDeadTransitionsEmpty() throws Exception {
+    Automaton a = Automata.makeEmpty();
+    Automaton a2 = Operations.removeDeadStates(a);
+    assertTrue(Operations.isEmpty(a2));
+  }
+
+  public void testInvalidAddTransition() throws Exception {
+    Automaton a = new Automaton();
+    int s1 = a.createState();
+    int s2 = a.createState();
+    a.addTransition(s1, s2, 'a');
+    a.addTransition(s2, s2, 'a');
+    try {
+      a.addTransition(s1, s2, 'b');
+      fail("didn't hit expected exception");
+    } catch (IllegalStateException ise) {
+      // expected
+    }
+  }
+
+  public void testBuilderRandom() throws Exception {
+    int ITERS = atLeast(100);
+    for(int iter=0;iter<ITERS;iter++) {
+      Automaton a = AutomatonTestUtil.randomAutomaton(random());
+
+      // Just get all transitions, shuffle, and build a new automaton with the same transitions:
+      List<Transition> allTrans = new ArrayList<>();
+      int numStates = a.getNumStates();
+      for(int s=0;s<numStates;s++) {
+        int count = a.getNumTransitions(s);
+        for(int i=0;i<count;i++) {
+          Transition t = new Transition();
+          a.getTransition(s, i, t);
+          allTrans.add(t);
+        }
+      }
+
+      Automaton.Builder builder = new Automaton.Builder();
+      for(int i=0;i<numStates;i++) {
+        int s = builder.createState();
+        builder.setAccept(s, a.isAccept(s));
+      }
+
+      Collections.shuffle(allTrans, random());
+      for(Transition t : allTrans) {
+        builder.addTransition(t.source, t.dest, t.min, t.max);
+      }
+
+      assertTrue(Operations.sameLanguage(
+                    Operations.determinize(Operations.removeDeadStates(a)),
+                    Operations.determinize(Operations.removeDeadStates(builder.finish()))));
+      
+    }
+  }
+
+  public void testIsTotal() throws Exception {
+    assertFalse(Operations.isTotal(new Automaton()));
+    Automaton a = new Automaton();
+    int init = a.createState();
+    int fini = a.createState();
+    a.setAccept(fini, true);
+    a.addTransition(init, fini, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);
+    a.finishState();
+    assertFalse(Operations.isTotal(a));
+    a.addTransition(fini, fini, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);
+    a.finishState();
+    assertFalse(Operations.isTotal(a));
+    a.setAccept(init, true);
+    assertTrue(Operations.isTotal(MinimizationOperations.minimize(a)));
+  }
+
+  public void testMinimizeEmpty() throws Exception {
+    Automaton a = new Automaton();
+    int init = a.createState();
+    int fini = a.createState();
+    a.addTransition(init, fini, 'a');
+    a.finishState();
+    a = MinimizationOperations.minimize(a);
+    assertEquals(0, a.getNumStates());
+  }
+
+  public void testMinus() throws Exception {
+    Automaton a1 = Automata.makeString("foobar");
+    Automaton a2 = Automata.makeString("boobar");
+    Automaton a3 = Automata.makeString("beebar");
+    Automaton a = Operations.union(Arrays.asList(a1, a2, a3));
+    if (random().nextBoolean()) {
+      a = Operations.determinize(a);
+    } else if (random().nextBoolean()) {
+      a = MinimizationOperations.minimize(a);
+    }
+    assertMatches(a, "foobar", "beebar", "boobar");
+
+    Automaton a4 = Operations.determinize(Operations.minus(a, a2));
+    
+    assertTrue(Operations.run(a4, "foobar"));
+    assertFalse(Operations.run(a4, "boobar"));
+    assertTrue(Operations.run(a4, "beebar"));
+    assertMatches(a4, "foobar", "beebar");
+
+    a4 = Operations.determinize(Operations.minus(a4, a1));
+    assertFalse(Operations.run(a4, "foobar"));
+    assertFalse(Operations.run(a4, "boobar"));
+    assertTrue(Operations.run(a4, "beebar"));
+    assertMatches(a4, "beebar");
+
+    a4 = Operations.determinize(Operations.minus(a4, a3));
+    assertFalse(Operations.run(a4, "foobar"));
+    assertFalse(Operations.run(a4, "boobar"));
+    assertFalse(Operations.run(a4, "beebar"));
+    assertMatches(a4);
+  }
+
+  public void testOneInterval() throws Exception {
+    Automaton a = Automata.makeInterval(999, 1032, 0);
+    a = Operations.determinize(a);
+    assertTrue(Operations.run(a, "0999"));
+    assertTrue(Operations.run(a, "00999"));
+    assertTrue(Operations.run(a, "000999"));
+  }
+
+  public void testAnotherInterval() throws Exception {
+    Automaton a = Automata.makeInterval(1, 2, 0);
+    a = Operations.determinize(a);
+    assertTrue(Operations.run(a, "01"));
+  }
+
+  public void testIntervalRandom() throws Exception {
+    int ITERS = atLeast(100);
+    for(int iter=0;iter<ITERS;iter++) {
+      int min = TestUtil.nextInt(random(), 0, 100000);
+      int max = TestUtil.nextInt(random(), min, min+100000);
+      int digits;
+      if (random().nextBoolean()) {
+        digits = 0;
+      } else {
+        String s = Integer.toString(max);
+        digits = TestUtil.nextInt(random(), s.length(), 2*s.length());
+      }
+      StringBuilder b = new StringBuilder();
+      for(int i=0;i<digits;i++) {
+        b.append('0');
+      }
+      String prefix = b.toString();
+
+      Automaton a = Operations.determinize(Automata.makeInterval(min, max, digits));
+      if (random().nextBoolean()) {
+        a = MinimizationOperations.minimize(a);
+      }
+      String mins = Integer.toString(min);
+      String maxs = Integer.toString(max);
+      if (digits > 0) {
+        mins = prefix.substring(mins.length()) + mins;
+        maxs = prefix.substring(maxs.length()) + maxs;
+      }
+      assertTrue(Operations.run(a, mins));
+      assertTrue(Operations.run(a, maxs));
+
+      for(int iter2=0;iter2<100;iter2++) {
+        int x = random().nextInt(2*max);
+        boolean expected = x >= min && x <= max;
+        String sx = Integer.toString(x);
+        if (sx.length() < digits) {
+          // Left-fill with 0s
+          sx = b.substring(sx.length()) + sx;
+        } else if (digits == 0) {
+          // Left-fill with random number of 0s:
+          int numZeros = random().nextInt(10);
+          StringBuilder sb = new StringBuilder();
+          for(int i=0;i<numZeros;i++) {
+            sb.append('0');
+          }
+          sb.append(sx);
+          sx = sb.toString();
+        }
+        assertEquals(expected, Operations.run(a, sx));
+      }
+    }
+  }
+
+  private void assertMatches(Automaton a, String... strings) {
+    Set<IntsRef> expected = new HashSet<>();
+    for(String s : strings) {
+      IntsRef ints = new IntsRef();
+      expected.add(Util.toUTF32(s, ints));
+    }
+
+    assertEquals(expected, Operations.getFiniteStrings(Operations.determinize(a), -1)); 
+  }
+
+  public void testConcatenatePreservesDet() throws Exception {
+    Automaton a1 = Automata.makeString("foobar");
+    assertTrue(a1.isDeterministic());
+    Automaton a2 = Automata.makeString("baz");
+    assertTrue(a2.isDeterministic());
+    assertTrue((Operations.concatenate(Arrays.asList(a1, a2)).isDeterministic()));
+  }
+
+  public void testRemoveDeadStates() throws Exception {
+    Automaton a = Operations.concatenate(Arrays.asList(Automata.makeString("x"),
+                                                                      Automata.makeString("y")));
+    assertEquals(4, a.getNumStates());
+    a = Operations.removeDeadStates(a);
+    assertEquals(3, a.getNumStates());
+  }
+
+  public void testRemoveDeadStatesEmpty1() throws Exception {
+    Automaton a = new Automaton();
+    a.finishState();
+    assertTrue(Operations.isEmpty(a));
+    assertTrue(Operations.isEmpty(Operations.removeDeadStates(a)));
+  }
+
+  public void testRemoveDeadStatesEmpty2() throws Exception {
+    Automaton a = new Automaton();
+    a.finishState();
+    assertTrue(Operations.isEmpty(a));
+    assertTrue(Operations.isEmpty(Operations.removeDeadStates(a)));
+  }
+
+  public void testRemoveDeadStatesEmpty3() throws Exception {
+    Automaton a = new Automaton();
+    int init = a.createState();
+    int fini = a.createState();
+    a.addTransition(init, fini, 'a');
+    Automaton a2 = Operations.removeDeadStates(a);
+    assertEquals(0, a2.getNumStates());
+  }
+
+  public void testConcatEmpty() throws Exception {
+    // If you concat empty automaton to anything the result should still be empty:
+    Automaton a = Operations.concatenate(Automata.makeEmpty(),
+                                                        Automata.makeString("foo"));
+    assertEquals(new HashSet<IntsRef>(), Operations.getFiniteStrings(a, -1));
+
+    a = Operations.concatenate(Automata.makeString("foo"),
+                                         Automata.makeEmpty());
+    assertEquals(new HashSet<IntsRef>(), Operations.getFiniteStrings(a, -1));
+  }
+
+  public void testSeemsNonEmptyButIsNot1() throws Exception {
+    Automaton a = new Automaton();
+    // Init state has a transition but doesn't lead to accept
+    int init = a.createState();
+    int s = a.createState();
+    a.addTransition(init, s, 'a');
+    a.finishState();
+    assertTrue(Operations.isEmpty(a));
+  }
+
+  public void testSeemsNonEmptyButIsNot2() throws Exception {
+    Automaton a = new Automaton();
+    int init = a.createState();
+    int s = a.createState();
+    a.addTransition(init, s, 'a');
+    // An orphan'd accept state
+    s = a.createState();
+    a.setAccept(s, true);
+    a.finishState();
+    assertTrue(Operations.isEmpty(a));
+  }
+
+  public void testSameLanguage1() throws Exception {
+    Automaton a = Automata.makeEmptyString();
+    Automaton a2 = Automata.makeEmptyString();
+    int state = a2.createState();
+    a2.addTransition(0, state, 'a');
+    a2.finishState();
+    assertTrue(Operations.sameLanguage(Operations.removeDeadStates(a),
+                                            Operations.removeDeadStates(a2)));
+  }
+
+  private Automaton randomNoOp(Automaton a) {
+    switch (random().nextInt(5)) {
+    case 0:
+      if (VERBOSE) {
+        System.out.println("  randomNoOp: determinize");
+      }
+      return Operations.determinize(a);
+    case 1:
+      if (VERBOSE) {
+        System.out.println("  randomNoOp: minimize");
+      }
+      return MinimizationOperations.minimize(a);
+    case 2:
+      if (VERBOSE) {
+        System.out.println("  randomNoOp: removeDeadStates");
+      }
+      return Operations.removeDeadStates(a);
+    case 3:
+      if (VERBOSE) {
+        System.out.println("  randomNoOp: reverse reverse");
+      }
+      a = Operations.reverse(a);
+      a = randomNoOp(a);
+      return Operations.reverse(a);
+    case 4:
+      if (VERBOSE) {
+        System.out.println("  randomNoOp: concat empty string");
+      }
+      return Operations.concatenate(a, Automata.makeEmptyString());
+    case 5:
+      if (VERBOSE) {
+        System.out.println("  randomNoOp: union empty automaton");
+      }
+      return Operations.union(a, Automata.makeEmpty());
+    }
+    assert false;
+    return null;
+  }
+
+  private Automaton unionTerms(Collection<BytesRef> terms) {
+    Automaton a;
+    if (random().nextBoolean()) {
+      if (VERBOSE) {
+        System.out.println("TEST: unionTerms: use union");
+      }
+      List<Automaton> as = new ArrayList<>();
+      for(BytesRef term : terms) {
+        as.add(Automata.makeString(term.utf8ToString()));
+      }
+      a = Operations.union(as);
+    } else {
+      if (VERBOSE) {
+        System.out.println("TEST: unionTerms: use makeStringUnion");
+      }
+      List<BytesRef> termsList = new ArrayList<>(terms);
+      Collections.sort(termsList);
+      a = Automata.makeStringUnion(termsList);
+    }
+
+    return randomNoOp(a);
+  }
+
+  private String getRandomString(boolean isAscii) {
+    if (isAscii) {
+      return TestUtil.randomSimpleString(random());
+    } else {
+      return TestUtil.randomRealisticUnicodeString(random());
+    }
+  }
+
+  public void testRandomFinite() throws Exception {
+
+    int numTerms = atLeast(10);
+    int iters = atLeast(100);
+
+    // Some of the ops we do (stripping random byte, reverse) turn valid UTF8 into invalid if we allow non-ascii:
+    boolean isAscii = random().nextBoolean();
+
+    if (VERBOSE) {
+      System.out.println("TEST: isAscii=" + isAscii + " numTerms" + numTerms + " iters=" + iters);
+    }
+
+    Set<BytesRef> terms = new HashSet<>();
+    while (terms.size() < numTerms) {
+      terms.add(new BytesRef(getRandomString(isAscii)));
+    }
+
+    Automaton a = unionTerms(terms);
+    assertSame(terms, a);
+
+    for(int iter=0;iter<iters;iter++) {
+      if (VERBOSE) {
+        System.out.println("TEST: iter=" + iter + " numTerms=" + terms.size());
+        System.out.println("  terms:");
+        for(BytesRef term : terms) {
+          System.out.println("    " + term);
+        }
+      }
+      switch(random().nextInt(14)) {
+
+      case 0:
+        // concatenate prefix
+        {
+          if (VERBOSE) {
+            System.out.println("  op=concat prefix");
+          }
+          Set<BytesRef> newTerms = new HashSet<>();
+          BytesRef prefix = new BytesRef(getRandomString(isAscii));
+          for(BytesRef term : terms) {
+            BytesRef newTerm = BytesRef.deepCopyOf(prefix);
+            newTerm.append(term);
+            newTerms.add(newTerm);
+          }
+          terms = newTerms;
+          boolean wasDeterministic1 = a.isDeterministic();
+          a = Operations.concatenate(Automata.makeString(prefix.utf8ToString()), a);
+          assertEquals(wasDeterministic1, a.isDeterministic());
+        }
+        break;
+
+      case 1:
+        // concatenate suffix
+        {
+          BytesRef suffix = new BytesRef(getRandomString(isAscii));
+          if (VERBOSE) {
+            System.out.println("  op=concat suffix " + suffix);
+          }
+          Set<BytesRef> newTerms = new HashSet<>();
+          for(BytesRef term : terms) {
+            BytesRef newTerm = BytesRef.deepCopyOf(term);
+            newTerm.append(suffix);
+            newTerms.add(newTerm);
+          }
+          terms = newTerms;
+          a = Operations.concatenate(a, Automata.makeString(suffix.utf8ToString()));
+        }
+        break;
+
+        // nocommit sometimes concat a suffix accepting more than 1 term, and sometimes non-det
+
+      case 2:
+        // determinize
+        if (VERBOSE) {
+          System.out.println("  op=determinize");
+        }
+        a = Operations.determinize(a);
+        assertTrue(a.isDeterministic());
+        break;
+
+      case 3:
+        if (VERBOSE) {
+          System.out.println("  op=minimize");
+        }
+        // minimize
+        a = MinimizationOperations.minimize(a);
+        break;
+
+      case 4:
+        // union
+        {
+          if (VERBOSE) {
+            System.out.println("  op=union");
+          }
+          Set<BytesRef> newTerms = new HashSet<>();
+          int numNewTerms = random().nextInt(5);
+          while (newTerms.size() < numNewTerms) {
+            newTerms.add(new BytesRef(getRandomString(isAscii)));
+          }
+          terms.addAll(newTerms);
+          Automaton newA = unionTerms(newTerms);
+          a = Operations.union(a, newA);
+        }
+        break;
+
+      case 5:
+        // optional
+        {
+          if (VERBOSE) {
+            System.out.println("  op=optional");
+          }
+          a = Operations.optional(a);
+          terms.add(new BytesRef());
+        }
+        break;
+
+      case 6:
+        // minus finite 
+        {
+          if (VERBOSE) {
+            System.out.println("  op=minus finite");
+          }
+          if (terms.size() > 0) {
+            RandomAcceptedStrings rasl = new RandomAcceptedStrings(Operations.removeDeadStates(a));
+            Set<BytesRef> toRemove = new HashSet<>();
+            int numToRemove = TestUtil.nextInt(random(), 1, (terms.size()+1)/2);
+            while (toRemove.size() < numToRemove) {
+              int[] ints = rasl.getRandomAcceptedString(random());
+              BytesRef term = new BytesRef(UnicodeUtil.newString(ints, 0, ints.length));
+              if (toRemove.contains(term) == false) {
+                toRemove.add(term);
+              }
+            }
+            for(BytesRef term : toRemove) {
+              boolean removed = terms.remove(term);
+              assertTrue(removed);
+            }
+            Automaton a2 = unionTerms(toRemove);
+            a = Operations.minus(a, a2);
+          }
+        }
+        break;
+
+      case 7:
+        {
+          // minus infinite
+          List<Automaton> as = new ArrayList<>();
+          int count = TestUtil.nextInt(random(), 1, 5);
+          Set<Integer> prefixes = new HashSet<>();
+          while(prefixes.size() < count) {
+            // prefix is a leading ascii byte; we remove <prefix>* from a
+            int prefix = random().nextInt(128);
+            prefixes.add(prefix);
+          }
+
+          if (VERBOSE) {
+            System.out.println("  op=minus infinite prefixes=" + prefixes);
+          }
+
+          for(int prefix : prefixes) {
+            // prefix is a leading ascii byte; we remove <prefix>* from a
+            Automaton a2 = new Automaton();
+            int init = a2.createState();
+            int state = a2.createState();
+            a2.addTransition(init, state, prefix);
+            a2.setAccept(state, true);
+            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);
+            a2.finishState();
+            as.add(a2);
+            Iterator<BytesRef> it = terms.iterator();
+            while (it.hasNext()) {
+              BytesRef term = it.next();
+              if (term.length > 0 && (term.bytes[term.offset] & 0xFF) == prefix) {
+                it.remove();
+              }
+            }
+          }
+          Automaton a2 = randomNoOp(Operations.union(as));
+          a = Operations.minus(a, a2);
+        }
+        break;
+
+      case 8:
+        {
+          int count = TestUtil.nextInt(random(), 10, 20);
+          if (VERBOSE) {
+            System.out.println("  op=intersect infinite count=" + count);
+          }
+          // intersect infinite
+          List<Automaton> as = new ArrayList<>();
+
+          Set<Integer> prefixes = new HashSet<>();
+          while(prefixes.size() < count) {
+            int prefix = random().nextInt(128);
+            prefixes.add(prefix);
+          }
+          if (VERBOSE) {
+            System.out.println("  prefixes=" + prefixes);
+          }
+
+          for(int prefix : prefixes) {
+            // prefix is a leading ascii byte; we retain <prefix>* in a
+            Automaton a2 = new Automaton();
+            int init = a2.createState();
+            int state = a2.createState();
+            a2.addTransition(init, state, prefix);
+            a2.setAccept(state, true);
+            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);
+            a2.finishState();
+            as.add(a2);
+            prefixes.add(prefix);
+          }
+
+          Automaton a2 = Operations.union(as);
+          if (random().nextBoolean()) {
+            a2 = Operations.determinize(a2);
+          } else if (random().nextBoolean()) {
+            a2 = MinimizationOperations.minimize(a2);
+          }
+          a = Operations.intersection(a, a2);
+
+          Iterator<BytesRef> it = terms.iterator();
+          while (it.hasNext()) {
+            BytesRef term = it.next();
+            if (term.length == 0 || prefixes.contains(term.bytes[term.offset]&0xff) == false) {
+              if (VERBOSE) {
+                System.out.println("  drop term=" + term);
+              }
+              it.remove();
+            } else {
+              if (VERBOSE) {
+                System.out.println("  keep term=" + term);
+              }
+            }
+          }
+        }        
+        break;
+
+      case 9:
+        // reverse
+        if (VERBOSE) {
+          System.out.println("  op=reverse");
+        }
+        a = Operations.reverse(a);
+        Set<BytesRef> newTerms = new HashSet<>();
+        for(BytesRef term : terms) {
+          newTerms.add(new BytesRef(new StringBuilder(term.utf8ToString()).reverse().toString()));
+        }
+        terms = newTerms;
+        break;
+
+      case 10:
+        if (VERBOSE) {
+          System.out.println("  op=randomNoOp");
+        }
+        a = randomNoOp(a);
+        break;
+
+      case 11:
+        // interval
+        int min = random().nextInt(1000);
+        int max = min + random().nextInt(50);
+        // digits must be non-zero else we make cycle
+        int digits = Integer.toString(max).length();
+        if (VERBOSE) {
+          System.out.println("  op=union interval min=" + min + " max=" + max + " digits=" + digits);
+        }
+        a = Operations.union(a, Automata.makeInterval(min, max, digits));
+        StringBuilder b = new StringBuilder();
+        for(int i=0;i<digits;i++) {
+          b.append('0');
+        }
+        String prefix = b.toString();
+        for(int i=min;i<=max;i++) {
+          String s = Integer.toString(i);
+          if (s.length() < digits) {
+            // Left-fill with 0s
+            s = prefix.substring(s.length()) + s;
+          }
+          terms.add(new BytesRef(s));
+        }
+        break;
+
+      case 12:
+        if (VERBOSE) {
+          System.out.println("  op=remove the empty string");
+        }
+        a = Operations.minus(a, Automata.makeEmptyString());
+        terms.remove(new BytesRef());
+        break;
+
+      case 13:
+        if (VERBOSE) {
+          System.out.println("  op=add the empty string");
+        }
+        a = Operations.union(a, Automata.makeEmptyString());
+        terms.add(new BytesRef());
+        break;
+      }
+
+      assertSame(terms, a);
+    }
+
+    assertSame(terms, a);
+  }
+
+  private void assertSame(Collection<BytesRef> terms, Automaton a) {
+
+    try {
+      assertTrue(Operations.isFinite(a));
+      assertFalse(Operations.isTotal(a));
+
+      Automaton detA = Operations.determinize(a);
+
+      // Make sure all terms are accepted:
+      IntsRef scratch = new IntsRef();
+      for(BytesRef term : terms) {
+        Util.toIntsRef(term, scratch);
+        assertTrue("failed to accept term=" + term.utf8ToString(), Operations.run(detA, term.utf8ToString()));
+      }
+
+      // Use getFiniteStrings:
+      Set<IntsRef> expected = new HashSet<>();
+      for(BytesRef term : terms) {
+        IntsRef intsRef = new IntsRef();
+        Util.toUTF32(term.utf8ToString(), intsRef);
+        expected.add(intsRef);
+      }
+      Set<IntsRef> actual = Operations.getFiniteStrings(a, -1);
+
+      if (expected.equals(actual) == false) {
+        System.out.println("FAILED:");
+        for(IntsRef term : expected) {
+          if (actual.contains(term) == false) {
+            System.out.println("  term=" + term + " should be accepted but isn't");
+          }
+        }
+        for(IntsRef term : actual) {
+          if (expected.contains(term) == false) {
+            System.out.println("  term=" + term + " is accepted but should not be");
+          }
+        }
+        throw new AssertionError("mismatch");
+      }
+
+      // Use sameLanguage:
+      Automaton a2 = Operations.removeDeadStates(Operations.determinize(unionTerms(terms)));
+      assertTrue(Operations.sameLanguage(a2, Operations.removeDeadStates(Operations.determinize(a))));
+
+      // Do same check, in UTF8 space
+      Automaton utf8 = randomNoOp(new UTF32ToUTF8().convert(a));
+    
+      Set<IntsRef> expected2 = new HashSet<>();
+      for(BytesRef term : terms) {
+        IntsRef intsRef = new IntsRef();
+        Util.toIntsRef(term, intsRef);
+        expected2.add(intsRef);
+      }
+      assertEquals(expected2, Operations.getFiniteStrings(utf8, -1));
+    } catch (AssertionError ae) {
+      System.out.println("TEST: FAILED: not same");
+      System.out.println("  terms (count=" + terms.size() + "):");
+      for(BytesRef term : terms) {
+        System.out.println("    " + term);
+      }
+      System.out.println("  automaton:");
+      System.out.println(a.toDot());
+      //a.writeDot("fail");
+      throw ae;
+    }
+  }
+}
diff --git a/lucene/core/src/test/org/apache/lucene/util/automaton/TestBasicOperations.java b/lucene/core/src/test/org/apache/lucene/util/automaton/TestBasicOperations.java
deleted file mode 100644
index 2252138..0000000
--- a/lucene/core/src/test/org/apache/lucene/util/automaton/TestBasicOperations.java
+++ /dev/null
@@ -1,106 +0,0 @@
-package org.apache.lucene.util.automaton;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.*;
-
-import org.apache.lucene.util.*;
-
-import com.carrotsearch.randomizedtesting.generators.RandomInts;
-
-public class TestBasicOperations extends LuceneTestCase {
-  /** Test string union. */
-  public void testStringUnion() {
-    List<BytesRef> strings = new ArrayList<>();
-    for (int i = RandomInts.randomIntBetween(random(), 0, 1000); --i >= 0;) {
-      strings.add(new BytesRef(TestUtil.randomUnicodeString(random())));
-    }
-
-    Collections.sort(strings);
-    LightAutomaton union = BasicAutomata.makeStringUnionLight(strings);
-    assertTrue(union.isDeterministic());
-    assertTrue(BasicOperations.sameLanguage(union, naiveUnion(strings)));
-  }
-
-  private static LightAutomaton naiveUnion(List<BytesRef> strings) {
-    LightAutomaton[] eachIndividual = new LightAutomaton[strings.size()];
-    int i = 0;
-    for (BytesRef bref : strings) {
-      eachIndividual[i++] = BasicAutomata.makeStringLight(bref.utf8ToString());
-    }
-    return BasicOperations.determinize(BasicOperations.unionLight(Arrays.asList(eachIndividual)));
-  }
-
-  /** Test concatenation with empty language returns empty */
-  public void testEmptyLanguageConcatenate() {
-    LightAutomaton a = BasicAutomata.makeStringLight("a");
-    LightAutomaton concat = BasicOperations.concatenateLight(a, BasicAutomata.makeEmptyLight());
-    assertTrue(BasicOperations.isEmpty(concat));
-  }
-  
-  /** Test optimization to concatenate() with empty String to an NFA */
-  public void testEmptySingletonNFAConcatenate() {
-    LightAutomaton singleton = BasicAutomata.makeStringLight("");
-    LightAutomaton expandedSingleton = singleton;
-    // an NFA (two transitions for 't' from initial state)
-    LightAutomaton nfa = BasicOperations.unionLight(BasicAutomata.makeStringLight("this"),
-        BasicAutomata.makeStringLight("three"));
-    LightAutomaton concat1 = BasicOperations.concatenateLight(expandedSingleton, nfa);
-    LightAutomaton concat2 = BasicOperations.concatenateLight(singleton, nfa);
-    assertFalse(concat2.isDeterministic());
-    assertTrue(BasicOperations.sameLanguage(BasicOperations.determinize(concat1),
-                                            BasicOperations.determinize(concat2)));
-    assertTrue(BasicOperations.sameLanguage(BasicOperations.determinize(nfa),
-                                            BasicOperations.determinize(concat1)));
-    assertTrue(BasicOperations.sameLanguage(BasicOperations.determinize(nfa),
-                                            BasicOperations.determinize(concat2)));
-  }
-
-  public void testGetRandomAcceptedString() throws Throwable {
-    final int ITER1 = atLeast(100);
-    final int ITER2 = atLeast(100);
-    for(int i=0;i<ITER1;i++) {
-
-      final RegExp re = new RegExp(AutomatonTestUtil.randomRegexp(random()), RegExp.NONE);
-      //System.out.println("TEST i=" + i + " re=" + re);
-      final LightAutomaton a = BasicOperations.determinize(re.toLightAutomaton());
-      assertFalse(BasicOperations.isEmpty(a));
-
-      final AutomatonTestUtil.RandomAcceptedStrings rx = new AutomatonTestUtil.RandomAcceptedStrings(a);
-      for(int j=0;j<ITER2;j++) {
-        //System.out.println("TEST: j=" + j);
-        int[] acc = null;
-        try {
-          acc = rx.getRandomAcceptedString(random());
-          final String s = UnicodeUtil.newString(acc, 0, acc.length);
-          //a.writeDot("adot");
-          assertTrue(BasicOperations.run(a, s));
-        } catch (Throwable t) {
-          System.out.println("regexp: " + re);
-          if (acc != null) {
-            System.out.println("fail acc re=" + re + " count=" + acc.length);
-            for(int k=0;k<acc.length;k++) {
-              System.out.println("  " + Integer.toHexString(acc[k]));
-            }
-          }
-          throw t;
-        }
-      }
-    }
-  }
-}
diff --git a/lucene/core/src/test/org/apache/lucene/util/automaton/TestCompiledAutomaton.java b/lucene/core/src/test/org/apache/lucene/util/automaton/TestCompiledAutomaton.java
index 6a86211..7370f34 100644
--- a/lucene/core/src/test/org/apache/lucene/util/automaton/TestCompiledAutomaton.java
+++ b/lucene/core/src/test/org/apache/lucene/util/automaton/TestCompiledAutomaton.java
@@ -36,7 +36,7 @@ public class TestCompiledAutomaton extends LuceneTestCase {
       terms.add(new BytesRef(s));
     }
     Collections.sort(terms);
-    final LightAutomaton a = DaciukMihovAutomatonBuilderLight.build(terms);
+    final Automaton a = DaciukMihovAutomatonBuilder.build(terms);
     return new CompiledAutomaton(a, true, false);
   }
 
diff --git a/lucene/core/src/test/org/apache/lucene/util/automaton/TestDeterminism.java b/lucene/core/src/test/org/apache/lucene/util/automaton/TestDeterminism.java
index 5b48a00..f8d2d76 100644
--- a/lucene/core/src/test/org/apache/lucene/util/automaton/TestDeterminism.java
+++ b/lucene/core/src/test/org/apache/lucene/util/automaton/TestDeterminism.java
@@ -29,7 +29,7 @@ public class TestDeterminism extends LuceneTestCase {
   public void testRegexps() throws Exception {
       int num = atLeast(500);
       for (int i = 0; i < num; i++) {
-        assertAutomaton(new RegExp(AutomatonTestUtil.randomRegexp(random()), RegExp.NONE).toLightAutomaton());
+        assertAutomaton(new RegExp(AutomatonTestUtil.randomRegexp(random()), RegExp.NONE).toAutomaton());
       }
   }
   
@@ -37,42 +37,42 @@ public class TestDeterminism extends LuceneTestCase {
   public void testAgainstSimple() throws Exception {
     int num = atLeast(200);
     for (int i = 0; i < num; i++) {
-      LightAutomaton a = AutomatonTestUtil.randomAutomaton(random());
-      a = AutomatonTestUtil.determinizeSimpleLight(a);
-      LightAutomaton b = BasicOperations.determinize(a);
+      Automaton a = AutomatonTestUtil.randomAutomaton(random());
+      a = AutomatonTestUtil.determinizeSimple(a);
+      Automaton b = Operations.determinize(a);
       // TODO: more verifications possible?
-      assertTrue(BasicOperations.sameLanguage(a, b));
+      assertTrue(Operations.sameLanguage(a, b));
     }
   }
   
-  private static void assertAutomaton(LightAutomaton a) {
-    a = BasicOperations.determinize(BasicOperations.removeDeadStates(a));
+  private static void assertAutomaton(Automaton a) {
+    a = Operations.determinize(Operations.removeDeadStates(a));
 
     // complement(complement(a)) = a
-    LightAutomaton equivalent = BasicOperations.complementLight(BasicOperations.complementLight(a));
-    assertTrue(BasicOperations.sameLanguage(a, equivalent));
+    Automaton equivalent = Operations.complement(Operations.complement(a));
+    assertTrue(Operations.sameLanguage(a, equivalent));
     
     // a union a = a
-    equivalent = BasicOperations.determinize(BasicOperations.removeDeadStates(BasicOperations.unionLight(a, a)));
-    assertTrue(BasicOperations.sameLanguage(a, equivalent));
+    equivalent = Operations.determinize(Operations.removeDeadStates(Operations.union(a, a)));
+    assertTrue(Operations.sameLanguage(a, equivalent));
     
     // a intersect a = a
-    equivalent = BasicOperations.determinize(BasicOperations.removeDeadStates(BasicOperations.intersectionLight(a, a)));
-    assertTrue(BasicOperations.sameLanguage(a, equivalent));
+    equivalent = Operations.determinize(Operations.removeDeadStates(Operations.intersection(a, a)));
+    assertTrue(Operations.sameLanguage(a, equivalent));
     
     // a minus a = empty
-    LightAutomaton empty = BasicOperations.minusLight(a, a);
-    assertTrue(BasicOperations.isEmpty(empty));
+    Automaton empty = Operations.minus(a, a);
+    assertTrue(Operations.isEmpty(empty));
     
     // as long as don't accept the empty string
     // then optional(a) - empty = a
-    if (!BasicOperations.run(a, "")) {
+    if (!Operations.run(a, "")) {
       //System.out.println("test " + a);
-      LightAutomaton optional = BasicOperations.optionalLight(a);
+      Automaton optional = Operations.optional(a);
       //System.out.println("optional " + optional);
-      equivalent = BasicOperations.minusLight(optional, BasicAutomata.makeEmptyStringLight());
+      equivalent = Operations.minus(optional, Automata.makeEmptyString());
       //System.out.println("equiv " + equivalent);
-      assertTrue(BasicOperations.sameLanguage(a, equivalent));
+      assertTrue(Operations.sameLanguage(a, equivalent));
     }
   } 
 }
diff --git a/lucene/core/src/test/org/apache/lucene/util/automaton/TestDeterminizeLexicon.java b/lucene/core/src/test/org/apache/lucene/util/automaton/TestDeterminizeLexicon.java
index 84d0f7a..1ae00e4 100644
--- a/lucene/core/src/test/org/apache/lucene/util/automaton/TestDeterminizeLexicon.java
+++ b/lucene/core/src/test/org/apache/lucene/util/automaton/TestDeterminizeLexicon.java
@@ -30,7 +30,7 @@ import org.apache.lucene.util.TestUtil;
  * somewhat randomly, by determinizing a huge random lexicon.
  */
 public class TestDeterminizeLexicon extends LuceneTestCase {
-  private List<LightAutomaton> automata = new ArrayList<>();
+  private List<Automaton> automata = new ArrayList<>();
   private List<String> terms = new ArrayList<>();
   
   public void testLexicon() throws Exception {
@@ -41,7 +41,7 @@ public class TestDeterminizeLexicon extends LuceneTestCase {
       for (int j = 0; j < 5000; j++) {
         String randomString = TestUtil.randomUnicodeString(random());
         terms.add(randomString);
-        automata.add(BasicAutomata.makeStringLight(randomString));
+        automata.add(Automata.makeString(randomString));
       }
       assertLexicon();
     }
@@ -49,11 +49,11 @@ public class TestDeterminizeLexicon extends LuceneTestCase {
   
   public void assertLexicon() throws Exception {
     Collections.shuffle(automata, random());
-    LightAutomaton lex = BasicOperations.unionLight(automata);
-    lex = BasicOperations.determinize(lex);
-    assertTrue(SpecialOperations.isFinite(lex));
+    Automaton lex = Operations.union(automata);
+    lex = Operations.determinize(lex);
+    assertTrue(Operations.isFinite(lex));
     for (String s : terms) {
-      assertTrue(BasicOperations.run(lex, s));
+      assertTrue(Operations.run(lex, s));
     }
     final ByteRunAutomaton lexByte = new ByteRunAutomaton(lex);
     for (String s : terms) {
diff --git a/lucene/core/src/test/org/apache/lucene/util/automaton/TestLevenshteinAutomata.java b/lucene/core/src/test/org/apache/lucene/util/automaton/TestLevenshteinAutomata.java
index fdb8c54..a4f9a0d 100644
--- a/lucene/core/src/test/org/apache/lucene/util/automaton/TestLevenshteinAutomata.java
+++ b/lucene/core/src/test/org/apache/lucene/util/automaton/TestLevenshteinAutomata.java
@@ -41,7 +41,7 @@ public class TestLevenshteinAutomata extends LuceneTestCase {
   
   // LUCENE-3094
   public void testNoWastedStates() throws Exception {
-    assertFalse(BasicOperations.hasDeadStatesFromInitial(new LevenshteinAutomata("abc", false).toAutomaton(1)));
+    assertFalse(Operations.hasDeadStatesFromInitial(new LevenshteinAutomata("abc", false).toAutomaton(1)));
   }
   
   /** 
@@ -66,8 +66,8 @@ public class TestLevenshteinAutomata extends LuceneTestCase {
   private void assertLev(String s, int maxDistance) {
     LevenshteinAutomata builder = new LevenshteinAutomata(s, false);
     LevenshteinAutomata tbuilder = new LevenshteinAutomata(s, true);
-    LightAutomaton automata[] = new LightAutomaton[maxDistance + 1];
-    LightAutomaton tautomata[] = new LightAutomaton[maxDistance + 1];
+    Automaton automata[] = new Automaton[maxDistance + 1];
+    Automaton tautomata[] = new Automaton[maxDistance + 1];
     for (int n = 0; n < automata.length; n++) {
       automata[n] = builder.toAutomaton(n);
       tautomata[n] = tbuilder.toAutomaton(n);
@@ -75,36 +75,36 @@ public class TestLevenshteinAutomata extends LuceneTestCase {
       assertNotNull(tautomata[n]);
       assertTrue(automata[n].isDeterministic());
       assertTrue(tautomata[n].isDeterministic());
-      assertTrue(SpecialOperations.isFinite(automata[n]));
-      assertTrue(SpecialOperations.isFinite(tautomata[n]));
-      assertFalse(BasicOperations.hasDeadStatesFromInitial(automata[n]));
-      assertFalse(BasicOperations.hasDeadStatesFromInitial(tautomata[n]));
+      assertTrue(Operations.isFinite(automata[n]));
+      assertTrue(Operations.isFinite(tautomata[n]));
+      assertFalse(Operations.hasDeadStatesFromInitial(automata[n]));
+      assertFalse(Operations.hasDeadStatesFromInitial(tautomata[n]));
       // check that the dfa for n-1 accepts a subset of the dfa for n
       if (n > 0) {
-        assertTrue(BasicOperations.subsetOf(BasicOperations.removeDeadStates(automata[n-1]),
-                                            BasicOperations.removeDeadStates(automata[n])));
-        assertTrue(BasicOperations.subsetOf(BasicOperations.removeDeadStates(automata[n-1]),
-                                            BasicOperations.removeDeadStates(tautomata[n])));
-        assertTrue(BasicOperations.subsetOf(BasicOperations.removeDeadStates(tautomata[n-1]),
-                                            BasicOperations.removeDeadStates(automata[n])));
-        assertTrue(BasicOperations.subsetOf(BasicOperations.removeDeadStates(tautomata[n-1]),
-                                            BasicOperations.removeDeadStates(tautomata[n])));
+        assertTrue(Operations.subsetOf(Operations.removeDeadStates(automata[n-1]),
+                                       Operations.removeDeadStates(automata[n])));
+        assertTrue(Operations.subsetOf(Operations.removeDeadStates(automata[n-1]),
+                                       Operations.removeDeadStates(tautomata[n])));
+        assertTrue(Operations.subsetOf(Operations.removeDeadStates(tautomata[n-1]),
+                                       Operations.removeDeadStates(automata[n])));
+        assertTrue(Operations.subsetOf(Operations.removeDeadStates(tautomata[n-1]),
+                                       Operations.removeDeadStates(tautomata[n])));
         assertNotSame(automata[n-1], automata[n]);
       }
       // check that Lev(N) is a subset of LevT(N)
-      assertTrue(BasicOperations.subsetOf(BasicOperations.removeDeadStates(automata[n]),
-                                          BasicOperations.removeDeadStates(tautomata[n])));
+      assertTrue(Operations.subsetOf(Operations.removeDeadStates(automata[n]),
+                                     Operations.removeDeadStates(tautomata[n])));
       // special checks for specific n
       switch(n) {
         case 0:
           // easy, matches the string itself
-          assertTrue(BasicOperations.sameLanguage(BasicAutomata.makeStringLight(s), BasicOperations.removeDeadStates(automata[0])));
-          assertTrue(BasicOperations.sameLanguage(BasicAutomata.makeStringLight(s), BasicOperations.removeDeadStates(tautomata[0])));
+          assertTrue(Operations.sameLanguage(Automata.makeString(s), Operations.removeDeadStates(automata[0])));
+          assertTrue(Operations.sameLanguage(Automata.makeString(s), Operations.removeDeadStates(tautomata[0])));
           break;
         case 1:
           // generate a lev1 naively, and check the accepted lang is the same.
-          assertTrue(BasicOperations.sameLanguage(naiveLev1(s), BasicOperations.removeDeadStates(automata[1])));
-          assertTrue(BasicOperations.sameLanguage(naiveLev1T(s), BasicOperations.removeDeadStates(tautomata[1])));
+          assertTrue(Operations.sameLanguage(naiveLev1(s), Operations.removeDeadStates(automata[1])));
+          assertTrue(Operations.sameLanguage(naiveLev1T(s), Operations.removeDeadStates(tautomata[1])));
           break;
         default:
           assertBruteForce(s, automata[n], n);
@@ -118,14 +118,14 @@ public class TestLevenshteinAutomata extends LuceneTestCase {
    * Return an automaton that accepts all 1-character insertions, deletions, and
    * substitutions of s.
    */
-  private LightAutomaton naiveLev1(String s) {
-    LightAutomaton a = BasicAutomata.makeStringLight(s);
-    a = BasicOperations.unionLight(a, insertionsOf(s));
-    a = MinimizationOperationsLight.minimize(a);
-    a = BasicOperations.unionLight(a, deletionsOf(s));
-    a = MinimizationOperationsLight.minimize(a);
-    a = BasicOperations.unionLight(a, substitutionsOf(s));
-    a = MinimizationOperationsLight.minimize(a);
+  private Automaton naiveLev1(String s) {
+    Automaton a = Automata.makeString(s);
+    a = Operations.union(a, insertionsOf(s));
+    a = MinimizationOperations.minimize(a);
+    a = Operations.union(a, deletionsOf(s));
+    a = MinimizationOperations.minimize(a);
+    a = Operations.union(a, substitutionsOf(s));
+    a = MinimizationOperations.minimize(a);
     
     return a;
   }
@@ -134,10 +134,10 @@ public class TestLevenshteinAutomata extends LuceneTestCase {
    * Return an automaton that accepts all 1-character insertions, deletions,
    * substitutions, and transpositions of s.
    */
-  private LightAutomaton naiveLev1T(String s) {
-    LightAutomaton a = naiveLev1(s);
-    a = BasicOperations.unionLight(a, transpositionsOf(s));
-    a = MinimizationOperationsLight.minimize(a);
+  private Automaton naiveLev1T(String s) {
+    Automaton a = naiveLev1(s);
+    a = Operations.union(a, transpositionsOf(s));
+    a = MinimizationOperations.minimize(a);
     return a;
   }
   
@@ -145,18 +145,18 @@ public class TestLevenshteinAutomata extends LuceneTestCase {
    * Return an automaton that accepts all 1-character insertions of s (inserting
    * one character)
    */
-  private LightAutomaton insertionsOf(String s) {
-    List<LightAutomaton> list = new ArrayList<>();
+  private Automaton insertionsOf(String s) {
+    List<Automaton> list = new ArrayList<>();
     
     for (int i = 0; i <= s.length(); i++) {
-      LightAutomaton a = BasicAutomata.makeStringLight(s.substring(0, i));
-      a = BasicOperations.concatenateLight(a, BasicAutomata.makeAnyCharLight());
-      a = BasicOperations.concatenateLight(a, BasicAutomata.makeStringLight(s.substring(i)));
+      Automaton a = Automata.makeString(s.substring(0, i));
+      a = Operations.concatenate(a, Automata.makeAnyChar());
+      a = Operations.concatenate(a, Automata.makeString(s.substring(i)));
       list.add(a);
     }
     
-    LightAutomaton a = BasicOperations.unionLight(list);
-    a = MinimizationOperationsLight.minimize(a);
+    Automaton a = Operations.union(list);
+    a = MinimizationOperations.minimize(a);
     return a;
   }
   
@@ -164,17 +164,17 @@ public class TestLevenshteinAutomata extends LuceneTestCase {
    * Return an automaton that accepts all 1-character deletions of s (deleting
    * one character).
    */
-  private LightAutomaton deletionsOf(String s) {
-    List<LightAutomaton> list = new ArrayList<>();
+  private Automaton deletionsOf(String s) {
+    List<Automaton> list = new ArrayList<>();
     
     for (int i = 0; i < s.length(); i++) {
-      LightAutomaton a = BasicAutomata.makeStringLight(s.substring(0, i));
-      a = BasicOperations.concatenateLight(a, BasicAutomata.makeStringLight(s.substring(i + 1)));
+      Automaton a = Automata.makeString(s.substring(0, i));
+      a = Operations.concatenate(a, Automata.makeString(s.substring(i + 1)));
       list.add(a);
     }
     
-    LightAutomaton a = BasicOperations.unionLight(list);
-    a = MinimizationOperationsLight.minimize(a);
+    Automaton a = Operations.union(list);
+    a = MinimizationOperations.minimize(a);
     return a;
   }
   
@@ -182,18 +182,18 @@ public class TestLevenshteinAutomata extends LuceneTestCase {
    * Return an automaton that accepts all 1-character substitutions of s
    * (replacing one character)
    */
-  private LightAutomaton substitutionsOf(String s) {
-    List<LightAutomaton> list = new ArrayList<>();
+  private Automaton substitutionsOf(String s) {
+    List<Automaton> list = new ArrayList<>();
     
     for (int i = 0; i < s.length(); i++) {
-      LightAutomaton a = BasicAutomata.makeStringLight(s.substring(0, i));
-      a = BasicOperations.concatenateLight(a, BasicAutomata.makeAnyCharLight());
-      a = BasicOperations.concatenateLight(a, BasicAutomata.makeStringLight(s.substring(i + 1)));
+      Automaton a = Automata.makeString(s.substring(0, i));
+      a = Operations.concatenate(a, Automata.makeAnyChar());
+      a = Operations.concatenate(a, Automata.makeString(s.substring(i + 1)));
       list.add(a);
     }
     
-    LightAutomaton a = BasicOperations.unionLight(list);
-    a = MinimizationOperationsLight.minimize(a);
+    Automaton a = Operations.union(list);
+    a = MinimizationOperations.minimize(a);
     return a;
   }
   
@@ -201,11 +201,11 @@ public class TestLevenshteinAutomata extends LuceneTestCase {
    * Return an automaton that accepts all transpositions of s
    * (transposing two adjacent characters)
    */
-  private LightAutomaton transpositionsOf(String s) {
+  private Automaton transpositionsOf(String s) {
     if (s.length() < 2) {
-      return BasicAutomata.makeEmptyLight();
+      return Automata.makeEmpty();
     }
-    List<LightAutomaton> list = new ArrayList<>();
+    List<Automaton> list = new ArrayList<>();
     for (int i = 0; i < s.length()-1; i++) {
       StringBuilder sb = new StringBuilder();
       sb.append(s.substring(0, i));
@@ -214,15 +214,15 @@ public class TestLevenshteinAutomata extends LuceneTestCase {
       sb.append(s.substring(i+2, s.length()));
       String st = sb.toString();
       if (!st.equals(s)) {
-        list.add(BasicAutomata.makeStringLight(st));
+        list.add(Automata.makeString(st));
       }
     }
-    LightAutomaton a = BasicOperations.unionLight(list);
-    a = MinimizationOperationsLight.minimize(a);
+    Automaton a = Operations.union(list);
+    a = MinimizationOperations.minimize(a);
     return a;
   }
   
-  private void assertBruteForce(String input, LightAutomaton dfa, int distance) {
+  private void assertBruteForce(String input, Automaton dfa, int distance) {
     CharacterRunAutomaton ra = new CharacterRunAutomaton(dfa);
     int maxLen = input.length() + distance + 1;
     int maxNum = (int) Math.pow(2, maxLen);
@@ -237,7 +237,7 @@ public class TestLevenshteinAutomata extends LuceneTestCase {
     }
   }
   
-  private void assertBruteForceT(String input, LightAutomaton dfa, int distance) {
+  private void assertBruteForceT(String input, Automaton dfa, int distance) {
     CharacterRunAutomaton ra = new CharacterRunAutomaton(dfa);
     int maxLen = input.length() + distance + 1;
     int maxNum = (int) Math.pow(2, maxLen);
diff --git a/lucene/core/src/test/org/apache/lucene/util/automaton/TestLightAutomaton.java b/lucene/core/src/test/org/apache/lucene/util/automaton/TestLightAutomaton.java
deleted file mode 100644
index 0f75181..0000000
--- a/lucene/core/src/test/org/apache/lucene/util/automaton/TestLightAutomaton.java
+++ /dev/null
@@ -1,1013 +0,0 @@
-package org.apache.lucene.util.automaton;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Set;
-
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.IntsRef;
-import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.util.TestUtil;
-import org.apache.lucene.util.UnicodeUtil;
-import org.apache.lucene.util.automaton.AutomatonTestUtil.RandomAcceptedStrings;
-import org.apache.lucene.util.fst.Util;
-
-public class TestLightAutomaton extends LuceneTestCase {
-
-  public void testBasic() throws Exception {
-    LightAutomaton a = new LightAutomaton();
-    int start = a.createState();
-    int x = a.createState();
-    int y = a.createState();
-    int end = a.createState();
-    a.setAccept(end, true);
-
-    a.addTransition(start, x, 'a', 'a');
-    a.addTransition(start, end, 'd', 'd');
-    a.addTransition(x, y, 'b', 'b');
-    a.addTransition(y, end, 'c', 'c');
-    a.finishState();
-  }
-
-  public void testReduceBasic() throws Exception {
-    LightAutomaton a = new LightAutomaton();
-    int start = a.createState();
-    int end = a.createState();
-    a.setAccept(end, true);
-    // Should collapse to a-b:
-    a.addTransition(start, end, 'a', 'a');
-    a.addTransition(start, end, 'b', 'b');
-    a.addTransition(start, end, 'm', 'm');
-    // Should collapse to x-y:
-    a.addTransition(start, end, 'x', 'x');
-    a.addTransition(start, end, 'y', 'y');
-
-    a.finishState();
-    assertEquals(3, a.getNumTransitions(start));
-    Transition scratch = new Transition();
-    a.initTransition(start, scratch);
-    a.getNextTransition(scratch);
-    assertEquals('a', scratch.min);
-    assertEquals('b', scratch.max);
-    a.getNextTransition(scratch);
-    assertEquals('m', scratch.min);
-    assertEquals('m', scratch.max);
-    a.getNextTransition(scratch);
-    assertEquals('x', scratch.min);
-    assertEquals('y', scratch.max);
-  }
-
-  public void testSameLanguage() throws Exception {
-    LightAutomaton a1 = BasicAutomata.makeStringLight("foobar");
-    LightAutomaton a2 = BasicOperations.removeDeadStates(BasicOperations.concatenateLight(
-                            BasicAutomata.makeStringLight("foo"),
-                            BasicAutomata.makeStringLight("bar")));
-    assertTrue(BasicOperations.sameLanguage(a1, a2));
-  }
-
-  public void testCommonPrefix() throws Exception {
-    LightAutomaton a = BasicOperations.concatenateLight(
-                            BasicAutomata.makeStringLight("foobar"),
-                            BasicAutomata.makeAnyStringLight());
-    assertEquals("foobar", SpecialOperations.getCommonPrefix(a));
-  }
-
-  public void testConcatenate1() throws Exception {
-    LightAutomaton a = BasicOperations.concatenateLight(
-                            BasicAutomata.makeStringLight("m"),
-                            BasicAutomata.makeAnyStringLight());
-    assertTrue(BasicOperations.run(a, "m"));
-    assertTrue(BasicOperations.run(a, "me"));
-    assertTrue(BasicOperations.run(a, "me too"));
-  }
-
-  public void testConcatenate2() throws Exception {
-    LightAutomaton a = BasicOperations.concatenateLight(Arrays.asList(
-                            BasicAutomata.makeStringLight("m"),
-                            BasicAutomata.makeAnyStringLight(),
-                            BasicAutomata.makeStringLight("n"),
-                            BasicAutomata.makeAnyStringLight()));
-    a = BasicOperations.determinize(a);
-    assertTrue(BasicOperations.run(a, "mn"));
-    assertTrue(BasicOperations.run(a, "mone"));
-    assertFalse(BasicOperations.run(a, "m"));
-    assertFalse(SpecialOperations.isFinite(a));
-  }
-
-  public void testUnion1() throws Exception {
-    LightAutomaton a = BasicOperations.unionLight(Arrays.asList(
-                            BasicAutomata.makeStringLight("foobar"),
-                            BasicAutomata.makeStringLight("barbaz")));
-    a = BasicOperations.determinize(a);
-    assertTrue(BasicOperations.run(a, "foobar"));
-    assertTrue(BasicOperations.run(a, "barbaz"));
-
-    assertMatches(a, "foobar", "barbaz");
-  }
-
-  public void testUnion2() throws Exception {
-    LightAutomaton a = BasicOperations.unionLight(Arrays.asList(
-                            BasicAutomata.makeStringLight("foobar"),
-                            BasicAutomata.makeStringLight(""),
-                            BasicAutomata.makeStringLight("barbaz")));
-    a = BasicOperations.determinize(a);
-    assertTrue(BasicOperations.run(a, "foobar"));
-    assertTrue(BasicOperations.run(a, "barbaz"));
-    assertTrue(BasicOperations.run(a, ""));
-
-    assertMatches(a, "", "foobar", "barbaz");
-  }
-
-  public void testMinimizeSimple() throws Exception {
-    LightAutomaton a = BasicAutomata.makeStringLight("foobar");
-    LightAutomaton aMin = MinimizationOperationsLight.minimize(a);
-
-    assertTrue(BasicOperations.sameLanguage(a, aMin));
-  }
-
-  public void testMinimize2() throws Exception {
-    LightAutomaton a = BasicOperations.unionLight(Arrays.asList(BasicAutomata.makeStringLight("foobar"),
-                                                                BasicAutomata.makeStringLight("boobar")));
-    LightAutomaton aMin = MinimizationOperationsLight.minimize(a);
-    assertTrue(BasicOperations.sameLanguage(BasicOperations.determinize(BasicOperations.removeDeadStates(a)), aMin));
-  }
-
-  public void testReverse() throws Exception {
-    LightAutomaton a = BasicAutomata.makeStringLight("foobar");
-    LightAutomaton ra = SpecialOperations.reverse(a);
-    LightAutomaton a2 = BasicOperations.determinize(SpecialOperations.reverse(ra));
-    
-    assertTrue(BasicOperations.sameLanguage(a, a2));
-  }
-
-  public void testOptional() throws Exception {
-    LightAutomaton a = BasicAutomata.makeStringLight("foobar");
-    LightAutomaton a2 = BasicOperations.optionalLight(a);
-    a2 = BasicOperations.determinize(a2);
-    
-    assertTrue(BasicOperations.run(a, "foobar"));
-    assertFalse(BasicOperations.run(a, ""));
-    assertTrue(BasicOperations.run(a2, "foobar"));
-    assertTrue(BasicOperations.run(a2, ""));
-  }
-
-  public void testRepeatAny() throws Exception {
-    LightAutomaton a = BasicAutomata.makeStringLight("zee");
-    LightAutomaton a2 = BasicOperations.determinize(BasicOperations.repeatLight(a));
-    assertTrue(BasicOperations.run(a2, ""));
-    assertTrue(BasicOperations.run(a2, "zee"));    
-    assertTrue(BasicOperations.run(a2, "zeezee"));
-    assertTrue(BasicOperations.run(a2, "zeezeezee"));
-  }
-
-  public void testRepeatMin() throws Exception {
-    LightAutomaton a = BasicAutomata.makeStringLight("zee");
-    LightAutomaton a2 = BasicOperations.determinize(BasicOperations.repeatLight(a, 2));
-    assertFalse(BasicOperations.run(a2, ""));
-    assertFalse(BasicOperations.run(a2, "zee"));    
-    assertTrue(BasicOperations.run(a2, "zeezee"));
-    assertTrue(BasicOperations.run(a2, "zeezeezee"));
-  }
-
-  public void testRepeatMinMax1() throws Exception {
-    LightAutomaton a = BasicAutomata.makeStringLight("zee");
-    LightAutomaton a2 = BasicOperations.determinize(BasicOperations.repeatLight(a, 0, 2));
-    assertTrue(BasicOperations.run(a2, ""));
-    assertTrue(BasicOperations.run(a2, "zee"));    
-    assertTrue(BasicOperations.run(a2, "zeezee"));
-    assertFalse(BasicOperations.run(a2, "zeezeezee"));
-  }
-
-  public void testRepeatMinMax2() throws Exception {
-    LightAutomaton a = BasicAutomata.makeStringLight("zee");
-    LightAutomaton a2 = BasicOperations.determinize(BasicOperations.repeatLight(a, 2, 4));
-    assertFalse(BasicOperations.run(a2, ""));
-    assertFalse(BasicOperations.run(a2, "zee"));    
-    assertTrue(BasicOperations.run(a2, "zeezee"));
-    assertTrue(BasicOperations.run(a2, "zeezeezee"));
-    assertTrue(BasicOperations.run(a2, "zeezeezeezee"));
-    assertFalse(BasicOperations.run(a2, "zeezeezeezeezee"));
-  }
-
-  public void testComplement() throws Exception {
-    LightAutomaton a = BasicAutomata.makeStringLight("zee");
-    LightAutomaton a2 = BasicOperations.determinize(BasicOperations.complementLight(a));
-    assertTrue(BasicOperations.run(a2, ""));
-    assertFalse(BasicOperations.run(a2, "zee"));    
-    assertTrue(BasicOperations.run(a2, "zeezee"));
-    assertTrue(BasicOperations.run(a2, "zeezeezee"));
-  }
-
-  public void testInterval() throws Exception {
-    LightAutomaton a = BasicOperations.determinize(BasicAutomata.makeIntervalLight(17, 100, 3));
-    assertFalse(BasicOperations.run(a, ""));
-    assertTrue(BasicOperations.run(a, "017"));
-    assertTrue(BasicOperations.run(a, "100"));
-    assertTrue(BasicOperations.run(a, "073"));
-  }
-
-  public void testCommonSuffix() throws Exception {
-    LightAutomaton a = new LightAutomaton();
-    int init = a.createState();
-    int fini = a.createState();
-    a.setAccept(init, true);
-    a.setAccept(fini, true);
-    a.addTransition(init, fini, 'm');
-    a.addTransition(fini, fini, 'm');
-    a.finishState();
-    assertEquals(0, SpecialOperations.getCommonSuffixBytesRef(a).length);
-  }
-
-  public void testReverseRandom1() throws Exception {
-    int ITERS = atLeast(100);
-    for(int i=0;i<ITERS;i++) {
-      LightAutomaton a = AutomatonTestUtil.randomAutomaton(random());
-      LightAutomaton ra = SpecialOperations.reverse(a);
-      LightAutomaton rra = SpecialOperations.reverse(ra);
-      assertTrue(BasicOperations.sameLanguage(BasicOperations.determinize(BasicOperations.removeDeadStates(a)),
-                                              BasicOperations.determinize(BasicOperations.removeDeadStates(rra))));
-    }
-  }
-
-  public void testReverseRandom2() throws Exception {
-    int ITERS = atLeast(100);
-    for(int iter=0;iter<ITERS;iter++) {
-      //System.out.println("TEST: iter=" + iter);
-      LightAutomaton a = AutomatonTestUtil.randomAutomaton(random());
-      if (random().nextBoolean()) {
-        a = BasicOperations.removeDeadStates(a);
-      }
-      LightAutomaton ra = SpecialOperations.reverse(a);
-      LightAutomaton rda = BasicOperations.determinize(ra);
-
-      if (BasicOperations.isEmpty(a)) {
-        assertTrue(BasicOperations.isEmpty(rda));
-        continue;
-      }
-
-      RandomAcceptedStrings ras = new RandomAcceptedStrings(a);
-
-      for(int iter2=0;iter2<20;iter2++) {
-        // Find string accepted by original automaton
-        int[] s = ras.getRandomAcceptedString(random());
-
-        // Reverse it
-        for(int j=0;j<s.length/2;j++) {
-          int x = s[j];
-          s[j] = s[s.length-j-1];
-          s[s.length-j-1] = x;
-        }
-        //System.out.println("TEST:   iter2=" + iter2 + " s=" + Arrays.toString(s));
-
-        // Make sure reversed automaton accepts it
-        assertTrue(BasicOperations.run(rda, new IntsRef(s, 0, s.length)));
-      }
-    }
-  }
-
-  public void testAnyStringEmptyString() throws Exception {
-    LightAutomaton a = BasicOperations.determinize(BasicAutomata.makeAnyStringLight());
-    assertTrue(BasicOperations.run(a, ""));
-  }
-
-  public void testBasicIsEmpty() throws Exception {
-    LightAutomaton a = new LightAutomaton();
-    a.createState();
-    assertTrue(BasicOperations.isEmpty(a));
-  }
-
-  public void testRemoveDeadTransitionsEmpty() throws Exception {
-    LightAutomaton a = BasicAutomata.makeEmptyLight();
-    LightAutomaton a2 = BasicOperations.removeDeadStates(a);
-    assertTrue(BasicOperations.isEmpty(a2));
-  }
-
-  public void testInvalidAddTransition() throws Exception {
-    LightAutomaton a = new LightAutomaton();
-    int s1 = a.createState();
-    int s2 = a.createState();
-    a.addTransition(s1, s2, 'a');
-    a.addTransition(s2, s2, 'a');
-    try {
-      a.addTransition(s1, s2, 'b');
-      fail("didn't hit expected exception");
-    } catch (IllegalStateException ise) {
-      // expected
-    }
-  }
-
-  public void testBuilderRandom() throws Exception {
-    int ITERS = atLeast(100);
-    for(int iter=0;iter<ITERS;iter++) {
-      LightAutomaton a = AutomatonTestUtil.randomAutomaton(random());
-
-      // Just get all transitions, shuffle, and build a new automaton with the same transitions:
-      List<Transition> allTrans = new ArrayList<>();
-      int numStates = a.getNumStates();
-      for(int s=0;s<numStates;s++) {
-        int count = a.getNumTransitions(s);
-        for(int i=0;i<count;i++) {
-          Transition t = new Transition();
-          a.getTransition(s, i, t);
-          allTrans.add(t);
-        }
-      }
-
-      LightAutomaton.Builder builder = new LightAutomaton.Builder();
-      for(int i=0;i<numStates;i++) {
-        int s = builder.createState();
-        builder.setAccept(s, a.isAccept(s));
-      }
-
-      Collections.shuffle(allTrans, random());
-      for(Transition t : allTrans) {
-        builder.addTransition(t.source, t.dest, t.min, t.max);
-      }
-
-      assertTrue(BasicOperations.sameLanguage(
-                    BasicOperations.determinize(BasicOperations.removeDeadStates(a)),
-                    BasicOperations.determinize(BasicOperations.removeDeadStates(builder.finish()))));
-      
-    }
-  }
-
-  public void testIsTotal() throws Exception {
-    assertFalse(BasicOperations.isTotal(new LightAutomaton()));
-    LightAutomaton a = new LightAutomaton();
-    int init = a.createState();
-    int fini = a.createState();
-    a.setAccept(fini, true);
-    a.addTransition(init, fini, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);
-    a.finishState();
-    assertFalse(BasicOperations.isTotal(a));
-    a.addTransition(fini, fini, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);
-    a.finishState();
-    assertFalse(BasicOperations.isTotal(a));
-    a.setAccept(init, true);
-    assertTrue(BasicOperations.isTotal(MinimizationOperationsLight.minimize(a)));
-  }
-
-  public void testMinimizeEmpty() throws Exception {
-    LightAutomaton a = new LightAutomaton();
-    int init = a.createState();
-    int fini = a.createState();
-    a.addTransition(init, fini, 'a');
-    a.finishState();
-    a = MinimizationOperationsLight.minimize(a);
-    assertEquals(0, a.getNumStates());
-  }
-
-  public void testMinus() throws Exception {
-    LightAutomaton a1 = BasicAutomata.makeStringLight("foobar");
-    LightAutomaton a2 = BasicAutomata.makeStringLight("boobar");
-    LightAutomaton a3 = BasicAutomata.makeStringLight("beebar");
-    LightAutomaton a = BasicOperations.unionLight(Arrays.asList(a1, a2, a3));
-    if (random().nextBoolean()) {
-      a = BasicOperations.determinize(a);
-    } else if (random().nextBoolean()) {
-      a = MinimizationOperationsLight.minimize(a);
-    }
-    assertMatches(a, "foobar", "beebar", "boobar");
-
-    LightAutomaton a4 = BasicOperations.determinize(BasicOperations.minusLight(a, a2));
-    
-    assertTrue(BasicOperations.run(a4, "foobar"));
-    assertFalse(BasicOperations.run(a4, "boobar"));
-    assertTrue(BasicOperations.run(a4, "beebar"));
-    assertMatches(a4, "foobar", "beebar");
-
-    a4 = BasicOperations.determinize(BasicOperations.minusLight(a4, a1));
-    assertFalse(BasicOperations.run(a4, "foobar"));
-    assertFalse(BasicOperations.run(a4, "boobar"));
-    assertTrue(BasicOperations.run(a4, "beebar"));
-    assertMatches(a4, "beebar");
-
-    a4 = BasicOperations.determinize(BasicOperations.minusLight(a4, a3));
-    assertFalse(BasicOperations.run(a4, "foobar"));
-    assertFalse(BasicOperations.run(a4, "boobar"));
-    assertFalse(BasicOperations.run(a4, "beebar"));
-    assertMatches(a4);
-  }
-
-  public void testOneInterval() throws Exception {
-    LightAutomaton a = BasicAutomata.makeIntervalLight(999, 1032, 0);
-    a = BasicOperations.determinize(a);
-    assertTrue(BasicOperations.run(a, "0999"));
-    assertTrue(BasicOperations.run(a, "00999"));
-    assertTrue(BasicOperations.run(a, "000999"));
-  }
-
-  public void testAnotherInterval() throws Exception {
-    LightAutomaton a = BasicAutomata.makeIntervalLight(1, 2, 0);
-    a = BasicOperations.determinize(a);
-    assertTrue(BasicOperations.run(a, "01"));
-  }
-
-  public void testIntervalRandom() throws Exception {
-    int ITERS = atLeast(100);
-    for(int iter=0;iter<ITERS;iter++) {
-      int min = TestUtil.nextInt(random(), 0, 100000);
-      int max = TestUtil.nextInt(random(), min, min+100000);
-      int digits;
-      if (random().nextBoolean()) {
-        digits = 0;
-      } else {
-        String s = Integer.toString(max);
-        digits = TestUtil.nextInt(random(), s.length(), 2*s.length());
-      }
-      StringBuilder b = new StringBuilder();
-      for(int i=0;i<digits;i++) {
-        b.append('0');
-      }
-      String prefix = b.toString();
-
-      LightAutomaton a = BasicOperations.determinize(BasicAutomata.makeIntervalLight(min, max, digits));
-      if (random().nextBoolean()) {
-        a = MinimizationOperationsLight.minimize(a);
-      }
-      String mins = Integer.toString(min);
-      String maxs = Integer.toString(max);
-      if (digits > 0) {
-        mins = prefix.substring(mins.length()) + mins;
-        maxs = prefix.substring(maxs.length()) + maxs;
-      }
-      assertTrue(BasicOperations.run(a, mins));
-      assertTrue(BasicOperations.run(a, maxs));
-
-      for(int iter2=0;iter2<100;iter2++) {
-        int x = random().nextInt(2*max);
-        boolean expected = x >= min && x <= max;
-        String sx = Integer.toString(x);
-        if (sx.length() < digits) {
-          // Left-fill with 0s
-          sx = b.substring(sx.length()) + sx;
-        } else if (digits == 0) {
-          // Left-fill with random number of 0s:
-          int numZeros = random().nextInt(10);
-          StringBuilder sb = new StringBuilder();
-          for(int i=0;i<numZeros;i++) {
-            sb.append('0');
-          }
-          sb.append(sx);
-          sx = sb.toString();
-        }
-        assertEquals(expected, BasicOperations.run(a, sx));
-      }
-    }
-  }
-
-  private void assertMatches(LightAutomaton a, String... strings) {
-    Set<IntsRef> expected = new HashSet<>();
-    for(String s : strings) {
-      IntsRef ints = new IntsRef();
-      expected.add(Util.toUTF32(s, ints));
-    }
-
-    assertEquals(expected, SpecialOperations.getFiniteStrings(BasicOperations.determinize(a), -1)); 
-  }
-
-  public void testConcatenatePreservesDet() throws Exception {
-    LightAutomaton a1 = BasicAutomata.makeStringLight("foobar");
-    assertTrue(a1.isDeterministic());
-    LightAutomaton a2 = BasicAutomata.makeStringLight("baz");
-    assertTrue(a2.isDeterministic());
-    assertTrue((BasicOperations.concatenateLight(Arrays.asList(a1, a2)).isDeterministic()));
-  }
-
-  public void testRemoveDeadStates() throws Exception {
-    LightAutomaton a = BasicOperations.concatenateLight(Arrays.asList(BasicAutomata.makeStringLight("x"),
-                                                                      BasicAutomata.makeStringLight("y")));
-    assertEquals(4, a.getNumStates());
-    a = BasicOperations.removeDeadStates(a);
-    assertEquals(3, a.getNumStates());
-  }
-
-  public void testRemoveDeadStatesEmpty1() throws Exception {
-    LightAutomaton a = new LightAutomaton();
-    a.finishState();
-    assertTrue(BasicOperations.isEmpty(a));
-    assertTrue(BasicOperations.isEmpty(BasicOperations.removeDeadStates(a)));
-  }
-
-  public void testRemoveDeadStatesEmpty2() throws Exception {
-    LightAutomaton a = new LightAutomaton();
-    a.finishState();
-    assertTrue(BasicOperations.isEmpty(a));
-    assertTrue(BasicOperations.isEmpty(BasicOperations.removeDeadStates(a)));
-  }
-
-  public void testRemoveDeadStatesEmpty3() throws Exception {
-    LightAutomaton a = new LightAutomaton();
-    int init = a.createState();
-    int fini = a.createState();
-    a.addTransition(init, fini, 'a');
-    LightAutomaton a2 = BasicOperations.removeDeadStates(a);
-    assertEquals(0, a2.getNumStates());
-  }
-
-  public void testConcatEmpty() throws Exception {
-    // If you concat empty automaton to anything the result should still be empty:
-    LightAutomaton a = BasicOperations.concatenateLight(BasicAutomata.makeEmptyLight(),
-                                                        BasicAutomata.makeStringLight("foo"));
-    assertEquals(new HashSet<IntsRef>(), SpecialOperations.getFiniteStrings(a, -1));
-
-    a = BasicOperations.concatenateLight(BasicAutomata.makeStringLight("foo"),
-                                         BasicAutomata.makeEmptyLight());
-    assertEquals(new HashSet<IntsRef>(), SpecialOperations.getFiniteStrings(a, -1));
-  }
-
-  public void testSeemsNonEmptyButIsNot1() throws Exception {
-    LightAutomaton a = new LightAutomaton();
-    // Init state has a transition but doesn't lead to accept
-    int init = a.createState();
-    int s = a.createState();
-    a.addTransition(init, s, 'a');
-    a.finishState();
-    assertTrue(BasicOperations.isEmpty(a));
-  }
-
-  public void testSeemsNonEmptyButIsNot2() throws Exception {
-    LightAutomaton a = new LightAutomaton();
-    int init = a.createState();
-    int s = a.createState();
-    a.addTransition(init, s, 'a');
-    // An orphan'd accept state
-    s = a.createState();
-    a.setAccept(s, true);
-    a.finishState();
-    assertTrue(BasicOperations.isEmpty(a));
-  }
-
-  public void testSameLanguage1() throws Exception {
-    LightAutomaton a = BasicAutomata.makeEmptyStringLight();
-    LightAutomaton a2 = BasicAutomata.makeEmptyStringLight();
-    int state = a2.createState();
-    a2.addTransition(0, state, 'a');
-    a2.finishState();
-    assertTrue(BasicOperations.sameLanguage(BasicOperations.removeDeadStates(a),
-                                            BasicOperations.removeDeadStates(a2)));
-  }
-
-  private LightAutomaton randomNoOp(LightAutomaton a) {
-    switch (random().nextInt(5)) {
-    case 0:
-      if (VERBOSE) {
-        System.out.println("  randomNoOp: determinize");
-      }
-      return BasicOperations.determinize(a);
-    case 1:
-      if (VERBOSE) {
-        System.out.println("  randomNoOp: minimize");
-      }
-      return MinimizationOperationsLight.minimize(a);
-    case 2:
-      if (VERBOSE) {
-        System.out.println("  randomNoOp: removeDeadStates");
-      }
-      return BasicOperations.removeDeadStates(a);
-    case 3:
-      if (VERBOSE) {
-        System.out.println("  randomNoOp: reverse reverse");
-      }
-      a = SpecialOperations.reverse(a);
-      a = randomNoOp(a);
-      return SpecialOperations.reverse(a);
-    case 4:
-      if (VERBOSE) {
-        System.out.println("  randomNoOp: concat empty string");
-      }
-      return BasicOperations.concatenateLight(a, BasicAutomata.makeEmptyStringLight());
-    case 5:
-      if (VERBOSE) {
-        System.out.println("  randomNoOp: union empty automaton");
-      }
-      return BasicOperations.unionLight(a, BasicAutomata.makeEmptyLight());
-    }
-    assert false;
-    return null;
-  }
-
-  private LightAutomaton unionTerms(Collection<BytesRef> terms) {
-    LightAutomaton a;
-    if (random().nextBoolean()) {
-      if (VERBOSE) {
-        System.out.println("TEST: unionTerms: use union");
-      }
-      List<LightAutomaton> as = new ArrayList<>();
-      for(BytesRef term : terms) {
-        as.add(BasicAutomata.makeStringLight(term.utf8ToString()));
-      }
-      a = BasicOperations.unionLight(as);
-    } else {
-      if (VERBOSE) {
-        System.out.println("TEST: unionTerms: use makeStringUnion");
-      }
-      List<BytesRef> termsList = new ArrayList<>(terms);
-      Collections.sort(termsList);
-      a = BasicAutomata.makeStringUnionLight(termsList);
-    }
-
-    return randomNoOp(a);
-  }
-
-  private String getRandomString(boolean isAscii) {
-    if (isAscii) {
-      return TestUtil.randomSimpleString(random());
-    } else {
-      return TestUtil.randomRealisticUnicodeString(random());
-    }
-  }
-
-  public void testRandomFinite() throws Exception {
-
-    int numTerms = atLeast(10);
-    int iters = atLeast(100);
-
-    // Some of the ops we do (stripping random byte, reverse) turn valid UTF8 into invalid if we allow non-ascii:
-    boolean isAscii = random().nextBoolean();
-
-    if (VERBOSE) {
-      System.out.println("TEST: isAscii=" + isAscii + " numTerms" + numTerms + " iters=" + iters);
-    }
-
-    Set<BytesRef> terms = new HashSet<>();
-    while (terms.size() < numTerms) {
-      terms.add(new BytesRef(getRandomString(isAscii)));
-    }
-
-    LightAutomaton a = unionTerms(terms);
-    assertSame(terms, a);
-
-    for(int iter=0;iter<iters;iter++) {
-      if (VERBOSE) {
-        System.out.println("TEST: iter=" + iter + " numTerms=" + terms.size());
-        System.out.println("  terms:");
-        for(BytesRef term : terms) {
-          System.out.println("    " + term);
-        }
-      }
-      switch(random().nextInt(14)) {
-
-      case 0:
-        // concatenate prefix
-        {
-          if (VERBOSE) {
-            System.out.println("  op=concat prefix");
-          }
-          Set<BytesRef> newTerms = new HashSet<>();
-          BytesRef prefix = new BytesRef(getRandomString(isAscii));
-          for(BytesRef term : terms) {
-            BytesRef newTerm = BytesRef.deepCopyOf(prefix);
-            newTerm.append(term);
-            newTerms.add(newTerm);
-          }
-          terms = newTerms;
-          boolean wasDeterministic1 = a.isDeterministic();
-          a = BasicOperations.concatenateLight(BasicAutomata.makeStringLight(prefix.utf8ToString()), a);
-          assertEquals(wasDeterministic1, a.isDeterministic());
-        }
-        break;
-
-      case 1:
-        // concatenate suffix
-        {
-          BytesRef suffix = new BytesRef(getRandomString(isAscii));
-          if (VERBOSE) {
-            System.out.println("  op=concat suffix " + suffix);
-          }
-          Set<BytesRef> newTerms = new HashSet<>();
-          for(BytesRef term : terms) {
-            BytesRef newTerm = BytesRef.deepCopyOf(term);
-            newTerm.append(suffix);
-            newTerms.add(newTerm);
-          }
-          terms = newTerms;
-          a = BasicOperations.concatenateLight(a, BasicAutomata.makeStringLight(suffix.utf8ToString()));
-        }
-        break;
-
-        // nocommit sometimes concat a suffix accepting more than 1 term, and sometimes non-det
-
-      case 2:
-        // determinize
-        if (VERBOSE) {
-          System.out.println("  op=determinize");
-        }
-        a = BasicOperations.determinize(a);
-        assertTrue(a.isDeterministic());
-        break;
-
-      case 3:
-        if (VERBOSE) {
-          System.out.println("  op=minimize");
-        }
-        // minimize
-        a = MinimizationOperationsLight.minimize(a);
-        break;
-
-      case 4:
-        // union
-        {
-          if (VERBOSE) {
-            System.out.println("  op=union");
-          }
-          Set<BytesRef> newTerms = new HashSet<>();
-          int numNewTerms = random().nextInt(5);
-          while (newTerms.size() < numNewTerms) {
-            newTerms.add(new BytesRef(getRandomString(isAscii)));
-          }
-          terms.addAll(newTerms);
-          LightAutomaton newA = unionTerms(newTerms);
-          a = BasicOperations.unionLight(a, newA);
-        }
-        break;
-
-      case 5:
-        // optional
-        {
-          if (VERBOSE) {
-            System.out.println("  op=optional");
-          }
-          a = BasicOperations.optionalLight(a);
-          terms.add(new BytesRef());
-        }
-        break;
-
-      case 6:
-        // minus finite 
-        {
-          if (VERBOSE) {
-            System.out.println("  op=minus finite");
-          }
-          if (terms.size() > 0) {
-            RandomAcceptedStrings rasl = new RandomAcceptedStrings(BasicOperations.removeDeadStates(a));
-            Set<BytesRef> toRemove = new HashSet<>();
-            int numToRemove = TestUtil.nextInt(random(), 1, (terms.size()+1)/2);
-            while (toRemove.size() < numToRemove) {
-              int[] ints = rasl.getRandomAcceptedString(random());
-              BytesRef term = new BytesRef(UnicodeUtil.newString(ints, 0, ints.length));
-              if (toRemove.contains(term) == false) {
-                toRemove.add(term);
-              }
-            }
-            for(BytesRef term : toRemove) {
-              boolean removed = terms.remove(term);
-              assertTrue(removed);
-            }
-            LightAutomaton a2 = unionTerms(toRemove);
-            a = BasicOperations.minusLight(a, a2);
-          }
-        }
-        break;
-
-      case 7:
-        {
-          // minus infinite
-          List<LightAutomaton> as = new ArrayList<>();
-          int count = TestUtil.nextInt(random(), 1, 5);
-          Set<Integer> prefixes = new HashSet<>();
-          while(prefixes.size() < count) {
-            // prefix is a leading ascii byte; we remove <prefix>* from a
-            int prefix = random().nextInt(128);
-            prefixes.add(prefix);
-          }
-
-          if (VERBOSE) {
-            System.out.println("  op=minus infinite prefixes=" + prefixes);
-          }
-
-          for(int prefix : prefixes) {
-            // prefix is a leading ascii byte; we remove <prefix>* from a
-            LightAutomaton a2 = new LightAutomaton();
-            int init = a2.createState();
-            int state = a2.createState();
-            a2.addTransition(init, state, prefix);
-            a2.setAccept(state, true);
-            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);
-            a2.finishState();
-            as.add(a2);
-            Iterator<BytesRef> it = terms.iterator();
-            while (it.hasNext()) {
-              BytesRef term = it.next();
-              if (term.length > 0 && (term.bytes[term.offset] & 0xFF) == prefix) {
-                it.remove();
-              }
-            }
-          }
-          LightAutomaton a2 = randomNoOp(BasicOperations.unionLight(as));
-          a = BasicOperations.minusLight(a, a2);
-        }
-        break;
-
-      case 8:
-        {
-          int count = TestUtil.nextInt(random(), 10, 20);
-          if (VERBOSE) {
-            System.out.println("  op=intersect infinite count=" + count);
-          }
-          // intersect infinite
-          List<LightAutomaton> as = new ArrayList<>();
-
-          Set<Integer> prefixes = new HashSet<>();
-          while(prefixes.size() < count) {
-            int prefix = random().nextInt(128);
-            prefixes.add(prefix);
-          }
-          if (VERBOSE) {
-            System.out.println("  prefixes=" + prefixes);
-          }
-
-          for(int prefix : prefixes) {
-            // prefix is a leading ascii byte; we retain <prefix>* in a
-            LightAutomaton a2 = new LightAutomaton();
-            int init = a2.createState();
-            int state = a2.createState();
-            a2.addTransition(init, state, prefix);
-            a2.setAccept(state, true);
-            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);
-            a2.finishState();
-            as.add(a2);
-            prefixes.add(prefix);
-          }
-
-          LightAutomaton a2 = BasicOperations.unionLight(as);
-          if (random().nextBoolean()) {
-            a2 = BasicOperations.determinize(a2);
-          } else if (random().nextBoolean()) {
-            a2 = MinimizationOperationsLight.minimize(a2);
-          }
-          a = BasicOperations.intersectionLight(a, a2);
-
-          Iterator<BytesRef> it = terms.iterator();
-          while (it.hasNext()) {
-            BytesRef term = it.next();
-            if (term.length == 0 || prefixes.contains(term.bytes[term.offset]&0xff) == false) {
-              if (VERBOSE) {
-                System.out.println("  drop term=" + term);
-              }
-              it.remove();
-            } else {
-              if (VERBOSE) {
-                System.out.println("  keep term=" + term);
-              }
-            }
-          }
-        }        
-        break;
-
-      case 9:
-        // reverse
-        if (VERBOSE) {
-          System.out.println("  op=reverse");
-        }
-        a = SpecialOperations.reverse(a);
-        Set<BytesRef> newTerms = new HashSet<>();
-        for(BytesRef term : terms) {
-          newTerms.add(new BytesRef(new StringBuilder(term.utf8ToString()).reverse().toString()));
-        }
-        terms = newTerms;
-        break;
-
-      case 10:
-        if (VERBOSE) {
-          System.out.println("  op=randomNoOp");
-        }
-        a = randomNoOp(a);
-        break;
-
-      case 11:
-        // interval
-        int min = random().nextInt(1000);
-        int max = min + random().nextInt(50);
-        // digits must be non-zero else we make cycle
-        int digits = Integer.toString(max).length();
-        if (VERBOSE) {
-          System.out.println("  op=union interval min=" + min + " max=" + max + " digits=" + digits);
-        }
-        a = BasicOperations.unionLight(a, BasicAutomata.makeIntervalLight(min, max, digits));
-        StringBuilder b = new StringBuilder();
-        for(int i=0;i<digits;i++) {
-          b.append('0');
-        }
-        String prefix = b.toString();
-        for(int i=min;i<=max;i++) {
-          String s = Integer.toString(i);
-          if (s.length() < digits) {
-            // Left-fill with 0s
-            s = prefix.substring(s.length()) + s;
-          }
-          terms.add(new BytesRef(s));
-        }
-        break;
-
-      case 12:
-        if (VERBOSE) {
-          System.out.println("  op=remove the empty string");
-        }
-        a = BasicOperations.minusLight(a, BasicAutomata.makeEmptyStringLight());
-        terms.remove(new BytesRef());
-        break;
-
-      case 13:
-        if (VERBOSE) {
-          System.out.println("  op=add the empty string");
-        }
-        a = BasicOperations.unionLight(a, BasicAutomata.makeEmptyStringLight());
-        terms.add(new BytesRef());
-        break;
-      }
-
-      assertSame(terms, a);
-    }
-
-    assertSame(terms, a);
-  }
-
-  private void assertSame(Collection<BytesRef> terms, LightAutomaton a) {
-
-    try {
-      assertTrue(SpecialOperations.isFinite(a));
-      assertFalse(BasicOperations.isTotal(a));
-
-      LightAutomaton detA = BasicOperations.determinize(a);
-
-      // Make sure all terms are accepted:
-      IntsRef scratch = new IntsRef();
-      for(BytesRef term : terms) {
-        Util.toIntsRef(term, scratch);
-        assertTrue("failed to accept term=" + term.utf8ToString(), BasicOperations.run(detA, term.utf8ToString()));
-      }
-
-      // Use getFiniteStrings:
-      Set<IntsRef> expected = new HashSet<>();
-      for(BytesRef term : terms) {
-        IntsRef intsRef = new IntsRef();
-        Util.toUTF32(term.utf8ToString(), intsRef);
-        expected.add(intsRef);
-      }
-      Set<IntsRef> actual = SpecialOperations.getFiniteStrings(a, -1);
-
-      if (expected.equals(actual) == false) {
-        System.out.println("FAILED:");
-        for(IntsRef term : expected) {
-          if (actual.contains(term) == false) {
-            System.out.println("  term=" + term + " should be accepted but isn't");
-          }
-        }
-        for(IntsRef term : actual) {
-          if (expected.contains(term) == false) {
-            System.out.println("  term=" + term + " is accepted but should not be");
-          }
-        }
-        throw new AssertionError("mismatch");
-      }
-
-      // Use sameLanguage:
-      LightAutomaton a2 = BasicOperations.removeDeadStates(BasicOperations.determinize(unionTerms(terms)));
-      assertTrue(BasicOperations.sameLanguage(a2, BasicOperations.removeDeadStates(BasicOperations.determinize(a))));
-
-      // Do same check, in UTF8 space
-      LightAutomaton utf8 = randomNoOp(new UTF32ToUTF8Light().convert(a));
-    
-      Set<IntsRef> expected2 = new HashSet<>();
-      for(BytesRef term : terms) {
-        IntsRef intsRef = new IntsRef();
-        Util.toIntsRef(term, intsRef);
-        expected2.add(intsRef);
-      }
-      assertEquals(expected2, SpecialOperations.getFiniteStrings(utf8, -1));
-    } catch (AssertionError ae) {
-      System.out.println("TEST: FAILED: not same");
-      System.out.println("  terms (count=" + terms.size() + "):");
-      for(BytesRef term : terms) {
-        System.out.println("    " + term);
-      }
-      System.out.println("  automaton:");
-      System.out.println(a.toDot());
-      //a.writeDot("fail");
-      throw ae;
-    }
-  }
-}
diff --git a/lucene/core/src/test/org/apache/lucene/util/automaton/TestMinimize.java b/lucene/core/src/test/org/apache/lucene/util/automaton/TestMinimize.java
index a0150a1..82a2914 100644
--- a/lucene/core/src/test/org/apache/lucene/util/automaton/TestMinimize.java
+++ b/lucene/core/src/test/org/apache/lucene/util/automaton/TestMinimize.java
@@ -27,10 +27,10 @@ public class TestMinimize extends LuceneTestCase {
   public void testBasic() {
     int num = atLeast(200);
     for (int i = 0; i < num; i++) {
-      LightAutomaton a = AutomatonTestUtil.randomAutomaton(random());
-      LightAutomaton la = BasicOperations.determinize(BasicOperations.removeDeadStates(a));
-      LightAutomaton lb = MinimizationOperationsLight.minimize(a);
-      assertTrue(BasicOperations.sameLanguage(la, lb));
+      Automaton a = AutomatonTestUtil.randomAutomaton(random());
+      Automaton la = Operations.determinize(Operations.removeDeadStates(a));
+      Automaton lb = MinimizationOperations.minimize(a);
+      assertTrue(Operations.sameLanguage(la, lb));
     }
   }
   
@@ -40,10 +40,10 @@ public class TestMinimize extends LuceneTestCase {
   public void testAgainstBrzozowski() {
     int num = atLeast(200);
     for (int i = 0; i < num; i++) {
-      LightAutomaton a = AutomatonTestUtil.randomAutomaton(random());
+      Automaton a = AutomatonTestUtil.randomAutomaton(random());
       a = AutomatonTestUtil.minimizeSimple(a);
-      LightAutomaton b = MinimizationOperationsLight.minimize(a);
-      assertTrue(BasicOperations.sameLanguage(a, b));
+      Automaton b = MinimizationOperations.minimize(a);
+      assertTrue(Operations.sameLanguage(a, b));
       assertEquals(a.getNumStates(), b.getNumStates());
       int numStates = a.getNumStates();
 
@@ -62,6 +62,6 @@ public class TestMinimize extends LuceneTestCase {
   
   /** n^2 space usage in Hopcroft minimization? */
   public void testMinimizeHuge() {
-    new RegExp("+-*(A|.....|BC)*]", RegExp.NONE).toLightAutomaton();
+    new RegExp("+-*(A|.....|BC)*]", RegExp.NONE).toAutomaton();
   }
 }
diff --git a/lucene/core/src/test/org/apache/lucene/util/automaton/TestOperations.java b/lucene/core/src/test/org/apache/lucene/util/automaton/TestOperations.java
new file mode 100644
index 0000000..e4f2280
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/util/automaton/TestOperations.java
@@ -0,0 +1,289 @@
+package org.apache.lucene.util.automaton;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.*;
+
+import org.apache.lucene.util.*;
+import org.apache.lucene.util.fst.Util;
+import com.carrotsearch.randomizedtesting.generators.RandomInts;
+
+public class TestOperations extends LuceneTestCase {
+  /** Test string union. */
+  public void testStringUnion() {
+    List<BytesRef> strings = new ArrayList<>();
+    for (int i = RandomInts.randomIntBetween(random(), 0, 1000); --i >= 0;) {
+      strings.add(new BytesRef(TestUtil.randomUnicodeString(random())));
+    }
+
+    Collections.sort(strings);
+    Automaton union = Automata.makeStringUnion(strings);
+    assertTrue(union.isDeterministic());
+    assertTrue(Operations.sameLanguage(union, naiveUnion(strings)));
+  }
+
+  private static Automaton naiveUnion(List<BytesRef> strings) {
+    Automaton[] eachIndividual = new Automaton[strings.size()];
+    int i = 0;
+    for (BytesRef bref : strings) {
+      eachIndividual[i++] = Automata.makeString(bref.utf8ToString());
+    }
+    return Operations.determinize(Operations.union(Arrays.asList(eachIndividual)));
+  }
+
+  /** Test concatenation with empty language returns empty */
+  public void testEmptyLanguageConcatenate() {
+    Automaton a = Automata.makeString("a");
+    Automaton concat = Operations.concatenate(a, Automata.makeEmpty());
+    assertTrue(Operations.isEmpty(concat));
+  }
+  
+  /** Test optimization to concatenate() with empty String to an NFA */
+  public void testEmptySingletonNFAConcatenate() {
+    Automaton singleton = Automata.makeString("");
+    Automaton expandedSingleton = singleton;
+    // an NFA (two transitions for 't' from initial state)
+    Automaton nfa = Operations.union(Automata.makeString("this"),
+        Automata.makeString("three"));
+    Automaton concat1 = Operations.concatenate(expandedSingleton, nfa);
+    Automaton concat2 = Operations.concatenate(singleton, nfa);
+    assertFalse(concat2.isDeterministic());
+    assertTrue(Operations.sameLanguage(Operations.determinize(concat1),
+                                       Operations.determinize(concat2)));
+    assertTrue(Operations.sameLanguage(Operations.determinize(nfa),
+                                       Operations.determinize(concat1)));
+    assertTrue(Operations.sameLanguage(Operations.determinize(nfa),
+                                       Operations.determinize(concat2)));
+  }
+
+  public void testGetRandomAcceptedString() throws Throwable {
+    final int ITER1 = atLeast(100);
+    final int ITER2 = atLeast(100);
+    for(int i=0;i<ITER1;i++) {
+
+      final RegExp re = new RegExp(AutomatonTestUtil.randomRegexp(random()), RegExp.NONE);
+      //System.out.println("TEST i=" + i + " re=" + re);
+      final Automaton a = Operations.determinize(re.toAutomaton());
+      assertFalse(Operations.isEmpty(a));
+
+      final AutomatonTestUtil.RandomAcceptedStrings rx = new AutomatonTestUtil.RandomAcceptedStrings(a);
+      for(int j=0;j<ITER2;j++) {
+        //System.out.println("TEST: j=" + j);
+        int[] acc = null;
+        try {
+          acc = rx.getRandomAcceptedString(random());
+          final String s = UnicodeUtil.newString(acc, 0, acc.length);
+          //a.writeDot("adot");
+          assertTrue(Operations.run(a, s));
+        } catch (Throwable t) {
+          System.out.println("regexp: " + re);
+          if (acc != null) {
+            System.out.println("fail acc re=" + re + " count=" + acc.length);
+            for(int k=0;k<acc.length;k++) {
+              System.out.println("  " + Integer.toHexString(acc[k]));
+            }
+          }
+          throw t;
+        }
+      }
+    }
+  }
+  /**
+   * tests against the original brics implementation.
+   */
+  public void testIsFinite() {
+    int num = atLeast(200);
+    for (int i = 0; i < num; i++) {
+      Automaton a = AutomatonTestUtil.randomAutomaton(random());
+      assertEquals(AutomatonTestUtil.isFiniteSlow(a), Operations.isFinite(a));
+    }
+  }
+
+  /** Pass false for testRecursive if the expected strings
+   *  may be too long */
+  private Set<IntsRef> getFiniteStrings(Automaton a, int limit, boolean testRecursive) {
+    Set<IntsRef> result = Operations.getFiniteStrings(a, limit);
+    if (testRecursive) {
+      assertEquals(AutomatonTestUtil.getFiniteStringsRecursive(a, limit), result);
+    }
+    return result;
+  }
+  
+  /**
+   * Basic test for getFiniteStrings
+   */
+  public void testFiniteStringsBasic() {
+    Automaton a = Operations.union(Automata.makeString("dog"), Automata.makeString("duck"));
+    a = MinimizationOperations.minimize(a);
+    Set<IntsRef> strings = getFiniteStrings(a, -1, true);
+    assertEquals(2, strings.size());
+    IntsRef dog = new IntsRef();
+    Util.toIntsRef(new BytesRef("dog"), dog);
+    assertTrue(strings.contains(dog));
+    IntsRef duck = new IntsRef();
+    Util.toIntsRef(new BytesRef("duck"), duck);
+    assertTrue(strings.contains(duck));
+  }
+
+  public void testFiniteStringsEatsStack() {
+    char[] chars = new char[50000];
+    TestUtil.randomFixedLengthUnicodeString(random(), chars, 0, chars.length);
+    String bigString1 = new String(chars);
+    TestUtil.randomFixedLengthUnicodeString(random(), chars, 0, chars.length);
+    String bigString2 = new String(chars);
+    Automaton a = Operations.union(Automata.makeString(bigString1), Automata.makeString(bigString2));
+    Set<IntsRef> strings = getFiniteStrings(a, -1, false);
+    assertEquals(2, strings.size());
+    IntsRef scratch = new IntsRef();
+    Util.toUTF32(bigString1.toCharArray(), 0, bigString1.length(), scratch);
+    assertTrue(strings.contains(scratch));
+    Util.toUTF32(bigString2.toCharArray(), 0, bigString2.length(), scratch);
+    assertTrue(strings.contains(scratch));
+  }
+
+  public void testRandomFiniteStrings1() {
+
+    int numStrings = atLeast(100);
+    if (VERBOSE) {
+      System.out.println("TEST: numStrings=" + numStrings);
+    }
+
+    Set<IntsRef> strings = new HashSet<IntsRef>();
+    List<Automaton> automata = new ArrayList<>();
+    for(int i=0;i<numStrings;i++) {
+      String s = TestUtil.randomSimpleString(random(), 1, 200);
+      automata.add(Automata.makeString(s));
+      IntsRef scratch = new IntsRef();
+      Util.toUTF32(s.toCharArray(), 0, s.length(), scratch);
+      strings.add(scratch);
+      if (VERBOSE) {
+        System.out.println("  add string=" + s);
+      }
+    }
+
+    // TODO: we could sometimes use
+    // DaciukMihovAutomatonBuilder here
+
+    // TODO: what other random things can we do here...
+    Automaton a = Operations.union(automata);
+    if (random().nextBoolean()) {
+      a = MinimizationOperations.minimize(a);
+      if (VERBOSE) {
+        System.out.println("TEST: a.minimize numStates=" + a.getNumStates());
+      }
+    } else if (random().nextBoolean()) {
+      if (VERBOSE) {
+        System.out.println("TEST: a.determinize");
+      }
+      a = Operations.determinize(a);
+    } else if (random().nextBoolean()) {
+      if (VERBOSE) {
+        System.out.println("TEST: a.removeDeadStates");
+      }
+      a = Operations.removeDeadStates(a);
+    }
+
+    Set<IntsRef> actual = getFiniteStrings(a, -1, true);
+    if (strings.equals(actual) == false) {
+      System.out.println("strings.size()=" + strings.size() + " actual.size=" + actual.size());
+      List<IntsRef> x = new ArrayList<>(strings);
+      Collections.sort(x);
+      List<IntsRef> y = new ArrayList<>(actual);
+      Collections.sort(y);
+      int end = Math.min(x.size(), y.size());
+      for(int i=0;i<end;i++) {
+        System.out.println("  i=" + i + " string=" + toString(x.get(i)) + " actual=" + toString(y.get(i)));
+      }
+      fail("wrong strings found");
+    }
+  }
+
+  // ascii only!
+  private static String toString(IntsRef ints) {
+    BytesRef br = new BytesRef(ints.length);
+    for(int i=0;i<ints.length;i++) {
+      br.bytes[i] = (byte) ints.ints[i];
+    }
+    br.length = ints.length;
+    return br.utf8ToString();
+  }
+
+  public void testWithCycle() throws Exception {
+    try {
+      Operations.getFiniteStrings(new RegExp("abc.*", RegExp.NONE).toAutomaton(), -1);
+      fail("did not hit exception");
+    } catch (IllegalArgumentException iae) {
+      // expected
+    }
+  }
+
+  public void testRandomFiniteStrings2() {
+    // Just makes sure we can run on any random finite
+    // automaton:
+    int iters = atLeast(100);
+    for(int i=0;i<iters;i++) {
+      Automaton a = AutomatonTestUtil.randomAutomaton(random());
+      try {
+        // Must pass a limit because the random automaton
+        // can accept MANY strings:
+        Operations.getFiniteStrings(a, TestUtil.nextInt(random(), 1, 1000));
+        // NOTE: cannot do this, because the method is not
+        // guaranteed to detect cycles when you have a limit
+        //assertTrue(Operations.isFinite(a));
+      } catch (IllegalArgumentException iae) {
+        assertFalse(Operations.isFinite(a));
+      }
+    }
+  }
+
+  public void testInvalidLimit() {
+    Automaton a = AutomatonTestUtil.randomAutomaton(random());
+    try {
+      Operations.getFiniteStrings(a, -7);
+      fail("did not hit exception");
+    } catch (IllegalArgumentException iae) {
+      // expected
+    }
+  }
+
+  public void testInvalidLimit2() {
+    Automaton a = AutomatonTestUtil.randomAutomaton(random());
+    try {
+      Operations.getFiniteStrings(a, 0);
+      fail("did not hit exception");
+    } catch (IllegalArgumentException iae) {
+      // expected
+    }
+  }
+
+  public void testSingletonNoLimit() {
+    Set<IntsRef> result = Operations.getFiniteStrings(Automata.makeString("foobar"), -1);
+    assertEquals(1, result.size());
+    IntsRef scratch = new IntsRef();
+    Util.toUTF32("foobar".toCharArray(), 0, 6, scratch);
+    assertTrue(result.contains(scratch));
+  }
+
+  public void testSingletonLimit1() {
+    Set<IntsRef> result = Operations.getFiniteStrings(Automata.makeString("foobar"), 1);
+    assertEquals(1, result.size());
+    IntsRef scratch = new IntsRef();
+    Util.toUTF32("foobar".toCharArray(), 0, 6, scratch);
+    assertTrue(result.contains(scratch));
+  }
+}
diff --git a/lucene/core/src/test/org/apache/lucene/util/automaton/TestSpecialOperations.java b/lucene/core/src/test/org/apache/lucene/util/automaton/TestSpecialOperations.java
deleted file mode 100644
index 895d03f..0000000
--- a/lucene/core/src/test/org/apache/lucene/util/automaton/TestSpecialOperations.java
+++ /dev/null
@@ -1,216 +0,0 @@
-package org.apache.lucene.util.automaton;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.IntsRef;
-import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.util.TestUtil;
-import org.apache.lucene.util.fst.Util;
-
-public class TestSpecialOperations extends LuceneTestCase {
-  /**
-   * tests against the original brics implementation.
-   */
-  public void testIsFinite() {
-    int num = atLeast(200);
-    for (int i = 0; i < num; i++) {
-      LightAutomaton a = AutomatonTestUtil.randomAutomaton(random());
-      assertEquals(AutomatonTestUtil.isFiniteSlow(a), SpecialOperations.isFinite(a));
-    }
-  }
-
-  /** Pass false for testRecursive if the expected strings
-   *  may be too long */
-  private Set<IntsRef> getFiniteStrings(LightAutomaton a, int limit, boolean testRecursive) {
-    Set<IntsRef> result = SpecialOperations.getFiniteStrings(a, limit);
-    if (testRecursive) {
-      assertEquals(AutomatonTestUtil.getFiniteStringsRecursiveLight(a, limit), result);
-    }
-    return result;
-  }
-  
-  /**
-   * Basic test for getFiniteStrings
-   */
-  public void testFiniteStringsBasic() {
-    LightAutomaton a = BasicOperations.unionLight(BasicAutomata.makeStringLight("dog"), BasicAutomata.makeStringLight("duck"));
-    a = MinimizationOperationsLight.minimize(a);
-    Set<IntsRef> strings = getFiniteStrings(a, -1, true);
-    assertEquals(2, strings.size());
-    IntsRef dog = new IntsRef();
-    Util.toIntsRef(new BytesRef("dog"), dog);
-    assertTrue(strings.contains(dog));
-    IntsRef duck = new IntsRef();
-    Util.toIntsRef(new BytesRef("duck"), duck);
-    assertTrue(strings.contains(duck));
-  }
-
-  public void testFiniteStringsEatsStack() {
-    char[] chars = new char[50000];
-    TestUtil.randomFixedLengthUnicodeString(random(), chars, 0, chars.length);
-    String bigString1 = new String(chars);
-    TestUtil.randomFixedLengthUnicodeString(random(), chars, 0, chars.length);
-    String bigString2 = new String(chars);
-    LightAutomaton a = BasicOperations.unionLight(BasicAutomata.makeStringLight(bigString1), BasicAutomata.makeStringLight(bigString2));
-    Set<IntsRef> strings = getFiniteStrings(a, -1, false);
-    assertEquals(2, strings.size());
-    IntsRef scratch = new IntsRef();
-    Util.toUTF32(bigString1.toCharArray(), 0, bigString1.length(), scratch);
-    assertTrue(strings.contains(scratch));
-    Util.toUTF32(bigString2.toCharArray(), 0, bigString2.length(), scratch);
-    assertTrue(strings.contains(scratch));
-  }
-
-  public void testRandomFiniteStrings1() {
-
-    int numStrings = atLeast(100);
-    if (VERBOSE) {
-      System.out.println("TEST: numStrings=" + numStrings);
-    }
-
-    Set<IntsRef> strings = new HashSet<IntsRef>();
-    List<LightAutomaton> automata = new ArrayList<>();
-    for(int i=0;i<numStrings;i++) {
-      String s = TestUtil.randomSimpleString(random(), 1, 200);
-      automata.add(BasicAutomata.makeStringLight(s));
-      IntsRef scratch = new IntsRef();
-      Util.toUTF32(s.toCharArray(), 0, s.length(), scratch);
-      strings.add(scratch);
-      if (VERBOSE) {
-        System.out.println("  add string=" + s);
-      }
-    }
-
-    // TODO: we could sometimes use
-    // DaciukMihovAutomatonBuilder here
-
-    // TODO: what other random things can we do here...
-    LightAutomaton a = BasicOperations.unionLight(automata);
-    if (random().nextBoolean()) {
-      a = MinimizationOperationsLight.minimize(a);
-      if (VERBOSE) {
-        System.out.println("TEST: a.minimize numStates=" + a.getNumStates());
-      }
-    } else if (random().nextBoolean()) {
-      if (VERBOSE) {
-        System.out.println("TEST: a.determinize");
-      }
-      a = BasicOperations.determinize(a);
-    } else if (random().nextBoolean()) {
-      if (VERBOSE) {
-        System.out.println("TEST: a.removeDeadStates");
-      }
-      a = BasicOperations.removeDeadStates(a);
-    }
-
-    Set<IntsRef> actual = getFiniteStrings(a, -1, true);
-    if (strings.equals(actual) == false) {
-      System.out.println("strings.size()=" + strings.size() + " actual.size=" + actual.size());
-      List<IntsRef> x = new ArrayList<>(strings);
-      Collections.sort(x);
-      List<IntsRef> y = new ArrayList<>(actual);
-      Collections.sort(y);
-      int end = Math.min(x.size(), y.size());
-      for(int i=0;i<end;i++) {
-        System.out.println("  i=" + i + " string=" + toString(x.get(i)) + " actual=" + toString(y.get(i)));
-      }
-      fail("wrong strings found");
-    }
-  }
-
-  // ascii only!
-  private static String toString(IntsRef ints) {
-    BytesRef br = new BytesRef(ints.length);
-    for(int i=0;i<ints.length;i++) {
-      br.bytes[i] = (byte) ints.ints[i];
-    }
-    br.length = ints.length;
-    return br.utf8ToString();
-  }
-
-  public void testWithCycle() throws Exception {
-    try {
-      SpecialOperations.getFiniteStrings(new RegExp("abc.*", RegExp.NONE).toLightAutomaton(), -1);
-      fail("did not hit exception");
-    } catch (IllegalArgumentException iae) {
-      // expected
-    }
-  }
-
-  public void testRandomFiniteStrings2() {
-    // Just makes sure we can run on any random finite
-    // automaton:
-    int iters = atLeast(100);
-    for(int i=0;i<iters;i++) {
-      LightAutomaton a = AutomatonTestUtil.randomAutomaton(random());
-      try {
-        // Must pass a limit because the random automaton
-        // can accept MANY strings:
-        SpecialOperations.getFiniteStrings(a, TestUtil.nextInt(random(), 1, 1000));
-        // NOTE: cannot do this, because the method is not
-        // guaranteed to detect cycles when you have a limit
-        //assertTrue(SpecialOperations.isFinite(a));
-      } catch (IllegalArgumentException iae) {
-        assertFalse(SpecialOperations.isFinite(a));
-      }
-    }
-  }
-
-  public void testInvalidLimit() {
-    LightAutomaton a = AutomatonTestUtil.randomAutomaton(random());
-    try {
-      SpecialOperations.getFiniteStrings(a, -7);
-      fail("did not hit exception");
-    } catch (IllegalArgumentException iae) {
-      // expected
-    }
-  }
-
-  public void testInvalidLimit2() {
-    LightAutomaton a = AutomatonTestUtil.randomAutomaton(random());
-    try {
-      SpecialOperations.getFiniteStrings(a, 0);
-      fail("did not hit exception");
-    } catch (IllegalArgumentException iae) {
-      // expected
-    }
-  }
-
-  public void testSingletonNoLimit() {
-    Set<IntsRef> result = SpecialOperations.getFiniteStrings(BasicAutomata.makeStringLight("foobar"), -1);
-    assertEquals(1, result.size());
-    IntsRef scratch = new IntsRef();
-    Util.toUTF32("foobar".toCharArray(), 0, 6, scratch);
-    assertTrue(result.contains(scratch));
-  }
-
-  public void testSingletonLimit1() {
-    Set<IntsRef> result = SpecialOperations.getFiniteStrings(BasicAutomata.makeStringLight("foobar"), 1);
-    assertEquals(1, result.size());
-    IntsRef scratch = new IntsRef();
-    Util.toUTF32("foobar".toCharArray(), 0, 6, scratch);
-    assertTrue(result.contains(scratch));
-  }
-}
diff --git a/lucene/core/src/test/org/apache/lucene/util/automaton/TestUTF32ToUTF8.java b/lucene/core/src/test/org/apache/lucene/util/automaton/TestUTF32ToUTF8.java
index 7b01055..95b19e0 100644
--- a/lucene/core/src/test/org/apache/lucene/util/automaton/TestUTF32ToUTF8.java
+++ b/lucene/core/src/test/org/apache/lucene/util/automaton/TestUTF32ToUTF8.java
@@ -155,14 +155,14 @@ public class TestUTF32ToUTF8 extends LuceneTestCase {
         continue;
       }
       
-      LightAutomaton a = BasicAutomata.makeCharRangeLight(startCode, endCode);
+      Automaton a = Automata.makeCharRange(startCode, endCode);
       testOne(r, new ByteRunAutomaton(a), startCode, endCode, ITERS_PER_DFA);
     }
   }
 
   public void testSpecialCase() {
     RegExp re = new RegExp(".?");
-    LightAutomaton automaton = re.toLightAutomaton();
+    Automaton automaton = re.toAutomaton();
     CharacterRunAutomaton cra = new CharacterRunAutomaton(automaton);
     ByteRunAutomaton bra = new ByteRunAutomaton(automaton);
     // make sure character dfa accepts empty string
@@ -178,7 +178,7 @@ public class TestUTF32ToUTF8 extends LuceneTestCase {
   public void testSpecialCase2() throws Exception {
     RegExp re = new RegExp(".+\u0775");
     String input = "\ufadc\ufffd\ub80b\uda5a\udc68\uf234\u0056\uda5b\udcc1\ufffd\ufffd\u0775";
-    LightAutomaton automaton = re.toLightAutomaton();
+    Automaton automaton = re.toAutomaton();
     CharacterRunAutomaton cra = new CharacterRunAutomaton(automaton);
     ByteRunAutomaton bra = new ByteRunAutomaton(automaton);
 
@@ -191,7 +191,7 @@ public class TestUTF32ToUTF8 extends LuceneTestCase {
   public void testSpecialCase3() throws Exception {
     RegExp re = new RegExp("(\\?)*(.)*\\?");
     String input = "\u5cfd\ufffd\ub2f7\u0033\ue304\u51d7\u3692\udb50\udfb3\u0576\udae2\udc62\u0053\u0449\u04d4";
-    LightAutomaton automaton = re.toLightAutomaton();
+    Automaton automaton = re.toAutomaton();
     CharacterRunAutomaton cra = new CharacterRunAutomaton(automaton);
     ByteRunAutomaton bra = new ByteRunAutomaton(automaton);
 
@@ -204,7 +204,7 @@ public class TestUTF32ToUTF8 extends LuceneTestCase {
   public void testRandomRegexes() throws Exception {
     int num = atLeast(250);
     for (int i = 0; i < num; i++) {
-      assertAutomaton(new RegExp(AutomatonTestUtil.randomRegexp(random()), RegExp.NONE).toLightAutomaton());
+      assertAutomaton(new RegExp(AutomatonTestUtil.randomRegexp(random()), RegExp.NONE).toAutomaton());
     }
   }
 
@@ -212,17 +212,17 @@ public class TestUTF32ToUTF8 extends LuceneTestCase {
     int iters = atLeast(100);
     for(int iter=0;iter<iters;iter++) {
       String s = TestUtil.randomRealisticUnicodeString(random());
-      LightAutomaton a = BasicAutomata.makeStringLight(s);
-      LightAutomaton utf8 = new UTF32ToUTF8Light().convert(a);
+      Automaton a = Automata.makeString(s);
+      Automaton utf8 = new UTF32ToUTF8().convert(a);
       IntsRef ints = new IntsRef();
       Util.toIntsRef(new BytesRef(s), ints);
       Set<IntsRef> set = new HashSet<>();
       set.add(ints);
-      assertEquals(set, SpecialOperations.getFiniteStrings(utf8, -1));
+      assertEquals(set, Operations.getFiniteStrings(utf8, -1));
     }
   }
   
-  private void assertAutomaton(LightAutomaton automaton) throws Exception {
+  private void assertAutomaton(Automaton automaton) throws Exception {
     CharacterRunAutomaton cra = new CharacterRunAutomaton(automaton);
     ByteRunAutomaton bra = new ByteRunAutomaton(automaton);
     final AutomatonTestUtil.RandomAcceptedStrings ras = new AutomatonTestUtil.RandomAcceptedStrings(automaton);
diff --git a/lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs.java b/lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs.java
index 733eaab..8c3f60c 100644
--- a/lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs.java
+++ b/lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs.java
@@ -69,7 +69,7 @@ import org.apache.lucene.util.LuceneTestCase.SuppressCodecs;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.TestUtil;
 import org.apache.lucene.util.automaton.CompiledAutomaton;
-import org.apache.lucene.util.automaton.LightAutomaton;
+import org.apache.lucene.util.automaton.Automaton;
 import org.apache.lucene.util.automaton.RegExp;
 import org.apache.lucene.util.fst.BytesRefFSTEnum.InputOutput;
 import org.apache.lucene.util.fst.FST.Arc;
@@ -346,7 +346,7 @@ public class TestFSTs extends LuceneTestCase {
       BytesRef term;
       int ord = 0;
 
-      LightAutomaton automaton = new RegExp(".*", RegExp.NONE).toLightAutomaton();
+      Automaton automaton = new RegExp(".*", RegExp.NONE).toAutomaton();
       final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);
 
       while((term = termsEnum.next()) != null) {
diff --git a/lucene/highlighter/src/java/org/apache/lucene/search/postingshighlight/MultiTermHighlighting.java b/lucene/highlighter/src/java/org/apache/lucene/search/postingshighlight/MultiTermHighlighting.java
index 610cb28..bf2f1d2 100644
--- a/lucene/highlighter/src/java/org/apache/lucene/search/postingshighlight/MultiTermHighlighting.java
+++ b/lucene/highlighter/src/java/org/apache/lucene/search/postingshighlight/MultiTermHighlighting.java
@@ -46,11 +46,11 @@ import org.apache.lucene.search.spans.SpanPositionCheckQuery;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.CharsRef;
 import org.apache.lucene.util.UnicodeUtil;
-import org.apache.lucene.util.automaton.BasicAutomata;
-import org.apache.lucene.util.automaton.BasicOperations;
+import org.apache.lucene.util.automaton.Automata;
+import org.apache.lucene.util.automaton.Operations;
 import org.apache.lucene.util.automaton.CharacterRunAutomaton;
 import org.apache.lucene.util.automaton.LevenshteinAutomata;
-import org.apache.lucene.util.automaton.LightAutomaton;
+import org.apache.lucene.util.automaton.Automaton;
 
 /**
  * Support for highlighting multiterm queries in PostingsHighlighter.
@@ -95,7 +95,7 @@ class MultiTermHighlighting {
     } else if (query instanceof AutomatonQuery) {
       final AutomatonQuery aq = (AutomatonQuery) query;
       if (aq.getField().equals(field)) {
-        list.add(new CharacterRunAutomaton(aq.getLightAutomaton()) {
+        list.add(new CharacterRunAutomaton(aq.getAutomaton()) {
           @Override
           public String toString() {
             return aq.toString();
@@ -106,8 +106,8 @@ class MultiTermHighlighting {
       final PrefixQuery pq = (PrefixQuery) query;
       Term prefix = pq.getPrefix();
       if (prefix.field().equals(field)) {
-        list.add(new CharacterRunAutomaton(BasicOperations.concatenateLight(BasicAutomata.makeStringLight(prefix.text()), 
-                                                                            BasicAutomata.makeAnyStringLight())) {
+        list.add(new CharacterRunAutomaton(Operations.concatenate(Automata.makeString(prefix.text()), 
+                                                                       Automata.makeAnyString())) {
           @Override
           public String toString() {
             return pq.toString();
@@ -127,7 +127,7 @@ class MultiTermHighlighting {
         String suffix = UnicodeUtil.newString(termText, prefixLength, termText.length - prefixLength);
         LevenshteinAutomata builder = new LevenshteinAutomata(suffix, fq.getTranspositions());
         String prefix = UnicodeUtil.newString(termText, 0, prefixLength);
-        LightAutomaton automaton = builder.toAutomaton(fq.getMaxEdits(), prefix);
+        Automaton automaton = builder.toAutomaton(fq.getMaxEdits(), prefix);
         list.add(new CharacterRunAutomaton(automaton) {
           @Override
           public String toString() {
@@ -158,7 +158,7 @@ class MultiTermHighlighting {
         final Comparator<CharsRef> comparator = CharsRef.getUTF16SortedAsUTF8Comparator();
         
         // this is *not* an automaton, but its very simple
-        list.add(new CharacterRunAutomaton(BasicAutomata.makeEmptyLight()) {
+        list.add(new CharacterRunAutomaton(Automata.makeEmpty()) {
           @Override
           public boolean run(char[] s, int offset, int length) {
             scratch.chars = s;
diff --git a/lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java b/lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java
index e24480a..ee6d8b8 100644
--- a/lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java
+++ b/lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java
@@ -55,7 +55,7 @@ import org.apache.lucene.search.spans.*;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.util.automaton.BasicAutomata;
+import org.apache.lucene.util.automaton.Automata;
 import org.apache.lucene.util.automaton.CharacterRunAutomaton;
 import org.apache.lucene.util.automaton.RegExp;
 import org.w3c.dom.Element;
@@ -1340,7 +1340,7 @@ public class HighlighterTest extends BaseTokenStreamTestCase implements Formatte
       @Override
       public void run() throws Exception {
         String goodWord = "goodtoken";
-        CharacterRunAutomaton stopWords = new CharacterRunAutomaton(BasicAutomata.makeStringLight("stoppedtoken"));
+        CharacterRunAutomaton stopWords = new CharacterRunAutomaton(Automata.makeString("stoppedtoken"));
         // we disable MockTokenizer checks because we will forcefully limit the 
         // tokenstream and call end() before incrementToken() returns false.
         final MockAnalyzer analyzer = new MockAnalyzer(random(), MockTokenizer.SIMPLE, true, stopWords);
@@ -1386,7 +1386,7 @@ public class HighlighterTest extends BaseTokenStreamTestCase implements Formatte
     TestHighlightRunner helper = new TestHighlightRunner() {
       @Override
       public void run() throws Exception {
-        CharacterRunAutomaton stopWords = new CharacterRunAutomaton(new RegExp("i[nt]").toLightAutomaton());
+        CharacterRunAutomaton stopWords = new CharacterRunAutomaton(new RegExp("i[nt]").toAutomaton());
         TermQuery query = new TermQuery(new Term("text", "searchterm"));
 
         String text = "this is a text with searchterm in it";
diff --git a/lucene/highlighter/src/test/org/apache/lucene/search/vectorhighlight/FastVectorHighlighterTest.java b/lucene/highlighter/src/test/org/apache/lucene/search/vectorhighlight/FastVectorHighlighterTest.java
index 5c65e09..c7f4612 100644
--- a/lucene/highlighter/src/test/org/apache/lucene/search/vectorhighlight/FastVectorHighlighterTest.java
+++ b/lucene/highlighter/src/test/org/apache/lucene/search/vectorhighlight/FastVectorHighlighterTest.java
@@ -602,8 +602,8 @@ public class FastVectorHighlighterTest extends LuceneTestCase {
     fieldAnalyzers.put( "field", new MockAnalyzer( random(), MockTokenizer.WHITESPACE, true, MockTokenFilter.ENGLISH_STOPSET ) );
     fieldAnalyzers.put( "field_exact", new MockAnalyzer( random() ) );
     fieldAnalyzers.put( "field_super_exact", new MockAnalyzer( random(), MockTokenizer.WHITESPACE, false ) );
-    fieldAnalyzers.put( "field_characters", new MockAnalyzer( random(), new CharacterRunAutomaton( new RegExp(".").toLightAutomaton() ), true ) );
-    fieldAnalyzers.put( "field_tripples", new MockAnalyzer( random(), new CharacterRunAutomaton( new RegExp("...").toLightAutomaton() ), true ) );
+    fieldAnalyzers.put( "field_characters", new MockAnalyzer( random(), new CharacterRunAutomaton( new RegExp(".").toAutomaton() ), true ) );
+    fieldAnalyzers.put( "field_tripples", new MockAnalyzer( random(), new CharacterRunAutomaton( new RegExp("...").toAutomaton() ), true ) );
     fieldAnalyzers.put( "field_sliced", fieldAnalyzers.get( "field" ) );
     fieldAnalyzers.put( "field_der_red", fieldAnalyzers.get( "field" ) );  // This is required even though we provide a token stream
     Analyzer analyzer = new AnalyzerWrapper() {
diff --git a/lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin.java b/lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin.java
index 48c33fe..acf07b6 100644
--- a/lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin.java
+++ b/lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin.java
@@ -629,7 +629,7 @@ public class TestBlockJoin extends LuceneTestCase {
       }
       DocsEnum parents = MultiFields.getTermDocsEnum(joinR, null, "isParent", new BytesRef("x"));
       System.out.println("parent docIDs:");
-      while (parents.nextDoc() != parents.NO_MORE_DOCS) {
+      while (parents.nextDoc() != DocsEnum.NO_MORE_DOCS) {
         System.out.println("  " + parents.docID());
       }
     }
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/precedence/TestPrecedenceQueryParser.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/precedence/TestPrecedenceQueryParser.java
index 012bd03..389bd0f 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/precedence/TestPrecedenceQueryParser.java
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/precedence/TestPrecedenceQueryParser.java
@@ -46,7 +46,7 @@ import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TermRangeQuery;
 import org.apache.lucene.search.WildcardQuery;
 import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.util.automaton.BasicAutomata;
+import org.apache.lucene.util.automaton.Automata;
 import org.apache.lucene.util.automaton.CharacterRunAutomaton;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
@@ -557,7 +557,7 @@ public class TestPrecedenceQueryParser extends LuceneTestCase {
   }
 
   public void testBoost() throws Exception {
-    CharacterRunAutomaton stopSet = new CharacterRunAutomaton(BasicAutomata.makeStringLight("on"));
+    CharacterRunAutomaton stopSet = new CharacterRunAutomaton(Automata.makeString("on"));
     Analyzer oneStopAnalyzer = new MockAnalyzer(random(), MockTokenizer.SIMPLE, true, stopSet);
 
     PrecedenceQueryParser qp = new PrecedenceQueryParser();
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestQPHelper.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestQPHelper.java
index f958e3d0..5068210 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestQPHelper.java
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestQPHelper.java
@@ -67,7 +67,7 @@ import org.apache.lucene.search.TermRangeQuery;
 import org.apache.lucene.search.WildcardQuery;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.util.automaton.BasicAutomata;
+import org.apache.lucene.util.automaton.Automata;
 import org.apache.lucene.util.automaton.CharacterRunAutomaton;
 import org.apache.lucene.util.automaton.RegExp;
 import org.junit.AfterClass;
@@ -957,7 +957,7 @@ public class TestQPHelper extends LuceneTestCase {
   }
 
   public void testBoost() throws Exception {
-    CharacterRunAutomaton stopSet = new CharacterRunAutomaton(BasicAutomata.makeStringLight("on"));
+    CharacterRunAutomaton stopSet = new CharacterRunAutomaton(Automata.makeString("on"));
     Analyzer oneStopAnalyzer = new MockAnalyzer(random(), MockTokenizer.SIMPLE, true, stopSet);
     StandardQueryParser qp = new StandardQueryParser();
     qp.setAnalyzer(oneStopAnalyzer);
@@ -1190,7 +1190,7 @@ public class TestQPHelper extends LuceneTestCase {
 
   public void testStopwords() throws Exception {
     StandardQueryParser qp = new StandardQueryParser();
-    CharacterRunAutomaton stopSet = new CharacterRunAutomaton(new RegExp("the|foo").toLightAutomaton());
+    CharacterRunAutomaton stopSet = new CharacterRunAutomaton(new RegExp("the|foo").toAutomaton());
     qp.setAnalyzer(new MockAnalyzer(random(), MockTokenizer.SIMPLE, true, stopSet));
 
     Query result = qp.parse("a:the OR a:foo", "a");
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/util/QueryParserTestBase.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/util/QueryParserTestBase.java
index 1cc5c1b..f76c9e1 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/util/QueryParserTestBase.java
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/util/QueryParserTestBase.java
@@ -47,7 +47,7 @@ import org.apache.lucene.search.*;
 import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.util.automaton.BasicAutomata;
+import org.apache.lucene.util.automaton.Automata;
 import org.apache.lucene.util.automaton.CharacterRunAutomaton;
 import org.apache.lucene.util.automaton.RegExp;
 import org.junit.AfterClass;
@@ -868,7 +868,7 @@ public abstract class QueryParserTestBase extends LuceneTestCase {
 
   public void testBoost()
     throws Exception {
-    CharacterRunAutomaton stopWords = new CharacterRunAutomaton(BasicAutomata.makeStringLight("on"));
+    CharacterRunAutomaton stopWords = new CharacterRunAutomaton(Automata.makeString("on"));
     Analyzer oneStopAnalyzer = new MockAnalyzer(random(), MockTokenizer.SIMPLE, true, stopWords);
     CommonQueryParserConfiguration qp = getParserConfig(oneStopAnalyzer);
     Query q = getQuery("on^1.0",qp);
@@ -1023,7 +1023,7 @@ public abstract class QueryParserTestBase extends LuceneTestCase {
   }
   
   public void testStopwords() throws Exception {
-    CharacterRunAutomaton stopSet = new CharacterRunAutomaton(new RegExp("the|foo").toLightAutomaton());
+    CharacterRunAutomaton stopSet = new CharacterRunAutomaton(new RegExp("the|foo").toAutomaton());
     CommonQueryParserConfiguration qp = getParserConfig(new MockAnalyzer(random(), MockTokenizer.SIMPLE, true, stopSet));
     Query result = getQuery("field:the OR field:foo",qp);
     assertNotNull("result is null and it shouldn't be", result);
@@ -1251,7 +1251,7 @@ public abstract class QueryParserTestBase extends LuceneTestCase {
 
   public void testPhraseQueryPositionIncrements() throws Exception {
     CharacterRunAutomaton stopStopList =
-    new CharacterRunAutomaton(new RegExp("[sS][tT][oO][pP]").toLightAutomaton());
+    new CharacterRunAutomaton(new RegExp("[sS][tT][oO][pP]").toAutomaton());
 
     CommonQueryParserConfiguration qp = getParserConfig(new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false, stopStopList));
 
diff --git a/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester.java b/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester.java
index 3b44198..afae341 100644
--- a/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester.java
+++ b/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester.java
@@ -43,9 +43,8 @@ import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.IntsRef;
 import org.apache.lucene.util.OfflineSorter;
 import org.apache.lucene.util.UnicodeUtil;
-import org.apache.lucene.util.automaton.BasicOperations;
-import org.apache.lucene.util.automaton.LightAutomaton;
-import org.apache.lucene.util.automaton.SpecialOperations;
+import org.apache.lucene.util.automaton.Operations;
+import org.apache.lucene.util.automaton.Automaton;
 import org.apache.lucene.util.automaton.Transition;
 import org.apache.lucene.util.fst.Builder;
 import org.apache.lucene.util.fst.ByteSequenceOutputs;
@@ -255,7 +254,7 @@ public class AnalyzingSuggester extends Lookup {
     return fst == null ? 0 : fst.ramBytesUsed();
   }
 
-  private int[] topoSortStates(LightAutomaton a) {
+  private int[] topoSortStates(Automaton a) {
     int[] states = new int[a.getNumStates()];
     final Set<Integer> visited = new HashSet<>();
     final LinkedList<Integer> worklist = new LinkedList<>();
@@ -283,9 +282,9 @@ public class AnalyzingSuggester extends Lookup {
 
   // Replaces SEP with epsilon or remaps them if
   // we were asked to preserve them:
-  private LightAutomaton replaceSep(LightAutomaton a) {
+  private Automaton replaceSep(Automaton a) {
 
-    LightAutomaton result = new LightAutomaton();
+    Automaton result = new Automaton();
 
     // Copy all states over
     int numStates = a.getNumStates();
@@ -335,7 +334,7 @@ public class AnalyzingSuggester extends Lookup {
 
   /** Used by subclass to change the lookup automaton, if
    *  necessary. */
-  protected LightAutomaton convertAutomaton(LightAutomaton a) {
+  protected Automaton convertAutomaton(Automaton a) {
     return a;
   }
   
@@ -694,7 +693,7 @@ public class AnalyzingSuggester extends Lookup {
     }
     final BytesRef utf8Key = new BytesRef(key);
     try {
-      LightAutomaton lookupAutomaton = toLookupAutomaton(key);
+      Automaton lookupAutomaton = toLookupAutomaton(key);
 
       final CharsRef spare = new CharsRef();
 
@@ -846,7 +845,7 @@ public class AnalyzingSuggester extends Lookup {
 
   /** Returns all prefix paths to initialize the search. */
   protected List<FSTUtil.Path<Pair<Long,BytesRef>>> getFullPrefixPaths(List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths,
-                                                                       LightAutomaton lookupAutomaton,
+                                                                       Automaton lookupAutomaton,
                                                                        FST<Pair<Long,BytesRef>> fst)
     throws IOException {
     return prefixPaths;
@@ -854,7 +853,7 @@ public class AnalyzingSuggester extends Lookup {
   
   final Set<IntsRef> toFiniteStrings(final BytesRef surfaceForm, final TokenStreamToAutomaton ts2a) throws IOException {
     // Analyze surface form:
-    LightAutomaton automaton = null;
+    Automaton automaton = null;
     try (TokenStream ts = indexAnalyzer.tokenStream("", surfaceForm.utf8ToString())) {
 
       // Create corresponding automaton: labels are bytes
@@ -877,13 +876,13 @@ public class AnalyzingSuggester extends Lookup {
     // don't have to alloc [possibly biggish]
     // intermediate HashSet in RAM:
 
-    return SpecialOperations.getFiniteStrings(automaton, maxGraphExpansions);
+    return Operations.getFiniteStrings(automaton, maxGraphExpansions);
   }
 
-  final LightAutomaton toLookupAutomaton(final CharSequence key) throws IOException {
+  final Automaton toLookupAutomaton(final CharSequence key) throws IOException {
     // TODO: is there a Reader from a CharSequence?
     // Turn tokenstream into automaton:
-    LightAutomaton automaton = null;
+    Automaton automaton = null;
     try (TokenStream ts = queryAnalyzer.tokenStream("", key.toString())) {
         automaton = getTokenStreamToAutomaton().toAutomaton(ts);
     }
@@ -892,7 +891,7 @@ public class AnalyzingSuggester extends Lookup {
 
     // TODO: we can optimize this somewhat by determinizing
     // while we convert
-    automaton = BasicOperations.determinize(automaton);
+    automaton = Operations.determinize(automaton);
     return automaton;
   }
 
diff --git a/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil.java b/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil.java
index ce72c06..ef6ea60 100644
--- a/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil.java
+++ b/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil.java
@@ -22,7 +22,7 @@ import java.util.ArrayList;
 import java.util.List;
 
 import org.apache.lucene.util.IntsRef;
-import org.apache.lucene.util.automaton.LightAutomaton;
+import org.apache.lucene.util.automaton.Automaton;
 import org.apache.lucene.util.automaton.Transition;
 import org.apache.lucene.util.fst.FST;
 import org.apache.lucene.util.fst.Util;
@@ -66,7 +66,7 @@ public class FSTUtil {
    * Enumerates all minimal prefix paths in the automaton that also intersect the FST,
    * accumulating the FST end node and output for each path.
    */
-  public static <T> List<Path<T>> intersectPrefixPaths(LightAutomaton a, FST<T> fst)
+  public static <T> List<Path<T>> intersectPrefixPaths(Automaton a, FST<T> fst)
       throws IOException {
     assert a.isDeterministic();
     final List<Path<T>> queue = new ArrayList<>();
diff --git a/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester.java b/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester.java
index 0c81f57..c4f91aa 100644
--- a/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester.java
+++ b/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester.java
@@ -29,12 +29,11 @@ import org.apache.lucene.analysis.tokenattributes.TermToBytesRefAttribute; // ja
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.IntsRef;
 import org.apache.lucene.util.UnicodeUtil;
-import org.apache.lucene.util.automaton.BasicAutomata;
-import org.apache.lucene.util.automaton.BasicOperations;
+import org.apache.lucene.util.automaton.Automata;
+import org.apache.lucene.util.automaton.Operations;
 import org.apache.lucene.util.automaton.LevenshteinAutomata;
-import org.apache.lucene.util.automaton.LightAutomaton;
-import org.apache.lucene.util.automaton.SpecialOperations;
-import org.apache.lucene.util.automaton.UTF32ToUTF8Light;
+import org.apache.lucene.util.automaton.Automaton;
+import org.apache.lucene.util.automaton.UTF32ToUTF8;
 import org.apache.lucene.util.fst.FST;
 import org.apache.lucene.util.fst.PairOutputs.Pair;
 
@@ -178,7 +177,7 @@ public final class FuzzySuggester extends AnalyzingSuggester {
   
   @Override
   protected List<FSTUtil.Path<Pair<Long,BytesRef>>> getFullPrefixPaths(List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths,
-                                                                       LightAutomaton lookupAutomaton,
+                                                                       Automaton lookupAutomaton,
                                                                        FST<Pair<Long,BytesRef>> fst)
     throws IOException {
 
@@ -192,7 +191,7 @@ public final class FuzzySuggester extends AnalyzingSuggester {
     // "compete") ... in which case I think the wFST needs
     // to be log weights or something ...
 
-    LightAutomaton levA = convertAutomaton(toLevenshteinAutomata(lookupAutomaton));
+    Automaton levA = convertAutomaton(toLevenshteinAutomata(lookupAutomaton));
     /*
       Writer w = new OutputStreamWriter(new FileOutputStream("out.dot"), StandardCharsets.UTF_8);
       w.write(levA.toDot());
@@ -203,10 +202,10 @@ public final class FuzzySuggester extends AnalyzingSuggester {
   }
 
   @Override
-  protected LightAutomaton convertAutomaton(LightAutomaton a) {
+  protected Automaton convertAutomaton(Automaton a) {
     if (unicodeAware) {
-      LightAutomaton utf8automaton = new UTF32ToUTF8Light().convert(a);
-      utf8automaton = BasicOperations.determinize(utf8automaton);
+      Automaton utf8automaton = new UTF32ToUTF8().convert(a);
+      utf8automaton = Operations.determinize(utf8automaton);
       return utf8automaton;
     } else {
       return a;
@@ -220,13 +219,13 @@ public final class FuzzySuggester extends AnalyzingSuggester {
     return tsta;
   }
 
-  LightAutomaton toLevenshteinAutomata(LightAutomaton automaton) {
-    final Set<IntsRef> ref = SpecialOperations.getFiniteStrings(automaton, -1);
-    LightAutomaton subs[] = new LightAutomaton[ref.size()];
+  Automaton toLevenshteinAutomata(Automaton automaton) {
+    final Set<IntsRef> ref = Operations.getFiniteStrings(automaton, -1);
+    Automaton subs[] = new Automaton[ref.size()];
     int upto = 0;
     for (IntsRef path : ref) {
       if (path.length <= nonFuzzyPrefix || path.length < minFuzzyLength) {
-        subs[upto] = BasicAutomata.makeStringLight(path.ints, path.offset, path.length);
+        subs[upto] = Automata.makeString(path.ints, path.offset, path.length);
         upto++;
       } else {
         int ints[] = new int[path.length-nonFuzzyPrefix];
@@ -244,17 +243,17 @@ public final class FuzzySuggester extends AnalyzingSuggester {
 
     if (subs.length == 0) {
       // automaton is empty, there is no accepted paths through it
-      return BasicAutomata.makeEmptyLight(); // matches nothing
+      return Automata.makeEmpty(); // matches nothing
     } else if (subs.length == 1) {
       // no synonyms or anything: just a single path through the tokenstream
       return subs[0];
     } else {
       // multiple paths: this is really scary! is it slow?
       // maybe we should not do this and throw UOE?
-      LightAutomaton a = BasicOperations.unionLight(Arrays.asList(subs));
+      Automaton a = Operations.union(Arrays.asList(subs));
       // TODO: we could call toLevenshteinAutomata() before det? 
       // this only happens if you have multiple paths anyway (e.g. synonyms)
-      return BasicOperations.determinize(a);
+      return Operations.determinize(a);
     }
   }
 }
diff --git a/lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/FuzzySuggesterTest.java b/lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/FuzzySuggesterTest.java
index 99f35f5..0859055 100644
--- a/lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/FuzzySuggesterTest.java
+++ b/lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/FuzzySuggesterTest.java
@@ -47,8 +47,7 @@ import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.IntsRef;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.TestUtil;
-import org.apache.lucene.util.automaton.BasicOperations;
-import org.apache.lucene.util.automaton.LightAutomaton;
+import org.apache.lucene.util.automaton.Automaton;
 import org.apache.lucene.util.fst.Util;
 
 public class FuzzySuggesterTest extends LuceneTestCase {
@@ -752,7 +751,7 @@ public class FuzzySuggesterTest extends LuceneTestCase {
       // us the "answer key" (ie maybe we have a bug in
       // suggester.toLevA ...) ... but testRandom2() fixes
       // this:
-      LightAutomaton automaton = suggester.convertAutomaton(suggester.toLevenshteinAutomata(suggester.toLookupAutomaton(analyzedKey)));
+      Automaton automaton = suggester.convertAutomaton(suggester.toLevenshteinAutomata(suggester.toLookupAutomaton(analyzedKey)));
       assertTrue(automaton.isDeterministic());
 
       // TODO: could be faster... but its slowCompletor for a reason
diff --git a/lucene/test-framework/src/java/org/apache/lucene/analysis/MockTokenFilter.java b/lucene/test-framework/src/java/org/apache/lucene/analysis/MockTokenFilter.java
index ac3c3d6..25619a8 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/analysis/MockTokenFilter.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/analysis/MockTokenFilter.java
@@ -17,15 +17,15 @@ package org.apache.lucene.analysis;
  * limitations under the License.
  */
 
-import static org.apache.lucene.util.automaton.BasicAutomata.makeEmptyLight;
-import static org.apache.lucene.util.automaton.BasicAutomata.makeStringLight;
+import static org.apache.lucene.util.automaton.Automata.makeEmpty;
+import static org.apache.lucene.util.automaton.Automata.makeString;
 
 import java.io.IOException;
 import java.util.Arrays;
 
 import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
-import org.apache.lucene.util.automaton.BasicOperations;
+import org.apache.lucene.util.automaton.Operations;
 import org.apache.lucene.util.automaton.CharacterRunAutomaton;
 
 /**
@@ -39,20 +39,20 @@ import org.apache.lucene.util.automaton.CharacterRunAutomaton;
 public final class MockTokenFilter extends TokenFilter {
   /** Empty set of stopwords */
   public static final CharacterRunAutomaton EMPTY_STOPSET =
-    new CharacterRunAutomaton(makeEmptyLight());
+    new CharacterRunAutomaton(makeEmpty());
   
   /** Set of common english stopwords */
   public static final CharacterRunAutomaton ENGLISH_STOPSET = 
-    new CharacterRunAutomaton(BasicOperations.unionLight(Arrays.asList(
-      makeStringLight("a"), makeStringLight("an"), makeStringLight("and"), makeStringLight("are"),
-      makeStringLight("as"), makeStringLight("at"), makeStringLight("be"), makeStringLight("but"), 
-      makeStringLight("by"), makeStringLight("for"), makeStringLight("if"), makeStringLight("in"), 
-      makeStringLight("into"), makeStringLight("is"), makeStringLight("it"), makeStringLight("no"),
-      makeStringLight("not"), makeStringLight("of"), makeStringLight("on"), makeStringLight("or"), 
-      makeStringLight("such"), makeStringLight("that"), makeStringLight("the"), makeStringLight("their"), 
-      makeStringLight("then"), makeStringLight("there"), makeStringLight("these"), makeStringLight("they"), 
-      makeStringLight("this"), makeStringLight("to"), makeStringLight("was"), makeStringLight("will"), 
-      makeStringLight("with"))));
+    new CharacterRunAutomaton(Operations.union(Arrays.asList(
+      makeString("a"), makeString("an"), makeString("and"), makeString("are"),
+      makeString("as"), makeString("at"), makeString("be"), makeString("but"), 
+      makeString("by"), makeString("for"), makeString("if"), makeString("in"), 
+      makeString("into"), makeString("is"), makeString("it"), makeString("no"),
+      makeString("not"), makeString("of"), makeString("on"), makeString("or"), 
+      makeString("such"), makeString("that"), makeString("the"), makeString("their"), 
+      makeString("then"), makeString("there"), makeString("these"), makeString("they"), 
+      makeString("this"), makeString("to"), makeString("was"), makeString("will"), 
+      makeString("with"))));
   
   private final CharacterRunAutomaton filter;
 
diff --git a/lucene/test-framework/src/java/org/apache/lucene/analysis/MockTokenizer.java b/lucene/test-framework/src/java/org/apache/lucene/analysis/MockTokenizer.java
index cdd1924..e85729f 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/analysis/MockTokenizer.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/analysis/MockTokenizer.java
@@ -44,16 +44,16 @@ import com.carrotsearch.randomizedtesting.RandomizedContext;
 public class MockTokenizer extends Tokenizer {
   /** Acts Similar to WhitespaceTokenizer */
   public static final CharacterRunAutomaton WHITESPACE = 
-    new CharacterRunAutomaton(new RegExp("[^ \t\r\n]+").toLightAutomaton());
+    new CharacterRunAutomaton(new RegExp("[^ \t\r\n]+").toAutomaton());
   /** Acts Similar to KeywordTokenizer.
    * TODO: Keyword returns an "empty" token for an empty reader... 
    */
   public static final CharacterRunAutomaton KEYWORD =
-    new CharacterRunAutomaton(new RegExp(".*").toLightAutomaton());
+    new CharacterRunAutomaton(new RegExp(".*").toAutomaton());
   /** Acts like LetterTokenizer. */
   // the ugly regex below is incomplete Unicode 5.2 [:Letter:]
   public static final CharacterRunAutomaton SIMPLE =
-    new CharacterRunAutomaton(new RegExp("[A-Za-z?-??--??-?+").toLightAutomaton());
+    new CharacterRunAutomaton(new RegExp("[A-Za-z?-??--??-?+").toAutomaton());
 
   private final CharacterRunAutomaton runAutomaton;
   private final boolean lowerCase;
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/SearchEquivalenceTestBase.java b/lucene/test-framework/src/java/org/apache/lucene/search/SearchEquivalenceTestBase.java
index 29d3b00..a47dd3d 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/search/SearchEquivalenceTestBase.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/SearchEquivalenceTestBase.java
@@ -33,7 +33,7 @@ import org.apache.lucene.index.Term;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.TestUtil;
-import org.apache.lucene.util.automaton.BasicAutomata;
+import org.apache.lucene.util.automaton.Automata;
 import org.apache.lucene.util.automaton.CharacterRunAutomaton;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
@@ -57,7 +57,7 @@ public abstract class SearchEquivalenceTestBase extends LuceneTestCase {
     Random random = random();
     directory = newDirectory();
     stopword = "" + randomChar();
-    CharacterRunAutomaton stopset = new CharacterRunAutomaton(BasicAutomata.makeStringLight(stopword));
+    CharacterRunAutomaton stopset = new CharacterRunAutomaton(Automata.makeString(stopword));
     analyzer = new MockAnalyzer(random, MockTokenizer.WHITESPACE, false, stopset);
     RandomIndexWriter iw = new RandomIndexWriter(random, directory, analyzer);
     Document doc = new Document();
diff --git a/lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java b/lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java
index 6fcb139..4256337 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java
@@ -1788,7 +1788,7 @@ public abstract class LuceneTestCase extends Assert {
       int numIntersections = atLeast(3);
       for (int i = 0; i < numIntersections; i++) {
         String re = AutomatonTestUtil.randomRegexp(random());
-        CompiledAutomaton automaton = new CompiledAutomaton(new RegExp(re, RegExp.NONE).toLightAutomaton());
+        CompiledAutomaton automaton = new CompiledAutomaton(new RegExp(re, RegExp.NONE).toAutomaton());
         if (automaton.type == CompiledAutomaton.AUTOMATON_TYPE.NORMAL) {
           // TODO: test start term too
           TermsEnum leftIntersection = leftTerms.intersect(automaton, null);
diff --git a/lucene/test-framework/src/java/org/apache/lucene/util/automaton/AutomatonTestUtil.java b/lucene/test-framework/src/java/org/apache/lucene/util/automaton/AutomatonTestUtil.java
index 054f5b3..30b490d 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/util/automaton/AutomatonTestUtil.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/util/automaton/AutomatonTestUtil.java
@@ -137,7 +137,7 @@ public class AutomatonTestUtil {
   public static class RandomAcceptedStrings {
 
     private final Map<Transition,Boolean> leadsToAccept;
-    private final LightAutomaton a;
+    private final Automaton a;
     private final Transition[][] transitions;
 
     private static class ArrivingTransition {
@@ -150,7 +150,7 @@ public class AutomatonTestUtil {
       }
     }
 
-    public RandomAcceptedStrings(LightAutomaton a) {
+    public RandomAcceptedStrings(Automaton a) {
       this.a = a;
       if (a.getNumStates() == 0) {
         throw new IllegalArgumentException("this automaton accepts nothing");
@@ -252,24 +252,24 @@ public class AutomatonTestUtil {
   }
   
   /** return a random NFA/DFA for testing */
-  public static LightAutomaton randomAutomaton(Random random) {
+  public static Automaton randomAutomaton(Random random) {
     // get two random Automata from regexps
-    LightAutomaton a1 = new RegExp(AutomatonTestUtil.randomRegexp(random), RegExp.NONE).toLightAutomaton();
+    Automaton a1 = new RegExp(AutomatonTestUtil.randomRegexp(random), RegExp.NONE).toAutomaton();
     if (random.nextBoolean()) {
-      a1 = BasicOperations.complementLight(a1);
+      a1 = Operations.complement(a1);
     }
     
-    LightAutomaton a2 = new RegExp(AutomatonTestUtil.randomRegexp(random), RegExp.NONE).toLightAutomaton();
+    Automaton a2 = new RegExp(AutomatonTestUtil.randomRegexp(random), RegExp.NONE).toAutomaton();
     if (random.nextBoolean()) {
-      a2 = BasicOperations.complementLight(a2);
+      a2 = Operations.complement(a2);
     }
 
     // combine them in random ways
     switch (random.nextInt(4)) {
-      case 0: return BasicOperations.concatenateLight(a1, a2);
-      case 1: return BasicOperations.unionLight(a1, a2);
-      case 2: return BasicOperations.intersectionLight(a1, a2);
-      default: return BasicOperations.minusLight(a1, a2);
+      case 0: return Operations.concatenate(a1, a2);
+      case 1: return Operations.union(a1, a2);
+      case 2: return Operations.intersection(a1, a2);
+      default: return Operations.minus(a1, a2);
     }
   }
   
@@ -310,28 +310,28 @@ public class AutomatonTestUtil {
   /**
    * Simple, original brics implementation of Brzozowski minimize()
    */
-  public static LightAutomaton minimizeSimple(LightAutomaton a) {
+  public static Automaton minimizeSimple(Automaton a) {
     Set<Integer> initialSet = new HashSet<Integer>();
-    a = determinizeSimpleLight(SpecialOperations.reverse(a, initialSet), initialSet);
+    a = determinizeSimple(Operations.reverse(a, initialSet), initialSet);
     initialSet.clear();
-    a = determinizeSimpleLight(SpecialOperations.reverse(a, initialSet), initialSet);
+    a = determinizeSimple(Operations.reverse(a, initialSet), initialSet);
     return a;
   }
   
   /**
    * Simple, original brics implementation of determinize()
    */
-  public static LightAutomaton determinizeSimpleLight(LightAutomaton a) {
+  public static Automaton determinizeSimple(Automaton a) {
     Set<Integer> initialset = new HashSet<>();
     initialset.add(0);
-    return determinizeSimpleLight(a, initialset);
+    return determinizeSimple(a, initialset);
   }
 
   /** 
    * Simple, original brics implementation of determinize()
    * Determinizes the given automaton using the given set of initial states. 
    */
-  public static LightAutomaton determinizeSimpleLight(LightAutomaton a, Set<Integer> initialset) {
+  public static Automaton determinizeSimple(Automaton a, Set<Integer> initialset) {
     if (a.getNumStates() == 0) {
       return a;
     }
@@ -342,7 +342,7 @@ public class AutomatonTestUtil {
     Map<Set<Integer>, Integer> newstate = new HashMap<>();
     sets.put(initialset, initialset);
     worklist.add(initialset);
-    LightAutomaton.Builder result = new LightAutomaton.Builder();
+    Automaton.Builder result = new Automaton.Builder();
     result.createState();
     newstate.put(initialset, 0);
     Transition t = new Transition();
@@ -384,7 +384,7 @@ public class AutomatonTestUtil {
       }
     }
 
-    return BasicOperations.removeDeadStates(result.finish());
+    return Operations.removeDeadStates(result.finish());
   }
 
   /**
@@ -399,9 +399,9 @@ public class AutomatonTestUtil {
    * frame for each digit in the returned strings (ie, max
    * is the max length returned string).
    */
-  public static Set<IntsRef> getFiniteStringsRecursiveLight(LightAutomaton a, int limit) {
+  public static Set<IntsRef> getFiniteStringsRecursive(Automaton a, int limit) {
     HashSet<IntsRef> strings = new HashSet<>();
-    if (!getFiniteStringsLight(a, 0, new HashSet<Integer>(), strings, new IntsRef(), limit)) {
+    if (!getFiniteStrings(a, 0, new HashSet<Integer>(), strings, new IntsRef(), limit)) {
       return strings;
     }
     return strings;
@@ -412,7 +412,7 @@ public class AutomatonTestUtil {
    * false if more than <code>limit</code> strings are found. 
    * <code>limit</code>&lt;0 means "infinite".
    */
-  private static boolean getFiniteStringsLight(LightAutomaton a, int s, HashSet<Integer> pathstates, 
+  private static boolean getFiniteStrings(Automaton a, int s, HashSet<Integer> pathstates, 
       HashSet<IntsRef> strings, IntsRef path, int limit) {
     pathstates.add(s);
     Transition t = new Transition();
@@ -432,7 +432,7 @@ public class AutomatonTestUtil {
             return false;
           }
         }
-        if (!getFiniteStringsLight(a, t.dest, pathstates, strings, path, limit)) {
+        if (!getFiniteStrings(a, t.dest, pathstates, strings, path, limit)) {
           return false;
         }
         path.length--;
@@ -448,7 +448,7 @@ public class AutomatonTestUtil {
    * WARNING: this method is slow, it will blow up if the automaton is large.
    * this is only used to test the correctness of our faster implementation.
    */
-  public static boolean isFiniteSlow(LightAutomaton a) {
+  public static boolean isFiniteSlow(Automaton a) {
     if (a.getNumStates() == 0) {
       return true;
     }
@@ -461,7 +461,7 @@ public class AutomatonTestUtil {
    */
   // TODO: not great that this is recursive... in theory a
   // large automata could exceed java's stack
-  private static boolean isFiniteSlow(LightAutomaton a, int s, HashSet<Integer> path) {
+  private static boolean isFiniteSlow(Automaton a, int s, HashSet<Integer> path) {
     path.add(s);
     Transition t = new Transition();
     int count = a.initTransition(s, t);
@@ -479,14 +479,14 @@ public class AutomatonTestUtil {
    * Checks that an automaton has no detached states that are unreachable
    * from the initial state.
    */
-  public static void assertNoDetachedStates(LightAutomaton a) {
-    LightAutomaton a2 = BasicOperations.removeDeadStates(a);
+  public static void assertNoDetachedStates(Automaton a) {
+    Automaton a2 = Operations.removeDeadStates(a);
     assert a.getNumStates() == a2.getNumStates() : "automaton has " + (a.getNumStates() - a2.getNumStates()) + " detached states";
   }
 
   // nocommit where to assert this...
   /** Returns true if the automaton is deterministic. */
-  public static boolean isDeterministicSlow(LightAutomaton a) {
+  public static boolean isDeterministicSlow(Automaton a) {
     Transition t = new Transition();
     int numStates = a.getNumStates();
     for(int s=0;s<numStates;s++) {
diff --git a/solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase.java b/solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase.java
index f624d70..1ef4d0a 100644
--- a/solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase.java
+++ b/solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase.java
@@ -40,10 +40,9 @@ import org.apache.lucene.search.WildcardQuery;
 import org.apache.lucene.util.QueryBuilder;
 import org.apache.lucene.util.ToStringUtils;
 import org.apache.lucene.util.Version;
-import org.apache.lucene.util.automaton.BasicAutomata;
-import org.apache.lucene.util.automaton.BasicOperations;
-import org.apache.lucene.util.automaton.LightAutomaton;
-import org.apache.lucene.util.automaton.SpecialOperations;
+import org.apache.lucene.util.automaton.Automata;
+import org.apache.lucene.util.automaton.Operations;
+import org.apache.lucene.util.automaton.Automaton;
 import org.apache.solr.analysis.ReversedWildcardFilterFactory;
 import org.apache.solr.analysis.TokenizerChain;
 import org.apache.solr.common.SolrException;
@@ -777,19 +776,19 @@ public abstract class SolrQueryParserBase extends QueryBuilder {
     if (factory != null) {
       Term term = new Term(field, termStr);
       // fsa representing the query
-      LightAutomaton automaton = WildcardQuery.toAutomaton(term);
+      Automaton automaton = WildcardQuery.toAutomaton(term);
       // TODO: we should likely use the automaton to calculate shouldReverse, too.
       if (factory.shouldReverse(termStr)) {
-        automaton = BasicOperations.concatenateLight(automaton, BasicAutomata.makeCharLight(factory.getMarkerChar()));
-        automaton = SpecialOperations.reverse(automaton);
+        automaton = Operations.concatenate(automaton, Automata.makeChar(factory.getMarkerChar()));
+        automaton = Operations.reverse(automaton);
       } else {
         // reverse wildcardfilter is active: remove false positives
         // fsa representing false positives (markerChar*)
-        LightAutomaton falsePositives = BasicOperations.concatenateLight(
-            BasicAutomata.makeCharLight(factory.getMarkerChar()),
-            BasicAutomata.makeAnyStringLight());
+        Automaton falsePositives = Operations.concatenate(
+            Automata.makeChar(factory.getMarkerChar()),
+            Automata.makeAnyString());
         // subtract these away
-        automaton = BasicOperations.minusLight(automaton, falsePositives);
+        automaton = Operations.minus(automaton, falsePositives);
       }
       return new AutomatonQuery(term, automaton) {
         // override toString so its completely transparent
diff --git a/solr/core/src/java/org/apache/solr/search/SolrQueryParser.java b/solr/core/src/java/org/apache/solr/search/SolrQueryParser.java
index 04eb4bc..21fbf5e 100644
--- a/solr/core/src/java/org/apache/solr/search/SolrQueryParser.java
+++ b/solr/core/src/java/org/apache/solr/search/SolrQueryParser.java
@@ -25,9 +25,7 @@ import org.apache.lucene.analysis.util.TokenFilterFactory;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.*;
 import org.apache.lucene.util.ToStringUtils;
-import org.apache.lucene.util.automaton.BasicAutomata;
-import org.apache.lucene.util.automaton.BasicOperations;
-import org.apache.lucene.util.automaton.SpecialOperations;
+import org.apache.lucene.util.automaton.Automata;
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.solr.analysis.ReversedWildcardFilterFactory;
 import org.apache.solr.analysis.TokenizerChain;
diff --git a/solr/core/src/test/org/apache/solr/analysis/TestReversedWildcardFilterFactory.java b/solr/core/src/test/org/apache/solr/analysis/TestReversedWildcardFilterFactory.java
index 5de7398..2ce6a23 100644
--- a/solr/core/src/test/org/apache/solr/analysis/TestReversedWildcardFilterFactory.java
+++ b/solr/core/src/test/org/apache/solr/analysis/TestReversedWildcardFilterFactory.java
@@ -26,9 +26,8 @@ import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.search.AutomatonQuery;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.util.automaton.BasicOperations;
-import org.apache.lucene.util.automaton.LightAutomaton;
-import org.apache.lucene.util.automaton.SpecialOperations;
+import org.apache.lucene.util.automaton.Operations;
+import org.apache.lucene.util.automaton.Automaton;
 import org.apache.solr.SolrTestCaseJ4;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.schema.IndexSchema;
@@ -161,8 +160,8 @@ public class TestReversedWildcardFilterFactory extends SolrTestCaseJ4 {
     if (!(q instanceof AutomatonQuery)) {
       return false;
     }
-    LightAutomaton automaton = ((AutomatonQuery) q).getLightAutomaton();
-    String prefix = SpecialOperations.getCommonPrefix(BasicOperations.determinize(automaton));
+    Automaton automaton = ((AutomatonQuery) q).getAutomaton();
+    String prefix = Operations.getCommonPrefix(Operations.determinize(automaton));
     return prefix.length() > 0 && prefix.charAt(0) == '\u0001';
   }
 
diff --git a/solr/test-framework/src/java/org/apache/solr/analysis/MockTokenFilterFactory.java b/solr/test-framework/src/java/org/apache/solr/analysis/MockTokenFilterFactory.java
index afe327d..56d7c57 100644
--- a/solr/test-framework/src/java/org/apache/solr/analysis/MockTokenFilterFactory.java
+++ b/solr/test-framework/src/java/org/apache/solr/analysis/MockTokenFilterFactory.java
@@ -48,7 +48,7 @@ public class MockTokenFilterFactory extends TokenFilterFactory {
       }
     } else if (null != stopregex) {
       RegExp regex = new RegExp(stopregex);
-      filter = new CharacterRunAutomaton(regex.toLightAutomaton());
+      filter = new CharacterRunAutomaton(regex.toAutomaton());
     } else {
       throw new IllegalArgumentException
           ("Configuration Error: either the 'stopset' or the 'stopregex' parameter must be specified.");

