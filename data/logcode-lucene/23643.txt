GitDiffStart: 0e23b32894d17a4cbb7f4961c272199be7fe21c6 | Tue Jun 27 19:31:20 2006 +0000
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/data/GDataAccount.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/data/GDataAccount.java
new file mode 100644
index 0000000..dc04db6
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/data/GDataAccount.java
@@ -0,0 +1,332 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+
+package org.apache.lucene.gdata.data;
+
+import java.net.URL;
+import java.util.HashSet;
+import java.util.Set;
+
+import com.google.gdata.data.Person;
+
+/**
+ * The GData-Server system provides acccount to be associated with registered
+ * feed. Every feed has an owner account. The account holder is automaticaly in
+ * role to modify his feeds. One account can own <i>n</i> feeds having <i>m</i>
+ * entries.
+ * <p>
+ * Additionally an account can be in role to modify other feeds, create accounts
+ * or feeds. See {@link AccountRole} for detailed infomation about roles. One
+ * account can also have more than one role. All roles in {@link AccountRole}
+ * can be combined
+ * </p>
+ * <p>
+ * For each account values for author name, author email and author link can be
+ * set at creation time or during an update. These values will be used as the
+ * corresponding values for the feed
+ * {@link org.apache.lucene.gdata.data.ServerBaseFeed#addAuthor(Person)} if no
+ * value for the feed has be specified.
+ * </p>
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class GDataAccount {
+    private String name;
+
+    private String authorname;
+
+    private String authorMail;
+
+    private URL authorLink;
+
+    private String password;
+
+    private Set<AccountRole> roles = new HashSet<AccountRole>(4);
+
+    /**
+     * Creates a new GDataAccount. The default role {@link AccountRole#USER}
+     * will be set.
+     * 
+     */
+    public GDataAccount() {
+        this.roles.add(AccountRole.USER);
+
+    }
+
+    /**
+     * @return - the password
+     */
+    public String getPassword() {
+        return this.password;
+    }
+
+    /**
+     * @param password -
+     *            the account Password
+     */
+    public void setPassword(String password) {
+        this.password = password;
+    }
+
+    /**
+     * @return - the account name
+     */
+    public String getName() {
+        return this.name;
+    }
+
+    /**
+     * @param name
+     *            The name to set.
+     */
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    /**
+     * @return - the http link specified for the author
+     */
+    public URL getAuthorLink() {
+        return this.authorLink;
+    }
+
+    /**
+     * @param authorLink -
+     *            the http link specified for the author
+     */
+    public void setAuthorLink(URL authorLink) {
+        this.authorLink = authorLink;
+    }
+
+    /**
+     * @return - the authors mail address
+     */
+    public String getAuthorMail() {
+        return this.authorMail;
+    }
+
+    /**
+     * @param authorMail -
+     *            the authors mail address
+     */
+    public void setAuthorMail(String authorMail) {
+        this.authorMail = authorMail;
+    }
+
+    /**
+     * @return - the name specified as being the author name
+     */
+    public String getAuthorname() {
+        return this.authorname;
+    }
+
+    /**
+     * @param authorname -
+     *            the name specified as being the author name
+     */
+    public void setAuthorname(String authorname) {
+        this.authorname = authorname;
+    }
+
+    /**
+     * Adds the given role to the role list
+     * 
+     * @param role -
+     *            the role to add to the role list
+     */
+    public void setRole(AccountRole role) {
+        if (role == null)
+            return;
+        this.roles.add(role);
+    }
+
+    /**
+     * @return - the set containing all roles
+     */
+    public Set<AccountRole> getRoles() {
+        return this.roles;
+    }
+
+    /**
+     * @param role -
+     *            the role to check
+     * @return <code>true</code> if the role list contains the given role
+     */
+    public boolean isUserInRole(AccountRole role) {
+        if (role == null)
+            return false;
+        return this.roles.contains(role);
+    }
+
+    /**
+     * @see GDataAccount#setRolesAsInt(int)
+     * @return - the integer representation for the user roles
+     */
+    public int getRolesAsInt() {
+        // 1 as the Userrole is always set
+        int bits = 1;
+        for (AccountRole role : this.roles) {
+            if (role == AccountRole.ENTRYAMINISTRATOR)
+                bits ^= 2;
+            else if (role == AccountRole.FEEDAMINISTRATOR)
+                bits ^= 4;
+            else if (role == AccountRole.USERADMINISTRATOR)
+                bits ^= 8;
+
+        }
+        return bits;
+
+    }
+
+    /**
+     * Sets the roles from a int representation.
+     * <ol>
+     * <li>The fist bit set indicates a {@link AccountRole#USER} - int value 1</li>
+     * <li>The second bit set indicates a {@link AccountRole#ENTRYAMINISTRATOR} -
+     * int value 2</li>
+     * <li>The third bit set indicates a {@link AccountRole#FEEDAMINISTRATOR} -
+     * int value 4</li>
+     * <li>The forth bit set indicates a {@link AccountRole#USERADMINISTRATOR} -
+     * int value 8</li>
+     * <ol>
+     * This method will only set roles, will not remove roles! A combination of
+     * roles is also possible e.g. the int value 6 combines
+     * {@link AccountRole#ENTRYAMINISTRATOR} and
+     * {@link AccountRole#FEEDAMINISTRATOR}.
+     * 
+     * @param i -
+     *            the integer used to set the roles
+     */
+    public void setRolesAsInt(int i) {
+
+        if ((i & 2) > 0)
+            this.roles.add(AccountRole.ENTRYAMINISTRATOR);
+        if ((i & 4) > 0)
+            this.roles.add(AccountRole.FEEDAMINISTRATOR);
+        if ((i & 8) > 0)
+            this.roles.add(AccountRole.USERADMINISTRATOR);
+
+    }
+
+    /**
+     * @see java.lang.Object#equals(java.lang.Object)
+     */
+    public boolean equals(Object o) {
+        if (this == o)
+            return true;
+        if (!(o instanceof GDataAccount) || o == null)
+            return false;
+        GDataAccount toCompare = (GDataAccount) o;
+        if (this.name.equals(toCompare.name))
+            return true;
+        return false;
+
+    }
+
+    /**
+     * @see java.lang.Object#hashCode()
+     */
+    public int hashCode() {
+        int ret = 37;
+        ret = 9 * ret + this.name.hashCode();
+        return ret;
+    }
+
+    /**
+     * Checks the requiered values for creating an account are set. Required
+     * values are <tt>name</tt> and <tt>password</tt> the minimum length of
+     * these values is 6.
+     * 
+     * @return <code>true</code> if an only if password and name are not <code>null</code> and the length is <tt>> 5</tt>
+     */
+    public boolean requiredValuesSet() {
+        return (this.name != null && this.password != null
+                && this.name.length() > 5 && this.password.length() > 5);
+    }
+    
+    /**
+     * @see java.lang.Object#toString()
+     */
+    public String toString(){
+        StringBuilder builder = new StringBuilder("GdataAccount: ");
+        builder.append("name: ").append(this.name);
+        builder.append(" password: ").append((this.password!= null?" length: "+this.password.length():null));
+        builder.append(" author: ").append(this.authorname);
+        builder.append(" author email: ").append(this.authorMail);
+        builder.append(" author link: ").append(this.authorLink);
+        return builder.toString();
+    }
+    
+    /**
+     * checks whether the given integer matches the account role.
+     * @param intRole - integer representation of a role
+     * @param role - the accountrole to match
+     * @return <code>true</code> if and only if the given roles match, otherwise <code>false</code>
+     */
+    public static boolean isInRole(int intRole, AccountRole role){
+        if(role == AccountRole.USER)
+            return (intRole&1)>0;
+        if (role == AccountRole.ENTRYAMINISTRATOR)
+            return (intRole&2) >0 ;
+        else if (role == AccountRole.FEEDAMINISTRATOR)
+            return (intRole&4) >0 ;
+        else if (role == AccountRole.USERADMINISTRATOR)
+            return (intRole&8) >0 ;
+        return false;
+    }
+    
+    /**
+     * @return - a new Administartor accoutn 
+     */
+    public static final GDataAccount createAdminAccount(){
+        GDataAccount retVal = new GDataAccount();
+        retVal.setName("administrator");
+        retVal.setPassword("password");
+        retVal.setRole(AccountRole.USERADMINISTRATOR);
+        retVal.setRole(AccountRole.FEEDAMINISTRATOR);
+        retVal.setRole(AccountRole.ENTRYAMINISTRATOR);
+        return retVal;
+    }
+
+    /**
+     * This enum respesents all account roles an account can have.
+     * 
+     * @author Simon Willnauer
+     * 
+     */
+    public enum AccountRole {
+
+        /**
+         * Can create / alter user
+         */
+        USERADMINISTRATOR,
+
+        /**
+         * Can create / alter feeds
+         */
+        FEEDAMINISTRATOR,
+        /**
+         * Can create / alter entries
+         */
+        ENTRYAMINISTRATOR,
+        /**
+         * can create / alter his own feed entries
+         */
+        USER
+    }
+
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/data/ServerBaseEntry.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/data/ServerBaseEntry.java
new file mode 100644
index 0000000..4435877
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/data/ServerBaseEntry.java
@@ -0,0 +1,623 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.data;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.Reader;
+import java.util.List;
+import java.util.Set;
+
+import org.apache.lucene.gdata.server.registry.ProvidedService;
+
+import com.google.gdata.client.Service;
+import com.google.gdata.data.BaseEntry;
+import com.google.gdata.data.Content;
+import com.google.gdata.data.DateTime;
+import com.google.gdata.data.Entry;
+import com.google.gdata.data.Extension;
+import com.google.gdata.data.ExtensionProfile;
+import com.google.gdata.data.Link;
+import com.google.gdata.data.Source;
+import com.google.gdata.data.TextConstruct;
+import com.google.gdata.util.ParseException;
+import com.google.gdata.util.ServiceException;
+import com.google.gdata.util.XmlBlob;
+import com.google.gdata.util.common.xml.XmlWriter;
+
+/**
+ * The GData-Server uses the GDATA-Client API for an interal representation of
+ * entries. These entities have dynamic elements like Links being generated
+ * using the requested URL.<br/> Some components of the server also need
+ * additional infomation like the service type
+ * {@link org.apache.lucene.gdata.server.registry.ProvidedService} of the entry
+ * and the feedid a entry belongs to. All these information are
+ * encapsulated in the ServerBaseEntry decorating a concrete sub class of <tt>BaseEntry</tt>. The actual
+ * {@link com.google.gdata.data.BaseEntry} will be passed to the ServerBaseEntry
+ * at creation time via the constructor. To use the ServerBaseFeed for generation a provided format like
+ * RSS/ATOM the corresponding {@link com.google.gdata.data.ExtensionProfile} has
+ * to be provided to the generation method.
+ * <p> For a general overview of the generic BaseFeed class see the gdata-client API documentation</p>
+ * 
+ * @see com.google.gdata.data.ExtensionProfile
+ * @see com.google.gdata.data.BaseFeed
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class ServerBaseEntry {
+    private String feedId;
+
+    private String serviceType;
+
+    private ProvidedService serviceConfig;
+    private BaseEntry entry;
+    
+
+    
+   
+    /**
+     * @return - the provided service for the source entry 
+     */
+    public ProvidedService getServiceConfig() {
+        return this.serviceConfig;
+    }
+
+    /**
+     * @param serviceConfig - the provided service for the source entry
+     */
+    public void setServiceConfig(ProvidedService serviceConfig) {
+        this.serviceConfig = serviceConfig;
+        if (serviceConfig != null)
+            this.serviceType = serviceConfig.getName();
+    }
+
+    /**
+     * @return - the name of the service related of the feed containing this entry
+     */
+    public String getServiceType() {
+        return this.serviceType;
+    }
+
+    /**
+     *  Constructs a new ServerBaseEntry.
+     *  To provide a concrete entry to decorate after object creation use {@link ServerBaseEntry#setEntry(BaseEntry)}  
+     *  
+     */
+    @SuppressWarnings("unchecked")
+    public ServerBaseEntry() {
+        
+        this.entry = new Entry();
+    }
+
+    /**
+     * @param arg0 - the source entry
+     */
+    @SuppressWarnings("unchecked")
+    public ServerBaseEntry(BaseEntry arg0) {
+        this.entry = arg0;
+
+    }
+
+
+    /**
+     * @param link - a link added to this entry
+     */
+    @SuppressWarnings("unchecked")
+    public void addLink(final Link link) {
+        this.entry.getLinks().add(link);
+    }
+
+    /**
+     * @return - the id of the owning feed
+     */
+    public String getFeedId() {
+        return this.feedId;
+    }
+
+    /**
+     * @param feedId - the id of the owning feed
+     */
+    public void setFeedId(String feedId) {
+        this.feedId = feedId;
+    }
+    /**
+     * @return - the decorated entry
+     */
+    public BaseEntry getEntry(){
+        return this.entry;
+    }
+    /**
+     * @param entry - the entry to decorate
+     */
+    public void setEntry(BaseEntry entry){
+        this.entry = entry;
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#addHtmlLink(java.lang.String, java.lang.String, java.lang.String)
+     */
+    public void addHtmlLink(String arg0, String arg1, String arg2) {
+        
+        this.entry.addHtmlLink(arg0, arg1, arg2);
+    }
+
+
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#generateAtom(com.google.gdata.util.common.xml.XmlWriter, com.google.gdata.data.ExtensionProfile)
+     */
+    
+    public void generateAtom(XmlWriter arg0, ExtensionProfile arg1) throws IOException {
+        
+        this.entry.generateAtom(arg0, arg1);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#generateRss(com.google.gdata.util.common.xml.XmlWriter, com.google.gdata.data.ExtensionProfile)
+     */
+    
+    public void generateRss(XmlWriter arg0, ExtensionProfile arg1) throws IOException {
+        
+        this.entry.generateRss(arg0, arg1);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getAuthors()
+     */
+    
+    public List getAuthors() {
+        
+        return this.entry.getAuthors();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getCanEdit()
+     */
+    
+    public boolean getCanEdit() {
+        
+        return this.entry.getCanEdit();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getCategories()
+     */
+    
+    public Set getCategories() {
+        
+        return this.entry.getCategories();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getContent()
+     */
+    
+    public Content getContent() {
+        
+        return this.entry.getContent();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getContributors()
+     */
+    
+    public List getContributors() {
+        
+        return this.entry.getContributors();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getEditLink()
+     */
+    
+    public Link getEditLink() {
+        
+        return this.entry.getEditLink();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getHtmlLink()
+     */
+    
+    public Link getHtmlLink() {
+        
+        return this.entry.getHtmlLink();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getId()
+     */
+    
+    public String getId() {
+        
+        return this.entry.getId();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getLink(java.lang.String, java.lang.String)
+     */
+    
+    public Link getLink(String arg0, String arg1) {
+        
+        return this.entry.getLink(arg0, arg1);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getLinks()
+     */
+    
+    public List getLinks() {
+        
+        return this.entry.getLinks();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getPublished()
+     */
+    
+    public DateTime getPublished() {
+        
+        return this.entry.getPublished();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getRights()
+     */
+    
+    public TextConstruct getRights() {
+        
+        return this.entry.getRights();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getSelf()
+     */
+    
+    public BaseEntry getSelf() throws IOException, ServiceException {
+        
+        return this.entry.getSelf();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getSelfLink()
+     */
+    
+    public Link getSelfLink() {
+        
+        return this.entry.getSelfLink();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getService()
+     */
+    
+    public Service getService() {
+        
+        return this.entry.getService();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getSource()
+     */
+    
+    public Source getSource() {
+        
+        return this.entry.getSource();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getSummary()
+     */
+    
+    public TextConstruct getSummary() {
+        
+        return this.entry.getSummary();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getTitle()
+     */
+    
+    public TextConstruct getTitle() {
+        
+        return this.entry.getTitle();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getUpdated()
+     */
+    
+    public DateTime getUpdated() {
+        
+        return this.entry.getUpdated();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getVersionId()
+     */
+    
+    public String getVersionId() {
+        
+        return this.entry.getVersionId();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#isDraft()
+     */
+    
+    public boolean isDraft() {
+        
+        return this.entry.isDraft();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#parseAtom(com.google.gdata.data.ExtensionProfile, java.io.InputStream)
+     */
+    
+    public void parseAtom(ExtensionProfile arg0, InputStream arg1) throws IOException, ParseException {
+        
+        this.entry.parseAtom(arg0, arg1);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#parseAtom(com.google.gdata.data.ExtensionProfile, java.io.Reader)
+     */
+    
+    public void parseAtom(ExtensionProfile arg0, Reader arg1) throws IOException, ParseException {
+        
+        this.entry.parseAtom(arg0, arg1);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#setCanEdit(boolean)
+     */
+    
+    public void setCanEdit(boolean arg0) {
+        
+        this.entry.setCanEdit(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#setContent(com.google.gdata.data.Content)
+     */
+    
+    public void setContent(Content arg0) {
+        
+        this.entry.setContent(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#setContent(com.google.gdata.data.TextConstruct)
+     */
+    
+    public void setContent(TextConstruct arg0) {
+        
+        this.entry.setContent(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#setDraft(boolean)
+     */
+    
+    public void setDraft(boolean arg0) {
+        
+        this.entry.setDraft(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#setId(java.lang.String)
+     */
+    
+    public void setId(String arg0) {
+        
+        this.entry.setId(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#setPublished(com.google.gdata.data.DateTime)
+     */
+    
+    public void setPublished(DateTime arg0) {
+        
+        this.entry.setPublished(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#setRights(com.google.gdata.data.TextConstruct)
+     */
+    
+    public void setRights(TextConstruct arg0) {
+        
+        this.entry.setRights(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#setService(com.google.gdata.client.Service)
+     */
+    
+    public void setService(Service arg0) {
+        
+        this.entry.setService(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#setSource(com.google.gdata.data.Source)
+     */
+    
+    public void setSource(Source arg0) {
+        
+        this.entry.setSource(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#setSummary(com.google.gdata.data.TextConstruct)
+     */
+    
+    public void setSummary(TextConstruct arg0) {
+        
+        this.entry.setSummary(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#setTitle(com.google.gdata.data.TextConstruct)
+     */
+    
+    public void setTitle(TextConstruct arg0) {
+        
+        this.entry.setTitle(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#setUpdated(com.google.gdata.data.DateTime)
+     */
+    
+    public void setUpdated(DateTime arg0) {
+        
+        this.entry.setUpdated(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#setVersionId(java.lang.String)
+     */
+    
+    public void setVersionId(String arg0) {
+        
+        this.entry.setVersionId(arg0);
+    }
+
+ 
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#addExtension(com.google.gdata.data.Extension)
+     */
+    
+    public void addExtension(Extension arg0) {
+        
+        this.entry.addExtension(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#addRepeatingExtension(com.google.gdata.data.Extension)
+     */
+    
+    public void addRepeatingExtension(Extension arg0) {
+        
+        this.entry.addRepeatingExtension(arg0);
+    }
+
+   
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#generateCumulativeXmlBlob(com.google.gdata.data.ExtensionProfile)
+     */
+    
+    public XmlBlob generateCumulativeXmlBlob(ExtensionProfile arg0) throws IOException {
+        
+        return this.entry.generateCumulativeXmlBlob(arg0);
+    }
+
+  
+   
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#getRepeatingExtension(java.lang.Class)
+     */
+    
+    public <T extends Extension> List<T> getRepeatingExtension(Class<T> arg0) {
+        
+        return this.entry.getRepeatingExtension(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#getXmlBlob()
+     */
+    
+    public XmlBlob getXmlBlob() {
+        
+        return this.entry.getXmlBlob();
+    }
+
+  
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#parseCumulativeXmlBlob(com.google.gdata.util.XmlBlob, com.google.gdata.data.ExtensionProfile, java.lang.Class)
+     */
+    
+    public void parseCumulativeXmlBlob(XmlBlob arg0, ExtensionProfile arg1, Class arg2) throws IOException, ParseException {
+        
+        this.entry.parseCumulativeXmlBlob(arg0, arg1, arg2);
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#removeExtension(java.lang.Class)
+     */
+    
+    public void removeExtension(Class arg0) {
+        
+        this.entry.removeExtension(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#removeExtension(com.google.gdata.data.Extension)
+     */
+    
+    public void removeExtension(Extension arg0) {
+        
+        this.entry.removeExtension(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#removeRepeatingExtension(com.google.gdata.data.Extension)
+     */
+    
+    public void removeRepeatingExtension(Extension arg0) {
+        
+        this.entry.removeRepeatingExtension(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#setExtension(com.google.gdata.data.Extension)
+     */
+    
+    public void setExtension(Extension arg0) {
+        
+        this.entry.setExtension(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#setXmlBlob(com.google.gdata.util.XmlBlob)
+     */
+    
+    public void setXmlBlob(XmlBlob arg0) {
+        
+        this.entry.setXmlBlob(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#declareExtensions(com.google.gdata.data.ExtensionProfile)
+     */
+    
+    public void declareExtensions(ExtensionProfile arg0) {
+        this.entry.declareExtensions(arg0);
+    }
+    
+    
+    
+    
+    
+    
+
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/data/ServerBaseFeed.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/data/ServerBaseFeed.java
new file mode 100644
index 0000000..b44022e
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/data/ServerBaseFeed.java
@@ -0,0 +1,683 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.data;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.Reader;
+import java.util.Collection;
+import java.util.List;
+import java.util.Set;
+
+import org.apache.lucene.gdata.server.registry.ProvidedService;
+
+import com.google.gdata.client.Service;
+import com.google.gdata.data.BaseEntry;
+import com.google.gdata.data.BaseFeed;
+import com.google.gdata.data.Category;
+import com.google.gdata.data.DateTime;
+import com.google.gdata.data.Extension;
+import com.google.gdata.data.ExtensionProfile;
+import com.google.gdata.data.Feed;
+import com.google.gdata.data.Generator;
+import com.google.gdata.data.Link;
+import com.google.gdata.data.Person;
+import com.google.gdata.data.TextConstruct;
+import com.google.gdata.util.ParseException;
+import com.google.gdata.util.ServiceException;
+import com.google.gdata.util.XmlBlob;
+import com.google.gdata.util.common.xml.XmlWriter;
+
+/**
+ * The GData-Server uses the GDATA-Client API for an interal representation of
+ * entries. These entities have dynamic elements like Links being generated
+ * using the requested URL.<br/> Some components of the server also need
+ * additional infomation like the service type
+ * {@link org.apache.lucene.gdata.server.registry.ProvidedService} of the feed.
+ * All these information are
+ * encapsulated in the ServerBaseFeed decoration a concrete subl class of <tt>BaseFeed</tt>. The type of the 
+ * {@link com.google.gdata.data.BaseEntry} contained it this feed will be passed to the ServerBaseFeed
+ * at creation time via the constructor. To retrieve the original entry call
+ * {@link ServerBaseFeed#getFeed()} returns a
+ * {@link com.google.gdata.data.BaseFeed} instance which can be casted into the
+ * actual type. To use the ServerBaseEntry for generation a provided format like
+ * RSS/ATOM the corresponding {@link com.google.gdata.data.ExtensionProfile} has
+ * to be provided to the generation method.
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class ServerBaseFeed  {
+
+    private String serviceType;
+
+    private ProvidedService serviceConfig;
+    
+    private GDataAccount account;
+    
+    private BaseFeed feed;
+    /**
+     * @return Returns the account.
+     */
+    public GDataAccount getAccount() {
+        return this.account;
+    }
+
+    /**
+     * @param account The account to set.
+     */
+    public void setAccount(GDataAccount account) {
+        this.account = account;
+    }
+
+    /**
+     * Creates a new ServerBaseFeed and decorates a basic instance of {@link Feed}
+     */
+    @SuppressWarnings("unchecked")
+    public ServerBaseFeed() {
+        this.feed = new Feed();
+        
+    }
+    /**
+     * @param feed - the feed to decorate
+     *            
+     */
+    @SuppressWarnings("unchecked")
+    public ServerBaseFeed(BaseFeed feed) {
+        this.feed = feed;
+        
+    }
+
+    /**
+     * @return Returns the feed.
+     */
+    public BaseFeed getFeed() {
+        return this.feed;
+    }
+
+    /**
+     * @param feed The feed to set.
+     */
+    public void setFeed(BaseFeed feed) {
+        this.feed = feed;
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#declareExtensions(com.google.gdata.data.ExtensionProfile)
+     */
+    public void declareExtensions(ExtensionProfile extProfile) {
+
+      this.feed.declareExtensions(extProfile);
+    }
+
+    /**
+     * @param link -
+     *            a link added to the link list of the feed
+     */
+    @SuppressWarnings("unchecked")
+    public void addLink(final Link link) {
+        this.feed.getLinks().add(link);
+    }
+
+    /**
+     * @param collection -
+     *            a collection of <code>Link</code> instance to be added to
+     *            the feeds link list
+     */
+    public void addLinks(final Collection<Link> collection) {
+        this.feed.getLinks().addAll(collection);
+    }
+
+    /**
+     * @return - the name of the service related of the feed represented by this
+     *         ServerBaseFeed
+     */
+    public String getServiceType() {
+        return this.serviceType;
+    }
+
+    /**
+     * @param serviceType -
+     *            the name of the service related of the feed represented by
+     *            this ServerBaseFeed
+     */
+    public void setServiceType(String serviceType) {
+        this.serviceType = serviceType;
+    }
+
+    /**
+     * @return - the provided service
+     */
+    public ProvidedService getServiceConfig() {
+        return this.serviceConfig;
+    }
+
+    /**
+     * @param serviceConfig - -
+     *            the provided service
+     */
+    public void setServiceConfig(ProvidedService serviceConfig) {
+        this.serviceConfig = serviceConfig;
+        if (serviceConfig != null)
+            this.serviceType = this.serviceConfig.getName();
+
+    }
+
+    /**
+     * @param person -
+     *            adds an author to the feed
+     */
+    public void addAuthor(final Person person) {
+        this.feed.getAuthors().add(person);
+    }
+    
+    /**
+     * @see com.google.gdata.data.BaseFeed#createEntry()
+     */
+    
+    public BaseEntry createEntry() {
+        
+        return this.feed.createEntry();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#generateAtom(com.google.gdata.util.common.xml.XmlWriter, com.google.gdata.data.ExtensionProfile)
+     */
+    
+    public void generateAtom(XmlWriter arg0, ExtensionProfile arg1) throws IOException {
+        
+        this.feed.generateAtom(arg0, arg1);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#generateAtomColl(com.google.gdata.util.common.xml.XmlWriter)
+     */
+    
+    public void generateAtomColl(XmlWriter arg0) throws IOException {
+        
+        this.feed.generateAtomColl(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#generateRss(com.google.gdata.util.common.xml.XmlWriter, com.google.gdata.data.ExtensionProfile)
+     */
+    
+    public void generateRss(XmlWriter arg0, ExtensionProfile arg1) throws IOException {
+        
+        this.feed.generateRss(arg0, arg1);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#getCanPost()
+     */
+    
+    public boolean getCanPost() {
+        
+        return this.feed.getCanPost();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#getEntries()
+     */
+    
+    public List getEntries() {
+        
+        return this.feed.getEntries();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#getEntryPostLink()
+     */
+    
+    public Link getEntryPostLink() {
+        
+        return this.feed.getEntryPostLink();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#getItemsPerPage()
+     */
+    
+    public int getItemsPerPage() {
+        
+        return this.feed.getItemsPerPage();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#getSelf()
+     */
+    
+    public BaseFeed getSelf() throws IOException, ServiceException {
+        
+        return this.feed.getSelf();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#getSelfLink()
+     */
+    
+    public Link getSelfLink() {
+        
+        return this.feed.getSelfLink();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#getService()
+     */
+    
+    public Service getService() {
+        
+        return this.feed.getService();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#getStartIndex()
+     */
+    
+    public int getStartIndex() {
+        
+        return this.feed.getStartIndex();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#getTotalResults()
+     */
+    
+    public int getTotalResults() {
+        
+        return this.feed.getTotalResults();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#insert(E)
+     */
+    
+    public BaseEntry insert(BaseEntry arg0) throws ServiceException, IOException {
+        
+        return this.feed.insert(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#parseAtom(com.google.gdata.data.ExtensionProfile, java.io.InputStream)
+     */
+    
+    public void parseAtom(ExtensionProfile arg0, InputStream arg1) throws IOException, ParseException {
+        
+        this.feed.parseAtom(arg0, arg1);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#parseAtom(com.google.gdata.data.ExtensionProfile, java.io.Reader)
+     */
+    
+    public void parseAtom(ExtensionProfile arg0, Reader arg1) throws IOException, ParseException {
+        
+        this.feed.parseAtom(arg0, arg1);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#setCanPost(boolean)
+     */
+    
+    public void setCanPost(boolean arg0) {
+        
+        this.feed.setCanPost(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#setItemsPerPage(int)
+     */
+    
+    public void setItemsPerPage(int arg0) {
+        
+        this.feed.setItemsPerPage(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#setService(com.google.gdata.client.Service)
+     */
+    
+    public void setService(Service arg0) {
+        
+        this.feed.setService(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#setStartIndex(int)
+     */
+    
+    public void setStartIndex(int arg0) {
+        
+        this.feed.setStartIndex(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#setTotalResults(int)
+     */
+    
+    public void setTotalResults(int arg0) {
+        
+        this.feed.setTotalResults(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#addHtmlLink(java.lang.String, java.lang.String, java.lang.String)
+     */
+    
+    public void addHtmlLink(String arg0, String arg1, String arg2) {
+        
+        this.feed.addHtmlLink(arg0, arg1, arg2);
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#getAuthors()
+     */
+    
+    public List<Person> getAuthors() {
+        
+        return this.feed.getAuthors();
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#getCategories()
+     */
+    
+    public Set<Category> getCategories() {
+        
+        return this.feed.getCategories();
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#getContributors()
+     */
+    
+    public List<Person> getContributors() {
+        
+        return this.feed.getContributors();
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#getGenerator()
+     */
+    
+    public Generator getGenerator() {
+        
+        return this.feed.getGenerator();
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#getHtmlLink()
+     */
+    
+    public Link getHtmlLink() {
+        
+        return this.feed.getHtmlLink();
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#getIcon()
+     */
+    
+    public String getIcon() {
+        
+        return this.feed.getIcon();
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#getId()
+     */
+    
+    public String getId() {
+        
+        return this.feed.getId();
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#getLink(java.lang.String, java.lang.String)
+     */
+    
+    public Link getLink(String arg0, String arg1) {
+        
+        return this.feed.getLink(arg0, arg1);
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#getLinks()
+     */
+    
+    public List<Link> getLinks() {
+        
+        return this.feed.getLinks();
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#getLogo()
+     */
+    
+    public String getLogo() {
+        
+        return this.feed.getLogo();
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#getRights()
+     */
+    
+    public TextConstruct getRights() {
+        
+        return this.feed.getRights();
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#getSubtitle()
+     */
+    
+    public TextConstruct getSubtitle() {
+        
+        return this.feed.getSubtitle();
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#getTitle()
+     */
+    
+    public TextConstruct getTitle() {
+        
+        return this.feed.getTitle();
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#getUpdated()
+     */
+    
+    public DateTime getUpdated() {
+        
+        return this.feed.getUpdated();
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#setGenerator(com.google.gdata.data.Generator)
+     */
+    
+    public void setGenerator(Generator arg0) {
+        
+        this.feed.setGenerator(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#setIcon(java.lang.String)
+     */
+    
+    public void setIcon(String arg0) {
+        
+        this.feed.setIcon(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#setId(java.lang.String)
+     */
+    
+    public void setId(String arg0) {
+        
+        this.feed.setId(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#setLogo(java.lang.String)
+     */
+    
+    public void setLogo(String arg0) {
+        
+        this.feed.setLogo(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#setRights(com.google.gdata.data.TextConstruct)
+     */
+    
+    public void setRights(TextConstruct arg0) {
+        
+        this.feed.setRights(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#setSubtitle(com.google.gdata.data.TextConstruct)
+     */
+    
+    public void setSubtitle(TextConstruct arg0) {
+        
+        this.feed.setSubtitle(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#setTitle(com.google.gdata.data.TextConstruct)
+     */
+    
+    public void setTitle(TextConstruct arg0) {
+        
+        this.feed.setTitle(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#setUpdated(com.google.gdata.data.DateTime)
+     */
+    
+    public void setUpdated(DateTime arg0) {
+        
+        this.feed.setUpdated(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#addExtension(com.google.gdata.data.Extension)
+     */
+    
+    public void addExtension(Extension arg0) {
+        
+        this.feed.addExtension(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#addRepeatingExtension(com.google.gdata.data.Extension)
+     */
+    
+    public void addRepeatingExtension(Extension arg0) {
+        
+        this.feed.addRepeatingExtension(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#getExtension(java.lang.Class)
+     */
+    
+    public <T extends Extension> T getExtension(Class<T> arg0) {
+        
+        return this.feed.getExtension(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#getRepeatingExtension(java.lang.Class)
+     */
+    
+    public <T extends Extension> List<T> getRepeatingExtension(Class<T> arg0) {
+        
+        return this.feed.getRepeatingExtension(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#getXmlBlob()
+     */
+    
+    public XmlBlob getXmlBlob() {
+        
+        return this.feed.getXmlBlob();
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#parseCumulativeXmlBlob(com.google.gdata.util.XmlBlob, com.google.gdata.data.ExtensionProfile, java.lang.Class)
+     */
+    
+    public void parseCumulativeXmlBlob(XmlBlob arg0, ExtensionProfile arg1, Class arg2) throws IOException, ParseException {
+        
+        this.feed.parseCumulativeXmlBlob(arg0, arg1, arg2);
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#removeExtension(java.lang.Class)
+     */
+    
+    public void removeExtension(Class arg0) {
+        
+        this.feed.removeExtension(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#removeExtension(com.google.gdata.data.Extension)
+     */
+    
+    public void removeExtension(Extension arg0) {
+        
+        this.feed.removeExtension(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#removeRepeatingExtension(com.google.gdata.data.Extension)
+     */
+    
+    public void removeRepeatingExtension(Extension arg0) {
+        
+        this.feed.removeRepeatingExtension(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#setExtension(com.google.gdata.data.Extension)
+     */
+    
+    public void setExtension(Extension arg0) {
+        
+        this.feed.setExtension(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#setXmlBlob(com.google.gdata.util.XmlBlob)
+     */
+    
+    public void setXmlBlob(XmlBlob arg0) {
+        
+        this.feed.setXmlBlob(arg0);
+    }
+
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/administration/AccountBuilder.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/administration/AccountBuilder.java
new file mode 100644
index 0000000..41209c1
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/administration/AccountBuilder.java
@@ -0,0 +1,62 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.server.administration;
+
+import java.io.IOException;
+import java.io.Reader;
+
+import org.apache.commons.digester.Digester;
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.xml.sax.SAXException;
+
+/**
+ * Helperclass to create {@link org.apache.lucene.gdata.data.GDataAccount}
+ * instances from a xml stream provided via a {@link Reader} instance.
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class AccountBuilder {
+
+    /**
+     * Reads the xml from the provided reader and binds the values to the 
+     * @param reader - the reader to read the xml from
+     * @return - the GDataAccount 
+     * @throws IOException - if an IOException occures
+     * @throws SAXException - if the xml can not be parsed by the sax reader
+     */
+    public static GDataAccount buildAccount(final Reader reader) throws IOException,
+            SAXException {
+        if (reader == null)
+            throw new IllegalArgumentException("Reader must not be null");
+        GDataAccount account = null;
+        Digester digester = new Digester();
+        digester.setValidating(false);
+        digester.addObjectCreate("account", GDataAccount.class);
+        digester.addBeanPropertySetter("account/account-name", "name");
+        digester.addBeanPropertySetter("account/password", "password");
+        digester.addBeanPropertySetter("account/account-role", "rolesAsInt");
+        digester.addBeanPropertySetter("account/account-owner/name",
+                "authorname");
+        digester.addBeanPropertySetter("account/account-owner/email-address",
+                "authorMail");
+        digester.addBeanPropertySetter("account/account-owner/url",
+                "authorLink");
+        account = (GDataAccount) digester.parse(reader);
+        return account;
+    }
+
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/administration/AdminService.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/administration/AdminService.java
new file mode 100644
index 0000000..b6e81b2
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/administration/AdminService.java
@@ -0,0 +1,123 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.server.administration;
+
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.data.ServerBaseFeed;
+import org.apache.lucene.gdata.server.Service;
+import org.apache.lucene.gdata.server.ServiceException;
+
+/**
+ * The AdminService interface extends the Service interface to serve common
+ * administrator requests. Common users can not create feed or user instances.
+ * This interface provides all actions for create, delete or update Users and
+ * Feeds. Each Feed has an associated Feed - Name which acts as an ID. Feed will
+ * be identified by the feed name e.g. {@link com.google.gdata.data.Source#getId()}
+ * <p>User accounts are supposed to have a unique username attribute as the username acts as a primary key for the storage</p>
+ *  
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public interface AdminService extends Service {
+
+    /**
+     * Creates a new feed instance.
+     * 
+     * @param feed -
+     *            the feed to create
+     * @param account - the account who own this feed
+     * @throws ServiceException -
+     *             if the feed can not be created
+     */
+    public abstract void createFeed(final ServerBaseFeed feed,
+            final GDataAccount account) throws ServiceException;
+
+    /**
+     * Updates the given feed
+     * 
+     * @param feed -
+     *            the feed to update
+     * @param account - the account who own this feed
+     * 
+     * @throws ServiceException -
+     *             if the feed can not be updated or does not exist.
+     */
+    public abstract void updateFeed(final ServerBaseFeed feed,
+            final GDataAccount account) throws ServiceException;
+
+    /**
+     * Deletes the given feed and all containing entries from the storage. The feed will not be accessable
+     * anymore.
+     * 
+     * @param feed -
+     *            the feed to deltete
+     * 
+     * @throws ServiceException -
+     *             if the feed can not be deleted or does not exist
+     */
+    public abstract void deleteFeed(final ServerBaseFeed feed) throws ServiceException;
+
+    /**
+     * Creates a new account accout.
+     * 
+     * @param account -
+     *            the account to create
+     * @throws ServiceException -
+     *             if the account can not be created or the account does already
+     *             exist.
+     */
+    public abstract void createAccount(final GDataAccount account)
+            throws ServiceException;
+
+    /**
+     * Deletes the given account from the storage. it will also delete all
+     * accociated feeds.
+     * 
+     * @param account
+     *            the account to delete
+     * @throws ServiceException -
+     *             if the account does not exist or the account can not be deleted
+     */
+    public abstract void deleteAccount(final GDataAccount account)
+            throws ServiceException;
+
+    /**
+     * Updates the given account if the account already exists.
+     * 
+     * @param account - the account to update 
+     * @throws ServiceException - if the account can not be updated or the account does not exist
+     */
+    public abstract void updateAccount(final GDataAccount account)
+            throws ServiceException;
+
+    /**
+     * Returns the account for the given account name or <code>null</code> if the account does not exist 
+     * 
+     * @param account - account name
+     * @return - the account for the given account name or <code>null</code> if the account does not exist
+     * @throws ServiceException - if the account can not be accessed
+     */
+    public abstract GDataAccount getAccount(String account) throws ServiceException;
+    
+    /**
+     * Returns the account associated with the feed for the given feed id
+     * @param feedId - the feed id
+     * @return - the GdataAccount assoziated with the feed for the given feed Id or <code>null</code> if there is no feed for the given feed Id
+     * @throws ServiceException - if the storage can not be accessed
+     */
+    public abstract GDataAccount getFeedOwningAccount(String feedId) throws ServiceException;
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/administration/GDataAdminService.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/administration/GDataAdminService.java
new file mode 100644
index 0000000..f48cdce
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/administration/GDataAdminService.java
@@ -0,0 +1,195 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.server.administration;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.data.ServerBaseFeed;
+import org.apache.lucene.gdata.server.GDataService;
+import org.apache.lucene.gdata.server.ServiceException;
+import org.apache.lucene.gdata.storage.StorageException;
+
+
+
+/**
+ * default implementation of the {@link org.apache.lucene.gdata.server.administration.AdminService} interface.
+ * @author Simon Willnauer
+ *
+ */
+public class GDataAdminService extends GDataService implements AdminService {
+    private static final Log LOG = LogFactory.getLog(GDataAdminService.class);
+    /**
+     * @throws ServiceException
+     */
+    public GDataAdminService() throws ServiceException {
+        super();
+        
+    }
+
+    
+
+    /**
+     * @see org.apache.lucene.gdata.server.administration.AdminService#createFeed(org.apache.lucene.gdata.data.ServerBaseFeed, org.apache.lucene.gdata.data.GDataAccount)
+     */
+    public void createFeed(final ServerBaseFeed feed,final GDataAccount account) throws ServiceException {
+        if(feed == null)
+            throw new ServiceException("Can not create feed -- feed is null");
+        if(account == null)
+            throw new ServiceException("Can not create feed -- account is null");
+        if(feed.getId() == null)
+            throw new ServiceException("Feed ID is null can not create feed");
+        if(account.getName() == null)
+            throw new ServiceException("Account name is null -- can't create feed");
+    try {
+        feed.setAccount(account);
+        this.storage.storeFeed(feed,account.getName());
+    } catch (StorageException e) {
+        if(LOG.isInfoEnabled())
+            LOG.info("Can not save feed -- "+e.getMessage(),e);
+        throw new ServiceException("Can not save feed",e);
+    }
+ 
+    }
+
+
+   
+    /**
+     * @see org.apache.lucene.gdata.server.administration.AdminService#updateFeed(org.apache.lucene.gdata.data.ServerBaseFeed, org.apache.lucene.gdata.data.GDataAccount)
+     */
+    public void updateFeed(ServerBaseFeed feed, GDataAccount account) throws ServiceException {
+        if(feed == null)
+            throw new ServiceException("Can not update null feed");
+        if(account == null)
+            throw new ServiceException("Can not update feed -- account is null");
+        if(feed.getId() == null)
+            throw new ServiceException("Feed ID is null can not update feed");
+        if(account.getName() == null)
+            throw new ServiceException("Account name is null -- can't update feed");
+    try {
+        feed.setAccount(account);
+        this.storage.updateFeed(feed,account.getName());
+    } catch (StorageException e) {
+        if(LOG.isInfoEnabled())
+            LOG.info("Can not update feed -- "+e.getMessage(),e);
+        throw new ServiceException("Can not update feed",e);
+    }
+
+    }
+
+   
+    
+    /**
+     * @see org.apache.lucene.gdata.server.administration.AdminService#deleteFeed(org.apache.lucene.gdata.data.ServerBaseFeed)
+     */
+    public void deleteFeed(ServerBaseFeed feed) throws ServiceException {
+        if(feed == null)
+            throw new ServiceException("Can not delete null feed");
+        if(feed.getId() == null)
+            throw new ServiceException("Feed ID is null can not delete feed");
+    try {
+        this.storage.deleteFeed(feed.getId());
+    } catch (StorageException e) {
+        if(LOG.isInfoEnabled())
+            LOG.info("Can not delete feed -- "+e.getMessage(),e);
+        throw new ServiceException("Can not delete feed",e);
+    }
+
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.administration.AdminService#createAccount(org.apache.lucene.gdata.data.GDataAccount)
+     */
+    public void createAccount(GDataAccount account) throws ServiceException {
+        if(account == null)
+            throw new ServiceException("Can not save null account");
+        try {
+            this.storage.storeAccount(account);
+        } catch (StorageException e) {
+            if(LOG.isInfoEnabled())
+                LOG.info("Can not save account -- "+e.getMessage(),e);
+            throw new ServiceException("Can not save account",e);
+        }
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.administration.AdminService#deleteAccount(org.apache.lucene.gdata.data.GDataAccount)
+     */
+    public void deleteAccount(GDataAccount account) throws ServiceException {
+        if(account == null)
+            throw new ServiceException("Can not delete null account");
+        try {
+            this.storage.deleteAccount(account.getName());
+        } catch (StorageException e) {
+            if(LOG.isInfoEnabled())
+                LOG.info("Can not save account -- "+e.getMessage(),e);
+            throw new ServiceException("Can not save account",e);
+        }
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.administration.AdminService#updateAccount(org.apache.lucene.gdata.data.GDataAccount)
+     */
+    public void updateAccount(GDataAccount account) throws ServiceException {
+        if(account == null)
+            throw new ServiceException("Can not update null account");
+        try {
+            this.storage.updateAccount(account);
+        } catch (StorageException e) {
+            if(LOG.isInfoEnabled())
+                LOG.info("Can not save account -- "+e.getMessage(),e);
+            throw new ServiceException("Can not save account",e);
+        }
+    }
+    
+    /**
+     * @see org.apache.lucene.gdata.server.administration.AdminService#getAccount(java.lang.String)
+     */
+    public GDataAccount getAccount(String accountName)throws ServiceException{
+        if(accountName == null)
+            throw new ServiceException("Can not get null account");
+        try {
+            return this.storage.getAccount(accountName);
+        } catch (StorageException e) {
+            if(LOG.isInfoEnabled())
+                LOG.info("Can not get account -- "+e.getMessage(),e);
+            throw new ServiceException("Can not get account",e);
+        }
+       
+    }
+
+
+
+    /**
+     * @see org.apache.lucene.gdata.server.administration.AdminService#getFeedOwningAccount(java.lang.String)
+     */
+    public GDataAccount getFeedOwningAccount(String feedId) throws ServiceException {
+        if(feedId == null)
+            throw new ServiceException("Can not get account - feed id must not be null");
+        try {
+            String accountName =  this.storage.getAccountNameForFeedId(feedId);
+           return this.storage.getAccount(accountName);
+            
+        } catch (StorageException e) {
+            if(LOG.isInfoEnabled())
+                LOG.info("Can not get account for feed Id -- "+e.getMessage(),e);
+            throw new ServiceException("Can not get account for the given feed id",e);
+        }
+    }
+
+   
+
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/administration/package.html b/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/administration/package.html
new file mode 100644
index 0000000..3ea9939
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/administration/package.html
@@ -0,0 +1,10 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
+<html> 
+<head> 
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
+   <meta name="Author" content="Simon Willnauer"> 
+</head> 
+<body> 
+Classes and Services used for user and feed configuration
+</body> 
+</html> 
\ No newline at end of file
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/authentication/AuthenticationController.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/authentication/AuthenticationController.java
new file mode 100644
index 0000000..49f9831
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/authentication/AuthenticationController.java
@@ -0,0 +1,122 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.server.authentication;
+
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
+import org.apache.lucene.gdata.server.registry.ServerComponent;
+
+/**
+ * Implementations of the AuthenticationController interface contain all the
+ * logic for processing token based authentification. A token is an encoded
+ * unique <tt>String</tt> value passed back to the client if successfully
+ * authenticated. Clients provide account name, password, the requested service
+ * and the name of the application used for accessing the the gdata service.
+ * <p>
+ * The algorithmn to create and reauthenticate the token can be choosen by the
+ * implementor. <br/> This interface extends
+ * {@link org.apache.lucene.gdata.server.registry.ServerComponent} e.g.
+ * implementing classes can be registered as a
+ * {@link org.apache.lucene.gdata.server.registry.Component} in the
+ * {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry} to be
+ * accessed via the provided lookup service
+ * </p>
+ * 
+ * @see org.apache.lucene.gdata.server.authentication.BlowfishAuthenticationController
+ * @author Simon Willnauer
+ * 
+ */
+public interface AuthenticationController extends ServerComponent {
+
+    /**
+     * The header name containing the authentication token provided by the
+     * client
+     */
+    public static final String AUTHORIZATION_HEADER = "Authorization";
+
+    /**
+     * Authentication parameter for the account name. Provided by the client to
+     * recieve the auth token.
+     */
+    public static final String ACCOUNT_PARAMETER = "Email";
+
+    /**
+     * Authentication parameter for the account password. Provided by the client
+     * to recieve the auth token.
+     */
+    public static final String PASSWORD_PARAMETER = "Passwd";
+
+    /**
+     * Authentication parameter for the requested service. Provided by the
+     * client to recieve the auth token.
+     */
+    public static final String SERVICE_PARAMETER = "service";
+
+    /**
+     * Authentication parameter for the application name of the clients
+     * application. This is just used for loggin purposes
+     */
+    public static final String APPLICATION_PARAMETER = "source";
+
+    /**
+     * The key used for respond the auth token to the client. Either as a cookie
+     * (key as cookie name) or as plain response (TOKEN_KEY=TOKEN)
+     */
+    public final static String TOKEN_KEY = "Auth";
+
+    /**
+     * Creates a authentication token for the given account. The token will be
+     * calculated based on a part of the clients ip address, the account role
+     * and the account name and the time in millisecond at the point of
+     * creation.
+     * 
+     * @param account -
+     *            the account to create the token for
+     * @param requestIp -
+     *            the clients request ip address
+     * @return - a BASE64 encoded authentification token
+     */
+    public abstract String authenticatAccount(GDataAccount account,
+            String requestIp);
+
+    /**
+     * Authenticates the given auth token and checks the given parameter for
+     * matching the information contained inside the token.
+     * <p>
+     * if the given account name is <code>null</code> the authentication will
+     * ignore the account name and the decision whether the token is valid or
+     * not will be based on the given role compared to the role inside the token
+     * </p>
+     * 
+     * @param token -
+     *            the token to authenticate
+     * @param requestIp -
+     *            the client request IP address
+     * @param role -
+     *            the required role
+     * @param accountName -
+     *            the name of the account
+     * @return <code>true</code> if the given values match the values inside
+     *         the token and if the timestamp plus the configured timeout is
+     *         greater than the current time, if one of the values does not
+     *         match or the token has timed out it will return
+     *         <code>false</code>
+     */
+    public abstract boolean authenticateToken(final String token,
+            final String requestIp, AccountRole role, String accountName);
+
+}
\ No newline at end of file
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/authentication/AuthenticationException.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/authentication/AuthenticationException.java
new file mode 100644
index 0000000..7d1044b
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/authentication/AuthenticationException.java
@@ -0,0 +1,70 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.server.authentication;
+
+/**
+ * 
+ * @author Simon Willnauer
+ *
+ */
+public class AuthenticationException extends Exception {
+
+    /**
+     * 
+     */
+    private static final long serialVersionUID = 5467768078178612671L;
+
+    /**
+     * Constructs a new Authentication Exception
+     */
+    public AuthenticationException() {
+        super();
+       
+    }
+
+    /**
+     * Constructs a new Authentication Exception with the specified detail message 
+     * @param arg0 - detail message
+     */
+    public AuthenticationException(String arg0) {
+        super(arg0);
+       
+    }
+
+    /**
+     * Constructs a new Authentication Exception with the specified detail message and
+     * nested exception caused this exception.
+      * @param arg0 -
+     *            detail message
+     * @param arg1 -
+     *            nested exception
+     */
+    public AuthenticationException(String arg0, Throwable arg1) {
+        super(arg0, arg1);
+       
+    }
+
+    /**
+     * Constructs a new Authentication Exception with a nested exception caused this exception
+     * @param arg0 - nested exception
+     */
+    public AuthenticationException(Throwable arg0) {
+        super(arg0);
+       
+    }
+
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/authentication/AuthenticatorException.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/authentication/AuthenticatorException.java
new file mode 100644
index 0000000..4bf9872
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/authentication/AuthenticatorException.java
@@ -0,0 +1,71 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.server.authentication;
+
+/**
+ * This exception will be thrown by
+ * {@link org.apache.lucene.gdata.server.authentication.AuthenticationController}
+ * implementations if an error while de/encrypting the token occures.
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class AuthenticatorException extends RuntimeException {
+
+    private static final long serialVersionUID = -5690495392712564651L;
+
+    /**
+     * Constructs a new Authenticator Exception
+     */ 
+    public AuthenticatorException() {
+        super();
+        
+    }
+
+    /**
+     * Constructs a new Authenticator Exception with the specified detail message.
+     * @param arg0 - detail message
+     */
+    public AuthenticatorException(String arg0) {
+        super(arg0);
+        
+    }
+
+    /**
+     * Constructs a new Authenticator Exception with the specified detail message and
+     * nested exception.
+     * 
+     * @param arg0 -
+     *            detail message
+     * @param arg1 -
+     *            nested exception
+     */
+    public AuthenticatorException(String arg0, Throwable arg1) {
+        super(arg0, arg1);
+        
+    }
+
+    /**
+     * Constructs a new Authenticator Exception with a nested exception caused this exception.
+     * @param arg0 - nested exception
+     */
+    public AuthenticatorException(Throwable arg0) {
+        super(arg0);
+        
+    }
+
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/authentication/BlowfishAuthenticationController.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/authentication/BlowfishAuthenticationController.java
new file mode 100644
index 0000000..3806954
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/authentication/BlowfishAuthenticationController.java
@@ -0,0 +1,274 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.server.authentication;
+
+import java.io.IOException;
+import java.io.UnsupportedEncodingException;
+import java.security.Provider;
+import java.security.Security;
+import java.util.StringTokenizer;
+import java.util.concurrent.locks.ReentrantLock;
+
+import javax.crypto.BadPaddingException;
+import javax.crypto.Cipher;
+import javax.crypto.IllegalBlockSizeException;
+import javax.crypto.KeyGenerator;
+import javax.crypto.spec.SecretKeySpec;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
+import org.apache.lucene.gdata.server.registry.Component;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+
+import sun.misc.BASE64Decoder;
+import sun.misc.BASE64Encoder;
+
+/**
+ * A
+ * {@link org.apache.lucene.gdata.server.authentication.AuthenticationController}
+ * implmentation using a <i>Blowfish</i> algorithmn to en/decrpyt the
+ * authentification token. The <i>Blowfish</i> algorithmn enables a stateless
+ * authetication of the client. The token contains all information to
+ * authenticate the client on possible other hosts.
+ * <p>
+ * The token contains the first 32 bit of the client ip (e.g. 192.168.0),
+ * account name, {@link org.apache.lucene.gdata.data.GDataAccount.AccountRole}
+ * and the cration time as a timestamp. The timestamp will be checked on every
+ * subsequent request. If the timestamp plus the configured timeout is less
+ * than the current time the client has to reauthenticate again.
+ * </p>
+ * <p>
+ * The auth token returned by the
+ * {@link BlowfishAuthenticationController#authenticatAccount(GDataAccount, String)}
+ * method is a BASE64 encoded string.
+ * </p>
+ * 
+ * @see javax.crypto.Cipher
+ * @see sun.misc.BASE64Encoder
+ * @see sun.misc.BASE64Decoder
+ * @author Simon Willnauer
+ * 
+ */
+@Component(componentType = ComponentType.AUTHENTICATIONCONTROLLER)
+public class BlowfishAuthenticationController implements
+        AuthenticationController {
+    private static final Log LOG = LogFactory
+            .getLog(BlowfishAuthenticationController.class);
+
+    private static final String ALG = "Blowfish";
+
+    private static final String TOKEN_LIMITER = "#";
+
+    private static final String ENCODING = "UTF-8";
+
+    private Cipher deCrypt;
+
+    private Cipher enCrypt;
+
+    // TODO make this configurable
+    private int minuteOffset = 30;
+
+    private long milisecondOffset;
+
+    private BASE64Encoder encoder = new BASE64Encoder();
+
+    private BASE64Decoder decoder = new BASE64Decoder();
+
+    private ReentrantLock lock = new ReentrantLock();
+
+    // TODO make this configurable
+    private String key = "myTestKey";
+
+    /**
+     * @see org.apache.lucene.gdata.server.authentication.AuthenticationController#initialize()
+     */
+    public void initialize() {
+        if (this.key == null)
+            throw new IllegalArgumentException("Auth key must not be null");
+        if (this.key.length() < 5 || this.key.length() > 16)
+            throw new IllegalArgumentException(
+                    "Auth key length must be greater than 4 and less than 17");
+
+        try {
+            Provider sunJce = new com.sun.crypto.provider.SunJCE();
+            Security.addProvider(sunJce);
+            KeyGenerator kgen = KeyGenerator.getInstance(ALG);
+            kgen.init(448); // 448 Bit^M
+            byte[] raw = this.key.getBytes();
+            SecretKeySpec skeySpec = new SecretKeySpec(raw, ALG);
+            this.deCrypt = Cipher.getInstance(ALG);
+            this.enCrypt = Cipher.getInstance(ALG);
+            this.deCrypt.init(Cipher.DECRYPT_MODE, skeySpec);
+            this.enCrypt.init(Cipher.ENCRYPT_MODE, skeySpec);
+        } catch (Exception e) {
+            throw new AuthenticatorException(
+                    "Can't initialize BlowfishAuthenticationController -- "
+                            + e.getMessage(), e);
+
+        }
+        calculateTimeOffset();
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.authentication.AuthenticationController#authenticatAccount(org.apache.lucene.gdata.data.GDataAccount,
+     *      java.lang.String)
+     */
+    public String authenticatAccount(GDataAccount account, String requestIp) {
+        try {
+            String passIp = requestIp.substring(0, requestIp.lastIndexOf('.'));
+            String role = Integer.toString(account.getRolesAsInt());
+
+            return calculateAuthToken(passIp, role, account.getName());
+        } catch (Exception e) {
+            throw new AuthenticatorException("Can not authenticat account -- "
+                    + e.getMessage(), e);
+
+        }
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.authentication.AuthenticationController#authenticateToken(java.lang.String,
+     *      java.lang.String,
+     *      org.apache.lucene.gdata.data.GDataAccount.AccountRole,
+     *      java.lang.String)
+     */
+    public boolean authenticateToken(final String token,
+            final String requestIp, AccountRole role, String accountName) {
+        if (LOG.isInfoEnabled())
+            LOG.info("authenticate Token " + token + " for requestIp: "
+                    + requestIp);
+        if (token == null || requestIp == null)
+            return false;
+        String passIp = requestIp.substring(0, requestIp.lastIndexOf('.'));
+        String authString = null;
+        try {
+            authString = deCryptAuthToken(token);
+        } catch (Exception e) {
+            throw new AuthenticatorException("Can not decrypt token -- "
+                    + e.getMessage(), e);
+        }
+        if (authString == null)
+            return false;
+        try {
+            StringTokenizer tokenizer = new StringTokenizer(authString,
+                    TOKEN_LIMITER);
+            if (!tokenizer.nextToken().equals(passIp))
+                return false;
+            String tempAccountName = tokenizer.nextToken();
+            int intRole = Integer.parseInt(tokenizer.nextToken());
+            /*
+             * Authentication goes either for a account role or a account. For
+             * entry manipulation the account name will be retrieved by the
+             * feedId otherwise it will be null If it is null the authentication
+             * goes against the account role
+             */
+            if (tempAccountName == null
+                    || (!tempAccountName.equals(accountName) && !GDataAccount
+                            .isInRole(intRole, role)))
+                return false;
+            long timeout = Long.parseLong(tokenizer.nextToken());
+
+            return (timeout + this.milisecondOffset) > System
+                    .currentTimeMillis();
+        } catch (Exception e) {
+            LOG.error("Error occured while encrypting token " + e.getMessage(),
+                    e);
+            return false;
+        }
+
+    }
+
+    private void calculateTimeOffset() {
+        this.milisecondOffset = this.minuteOffset * 60 * 1000;
+    }
+
+    protected String calculateAuthToken(final String ipAddress,
+            final String role, String accountName)
+            throws IllegalBlockSizeException, BadPaddingException,
+            UnsupportedEncodingException {
+        StringBuilder builder = new StringBuilder();
+        builder.append(ipAddress).append(TOKEN_LIMITER);
+        builder.append(accountName).append(TOKEN_LIMITER);
+        builder.append(role).append(TOKEN_LIMITER);
+        builder.append(System.currentTimeMillis());
+
+        this.lock.lock();
+        try {
+            byte[] toencode = builder.toString().getBytes(ENCODING);
+            byte[] result = this.enCrypt.doFinal(toencode);
+            return this.encoder.encode(result);
+        } finally {
+            this.lock.unlock();
+
+        }
+
+    }
+
+    protected String deCryptAuthToken(final String authToken)
+            throws IOException, IllegalBlockSizeException, BadPaddingException {
+        this.lock.lock();
+        try {
+            byte[] input = this.decoder.decodeBuffer(authToken);
+            byte[] result = this.deCrypt.doFinal(input);
+            return new String(result, ENCODING);
+        } finally {
+            this.lock.unlock();
+        }
+
+    }
+
+    /**
+     * @return Returns the minuteOffset.
+     */
+    public int getMinuteOffset() {
+        return this.minuteOffset;
+    }
+
+    /**
+     * @param minuteOffset
+     *            The minuteOffset to set.
+     */
+    public void setMinuteOffset(int minuteOffset) {
+        this.minuteOffset = minuteOffset;
+        calculateTimeOffset();
+    }
+
+    /**
+     * @return Returns the key.
+     */
+    public String getKey() {
+        return this.key;
+    }
+
+    /**
+     * @param key
+     *            The key to set.
+     */
+    public void setKey(String key) {
+        this.key = key;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.registry.ServerComponent#destroy()
+     */
+    public void destroy() {
+        //
+    }
+
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/authentication/GDataHttpAuthenticator.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/authentication/GDataHttpAuthenticator.java
new file mode 100644
index 0000000..433e1d5
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/authentication/GDataHttpAuthenticator.java
@@ -0,0 +1,59 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.server.authentication;
+
+import javax.servlet.http.HttpServletRequest;
+
+import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
+import org.apache.lucene.gdata.server.GDataRequest;
+
+/**
+ * The GData protocol is based on the widly know REST approach and therefor
+ * client authentication will mostly be provided via a REST interface.
+ * <p>
+ * This interface describes internally used authentication methods to be
+ * implemented by http based authenticator implementations. The GData Server
+ * basically has 2 different REST interfaces need authentication. One is for
+ * altering feed entries and the other for administration actions.
+ * </p>
+ * <p>The interface altering entries work with {@link com.google.gdata.client.Service.GDataRequest} object created by the handler and passed to the {@link org.apache.lucene.gdata.server.Service} instance.
+ * Administration interfaces use the plain {@link javax.servlet.http.HttpServletRequest} inside the handler.
+ * For each type of interface a authentication type a method has to be provided by implementing classes.</p> 
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public interface GDataHttpAuthenticator {
+
+    /**
+     * Authenticates the client request based on the given GdataRequst and required account role
+     * @param request - the gdata request
+     * @param role - the required role for passing the authentication
+     * 
+     * @return <code>true</code> if the request successfully authenticates, otherwise <code>false</code>
+     */
+    public boolean authenticateAccount(final GDataRequest request,
+            AccountRole role);
+
+    /**
+     * Authenticates the client request based on the given requst and required account role
+     * @param request - the client request
+     * @param role - the required role for passing the authentication
+     * @return <code>true</code> if the request successfully authenticates, otherwise <code>false</code>
+     */
+    public boolean authenticateAccount(final HttpServletRequest request,
+            AccountRole role);
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/authentication/package.html b/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/authentication/package.html
new file mode 100644
index 0000000..2b5672b
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/authentication/package.html
@@ -0,0 +1,10 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
+<html> 
+<head> 
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
+   <meta name="Author" content="Simon Willnauer"> 
+</head> 
+<body> 
+Classes and Exceptions used for client authentification.
+</body> 
+</html> 
\ No newline at end of file
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/registry/Component.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/registry/Component.java
new file mode 100644
index 0000000..335d816
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/registry/Component.java
@@ -0,0 +1,74 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.server.registry;
+
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+/**
+ * The {@link Component} annotation is used to annotate a class as a
+ * server-component of the GDATA-Server. Annotated class can be configured via
+ * the gdata-config.xml file to be looked up by aribaty classes at runtime via
+ * the
+ * {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry#lookup(Class, ComponentType)}
+ * method.
+ * <p>
+ * Classes annotated with the Component annotation need to provide a default
+ * constructor to be instanciated via reflection. Components of the GData-Server
+ * are definded in the
+ * {@link org.apache.lucene.gdata.server.registry.ComponentType} enumeration.
+ * Each of the enum types are annotated with a
+ * {@link org.apache.lucene.gdata.server.registry.SuperType} annotation. This
+ * annotation specifies the super class or interface of the component. A class
+ * annotated with the Component annotation must implement or extends this
+ * defined super-type. This enables developers to use custom implemetations of
+ * the component like a custom {@link org.apache.lucene.gdata.storage.Storage}.
+ * </p>
+ * <p>
+ * Each ComponentType can only registerd once as the
+ * {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry} does not
+ * provide multipe instances of a ComponentType.
+ * </p>
+ * <p>
+ * This annotation can only annotate types and can be accessed at runtime.
+ * {@link java.lang.annotation.Target} ==
+ * {@link java.lang.annotation.ElementType#TYPE} and
+ * {@link java.lang.annotation.Retention} ==
+ * {@link java.lang.annotation.RetentionPolicy#RUNTIME}.
+ * 
+ * @see org.apache.lucene.gdata.server.registry.GDataServerRegistry
+ * @see org.apache.lucene.gdata.server.registry.ComponentType
+ * @see org.apache.lucene.gdata.server.registry.SuperType
+ * 
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+@Target( { TYPE })
+@Retention(value = RUNTIME)
+public @interface Component {
+
+    /**
+     * @see ComponentType
+     * @return - the component type
+     */
+    ComponentType componentType();
+
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/registry/ComponentType.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/registry/ComponentType.java
new file mode 100644
index 0000000..d28c4d0
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/registry/ComponentType.java
@@ -0,0 +1,53 @@
+package org.apache.lucene.gdata.server.registry;
+
+import org.apache.lucene.gdata.server.ServiceFactory;
+import org.apache.lucene.gdata.server.authentication.AuthenticationController;
+import org.apache.lucene.gdata.servlet.handler.RequestHandlerFactory;
+import org.apache.lucene.gdata.storage.StorageController;
+
+/**
+ * The enmueration {@link ComponentType} defines the GDATA-Server Components 
+ * available via {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry#lookup(Class, ComponentType)} 
+ * method.
+ * @see org.apache.lucene.gdata.server.registry.Component
+ * @see org.apache.lucene.gdata.server.registry.GDataServerRegistry 
+ * @author Simon Willnauer
+ *
+ */
+public enum ComponentType {
+    /**
+     * StorageController Type
+     * 
+     * @see StorageController
+     */
+    @SuperType(superType = StorageController.class)
+    STORAGECONTROLLER,
+    /**
+     * RequestHandlerFactory Type
+     * 
+     * @see RequestHandlerFactory
+     */
+    @SuperType(superType = RequestHandlerFactory.class)
+    REQUESTHANDLERFACTORY,
+    /**
+     * INDEXER TYPE
+     * 
+     */
+    // TODO not available yet
+    @SuperType(superType = Object.class)
+    INDEXER,
+    /**
+     * ServiceFactory Type
+     * 
+     * @see ServiceFactory
+     */
+    @SuperType(superType = ServiceFactory.class)
+    SERVICEFACTORY,
+    /**
+     * Supertype for AuthenticationController implementations
+     * @see AuthenticationController
+     */
+    @SuperType(superType = AuthenticationController.class)
+    AUTHENTICATIONCONTROLLER
+
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/registry/ProvidedService.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/registry/ProvidedService.java
new file mode 100644
index 0000000..3caf84a
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/registry/ProvidedService.java
@@ -0,0 +1,48 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */ 
+package org.apache.lucene.gdata.server.registry;
+
+import com.google.gdata.data.ExtensionProfile;
+
+/**
+ * This interface describes a service provided by the GData-Server.
+ * @see org.apache.lucene.gdata.server.registry.GDataServerRegistry 
+ * @author Simon Willnauer
+ *
+ */
+public interface ProvidedService {
+
+    /** 
+     * @return Returns the feedType. 
+     */
+    public abstract Class getFeedType();
+
+    /** 
+     * @return - the extension profile for this feed 
+     */
+    public abstract ExtensionProfile getExtensionProfile();
+
+    /**
+     * @return the entry Type configured for this Service
+     */
+    public abstract Class getEntryType();
+
+    /**
+     * @return - the servicename
+     */
+    public abstract String getName();
+
+}
\ No newline at end of file
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/registry/ProvidedServiceConfig.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/registry/ProvidedServiceConfig.java
new file mode 100644
index 0000000..227b5dd
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/registry/ProvidedServiceConfig.java
@@ -0,0 +1,131 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.server.registry;
+
+import com.google.gdata.data.ExtensionProfile;
+
+/**
+ * Standart implementation of
+ * {@link org.apache.lucene.gdata.server.registry.ProvidedService} to be used
+ * inside the
+ * {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry}
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class ProvidedServiceConfig implements ProvidedService {
+    private String serviceName;
+
+    private Class entryType;
+
+    private Class feedType;
+
+    private ExtensionProfile extensionProfile;
+
+   
+    ProvidedServiceConfig(ExtensionProfile profile, Class feedType,
+            Class entryType, String serviceName) {
+        this.extensionProfile = profile;
+        this.feedType = feedType;
+        this.entryType = entryType;
+        this.serviceName = serviceName;
+
+    }
+
+    /**
+     * Default constructor to instanciate via reflection 
+     */
+    public ProvidedServiceConfig() {
+        //
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.registry.ProvidedService#getFeedType()
+     */
+    public Class getFeedType() {
+        return this.feedType;
+    }
+
+    /**
+     * @param feedType
+     *            The feedType to set.
+     */
+    public void setFeedType(Class feedType) {
+        this.feedType = feedType;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.registry.ProvidedService#getExtensionProfile()
+     */
+    public ExtensionProfile getExtensionProfile() {
+        return this.extensionProfile;
+    }
+
+    /**
+     * @param extensionProfil -
+     *            the extensionprofile for this feed configuration
+     */
+    public void setExtensionProfile(ExtensionProfile extensionProfil) {
+        this.extensionProfile = extensionProfil;
+    }
+
+    
+    /**
+     *TODO add comment
+     * @param <E>
+     * @param extensionProfileClass
+     * @throws InstantiationException
+     * @throws IllegalAccessException
+     */
+    public <E extends ExtensionProfile> void setExtensionProfileClass(
+            Class<E> extensionProfileClass) throws InstantiationException,
+            IllegalAccessException {
+        if (extensionProfileClass == null)
+            throw new IllegalArgumentException(
+                    "ExtensionProfile class must not be null");
+
+        this.extensionProfile = extensionProfileClass.newInstance();
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.registry.ProvidedService#getEntryType()
+     */
+    public Class getEntryType() {
+        return this.entryType;
+    }
+    
+    /**
+     * @param entryType
+     */
+    public void setEntryType(Class entryType) {
+        this.entryType = entryType;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.registry.ProvidedService#getName()
+     */
+    public String getName() {
+        return this.serviceName;
+    }
+
+    /**
+     * @param serviceName
+     */
+    public void setName(String serviceName) {
+        this.serviceName = serviceName;
+    }
+
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/registry/RegistryException.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/registry/RegistryException.java
new file mode 100644
index 0000000..81a5db1
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/registry/RegistryException.java
@@ -0,0 +1,51 @@
+package org.apache.lucene.gdata.server.registry;
+
+/**
+ * This exception is thrown by the
+ * {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry} if
+ * registering a service or a component fails.
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class RegistryException extends Exception {
+
+ 
+    private static final long serialVersionUID = -3563720639871194466L;
+
+    /**
+     * Constructs a new Registry Exception.
+     */
+    public RegistryException() {
+        super();
+        
+    }
+
+    /**
+     * Constructs a new Registry Exception with the specified detail message.
+     * @param arg0 - detail message
+     */
+    public RegistryException(String arg0) {
+        super(arg0);
+        
+    }
+
+    /**
+     * Constructs a new Registry Exception with the specified detail message and nested exception.
+     * @param arg0 - detail message
+     * @param arg1 - nested exception
+     */
+    public RegistryException(String arg0, Throwable arg1) {
+        super(arg0, arg1);
+        
+    }
+
+    /** Constructs a new Registry Exception with a nested exception.
+     * @param arg0 - nested exception
+     */
+    public RegistryException(Throwable arg0) {
+        super(arg0);
+        
+    }
+
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/registry/ServerComponent.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/registry/ServerComponent.java
new file mode 100644
index 0000000..e211158
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/registry/ServerComponent.java
@@ -0,0 +1,42 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.server.registry;
+
+/**
+ * To Register a class as a component in the
+ * {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry} the class
+ * or a super class must implements this interface.
+ * <p>
+ * <tt>ServerComponent</tt> defines a method <tt>initialize</tt> and
+ * <tt>destroy</tt>. <tt>initialize</tt> will be called when the component
+ * is registered and <tt>destroy</tt> when the registry is destroyed (usually
+ * at server shut down).</p>
+ * @see org.apache.lucene.gdata.server.registry.GDataServerRegistry
+ * @author Simon Willnauer
+ * 
+ */
+public interface ServerComponent {
+    /**
+     * will be call when the component is registered.
+     */
+    public abstract void initialize();
+
+    /**
+     * will be called when the registry is going down e.g. when the  {@link GDataServerRegistry#destroy()} method is called.
+     */
+    public abstract void destroy();
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/registry/SuperType.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/registry/SuperType.java
new file mode 100644
index 0000000..c23a95d
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/server/registry/SuperType.java
@@ -0,0 +1,44 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.server.registry;
+
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+/**
+ * This Annotation is use to annotate
+ * {@link org.apache.lucene.gdata.server.registry.ComponentType} elements to
+ * specify an interface e.g. super type of a defined component.
+ * <p>This annotation will be visible at runtime</p>
+ * @see org.apache.lucene.gdata.server.registry.Component
+ * @see org.apache.lucene.gdata.server.registry.GDataServerRegistry
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+@Target( { FIELD })
+@Retention(value = RUNTIME)
+public @interface SuperType {
+    /**
+     * 
+     * @return the specified super type
+     */
+    Class superType();
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/AccountAdministrationServlet.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/AccountAdministrationServlet.java
new file mode 100644
index 0000000..3e9a64c
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/AccountAdministrationServlet.java
@@ -0,0 +1,73 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.servlet;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.servlet.handler.GDataRequestHandler;
+
+/**
+ * This Servlet provides an REST interface to create / update and delete user instances.
+ * @author Simon Willnauer
+ *
+ */
+public class AccountAdministrationServlet extends AbstractGdataServlet {
+   
+    private static final Log LOGGER = LogFactory.getLog(AccountAdministrationServlet.class);
+
+    /**
+     * 
+     */
+    private static final long serialVersionUID = 8215863212137543185L;
+
+    @Override
+    protected void doDelete(HttpServletRequest arg0, HttpServletResponse arg1) throws ServletException, IOException {
+        GDataRequestHandler handler = HANDLER_FACTORY.getDeleteAccountHandler();
+        if(LOGGER.isInfoEnabled())
+            LOGGER.info("Process delete Account request");
+        handler.processRequest(arg0,arg1);
+       
+    }
+
+    @Override
+    protected void doPost(HttpServletRequest arg0, HttpServletResponse arg1) throws ServletException, IOException {
+        GDataRequestHandler handler = HANDLER_FACTORY.getInsertAccountHandler();
+        if(LOGGER.isInfoEnabled())
+            LOGGER.info("Process insert Account request");
+        handler.processRequest(arg0,arg1);        
+       
+    }
+
+    @Override
+    protected void doPut(HttpServletRequest arg0, HttpServletResponse arg1) throws ServletException, IOException {
+        
+        GDataRequestHandler handler = HANDLER_FACTORY.getUpdateAccountHandler();
+        if(LOGGER.isInfoEnabled())
+            LOGGER.info("Process update Account request");
+        handler.processRequest(arg0,arg1);  
+    }
+    
+   
+   
+
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/AuthenticationServlet.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/AuthenticationServlet.java
new file mode 100644
index 0000000..0d84c68
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/AuthenticationServlet.java
@@ -0,0 +1,50 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.servlet;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.lucene.gdata.servlet.handler.AuthenticationHandler;
+
+/**
+ * REST interface for handling authentification requests from clients to get a
+ * auth token either as a cookie or as a plain auth token. This Servlet uses a
+ * single {@link org.apache.lucene.gdata.servlet.handler.AuthenticationHandler}
+ * instance to handle the incoming requests.
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class AuthenticationServlet extends HttpServlet {
+
+    private final AuthenticationHandler handler = new AuthenticationHandler();
+
+    private static final long serialVersionUID = 7132478125868917848L;
+
+    @SuppressWarnings("unused")
+    @Override
+    protected void doPost(HttpServletRequest request,
+            HttpServletResponse response) throws ServletException, IOException {
+        this.handler.processRequest(request, response);
+    }
+
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/FeedAdministrationServlet.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/FeedAdministrationServlet.java
new file mode 100644
index 0000000..3a16073
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/FeedAdministrationServlet.java
@@ -0,0 +1,71 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.servlet;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.servlet.handler.GDataRequestHandler;
+
+/**
+ * This Servlet provides an REST interface to create / update and delete Feed instances.
+ *  
+ * @author Simon Willnauer
+ *
+ */
+public class FeedAdministrationServlet extends AbstractGdataServlet {
+    private static final Log LOGGER = LogFactory.getLog(FeedAdministrationServlet.class);
+    /**
+     * 
+     */
+    private static final long serialVersionUID = -905586350743277032L;
+
+    @Override
+    protected void doDelete(HttpServletRequest arg0, HttpServletResponse arg1) throws ServletException, IOException {
+        GDataRequestHandler handler = HANDLER_FACTORY.getDeleteFeedHandler();
+        if(LOGGER.isInfoEnabled())
+            LOGGER.info("Process delete feed request");
+        handler.processRequest(arg0,arg1);
+     
+    }
+
+    @Override
+    protected void doPost(HttpServletRequest arg0, HttpServletResponse arg1) throws ServletException, IOException {
+        GDataRequestHandler handler = HANDLER_FACTORY.getInsertFeedHandler();
+        if(LOGGER.isInfoEnabled())
+            LOGGER.info("Process insert feed request");
+        handler.processRequest(arg0,arg1);
+     
+    }
+
+    @Override
+    protected void doPut(HttpServletRequest arg0, HttpServletResponse arg1) throws ServletException, IOException {
+        GDataRequestHandler handler = HANDLER_FACTORY.getUpdateFeedHandler();
+        if(LOGGER.isInfoEnabled())
+            LOGGER.info("Process update feed request");
+        handler.processRequest(arg0,arg1);
+     
+    }
+
+  
+
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/handler/AbstractAccountHandler.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/handler/AbstractAccountHandler.java
new file mode 100644
index 0000000..6bd76ef
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/handler/AbstractAccountHandler.java
@@ -0,0 +1,186 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.servlet.handler;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
+import org.apache.lucene.gdata.server.ServiceException;
+import org.apache.lucene.gdata.server.ServiceFactory;
+import org.apache.lucene.gdata.server.administration.AccountBuilder;
+import org.apache.lucene.gdata.server.administration.AdminService;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
+import org.xml.sax.SAXException;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public abstract class AbstractAccountHandler extends RequestAuthenticator
+        implements GDataRequestHandler {
+    private static final Log LOG = LogFactory
+            .getLog(AbstractAccountHandler.class);
+
+    private boolean authenticated = false;
+
+    private int error;
+
+    private String errorMessage = "";
+
+    private boolean isError = false;
+
+    protected AdminService service;
+
+    /**
+     * @see org.apache.lucene.gdata.servlet.handler.GDataRequestHandler#processRequest(javax.servlet.http.HttpServletRequest,
+     *      javax.servlet.http.HttpServletResponse)
+     */
+    @SuppressWarnings("unused")
+    public void processRequest(HttpServletRequest request,
+            HttpServletResponse response) throws ServletException, IOException {
+        
+            this.authenticated = authenticateAccount(request,
+                AccountRole.USERADMINISTRATOR);
+        
+        if (this.authenticated) {
+            GDataServerRegistry registry = GDataServerRegistry.getRegistry();
+            ServiceFactory factory = registry.lookup(ServiceFactory.class,
+                    ComponentType.SERVICEFACTORY);
+            try {
+
+                GDataAccount account = getAccountFromRequest(request);
+                if (!account.requiredValuesSet()) {
+                    setError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
+                            "requiered server component not available");
+                    throw new AccountHandlerException(
+                            "requiered values are not set -- account can not be saved -- "
+                                    + account);
+                }
+                this.service = factory.getAdminService();
+                processServiceAction(account);
+            } catch (ServiceException e) {
+                LOG.error("Can't process account action -- " + e.getMessage(),
+                        e);
+                setError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "");
+            } catch (Exception e) {
+                LOG.error("Can't process account action -- " + e.getMessage(),
+                        e);
+            }
+        }else{
+            setError(HttpServletResponse.SC_UNAUTHORIZED,"Authorization failed");
+        }
+        sendResponse(response);
+
+    }
+    
+    
+    
+
+    protected GDataAccount getAccountFromRequest(
+            final HttpServletRequest request) throws AccountHandlerException {
+        try {
+            GDataAccount account = AccountBuilder.buildAccount(request
+                    .getReader());
+            if (account == null) {
+                setError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "");
+                throw new AccountHandlerException(
+                        "unexpected value -- parsed account is null");
+            }
+            return account;
+        } catch (IOException e) {
+            setError(HttpServletResponse.SC_BAD_REQUEST, "can not read input");
+            throw new AccountHandlerException("Can't read from request reader",
+                    e);
+        } catch (SAXException e) {
+            setError(HttpServletResponse.SC_BAD_REQUEST,
+                    "can not parse gdata account");
+            throw new AccountHandlerException(
+                    "Can not parse incoming gdata account", e);
+        }
+    }
+
+    protected void sendResponse(HttpServletResponse response) {
+
+        if (!this.isError)
+            return;
+        try {
+            response.sendError(this.error, this.errorMessage);
+        } catch (IOException e) {
+            LOG.warn("can send error in RequestHandler ", e);
+        }
+    }
+
+    protected void setError(int error, String message) {
+        this.error = error;
+        this.errorMessage = message;
+        this.isError = true;
+    }
+
+    protected int getErrorCode() {
+        return this.error;
+    }
+
+    protected String getErrorMessage() {
+        return this.errorMessage;
+    }
+
+    protected abstract void processServiceAction(final GDataAccount account)
+            throws ServiceException;
+
+    static class AccountHandlerException extends Exception {
+
+        /**
+         * 
+         */
+        private static final long serialVersionUID = 3140463271122190694L;
+
+        /**
+         * Constructs a new <tt>AccountHandlerException</tt> with an exception
+         * message and the exception caused this exception.
+         * 
+         * @param arg0 -
+         *            the exception message
+         * @param arg1 -
+         *            the exception cause
+         */
+        public AccountHandlerException(String arg0, Throwable arg1) {
+            super(arg0, arg1);
+
+        }
+
+        /**
+         * Constructs a new <tt>AccountHandlerException</tt> with an exception
+         * message.
+         * 
+         * @param arg0 -
+         *            the exception message
+         */
+        public AccountHandlerException(String arg0) {
+            super(arg0);
+
+        }
+
+    }
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/handler/AbstractFeedHandler.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/handler/AbstractFeedHandler.java
new file mode 100644
index 0000000..a1284b7
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/handler/AbstractFeedHandler.java
@@ -0,0 +1,173 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.servlet.handler;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.data.ServerBaseFeed;
+import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
+import org.apache.lucene.gdata.server.GDataEntityBuilder;
+import org.apache.lucene.gdata.server.ServiceException;
+import org.apache.lucene.gdata.server.ServiceFactory;
+import org.apache.lucene.gdata.server.administration.AdminService;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
+import org.apache.lucene.gdata.server.registry.ProvidedService;
+
+import com.google.gdata.util.ParseException;
+
+/**
+ * 
+ * @author Simon Willnauer
+ *
+ */
+public abstract class AbstractFeedHandler extends RequestAuthenticator implements GDataRequestHandler {
+    private static final Log LOG = LogFactory.getLog(AbstractFeedHandler.class);
+
+    protected static final String PARAMETER_ACCOUNT = "account";
+
+    protected static final String PARAMETER_SERVICE = "service";
+    private int error;
+    protected boolean authenticated = false;
+    
+      private String errorMessage = "";
+      private boolean isError = false;
+      
+    /**
+     * @see org.apache.lucene.gdata.servlet.handler.GDataRequestHandler#processRequest(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
+     */
+    @SuppressWarnings("unused")
+    public void processRequest(HttpServletRequest request,
+            HttpServletResponse response) throws ServletException, IOException {
+            this.authenticated = authenticateAccount(request,AccountRole.FEEDAMINISTRATOR);
+            if(!this.authenticated)
+                setError(HttpServletResponse.SC_UNAUTHORIZED,"Authorization failed");
+        
+    }
+    
+    protected ServerBaseFeed createFeedFromRequest(HttpServletRequest request) throws ParseException, IOException, FeedHandlerException{
+        GDataServerRegistry registry = GDataServerRegistry.getRegistry();
+        String providedService = request.getParameter(PARAMETER_SERVICE);
+        if(!registry.isServiceRegistered(providedService)){
+            setError(HttpServletResponse.SC_NOT_FOUND,"no such service");
+            throw new FeedHandlerException("ProvicdedService is not registered -- Name: "+providedService);
+         }
+        ProvidedService provServiceInstance = registry.getProvidedService(providedService);  
+        if(providedService == null){
+            setError(HttpServletResponse.SC_BAD_REQUEST,"no such service");
+            throw new FeedHandlerException("no such service registered -- "+providedService);
+        }
+        try{
+            ServerBaseFeed retVal = new ServerBaseFeed(GDataEntityBuilder.buildFeed(request.getReader(),provServiceInstance));
+            retVal.setServiceConfig(provServiceInstance);
+        return retVal;
+        }catch (IOException e) {
+            if(LOG.isInfoEnabled())
+                LOG.info("Can not read from input stream - ",e);
+            setError(HttpServletResponse.SC_BAD_REQUEST,"Can not read from input stream");
+            throw e;
+        }catch (ParseException e) {
+            if(LOG.isInfoEnabled())
+                LOG.info("feed can not be parsed - ",e);
+            setError(HttpServletResponse.SC_BAD_REQUEST,"incoming feed can not be parsed");
+            throw e;
+        }
+        
+    }
+    
+    
+    protected GDataAccount createRequestedAccount(HttpServletRequest request) throws FeedHandlerException{
+        GDataServerRegistry registry = GDataServerRegistry.getRegistry();
+           ServiceFactory serviceFactory = registry.lookup(ServiceFactory.class,ComponentType.SERVICEFACTORY);
+        
+        if(serviceFactory == null){
+            setError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "Required server component not available");
+            throw new FeedHandlerException("Required server component not available -- "+ServiceFactory.class.getName());
+        }
+        AdminService service = serviceFactory.getAdminService();
+        String account = request.getParameter(PARAMETER_ACCOUNT);
+        try{
+        return service.getAccount(account);
+        }catch (ServiceException e) {
+            if(LOG.isInfoEnabled())
+                LOG.info("no account for requested account - "+account,e);
+            setError(HttpServletResponse.SC_BAD_REQUEST,"no such account");
+            throw new FeedHandlerException(e.getMessage(),e);
+        }
+    }
+    
+    protected void sendResponse(HttpServletResponse response){
+        
+        if(!this.isError)
+            return;
+        try{
+        response.sendError(this.error,this.errorMessage);
+        }catch (IOException e) {
+            LOG.warn("can send error in RequestHandler ",e);
+        }
+    }
+    
+    protected void setError(int error, String message){
+        this.error = error;
+        this.errorMessage = message;
+        this.isError = true;
+    }
+    protected int getErrorCode(){
+        return this.error;
+    }
+    
+    protected String getErrorMessage(){
+        return this.errorMessage;
+    }
+    
+    class FeedHandlerException extends Exception{
+
+        /**
+         * 
+         */
+        private static final long serialVersionUID = 1L;
+
+        /**
+         * Creates a new FeedHandlerException with a exception message and the exception cause this ex.
+         * @param arg0 - the message
+         * @param arg1 - the cause
+         */
+        public FeedHandlerException(String arg0, Throwable arg1) {
+            super(arg0, arg1);
+       
+        }
+
+        /**
+         * Creates a new FeedHandlerException with a exception message.
+         * @param arg0 - message
+         */
+        public FeedHandlerException(String arg0) {
+            super(arg0 );
+            
+        }
+        
+    }
+    
+
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/handler/AuthenticationHandler.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/handler/AuthenticationHandler.java
new file mode 100644
index 0000000..51acf3b
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/handler/AuthenticationHandler.java
@@ -0,0 +1,124 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.servlet.handler;
+
+import java.io.IOException;
+import java.io.Writer;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.server.ServiceException;
+import org.apache.lucene.gdata.server.ServiceFactory;
+import org.apache.lucene.gdata.server.administration.AdminService;
+import org.apache.lucene.gdata.server.authentication.AuthenticationController;
+import org.apache.lucene.gdata.server.authentication.AuthenticationException;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
+
+
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class AuthenticationHandler implements GDataRequestHandler {
+    private static final Log LOG = LogFactory.getLog(AuthenticationHandler.class);
+    private final AuthenticationController controller;
+    private final static String errorKey = "Error";
+    private final static char seperatory = '=';
+    private final ServiceFactory serviceFactory;
+    private final GDataServerRegistry registry;
+    /**
+     * 
+     */
+    public AuthenticationHandler() {
+        this.registry = GDataServerRegistry.getRegistry();
+        this.controller = this.registry.lookup(AuthenticationController.class, ComponentType.AUTHENTICATIONCONTROLLER);
+        this.serviceFactory = this.registry.lookup(ServiceFactory.class, ComponentType.SERVICEFACTORY);
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.servlet.handler.GDataRequestHandler#processRequest(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
+     */
+    @SuppressWarnings("unused")
+    public void processRequest(HttpServletRequest request,
+            HttpServletResponse response) throws ServletException, IOException {
+        
+        try {
+        String serviceName = request.getParameter(AuthenticationController.SERVICE_PARAMETER);
+        if(LOG.isInfoEnabled()){
+            String application = request.getParameter(AuthenticationController.APPLICATION_PARAMETER);
+            LOG.info("Authentication request for service: "+serviceName+"; Application name: "+application);
+        }
+        
+        if(!this.registry.isServiceRegistered(serviceName))
+            throw new AuthenticationException("requested Service "+serviceName+"is not registered");
+        String password = request.getParameter(AuthenticationController.PASSWORD_PARAMETER);
+        String accountName = request.getParameter(AuthenticationController.ACCOUNT_PARAMETER);
+        String clientIp = request.getRemoteHost();
+        
+       
+        
+        GDataAccount  account = getAccount(accountName);
+        if(account == null || !account.getPassword().equals(password))
+            throw new AuthenticationException("Account is null or password does not match");
+        
+        String token = this.controller.authenticatAccount(account,clientIp);
+        sendToken(response,token);
+        if(LOG.isInfoEnabled()){
+            
+            LOG.info("Account authenticated -- "+account);
+        }
+        } catch (AuthenticationException e){
+            LOG.error("BadAuthentication -- "+e.getMessage(),e);
+            sendError(response, HttpServletResponse.SC_FORBIDDEN,"BadAuthentication");
+        }catch (Exception e) {
+            LOG.error("Unexpected Exception -- SERVERERROR -- "+e.getMessage(),e);
+            sendError(response,HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "Service not available");
+        }
+    }
+    
+    
+   private GDataAccount getAccount(String accountName) throws ServiceException{
+       AdminService service = this.serviceFactory.getAdminService();
+       return service.getAccount(accountName);
+        
+    }
+   private void sendError(HttpServletResponse response, int code, String message)throws IOException{
+       Writer writer = response.getWriter();
+       writer.write(errorKey);
+       writer.write(seperatory);
+       writer.write(message);
+       response.sendError(code);
+   }
+   
+   private void sendToken(HttpServletResponse response, String token) throws IOException{
+       Writer responseWriter = response.getWriter();
+       Cookie cookie = new Cookie(AuthenticationController.TOKEN_KEY,token);
+       response.addCookie(cookie);
+       responseWriter.write(AuthenticationController.TOKEN_KEY);
+       responseWriter.write(seperatory);
+       responseWriter.write(token);
+       responseWriter.close();
+   }
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/handler/DeleteAccountStrategy.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/handler/DeleteAccountStrategy.java
new file mode 100644
index 0000000..5623b71
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/handler/DeleteAccountStrategy.java
@@ -0,0 +1,44 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.servlet.handler;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.server.ServiceException;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class DeleteAccountStrategy extends AbstractAccountHandler {
+
+    private static final Log LOG = LogFactory.getLog(DefaultDeleteHandler.class);
+
+    
+
+    @Override
+    protected void processServiceAction(GDataAccount account) throws ServiceException {
+        try{
+        this.service.deleteAccount(account);
+        }catch (ServiceException e) {
+            LOG.error("Can't delete account -- "+e.getMessage(),e);
+            throw e;
+        }
+        
+    }
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/handler/DeleteFeedHandler.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/handler/DeleteFeedHandler.java
new file mode 100644
index 0000000..e00fe8c
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/handler/DeleteFeedHandler.java
@@ -0,0 +1,81 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.servlet.handler;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.ServerBaseFeed;
+import org.apache.lucene.gdata.server.ServiceFactory;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class DeleteFeedHandler extends AbstractFeedHandler{
+    private static final Log LOG = LogFactory.getLog(DeleteFeedHandler.class);
+
+    /**
+     * @throws IOException 
+     * @see org.apache.lucene.gdata.servlet.handler.GDataRequestHandler#processRequest(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
+     */
+    @Override
+    public void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
+            super.processRequest(request,response);
+            if(this.authenticated){
+            try {
+                ServerBaseFeed feed = createDeleteFeed(request);
+                
+                GDataServerRegistry registry = GDataServerRegistry.getRegistry();
+                ServiceFactory serviceFactory = registry.lookup(ServiceFactory.class,ComponentType.SERVICEFACTORY);
+                if(serviceFactory == null){
+                    setError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,"required component is not available");
+                    throw new FeedHandlerException("Can't save feed - ServiceFactory is null");
+                }
+                serviceFactory.getAdminService().deleteFeed(feed);
+            } catch (FeedHandlerException e) {
+                LOG.error("Can not delete feed -- "+e.getMessage(),e);
+            }catch (Exception e) {
+                LOG.error("Can not delete feed -- "+e.getMessage(),e);
+                setError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,"can not create feed");
+            } 
+            }
+            sendResponse(response);
+           
+        
+        
+    }
+
+    private ServerBaseFeed createDeleteFeed(final HttpServletRequest request) throws FeedHandlerException {
+        String feedId = request.getParameter("feedid");
+        if(feedId == null){
+            setError(HttpServletResponse.SC_BAD_REQUEST,"No feed id specified");
+            throw new FeedHandlerException("no feed Id specified");
+        }
+        ServerBaseFeed retVal = new ServerBaseFeed();
+        retVal.setId(feedId);
+        return retVal;
+    }
+
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/handler/InsertAccountStrategy.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/handler/InsertAccountStrategy.java
new file mode 100644
index 0000000..8c46c08
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/handler/InsertAccountStrategy.java
@@ -0,0 +1,48 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.servlet.handler;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.server.ServiceException;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class InsertAccountStrategy extends AbstractAccountHandler {
+    private static final Log LOG = LogFactory.getLog(InsertAccountStrategy.class);
+   
+  
+
+    @Override
+    protected void processServiceAction(GDataAccount account) throws ServiceException {
+        try{
+        this.service.createAccount(account);
+        }catch (ServiceException e) {
+            LOG.error("Can't create account -- "+e.getMessage(),e);
+            throw e;
+        }
+        
+    }
+
+
+
+    
+
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/handler/InsertFeedHandler.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/handler/InsertFeedHandler.java
new file mode 100644
index 0000000..520fb92
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/handler/InsertFeedHandler.java
@@ -0,0 +1,78 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.servlet.handler;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.data.ServerBaseFeed;
+import org.apache.lucene.gdata.server.ServiceException;
+import org.apache.lucene.gdata.server.ServiceFactory;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class InsertFeedHandler extends AbstractFeedHandler {
+    private static final Log LOG = LogFactory.getLog(InsertFeedHandler.class);
+
+    /**
+     * @see org.apache.lucene.gdata.servlet.handler.GDataRequestHandler#processRequest(javax.servlet.http.HttpServletRequest,
+     *      javax.servlet.http.HttpServletResponse)
+     */
+    @SuppressWarnings("unused")
+    public void processRequest(HttpServletRequest request,
+            HttpServletResponse response) throws ServletException, IOException {
+        super.processRequest(request, response);
+        if (this.authenticated) {
+            try {
+                ServerBaseFeed feed = createFeedFromRequest(request);
+                GDataAccount account = createRequestedAccount(request);
+
+                GDataServerRegistry registry = GDataServerRegistry
+                        .getRegistry();
+                ServiceFactory serviceFactory = registry.lookup(
+                        ServiceFactory.class, ComponentType.SERVICEFACTORY);
+                if (serviceFactory == null) {
+                    setError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
+                            "required component is not available");
+                    throw new FeedHandlerException(
+                            "Can't save feed - ServiceFactory is null");
+                }
+                serviceFactory.getAdminService().createFeed(feed, account);
+            } catch (ServiceException e) {
+                setError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
+                        "can not create feed");
+                LOG.error("Can not create feed -- " + e.getMessage(), e);
+            } catch (Exception e) {
+                LOG.error("Can not create feed -- " + e.getMessage(), e);
+
+            }
+
+        }
+        sendResponse(response);
+    }
+
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/handler/RequestAuthenticator.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/handler/RequestAuthenticator.java
new file mode 100644
index 0000000..1ad95ee
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/handler/RequestAuthenticator.java
@@ -0,0 +1,145 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.servlet.handler;
+
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServletRequest;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
+import org.apache.lucene.gdata.server.GDataRequest;
+import org.apache.lucene.gdata.server.ServiceException;
+import org.apache.lucene.gdata.server.ServiceFactory;
+import org.apache.lucene.gdata.server.administration.AdminService;
+import org.apache.lucene.gdata.server.authentication.AuthenticationController;
+import org.apache.lucene.gdata.server.authentication.AuthenticatorException;
+import org.apache.lucene.gdata.server.authentication.GDataHttpAuthenticator;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
+
+/**
+ * The RequestAuthenticator provides access to the registered
+ * {@link org.apache.lucene.gdata.server.authentication.AuthenticationController}
+ * as a super class for all request handler requiereing authentication for
+ * access. This class implements the
+ * {@link org.apache.lucene.gdata.server.authentication.GDataHttpAuthenticator}
+ * to get the auth token from the given request and call the needed Components
+ * to authenticat the client.
+ * <p>
+ * For request handler handling common requests like entry insert or update the
+ * authentication will be based on the account name verified as the owner of the
+ * feed to alter. If the accountname in the token does not match the name of the
+ * account which belongs to the feed the given role will be used for
+ * autentication. Authentication using the
+ * {@link RequestAuthenticator#authenticateAccount(HttpServletRequest, AccountRole)}
+ * method, the account name will be ignored, authentication will be based on the
+ * given <tt>AccountRole</tt>
+ * </p>
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class RequestAuthenticator implements GDataHttpAuthenticator {
+    private static final Log LOG = LogFactory
+            .getLog(RequestAuthenticator.class);
+
+    /**
+     * @see org.apache.lucene.gdata.server.authentication.GDataHttpAuthenticator#authenticateAccount(org.apache.lucene.gdata.server.GDataRequest,
+     *      org.apache.lucene.gdata.data.GDataAccount.AccountRole)
+     */
+    public boolean authenticateAccount(GDataRequest request, AccountRole role) {
+        String clientIp = request.getRemoteAddress();
+        if (LOG.isDebugEnabled())
+            LOG
+                    .debug("Authenticating Account for GDataRequest -- modifying entries -- Role: "
+                            + role + "; ClientIp: " + clientIp);
+
+        AuthenticationController controller = GDataServerRegistry.getRegistry()
+                .lookup(AuthenticationController.class,
+                        ComponentType.AUTHENTICATIONCONTROLLER);
+        ServiceFactory factory = GDataServerRegistry.getRegistry().lookup(
+                ServiceFactory.class, ComponentType.SERVICEFACTORY);
+        AdminService adminService = factory.getAdminService();
+        GDataAccount account;
+        try {
+            account = adminService.getFeedOwningAccount(request.getFeedId());
+            String token = getTokenFromRequest(request.getHttpServletRequest());
+            if (LOG.isDebugEnabled())
+                LOG.debug("Got Token: " + token + "; for requesting account: "
+                        + account);
+            if (account != null && token != null)
+                return controller.authenticateToken(token, clientIp,
+                        AccountRole.ENTRYAMINISTRATOR, account.getName());
+
+        } catch (ServiceException e) {
+            LOG.error("can get GDataAccount for feedID -- "
+                    + request.getFeedId(), e);
+            throw new AuthenticatorException(" Service exception occured", e);
+
+        }
+
+        return false;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.authentication.GDataHttpAuthenticator#authenticateAccount(javax.servlet.http.HttpServletRequest,
+     *      org.apache.lucene.gdata.data.GDataAccount.AccountRole)
+     */
+    public boolean authenticateAccount(HttpServletRequest request,
+            AccountRole role) {
+        String clientIp = request.getRemoteAddr();
+        if (LOG.isDebugEnabled())
+            LOG
+                    .debug("Authenticating Account for GDataRequest -- modifying entries -- Role: "
+                            + role + "; ClientIp: " + clientIp);
+        AuthenticationController controller = GDataServerRegistry.getRegistry()
+                .lookup(AuthenticationController.class,
+                        ComponentType.AUTHENTICATIONCONTROLLER);
+        String token = getTokenFromRequest(request);
+        if (LOG.isDebugEnabled())
+            LOG.debug("Got Token: " + token + ";");
+        if (token == null)
+            return false;
+        return controller.authenticateToken(token, clientIp, role, null);
+
+    }
+
+    protected String getTokenFromRequest(HttpServletRequest request) {
+        String token = request
+                .getHeader(AuthenticationController.AUTHORIZATION_HEADER);
+        if (token == null || !token.startsWith("GoogleLogin")) {
+            Cookie[] cookies = request.getCookies();
+            if (cookies == null) {
+                return null;
+            }
+            for (int i = 0; i < cookies.length; i++) {
+                if (cookies[i].getName().equals(
+                        AuthenticationController.TOKEN_KEY)) {
+                    token = cookies[i].getValue();
+                    break;
+                }
+
+            }
+        }
+        if (token != null)
+            token = token.substring(token.indexOf("=") + 1);
+        return token;
+    }
+
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/handler/UpdataAccountStrategy.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/handler/UpdataAccountStrategy.java
new file mode 100644
index 0000000..e7ddc98
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/handler/UpdataAccountStrategy.java
@@ -0,0 +1,44 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.servlet.handler;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.server.ServiceException;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class UpdataAccountStrategy extends AbstractAccountHandler {
+
+    private static final Log LOG = LogFactory.getLog(UpdataAccountStrategy.class);
+
+    
+
+    @Override
+    protected void processServiceAction(GDataAccount account) throws ServiceException {
+        try{
+        this.service.updateAccount(account);
+        }catch (ServiceException e) {
+            LOG.error("Can't update account -- "+e.getMessage(),e);
+            throw e;
+        }
+        
+    }
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/handler/UpdateFeedHandler.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/handler/UpdateFeedHandler.java
new file mode 100644
index 0000000..3cf5e74
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/servlet/handler/UpdateFeedHandler.java
@@ -0,0 +1,80 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.servlet.handler;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.data.ServerBaseFeed;
+import org.apache.lucene.gdata.server.ServiceException;
+import org.apache.lucene.gdata.server.ServiceFactory;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class UpdateFeedHandler extends AbstractFeedHandler {
+    private static final Log LOG = LogFactory.getLog(UpdateFeedHandler.class);
+
+    /**
+     * @see org.apache.lucene.gdata.servlet.handler.AbstractFeedHandler#processRequest(javax.servlet.http.HttpServletRequest,
+     *      javax.servlet.http.HttpServletResponse)
+     */
+    @SuppressWarnings("unused")
+    @Override
+    public void processRequest(HttpServletRequest request,
+            HttpServletResponse response) throws ServletException, IOException {
+        super.processRequest(request, response);
+        if (this.authenticated) {
+            try {
+                ServerBaseFeed feed = createFeedFromRequest(request);
+                GDataAccount account = createRequestedAccount(request);
+
+                GDataServerRegistry registry = GDataServerRegistry
+                        .getRegistry();
+                ServiceFactory serviceFactory = registry.lookup(
+                        ServiceFactory.class, ComponentType.SERVICEFACTORY);
+                if (serviceFactory == null) {
+                    setError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
+                            "required component is not available");
+                    throw new FeedHandlerException(
+                            "Can't update feed - ServiceFactory is null");
+                }
+                serviceFactory.getAdminService().updateFeed(feed, account);
+            } catch (ServiceException e) {
+                setError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
+                        "can not update feed");
+                LOG.error("Can not update feed -- " + e.getMessage(), e);
+            } catch (Exception e) {
+
+                LOG.error("Can not update feed -- " + e.getMessage(), e);
+
+            }
+        }
+        sendResponse(response);
+
+    }
+
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/ResourceNotFoundException.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/ResourceNotFoundException.java
new file mode 100644
index 0000000..69d0945
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/ResourceNotFoundException.java
@@ -0,0 +1,66 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.storage;
+
+/**
+ * This exception will be thrown if an requested resource of a resource to modify can not be found
+ * @author Simon Willnauer
+ *
+ */
+public class ResourceNotFoundException extends StorageException {
+
+   
+    private static final long serialVersionUID = -8549987918130998249L;
+
+    /**
+     * Constructs an empty ResourceNotFoundException
+     */
+    public ResourceNotFoundException() {
+        super();
+        // TODO Auto-generated constructor stub
+    }
+
+    /**
+     * Constructs a new ResourceNotFoundException with an exception message
+     * @param message - the exception message
+     */
+    public ResourceNotFoundException(String message) {
+        super(message);
+        // TODO Auto-generated constructor stub
+    }
+
+    /**
+     * Constructs a new ResourceNotFoundException with an exception message and a root cause 
+     * @param message - the exception message
+     * @param cause - the root cause of this exception
+     */
+    public ResourceNotFoundException(String message, Throwable cause) {
+        super(message, cause);
+        // TODO Auto-generated constructor stub
+    }
+
+    /**
+     * Constructs a new ResourceNotFoundException with  a root cause
+     * @param cause - the root cause of this exception
+     * 
+     */
+    public ResourceNotFoundException(Throwable cause) {
+        super(cause);
+        // TODO Auto-generated constructor stub
+    }
+
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageAccountWrapper.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageAccountWrapper.java
new file mode 100644
index 0000000..e721ccc
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageAccountWrapper.java
@@ -0,0 +1,111 @@
+package org.apache.lucene.gdata.storage.lucenestorage;
+
+import java.net.MalformedURLException;
+import java.net.URL;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.gdata.data.GDataAccount;
+
+/**
+ * Wrapps a User Object.
+ * The wrapper provides also a Lucene repesentation of the user;
+ * User Objects will not be Buffered in the lucene storage component. Each User will be written imidialtely.
+ * @author Simon Willnauer
+ *
+ */
+public class StorageAccountWrapper implements StorageWrapper{
+    private static final Log LOG = LogFactory.getLog(StorageAccountWrapper.class);
+    
+    /**
+     * Lucene field for the username
+     */
+    public static final String FIELD_ACCOUNTNAME = "accountName";
+    /**
+     * Lucene field for the password
+     */
+    public static final String FIELD_PASSWORD = "passwd";
+    /**
+     * Lucene field for the author name
+     */
+    public static final String FIELD_AUTHORNAME = "author";
+    /**
+     * Lucene field for the author mail address
+     */
+    public static final String FIELD_AUTHORMAIL = "authorMail";
+    /**
+     * Lucene field for the author link
+     */
+    public static final String FIELD_AUTHORHREF = "authorHref";
+    /**
+     * Lucene field fot the userroles
+     */
+    public static final String FIELD_ROLES = "userroles";
+    private final GDataAccount user;
+    /**
+     * @param user - the user to be wrapped
+     */
+    public StorageAccountWrapper(final GDataAccount user) {
+        if(user == null)
+            throw new IllegalArgumentException("user must not be null");
+        this.user = user;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageWrapper#getLuceneDocument()
+     */
+    public Document getLuceneDocument() {
+        Document doc = new Document();
+        
+        doc.add(new Field(FIELD_ACCOUNTNAME,this.user.getName(),Field.Store.YES,Field.Index.UN_TOKENIZED));
+        doc.add(new Field(FIELD_PASSWORD,this.user.getPassword()==null?"":this.user.getPassword(),Field.Store.YES,Field.Index.NO));
+        doc.add(new Field(FIELD_AUTHORNAME,this.user.getAuthorname()==null?"":this.user.getAuthorname(),Field.Store.YES,Field.Index.NO));
+        doc.add(new Field(FIELD_AUTHORMAIL,this.user.getAuthorMail()==null?"":this.user.getAuthorMail(),Field.Store.YES,Field.Index.NO));
+        doc.add(new Field(FIELD_AUTHORHREF,this.user.getAuthorLink()==null?"":this.user.getAuthorLink().toString(),Field.Store.YES,Field.Index.NO));
+        doc.add(new Field(FIELD_ROLES, Integer.toString(this.user.getRolesAsInt()),Field.Store.YES,Field.Index.NO)); 
+       
+        return doc;
+    }
+   
+   
+    
+    
+    /**
+     * @param doc - a lucene document representation of an user
+     * @return - the user to build from the document. or <code>null</code> if the document is <code>null</code>
+     */
+    public static GDataAccount buildEntity(final Document doc){
+        if(doc == null)
+            return null;
+        
+        GDataAccount user = new GDataAccount();
+        user.setName(doc.get(FIELD_ACCOUNTNAME));
+        user.setPassword(doc.get(FIELD_PASSWORD));
+        user.setAuthorname(doc.get(FIELD_AUTHORNAME));
+        user.setAuthorMail(doc.get(FIELD_AUTHORMAIL));
+        try{
+        user.setRolesAsInt(Integer.parseInt(doc.get(FIELD_ROLES)));
+        }catch (NumberFormatException e) {
+            LOG.info("Can't parse userroles: "+user.getName()+" throws NumberFormatException. -- skipping --",e);
+        }
+        try {
+            if(doc.get(FIELD_AUTHORHREF)!= null)
+                user.setAuthorLink(new URL(doc.get(FIELD_AUTHORHREF)));
+        } catch (MalformedURLException e) {
+            LOG.info("SPECIFIED URL for user: "+user.getName()+" throws MalformedURLException. -- skipping --",e);
+        }
+        return user;
+    }
+    
+   
+
+    /**
+     * @return - the wrapped user
+     */
+    public GDataAccount getUser() {
+        return this.user;
+    }
+
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageFeedWrapper.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageFeedWrapper.java
new file mode 100644
index 0000000..08feb06
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageFeedWrapper.java
@@ -0,0 +1,106 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.storage.lucenestorage;
+
+import java.io.IOException;
+import java.io.StringWriter;
+
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.gdata.data.ServerBaseFeed;
+import org.apache.lucene.gdata.server.registry.ProvidedService;
+
+import com.google.gdata.data.BaseFeed;
+import com.google.gdata.util.common.xml.XmlWriter;
+
+/**
+ * This immutable class wrapps <tt>GDataAccount</tt> instances for an internal Storage representation of 
+ * an account. This class also acts as a Documentfactory for lucene documents to 
+ * be stored inside the index. 
+ * @author Simon Willnauer
+ *
+ */
+public class StorageFeedWrapper implements StorageWrapper {
+    
+    private static final String INTERNAL_ENCODING = "UTF-8";
+    /**
+     * the account who owns the feed 
+     */
+    public static final String FIELD_ACCOUNTREFERENCE = "accountReference";
+    /**
+     * the id of the feed
+     */
+    public static final String FIELD_FEED_ID = "feedId";
+    /**
+     * The xml feed representation
+     */
+    public static final String FIELD_CONTENT = "content";
+    
+    /**
+     * The creation timestamp
+     */
+    public static final String FIELD_TIMESTAMP = "timestamp";
+
+    /**
+     * The Service this feed belongs to. 
+     */
+    public static final String FIELD_SERVICE_ID = "serviceId";
+    private final ServerBaseFeed feed;
+    private final String accountName;
+    private final ProvidedService config;
+    private final String content;
+    
+    
+    /**
+     * @param feed 
+     * @param accountname 
+     * @throws IOException 
+     * 
+     */
+    public StorageFeedWrapper(final ServerBaseFeed feed, final String accountname) throws IOException {
+        this.feed = feed;
+        this.accountName = accountname;
+        this.config = feed.getServiceConfig();
+        this.content = buildContent();
+       
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageWrapper#getLuceneDocument()
+     */
+    public Document getLuceneDocument() {
+        Document doc = new Document();
+        doc.add(new Field(FIELD_ACCOUNTREFERENCE,this.accountName,Field.Store.YES,Field.Index.UN_TOKENIZED));
+        doc.add(new Field(FIELD_FEED_ID,this.feed.getId(),Field.Store.YES,Field.Index.UN_TOKENIZED));
+        doc.add(new Field(FIELD_CONTENT,this.content,Field.Store.COMPRESS,Field.Index.NO));
+        doc.add(new Field(FIELD_SERVICE_ID,this.feed.getServiceType(),Field.Store.YES,Field.Index.NO));
+        return doc;
+    }
+
+    private String buildContent() throws IOException { 
+        StringWriter writer = new StringWriter(); 
+        XmlWriter xmlWriter = new XmlWriter(writer, INTERNAL_ENCODING); 
+        this.feed.generateAtom(xmlWriter,this.config.getExtensionProfile()); 
+        return writer.toString(); 
+    }
+    /**
+     * @return - the wrapped feed
+     */
+    public BaseFeed getFeed(){
+        return this.feed.getFeed();
+    }
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageWrapper.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageWrapper.java
new file mode 100644
index 0000000..90791e6
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageWrapper.java
@@ -0,0 +1,38 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.storage.lucenestorage;
+
+import org.apache.lucene.document.Document;
+
+/**
+ * A interface to be implemented by <tt>StorageWrapper</tt> sub classes to
+ * provide a lucene document for each entity wrapped.
+ * 
+ * @see org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper
+ * @see org.apache.lucene.gdata.storage.lucenestorage.StorageAccountWrapper
+ * @see org.apache.lucene.gdata.storage.lucenestorage.StorageFeedWrapper
+ * @author Simon Willnauer
+ * 
+ */
+public interface StorageWrapper {
+    /**
+     * Returns a Lucene document representing the Wrapped Entry
+     * 
+     * @return a Lucene Document
+     */
+    public abstract Document getLuceneDocument();
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverController.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverController.java
new file mode 100644
index 0000000..e76529f
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverController.java
@@ -0,0 +1,169 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.storage.lucenestorage.recover;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.FileReader;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.Writer;
+import java.util.List;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.storage.StorageException;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageModifier;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper.StorageOperation;
+
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class RecoverController {
+    private static final Log LOG = LogFactory.getLog(RecoverController.class);
+    private final File recoverDirectory;
+
+    private static final String FILE_SUFFIX = ".rec";
+
+    private File currentRecoverFile;
+
+    private RecoverWriter writer;
+
+    private Writer fileWriter;
+
+    private BufferedReader fileReader;
+
+    private RecoverReader reader;
+
+    private Lock lock = new ReentrantLock();
+    
+    private final boolean recover;
+    private final boolean keepRecoverFiles;
+
+    public RecoverController(final File recoverDirectory, boolean recover, boolean keepRecoverFiles) {
+        if (recoverDirectory == null)
+            throw new IllegalArgumentException("directory must not be null");
+        if (!recoverDirectory.isDirectory())
+            throw new IllegalStateException("the given File is not a directory");
+        this.recover = recover;
+        this.keepRecoverFiles = keepRecoverFiles;
+        this.recoverDirectory = recoverDirectory;
+       
+    }
+
+   public void storageModified(StorageEntryWrapper wrapper)
+            throws RecoverException {
+        // prevent deadlock either recovering or writing
+        if(this.recover){
+            LOG.warn("Can't write entry, Recovercontroller is initialized in recover mode");
+            return;
+        }
+        this.lock.lock();
+        try {
+
+            this.writer.writeEntry(wrapper, this.fileWriter);
+        } catch (Exception e) {
+            LOG.error("Writing entry failed -- create new recover file",e);
+            throw new RecoverException(
+                    "Writing entry failed -- create new recover file",e);
+
+        } finally {
+            this.lock.unlock();
+        }
+    }
+    
+    public void recoverEntries(final StorageModifier modifier){
+        // prevent deadlock either recovering or writing
+        if(!this.recover){
+            LOG.warn("Can't recover entries, Recovercontroller is initialized in write mode");
+            return;
+        }
+        this.lock.lock();
+        try{
+            this.reader = new RecoverReader();
+        File[] files = this.recoverDirectory.listFiles();
+        for (int i = 0; i < files.length; i++) {
+            if(!files[i].isDirectory()){
+                try{
+                this.fileReader = new BufferedReader(new FileReader(files[i]));
+                List<StorageEntryWrapper> entryList = this.reader.recoverEntries(this.fileReader);
+                if(entryList.size() == 0)
+                    continue;
+                storeEntries(entryList,modifier);
+                this.fileReader.close();
+                if(!this.keepRecoverFiles)
+                    files[i].delete();
+                }catch (StorageException e) {
+                    LOG.error("Can't store recover entries for file: "+files[i].getName()+" -- keep file "+e.getMessage(),e);
+                }catch (IOException e) {
+                    LOG.error("Can't recover entries for file: "+files[i].getName()+" -- keep file",e);
+                }
+            }
+        }
+        
+        }finally{
+            this.lock.unlock();
+        }
+    }
+    
+    protected void storeEntries(final List<StorageEntryWrapper> entries, final StorageModifier modifier) throws StorageException{
+        for (StorageEntryWrapper wrapper : entries) {
+            if(wrapper.getOperation() == StorageOperation.DELETE)
+                modifier.deleteEntry(wrapper);
+            else if(wrapper.getOperation() == StorageOperation.INSERT)
+                modifier.insertEntry(wrapper);
+            else if(wrapper.getOperation() == StorageOperation.UPDATE)
+                modifier.updateEntry(wrapper);
+                
+            
+        }
+    }
+
+    protected synchronized void initialize() throws IOException {
+        if(this.recover)
+            return;
+        String filename = System.currentTimeMillis() + FILE_SUFFIX;
+        this.currentRecoverFile = new File(this.recoverDirectory, filename);
+        this.writer = new RecoverWriter();
+        this.fileWriter = new BufferedWriter(new FileWriter(
+                this.currentRecoverFile));
+
+    }
+
+    protected void destroy() throws RecoverException {
+        if (this.fileWriter != null) {
+            this.lock.lock();
+            try {
+                this.fileWriter.flush();
+                this.fileWriter.close();
+            } catch (IOException e) {
+                throw new RecoverException("Can't close recover writer ", e);
+            } finally {
+                this.lock.unlock();
+            }
+        }
+    }
+    
+    
+
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverException.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverException.java
new file mode 100644
index 0000000..00fe65f
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverException.java
@@ -0,0 +1,63 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.storage.lucenestorage.recover;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class RecoverException extends Exception {
+
+    /**
+     * 
+     */
+    private static final long serialVersionUID = -1862309520257024464L;
+
+    /**
+     * 
+     */
+    public RecoverException() {
+        super();
+        // TODO Auto-generated constructor stub
+    }
+
+    /**
+     * @param arg0
+     */
+    public RecoverException(String arg0) {
+        super(arg0);
+        // TODO Auto-generated constructor stub
+    }
+
+    /**
+     * @param arg0
+     * @param arg1
+     */
+    public RecoverException(String arg0, Throwable arg1) {
+        super(arg0, arg1);
+        // TODO Auto-generated constructor stub
+    }
+
+    /**
+     * @param arg0
+     */
+    public RecoverException(Throwable arg0) {
+        super(arg0);
+        // TODO Auto-generated constructor stub
+    }
+
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverReader.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverReader.java
new file mode 100644
index 0000000..eb0807d
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverReader.java
@@ -0,0 +1,174 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.storage.lucenestorage.recover;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.StringReader;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.StringTokenizer;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.server.GDataEntityBuilder;
+import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
+import org.apache.lucene.gdata.server.registry.ProvidedService;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper.StorageOperation;
+
+import com.google.gdata.data.BaseEntry;
+import com.google.gdata.util.ParseException;
+
+/**
+ * Recovers the written object from the harddisc
+ * @author Simon Willnauer
+ *
+ */
+public class RecoverReader {
+    
+    private static final Log LOG = LogFactory.getLog(RecoverReader.class);
+    private RecoverStrategy strategy; 
+    protected RecoverReader(){
+        this.strategy = new RecoverStrategy();
+    }
+    /**
+     * @param reader
+     * @return
+     * @throws IOException
+     */
+    public List<StorageEntryWrapper> recoverEntries(final BufferedReader reader) throws IOException{
+        List<StorageEntryWrapper> actionList = new ArrayList<StorageEntryWrapper>();
+        this.strategy = new RecoverStrategy();
+        String input = null;
+        String metaData = null;
+        String entryData = null;
+        while((input=reader.readLine())!= null){
+            if(metaData == null){
+                metaData = input;
+                continue;
+            }
+            if(input.equals(RecoverWriter.STORAGE_OPERATION_SEPARATOR)){
+                try{
+                actionList.add(this.strategy.recover(metaData,entryData));
+                }catch (RecoverException e) {
+                  LOG.error("Skipping recover entry for metadata: "+metaData,e);
+                }
+                this.strategy = new RecoverStrategy();
+                metaData = null;
+                entryData = null;
+             continue;   
+            }
+            if(entryData == null){
+                entryData = input;
+            }
+            
+        }
+        
+        
+        
+        return actionList;
+        
+    }
+    
+    
+    
+    
+    
+  
+    
+    
+    private static  class RecoverStrategy{
+        private StorageOperation operation;
+        private ProvidedService config;
+        private String feedId;
+        private String entryId;
+        private long timestamp;
+        /**
+         * @param metaData
+         * @param entry
+         * @return
+         * @throws RecoverException
+         */
+        public StorageEntryWrapper recover(String metaData, String entry) throws RecoverException{
+                fillMetaData(metaData);
+                ServerBaseEntry retVal = null;
+                if(entry != null && this.operation == StorageOperation.DELETE)
+                    throw new RecoverException("Can not recover -- Delete operation has entry part");
+                if(entry != null)
+                    try {
+                        retVal = new ServerBaseEntry(buildEntry(entry,this.config));
+                    } catch (Exception e) {
+                        throw new RecoverException("Exception occured while building entry -- "+e.getMessage(),e);
+                    }
+                else
+                    retVal = new ServerBaseEntry();
+                retVal.setId(this.entryId);
+                retVal.setFeedId(this.feedId);
+                retVal.setServiceConfig(this.config);
+                
+           try{
+            return new StorageEntryWrapper(retVal,this.operation);
+           }catch (IOException e) {
+               throw new RecoverException("Can't create StorageWrapper -- "+e.getMessage(),e);
+        }
+        }
+        private void fillMetaData(String recoverString) throws RecoverException{
+            StringTokenizer tokenizer = new StringTokenizer(recoverString,RecoverWriter.META_DATA_SEPARATOR);
+            String temp = tokenizer.nextToken();
+            if(temp.equals("D"))
+                this.operation = StorageOperation.DELETE;
+            else if(temp.equals("U"))
+                this.operation = StorageOperation.UPDATE;
+            else if(temp.equals("I"))
+                this.operation = StorageOperation.INSERT;
+            else
+                throw new RecoverException("Illegal metadata --- "+recoverString);
+            temp = tokenizer.nextToken();
+            if(temp == null)
+                throw new RecoverException("Can't recover feed Id -- "+temp);
+            this.feedId = temp;
+            temp = tokenizer.nextToken();
+            if(temp == null)
+                throw new RecoverException("Can't recover entry Id -- "+temp);
+             this.entryId = temp;
+            
+            temp = tokenizer.nextToken();
+            try{
+                this.timestamp = Long.parseLong(temp);
+            }catch (Exception e) {
+                throw new RecoverException("Can't recover timestamp -- "+temp,e);
+            }
+            
+            if(this.operation != StorageOperation.DELETE){
+                temp = tokenizer.nextToken();
+                if(temp == null)
+                    throw new RecoverException("Can't recover service -- "+temp);  
+                if(!GDataServerRegistry.getRegistry().isServiceRegistered(temp))
+                    throw new RecoverException("Service in recover metadata is not registered  - "+temp);
+                this.config = GDataServerRegistry.getRegistry().getProvidedService(temp);
+                
+            }
+            
+        }
+        
+        private BaseEntry buildEntry(String entry, ProvidedService serviceConfig) throws ParseException, IOException{
+           StringReader reader = new StringReader(entry);
+           return GDataEntityBuilder.buildEntry(reader,serviceConfig);
+        }
+    }
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverWriter.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverWriter.java
new file mode 100644
index 0000000..2ec08a9
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverWriter.java
@@ -0,0 +1,104 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.storage.lucenestorage.recover;
+
+import java.io.IOException;
+import java.io.Writer;
+
+import org.apache.lucene.gdata.server.registry.ProvidedService;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper.StorageOperation;
+
+import com.google.gdata.data.BaseEntry;
+import com.google.gdata.util.common.xml.XmlWriter;
+
+/**
+ * Writes the recover objects to the hard disc.
+ * @author Simon Willnauer
+ *
+ */
+public class RecoverWriter {
+    protected static final String META_DATA_SEPARATOR = ";";
+    protected static final String META_DATA_ENTRY_SEPARATOR = System.getProperty("line.separator");
+    protected static final String STORAGE_OPERATION_SEPARATOR = "###########";
+    protected static final String OPERATION_DELETE = "D";
+    protected static final String OPERATION_UPDATE = "U";
+    protected static final String OPERATION_INSERT = "I";
+    protected static final String FILE_PREFIX = ".strg";
+   
+    
+    
+    /**
+     * @param wrapper 
+     * @throws IOException 
+     * 
+     * 
+     * 
+     */
+    public void writeEntry(StorageEntryWrapper wrapper,Writer writer)throws IOException{
+        
+        writeOperation(wrapper.getOperation(),writer);
+        writeFeedID(wrapper.getFeedId(),writer);
+        writeEntryID(wrapper.getEntryId(),writer);
+        writeTimeStamp(wrapper.getTimestamp().toString(),writer);
+        if(!wrapper.getOperation().equals(StorageOperation.DELETE)){
+        writeService(wrapper,writer);
+            writer.write(META_DATA_ENTRY_SEPARATOR);
+            BaseEntry entry = wrapper.getEntry();
+            XmlWriter xmlWriter = new XmlWriter(writer);
+            entry.generateAtom(xmlWriter,wrapper.getConfigurator().getExtensionProfile());
+        }
+        writer.write(META_DATA_ENTRY_SEPARATOR);
+        writer.write(STORAGE_OPERATION_SEPARATOR);
+        writer.write(META_DATA_ENTRY_SEPARATOR);
+    }
+
+   
+
+    private void writeTimeStamp(String timestamp, Writer writer) throws IOException{
+        writer.write(timestamp);
+        writer.write(META_DATA_SEPARATOR);
+    }
+    private void writeFeedID(String feedId,Writer writer) throws IOException{
+        writer.write(feedId);
+        writer.write(META_DATA_SEPARATOR);
+    }
+    private void writeEntryID(String entryId,Writer writer) throws IOException{
+        writer.write(entryId);
+        writer.write(META_DATA_SEPARATOR);
+    }
+    
+    private void writeService(StorageEntryWrapper wrapper, Writer writer) throws IOException{
+        ProvidedService config = wrapper.getConfigurator();
+        writer.write(config.getName());
+        writer.write(META_DATA_SEPARATOR);
+    }
+ 
+    private void writeOperation(StorageOperation operation, Writer writer) throws IOException{
+        if(operation.equals(StorageOperation.INSERT))
+            writer.write(OPERATION_INSERT);
+        else if (operation.equals(StorageOperation.UPDATE)) 
+            writer.write(OPERATION_UPDATE);
+        else if (operation.equals(StorageOperation.DELETE)) 
+            writer.write(OPERATION_DELETE);
+        writer.write(META_DATA_SEPARATOR);
+    }
+    
+    
+    
+
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/recover/package.html b/contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/recover/package.html
new file mode 100644
index 0000000..0ba6029
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/recover/package.html
@@ -0,0 +1,10 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
+<html> 
+<head> 
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
+   <meta name="Author" content="Simon Willnauer"> 
+</head> 
+<body> 
+Recovering component for the lucene storage
+</body> 
+</html> 
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/utils/DateFormater.java b/contrib/gdata-server/src/java/org/apache/lucene/gdata/utils/DateFormater.java
new file mode 100644
index 0000000..20778d0
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/utils/DateFormater.java
@@ -0,0 +1,125 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.utils;
+
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Stack;
+
+/**
+ * This class uses the {@link java.text.SimpleDateFormat} class to format dates
+ * into strings according to given date pattern.
+ * <p>
+ * As the creation of <tt>SimpleDateFormat</tt> objects is quiet expensive and
+ * formating dates is used quiet fequently the objects will be cached and reused
+ * in subsequent calls.
+ * </p>
+ * <p>
+ * This implementation is thread safe as it uses {@link java.util.Stack} as a
+ * cache
+ * </p>
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class DateFormater {
+    private final Stack<SimpleDateFormat> objectStack = new Stack<SimpleDateFormat>();
+
+    private static final DateFormater formater = new DateFormater();
+
+    /**
+     * Date format as it is used in Http Last modified header (Tue, 15 Nov 1994
+     * 12:45:26 GMT)
+     */
+    public static String HTTP_HEADER_DATE_FORMAT = "EEE, d MMM yyyy HH:mm:ss z";
+    /**
+     *  Date format as it is used in Http Last modified header (Tue, 15 Nov 1994
+     * 12:45:26 +0000)
+     */
+    public static String HTTP_HEADER_DATE_FORMAT_TIME_OFFSET = "EEE, d MMM yyyy HH:mm:ss Z";
+
+    private DateFormater() {
+        super();
+    }
+
+    /**
+     * Formats the given Date into the given date pattern.
+     * 
+     * @param date -
+     *            the date to format
+     * @param format -
+     *            date pattern
+     * @return - the string representation of the given <tt>Date</tt>
+     *         according to the given pattern
+     */
+    public static String formatDate(final Date date, String format) {
+        if (date == null || format == null)
+            throw new IllegalArgumentException(
+                    "given parameters must not be null");
+        SimpleDateFormat inst = formater.getFormater();
+        inst.applyPattern(format);
+        formater.returnFomater(inst);
+        return inst.format(date);
+    }
+    /**
+     * Parses the given string into one of the specified formates
+     * @param date - the string to parse
+     * @param formates - formates
+     * @return a {@link Date} instance representing the given string
+     * @throws ParseException - if the string can not be parsed
+     */
+    public static Date parseDate(final String date, final String...formates) throws ParseException{
+        for (int i = 0; i < formates.length; i++) {
+            try {
+             return parseDate(date,formates[i]);
+            } catch (ParseException e) {
+                //
+            }
+        }
+        throw new ParseException("Unparseable date: "+date,0);
+        
+    }
+    
+    /**
+     * Parses the given string into the specified formate
+     * @param dateString - the string to parse
+     * @param pattern - the expected formate
+     * @return a {@link Date} instance representing the given string
+     * @throws ParseException - if the string can not be parsed
+     */
+    public static Date parseDate(final String dateString,String pattern) throws ParseException{
+        if(dateString == null|| pattern == null)
+            throw new IllegalArgumentException(
+            "given parameters must not be null");
+        SimpleDateFormat inst = formater.getFormater();
+        inst.applyPattern(pattern);
+        return inst.parse(dateString);
+    }
+
+    private SimpleDateFormat getFormater() {
+        if (this.objectStack.empty())
+            return new SimpleDateFormat();
+        return this.objectStack.pop();
+    }
+
+    private void returnFomater(final SimpleDateFormat format) {
+        if (this.objectStack.size() <= 25)
+            this.objectStack.push(format);
+    }
+
+}
diff --git a/contrib/gdata-server/src/java/org/apache/lucene/gdata/utils/package.html b/contrib/gdata-server/src/java/org/apache/lucene/gdata/utils/package.html
new file mode 100644
index 0000000..9e0201c
--- /dev/null
+++ b/contrib/gdata-server/src/java/org/apache/lucene/gdata/utils/package.html
@@ -0,0 +1,10 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
+<html> 
+<head> 
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
+   <meta name="Author" content="Simon Willnauer"> 
+</head> 
+<body> 
+Utils package
+</body> 
+</html> 
diff --git a/contrib/gdata-server/src/test/gdata-config.xml b/contrib/gdata-server/src/test/gdata-config.xml
new file mode 100644
index 0000000..59ac2f6
--- /dev/null
+++ b/contrib/gdata-server/src/test/gdata-config.xml
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<gdata>
+	<service name="feed" public="true">
+		<feed-class>com.google.gdata.data.Feed</feed-class>
+		<entry-class>com.google.gdata.data.Entry</entry-class>
+		<extension-profile>
+			com.google.gdata.data.ExtensionProfile
+		</extension-profile>
+	</service>
+	<service name="calendar" public="true">
+		<feed-class>
+			com.google.gdata.data.extensions.EventFeed
+		</feed-class>
+		<entry-class>
+			com.google.gdata.data.extensions.EventEntry
+		</entry-class>
+		<extension-profile>
+			com.google.gdata.data.ExtensionProfile
+		</extension-profile>
+	</service>
+	<server-components>
+		<component>
+			org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController
+		</component>
+		<component>
+			org.apache.lucene.gdata.servlet.handler.DefaultRequestHandlerFactory
+		</component>
+		<component>
+			org.apache.lucene.gdata.server.ServiceFactory
+		</component>
+		<component>
+			org.apache.lucene.gdata.server.authentication.BlowfishAuthenticationController
+		</component>
+	</server-components>
+</gdata>
\ No newline at end of file
diff --git a/contrib/gdata-server/src/test/lucenestorage.properties.xml b/contrib/gdata-server/src/test/lucenestorage.properties.xml
new file mode 100644
index 0000000..a86d83c
--- /dev/null
+++ b/contrib/gdata-server/src/test/lucenestorage.properties.xml
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">
+<properties>
+<comment>Lucene Storage Properties</comment>
+<entry key="gdata.server.storage.lucene.buffersize">20</entry>
+<entry key="gdata.server.storage.lucene.optimizeInterval">20</entry>
+<entry key="gdata.server.storage.lucene.persistFactor">20</entry>
+<entry key="gdata.server.storage.lucene.directory.ramDirectory">true</entry>
+<entry key="gdata.server.storage.lucene.directory">/tmp/storage/</entry>
+<entry key="gdata.server.storage.lucene.recover">true</entry>
+<entry key="gdata.server.storage.lucene.recover.keepFiles">false</entry>
+</properties>
diff --git a/contrib/gdata-server/src/test/org/apache/lucene/gdata/data/TestGDataUser.java b/contrib/gdata-server/src/test/org/apache/lucene/gdata/data/TestGDataUser.java
new file mode 100644
index 0000000..f5817dd
--- /dev/null
+++ b/contrib/gdata-server/src/test/org/apache/lucene/gdata/data/TestGDataUser.java
@@ -0,0 +1,65 @@
+package org.apache.lucene.gdata.data;
+
+import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
+
+import junit.framework.TestCase;
+
+public class TestGDataUser extends TestCase {
+    private GDataAccount user;
+    @Override
+    protected void setUp() throws Exception {
+        this.user = new GDataAccount();
+        this.user.setName("simon");
+        super.setUp();
+    }
+
+    @Override
+    protected void tearDown() throws Exception {
+        
+        super.tearDown();
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.data.GDataUser.isUserInRole(UserRole)'
+     */
+    public void testIsUserInRole() {
+        assertTrue(this.user.isUserInRole(AccountRole.USER));
+        assertFalse(this.user.isUserInRole(AccountRole.ENTRYAMINISTRATOR));
+        this.user.setRole(AccountRole.ENTRYAMINISTRATOR);
+        assertTrue(this.user.isUserInRole(AccountRole.ENTRYAMINISTRATOR));
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.data.GDataUser.getRolesAsInt()'
+     */
+    public void testGetRolesAsInt() {
+        assertEquals(1,this.user.getRolesAsInt());
+        this.user.setRole(AccountRole.ENTRYAMINISTRATOR);
+        assertEquals(3,this.user.getRolesAsInt());
+        this.user.setRole(AccountRole.FEEDAMINISTRATOR);
+        assertEquals(7,this.user.getRolesAsInt());
+        this.user.setRole(AccountRole.USERADMINISTRATOR);
+        assertEquals(15,this.user.getRolesAsInt());
+        
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.data.GDataUser.setRolesAsInt(int)'
+     */
+    public void testSetRolesAsInt() {
+        this.user.setRolesAsInt(2);
+        this.user.setRolesAsInt(4);
+        this.user.setRolesAsInt(8);
+        assertEquals(4,this.user.getRoles().size()); 
+        this.user.setRolesAsInt(15);
+        assertEquals(4,this.user.getRoles().size());
+        this.user = new GDataAccount();
+        this.user.setName("simon");
+        this.user.setRolesAsInt(15);
+        assertEquals(4,this.user.getRoles().size());
+        
+    }
+    
+    
+
+}
diff --git a/contrib/gdata-server/src/test/org/apache/lucene/gdata/server/administration/TestAccountBuilder.java b/contrib/gdata-server/src/test/org/apache/lucene/gdata/server/administration/TestAccountBuilder.java
new file mode 100644
index 0000000..10273c2
--- /dev/null
+++ b/contrib/gdata-server/src/test/org/apache/lucene/gdata/server/administration/TestAccountBuilder.java
@@ -0,0 +1,54 @@
+package org.apache.lucene.gdata.server.administration;
+
+import java.io.IOException;
+import java.io.StringReader;
+import java.net.URL;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
+import org.xml.sax.SAXException;
+
+public class TestAccountBuilder extends TestCase {
+    private StringReader reader;
+    private String inputXML;
+    protected void setUp() throws Exception {
+        this.inputXML = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" +
+                "<account>" +
+                "<account-name>simon</account-name>" +
+                "<password>simon</password>" +
+                "<account-role>6</account-role>" +
+                "<account-owner>" +
+                "<name>simon willnauer</name>" +
+                "<email-address>simon@gmail.com</email-address>" +
+                "<url>http://www.javawithchopsticks.de</url>" +
+                "</account-owner>" +
+                "</account>";
+
+        this.reader = new StringReader(this.inputXML);
+        
+    }
+
+    protected void tearDown() throws Exception {
+        super.tearDown();
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.server.administration.AdminEntityBuilder.buildUser(Reader)'
+     */
+    public void testBuildUser() throws IOException, SAXException {
+        
+        GDataAccount user = AccountBuilder.buildAccount(this.reader);
+        assertEquals("simon",user.getName());
+        assertEquals("simon willnauer",user.getAuthorname());
+        assertEquals("simon@gmail.com",user.getAuthorMail());
+        assertEquals("simon",user.getPassword());
+        assertEquals(new URL("http://www.javawithchopsticks.de"),user.getAuthorLink());
+        assertTrue(user.isUserInRole(AccountRole.ENTRYAMINISTRATOR));
+        assertTrue(user.isUserInRole(AccountRole.FEEDAMINISTRATOR));
+        assertFalse(user.isUserInRole(AccountRole.USERADMINISTRATOR));
+        
+    }
+
+}
diff --git a/contrib/gdata-server/src/test/org/apache/lucene/gdata/server/authentication/TestBlowfishAuthenticationController.java b/contrib/gdata-server/src/test/org/apache/lucene/gdata/server/authentication/TestBlowfishAuthenticationController.java
new file mode 100644
index 0000000..4f855d0
--- /dev/null
+++ b/contrib/gdata-server/src/test/org/apache/lucene/gdata/server/authentication/TestBlowfishAuthenticationController.java
@@ -0,0 +1,94 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.server.authentication;
+
+import java.io.IOException;
+import java.io.UnsupportedEncodingException;
+
+import javax.crypto.BadPaddingException;
+import javax.crypto.IllegalBlockSizeException;
+
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
+
+import junit.framework.TestCase;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class TestBlowfishAuthenticationController extends TestCase {
+    private BlowfishAuthenticationController controller;
+    private String key = "myKey";
+    private String accountName = "simon";
+    
+    private String clientIp = "192.168.0.127";
+    protected void setUp() throws Exception {
+        this.controller = new BlowfishAuthenticationController();
+        this.controller.setKey(this.key);
+        
+        this.controller.initialize();
+    }
+
+    protected void tearDown() throws Exception {
+        super.tearDown();
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.server.authentication.AuthenticationController.authenticatAccount(HttpServletRequest)'
+     */
+    public void testAuthenticatAccount() throws IllegalBlockSizeException, BadPaddingException, AuthenticationException, IOException {
+        GDataAccount account = new GDataAccount();
+        account.setName(accountName);
+        account.setPassword("testme");
+        account.setRole(AccountRole.ENTRYAMINISTRATOR);
+        
+        String token = this.controller.authenticatAccount(account,this.clientIp);
+        String notSame = this.controller.calculateAuthToken("192.168.0",Integer.toString(account.getRolesAsInt()),this.accountName);
+        assertNotSame(notSame,token);
+        String authString = "192.168.0#"+this.accountName +"#"+account.getRolesAsInt()+"#";
+        assertTrue(this.controller.deCryptAuthToken(token).startsWith(authString));
+        assertTrue(this.controller.deCryptAuthToken(notSame).startsWith(authString));
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.server.authentication.AuthenticationController.authenticateToken(String)'
+     */
+    public void testAuthenticateToken() throws IllegalBlockSizeException, BadPaddingException, UnsupportedEncodingException, AuthenticationException {
+        GDataAccount account = new GDataAccount();
+        account.setName("simon");
+        account.setPassword("testme");
+        account.setRole(AccountRole.ENTRYAMINISTRATOR);
+        String token = this.controller.calculateAuthToken("192.168.0",Integer.toString(account.getRolesAsInt()),this.accountName);
+        
+        assertTrue(this.controller.authenticateToken(token,this.clientIp,AccountRole.ENTRYAMINISTRATOR,this.accountName));
+        assertTrue(this.controller.authenticateToken(token,this.clientIp,AccountRole.USER,this.accountName));
+        assertFalse(this.controller.authenticateToken(token,this.clientIp,AccountRole.USERADMINISTRATOR,"someOtherAccount"));
+        try{
+        this.controller.authenticateToken(token+"test",this.clientIp,AccountRole.ENTRYAMINISTRATOR,this.accountName);
+        fail("exception expected");
+        }catch (Exception e) {
+            // TODO: handle exception
+        }
+        this.controller.setMinuteOffset(0);
+        assertFalse(this.controller.authenticateToken(token,this.clientIp,AccountRole.ENTRYAMINISTRATOR,this.accountName));
+        
+    }
+
+    
+
+}
diff --git a/contrib/gdata-server/src/test/org/apache/lucene/gdata/servlet/handler/TestAbstractFeedHandler.java b/contrib/gdata-server/src/test/org/apache/lucene/gdata/servlet/handler/TestAbstractFeedHandler.java
new file mode 100644
index 0000000..2d00eea
--- /dev/null
+++ b/contrib/gdata-server/src/test/org/apache/lucene/gdata/servlet/handler/TestAbstractFeedHandler.java
@@ -0,0 +1,213 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.servlet.handler;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileReader;
+import java.io.IOException;
+
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.data.ServerBaseFeed;
+import org.apache.lucene.gdata.server.ServiceException;
+import org.apache.lucene.gdata.server.ServiceFactory;
+import org.apache.lucene.gdata.server.administration.AdminService;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
+import org.apache.lucene.gdata.server.registry.RegistryException;
+import org.apache.lucene.gdata.servlet.handler.AbstractFeedHandler.FeedHandlerException;
+import org.apache.lucene.gdata.utils.ProvidedServiceStub;
+import org.apache.lucene.gdata.utils.ServiceFactoryStub;
+import org.apache.lucene.gdata.utils.StorageStub;
+import org.easymock.MockControl;
+
+import com.google.gdata.util.ParseException;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class TestAbstractFeedHandler extends TestCase {
+    private MockControl requestMockControl; 
+    
+    private HttpServletRequest mockRequest = null; 
+    
+    private String accountName = "acc"; 
+    private MockControl adminServiceMockControl;
+    private AdminService adminService = null;
+    private ServiceFactoryStub stub;
+    private String serviceName = StorageStub.SERVICE_TYPE_RETURN;
+    private static File incomingFeed = new File("src/test/org/apache/lucene/gdata/server/registry/TestEntityBuilderIncomingFeed.xml");
+    BufferedReader reader;
+    static{
+        
+        try {
+            
+            GDataServerRegistry.getRegistry().registerComponent(StorageStub.class);
+            GDataServerRegistry.getRegistry().registerComponent(ServiceFactoryStub.class);
+        } catch (RegistryException e) {
+            
+            e.printStackTrace();
+        }
+    }
+    protected void setUp() throws Exception {
+        super.setUp();
+        
+        GDataServerRegistry.getRegistry().registerService(new ProvidedServiceStub());
+       this.requestMockControl = MockControl.createControl(HttpServletRequest.class);
+       this.adminServiceMockControl = MockControl.createControl(AdminService.class);
+       this.adminService = (AdminService)this.adminServiceMockControl.getMock();
+       this.mockRequest = (HttpServletRequest)this.requestMockControl.getMock();
+       this.stub = (ServiceFactoryStub)GDataServerRegistry.getRegistry().lookup(ServiceFactory.class,ComponentType.SERVICEFACTORY);
+       this.stub.setAdminService(this.adminService);
+       this.reader =  new BufferedReader(new FileReader(incomingFeed));
+    }
+
+    protected void tearDown() throws Exception {
+        super.tearDown();
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.servlet.handler.AbstractFeedHandler.createFeedFromRequest(HttpServletRequest)'
+     */
+    public void testCreateFeedFromRequest() throws ParseException, IOException, FeedHandlerException {
+        
+        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
+                .getParameter("service"), this.serviceName);
+        this.requestMockControl.expectAndReturn(this.mockRequest.getReader(),this.reader);
+        this.requestMockControl.replay();
+        AbstractFeedHandler handler = new InsertFeedHandler();
+        try{
+        ServerBaseFeed feed = handler.createFeedFromRequest(this.mockRequest);
+        assertNotNull(feed.getId());
+        
+        }catch (Exception e) {
+            e.printStackTrace();
+            fail("unexpected exception -- "+e.getMessage());
+            
+        }
+        this.requestMockControl.verify();
+        this.requestMockControl.reset();
+        /*
+         * Test for not registered service
+         */
+        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
+                .getParameter("service"), "some other service");
+        this.requestMockControl.replay();
+         handler = new InsertFeedHandler();
+        try{
+        ServerBaseFeed feed = handler.createFeedFromRequest(this.mockRequest);
+        
+        fail(" exception expected");
+        }catch (FeedHandlerException e) {
+            e.printStackTrace();
+            assertEquals(HttpServletResponse.SC_NOT_FOUND,handler.getErrorCode());
+        }
+        this.requestMockControl.verify();
+        
+        this.requestMockControl.reset();
+        /*
+         * Test for IOException
+         */
+        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
+                .getParameter("service"), this.serviceName);
+        this.reader.close();
+        this.requestMockControl.expectAndReturn(this.mockRequest.getReader(),this.reader);
+        this.requestMockControl.replay();
+         handler = new InsertFeedHandler();
+        try{
+        ServerBaseFeed feed = handler.createFeedFromRequest(this.mockRequest);
+        
+        fail(" exception expected");
+        }catch (IOException e) {
+            e.printStackTrace();
+            assertEquals(HttpServletResponse.SC_BAD_REQUEST,handler.getErrorCode());
+        }
+        this.requestMockControl.verify();
+        
+        
+        
+        
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.servlet.handler.AbstractFeedHandler.createRequestedAccount(HttpServletRequest)'
+     */
+    public void testCreateRequestedAccount() throws IOException, ParseException, ServiceException {
+        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
+                .getParameter(AbstractFeedHandler.PARAMETER_ACCOUNT), this.accountName);
+        GDataAccount a = new GDataAccount();
+        a.setName("helloworld");
+        this.adminServiceMockControl.expectAndReturn(this.adminService.getAccount(this.accountName),a );
+        this.requestMockControl.replay();
+        this.adminServiceMockControl.replay();
+        AbstractFeedHandler handler = new InsertFeedHandler();
+        try{
+            
+            GDataAccount account = handler.createRequestedAccount(this.mockRequest);
+       
+        assertEquals(a,account);
+        
+        }catch (Exception e) {
+            e.printStackTrace();
+            fail("unexpected exception -- "+e.getMessage());
+            
+        }
+        this.requestMockControl.verify();
+        this.requestMockControl.reset();
+        this.adminServiceMockControl.verify();
+        this.adminServiceMockControl.reset();
+        
+        /*
+         *Test for service exception 
+         */
+        
+        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
+                .getParameter(AbstractFeedHandler.PARAMETER_ACCOUNT), this.accountName);
+        
+        a.setName("helloworld");
+        this.adminServiceMockControl.expectAndDefaultThrow(this.adminService.getAccount(this.accountName),new ServiceException() );
+        this.requestMockControl.replay();
+        this.adminServiceMockControl.replay();
+         handler = new InsertFeedHandler();
+        try{
+            
+            GDataAccount account = handler.createRequestedAccount(this.mockRequest);
+       
+            fail(" exception expected ");
+        
+        }catch (Exception e) {
+            e.printStackTrace();
+            assertEquals(HttpServletResponse.SC_BAD_REQUEST,handler.getErrorCode());
+            
+        }
+        this.requestMockControl.verify();
+        this.requestMockControl.reset();
+        this.adminServiceMockControl.verify();
+        this.adminServiceMockControl.reset();
+        
+        
+        
+        
+        
+    }
+
+}
diff --git a/contrib/gdata-server/src/test/org/apache/lucene/gdata/servlet/handler/TestRequestAuthenticator.java b/contrib/gdata-server/src/test/org/apache/lucene/gdata/servlet/handler/TestRequestAuthenticator.java
new file mode 100644
index 0000000..1a780ea
--- /dev/null
+++ b/contrib/gdata-server/src/test/org/apache/lucene/gdata/servlet/handler/TestRequestAuthenticator.java
@@ -0,0 +1,79 @@
+package org.apache.lucene.gdata.servlet.handler;
+
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServletRequest;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.gdata.server.authentication.AuthenticationController;
+import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
+import org.easymock.MockControl;
+
+public class TestRequestAuthenticator extends TestCase {
+    private MockControl requestMock;
+    private HttpServletRequest request;
+    private RequestAuthenticator authenticator;
+    private String tokenHeader;
+    private String token;
+    private Cookie authCookie;
+    
+    protected void setUp() throws Exception {
+    createMocks();
+    this.authenticator = new RequestAuthenticator();
+    this.token = "myToken";
+    this.tokenHeader = "GoogleLogin auth="+this.token;
+    this.authCookie = new Cookie("Auth",this.token);
+    }
+    protected void createMocks() {
+        this.requestMock = MockControl.createControl(HttpServletRequest.class);
+        this.request = (HttpServletRequest)this.requestMock.getMock();
+        
+    }
+    protected void tearDown() throws Exception {
+        GDataServerRegistry.getRegistry().destroy();
+    }
+    /*
+     * Test method for 'org.apache.lucene.gdata.servlet.handler.RequestAuthenticator.authenticateAccount(GDataRequest, AccountRole)'
+     */
+    public void testGetTokenFromRequest() {
+        // test token present
+        this.requestMock.expectAndDefaultReturn(this.request.getHeader(AuthenticationController.AUTHORIZATION_HEADER), this.tokenHeader);
+        this.requestMock.replay();
+        assertEquals(this.token,this.authenticator.getTokenFromRequest(this.request));
+        this.requestMock.verify();
+        this.requestMock.reset();
+        
+        // test token null / cookie present
+        this.requestMock.expectAndDefaultReturn(this.request.getHeader(AuthenticationController.AUTHORIZATION_HEADER), null);
+        this.requestMock.expectAndDefaultReturn(this.request.getCookies(), new Cookie[]{this.authCookie});
+        this.requestMock.replay();
+        assertEquals(this.token,this.authenticator.getTokenFromRequest(this.request));
+        this.requestMock.verify();
+        this.requestMock.reset();
+        
+        // test token null / cookie not present
+        this.requestMock.expectAndDefaultReturn(this.request.getHeader(AuthenticationController.AUTHORIZATION_HEADER), null);
+        this.requestMock.expectAndDefaultReturn(this.request.getCookies(), new Cookie[]{new Cookie("somekey","someValue")});
+        this.requestMock.replay();
+        assertNull(this.authenticator.getTokenFromRequest(this.request));
+        this.requestMock.verify();
+        this.requestMock.reset();
+        
+//      test token null / cookie array emtpy 
+        this.requestMock.expectAndDefaultReturn(this.request.getHeader(AuthenticationController.AUTHORIZATION_HEADER), null);
+        this.requestMock.expectAndDefaultReturn(this.request.getCookies(), new Cookie[]{});
+        this.requestMock.replay();
+        assertNull(this.authenticator.getTokenFromRequest(this.request));
+        this.requestMock.verify();
+        this.requestMock.reset();
+        
+//      test token null / cookie array null
+        this.requestMock.expectAndDefaultReturn(this.request.getHeader(AuthenticationController.AUTHORIZATION_HEADER), null);
+        this.requestMock.expectAndDefaultReturn(this.request.getCookies(), null);
+        this.requestMock.replay();
+        assertNull(this.authenticator.getTokenFromRequest(this.request));
+        this.requestMock.verify();
+        this.requestMock.reset();
+    }
+
+}
diff --git a/contrib/gdata-server/src/test/org/apache/lucene/gdata/storage/lucenestorage/StorageModifierStub.java b/contrib/gdata-server/src/test/org/apache/lucene/gdata/storage/lucenestorage/StorageModifierStub.java
new file mode 100644
index 0000000..298c6e3
--- /dev/null
+++ b/contrib/gdata-server/src/test/org/apache/lucene/gdata/storage/lucenestorage/StorageModifierStub.java
@@ -0,0 +1,153 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.storage.lucenestorage;
+
+import java.io.IOException;
+
+import org.apache.lucene.analysis.standard.StandardAnalyzer;
+import org.apache.lucene.gdata.storage.StorageException;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageBuffer;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageModifier;
+import org.apache.lucene.gdata.utils.StorageControllerStub;
+import org.apache.lucene.index.IndexModifier;
+import org.apache.lucene.store.RAMDirectory;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class StorageModifierStub extends StorageModifier {
+
+    /**
+     * @param controller
+     * @param modifier
+     * @param buffer
+     * @param persitsFactor
+     * @param optimizeInterval
+     * @throws IOException 
+     * @throws StorageException 
+     */
+    public StorageModifierStub(StorageCoreController controller,
+            IndexModifier modifier, StorageBuffer buffer, int persitsFactor,
+            int optimizeInterval) throws IOException, StorageException {
+        
+        super(new StorageCoreController(), new IndexModifier(new RAMDirectory(),new StandardAnalyzer(),true), new StorageBuffer(1),1, 1);
+        
+        // TODO Auto-generated constructor stub
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier#close()
+     */
+    @Override
+    protected void close() throws IOException {
+        
+        
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier#createAccount(org.apache.lucene.gdata.storage.lucenestorage.StorageAccountWrapper)
+     */
+    @Override
+    public void createAccount(StorageAccountWrapper account) throws StorageException {
+        
+        
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier#createFeed(org.apache.lucene.gdata.storage.lucenestorage.StorageFeedWrapper)
+     */
+    @Override
+    public void createFeed(StorageFeedWrapper wrapper) throws StorageException {
+        
+        
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier#deleteAccount(java.lang.String)
+     */
+    @Override
+    public void deleteAccount(String accountName) throws StorageException {
+        
+        
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier#deleteEntry(org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper)
+     */
+    @Override
+    public void deleteEntry(StorageEntryWrapper wrapper) throws StorageException {
+        
+        
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier#deleteFeed(java.lang.String)
+     */
+    @Override
+    public void deleteFeed(String feedId) throws StorageException {
+        
+        
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier#forceWrite()
+     */
+    @Override
+    protected void forceWrite() throws IOException {
+        
+        
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier#insertEntry(org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper)
+     */
+    @Override
+    public void insertEntry(StorageEntryWrapper wrapper) throws StorageException {
+        
+        
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier#updateAccount(org.apache.lucene.gdata.storage.lucenestorage.StorageAccountWrapper)
+     */
+    @Override
+    public void updateAccount(StorageAccountWrapper user) throws StorageException {
+        
+        
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier#updateEntry(org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper)
+     */
+    @Override
+    public void updateEntry(StorageEntryWrapper wrapper) throws StorageException {
+        
+        
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier#updateFeed(org.apache.lucene.gdata.storage.lucenestorage.StorageFeedWrapper)
+     */
+    @Override
+    public void updateFeed(StorageFeedWrapper wrapper) throws StorageException {
+        
+        
+    }
+
+}
diff --git a/contrib/gdata-server/src/test/org/apache/lucene/gdata/storage/lucenestorage/recover/TestRecoverController.java b/contrib/gdata-server/src/test/org/apache/lucene/gdata/storage/lucenestorage/recover/TestRecoverController.java
new file mode 100644
index 0000000..9dc667f
--- /dev/null
+++ b/contrib/gdata-server/src/test/org/apache/lucene/gdata/storage/lucenestorage/recover/TestRecoverController.java
@@ -0,0 +1,105 @@
+package org.apache.lucene.gdata.storage.lucenestorage.recover;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.rmi.registry.Registry;
+
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
+import org.apache.lucene.gdata.storage.StorageException;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageModifier;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageModifierStub;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper.StorageOperation;
+import org.apache.lucene.gdata.utils.ProvidedServiceStub;
+import org.easymock.MockControl;
+
+import com.google.gdata.data.DateTime;
+
+import junit.framework.TestCase;
+
+public class TestRecoverController extends TestCase {
+    private RecoverController writeController;
+    private RecoverController readController;
+    private File recDir = new File("./temp/");
+    private String feedId = "feedid";
+    private String entryId = "entryId";
+    
+    protected void setUp() throws Exception {
+        if(!this.recDir.exists())
+            this.recDir.mkdir();
+        GDataServerRegistry.getRegistry().registerService(new ProvidedServiceStub());
+        this.writeController = new RecoverController(this.recDir,false,false);
+        this.readController = new RecoverController(this.recDir,true,false);
+        
+        
+
+        
+    }
+
+    protected void tearDown() throws Exception {
+        
+        
+        
+        File[] files = this.recDir.listFiles();
+        for (int i = 0; i < files.length; i++) {
+            files[i].delete();
+        }
+        this.recDir.delete();
+      GDataServerRegistry.getRegistry().destroy();
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.recover.RecoverController.storageModified(StorageEntryWrapper)'
+     */
+    public void testStorageModified() throws IOException, RecoverException {
+        this.writeController.initialize();
+        ServerBaseEntry entry = new ServerBaseEntry();
+        entry.setFeedId(this.feedId);
+        entry.setId(entryId);
+        entry.setUpdated(DateTime.now());
+        entry.setServiceConfig(new ProvidedServiceStub());
+        StorageEntryWrapper wrapper = new StorageEntryWrapper(entry,StorageOperation.INSERT);
+        this.writeController.storageModified(wrapper);
+        assertEquals(1,this.recDir.listFiles().length);
+        this.writeController.destroy();
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.recover.RecoverController.recoverEntries(StorageModifier)'
+     */
+    public void testRecoverEntries() throws IOException, StorageException, RecoverException {
+        testStorageModified();
+        
+        int length = this.recDir.listFiles().length;
+        assertEquals(1,length);
+        
+        this.readController.initialize();
+        try{
+        this.readController.recoverEntries(new StorageModifierStub(null,null,null,0,0));
+        }catch (Exception e) {
+            fail("unexpected exception"+e.getMessage());
+        }
+        this.readController.destroy();
+        assertEquals(0,this.recDir.listFiles().length);
+        assertNotSame(length,this.recDir.listFiles().length);
+        createCorruptedFile();
+        this.readController.initialize();
+        try{
+        this.readController.recoverEntries(new StorageModifierStub(null,null,null,0,0));
+        }catch (Exception e) {
+            fail("unexpected exception"+e.getMessage());
+        }
+        this.readController.destroy();
+        assertEquals(1,this.recDir.listFiles().length);
+    }
+    
+    
+    private void createCorruptedFile() throws IOException{
+        FileWriter writer = new FileWriter(new File(this.recDir,"somefile.rec"));
+        writer.write("someString\nSomeOtherString");
+        writer.close();
+    }
+
+}
diff --git a/contrib/gdata-server/src/test/org/apache/lucene/gdata/storage/lucenestorage/recover/TestRecoverWriter.java b/contrib/gdata-server/src/test/org/apache/lucene/gdata/storage/lucenestorage/recover/TestRecoverWriter.java
new file mode 100644
index 0000000..26053f2
--- /dev/null
+++ b/contrib/gdata-server/src/test/org/apache/lucene/gdata/storage/lucenestorage/recover/TestRecoverWriter.java
@@ -0,0 +1,75 @@
+package org.apache.lucene.gdata.storage.lucenestorage.recover;
+
+import java.io.IOException;
+import java.io.StringWriter;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.server.registry.ProvidedService;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper.StorageOperation;
+import org.apache.lucene.gdata.utils.ProvidedServiceStub;
+
+import com.google.gdata.data.DateTime;
+import com.google.gdata.data.Entry;
+import com.google.gdata.data.PlainTextConstruct;
+
+public class TestRecoverWriter extends TestCase {
+    private static final String ENTRYID = "myID";
+    private static final String TITLE = "title";
+    private static final String FEEDID = "myFeed";
+    
+    private static final Long TIMESTAMP = 132326657L;
+    private DateTime dateTime = new DateTime(TIMESTAMP,0);
+    String compareEntry = "I;"+FEEDID+";"+ENTRYID+";"+TIMESTAMP+";" +ProvidedServiceStub.SERVICE_NAME+";"+RecoverWriter.META_DATA_ENTRY_SEPARATOR+
+            "<atom:entry xmlns:atom='http://www.w3.org/2005/Atom'><atom:id>"+ENTRYID+"</atom:id><atom:updated>"+this.dateTime.toString()+"</atom:updated><atom:title type='text'>" + TITLE+
+            "</atom:title></atom:entry>"+RecoverWriter.META_DATA_ENTRY_SEPARATOR+RecoverWriter.STORAGE_OPERATION_SEPARATOR+RecoverWriter.META_DATA_ENTRY_SEPARATOR;
+    String compareDelete = "D;"+FEEDID+";"+ENTRYID+";"+TIMESTAMP+";"+RecoverWriter.META_DATA_ENTRY_SEPARATOR+RecoverWriter.STORAGE_OPERATION_SEPARATOR+RecoverWriter.META_DATA_ENTRY_SEPARATOR;
+    StorageEntryWrapper wrapper;
+    StorageEntryWrapper deleteWrapper;
+
+    protected void setUp() throws Exception {
+        ServerBaseEntry entry = new ServerBaseEntry(new Entry());
+        entry.setId(ENTRYID);
+        
+        entry.setUpdated(new DateTime(TIMESTAMP,0));
+        entry.setTitle(new PlainTextConstruct(TITLE));
+        ProvidedService config = new ProvidedServiceStub();
+        entry.setFeedId(FEEDID);
+        entry.setServiceConfig(config);
+        this.wrapper = new StorageEntryWrapper(entry,StorageOperation.INSERT);
+        this.deleteWrapper = new StorageEntryWrapper(entry,StorageOperation.DELETE);
+        
+        
+    }
+
+    protected void tearDown() throws Exception {
+        super.tearDown();
+        
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.recover.RecoverWriter.writeEntry(StorageEntryWrapper, Writer)'
+     */
+    public void testWriteEntry() throws IOException {
+        RecoverWriter wr = new RecoverWriter();
+        StringWriter writer = new StringWriter();
+        wr.writeEntry(this.wrapper,writer);
+        assertEquals(compareEntry,writer.toString());
+        writer.close();
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.recover.RecoverWriter.writeDelete(String, String, Writer)'
+     */
+    public void testWriteDelete() throws IOException {
+        RecoverWriter wr = new RecoverWriter();
+        StringWriter writer = new StringWriter();
+        wr.writeEntry(this.deleteWrapper,writer);
+        System.out.println(writer.toString());
+        assertEquals(compareDelete,writer.toString());
+        writer.close();
+    }
+
+}
diff --git a/contrib/gdata-server/src/test/org/apache/lucene/gdata/storage/lucenestorage/recover/TestRevocerReader.java b/contrib/gdata-server/src/test/org/apache/lucene/gdata/storage/lucenestorage/recover/TestRevocerReader.java
new file mode 100644
index 0000000..44e0996
--- /dev/null
+++ b/contrib/gdata-server/src/test/org/apache/lucene/gdata/storage/lucenestorage/recover/TestRevocerReader.java
@@ -0,0 +1,82 @@
+package org.apache.lucene.gdata.storage.lucenestorage.recover;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.StringReader;
+import java.util.List;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
+import org.apache.lucene.gdata.server.registry.ProvidedService;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper.StorageOperation;
+import org.apache.lucene.gdata.utils.ProvidedServiceStub;
+
+import com.google.gdata.data.DateTime;
+
+public class TestRevocerReader extends TestCase {
+    private RecoverReader recReader;
+    private static final String feedId = "myFeed";
+    private static final String entryId = "myID";
+    private static final Long timestamp = System.currentTimeMillis();
+    private String title = "myTitle";
+    private static final DateTime dateTime = DateTime.now();
+    private String delete = "D;"+feedId+";"+entryId+";"+timestamp+";\n###########\n";
+    private String insert = "I;"+feedId+";"+entryId+";"+timestamp+";" +ProvidedServiceStub.SERVICE_NAME+";"+RecoverWriter.META_DATA_ENTRY_SEPARATOR+
+    "<atom:entry xmlns:atom='http://www.w3.org/2005/Atom'><atom:id>"+entryId+"</atom:id><atom:updated>"+dateTime.toString()+"</atom:updated><atom:title type='text'>" + this.title+
+    "</atom:title></atom:entry>"+RecoverWriter.META_DATA_ENTRY_SEPARATOR+RecoverWriter.STORAGE_OPERATION_SEPARATOR+RecoverWriter.META_DATA_ENTRY_SEPARATOR;
+    protected void setUp() throws Exception {
+        this.recReader = new RecoverReader();
+        GDataServerRegistry.getRegistry().registerService(new ProvidedServiceStub());
+        
+    }
+
+    protected void tearDown() throws Exception {
+        super.tearDown();
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.recover.RecoverReader.getNonDeleteEntries(Reader)'
+     */
+    public void testRecoverDeletedEntries() throws IOException {
+        StringReader reader = new StringReader(this.delete);
+        assertNotNull(this.recReader.recoverEntries(new BufferedReader(reader)));
+        reader = new StringReader(this.delete);
+        List<StorageEntryWrapper> recList = this.recReader.recoverEntries(new BufferedReader(reader));
+        assertEquals(1,recList.size());
+        StorageEntryWrapper delWrapper = recList.get(0);
+        assertEquals(StorageOperation.DELETE,delWrapper.getOperation());
+        assertEquals(feedId,delWrapper.getFeedId());
+        assertEquals(entryId,delWrapper.getEntryId());
+        
+    }
+    public void testRecoverInsertedEntries() throws IOException {
+        
+        StringReader reader = new StringReader(this.insert);
+        List<StorageEntryWrapper> recList = this.recReader.recoverEntries(new BufferedReader(reader));
+        assertEquals(1,recList.size());
+        StorageEntryWrapper insWrapper = recList.get(0);
+        assertEquals(StorageOperation.INSERT,insWrapper.getOperation());
+        assertEquals(feedId,insWrapper.getFeedId());
+        assertEquals(entryId,insWrapper.getEntryId());
+        assertEquals(dateTime,insWrapper.getEntry().getUpdated());
+        assertEquals(this.title,insWrapper.getEntry().getTitle().getPlainText());
+        
+        
+    }
+    
+    public void testRecoverReader()throws IOException{
+        StringReader reader = new StringReader(this.insert+this.delete);
+        List<StorageEntryWrapper> recList = this.recReader.recoverEntries(new BufferedReader(reader));
+        assertEquals(2,recList.size());
+        assertEquals(StorageOperation.INSERT,recList.get(0).getOperation());
+        assertEquals(StorageOperation.DELETE,recList.get(1).getOperation());
+        
+        reader = new StringReader("some corrupted\n###########\n"+this.insert);
+        recList = this.recReader.recoverEntries(new BufferedReader(reader));
+        assertEquals(1,recList.size());
+        assertEquals(StorageOperation.INSERT,recList.get(0).getOperation());
+        
+    }
+}
diff --git a/contrib/gdata-server/src/test/org/apache/lucene/gdata/utils/AuthenticationContorllerStub.java b/contrib/gdata-server/src/test/org/apache/lucene/gdata/utils/AuthenticationContorllerStub.java
new file mode 100644
index 0000000..ce789a2
--- /dev/null
+++ b/contrib/gdata-server/src/test/org/apache/lucene/gdata/utils/AuthenticationContorllerStub.java
@@ -0,0 +1,70 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.utils;
+
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
+import org.apache.lucene.gdata.server.authentication.AuthenticationController;
+import org.apache.lucene.gdata.server.registry.Component;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+@Component(componentType=ComponentType.AUTHENTICATIONCONTROLLER)
+public class AuthenticationContorllerStub implements AuthenticationController {
+    public static AuthenticationController controller;
+    /**
+     * 
+     */
+    public AuthenticationContorllerStub() {
+        super();
+        // TODO Auto-generated constructor stub
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.authentication.AuthenticationController#authenticatAccount(org.apache.lucene.gdata.data.GDataAccount, java.lang.String, java.lang.String)
+     */
+    public String authenticatAccount(GDataAccount account, String requestIp
+            ) {
+
+        return controller.authenticatAccount(account,requestIp);
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.authentication.AuthenticationController#authenticateToken(java.lang.String, java.lang.String, org.apache.lucene.gdata.data.GDataAccount.AccountRole, java.lang.String)
+     */
+    public boolean authenticateToken(String token, String requestIp,
+            AccountRole role, String serviceName) {
+
+        return controller.authenticateToken(token,requestIp,role,serviceName);
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.registry.ServerComponent#initialize()
+     */
+    public void initialize() {
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.registry.ServerComponent#destroy()
+     */
+    public void destroy() {
+    }
+
+}
diff --git a/contrib/gdata-server/src/test/org/apache/lucene/gdata/utils/ProvidedServiceStub.java b/contrib/gdata-server/src/test/org/apache/lucene/gdata/utils/ProvidedServiceStub.java
new file mode 100644
index 0000000..9c030f5
--- /dev/null
+++ b/contrib/gdata-server/src/test/org/apache/lucene/gdata/utils/ProvidedServiceStub.java
@@ -0,0 +1,38 @@
+package org.apache.lucene.gdata.utils;
+
+import org.apache.lucene.gdata.server.registry.ProvidedService;
+
+import com.google.gdata.data.Entry;
+import com.google.gdata.data.ExtensionProfile;
+import com.google.gdata.data.Feed;
+
+public class ProvidedServiceStub implements ProvidedService {
+
+    public static final String SERVICE_NAME = "service";
+
+    public ProvidedServiceStub() {
+        super();
+        // TODO Auto-generated constructor stub
+    }
+
+    public Class getFeedType() {
+
+        return Feed.class;
+    }
+
+    public ExtensionProfile getExtensionProfile() {
+
+        return new ExtensionProfile();
+    }
+
+    public Class getEntryType() {
+
+        return Entry.class;
+    }
+
+    public String getName() {
+
+        return SERVICE_NAME;
+    }
+
+}
diff --git a/contrib/gdata-server/src/test/org/apache/lucene/gdata/utils/ServiceFactoryStub.java b/contrib/gdata-server/src/test/org/apache/lucene/gdata/utils/ServiceFactoryStub.java
new file mode 100644
index 0000000..aa5517f
--- /dev/null
+++ b/contrib/gdata-server/src/test/org/apache/lucene/gdata/utils/ServiceFactoryStub.java
@@ -0,0 +1,60 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.utils;
+
+import org.apache.lucene.gdata.server.Service;
+import org.apache.lucene.gdata.server.ServiceFactory;
+import org.apache.lucene.gdata.server.administration.AdminService;
+import org.apache.lucene.gdata.server.registry.Component;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+@Component(componentType=ComponentType.SERVICEFACTORY)
+public class ServiceFactoryStub extends ServiceFactory {
+   
+    public Service service;
+    public AdminService adminService;
+    /**
+     * @see org.apache.lucene.gdata.server.ServiceFactory#getAdminService()
+     */
+    @Override
+    public AdminService getAdminService() {
+        
+        return adminService;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.ServiceFactory#getService()
+     */
+    @Override
+    public Service getService() {
+        
+        return service;
+    }
+
+    public void setAdminService(AdminService service) {
+        this.adminService = service;
+    }
+    public void setService(Service service) {
+        this.service = service;
+    }
+    
+
+}
diff --git a/contrib/gdata-server/src/test/org/apache/lucene/gdata/utils/StorageControllerStub.java b/contrib/gdata-server/src/test/org/apache/lucene/gdata/utils/StorageControllerStub.java
new file mode 100644
index 0000000..540c976
--- /dev/null
+++ b/contrib/gdata-server/src/test/org/apache/lucene/gdata/utils/StorageControllerStub.java
@@ -0,0 +1,60 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.utils;
+
+import org.apache.lucene.gdata.server.registry.Component;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+import org.apache.lucene.gdata.storage.Storage;
+import org.apache.lucene.gdata.storage.StorageController;
+import org.apache.lucene.gdata.storage.StorageException;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+@Component(componentType = ComponentType.STORAGECONTROLLER)
+public class StorageControllerStub implements StorageController {
+
+    /**
+     * 
+     */
+    public StorageControllerStub() {
+        super();
+        // TODO Auto-generated constructor stub
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.StorageController#destroy()
+     */
+    public void destroy() {
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.StorageController#getStorage()
+     */
+    public Storage getStorage() throws StorageException {
+
+        return new StorageStub();
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.registry.ServerComponent#initialize()
+     */
+    public void initialize() {
+    }
+
+}
diff --git a/contrib/gdata-server/src/test/org/apache/lucene/gdata/utils/StorageStub.java b/contrib/gdata-server/src/test/org/apache/lucene/gdata/utils/StorageStub.java
new file mode 100644
index 0000000..5366b6a
--- /dev/null
+++ b/contrib/gdata-server/src/test/org/apache/lucene/gdata/utils/StorageStub.java
@@ -0,0 +1,173 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.utils;
+
+import java.util.Date;
+
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.data.ServerBaseFeed;
+import org.apache.lucene.gdata.server.registry.Component;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+import org.apache.lucene.gdata.storage.Storage;
+import org.apache.lucene.gdata.storage.StorageController;
+import org.apache.lucene.gdata.storage.StorageException;
+
+import com.google.gdata.data.BaseEntry;
+import com.google.gdata.data.BaseFeed;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+@Component(componentType=ComponentType.STORAGECONTROLLER)
+public class StorageStub implements Storage, StorageController {
+public static String SERVICE_TYPE_RETURN = "service";
+    /**
+     * 
+     */
+    public StorageStub() {
+        super();
+        // TODO Auto-generated constructor stub
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#storeEntry(org.apache.lucene.gdata.data.ServerBaseEntry)
+     */
+    public BaseEntry storeEntry(ServerBaseEntry entry)
+            throws StorageException {
+
+        return null;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#deleteEntry(org.apache.lucene.gdata.data.ServerBaseEntry)
+     */
+    public void deleteEntry(ServerBaseEntry entry) throws StorageException {
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#updateEntry(org.apache.lucene.gdata.data.ServerBaseEntry)
+     */
+    public BaseEntry updateEntry(ServerBaseEntry entry)
+            throws StorageException {
+
+        return null;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#getFeed(org.apache.lucene.gdata.data.ServerBaseFeed)
+     */
+    public BaseFeed getFeed(ServerBaseFeed feed) throws StorageException {
+
+        return null;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#getEntry(org.apache.lucene.gdata.data.ServerBaseEntry)
+     */
+    public BaseEntry getEntry(ServerBaseEntry entry)
+            throws StorageException {
+
+        return null;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#storeAccount(org.apache.lucene.gdata.data.GDataAccount)
+     */
+    public void storeAccount(GDataAccount Account) throws StorageException {
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#updateAccount(org.apache.lucene.gdata.data.GDataAccount)
+     */
+    public void updateAccount(GDataAccount Account) throws StorageException {
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#deleteAccount(java.lang.String)
+     */
+    public void deleteAccount(String Accountname) throws StorageException {
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#storeFeed(org.apache.lucene.gdata.data.ServerBaseFeed, java.lang.String)
+     */
+    public void storeFeed(ServerBaseFeed feed, String accountname)
+            throws StorageException {
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#deleteFeed(java.lang.String)
+     */
+    public void deleteFeed(String feedId) throws StorageException {
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#updateFeed(org.apache.lucene.gdata.data.ServerBaseFeed, java.lang.String)
+     */
+    public void updateFeed(ServerBaseFeed feed, String accountname)
+            throws StorageException {
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#close()
+     */
+    public void close() {
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#getServiceForFeed(java.lang.String)
+     */
+    public String getServiceForFeed(String feedId) throws StorageException {
+
+        return SERVICE_TYPE_RETURN;
+    }
+
+    public void destroy() {
+    }
+
+    public Storage getStorage() throws StorageException {
+        
+        return new StorageStub();
+    }
+
+    public GDataAccount getAccount(String accountName) throws StorageException {
+        
+        return null;
+    }
+
+    public String getAccountNameForFeedId(String feedId) throws StorageException {
+        
+        return null;
+    }
+
+    public void initialize() {
+    }
+
+
+    public Long getFeedLastModified(String feedId) throws StorageException {
+        
+        return null;
+    }
+
+    public Long getEntryLastModified(String entryId, String feedId) throws StorageException {
+        
+        return null;
+    }
+
+}
diff --git a/contrib/gdata-server/src/test/org/apache/lucene/gdata/utils/TestDateFormater.java b/contrib/gdata-server/src/test/org/apache/lucene/gdata/utils/TestDateFormater.java
new file mode 100644
index 0000000..a632c5e
--- /dev/null
+++ b/contrib/gdata-server/src/test/org/apache/lucene/gdata/utils/TestDateFormater.java
@@ -0,0 +1,38 @@
+package org.apache.lucene.gdata.utils;
+
+import java.text.ParseException;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.TimeZone;
+
+import com.sun.org.apache.xalan.internal.xsltc.compiler.Pattern;
+
+import junit.framework.TestCase;
+
+public class TestDateFormater extends TestCase {
+
+    protected void setUp() throws Exception {
+        super.setUp();
+    }
+
+    protected void tearDown() throws Exception {
+        super.tearDown();
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.utils.DateFormater.formatDate(Date, String)'
+     */
+    public void testFormatDate() throws ParseException {
+        
+        // this reg. --> bit weak but does the job
+            java.util.regex.Pattern pattern =  java.util.regex.Pattern.compile("[A-Z][a-z]{2}, [0-9]{1,2} [A-Z][a-z]{2} [0-9]{4} [0-9]{1,2}:[0-9]{1,2}:[0-9]{1,2} [A-Z]{2,4}");
+            Date date = new Date();
+            System.out.println(date.getTime());
+            String formatedDate = DateFormater.formatDate(date,DateFormater.HTTP_HEADER_DATE_FORMAT);
+            assertTrue(pattern.matcher(formatedDate).matches());    
+            System.out.println(DateFormater.parseDate(formatedDate,DateFormater.HTTP_HEADER_DATE_FORMAT).getTime());
+            DateFormater.parseDate("Sun, 25 Jun 2006 13:51:23 +0000",DateFormater.HTTP_HEADER_DATE_FORMAT,DateFormater.HTTP_HEADER_DATE_FORMAT_TIME_OFFSET);
+        
+    }
+
+}
diff --git a/contrib/gdata-server/webroot/WEB-INF/classes/gdata-account.xsd b/contrib/gdata-server/webroot/WEB-INF/classes/gdata-account.xsd
new file mode 100644
index 0000000..bc0b0e0
--- /dev/null
+++ b/contrib/gdata-server/webroot/WEB-INF/classes/gdata-account.xsd
@@ -0,0 +1,50 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
+	<xs:element name="password">
+		<xs:simpleType>
+			<xs:restriction base="xs:string">
+				<xs:minLength value="5" />
+			</xs:restriction>
+		</xs:simpleType>
+	</xs:element> 
+	<xs:element name="account-name">
+		<xs:simpleType>
+			<xs:restriction base="xs:string">
+				<xs:whiteSpace value="collapse" />
+			</xs:restriction>
+		</xs:simpleType>
+	</xs:element>
+
+	<xs:element name="email-address" type="xs:string" />
+	<xs:element name="url" type="xs:anyURI" />
+	<xs:element name="name" type="xs:string" />
+	<xs:element name="account-role">
+		<xs:simpleType>
+			<xs:restriction base="xs:positiveInteger">
+				<xs:fractionDigits value="2" />
+			</xs:restriction>
+		</xs:simpleType>
+	</xs:element>
+
+
+	<xs:element name="account-owner">
+		<xs:complexType>
+			<xs:sequence>
+				<xs:element ref="name" />
+				<xs:element ref="email-address" />
+				<xs:element ref="url" />
+			</xs:sequence>
+		</xs:complexType>
+	</xs:element>
+
+	<xs:element name="account">
+		<xs:complexType>
+			<xs:sequence>
+				<xs:element ref="account-name" />
+				<xs:element ref="password" />
+				<xs:element ref="account-role" />
+				<xs:element ref="account-owner" minOccurs="0" />
+			</xs:sequence>
+		</xs:complexType>
+	</xs:element>
+</xs:schema>
\ No newline at end of file
diff --git a/contrib/gdata-server/webroot/WEB-INF/classes/gdata-config.xml b/contrib/gdata-server/webroot/WEB-INF/classes/gdata-config.xml
new file mode 100644
index 0000000..59ac2f6
--- /dev/null
+++ b/contrib/gdata-server/webroot/WEB-INF/classes/gdata-config.xml
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<gdata>
+	<service name="feed" public="true">
+		<feed-class>com.google.gdata.data.Feed</feed-class>
+		<entry-class>com.google.gdata.data.Entry</entry-class>
+		<extension-profile>
+			com.google.gdata.data.ExtensionProfile
+		</extension-profile>
+	</service>
+	<service name="calendar" public="true">
+		<feed-class>
+			com.google.gdata.data.extensions.EventFeed
+		</feed-class>
+		<entry-class>
+			com.google.gdata.data.extensions.EventEntry
+		</entry-class>
+		<extension-profile>
+			com.google.gdata.data.ExtensionProfile
+		</extension-profile>
+	</service>
+	<server-components>
+		<component>
+			org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController
+		</component>
+		<component>
+			org.apache.lucene.gdata.servlet.handler.DefaultRequestHandlerFactory
+		</component>
+		<component>
+			org.apache.lucene.gdata.server.ServiceFactory
+		</component>
+		<component>
+			org.apache.lucene.gdata.server.authentication.BlowfishAuthenticationController
+		</component>
+	</server-components>
+</gdata>
\ No newline at end of file
diff --git a/contrib/gdata-server/webroot/meta-inf/context.xml b/contrib/gdata-server/webroot/meta-inf/context.xml
new file mode 100644
index 0000000..7c37688
--- /dev/null
+++ b/contrib/gdata-server/webroot/meta-inf/context.xml
@@ -0,0 +1,12 @@
+<!--
+    Context configuration file for the GDATA Server Web App
+-->
+
+
+<Context docBase="${catalina.home}/webapps/gdata-server"
+         privileged="false" reloadable="true" cookies="false" antiResourceLocking="false" antiJARLocking="false">
+
+
+
+</Context>
+

