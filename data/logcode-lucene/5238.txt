GitDiffStart: 322b697b0350d700b65ba17ca633d66e5a86c9c4 | Thu Oct 2 10:20:26 2014 +0000
diff --git a/lucene/queries/src/java/org/apache/lucene/queries/ChainedFilter.java b/lucene/queries/src/java/org/apache/lucene/queries/ChainedFilter.java
deleted file mode 100644
index 4f242b9..0000000
--- a/lucene/queries/src/java/org/apache/lucene/queries/ChainedFilter.java
+++ /dev/null
@@ -1,245 +0,0 @@
-package org.apache.lucene.queries;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-
-import org.apache.lucene.index.LeafReader;
-import org.apache.lucene.index.LeafReaderContext;
-import org.apache.lucene.search.BitsFilteredDocIdSet;
-import org.apache.lucene.search.DocIdSet;
-import org.apache.lucene.search.DocIdSetIterator;
-import org.apache.lucene.search.Filter;
-import org.apache.lucene.util.Bits;
-import org.apache.lucene.util.FixedBitSet;
-
-/**
- * <p>
- * Allows multiple {@link Filter}s to be chained.
- * Logical operations such as <b>NOT</b> and <b>XOR</b>
- * are applied between filters. One operation can be used
- * for all filters, or a specific operation can be declared
- * for each filter.
- * </p>
- * <p>
- * Order in which filters are called depends on
- * the position of the filter in the chain. It's probably
- * more efficient to place the most restrictive filters
- * /least computationally-intensive filters first.
- * </p>
- */
-public class ChainedFilter extends Filter {
-
-  public static final int OR = 0;
-  public static final int AND = 1;
-  public static final int ANDNOT = 2;
-  public static final int XOR = 3;
-  /**
-   * Logical operation when none is declared. Defaults to OR.
-   */
-  public static final int DEFAULT = OR;
-
-  /**
-   * The filter chain
-   */
-  private Filter[] chain = null;
-
-  private int[] logicArray;
-
-  private int logic = -1;
-
-  /**
-   * Ctor.
-   *
-   * @param chain The chain of filters
-   */
-  public ChainedFilter(Filter[] chain) {
-    this.chain = chain;
-  }
-
-  /**
-   * Ctor.
-   *
-   * @param chain The chain of filters
-   * @param logicArray Logical operations to apply between filters
-   */
-  public ChainedFilter(Filter[] chain, int[] logicArray) {
-    this.chain = chain;
-    this.logicArray = logicArray;
-  }
-
-  /**
-   * Ctor.
-   *
-   * @param chain The chain of filters
-   * @param logic Logical operation to apply to ALL filters
-   */
-  public ChainedFilter(Filter[] chain, int logic) {
-    this.chain = chain;
-    this.logic = logic;
-  }
-
-  /**
-   * {@link Filter#getDocIdSet}.
-   */
-  @Override
-  public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {
-    int[] index = new int[1]; // use array as reference to modifiable int;
-    index[0] = 0;             // an object attribute would not be thread safe.
-    if (logic != -1) {
-      return BitsFilteredDocIdSet.wrap(getDocIdSet(context, logic, index), acceptDocs);
-    } else if (logicArray != null) {
-      return BitsFilteredDocIdSet.wrap(getDocIdSet(context, logicArray, index), acceptDocs);
-    }
-    
-    return BitsFilteredDocIdSet.wrap(getDocIdSet(context, DEFAULT, index), acceptDocs);
-  }
-
-  private DocIdSetIterator getDISI(Filter filter, LeafReaderContext context)
-      throws IOException {
-    // we dont pass acceptDocs, we will filter at the end using an additional filter
-    DocIdSet docIdSet = filter.getDocIdSet(context, null);
-    if (docIdSet == null) {
-      return DocIdSetIterator.empty();
-    } else {
-      DocIdSetIterator iter = docIdSet.iterator();
-      if (iter == null) {
-        return DocIdSetIterator.empty();
-      } else {
-        return iter;
-      }
-    }
-  }
-
-  private FixedBitSet initialResult(LeafReaderContext context, int logic, int[] index)
-      throws IOException {
-    LeafReader reader = context.reader();
-    FixedBitSet result = new FixedBitSet(reader.maxDoc());
-    if (logic == AND) {
-      result.or(getDISI(chain[index[0]], context));
-      ++index[0];
-    } else if (logic == ANDNOT) {
-      result.or(getDISI(chain[index[0]], context));
-      result.flip(0, reader.maxDoc()); // NOTE: may set bits for deleted docs.
-      ++index[0];
-    }
-    return result;
-  }
-
-  /**
-   * Delegates to each filter in the chain.
-   *
-   * @param context LeafReaderContext
-   * @param logic Logical operation
-   * @return DocIdSet
-   */
-  private DocIdSet getDocIdSet(LeafReaderContext context, int logic, int[] index)
-      throws IOException {
-    FixedBitSet result = initialResult(context, logic, index);
-    for (; index[0] < chain.length; index[0]++) {
-      // we dont pass acceptDocs, we will filter at the end using an additional filter
-      doChain(result, logic, chain[index[0]].getDocIdSet(context, null));
-    }
-    return result;
-  }
-
-  /**
-   * Delegates to each filter in the chain.
-   *
-   * @param context LeafReaderContext
-   * @param logic Logical operation
-   * @return DocIdSet
-   */
-  private DocIdSet getDocIdSet(LeafReaderContext context, int[] logic, int[] index)
-      throws IOException {
-    if (logic.length != chain.length) {
-      throw new IllegalArgumentException("Invalid number of elements in logic array");
-    }
-
-    FixedBitSet result = initialResult(context, logic[0], index);
-    for (; index[0] < chain.length; index[0]++) {
-      // we dont pass acceptDocs, we will filter at the end using an additional filter
-      doChain(result, logic[index[0]], chain[index[0]].getDocIdSet(context, null));
-    }
-    return result;
-  }
-
-  @Override
-  public String toString() {
-    StringBuilder sb = new StringBuilder();
-    sb.append("ChainedFilter: [");
-    for (Filter aChain : chain) {
-      sb.append(aChain);
-      sb.append(' ');
-    }
-    sb.append(']');
-    return sb.toString();
-  }
-
-  private void doChain(FixedBitSet result, int logic, DocIdSet dis) throws IOException {
-    if (dis instanceof FixedBitSet) {
-      // optimized case for FixedBitSets
-      switch (logic) {
-        case OR:
-          result.or((FixedBitSet) dis);
-          break;
-        case AND:
-          result.and((FixedBitSet) dis);
-          break;
-        case ANDNOT:
-          result.andNot((FixedBitSet) dis);
-          break;
-        case XOR:
-          result.xor((FixedBitSet) dis);
-          break;
-        default:
-          doChain(result, DEFAULT, dis);
-          break;
-      }
-    } else {
-      DocIdSetIterator disi;
-      if (dis == null) {
-        disi = DocIdSetIterator.empty();
-      } else {
-        disi = dis.iterator();
-        if (disi == null) {
-          disi = DocIdSetIterator.empty();
-        }
-      }
-
-      switch (logic) {
-        case OR:
-          result.or(disi);
-          break;
-        case AND:
-          result.and(disi);
-          break;
-        case ANDNOT:
-          result.andNot(disi);
-          break;
-        case XOR:
-          result.xor(disi);
-          break;
-        default:
-          doChain(result, DEFAULT, dis);
-          break;
-      }
-    }
-  }
-
-}
diff --git a/lucene/queries/src/test/org/apache/lucene/queries/ChainedFilterTest.java b/lucene/queries/src/test/org/apache/lucene/queries/ChainedFilterTest.java
deleted file mode 100644
index 714d2a7..0000000
--- a/lucene/queries/src/test/org/apache/lucene/queries/ChainedFilterTest.java
+++ /dev/null
@@ -1,220 +0,0 @@
-package org.apache.lucene.queries;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.Calendar;
-import java.util.GregorianCalendar;
-import java.util.Locale;
-import java.util.TimeZone;
-
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.BooleanClause;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.CachingWrapperFilter;
-import org.apache.lucene.search.Filter;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.MatchAllDocsQuery;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.QueryWrapperFilter;
-import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.TermRangeFilter;
-import org.apache.lucene.search.TopDocs;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.LuceneTestCase;
-
-public class ChainedFilterTest extends LuceneTestCase {
-  public static final int MAX = 500;
-
-  private Directory directory;
-  private IndexSearcher searcher;
-  private IndexReader reader;
-  private Query query;
-  // private DateFilter dateFilter;   DateFilter was deprecated and removed
-  private TermRangeFilter dateFilter;
-  private QueryWrapperFilter bobFilter;
-  private QueryWrapperFilter sueFilter;
-
-  @Override
-  public void setUp() throws Exception {
-    super.setUp();
-    directory = newDirectory();
-    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);
-    // we use the default Locale/TZ since LuceneTestCase randomizes it
-    Calendar cal = new GregorianCalendar(TimeZone.getDefault(), Locale.getDefault());
-    cal.clear();
-    cal.setTimeInMillis(1041397200000L); // 2003 January 01
-
-    for (int i = 0; i < MAX; i++) {
-      Document doc = new Document();
-      doc.add(newStringField("key", "" + (i + 1), Field.Store.YES));
-      doc.add(newStringField("owner", (i < MAX / 2) ? "bob" : "sue", Field.Store.YES));
-      doc.add(newStringField("date", cal.getTime().toString(), Field.Store.YES));
-      writer.addDocument(doc);
-
-      cal.add(Calendar.DATE, 1);
-    }
-    reader = writer.getReader();
-    writer.close();
-
-    searcher = newSearcher(reader);
-
-    // query for everything to make life easier
-    BooleanQuery bq = new BooleanQuery();
-    bq.add(new TermQuery(new Term("owner", "bob")), BooleanClause.Occur.SHOULD);
-    bq.add(new TermQuery(new Term("owner", "sue")), BooleanClause.Occur.SHOULD);
-    query = bq;
-
-    // date filter matches everything too
-    //Date pastTheEnd = parseDate("2099 Jan 1");
-    // dateFilter = DateFilter.Before("date", pastTheEnd);
-    // just treat dates as strings and select the whole range for now...
-    dateFilter = TermRangeFilter.newStringRange("date","","ZZZZ",true,true);
-
-    bobFilter = new QueryWrapperFilter(
-        new TermQuery(new Term("owner", "bob")));
-    sueFilter = new QueryWrapperFilter(
-        new TermQuery(new Term("owner", "sue")));
-  }
-
-  @Override
-  public void tearDown() throws Exception {
-    reader.close();
-    directory.close();
-    super.tearDown();
-  }
-
-  private ChainedFilter getChainedFilter(Filter[] chain, int[] logic) {
-    if (logic == null) {
-      return new ChainedFilter(chain);
-    } else {
-      return new ChainedFilter(chain, logic);
-    }
-  }
-
-  private ChainedFilter getChainedFilter(Filter[] chain, int logic) {
-    return new ChainedFilter(chain, logic);
-  }
-
-  
-  public void testSingleFilter() throws Exception {
-    ChainedFilter chain = getChainedFilter(new Filter[] {dateFilter}, null);
-
-    int numHits = searcher.search(query, chain, 1000).totalHits;
-    assertEquals(MAX, numHits);
-
-    chain = new ChainedFilter(new Filter[] {bobFilter});
-    numHits = searcher.search(query, chain, 1000).totalHits;
-    assertEquals(MAX / 2, numHits);
-    
-    chain = getChainedFilter(new Filter[] {bobFilter}, new int[] {ChainedFilter.AND});
-    TopDocs hits = searcher.search(query, chain, 1000);
-    numHits = hits.totalHits;
-    assertEquals(MAX / 2, numHits);
-    assertEquals("bob", searcher.doc(hits.scoreDocs[0].doc).get("owner"));
-    
-    chain = getChainedFilter(new Filter[] {bobFilter}, new int[] {ChainedFilter.ANDNOT});
-    hits = searcher.search(query, chain, 1000);
-    numHits = hits.totalHits;
-    assertEquals(MAX / 2, numHits);
-    assertEquals("sue", searcher.doc(hits.scoreDocs[0].doc).get("owner"));
-  }
-
-  public void testOR() throws Exception {
-    ChainedFilter chain = getChainedFilter(
-      new Filter[] {sueFilter, bobFilter}, null);
-
-    int numHits = searcher.search(query, chain, 1000).totalHits;
-    assertEquals("OR matches all", MAX, numHits);
-  }
-
-  public void testAND() throws Exception {
-    ChainedFilter chain = getChainedFilter(
-      new Filter[] {dateFilter, bobFilter}, ChainedFilter.AND);
-
-    TopDocs hits = searcher.search(query, chain, 1000);
-    assertEquals("AND matches just bob", MAX / 2, hits.totalHits);
-    assertEquals("bob", searcher.doc(hits.scoreDocs[0].doc).get("owner"));
-  }
-
-  public void testXOR() throws Exception {
-    ChainedFilter chain = getChainedFilter(
-      new Filter[]{dateFilter, bobFilter}, ChainedFilter.XOR);
-
-    TopDocs hits = searcher.search(query, chain, 1000);
-    assertEquals("XOR matches sue", MAX / 2, hits.totalHits);
-    assertEquals("sue", searcher.doc(hits.scoreDocs[0].doc).get("owner"));
-  }
-
-  public void testANDNOT() throws Exception {
-    ChainedFilter chain = getChainedFilter(
-      new Filter[]{dateFilter, sueFilter},
-        new int[] {ChainedFilter.AND, ChainedFilter.ANDNOT});
-
-    TopDocs hits = searcher.search(query, chain, 1000);
-    assertEquals("ANDNOT matches just bob",
-        MAX / 2, hits.totalHits);
-    assertEquals("bob", searcher.doc(hits.scoreDocs[0].doc).get("owner"));
-    
-    chain = getChainedFilter(
-        new Filter[]{bobFilter, bobFilter},
-          new int[] {ChainedFilter.ANDNOT, ChainedFilter.ANDNOT});
-
-      hits = searcher.search(query, chain, 1000);
-      assertEquals("ANDNOT bob ANDNOT bob matches all sues",
-          MAX / 2, hits.totalHits);
-      assertEquals("sue", searcher.doc(hits.scoreDocs[0].doc).get("owner"));
-  }
-
-  /*
-  private Date parseDate(String s) throws ParseException {
-    return new SimpleDateFormat("yyyy MMM dd", Locale.ROOT).parse(s);
-  }
-  */
-  
-  public void testWithCachingFilter() throws Exception {
-    Directory dir = newDirectory();
-    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
-    IndexReader reader = writer.getReader();
-    writer.close();
-  
-    IndexSearcher searcher = newSearcher(reader);
-  
-    Query query = new TermQuery(new Term("none", "none"));
-  
-    QueryWrapperFilter queryFilter = new QueryWrapperFilter(query);
-    CachingWrapperFilter cachingFilter = new CachingWrapperFilter(queryFilter);
-  
-    searcher.search(query, cachingFilter, 1);
-  
-    CachingWrapperFilter cachingFilter2 = new CachingWrapperFilter(queryFilter);
-    Filter[] chain = new Filter[2];
-    chain[0] = cachingFilter;
-    chain[1] = cachingFilter2;
-    ChainedFilter cf = new ChainedFilter(chain);
-  
-    // throws java.lang.ClassCastException: org.apache.lucene.util.OpenBitSet cannot be cast to java.util.BitSet
-    searcher.search(new MatchAllDocsQuery(), cf, 1);
-    reader.close();
-    dir.close();
-  }
-
-}
diff --git a/solr/core/src/java/org/apache/solr/schema/CurrencyField.java b/solr/core/src/java/org/apache/solr/schema/CurrencyField.java
index 009baef..7e6cb22 100644
--- a/solr/core/src/java/org/apache/solr/schema/CurrencyField.java
+++ b/solr/core/src/java/org/apache/solr/schema/CurrencyField.java
@@ -22,12 +22,13 @@ import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.StorableField;
 import org.apache.lucene.queries.function.FunctionValues;
 import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.Filter;
 import org.apache.lucene.search.FieldValueFilter;
 import org.apache.lucene.uninverting.UninvertingReader.Type;
-import org.apache.lucene.queries.ChainedFilter;
+import org.apache.lucene.queries.BooleanFilter;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.SolrException.ErrorCode;
 import org.apache.solr.response.TextResponseWriter;
@@ -48,6 +49,7 @@ import javax.xml.xpath.XPath;
 import javax.xml.xpath.XPathConstants;
 import javax.xml.xpath.XPathExpressionException;
 import javax.xml.xpath.XPathFactory;
+
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.ArrayList;
@@ -332,8 +334,9 @@ public class CurrencyField extends FieldType implements SchemaAware, ResourceLoa
        p1 == null ? null : p1.getAmount() + "", 
        p2 == null ? null : p2.getAmount() + "",
        minInclusive, maxInclusive);
-    final Filter docsInRange = new ChainedFilter
-      (new Filter [] { docsWithValues, vsRangeFilter }, ChainedFilter.AND);
+    final BooleanFilter docsInRange = new BooleanFilter();
+    docsInRange.add(docsWithValues, Occur.MUST);
+    docsInRange.add(vsRangeFilter, Occur.MUST);
 
     return new SolrConstantScoreQuery(docsInRange);
     

