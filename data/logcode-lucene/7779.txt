GitDiffStart: 57f38e67d6517b42b6c9476412bde11a16cc7e42 | Wed Oct 9 15:59:24 2013 +0000
diff --git a/lucene/CHANGES.txt b/lucene/CHANGES.txt
index a62c85f..719e544 100644
--- a/lucene/CHANGES.txt
+++ b/lucene/CHANGES.txt
@@ -99,6 +99,10 @@ New Features
   contents of existing field, weight and optionally payload stored
   fields in an index (Areek Zillur via Mike McCandless)
 
+* LUCENE-5261: Add QueryBuilder, a simple API to build queries from
+  the analysis chain directly, or to make it easier to implement
+  query parsers.  (Robert Muir, Uwe Schindler)
+
 Bug Fixes
 
 * LUCENE-4998: Fixed a few places to pass IOContext.READONCE instead
diff --git a/lucene/core/src/java/org/apache/lucene/util/QueryBuilder.java b/lucene/core/src/java/org/apache/lucene/util/QueryBuilder.java
new file mode 100644
index 0000000..aedf14a
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/util/QueryBuilder.java
@@ -0,0 +1,413 @@
+package org.apache.lucene.util;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.CachingTokenFilter;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
+import org.apache.lucene.analysis.tokenattributes.TermToBytesRefAttribute;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.MultiPhraseQuery;
+import org.apache.lucene.search.PhraseQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TermQuery;
+
+/**
+ * Creates queries from the {@link Analyzer} chain.
+ * <p>
+ * Example usage:
+ * <pre class="prettyprint">
+ *   QueryBuilder builder = new QueryBuilder(analyzer);
+ *   Query a = builder.createBooleanQuery("body", "just a test");
+ *   Query b = builder.createPhraseQuery("body", "another test");
+ *   Query c = builder.createMinShouldMatchQuery("body", "another test", 0.5f);
+ * </pre>
+ * <p>
+ * This can also be used as a subclass for query parsers to make it easier
+ * to interact with the analysis chain. Factory methods such as {@code newTermQuery} 
+ * are provided so that the generated queries can be customized.
+ */
+public class QueryBuilder {
+  private Analyzer analyzer;
+  private boolean enablePositionIncrements = true;
+  
+  /** Creates a new QueryBuilder using the given analyzer. */
+  public QueryBuilder(Analyzer analyzer) {
+    this.analyzer = analyzer;
+  }
+  
+  /** 
+   * Creates a boolean query from the query text.
+   * <p>
+   * This is equivalent to {@code createBooleanQuery(field, queryText, Occur.SHOULD)}
+   * @param field field name
+   * @param queryText text to be passed to the analyzer
+   * @return {@code TermQuery} or {@code BooleanQuery}, based on the analysis
+   *         of {@code queryText}
+   */
+  public Query createBooleanQuery(String field, String queryText) {
+    return createBooleanQuery(field, queryText, BooleanClause.Occur.SHOULD);
+  }
+  
+  /** 
+   * Creates a boolean query from the query text.
+   * <p>
+   * @param field field name
+   * @param queryText text to be passed to the analyzer
+   * @param operator operator used for clauses between analyzer tokens.
+   * @return {@code TermQuery} or {@code BooleanQuery}, based on the analysis 
+   *         of {@code queryText}
+   */
+  public Query createBooleanQuery(String field, String queryText, BooleanClause.Occur operator) {
+    if (operator != BooleanClause.Occur.SHOULD && operator != BooleanClause.Occur.MUST) {
+      throw new IllegalArgumentException("invalid operator: only SHOULD or MUST are allowed");
+    }
+    return createFieldQuery(analyzer, operator, field, queryText, false, 0);
+  }
+  
+  /** 
+   * Creates a phrase query from the query text.
+   * <p>
+   * This is equivalent to {@code createPhraseQuery(field, queryText, 0)}
+   * @param field field name
+   * @param queryText text to be passed to the analyzer
+   * @return {@code TermQuery}, {@code BooleanQuery}, {@code PhraseQuery}, or
+   *         {@code MultiPhraseQuery}, based on the analysis of {@code queryText}
+   */
+  public Query createPhraseQuery(String field, String queryText) {
+    return createPhraseQuery(field, queryText, 0);
+  }
+  
+  /** 
+   * Creates a phrase query from the query text.
+   * <p>
+   * @param field field name
+   * @param queryText text to be passed to the analyzer
+   * @param phraseSlop number of other words permitted between words in query phrase
+   * @return {@code TermQuery}, {@code BooleanQuery}, {@code PhraseQuery}, or
+   *         {@code MultiPhraseQuery}, based on the analysis of {@code queryText}
+   */
+  public Query createPhraseQuery(String field, String queryText, int phraseSlop) {
+    return createFieldQuery(analyzer, BooleanClause.Occur.MUST, field, queryText, true, phraseSlop);
+  }
+  
+  /** 
+   * Creates a minimum-should-match query from the query text.
+   * <p>
+   * @param field field name
+   * @param queryText text to be passed to the analyzer
+   * @param fraction of query terms {@code [0..1]} that should match 
+   * @return {@code TermQuery} or {@code BooleanQuery}, based on the analysis 
+   *         of {@code queryText}
+   */
+  public Query createMinShouldMatchQuery(String field, String queryText, float fraction) {
+    if (Float.isNaN(fraction) || fraction < 0 || fraction > 1) {
+      throw new IllegalArgumentException("fraction should be >= 0 and <= 1");
+    }
+    
+    // TODO: wierd that BQ equals/rewrite/scorer doesn't handle this?
+    if (fraction == 1) {
+      return createBooleanQuery(field, queryText, BooleanClause.Occur.MUST);
+    }
+    
+    Query query = createFieldQuery(analyzer, BooleanClause.Occur.SHOULD, field, queryText, false, 0);
+    if (query instanceof BooleanQuery) {
+      BooleanQuery bq = (BooleanQuery) query;
+      bq.setMinimumNumberShouldMatch((int) (fraction * bq.clauses().size()));
+    }
+    return query;
+  }
+  
+  /** 
+   * Returns the analyzer. 
+   * @see #setAnalyzer(Analyzer)
+   */
+  public Analyzer getAnalyzer() {
+    return analyzer;
+  }
+  
+  /** 
+   * Sets the analyzer used to tokenize text.
+   */
+  public void setAnalyzer(Analyzer analyzer) {
+    this.analyzer = analyzer;
+  }
+  
+  /**
+   * Returns true if position increments are enabled.
+   * @see #setEnablePositionIncrements(boolean)
+   */
+  public boolean getEnablePositionIncrements() {
+    return enablePositionIncrements;
+  }
+  
+  /**
+   * Set to <code>true</code> to enable position increments in result query.
+   * <p>
+   * When set, result phrase and multi-phrase queries will
+   * be aware of position increments.
+   * Useful when e.g. a StopFilter increases the position increment of
+   * the token that follows an omitted token.
+   * <p>
+   * Default: true.
+   */
+  public void setEnablePositionIncrements(boolean enable) {
+    this.enablePositionIncrements = enable;
+  }
+
+  /**
+   * Creates a query from the analysis chain.
+   * <p>
+   * Expert: this is more useful for subclasses such as queryparsers. 
+   * If using this class directly, just use {@link #createBooleanQuery(String, String)}
+   * and {@link #createPhraseQuery(String, String)}
+   * @param analyzer analyzer used for this query
+   * @param operator default boolean operator used for this query
+   * @param field field to create queries against
+   * @param queryText text to be passed to the analysis chain
+   * @param quoted true if phrases should be generated when terms occur at more than one position
+   * @param phraseSlop slop factor for phrase/multiphrase queries
+   */
+  protected final Query createFieldQuery(Analyzer analyzer, BooleanClause.Occur operator, String field, String queryText, boolean quoted, int phraseSlop) {
+    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;
+    // Use the analyzer to get all the tokens, and then build a TermQuery,
+    // PhraseQuery, or nothing based on the term count
+    CachingTokenFilter buffer = null;
+    TermToBytesRefAttribute termAtt = null;
+    PositionIncrementAttribute posIncrAtt = null;
+    int numTokens = 0;
+    int positionCount = 0;
+    boolean severalTokensAtSamePosition = false;
+    boolean hasMoreTokens = false;    
+    
+    try (TokenStream source = analyzer.tokenStream(field, queryText)) {
+      source.reset();
+      buffer = new CachingTokenFilter(source);
+      buffer.reset();
+
+      if (buffer.hasAttribute(TermToBytesRefAttribute.class)) {
+        termAtt = buffer.getAttribute(TermToBytesRefAttribute.class);
+      }
+      if (buffer.hasAttribute(PositionIncrementAttribute.class)) {
+        posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);
+      }
+
+      if (termAtt != null) {
+        try {
+          hasMoreTokens = buffer.incrementToken();
+          while (hasMoreTokens) {
+            numTokens++;
+            int positionIncrement = (posIncrAtt != null) ? posIncrAtt.getPositionIncrement() : 1;
+            if (positionIncrement != 0) {
+              positionCount += positionIncrement;
+            } else {
+              severalTokensAtSamePosition = true;
+            }
+            hasMoreTokens = buffer.incrementToken();
+          }
+        } catch (IOException e) {
+          // ignore
+        }
+      }
+    } catch (IOException e) {
+      throw new RuntimeException("Error analyzing query text", e);
+    }
+    
+    // rewind the buffer stream
+    buffer.reset();
+
+    BytesRef bytes = termAtt == null ? null : termAtt.getBytesRef();
+
+    if (numTokens == 0)
+      return null;
+    else if (numTokens == 1) {
+      try {
+        boolean hasNext = buffer.incrementToken();
+        assert hasNext == true;
+        termAtt.fillBytesRef();
+      } catch (IOException e) {
+        // safe to ignore, because we know the number of tokens
+      }
+      return newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes)));
+    } else {
+      if (severalTokensAtSamePosition || (!quoted)) {
+        if (positionCount == 1 || (!quoted)) {
+          // no phrase query:
+          
+          if (positionCount == 1) {
+            // simple case: only one position, with synonyms
+            BooleanQuery q = newBooleanQuery(true);
+            for (int i = 0; i < numTokens; i++) {
+              try {
+                boolean hasNext = buffer.incrementToken();
+                assert hasNext == true;
+                termAtt.fillBytesRef();
+              } catch (IOException e) {
+                // safe to ignore, because we know the number of tokens
+              }
+              Query currentQuery = newTermQuery(
+                  new Term(field, BytesRef.deepCopyOf(bytes)));
+              q.add(currentQuery, BooleanClause.Occur.SHOULD);
+            }
+            return q;
+          } else {
+            // multiple positions
+            BooleanQuery q = newBooleanQuery(false);
+            Query currentQuery = null;
+            for (int i = 0; i < numTokens; i++) {
+              try {
+                boolean hasNext = buffer.incrementToken();
+                assert hasNext == true;
+                termAtt.fillBytesRef();
+              } catch (IOException e) {
+                // safe to ignore, because we know the number of tokens
+              }
+              if (posIncrAtt != null && posIncrAtt.getPositionIncrement() == 0) {
+                if (!(currentQuery instanceof BooleanQuery)) {
+                  Query t = currentQuery;
+                  currentQuery = newBooleanQuery(true);
+                  ((BooleanQuery)currentQuery).add(t, BooleanClause.Occur.SHOULD);
+                }
+                ((BooleanQuery)currentQuery).add(newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes))), BooleanClause.Occur.SHOULD);
+              } else {
+                if (currentQuery != null) {
+                  q.add(currentQuery, operator);
+                }
+                currentQuery = newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes)));
+              }
+            }
+            q.add(currentQuery, operator);
+            return q;
+          }
+        } else {
+          // phrase query:
+          MultiPhraseQuery mpq = newMultiPhraseQuery();
+          mpq.setSlop(phraseSlop);
+          List<Term> multiTerms = new ArrayList<Term>();
+          int position = -1;
+          for (int i = 0; i < numTokens; i++) {
+            int positionIncrement = 1;
+            try {
+              boolean hasNext = buffer.incrementToken();
+              assert hasNext == true;
+              termAtt.fillBytesRef();
+              if (posIncrAtt != null) {
+                positionIncrement = posIncrAtt.getPositionIncrement();
+              }
+            } catch (IOException e) {
+              // safe to ignore, because we know the number of tokens
+            }
+
+            if (positionIncrement > 0 && multiTerms.size() > 0) {
+              if (enablePositionIncrements) {
+                mpq.add(multiTerms.toArray(new Term[0]),position);
+              } else {
+                mpq.add(multiTerms.toArray(new Term[0]));
+              }
+              multiTerms.clear();
+            }
+            position += positionIncrement;
+            multiTerms.add(new Term(field, BytesRef.deepCopyOf(bytes)));
+          }
+          if (enablePositionIncrements) {
+            mpq.add(multiTerms.toArray(new Term[0]),position);
+          } else {
+            mpq.add(multiTerms.toArray(new Term[0]));
+          }
+          return mpq;
+        }
+      } else {
+        PhraseQuery pq = newPhraseQuery();
+        pq.setSlop(phraseSlop);
+        int position = -1;
+
+        for (int i = 0; i < numTokens; i++) {
+          int positionIncrement = 1;
+
+          try {
+            boolean hasNext = buffer.incrementToken();
+            assert hasNext == true;
+            termAtt.fillBytesRef();
+            if (posIncrAtt != null) {
+              positionIncrement = posIncrAtt.getPositionIncrement();
+            }
+          } catch (IOException e) {
+            // safe to ignore, because we know the number of tokens
+          }
+
+          if (enablePositionIncrements) {
+            position += positionIncrement;
+            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)),position);
+          } else {
+            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)));
+          }
+        }
+        return pq;
+      }
+    }
+  }
+  
+  /**
+   * Builds a new BooleanQuery instance.
+   * <p>
+   * This is intended for subclasses that wish to customize the generated queries.
+   * @param disableCoord disable coord
+   * @return new BooleanQuery instance
+   */
+  protected BooleanQuery newBooleanQuery(boolean disableCoord) {
+    return new BooleanQuery(disableCoord);
+  }
+  
+  /**
+   * Builds a new TermQuery instance.
+   * <p>
+   * This is intended for subclasses that wish to customize the generated queries.
+   * @param term term
+   * @return new TermQuery instance
+   */
+  protected Query newTermQuery(Term term) {
+    return new TermQuery(term);
+  }
+  
+  /**
+   * Builds a new PhraseQuery instance.
+   * <p>
+   * This is intended for subclasses that wish to customize the generated queries.
+   * @return new PhraseQuery instance
+   */
+  protected PhraseQuery newPhraseQuery() {
+    return new PhraseQuery();
+  }
+  
+  /**
+   * Builds a new MultiPhraseQuery instance.
+   * <p>
+   * This is intended for subclasses that wish to customize the generated queries.
+   * @return new MultiPhraseQuery instance
+   */
+  protected MultiPhraseQuery newMultiPhraseQuery() {
+    return new MultiPhraseQuery();
+  }
+}
diff --git a/lucene/core/src/test/org/apache/lucene/util/TestQueryBuilder.java b/lucene/core/src/test/org/apache/lucene/util/TestQueryBuilder.java
new file mode 100644
index 0000000..0bb2c04
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/util/TestQueryBuilder.java
@@ -0,0 +1,358 @@
+package org.apache.lucene.util;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.io.Reader;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.analysis.MockTokenizer;
+import org.apache.lucene.analysis.TokenFilter;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.Tokenizer;
+import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
+import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.MultiPhraseQuery;
+import org.apache.lucene.search.PhraseQuery;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.util.automaton.CharacterRunAutomaton;
+import org.apache.lucene.util.automaton.RegExp;
+
+public class TestQueryBuilder extends LuceneTestCase {
+  
+  public void testTerm() {
+    TermQuery expected = new TermQuery(new Term("field", "test"));
+    QueryBuilder builder = new QueryBuilder(new MockAnalyzer(random()));
+    assertEquals(expected, builder.createBooleanQuery("field", "test"));
+  }
+  
+  public void testBoolean() {
+    BooleanQuery expected = new BooleanQuery();
+    expected.add(new TermQuery(new Term("field", "foo")), BooleanClause.Occur.SHOULD);
+    expected.add(new TermQuery(new Term("field", "bar")), BooleanClause.Occur.SHOULD);
+    QueryBuilder builder = new QueryBuilder(new MockAnalyzer(random()));
+    assertEquals(expected, builder.createBooleanQuery("field", "foo bar"));
+  }
+  
+  public void testBooleanMust() {
+    BooleanQuery expected = new BooleanQuery();
+    expected.add(new TermQuery(new Term("field", "foo")), BooleanClause.Occur.MUST);
+    expected.add(new TermQuery(new Term("field", "bar")), BooleanClause.Occur.MUST);
+    QueryBuilder builder = new QueryBuilder(new MockAnalyzer(random()));
+    assertEquals(expected, builder.createBooleanQuery("field", "foo bar", BooleanClause.Occur.MUST));
+  }
+  
+  public void testMinShouldMatchNone() {
+    QueryBuilder builder = new QueryBuilder(new MockAnalyzer(random()));
+    assertEquals(builder.createBooleanQuery("field", "one two three four"),
+                 builder.createMinShouldMatchQuery("field", "one two three four", 0f));
+  }
+  
+  public void testMinShouldMatchAll() {
+    QueryBuilder builder = new QueryBuilder(new MockAnalyzer(random()));
+    assertEquals(builder.createBooleanQuery("field", "one two three four", BooleanClause.Occur.MUST),
+                 builder.createMinShouldMatchQuery("field", "one two three four", 1f));
+  }
+  
+  public void testMinShouldMatch() {
+    BooleanQuery expected = new BooleanQuery();
+    expected.add(new TermQuery(new Term("field", "one")), BooleanClause.Occur.SHOULD);
+    expected.add(new TermQuery(new Term("field", "two")), BooleanClause.Occur.SHOULD);
+    expected.add(new TermQuery(new Term("field", "three")), BooleanClause.Occur.SHOULD);
+    expected.add(new TermQuery(new Term("field", "four")), BooleanClause.Occur.SHOULD);
+    expected.setMinimumNumberShouldMatch(0);
+    
+    QueryBuilder builder = new QueryBuilder(new MockAnalyzer(random()));
+    assertEquals(expected, builder.createMinShouldMatchQuery("field", "one two three four", 0.1f));
+    assertEquals(expected, builder.createMinShouldMatchQuery("field", "one two three four", 0.24f));
+    
+    expected.setMinimumNumberShouldMatch(1);
+    assertEquals(expected, builder.createMinShouldMatchQuery("field", "one two three four", 0.25f));
+    assertEquals(expected, builder.createMinShouldMatchQuery("field", "one two three four", 0.49f));
+
+    expected.setMinimumNumberShouldMatch(2);
+    assertEquals(expected, builder.createMinShouldMatchQuery("field", "one two three four", 0.5f));
+    assertEquals(expected, builder.createMinShouldMatchQuery("field", "one two three four", 0.74f));
+    
+    expected.setMinimumNumberShouldMatch(3);
+    assertEquals(expected, builder.createMinShouldMatchQuery("field", "one two three four", 0.75f));
+    assertEquals(expected, builder.createMinShouldMatchQuery("field", "one two three four", 0.99f));
+  }
+  
+  public void testPhraseQueryPositionIncrements() throws Exception {
+    PhraseQuery expected = new PhraseQuery();
+    expected.add(new Term("field", "1"));
+    expected.add(new Term("field", "2"), 2);
+    
+    CharacterRunAutomaton stopList = new CharacterRunAutomaton(new RegExp("[sS][tT][oO][pP]").toAutomaton());
+
+    Analyzer analyzer = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false, stopList);
+
+    QueryBuilder builder = new QueryBuilder(analyzer);
+    assertEquals(expected, builder.createPhraseQuery("field", "1 stop 2"));
+  }
+  
+  public void testEmpty() {
+    QueryBuilder builder = new QueryBuilder(new MockAnalyzer(random()));
+    assertNull(builder.createBooleanQuery("field", ""));
+  }
+  
+  /** adds synonym of "dog" for "dogs". */
+  static class MockSynonymAnalyzer extends Analyzer {
+    @Override
+    protected TokenStreamComponents createComponents(String fieldName, Reader reader) {
+      MockTokenizer tokenizer = new MockTokenizer(reader);
+      return new TokenStreamComponents(tokenizer, new MockSynonymFilter(tokenizer));
+    }
+  }
+  
+  /**
+   * adds synonym of "dog" for "dogs".
+   */
+  protected static class MockSynonymFilter extends TokenFilter {
+    CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);
+    PositionIncrementAttribute posIncAtt = addAttribute(PositionIncrementAttribute.class);
+    boolean addSynonym = false;
+    
+    public MockSynonymFilter(TokenStream input) {
+      super(input);
+    }
+
+    @Override
+    public final boolean incrementToken() throws IOException {
+      if (addSynonym) { // inject our synonym
+        clearAttributes();
+        termAtt.setEmpty().append("dog");
+        posIncAtt.setPositionIncrement(0);
+        addSynonym = false;
+        return true;
+      }
+      
+      if (input.incrementToken()) {
+        addSynonym = termAtt.toString().equals("dogs");
+        return true;
+      } else {
+        return false;
+      }
+    } 
+  }
+  
+  /** simple synonyms test */
+  public void testSynonyms() throws Exception {
+    BooleanQuery expected = new BooleanQuery(true);
+    expected.add(new TermQuery(new Term("field", "dogs")), BooleanClause.Occur.SHOULD);
+    expected.add(new TermQuery(new Term("field", "dog")), BooleanClause.Occur.SHOULD);
+    QueryBuilder builder = new QueryBuilder(new MockSynonymAnalyzer());
+    assertEquals(expected, builder.createBooleanQuery("field", "dogs"));
+    assertEquals(expected, builder.createPhraseQuery("field", "dogs"));
+    assertEquals(expected, builder.createBooleanQuery("field", "dogs", BooleanClause.Occur.MUST));
+    assertEquals(expected, builder.createPhraseQuery("field", "dogs"));
+  }
+  
+  /** forms multiphrase query */
+  public void testSynonymsPhrase() throws Exception {
+    MultiPhraseQuery expected = new MultiPhraseQuery();
+    expected.add(new Term("field", "old"));
+    expected.add(new Term[] { new Term("field", "dogs"), new Term("field", "dog") });
+    QueryBuilder builder = new QueryBuilder(new MockSynonymAnalyzer());
+    assertEquals(expected, builder.createPhraseQuery("field", "old dogs"));
+  }
+
+  protected static class SimpleCJKTokenizer extends Tokenizer {
+    private CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);
+
+    public SimpleCJKTokenizer(Reader input) {
+      super(input);
+    }
+
+    @Override
+    public final boolean incrementToken() throws IOException {
+      int ch = input.read();
+      if (ch < 0)
+        return false;
+      clearAttributes();
+      termAtt.setEmpty().append((char) ch);
+      return true;
+    }
+  }
+  
+  private class SimpleCJKAnalyzer extends Analyzer {
+    @Override
+    public TokenStreamComponents createComponents(String fieldName, Reader reader) {
+      return new TokenStreamComponents(new SimpleCJKTokenizer(reader));
+    }
+  }
+  
+  public void testCJKTerm() throws Exception {
+    // individual CJK chars as terms
+    SimpleCJKAnalyzer analyzer = new SimpleCJKAnalyzer(); 
+    
+    BooleanQuery expected = new BooleanQuery();
+    expected.add(new TermQuery(new Term("field", "ä¸?")), BooleanClause.Occur.SHOULD);
+    expected.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
+    
+    QueryBuilder builder = new QueryBuilder(analyzer);
+    assertEquals(expected, builder.createBooleanQuery("field", "ä¸??"));
+  }
+  
+  public void testCJKPhrase() throws Exception {
+    // individual CJK chars as terms
+    SimpleCJKAnalyzer analyzer = new SimpleCJKAnalyzer();
+    
+    PhraseQuery expected = new PhraseQuery();
+    expected.add(new Term("field", "ä¸?"));
+    expected.add(new Term("field", "??"));
+    
+    QueryBuilder builder = new QueryBuilder(analyzer);
+    assertEquals(expected, builder.createPhraseQuery("field", "ä¸??"));
+  }
+  
+  public void testCJKSloppyPhrase() throws Exception {
+    // individual CJK chars as terms
+    SimpleCJKAnalyzer analyzer = new SimpleCJKAnalyzer();
+    
+    PhraseQuery expected = new PhraseQuery();
+    expected.setSlop(3);
+    expected.add(new Term("field", "ä¸?"));
+    expected.add(new Term("field", "??"));
+    
+    QueryBuilder builder = new QueryBuilder(analyzer);
+    assertEquals(expected, builder.createPhraseQuery("field", "ä¸??", 3));
+  }
+  
+  /**
+   * adds synonym of "??" for "??".
+   */
+  protected static class MockCJKSynonymFilter extends TokenFilter {
+    CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);
+    PositionIncrementAttribute posIncAtt = addAttribute(PositionIncrementAttribute.class);
+    boolean addSynonym = false;
+    
+    public MockCJKSynonymFilter(TokenStream input) {
+      super(input);
+    }
+
+    @Override
+    public final boolean incrementToken() throws IOException {
+      if (addSynonym) { // inject our synonym
+        clearAttributes();
+        termAtt.setEmpty().append("??");
+        posIncAtt.setPositionIncrement(0);
+        addSynonym = false;
+        return true;
+      }
+      
+      if (input.incrementToken()) {
+        addSynonym = termAtt.toString().equals("??");
+        return true;
+      } else {
+        return false;
+      }
+    } 
+  }
+  
+  static class MockCJKSynonymAnalyzer extends Analyzer {
+    @Override
+    protected TokenStreamComponents createComponents(String fieldName, Reader reader) {
+      Tokenizer tokenizer = new SimpleCJKTokenizer(reader);
+      return new TokenStreamComponents(tokenizer, new MockCJKSynonymFilter(tokenizer));
+    }
+  }
+  
+  /** simple CJK synonym test */
+  public void testCJKSynonym() throws Exception {
+    BooleanQuery expected = new BooleanQuery(true);
+    expected.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
+    expected.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
+    QueryBuilder builder = new QueryBuilder(new MockCJKSynonymAnalyzer());
+    assertEquals(expected, builder.createBooleanQuery("field", "??"));
+    assertEquals(expected, builder.createPhraseQuery("field", "??"));
+    assertEquals(expected, builder.createBooleanQuery("field", "??", BooleanClause.Occur.MUST));
+  }
+  
+  /** synonyms with default OR operator */
+  public void testCJKSynonymsOR() throws Exception {
+    BooleanQuery expected = new BooleanQuery();
+    expected.add(new TermQuery(new Term("field", "ä¸?")), BooleanClause.Occur.SHOULD);
+    BooleanQuery inner = new BooleanQuery(true);
+    inner.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
+    inner.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
+    expected.add(inner, BooleanClause.Occur.SHOULD);
+    QueryBuilder builder = new QueryBuilder(new MockCJKSynonymAnalyzer());
+    assertEquals(expected, builder.createBooleanQuery("field", "ä¸??"));
+  }
+  
+  /** more complex synonyms with default OR operator */
+  public void testCJKSynonymsOR2() throws Exception {
+    BooleanQuery expected = new BooleanQuery();
+    expected.add(new TermQuery(new Term("field", "ä¸?")), BooleanClause.Occur.SHOULD);
+    BooleanQuery inner = new BooleanQuery(true);
+    inner.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
+    inner.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
+    expected.add(inner, BooleanClause.Occur.SHOULD);
+    BooleanQuery inner2 = new BooleanQuery(true);
+    inner2.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
+    inner2.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
+    expected.add(inner2, BooleanClause.Occur.SHOULD);
+    QueryBuilder builder = new QueryBuilder(new MockCJKSynonymAnalyzer());
+    assertEquals(expected, builder.createBooleanQuery("field", "ä¸????"));
+  }
+  
+  /** synonyms with default AND operator */
+  public void testCJKSynonymsAND() throws Exception {
+    BooleanQuery expected = new BooleanQuery();
+    expected.add(new TermQuery(new Term("field", "ä¸?")), BooleanClause.Occur.MUST);
+    BooleanQuery inner = new BooleanQuery(true);
+    inner.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
+    inner.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
+    expected.add(inner, BooleanClause.Occur.MUST);
+    QueryBuilder builder = new QueryBuilder(new MockCJKSynonymAnalyzer());
+    assertEquals(expected, builder.createBooleanQuery("field", "ä¸??", BooleanClause.Occur.MUST));
+  }
+  
+  /** more complex synonyms with default AND operator */
+  public void testCJKSynonymsAND2() throws Exception {
+    BooleanQuery expected = new BooleanQuery();
+    expected.add(new TermQuery(new Term("field", "ä¸?")), BooleanClause.Occur.MUST);
+    BooleanQuery inner = new BooleanQuery(true);
+    inner.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
+    inner.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
+    expected.add(inner, BooleanClause.Occur.MUST);
+    BooleanQuery inner2 = new BooleanQuery(true);
+    inner2.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
+    inner2.add(new TermQuery(new Term("field", "??")), BooleanClause.Occur.SHOULD);
+    expected.add(inner2, BooleanClause.Occur.MUST);
+    QueryBuilder builder = new QueryBuilder(new MockCJKSynonymAnalyzer());
+    assertEquals(expected, builder.createBooleanQuery("field", "ä¸????", BooleanClause.Occur.MUST));
+  }
+  
+  /** forms multiphrase query */
+  public void testCJKSynonymsPhrase() throws Exception {
+    MultiPhraseQuery expected = new MultiPhraseQuery();
+    expected.add(new Term("field", "ä¸?"));
+    expected.add(new Term[] { new Term("field", "??"), new Term("field", "??")});
+    QueryBuilder builder = new QueryBuilder(new MockCJKSynonymAnalyzer());
+    assertEquals(expected, builder.createPhraseQuery("field", "ä¸??"));
+    expected.setSlop(3);
+    assertEquals(expected, builder.createPhraseQuery("field", "ä¸??", 3));
+  }
+}
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserBase.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserBase.java
index b5cf904..4e0d5a6 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserBase.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserBase.java
@@ -23,9 +23,7 @@ import java.text.DateFormat;
 import java.util.*;
 
 import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.analysis.CachingTokenFilter;
 import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
 import org.apache.lucene.analysis.tokenattributes.TermToBytesRefAttribute;
 import org.apache.lucene.document.DateTools;
 import org.apache.lucene.index.Term;
@@ -34,13 +32,14 @@ import org.apache.lucene.queryparser.flexible.standard.CommonQueryParserConfigur
 import org.apache.lucene.search.*;
 import org.apache.lucene.search.BooleanQuery.TooManyClauses;
 import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.QueryBuilder;
 import org.apache.lucene.util.Version;
 
 /** This class is overridden by QueryParser in QueryParser.jj
  * and acts to separate the majority of the Java code from the .jj grammar file. 
  */
-public abstract class QueryParserBase implements CommonQueryParserConfiguration {
-
+public abstract class QueryParserBase extends QueryBuilder implements CommonQueryParserConfiguration {
+  
   /** Do not catch this exception in your code, it means you are using methods that you should no longer use. */
   public static class MethodRemovedUseAnother extends Throwable {}
 
@@ -65,9 +64,7 @@ public abstract class QueryParserBase implements CommonQueryParserConfiguration
   boolean lowercaseExpandedTerms = true;
   MultiTermQuery.RewriteMethod multiTermRewriteMethod = MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT;
   boolean allowLeadingWildcard = false;
-  boolean enablePositionIncrements = true;
 
-  Analyzer analyzer;
   String field;
   int phraseSlop = 0;
   float fuzzyMinSim = FuzzyQuery.defaultMinSimilarity;
@@ -88,6 +85,7 @@ public abstract class QueryParserBase implements CommonQueryParserConfiguration
 
   // So the generated QueryParser(CharStream) won't error out
   protected QueryParserBase() {
+    super(null);
   }
 
   /** Initializes a query parser.  Called by the QueryParser constructor
@@ -96,7 +94,7 @@ public abstract class QueryParserBase implements CommonQueryParserConfiguration
    *  @param a   used to find terms in the query text.
    */
   public void init(Version matchVersion, String f, Analyzer a) {
-    analyzer = a;
+    setAnalyzer(a);
     field = f;
     setAutoGeneratePhraseQueries(false);
   }
@@ -135,15 +133,6 @@ public abstract class QueryParserBase implements CommonQueryParserConfiguration
     }
   }
 
-
-   /**
-   * @return Returns the analyzer.
-   */
-  @Override
-  public Analyzer getAnalyzer() {
-    return analyzer;
-  }
-
   /**
    * @return Returns the default field.
    */
@@ -248,29 +237,6 @@ public abstract class QueryParserBase implements CommonQueryParserConfiguration
   }
 
   /**
-   * Set to <code>true</code> to enable position increments in result query.
-   * <p>
-   * When set, result phrase and multi-phrase queries will
-   * be aware of position increments.
-   * Useful when e.g. a StopFilter increases the position increment of
-   * the token that follows an omitted token.
-   * <p>
-   * Default: true.
-   */
-  @Override
-  public void setEnablePositionIncrements(boolean enable) {
-    this.enablePositionIncrements = enable;
-  }
-
-  /**
-   * @see #setEnablePositionIncrements(boolean)
-   */
-  @Override
-  public boolean getEnablePositionIncrements() {
-    return enablePositionIncrements;
-  }
-
-  /**
    * Sets the boolean operator of the QueryParser.
    * In default mode (<code>OR_OPERATOR</code>) terms without any modifiers
    * are considered optional: for example <code>capital of Hungary</code> is equal to
@@ -488,193 +454,15 @@ public abstract class QueryParserBase implements CommonQueryParserConfiguration
    * @exception org.apache.lucene.queryparser.classic.ParseException throw in overridden method to disallow
    */
   protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {
-    return newFieldQuery(analyzer, field, queryText, quoted);
+    return newFieldQuery(getAnalyzer(), field, queryText, quoted);
   }
   
   /**
    * @exception org.apache.lucene.queryparser.classic.ParseException throw in overridden method to disallow
    */
   protected Query newFieldQuery(Analyzer analyzer, String field, String queryText, boolean quoted)  throws ParseException {
-    // Use the analyzer to get all the tokens, and then build a TermQuery,
-    // PhraseQuery, or nothing based on the term count
-    CachingTokenFilter buffer = null;
-    TermToBytesRefAttribute termAtt = null;
-    PositionIncrementAttribute posIncrAtt = null;
-    int numTokens = 0;
-    int positionCount = 0;
-    boolean severalTokensAtSamePosition = false;
-    boolean hasMoreTokens = false;    
-    
-    try (TokenStream source = analyzer.tokenStream(field, queryText)) {
-      source.reset();
-      buffer = new CachingTokenFilter(source);
-      buffer.reset();
-
-      if (buffer.hasAttribute(TermToBytesRefAttribute.class)) {
-        termAtt = buffer.getAttribute(TermToBytesRefAttribute.class);
-      }
-      if (buffer.hasAttribute(PositionIncrementAttribute.class)) {
-        posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);
-      }
-
-      if (termAtt != null) {
-        try {
-          hasMoreTokens = buffer.incrementToken();
-          while (hasMoreTokens) {
-            numTokens++;
-            int positionIncrement = (posIncrAtt != null) ? posIncrAtt.getPositionIncrement() : 1;
-            if (positionIncrement != 0) {
-              positionCount += positionIncrement;
-            } else {
-              severalTokensAtSamePosition = true;
-            }
-            hasMoreTokens = buffer.incrementToken();
-          }
-        } catch (IOException e) {
-          // ignore
-        }
-      }
-    } catch (IOException e) {
-      ParseException p = new ParseException("Eror analyzing query text");
-      p.initCause(e);
-      throw p;
-    }
-    
-    // rewind the buffer stream
-    buffer.reset();
-
-    BytesRef bytes = termAtt == null ? null : termAtt.getBytesRef();
-
-    if (numTokens == 0)
-      return null;
-    else if (numTokens == 1) {
-      try {
-        boolean hasNext = buffer.incrementToken();
-        assert hasNext == true;
-        termAtt.fillBytesRef();
-      } catch (IOException e) {
-        // safe to ignore, because we know the number of tokens
-      }
-      return newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes)));
-    } else {
-      if (severalTokensAtSamePosition || (!quoted && !autoGeneratePhraseQueries)) {
-        if (positionCount == 1 || (!quoted && !autoGeneratePhraseQueries)) {
-          // no phrase query:
-          
-          if (positionCount == 1) {
-            // simple case: only one position, with synonyms
-            BooleanQuery q = newBooleanQuery(true);
-            for (int i = 0; i < numTokens; i++) {
-              try {
-                boolean hasNext = buffer.incrementToken();
-                assert hasNext == true;
-                termAtt.fillBytesRef();
-              } catch (IOException e) {
-                // safe to ignore, because we know the number of tokens
-              }
-              Query currentQuery = newTermQuery(
-                  new Term(field, BytesRef.deepCopyOf(bytes)));
-              q.add(currentQuery, BooleanClause.Occur.SHOULD);
-            }
-            return q;
-          } else {
-            // multiple positions
-            BooleanQuery q = newBooleanQuery(false);
-            final BooleanClause.Occur occur = operator == Operator.AND ? BooleanClause.Occur.MUST : BooleanClause.Occur.SHOULD;
-            Query currentQuery = null;
-            for (int i = 0; i < numTokens; i++) {
-              try {
-                boolean hasNext = buffer.incrementToken();
-                assert hasNext == true;
-                termAtt.fillBytesRef();
-              } catch (IOException e) {
-                // safe to ignore, because we know the number of tokens
-              }
-              if (posIncrAtt != null && posIncrAtt.getPositionIncrement() == 0) {
-                if (!(currentQuery instanceof BooleanQuery)) {
-                  Query t = currentQuery;
-                  currentQuery = newBooleanQuery(true);
-                  ((BooleanQuery)currentQuery).add(t, BooleanClause.Occur.SHOULD);
-                }
-                ((BooleanQuery)currentQuery).add(newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes))), BooleanClause.Occur.SHOULD);
-              } else {
-                if (currentQuery != null) {
-                  q.add(currentQuery, occur);
-                }
-                currentQuery = newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes)));
-              }
-            }
-            q.add(currentQuery, occur);
-            return q;
-          }
-        }
-        else {
-          // phrase query:
-          MultiPhraseQuery mpq = newMultiPhraseQuery();
-          mpq.setSlop(phraseSlop);
-          List<Term> multiTerms = new ArrayList<Term>();
-          int position = -1;
-          for (int i = 0; i < numTokens; i++) {
-            int positionIncrement = 1;
-            try {
-              boolean hasNext = buffer.incrementToken();
-              assert hasNext == true;
-              termAtt.fillBytesRef();
-              if (posIncrAtt != null) {
-                positionIncrement = posIncrAtt.getPositionIncrement();
-              }
-            } catch (IOException e) {
-              // safe to ignore, because we know the number of tokens
-            }
-
-            if (positionIncrement > 0 && multiTerms.size() > 0) {
-              if (enablePositionIncrements) {
-                mpq.add(multiTerms.toArray(new Term[0]),position);
-              } else {
-                mpq.add(multiTerms.toArray(new Term[0]));
-              }
-              multiTerms.clear();
-            }
-            position += positionIncrement;
-            multiTerms.add(new Term(field, BytesRef.deepCopyOf(bytes)));
-          }
-          if (enablePositionIncrements) {
-            mpq.add(multiTerms.toArray(new Term[0]),position);
-          } else {
-            mpq.add(multiTerms.toArray(new Term[0]));
-          }
-          return mpq;
-        }
-      }
-      else {
-        PhraseQuery pq = newPhraseQuery();
-        pq.setSlop(phraseSlop);
-        int position = -1;
-
-        for (int i = 0; i < numTokens; i++) {
-          int positionIncrement = 1;
-
-          try {
-            boolean hasNext = buffer.incrementToken();
-            assert hasNext == true;
-            termAtt.fillBytesRef();
-            if (posIncrAtt != null) {
-              positionIncrement = posIncrAtt.getPositionIncrement();
-            }
-          } catch (IOException e) {
-            // safe to ignore, because we know the number of tokens
-          }
-
-          if (enablePositionIncrements) {
-            position += positionIncrement;
-            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)),position);
-          } else {
-            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)));
-          }
-        }
-        return pq;
-      }
-    }
+    BooleanClause.Occur occur = operator == Operator.AND ? BooleanClause.Occur.MUST : BooleanClause.Occur.SHOULD;
+    return createFieldQuery(analyzer, occur, field, queryText, quoted || autoGeneratePhraseQueries, phraseSlop);
   }
 
 
@@ -741,15 +529,6 @@ public abstract class QueryParserBase implements CommonQueryParserConfiguration
   }
 
  /**
-  * Builds a new BooleanQuery instance
-  * @param disableCoord disable coord
-  * @return new BooleanQuery instance
-  */
-  protected BooleanQuery newBooleanQuery(boolean disableCoord) {
-    return new BooleanQuery(disableCoord);
-  }
-
- /**
   * Builds a new BooleanClause instance
   * @param q sub query
   * @param occur how this clause should occur when matching documents
@@ -760,31 +539,6 @@ public abstract class QueryParserBase implements CommonQueryParserConfiguration
   }
 
   /**
-   * Builds a new TermQuery instance
-   * @param term term
-   * @return new TermQuery instance
-   */
-  protected Query newTermQuery(Term term){
-    return new TermQuery(term);
-  }
-
-  /**
-   * Builds a new PhraseQuery instance
-   * @return new PhraseQuery instance
-   */
-  protected PhraseQuery newPhraseQuery(){
-    return new PhraseQuery();
-  }
-
-  /**
-   * Builds a new MultiPhraseQuery instance
-   * @return new MultiPhraseQuery instance
-   */
-  protected MultiPhraseQuery newMultiPhraseQuery(){
-    return new MultiPhraseQuery();
-  }
-
-  /**
    * Builds a new PrefixQuery instance
    * @param prefix Prefix term
    * @return new PrefixQuery instance
@@ -823,11 +577,11 @@ public abstract class QueryParserBase implements CommonQueryParserConfiguration
 
   // TODO: Should this be protected instead?
   private BytesRef analyzeMultitermTerm(String field, String part) {
-    return analyzeMultitermTerm(field, part, analyzer);
+    return analyzeMultitermTerm(field, part, getAnalyzer());
   }
 
   protected BytesRef analyzeMultitermTerm(String field, String part, Analyzer analyzerIn) {
-    if (analyzerIn == null) analyzerIn = analyzer;
+    if (analyzerIn == null) analyzerIn = getAnalyzer();
 
     try (TokenStream source = analyzerIn.tokenStream(field, part)) {
       source.reset();
diff --git a/solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase.java b/solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase.java
index 3c85e0b..b653f80 100644
--- a/solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase.java
+++ b/solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase.java
@@ -18,10 +18,6 @@
 package org.apache.solr.parser;
 
 import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.analysis.CachingTokenFilter;
-import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
-import org.apache.lucene.analysis.tokenattributes.TermToBytesRefAttribute;
 import org.apache.lucene.analysis.util.TokenFilterFactory;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.AutomatonQuery;
@@ -35,9 +31,8 @@ import org.apache.lucene.search.PhraseQuery;
 import org.apache.lucene.search.PrefixQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.RegexpQuery;
-import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.WildcardQuery;
-import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.QueryBuilder;
 import org.apache.lucene.util.ToStringUtils;
 import org.apache.lucene.util.Version;
 import org.apache.lucene.util.automaton.Automaton;
@@ -55,9 +50,7 @@ import org.apache.solr.schema.TextField;
 import org.apache.solr.search.QParser;
 import org.apache.solr.search.SyntaxError;
 
-import java.io.IOException;
 import java.io.StringReader;
-import java.util.ArrayList;
 import java.util.EnumSet;
 import java.util.HashMap;
 import java.util.List;
@@ -66,7 +59,7 @@ import java.util.Map;
 /** This class is overridden by QueryParser in QueryParser.jj
  * and acts to separate the majority of the Java code from the .jj grammar file. 
  */
-public abstract class SolrQueryParserBase {
+public abstract class SolrQueryParserBase extends QueryBuilder {
 
 
   static final int CONJ_NONE   = 0;
@@ -89,7 +82,6 @@ public abstract class SolrQueryParserBase {
 
   MultiTermQuery.RewriteMethod multiTermRewriteMethod = MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT;
   boolean allowLeadingWildcard = true;
-  boolean enablePositionIncrements = true;
 
   String defaultField;
   int phraseSlop = 0;     // default slop for phrase queries
@@ -101,7 +93,6 @@ public abstract class SolrQueryParserBase {
 
   protected IndexSchema schema;
   protected QParser parser;
-  protected Analyzer analyzer;
 
   // implementation detail - caching ReversedWildcardFilterFactory based on type
   private Map<FieldType, ReversedWildcardFilterFactory> leadingWildcards;
@@ -137,6 +128,7 @@ public abstract class SolrQueryParserBase {
 
   // So the generated QueryParser(CharStream) won't error out
   protected SolrQueryParserBase() {
+    super(null);
   }
   // the generated parser will create these in QueryParser
   public abstract void ReInit(CharStream stream);
@@ -147,7 +139,7 @@ public abstract class SolrQueryParserBase {
     this.schema = parser.getReq().getSchema();
     this.parser = parser;
     this.defaultField = defaultField;
-    this.analyzer = schema.getQueryAnalyzer();
+    setAnalyzer(schema.getQueryAnalyzer());
   }
 
     /** Parses a query string, returning a {@link org.apache.lucene.search.Query}.
@@ -282,27 +274,6 @@ public abstract class SolrQueryParserBase {
   }
 
   /**
-   * Set to <code>true</code> to enable position increments in result query.
-   * <p>
-   * When set, result phrase and multi-phrase queries will
-   * be aware of position increments.
-   * Useful when e.g. a StopFilter increases the position increment of
-   * the token that follows an omitted token.
-   * <p>
-   * Default: true.
-   */
-  public void setEnablePositionIncrements(boolean enable) {
-    this.enablePositionIncrements = enable;
-  }
-
-  /**
-   * @see #setEnablePositionIncrements(boolean)
-   */
-  public boolean getEnablePositionIncrements() {
-    return enablePositionIncrements;
-  }
-
-  /**
    * Sets the boolean operator of the QueryParser.
    * In default mode (<code>OR_OPERATOR</code>) terms without any modifiers
    * are considered optional: for example <code>capital of Hungary</code> is equal to
@@ -400,156 +371,8 @@ public abstract class SolrQueryParserBase {
 
 
   protected Query newFieldQuery(Analyzer analyzer, String field, String queryText, boolean quoted)  throws SyntaxError {
-    // Use the analyzer to get all the tokens, and then build a TermQuery,
-    // PhraseQuery, or nothing based on the term count
-
-    CachingTokenFilter buffer = null;
-    TermToBytesRefAttribute termAtt = null;
-    PositionIncrementAttribute posIncrAtt = null;
-    int numTokens = 0;
-    int positionCount = 0;
-    boolean severalTokensAtSamePosition = false;
-    
-    try (TokenStream source = analyzer.tokenStream(field, queryText)) {
-      source.reset();
-      buffer = new CachingTokenFilter(source);
-      buffer.reset();
-
-      if (buffer.hasAttribute(TermToBytesRefAttribute.class)) {
-        termAtt = buffer.getAttribute(TermToBytesRefAttribute.class);
-      }
-      if (buffer.hasAttribute(PositionIncrementAttribute.class)) {
-        posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);
-      }
-
-      boolean hasMoreTokens = false;
-      if (termAtt != null) {
-        try {
-          hasMoreTokens = buffer.incrementToken();
-          while (hasMoreTokens) {
-            numTokens++;
-            int positionIncrement = (posIncrAtt != null) ? posIncrAtt.getPositionIncrement() : 1;
-            if (positionIncrement != 0) {
-              positionCount += positionIncrement;
-            } else {
-              severalTokensAtSamePosition = true;
-            }
-            hasMoreTokens = buffer.incrementToken();
-          }
-        } catch (IOException e) {
-          // ignore
-        }
-      }
-    } catch (IOException e) {
-      throw new SyntaxError("Error analyzing query text", e);
-    }
-    
-    // rewind the buffer stream
-    buffer.reset();
-
-    BytesRef bytes = termAtt == null ? null : termAtt.getBytesRef();
-
-    if (numTokens == 0)
-      return null;
-    else if (numTokens == 1) {
-      try {
-        boolean hasNext = buffer.incrementToken();
-        assert hasNext == true;
-        termAtt.fillBytesRef();
-      } catch (IOException e) {
-        // safe to ignore, because we know the number of tokens
-      }
-      return newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes)));
-    } else {
-      if (severalTokensAtSamePosition || (!quoted && !autoGeneratePhraseQueries)) {
-        if (positionCount == 1 || (!quoted && !autoGeneratePhraseQueries)) {
-          // no phrase query:
-          BooleanQuery q = newBooleanQuery(positionCount == 1);
-
-          BooleanClause.Occur occur = positionCount > 1 && operator == AND_OPERATOR ?
-            BooleanClause.Occur.MUST : BooleanClause.Occur.SHOULD;
-
-          for (int i = 0; i < numTokens; i++) {
-            try {
-              boolean hasNext = buffer.incrementToken();
-              assert hasNext == true;
-              termAtt.fillBytesRef();
-            } catch (IOException e) {
-              // safe to ignore, because we know the number of tokens
-            }
-            Query currentQuery = newTermQuery(
-                new Term(field, BytesRef.deepCopyOf(bytes)));
-            q.add(currentQuery, occur);
-          }
-          return q;
-        }
-        else {
-          // phrase query:
-          MultiPhraseQuery mpq = newMultiPhraseQuery();
-          mpq.setSlop(phraseSlop);
-          List<Term> multiTerms = new ArrayList<Term>();
-          int position = -1;
-          for (int i = 0; i < numTokens; i++) {
-            int positionIncrement = 1;
-            try {
-              boolean hasNext = buffer.incrementToken();
-              assert hasNext == true;
-              termAtt.fillBytesRef();
-              if (posIncrAtt != null) {
-                positionIncrement = posIncrAtt.getPositionIncrement();
-              }
-            } catch (IOException e) {
-              // safe to ignore, because we know the number of tokens
-            }
-
-            if (positionIncrement > 0 && multiTerms.size() > 0) {
-              if (enablePositionIncrements) {
-                mpq.add(multiTerms.toArray(new Term[0]),position);
-              } else {
-                mpq.add(multiTerms.toArray(new Term[0]));
-              }
-              multiTerms.clear();
-            }
-            position += positionIncrement;
-            multiTerms.add(new Term(field, BytesRef.deepCopyOf(bytes)));
-          }
-          if (enablePositionIncrements) {
-            mpq.add(multiTerms.toArray(new Term[0]),position);
-          } else {
-            mpq.add(multiTerms.toArray(new Term[0]));
-          }
-          return mpq;
-        }
-      }
-      else {
-        PhraseQuery pq = newPhraseQuery();
-        pq.setSlop(phraseSlop);
-        int position = -1;
-
-        for (int i = 0; i < numTokens; i++) {
-          int positionIncrement = 1;
-
-          try {
-            boolean hasNext = buffer.incrementToken();
-            assert hasNext == true;
-            termAtt.fillBytesRef();
-            if (posIncrAtt != null) {
-              positionIncrement = posIncrAtt.getPositionIncrement();
-            }
-          } catch (IOException e) {
-            // safe to ignore, because we know the number of tokens
-          }
-
-          if (enablePositionIncrements) {
-            position += positionIncrement;
-            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)),position);
-          } else {
-            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)));
-          }
-        }
-        return pq;
-      }
-    }
+    BooleanClause.Occur occur = operator == Operator.AND ? BooleanClause.Occur.MUST : BooleanClause.Occur.SHOULD;
+    return createFieldQuery(analyzer, occur, field, queryText, quoted || autoGeneratePhraseQueries, phraseSlop);
   }
 
 
@@ -580,16 +403,6 @@ public abstract class SolrQueryParserBase {
     return query;
   }
 
-
- /**
-  * Builds a new BooleanQuery instance
-  * @param disableCoord disable coord
-  * @return new BooleanQuery instance
-  */
-  protected BooleanQuery newBooleanQuery(boolean disableCoord) {
-    return new BooleanQuery(disableCoord);
-  }
-
  /**
   * Builds a new BooleanClause instance
   * @param q sub query
@@ -601,31 +414,6 @@ public abstract class SolrQueryParserBase {
   }
 
   /**
-   * Builds a new TermQuery instance
-   * @param term term
-   * @return new TermQuery instance
-   */
-  protected Query newTermQuery(Term term){
-    return new TermQuery(term);
-  }
-
-  /**
-   * Builds a new PhraseQuery instance
-   * @return new PhraseQuery instance
-   */
-  protected PhraseQuery newPhraseQuery(){
-    return new PhraseQuery();
-  }
-
-  /**
-   * Builds a new MultiPhraseQuery instance
-   * @return new MultiPhraseQuery instance
-   */
-  protected MultiPhraseQuery newMultiPhraseQuery(){
-    return new MultiPhraseQuery();
-  }
-
-  /**
    * Builds a new PrefixQuery instance
    * @param prefix Prefix term
    * @return new PrefixQuery instance
@@ -947,14 +735,14 @@ public abstract class SolrQueryParserBase {
       FieldType ft = sf.getType();
       // delegate to type for everything except tokenized fields
       if (ft.isTokenized() && sf.indexed()) {
-        return newFieldQuery(analyzer, field, queryText, quoted || (ft instanceof TextField && ((TextField)ft).getAutoGeneratePhraseQueries()));
+        return newFieldQuery(getAnalyzer(), field, queryText, quoted || (ft instanceof TextField && ((TextField)ft).getAutoGeneratePhraseQueries()));
       } else {
         return sf.getType().getFieldQuery(parser, sf, queryText);
       }
     }
 
     // default to a normal field query
-    return newFieldQuery(analyzer, field, queryText, quoted);
+    return newFieldQuery(getAnalyzer(), field, queryText, quoted);
   }
 
 
diff --git a/solr/core/src/java/org/apache/solr/schema/TextField.java b/solr/core/src/java/org/apache/solr/schema/TextField.java
index 9646176..b7fd860 100644
--- a/solr/core/src/java/org/apache/solr/schema/TextField.java
+++ b/solr/core/src/java/org/apache/solr/schema/TextField.java
@@ -20,20 +20,15 @@ package org.apache.solr.schema;
 import org.apache.lucene.analysis.tokenattributes.TermToBytesRefAttribute;
 import org.apache.lucene.search.*;
 import org.apache.lucene.index.StorableField;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
-import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
-import org.apache.lucene.analysis.CachingTokenFilter;
 import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.QueryBuilder;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.search.QParser;
 
 import java.util.Map;
-import java.util.List;
-import java.util.ArrayList;
 import java.io.IOException;
 
 /** <code>TextField</code> is the basic type for configurable text analysis.
@@ -159,154 +154,8 @@ public class TextField extends FieldType {
 
 
   static Query parseFieldQuery(QParser parser, Analyzer analyzer, String field, String queryText) {
-    int phraseSlop = 0;
-
-    // most of the following code is taken from the Lucene QueryParser
-
-    // Use the analyzer to get all the tokens, and then build a TermQuery,
-    // PhraseQuery, or nothing based on the term count
-
-    CachingTokenFilter buffer = null;
-    CharTermAttribute termAtt = null;
-    PositionIncrementAttribute posIncrAtt = null;
-    int numTokens = 0;
-    int positionCount = 0;
-    boolean severalTokensAtSamePosition = false;
-
-    try (TokenStream source = analyzer.tokenStream(field, queryText)) {
-      source.reset();
-      buffer = new CachingTokenFilter(source);
-      
-      buffer.reset();
-      
-      if (buffer.hasAttribute(CharTermAttribute.class)) {
-        termAtt = buffer.getAttribute(CharTermAttribute.class);
-      }
-      if (buffer.hasAttribute(PositionIncrementAttribute.class)) {
-        posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);
-      }
-      
-      boolean hasMoreTokens = false;
-      if (termAtt != null) {
-        try {
-          hasMoreTokens = buffer.incrementToken();
-          while (hasMoreTokens) {
-            numTokens++;
-            int positionIncrement = (posIncrAtt != null) ? posIncrAtt.getPositionIncrement() : 1;
-            if (positionIncrement != 0) {
-              positionCount += positionIncrement;
-            } else {
-              severalTokensAtSamePosition = true;
-            }
-            hasMoreTokens = buffer.incrementToken();
-          }
-        } catch (IOException e) {
-          // ignore
-        }
-      }
-    } catch (IOException e) {
-      throw new RuntimeException(e);
-    }
-
-    // rewind the buffer stream
-    buffer.reset();
-
-    if (numTokens == 0)
-      return null;
-    else if (numTokens == 1) {
-      String term = null;
-      try {
-        boolean hasNext = buffer.incrementToken();
-        assert hasNext == true;
-        term = termAtt.toString();
-      } catch (IOException e) {
-        // safe to ignore, because we know the number of tokens
-      }
-      // return newTermQuery(new Term(field, term));
-      return new TermQuery(new Term(field, term));
-    } else {
-      if (severalTokensAtSamePosition) {
-        if (positionCount == 1) {
-          // no phrase query:
-          // BooleanQuery q = newBooleanQuery(true);
-          BooleanQuery q = new BooleanQuery(true);
-          for (int i = 0; i < numTokens; i++) {
-            String term = null;
-            try {
-              boolean hasNext = buffer.incrementToken();
-              assert hasNext == true;
-              term = termAtt.toString();
-            } catch (IOException e) {
-              // safe to ignore, because we know the number of tokens
-            }
-
-            // Query currentQuery = newTermQuery(new Term(field, term));
-            Query currentQuery = new TermQuery(new Term(field, term));
-            q.add(currentQuery, BooleanClause.Occur.SHOULD);
-          }
-          return q;
-        }
-        else {
-          // phrase query:
-          // MultiPhraseQuery mpq = newMultiPhraseQuery();
-          MultiPhraseQuery mpq = new MultiPhraseQuery();
-          mpq.setSlop(phraseSlop);
-          List multiTerms = new ArrayList();
-          int position = -1;
-          for (int i = 0; i < numTokens; i++) {
-            String term = null;
-            int positionIncrement = 1;
-            try {
-              boolean hasNext = buffer.incrementToken();
-              assert hasNext == true;
-              term = termAtt.toString();
-              if (posIncrAtt != null) {
-                positionIncrement = posIncrAtt.getPositionIncrement();
-              }
-            } catch (IOException e) {
-              // safe to ignore, because we know the number of tokens
-            }
-
-            if (positionIncrement > 0 && multiTerms.size() > 0) {
-              mpq.add((Term[])multiTerms.toArray(new Term[multiTerms.size()]),position);
-              multiTerms.clear();
-            }
-            position += positionIncrement;
-            multiTerms.add(new Term(field, term));
-          }
-          mpq.add((Term[])multiTerms.toArray(new Term[multiTerms.size()]),position);
-          return mpq;
-        }
-      }
-      else {
-        // PhraseQuery pq = newPhraseQuery();
-        PhraseQuery pq = new PhraseQuery();
-        pq.setSlop(phraseSlop);
-        int position = -1;
-
-
-        for (int i = 0; i < numTokens; i++) {
-          String term = null;
-          int positionIncrement = 1;
-
-          try {
-            boolean hasNext = buffer.incrementToken();
-            assert hasNext == true;
-            term = termAtt.toString();
-            if (posIncrAtt != null) {
-              positionIncrement = posIncrAtt.getPositionIncrement();
-            }
-          } catch (IOException e) {
-            // safe to ignore, because we know the number of tokens
-          }
-
-          position += positionIncrement;
-          pq.add(new Term(field, term),position);
-        }
-        return pq;
-      }
-    }
-
+    // note, this method always worked this way (but nothing calls it?) because it has no idea of quotes...
+    return new QueryBuilder(analyzer).createPhraseQuery(field, queryText);
   }
 
   public void setIsExplicitMultiTermAnalyzer(boolean isExplicitMultiTermAnalyzer) {

