GitDiffStart: 7c9d78a2c45e9bbe631f1759d1850e92bf87418c | Fri Aug 7 07:10:40 2015 +0000
diff --git a/lucene/CHANGES.txt b/lucene/CHANGES.txt
index 21d35d9..cba15fb 100644
--- a/lucene/CHANGES.txt
+++ b/lucene/CHANGES.txt
@@ -58,6 +58,11 @@ Optimizations
 * LUCENE-6720: ValueSourceScorer, returned from
   FunctionValues.getRangeScorer(), now uses TwoPhaseIterator. (David Smiley)
 
+Other
+
+* LUCENE-6417: Upgrade ANTLR used in expressions module to version 4.5.
+  (Jack Conradson via Uwe Schindler)
+
 ======================= Lucene 5.3.0 =======================
 
 New Features
diff --git a/lucene/expressions/build.xml b/lucene/expressions/build.xml
index 4efbb86..70d589a 100644
--- a/lucene/expressions/build.xml
+++ b/lucene/expressions/build.xml
@@ -51,7 +51,7 @@
   <target name="regenerate" depends="run-antlr"/>
 
   <target name="resolve-antlr" xmlns:ivy="antlib:org.apache.ivy.ant">
-    <ivy:cachepath organisation="org.antlr" module="antlr" revision="3.5"
+    <ivy:cachepath organisation="org.antlr" module="antlr4" revision="4.5"
                   inline="true" conf="default" type="jar" pathid="antlr.classpath"/>
   </target>
 
@@ -97,13 +97,15 @@
       <replace-value property="grammar.matchpath" value="${grammar.path}${file.separator}" from="\" to="\\"/>
       <property name="-grammar.relative.path" location="${grammar.path}" relative="true"/>
       <replace-value property="grammar.relative.path" value="${-grammar.relative.path}${file.separator}" from="${file.separator}" to="/"/>
-      <java classname="org.antlr.Tool" fork="true" failonerror="true" classpathref="antlr.classpath" taskname="antlr">
+      <java classname="org.antlr.v4.Tool" fork="true" failonerror="true" classpathref="antlr.classpath" taskname="antlr">
         <sysproperty key="file.encoding" value="UTF-8"/>
         <sysproperty key="user.language" value="en"/>
         <sysproperty key="user.country" value="US"/>
         <sysproperty key="user.variant" value=""/>
-        <arg value="-verbose"/>
-        <arg value="-make"/>
+        <arg value="-package"/>
+        <arg value="org.apache.lucene.expressions.@{package}"/>
+        <arg value="-no-listener"/>
+        <arg value="-visitor"/>
         <arg value="-o"/>
         <arg path="${grammar.path}"/>
         <arg path="${grammar.path}/@{grammar}.g"/>
@@ -111,18 +113,28 @@
       <!-- replace absolute paths by relative ones -->
       <replace file="${grammar.path}/@{grammar}Parser.java" token="${grammar.matchpath}" value="${grammar.relative.path}" encoding="UTF-8"/>
       <replace file="${grammar.path}/@{grammar}Lexer.java" token="${grammar.matchpath}" value="${grammar.relative.path}" encoding="UTF-8"/>
-      <!-- make the generated classes package private (it's an antlr option with 4.0) -->
+      <replace file="${grammar.path}/@{grammar}Visitor.java" token="${grammar.matchpath}" value="${grammar.relative.path}" encoding="UTF-8"/>
+      <replace file="${grammar.path}/@{grammar}BaseVisitor.java" token="${grammar.matchpath}" value="${grammar.relative.path}" encoding="UTF-8"/>
+      <!-- make the generated classes package private -->
       <replace file="${grammar.path}/@{grammar}Parser.java" token="public class @{grammar}Parser" value="class @{grammar}Parser" encoding="UTF-8"/>
       <replace file="${grammar.path}/@{grammar}Lexer.java" token="public class @{grammar}Lexer" value="class @{grammar}Lexer" encoding="UTF-8"/>
+      <replace file="${grammar.path}/@{grammar}Visitor.java" token="public interface @{grammar}Visitor" value="interface @{grammar}Visitor" encoding="UTF-8"/>
+      <replace file="${grammar.path}/@{grammar}BaseVisitor.java" token="public class @{grammar}BaseVisitor" value="class @{grammar}BaseVisitor" encoding="UTF-8"/>
       <!-- nuke timestamps in generated files -->
       <replaceregexp file="${grammar.path}/@{grammar}Parser.java" match=".*" replace="\/\/ ANTLR GENERATED CODE: DO NOT EDIT" encoding="UTF-8"/>
       <replaceregexp file="${grammar.path}/@{grammar}Lexer.java" match=".*" replace="\/\/ ANTLR GENERATED CODE: DO NOT EDIT" encoding="UTF-8"/>
+      <replaceregexp file="${grammar.path}/@{grammar}Visitor.java" match=".*" replace="\/\/ ANTLR GENERATED CODE: DO NOT EDIT" encoding="UTF-8"/>
+      <replaceregexp file="${grammar.path}/@{grammar}BaseVisitor.java" match=".*" replace="\/\/ ANTLR GENERATED CODE: DO NOT EDIT" encoding="UTF-8"/>
       <!-- remove tabs in antlr generated files -->
       <replaceregexp file="${grammar.path}/@{grammar}Parser.java" match="\t" flags="g" replace="  " encoding="UTF-8"/>
       <replaceregexp file="${grammar.path}/@{grammar}Lexer.java" match="\t" flags="g" replace="  " encoding="UTF-8"/>
+      <replaceregexp file="${grammar.path}/@{grammar}Visitor.java" match="\t" flags="g" replace="  " encoding="UTF-8"/>
+      <replaceregexp file="${grammar.path}/@{grammar}BaseVisitor.java" match="\t" flags="g" replace="  " encoding="UTF-8"/>
       <!-- fix line endings -->
       <fixcrlf file="${grammar.path}/@{grammar}Parser.java"/>
       <fixcrlf file="${grammar.path}/@{grammar}Lexer.java"/>
+      <fixcrlf file="${grammar.path}/@{grammar}Visitor.java"/>
+      <fixcrlf file="${grammar.path}/@{grammar}BaseVisitor.java"/>
     </sequential>
   </macrodef>
 </project>
diff --git a/lucene/expressions/ivy.xml b/lucene/expressions/ivy.xml
index ebe1ead..6065522 100644
--- a/lucene/expressions/ivy.xml
+++ b/lucene/expressions/ivy.xml
@@ -22,7 +22,7 @@
     <conf name="compile" transitive="false"/>
   </configurations>
   <dependencies>
-    <dependency org="org.antlr" name="antlr-runtime" rev="${/org.antlr/antlr-runtime}" conf="compile"/>
+    <dependency org="org.antlr" name="antlr4-runtime" rev="${/org.antlr/antlr4-runtime}" conf="compile"/>
     <dependency org="org.ow2.asm" name="asm" rev="${/org.ow2.asm/asm}" conf="compile"/>
     <dependency org="org.ow2.asm" name="asm-commons" rev="${/org.ow2.asm/asm-commons}" conf="compile"/>
     <exclude org="*" ext="*" matcher="regexp" type="${ivy.exclude.types}"/>
diff --git a/lucene/expressions/src/java/org/apache/lucene/expressions/js/Javascript.g b/lucene/expressions/src/java/org/apache/lucene/expressions/js/Javascript.g
index 2278765..e15d9bf 100644
--- a/lucene/expressions/src/java/org/apache/lucene/expressions/js/Javascript.g
+++ b/lucene/expressions/src/java/org/apache/lucene/expressions/js/Javascript.g
@@ -1,417 +1,89 @@
 /*
-    Javascript.g
-    An expression syntax based on ECMAScript/Javascript.
- 
-    This file was adapted from a general ECMAScript language definition at http://research.xebic.com/es3.
-    The major changes are the following:
-        * Stripped grammar of all parts not relevant for expression syntax.
-        * Stripped grammar of unicode character support.
-        * Added override function for customized error handling.
-        * Renaming of many grammar rules.
-        * Removal of annotations no longer relevant for stripped pieces.
-     
-    The Original Copyright Notice is the following: 
-    
-        Copyrights 2008-2009 Xebic Reasearch BV. All rights reserved..
-        Original work by Patrick Hulsmeijer.
- 
-        This ANTLR 3 LL(*) grammar is based on Ecma-262 3rd edition (JavaScript 1.5, JScript 5.5). 
-        The annotations refer to the "A Grammar Summary" section (e.g. A.1 Lexical Grammar)
-        and the numbers in parenthesis to the paragraph numbers (e.g. (7.8) ).
-        This document is best viewed with ANTLRWorks (www.antlr.org).
- 
-        Software License Agreement (BSD License)
- 
-        Copyright (c) 2008-2010, Xebic Research B.V.
-        All rights reserved.
- 
-        Redistribution and use of this software in source and binary forms, with or without modification, are
-        permitted provided that the following conditions are met:
- 
-            * Redistributions of source code must retain the above
-              copyright notice, this list of conditions and the
-              following disclaimer.
- 
-            * Redistributions in binary form must reproduce the above
-              copyright notice, this list of conditions and the
-              following disclaimer in the documentation and/or other
-              materials provided with the distribution.
- 
-            * Neither the name of Xebic Research B.V. nor the names of its
-              contributors may be used to endorse or promote products
-              derived from this software without specific prior
-              written permission of Xebic Research B.V.
- 
-        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
-        WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-        PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-        ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-        LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-        INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
-        TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
-        ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
-// ***********************************************************************
-// * ANTLRv3 grammar for Lucene expression language.
-// ***********************************************************************
- 
-grammar Javascript;
-
-options {
-    language = Java;
-    output = AST;
-    ASTLabelType=CommonTree;
-}
-
-tokens
-{
-    AT_LPAREN          = '('  ;
-    AT_RPAREN          = ')'  ;
-    AT_DOT             = '.'  ;
-    AT_COMMA           = ','  ;
-    AT_COLON           = ':'  ;
-
-    AT_COMP_LT         = '<'  ;
-    AT_COMP_LTE        = '<=' ;
-    AT_COMP_EQ         = '==' ;
-    AT_COMP_NEQ        = '!=' ;
-    AT_COMP_GTE        = '>=' ;
-    AT_COMP_GT         = '>'  ;
-
-    AT_BOOL_NOT        = '!'  ;
-    AT_BOOL_AND        = '&&' ;
-    AT_BOOL_OR         = '||' ;
-    AT_COND_QUE        = '?'  ;
-
-    AT_NEGATE                 ;
-    AT_ADD             = '+'  ;
-    AT_SUBTRACT        = '-'  ;
-    AT_MULTIPLY        = '*'  ;
-    AT_DIVIDE          = '/'  ;
-    AT_MODULO          = '%'  ;
-
-    AT_BIT_SHL         = '<<' ;
-    AT_BIT_SHR         = '>>' ;
-    AT_BIT_SHU         = '>>>';
-    AT_BIT_AND         = '&'  ;
-    AT_BIT_OR          = '|'  ;
-    AT_BIT_XOR         = '^'  ;
-    AT_BIT_NOT         = '~'  ;
-    
-    AT_CALL                   ;
-}
-
-// ***********************************************************************
-// * Java Package
-// ***********************************************************************
-
-@lexer::header {
-package org.apache.lucene.expressions.js;
-
-import java.text.ParseException;
-}
-
-@parser::header {
-package org.apache.lucene.expressions.js;
-    
-import java.text.ParseException;
-}
- 
-// ***********************************************************************
-// * Error Handling
-// ***********************************************************************
-
-@lexer::members {
-
-@Override
-public void displayRecognitionError(String[] tokenNames, RecognitionException re) {  
-    String message = " unexpected character '" + (char)re.c 
-                   + "' at position (" + re.charPositionInLine + ").";
-    ParseException parseException = new ParseException(message, re.charPositionInLine);
-    parseException.initCause(re);
-    throw new RuntimeException(parseException);
-}
-
-}
-
-@parser::members {
-
-@Override
-public void displayRecognitionError(String[] tokenNames, RecognitionException re) {
-    String message;
-
-    if (re.token == null) {
-        message = " unknown error (missing token).";
-    }
-    else if (re instanceof UnwantedTokenException) {
-        message = " extraneous " + getReadableTokenString(re.token)
-                +  " at position (" + re.charPositionInLine + ").";
-    }
-    else if (re instanceof MissingTokenException) {
-        message = " missing " + getReadableTokenString(re.token)
-                +  " at position (" + re.charPositionInLine + ").";
-    }
-    else if (re instanceof NoViableAltException) {
-        switch (re.token.getType()) {
-        case EOF:
-            message = " unexpected end of expression.";
-            break;
-        default:
-            message = " invalid sequence of tokens near " + getReadableTokenString(re.token)
-                    +  " at position (" + re.charPositionInLine + ").";
-            break;
-        }
-    }
-    else {
-        message = " unexpected token " + getReadableTokenString(re.token) 
-                +  " at position (" + re.charPositionInLine + ").";
-    }
-    ParseException parseException = new ParseException(message, re.charPositionInLine);
-    parseException.initCause(re);
-    throw new RuntimeException(parseException);
-}
-
-public static String getReadableTokenString(Token token) {
-    if (token == null) {
-        return "unknown token";
-    }
-
-    switch (token.getType()) {
-    case AT_LPAREN:
-        return "open parenthesis '('";
-    case AT_RPAREN:
-        return "close parenthesis ')'";
-    case AT_COMP_LT:
-        return "less than '<'";
-    case AT_COMP_LTE:
-        return "less than or equal '<='";
-    case AT_COMP_GT:
-        return "greater than '>'";
-    case AT_COMP_GTE:
-        return "greater than or equal '>='";
-    case AT_COMP_EQ:
-        return "equal '=='";
-    case AT_NEGATE:
-        return "negate '!='";
-    case AT_BOOL_NOT:
-        return "boolean not '!'";
-    case AT_BOOL_AND:
-        return "boolean and '&&'";
-    case AT_BOOL_OR:
-        return "boolean or '||'";
-    case AT_COND_QUE:
-        return "conditional '?'";
-    case AT_ADD:
-        return "addition '+'";
-    case AT_SUBTRACT:
-        return "subtraction '-'";
-    case AT_MULTIPLY:
-        return "multiplication '*'";
-    case AT_DIVIDE:
-        return "division '/'";
-    case AT_MODULO:
-        return "modulo '\%'";
-    case AT_BIT_SHL:
-        return "bit shift left '<<'";
-    case AT_BIT_SHR:
-        return "bit shift right '>>'";
-    case AT_BIT_SHU:
-        return "unsigned bit shift right '>>>'";
-    case AT_BIT_AND:
-        return "bitwise and '&'";
-    case AT_BIT_OR:
-        return "bitwise or '|'";
-    case AT_BIT_XOR:
-        return "bitwise xor '^'";
-    case AT_BIT_NOT:
-        return "bitwise not '~'";
-    case ID:
-        return "identifier '" + token.getText() + "'";
-    case DECIMAL:
-        return "decimal '" + token.getText() + "'";
-    case OCTAL:
-        return "octal '" + token.getText() + "'";
-    case HEX:
-        return "hex '" + token.getText() + "'";
-    case EOF:
-        return "end of expression";
-    default:
-        return "'" + token.getText() + "'";
-    }
-}
-
-}
-
-// ***********************************************************************
-// * Parser Rules
-// ***********************************************************************
-
-expression
-    : conditional EOF!
-    ;
-
-conditional
-    : logical_or (AT_COND_QUE^ conditional AT_COLON! conditional)?
-    ;
-
-logical_or
-    : logical_and (AT_BOOL_OR^ logical_and)*
-    ;
-
-logical_and
-    : bitwise_or (AT_BOOL_AND^ bitwise_or)*
-    ;
-
-bitwise_or
-    : bitwise_xor (AT_BIT_OR^ bitwise_xor)*
-    ;
-
-bitwise_xor
-    : bitwise_and (AT_BIT_XOR^ bitwise_and)*
-    ;
-
-bitwise_and
-    :  equality (AT_BIT_AND^ equality)*
-    ;
-
-equality
-    : relational ((AT_COMP_EQ | AT_COMP_NEQ)^ relational)*
-    ;
-
-relational
-    : shift ((AT_COMP_LT | AT_COMP_GT | AT_COMP_LTE | AT_COMP_GTE)^ shift)*
-    ;
-
-shift
-    : additive ((AT_BIT_SHL | AT_BIT_SHR | AT_BIT_SHU)^ additive)*
-    ;
-
-additive
-    : multiplicative ((AT_ADD | AT_SUBTRACT)^ multiplicative)*
-    ;
-
-multiplicative
-    : unary ((AT_MULTIPLY | AT_DIVIDE | AT_MODULO)^ unary)*
-    ;
-
-unary
-    : postfix
-    | AT_ADD! unary
-    | unary_operator^ unary
-    ;
-
-unary_operator
-    : AT_SUBTRACT -> AT_NEGATE
-    | AT_BIT_NOT
-    | AT_BOOL_NOT
-    ;
-
-postfix
-    : primary
-    | VARIABLE arguments -> ^(AT_CALL VARIABLE arguments?)
-    ;
-
-primary
-    : VARIABLE
-    | numeric
-    | AT_LPAREN! conditional AT_RPAREN!
-    ;
-
-arguments
-    : AT_LPAREN! (conditional (AT_COMMA! conditional)*)? AT_RPAREN!
-    ;
-
-numeric
-    : HEX | OCTAL | DECIMAL
-    ;
-
-// ***********************************************************************
-// * Lexer Rules
-// ***********************************************************************
-
-VARIABLE
-    : OBJECT (AT_DOT OBJECT)*
-    ;
-
-fragment
-OBJECT
-    : ID ARRAY*
-    ;
-
-fragment
-ARRAY
-    : '[' STRING ']'
-    | '[' DECIMALINTEGER ']'
-    ;
-
-fragment
-ID
-    : ('a'..'z'|'A'..'Z'|'_'|'$') ('a'..'z'|'A'..'Z'|'0'..'9'|'_'|'$')*
-    ;
-
-fragment
-STRING
-    : '\'' SINGLE_STRING_CHAR* '\'' { }
-    | '"' DOUBLE_STRING_CHAR* '"'
-    ;
-
-fragment
-SINGLE_STRING_CHAR
-    : '\\\''
-    | '\\\\'
-    | ~('\\'|'\'')
-    ;
-
-fragment
-DOUBLE_STRING_CHAR
-    : '\\"'
-    | '\\\\'
-    | ~('\\'|'"')
-    ;
-
-WS
-    : (' '|'\t'|'\n'|'\r')+ {skip();}
-    ;
-
-DECIMAL
-    : DECIMALINTEGER AT_DOT DECIMALDIGIT* EXPONENT?
-    | AT_DOT DECIMALDIGIT+ EXPONENT?
-    | DECIMALINTEGER EXPONENT?
-    ;
-
-OCTAL
-    : '0' OCTALDIGIT+
-    ;
-
-HEX
-    : ('0x'|'0X') HEXDIGIT+
-    ;
-
-fragment 
-DECIMALINTEGER
-    : '0'
-    | '1'..'9' DECIMALDIGIT*
-    ;
-
-fragment 
-EXPONENT
-    : ('e'|'E') ('+'|'-')? DECIMALDIGIT+
-    ;
+/*
+ * ANTLRv4 grammar for the Lucene expressions language
+ */
 
-fragment
-DECIMALDIGIT
-    : '0'..'9'
-    ;
+grammar Javascript;
 
-fragment 
-HEXDIGIT
-    : DECIMALDIGIT 
-    | 'a'..'f' 
-    | 'A'..'F'
+compile
+    : expression EOF
     ;
 
-fragment 
-OCTALDIGIT
-    : '0'..'7'
+expression
+    : LP expression RP                                          # precedence
+    | ( OCTAL | HEX | DECIMAL )                                 # numeric
+    | VARIABLE ( LP (expression (COMMA expression)*)? RP )?     # external
+    | ( BOOLNOT | BWNOT | ADD | SUB ) expression                # unary
+    | expression ( MUL | DIV | REM ) expression                 # muldiv
+    | expression ( ADD | SUB ) expression                       # addsub
+    | expression ( LSH | RSH | USH ) expression                 # bwshift
+    | expression ( LT | LTE | GT | GTE ) expression             # boolcomp
+    | expression ( EQ | NE ) expression                         # booleqne
+    | expression BWAND expression                               # bwand
+    | expression BWXOR expression                               # bwxor
+    | expression BWOR expression                                # bwor
+    | expression BOOLAND expression                             # booland
+    | expression BOOLOR expression                              # boolor
+    | <assoc=right> expression COND expression COLON expression # conditional
+    ;
+
+LP:      [(];
+RP:      [)];
+COMMA:   [,];
+BOOLNOT: [!];
+BWNOT:   [~];
+MUL:     [*];
+DIV:     [/];
+REM:     [%];
+ADD:     [+];
+SUB:     [\-];
+LSH:     '<<';
+RSH:     '>>';
+USH:     '>>>';
+LT:      [<];
+LTE:     '<=';
+GT:      [>];
+GTE:     '>=';
+EQ:      '==';
+NE:      '!=';
+BWAND:   [&];
+BWXOR:   [^];
+BWOR:    [|];
+BOOLAND: '&&';
+BOOLOR:  '||';
+COND:    [?];
+COLON:   [:];
+
+WS: [ \t\n\r]+ -> skip;
+
+VARIABLE: ID ARRAY* ( [.] ID ARRAY* )*;
+fragment ARRAY: [[] ( STRING | INTEGER ) [\]];
+fragment ID: [_$a-zA-Z] [_$a-zA-Z0-9]*;
+fragment STRING
+    : ['] ( '\\\'' | '\\\\' | ~[\\'] )*? [']
+    | ["] ( '\\"' | '\\\\' | ~[\\"] )*? ["]
+    ;
+
+OCTAL: [0] [0-7]+;
+HEX: [0] [xX] [0-9a-fA-F]+;
+DECIMAL: ( INTEGER ( [.] [0-9]* )? | [.] [0-9]+ ) ( [eE] [+\-]? [0-9]+ )?;
+fragment INTEGER
+    : [0]
+    | [1-9] [0-9]*
     ;
diff --git a/lucene/expressions/src/java/org/apache/lucene/expressions/js/Javascript.tokens b/lucene/expressions/src/java/org/apache/lucene/expressions/js/Javascript.tokens
index b52131d..01e31ee 100644
--- a/lucene/expressions/src/java/org/apache/lucene/expressions/js/Javascript.tokens
+++ b/lucene/expressions/src/java/org/apache/lucene/expressions/js/Javascript.tokens
@@ -1,72 +1,40 @@
-ARRAY=4
-AT_ADD=5
-AT_BIT_AND=6
-AT_BIT_NOT=7
-AT_BIT_OR=8
-AT_BIT_SHL=9
-AT_BIT_SHR=10
-AT_BIT_SHU=11
-AT_BIT_XOR=12
-AT_BOOL_AND=13
-AT_BOOL_NOT=14
-AT_BOOL_OR=15
-AT_CALL=16
-AT_COLON=17
-AT_COMMA=18
-AT_COMP_EQ=19
-AT_COMP_GT=20
-AT_COMP_GTE=21
-AT_COMP_LT=22
-AT_COMP_LTE=23
-AT_COMP_NEQ=24
-AT_COND_QUE=25
-AT_DIVIDE=26
-AT_DOT=27
-AT_LPAREN=28
-AT_MODULO=29
-AT_MULTIPLY=30
-AT_NEGATE=31
-AT_RPAREN=32
-AT_SUBTRACT=33
-DECIMAL=34
-DECIMALDIGIT=35
-DECIMALINTEGER=36
-DOUBLE_STRING_CHAR=37
-EXPONENT=38
-HEX=39
-HEXDIGIT=40
-ID=41
-OBJECT=42
-OCTAL=43
-OCTALDIGIT=44
-SINGLE_STRING_CHAR=45
-STRING=46
-VARIABLE=47
-WS=48
-'!'=14
-'!='=24
-'%'=29
-'&&'=13
-'&'=6
-'('=28
-')'=32
-'*'=30
-'+'=5
-','=18
-'-'=33
-'.'=27
-'/'=26
-':'=17
-'<'=22
-'<<'=9
-'<='=23
-'=='=19
-'>'=20
-'>='=21
-'>>'=10
-'>>>'=11
-'?'=25
-'^'=12
-'|'=8
-'||'=15
-'~'=7
+LP=1
+RP=2
+COMMA=3
+BOOLNOT=4
+BWNOT=5
+MUL=6
+DIV=7
+REM=8
+ADD=9
+SUB=10
+LSH=11
+RSH=12
+USH=13
+LT=14
+LTE=15
+GT=16
+GTE=17
+EQ=18
+NE=19
+BWAND=20
+BWXOR=21
+BWOR=22
+BOOLAND=23
+BOOLOR=24
+COND=25
+COLON=26
+WS=27
+VARIABLE=28
+OCTAL=29
+HEX=30
+DECIMAL=31
+'<<'=11
+'>>'=12
+'>>>'=13
+'<='=15
+'>='=17
+'=='=18
+'!='=19
+'&&'=23
+'||'=24
diff --git a/lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptBaseVisitor.java b/lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptBaseVisitor.java
new file mode 100644
index 0000000..2ddc90b
--- /dev/null
+++ b/lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptBaseVisitor.java
@@ -0,0 +1,127 @@
+// ANTLR GENERATED CODE: DO NOT EDIT
+package org.apache.lucene.expressions.js;
+import org.antlr.v4.runtime.misc.NotNull;
+import org.antlr.v4.runtime.tree.AbstractParseTreeVisitor;
+
+/**
+ * This class provides an empty implementation of {@link JavascriptVisitor},
+ * which can be extended to create a visitor which only needs to handle a subset
+ * of the available methods.
+ *
+ * @param <T> The return type of the visit operation. Use {@link Void} for
+ * operations with no return type.
+ */
+class JavascriptBaseVisitor<T> extends AbstractParseTreeVisitor<T> implements JavascriptVisitor<T> {
+  /**
+   * {@inheritDoc}
+   *
+   * <p>The default implementation returns the result of calling
+   * {@link #visitChildren} on {@code ctx}.</p>
+   */
+  @Override public T visitCompile(JavascriptParser.CompileContext ctx) { return visitChildren(ctx); }
+  /**
+   * {@inheritDoc}
+   *
+   * <p>The default implementation returns the result of calling
+   * {@link #visitChildren} on {@code ctx}.</p>
+   */
+  @Override public T visitConditional(JavascriptParser.ConditionalContext ctx) { return visitChildren(ctx); }
+  /**
+   * {@inheritDoc}
+   *
+   * <p>The default implementation returns the result of calling
+   * {@link #visitChildren} on {@code ctx}.</p>
+   */
+  @Override public T visitBoolor(JavascriptParser.BoolorContext ctx) { return visitChildren(ctx); }
+  /**
+   * {@inheritDoc}
+   *
+   * <p>The default implementation returns the result of calling
+   * {@link #visitChildren} on {@code ctx}.</p>
+   */
+  @Override public T visitBoolcomp(JavascriptParser.BoolcompContext ctx) { return visitChildren(ctx); }
+  /**
+   * {@inheritDoc}
+   *
+   * <p>The default implementation returns the result of calling
+   * {@link #visitChildren} on {@code ctx}.</p>
+   */
+  @Override public T visitNumeric(JavascriptParser.NumericContext ctx) { return visitChildren(ctx); }
+  /**
+   * {@inheritDoc}
+   *
+   * <p>The default implementation returns the result of calling
+   * {@link #visitChildren} on {@code ctx}.</p>
+   */
+  @Override public T visitAddsub(JavascriptParser.AddsubContext ctx) { return visitChildren(ctx); }
+  /**
+   * {@inheritDoc}
+   *
+   * <p>The default implementation returns the result of calling
+   * {@link #visitChildren} on {@code ctx}.</p>
+   */
+  @Override public T visitUnary(JavascriptParser.UnaryContext ctx) { return visitChildren(ctx); }
+  /**
+   * {@inheritDoc}
+   *
+   * <p>The default implementation returns the result of calling
+   * {@link #visitChildren} on {@code ctx}.</p>
+   */
+  @Override public T visitPrecedence(JavascriptParser.PrecedenceContext ctx) { return visitChildren(ctx); }
+  /**
+   * {@inheritDoc}
+   *
+   * <p>The default implementation returns the result of calling
+   * {@link #visitChildren} on {@code ctx}.</p>
+   */
+  @Override public T visitMuldiv(JavascriptParser.MuldivContext ctx) { return visitChildren(ctx); }
+  /**
+   * {@inheritDoc}
+   *
+   * <p>The default implementation returns the result of calling
+   * {@link #visitChildren} on {@code ctx}.</p>
+   */
+  @Override public T visitExternal(JavascriptParser.ExternalContext ctx) { return visitChildren(ctx); }
+  /**
+   * {@inheritDoc}
+   *
+   * <p>The default implementation returns the result of calling
+   * {@link #visitChildren} on {@code ctx}.</p>
+   */
+  @Override public T visitBwshift(JavascriptParser.BwshiftContext ctx) { return visitChildren(ctx); }
+  /**
+   * {@inheritDoc}
+   *
+   * <p>The default implementation returns the result of calling
+   * {@link #visitChildren} on {@code ctx}.</p>
+   */
+  @Override public T visitBwor(JavascriptParser.BworContext ctx) { return visitChildren(ctx); }
+  /**
+   * {@inheritDoc}
+   *
+   * <p>The default implementation returns the result of calling
+   * {@link #visitChildren} on {@code ctx}.</p>
+   */
+  @Override public T visitBooland(JavascriptParser.BoolandContext ctx) { return visitChildren(ctx); }
+  /**
+   * {@inheritDoc}
+   *
+   * <p>The default implementation returns the result of calling
+   * {@link #visitChildren} on {@code ctx}.</p>
+   */
+  @Override public T visitBwxor(JavascriptParser.BwxorContext ctx) { return visitChildren(ctx); }
+  /**
+   * {@inheritDoc}
+   *
+   * <p>The default implementation returns the result of calling
+   * {@link #visitChildren} on {@code ctx}.</p>
+   */
+  @Override public T visitBwand(JavascriptParser.BwandContext ctx) { return visitChildren(ctx); }
+  /**
+   * {@inheritDoc}
+   *
+   * <p>The default implementation returns the result of calling
+   * {@link #visitChildren} on {@code ctx}.</p>
+   */
+  @Override public T visitBooleqne(JavascriptParser.BooleqneContext ctx) { return visitChildren(ctx); }
+}
diff --git a/lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler.java b/lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler.java
index 9e475f4..b23d86a 100644
--- a/lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler.java
+++ b/lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler.java
@@ -24,18 +24,18 @@ import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.nio.charset.StandardCharsets;
 import java.text.ParseException;
+import java.util.ArrayDeque;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.Deque;
 import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Properties;
 
-import org.antlr.runtime.ANTLRStringStream;
-import org.antlr.runtime.CharStream;
-import org.antlr.runtime.CommonTokenStream;
-import org.antlr.runtime.RecognitionException;
-import org.antlr.runtime.tree.Tree;
+import org.antlr.v4.runtime.ANTLRInputStream;
+import org.antlr.v4.runtime.CommonTokenStream;
+import org.antlr.v4.runtime.tree.ParseTree;
 import org.apache.lucene.expressions.Expression;
 import org.apache.lucene.queries.function.FunctionValues;
 import org.apache.lucene.util.IOUtils;
@@ -45,6 +45,8 @@ import org.objectweb.asm.Opcodes;
 import org.objectweb.asm.Type;
 import org.objectweb.asm.commons.GeneratorAdapter;
 
+import static org.apache.lucene.expressions.js.JavascriptParser.ExpressionContext;
+
 /**
  * An expression compiler for javascript expressions.
  * <p>
@@ -73,7 +75,6 @@ import org.objectweb.asm.commons.GeneratorAdapter;
  * @lucene.experimental
  */
 public class JavascriptCompiler {
-
   static final class Loader extends ClassLoader {
     Loader(ClassLoader parent) {
       super(parent);
@@ -91,13 +92,14 @@ public class JavascriptCompiler {
   private static final String COMPILED_EXPRESSION_CLASS = JavascriptCompiler.class.getName() + "$CompiledExpression";
   private static final String COMPILED_EXPRESSION_INTERNAL = COMPILED_EXPRESSION_CLASS.replace('.', '/');
   
-  private static final Type EXPRESSION_TYPE = Type.getType(Expression.class);
-  private static final Type FUNCTION_VALUES_TYPE = Type.getType(FunctionValues.class);
+  static final Type EXPRESSION_TYPE = Type.getType(Expression.class);
+  static final Type FUNCTION_VALUES_TYPE = Type.getType(FunctionValues.class);
 
   private static final org.objectweb.asm.commons.Method
     EXPRESSION_CTOR = getMethod("void <init>(String, String[])"),
-    EVALUATE_METHOD = getMethod("double evaluate(int, " + FunctionValues.class.getName() + "[])"),
-    DOUBLE_VAL_METHOD = getMethod("double doubleVal(int)");
+    EVALUATE_METHOD = getMethod("double evaluate(int, " + FunctionValues.class.getName() + "[])");
+
+  static final org.objectweb.asm.commons.Method DOUBLE_VAL_METHOD = getMethod("double doubleVal(int)");
   
   // to work around import clash:
   private static org.objectweb.asm.commons.Method getMethod(String method) {
@@ -108,12 +110,12 @@ public class JavascriptCompiler {
   // rcmuir: "If your ranking function is that large you need to check yourself into a mental institution!"
   private static final int MAX_SOURCE_LENGTH = 16384;
   
-  private final String sourceText;
-  private final Map<String, Integer> externalsMap = new LinkedHashMap<>();
-  private final ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);
-  private GeneratorAdapter gen;
+  final String sourceText;
+  final Map<String, Integer> externalsMap = new LinkedHashMap<>();
+  final ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);
+  GeneratorAdapter gen;
   
-  private final Map<String,Method> functions;
+  final Map<String,Method> functions;
   
   /**
    * Compiles the given expression.
@@ -188,21 +190,45 @@ public class JavascriptCompiler {
    */
   private Expression compileExpression(ClassLoader parent) throws ParseException {
     try {
-      Tree antlrTree = getAntlrComputedExpressionTree();
-      
+      ParseTree parseTree = getAntlrParseTree();
+
       beginCompile();
-      recursiveCompile(antlrTree, Type.DOUBLE_TYPE);
+      internalCompile(parseTree);
       endCompile();
       
-      Class<? extends Expression> evaluatorClass = new Loader(parent)
+      final Class<? extends Expression> evaluatorClass = new Loader(parent)
         .define(COMPILED_EXPRESSION_CLASS, classWriter.toByteArray());
-      Constructor<? extends Expression> constructor = evaluatorClass.getConstructor(String.class, String[].class);
+      final Constructor<? extends Expression> constructor = evaluatorClass.getConstructor(String.class, String[].class);
+
       return constructor.newInstance(sourceText, externalsMap.keySet().toArray(new String[externalsMap.size()]));
     } catch (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException exception) {
       throw new IllegalStateException("An internal error occurred attempting to compile the expression (" + sourceText + ").", exception);
     }
   }
-  
+
+  /**
+   * Parses the sourceText into an ANTLR 4 parse tree
+   *
+   * @return The ANTLR parse tree
+   * @throws ParseException on failure to parse
+   */
+  private ParseTree getAntlrParseTree() throws ParseException {
+    try {
+      final ANTLRInputStream antlrInputStream = new ANTLRInputStream(sourceText);
+      final JavascriptErrorHandlingLexer javascriptLexer = new JavascriptErrorHandlingLexer(antlrInputStream);
+      javascriptLexer.removeErrorListeners();
+      final JavascriptParser javascriptParser = new JavascriptParser(new CommonTokenStream(javascriptLexer));
+      javascriptParser.removeErrorListeners();
+      javascriptParser.setErrorHandler(new JavascriptParserErrorStrategy());
+      return javascriptParser.compile();
+    } catch (RuntimeException re) {
+      if (re.getCause() instanceof ParseException) {
+        throw (ParseException)re.getCause();
+      }
+      throw re;
+    }
+  }
+
   private void beginCompile() {
     classWriter.visit(CLASSFILE_VERSION,
         Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL | Opcodes.ACC_SYNTHETIC,
@@ -223,253 +249,431 @@ public class JavascriptCompiler {
     gen = new GeneratorAdapter(Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC,
         EVALUATE_METHOD, null, null, classWriter);
   }
-  
-  private void recursiveCompile(Tree current, Type expected) {
-    int type = current.getType();
-    String text = current.getText();
-    
-    switch (type) {
-      case JavascriptParser.AT_CALL:
-        Tree identifier = current.getChild(0);
-        String call = identifier.getText();
-        int arguments = current.getChildCount() - 1;
-        
-        Method method = functions.get(call);
-        if (method == null && (arguments > 0 || !call.contains("."))) {
-          throw new IllegalArgumentException("Unrecognized function call (" + call + ").");
-        } else if (method != null) {
+
+  // internalCompile is used to create an anonymous inner class around the ANTLR listener
+  // to completely hide the implementation details of expression compilation
+  private void internalCompile(ParseTree parseTree) {
+    new JavascriptBaseVisitor<Void>() {
+      private final Deque<Type> typeStack = new ArrayDeque<>();
+
+      /**
+       * For internal compiler use only, do NOT use
+       */
+      @Override
+      public Void visitCompile(JavascriptParser.CompileContext ctx) {
+        typeStack.push(Type.DOUBLE_TYPE);
+        visit(ctx.expression());
+        typeStack.pop();
+
+        return null;
+      }
+
+      /**
+       * For internal compiler use only, do NOT use
+       */
+      @Override
+      public Void visitPrecedence(JavascriptParser.PrecedenceContext ctx) {
+        visit(ctx.expression());
+
+        return null;
+      }
+
+      /**
+       * For internal compiler use only, do NOT use
+       */
+      @Override
+      public Void visitNumeric(JavascriptParser.NumericContext ctx) {
+        if (ctx.HEX() != null) {
+          pushLong(Long.parseLong(ctx.HEX().getText().substring(2), 16));
+        } else if (ctx.OCTAL() != null) {
+          pushLong(Long.parseLong(ctx.OCTAL().getText().substring(1), 8));
+        } else if (ctx.DECIMAL() != null) {
+          gen.push(Double.parseDouble(ctx.DECIMAL().getText()));
+          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());
+        } else {
+          throw new IllegalStateException("Unknown operation specified: " + ctx.getText());
+        }
+
+        return null;
+      }
+
+      /**
+       * For internal compiler use only, do NOT use
+       */
+      @Override
+      public Void visitExternal(JavascriptParser.ExternalContext ctx) {
+        String text = ctx.VARIABLE().getText();
+        int arguments = ctx.expression().size();
+        boolean parens = ctx.LP() != null && ctx.RP() != null;
+        Method method = parens ? functions.get(text) : null;
+
+        if (method != null) {
           int arity = method.getParameterTypes().length;
+
           if (arguments != arity) {
-            throw new IllegalArgumentException("Expected (" + arity + ") arguments for function call (" +
-                call + "), but found (" + arguments + ").");
+            throw new IllegalArgumentException(
+                "Expected (" + arity + ") arguments for function call (" + text + "), but found (" + arguments + ").");
           }
 
-          for (int argument = 1; argument <= arguments; ++argument) {
-            recursiveCompile(current.getChild(argument), Type.DOUBLE_TYPE);
+          typeStack.push(Type.DOUBLE_TYPE);
+
+          for (int argument = 0; argument < arguments; ++argument) {
+            visit(ctx.expression(argument));
           }
 
+          typeStack.pop();
+
           gen.invokeStatic(Type.getType(method.getDeclaringClass()),
               org.objectweb.asm.commons.Method.getMethod(method));
 
-          gen.cast(Type.DOUBLE_TYPE, expected);
-          break;
+          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());
+        } else if (!parens || arguments == 0 && text.contains(".")) {
+          int index;
+
+          text = normalizeQuotes(ctx.getText());
+
+          if (externalsMap.containsKey(text)) {
+            index = externalsMap.get(text);
+          } else {
+            index = externalsMap.size();
+            externalsMap.put(text, index);
+          }
+
+          gen.loadArg(1);
+          gen.push(index);
+          gen.arrayLoad(FUNCTION_VALUES_TYPE);
+          gen.loadArg(0);
+          gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);
+          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());
+        } else {
+          throw new IllegalArgumentException("Unrecognized function call (" + text + ").");
+        }
+
+        return null;
+      }
+
+      /**
+       * For internal compiler use only, do NOT use
+       */
+      @Override
+      public Void visitUnary(JavascriptParser.UnaryContext ctx) {
+        if (ctx.BOOLNOT() != null) {
+          Label labelNotTrue = new Label();
+          Label labelNotReturn = new Label();
+
+          typeStack.push(Type.INT_TYPE);
+          visit(ctx.expression());
+          typeStack.pop();
+          gen.visitJumpInsn(Opcodes.IFEQ, labelNotTrue);
+          pushBoolean(false);
+          gen.goTo(labelNotReturn);
+          gen.visitLabel(labelNotTrue);
+          pushBoolean(true);
+          gen.visitLabel(labelNotReturn);
+
+        } else if (ctx.BWNOT() != null) {
+          typeStack.push(Type.LONG_TYPE);
+          visit(ctx.expression());
+          typeStack.pop();
+          gen.push(-1L);
+          gen.visitInsn(Opcodes.LXOR);
+          gen.cast(Type.LONG_TYPE, typeStack.peek());
+
+        } else if (ctx.ADD() != null) {
+          visit(ctx.expression());
+
+        } else if (ctx.SUB() != null) {
+          typeStack.push(Type.DOUBLE_TYPE);
+          visit(ctx.expression());
+          typeStack.pop();
+          gen.visitInsn(Opcodes.DNEG);
+          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());
+
+        } else {
+          throw new IllegalStateException("Unknown operation specified: " + ctx.getText());
+        }
+
+        return null;
+      }
+
+      /**
+       * For internal compiler use only, do NOT use
+       */
+      @Override
+      public Void visitMuldiv(JavascriptParser.MuldivContext ctx) {
+        int opcode;
+
+        if (ctx.MUL() != null) {
+          opcode = Opcodes.DMUL;
+        } else if (ctx.DIV() != null) {
+          opcode = Opcodes.DDIV;
+        } else if (ctx.REM() != null) {
+          opcode = Opcodes.DREM;
         } else {
-          text = call + "()";
-          // intentionally fall through to the variable case to allow this non-static
-          // method to be forwarded to the bindings for processing
+          throw new IllegalStateException("Unknown operation specified: " + ctx.getText());
         }
-      case JavascriptParser.VARIABLE:
-        int index;
 
-        text = normalizeQuotes(text);
-        
-        if (externalsMap.containsKey(text)) {
-          index = externalsMap.get(text);
+        pushArith(opcode, ctx.expression(0), ctx.expression(1));
+
+        return null;
+      }
+
+      /**
+       * For internal compiler use only, do NOT use
+       */
+      @Override
+      public Void visitAddsub(JavascriptParser.AddsubContext ctx) {
+        int opcode;
+
+        if (ctx.ADD() != null) {
+          opcode = Opcodes.DADD;
+        } else if (ctx.SUB() != null) {
+          opcode = Opcodes.DSUB;
+        } else {
+          throw new IllegalStateException("Unknown operation specified: " + ctx.getText());
+        }
+
+        pushArith(opcode, ctx.expression(0), ctx.expression(1));
+
+        return null;
+      }
+
+      /**
+       * For internal compiler use only, do NOT use
+       */
+      @Override
+      public Void visitBwshift(JavascriptParser.BwshiftContext ctx) {
+        int opcode;
+
+        if (ctx.LSH() != null) {
+          opcode = Opcodes.LSHL;
+        } else if (ctx.RSH() != null) {
+          opcode = Opcodes.LSHR;
+        } else if (ctx.USH() != null) {
+          opcode = Opcodes.LUSHR;
+        } else {
+          throw new IllegalStateException("Unknown operation specified: " + ctx.getText());
+        }
+
+        pushShift(opcode, ctx.expression(0), ctx.expression(1));
+
+        return null;
+      }
+
+      /**
+       * For internal compiler use only, do NOT use
+       */
+      @Override
+      public Void visitBoolcomp(JavascriptParser.BoolcompContext ctx) {
+        int opcode;
+
+        if (ctx.LT() != null) {
+          opcode = GeneratorAdapter.LT;
+        } else if (ctx.LTE() != null) {
+          opcode = GeneratorAdapter.LE;
+        } else if (ctx.GT() != null) {
+          opcode = GeneratorAdapter.GT;
+        } else if (ctx.GTE() != null) {
+          opcode = GeneratorAdapter.GE;
         } else {
-          index = externalsMap.size();
-          externalsMap.put(text, index);
+          throw new IllegalStateException("Unknown operation specified: " + ctx.getText());
         }
-        
-        gen.loadArg(1);
-        gen.push(index);
-        gen.arrayLoad(FUNCTION_VALUES_TYPE);
-        gen.loadArg(0);
-        gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);
-        gen.cast(Type.DOUBLE_TYPE, expected);
-        break;
-      case JavascriptParser.HEX:
-        pushLong(expected, Long.parseLong(text.substring(2), 16));
-        break;
-      case JavascriptParser.OCTAL:
-        pushLong(expected, Long.parseLong(text.substring(1), 8));
-        break;
-      case JavascriptParser.DECIMAL:
-        gen.push(Double.parseDouble(text));
-        gen.cast(Type.DOUBLE_TYPE, expected);
-        break;
-      case JavascriptParser.AT_NEGATE:
-        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);
-        gen.visitInsn(Opcodes.DNEG);
-        gen.cast(Type.DOUBLE_TYPE, expected);
-        break;
-      case JavascriptParser.AT_ADD:
-        pushArith(Opcodes.DADD, current, expected);
-        break;
-      case JavascriptParser.AT_SUBTRACT:
-        pushArith(Opcodes.DSUB, current, expected);
-        break;
-      case JavascriptParser.AT_MULTIPLY:
-        pushArith(Opcodes.DMUL, current, expected);
-        break;
-      case JavascriptParser.AT_DIVIDE:
-        pushArith(Opcodes.DDIV, current, expected);
-        break;
-      case JavascriptParser.AT_MODULO:
-        pushArith(Opcodes.DREM, current, expected);
-        break;
-      case JavascriptParser.AT_BIT_SHL:
-        pushShift(Opcodes.LSHL, current, expected);
-        break;
-      case JavascriptParser.AT_BIT_SHR:
-        pushShift(Opcodes.LSHR, current, expected);
-        break;
-      case JavascriptParser.AT_BIT_SHU:
-        pushShift(Opcodes.LUSHR, current, expected);
-        break;
-      case JavascriptParser.AT_BIT_AND:
-        pushBitwise(Opcodes.LAND, current, expected);
-        break;
-      case JavascriptParser.AT_BIT_OR:
-        pushBitwise(Opcodes.LOR, current, expected);           
-        break;
-      case JavascriptParser.AT_BIT_XOR:
-        pushBitwise(Opcodes.LXOR, current, expected);           
-        break;
-      case JavascriptParser.AT_BIT_NOT:
-        recursiveCompile(current.getChild(0), Type.LONG_TYPE);
-        gen.push(-1L);
-        gen.visitInsn(Opcodes.LXOR);
-        gen.cast(Type.LONG_TYPE, expected);
-        break;
-      case JavascriptParser.AT_COMP_EQ:
-        pushCond(GeneratorAdapter.EQ, current, expected);
-        break;
-      case JavascriptParser.AT_COMP_NEQ:
-        pushCond(GeneratorAdapter.NE, current, expected);
-        break;
-      case JavascriptParser.AT_COMP_LT:
-        pushCond(GeneratorAdapter.LT, current, expected);
-        break;
-      case JavascriptParser.AT_COMP_GT:
-        pushCond(GeneratorAdapter.GT, current, expected);
-        break;
-      case JavascriptParser.AT_COMP_LTE:
-        pushCond(GeneratorAdapter.LE, current, expected);
-        break;
-      case JavascriptParser.AT_COMP_GTE:
-        pushCond(GeneratorAdapter.GE, current, expected);
-        break;
-      case JavascriptParser.AT_BOOL_NOT:
-        Label labelNotTrue = new Label();
-        Label labelNotReturn = new Label();
-        
-        recursiveCompile(current.getChild(0), Type.INT_TYPE);
-        gen.visitJumpInsn(Opcodes.IFEQ, labelNotTrue);
-        pushBoolean(expected, false);
-        gen.goTo(labelNotReturn);
-        gen.visitLabel(labelNotTrue);
-        pushBoolean(expected, true);
-        gen.visitLabel(labelNotReturn);
-        break;
-      case JavascriptParser.AT_BOOL_AND:
+
+        pushCond(opcode, ctx.expression(0), ctx.expression(1));
+
+        return null;
+      }
+
+      /**
+       * For internal compiler use only, do NOT use
+       */
+      @Override
+      public Void visitBooleqne(JavascriptParser.BooleqneContext ctx) {
+        int opcode;
+
+        if (ctx.EQ() != null) {
+          opcode = GeneratorAdapter.EQ;
+        } else if (ctx.NE() != null) {
+          opcode = GeneratorAdapter.NE;
+        } else {
+          throw new IllegalStateException("Unknown operation specified: " + ctx.getText());
+        }
+
+        pushCond(opcode, ctx.expression(0), ctx.expression(1));
+
+        return null;
+      }
+
+      /**
+       * For internal compiler use only, do NOT use
+       */
+      @Override
+      public Void visitBwand(JavascriptParser.BwandContext ctx) {
+        pushBitwise(Opcodes.LAND, ctx.expression(0), ctx.expression(1));
+
+        return null;
+      }
+
+      /**
+       * For internal compiler use only, do NOT use
+       */
+      @Override
+      public Void visitBwxor(JavascriptParser.BwxorContext ctx) {
+        pushBitwise(Opcodes.LXOR, ctx.expression(0), ctx.expression(1));
+
+        return null;
+      }
+
+      /**
+       * For internal compiler use only, do NOT use
+       */
+      @Override
+      public Void visitBwor(JavascriptParser.BworContext ctx) {
+        pushBitwise(Opcodes.LOR, ctx.expression(0), ctx.expression(1));
+
+        return null;
+      }
+
+      /**
+       * For internal compiler use only, do NOT use
+       */
+      @Override
+      public Void visitBooland(JavascriptParser.BoolandContext ctx) {
         Label andFalse = new Label();
         Label andEnd = new Label();
-        
-        recursiveCompile(current.getChild(0), Type.INT_TYPE);
+
+        typeStack.push(Type.INT_TYPE);
+        visit(ctx.expression(0));
         gen.visitJumpInsn(Opcodes.IFEQ, andFalse);
-        recursiveCompile(current.getChild(1), Type.INT_TYPE);
+        visit(ctx.expression(1));
         gen.visitJumpInsn(Opcodes.IFEQ, andFalse);
-        pushBoolean(expected, true);
+        typeStack.pop();
+        pushBoolean(true);
         gen.goTo(andEnd);
         gen.visitLabel(andFalse);
-        pushBoolean(expected, false);
+        pushBoolean(false);
         gen.visitLabel(andEnd);
-        break;
-      case JavascriptParser.AT_BOOL_OR:
+
+        return null;
+      }
+
+      /**
+       * For internal compiler use only, do NOT use
+       */
+      @Override
+      public Void visitBoolor(JavascriptParser.BoolorContext ctx) {
         Label orTrue = new Label();
         Label orEnd = new Label();
-        
-        recursiveCompile(current.getChild(0), Type.INT_TYPE);
+
+        typeStack.push(Type.INT_TYPE);
+        visit(ctx.expression(0));
         gen.visitJumpInsn(Opcodes.IFNE, orTrue);
-        recursiveCompile(current.getChild(1), Type.INT_TYPE);
+        visit(ctx.expression(1));
         gen.visitJumpInsn(Opcodes.IFNE, orTrue);
-        pushBoolean(expected, false);
+        typeStack.pop();
+        pushBoolean(false);
         gen.goTo(orEnd);
         gen.visitLabel(orTrue);
-        pushBoolean(expected, true);
+        pushBoolean(true);
         gen.visitLabel(orEnd);
-        break;
-      case JavascriptParser.AT_COND_QUE:
+
+        return null;
+      }
+
+      /**
+       * For internal compiler use only, do NOT use
+       */
+      @Override
+      public Void visitConditional(JavascriptParser.ConditionalContext ctx) {
         Label condFalse = new Label();
         Label condEnd = new Label();
-        
-        recursiveCompile(current.getChild(0), Type.INT_TYPE);
+
+        typeStack.push(Type.INT_TYPE);
+        visit(ctx.expression(0));
+        typeStack.pop();
         gen.visitJumpInsn(Opcodes.IFEQ, condFalse);
-        recursiveCompile(current.getChild(1), expected);
+        visit(ctx.expression(1));
         gen.goTo(condEnd);
         gen.visitLabel(condFalse);
-        recursiveCompile(current.getChild(2), expected);
+        visit(ctx.expression(2));
         gen.visitLabel(condEnd);
-        break;
-      default:
-        throw new IllegalStateException("Unknown operation specified: (" + current.getText() + ").");
-    }
-  }
 
-  private void pushArith(int operator, Tree current, Type expected) {
-    pushBinaryOp(operator, current, expected, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE);
-  }
-  
-  private void pushShift(int operator, Tree current, Type expected) {
-    pushBinaryOp(operator, current, expected, Type.LONG_TYPE, Type.INT_TYPE, Type.LONG_TYPE);
-  }
-  
-  private void pushBitwise(int operator, Tree current, Type expected) {
-    pushBinaryOp(operator, current, expected, Type.LONG_TYPE, Type.LONG_TYPE, Type.LONG_TYPE);
-  }
-  
-  private void pushBinaryOp(int operator, Tree current, Type expected, Type arg1, Type arg2, Type returnType) {
-    recursiveCompile(current.getChild(0), arg1);
-    recursiveCompile(current.getChild(1), arg2);
-    gen.visitInsn(operator);
-    gen.cast(returnType, expected);
-  }
-  
-  private void pushCond(int operator, Tree current, Type expected) {
-    Label labelTrue = new Label();
-    Label labelReturn = new Label();
-    
-    recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);
-    recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);
-    
-    gen.ifCmp(Type.DOUBLE_TYPE, operator, labelTrue);
-    pushBoolean(expected, false);
-    gen.goTo(labelReturn);
-    gen.visitLabel(labelTrue);
-    pushBoolean(expected, true);
-    gen.visitLabel(labelReturn);    
-  }
-  
-  private void pushBoolean(Type expected, boolean truth) {
-    switch (expected.getSort()) {
-      case Type.INT:
-        gen.push(truth);
-        break;
-      case Type.LONG:
-        gen.push(truth ? 1L : 0L);
-        break;
-      case Type.DOUBLE:
-        gen.push(truth ? 1. : 0.);
-        break;
-      default:
-        throw new IllegalStateException("Invalid expected type: " + expected);
-    }
-  }
-  
-  private void pushLong(Type expected, long i) {
-    switch (expected.getSort()) {
-      case Type.INT:
-        gen.push((int) i);
-        break;
-      case Type.LONG:
-        gen.push(i);
-        break;
-      case Type.DOUBLE:
-        gen.push((double) i);
-        break;
-      default:
-        throw new IllegalStateException("Invalid expected type: " + expected);
-    }
+        return null;
+      }
+
+      private void pushArith(int operator, ExpressionContext left, ExpressionContext right) {
+        pushBinaryOp(operator, left, right, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE);
+      }
+
+      private void pushShift(int operator, ExpressionContext left, ExpressionContext right) {
+        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.INT_TYPE, Type.LONG_TYPE);
+      }
+
+      private void pushBitwise(int operator, ExpressionContext left, ExpressionContext right) {
+        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.LONG_TYPE, Type.LONG_TYPE);
+      }
+
+      private void pushBinaryOp(int operator, ExpressionContext left, ExpressionContext right,
+                                Type leftType, Type rightType, Type returnType) {
+        typeStack.push(leftType);
+        visit(left);
+        typeStack.pop();
+        typeStack.push(rightType);
+        visit(right);
+        typeStack.pop();
+        gen.visitInsn(operator);
+        gen.cast(returnType, typeStack.peek());
+      }
+
+      private void pushCond(int operator, ExpressionContext left, ExpressionContext right) {
+        Label labelTrue = new Label();
+        Label labelReturn = new Label();
+
+        typeStack.push(Type.DOUBLE_TYPE);
+        visit(left);
+        visit(right);
+        typeStack.pop();
+
+        gen.ifCmp(Type.DOUBLE_TYPE, operator, labelTrue);
+        pushBoolean(false);
+        gen.goTo(labelReturn);
+        gen.visitLabel(labelTrue);
+        pushBoolean(true);
+        gen.visitLabel(labelReturn);
+      }
+
+      private void pushBoolean(boolean truth) {
+        switch (typeStack.peek().getSort()) {
+          case Type.INT:
+            gen.push(truth);
+            break;
+          case Type.LONG:
+            gen.push(truth ? 1L : 0L);
+            break;
+          case Type.DOUBLE:
+            gen.push(truth ? 1. : 0.);
+            break;
+          default:
+            throw new IllegalStateException("Invalid expected type: " + typeStack.peek());
+        }
+      }
+
+      private void pushLong(long i) {
+        switch (typeStack.peek().getSort()) {
+          case Type.INT:
+            gen.push((int) i);
+            break;
+          case Type.LONG:
+            gen.push(i);
+            break;
+          case Type.DOUBLE:
+            gen.push((double) i);
+            break;
+          default:
+            throw new IllegalStateException("Invalid expected type: " + typeStack.peek());
+        }
+      }
+    }.visit(parseTree);
   }
   
   private void endCompile() {
@@ -479,26 +683,7 @@ public class JavascriptCompiler {
     classWriter.visitEnd();
   }
 
-  private Tree getAntlrComputedExpressionTree() throws ParseException {
-    CharStream input = new ANTLRStringStream(sourceText);
-    JavascriptLexer lexer = new JavascriptLexer(input);
-    CommonTokenStream tokens = new CommonTokenStream(lexer);
-    JavascriptParser parser = new JavascriptParser(tokens);
-
-    try {
-      return parser.expression().tree;
-
-    } catch (RecognitionException exception) {
-      throw new IllegalArgumentException(exception);
-    } catch (RuntimeException exception) {
-      if (exception.getCause() instanceof ParseException) {
-        throw (ParseException)exception.getCause();
-      }
-      throw exception;
-    }
-  }
-
-  private static String normalizeQuotes(String text) {
+  static String normalizeQuotes(String text) {
     StringBuilder out = new StringBuilder(text.length());
     boolean inDoubleQuotes = false;
     for (int i = 0; i < text.length(); ++i) {
@@ -527,7 +712,7 @@ public class JavascriptCompiler {
     return out.toString();
   }
 
-  private static int findSingleQuoteStringEnd(String text, int start) {
+  static int findSingleQuoteStringEnd(String text, int start) {
     ++start; // skip beginning
     while (text.charAt(start) != '\'') {
       if (text.charAt(start) == '\\') {
diff --git a/lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptErrorHandlingLexer.java b/lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptErrorHandlingLexer.java
new file mode 100644
index 0000000..bb0fa0d
--- /dev/null
+++ b/lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptErrorHandlingLexer.java
@@ -0,0 +1,53 @@
+package org.apache.lucene.expressions.js;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.text.ParseException;
+
+import org.antlr.v4.runtime.CharStream;
+import org.antlr.v4.runtime.LexerNoViableAltException;
+import org.antlr.v4.runtime.misc.Interval;
+
+/**
+ * Overrides the ANTLR 4 generated JavascriptLexer to allow for proper error handling
+ */
+class JavascriptErrorHandlingLexer extends JavascriptLexer {
+  /**
+   * Constructor for JavascriptErrorHandlingLexer
+   * @param charStream the stream for the source text
+   */
+  public JavascriptErrorHandlingLexer(CharStream charStream) {
+    super(charStream);
+  }
+
+  /**
+   * Ensures the ANTLR lexer will throw an exception after the first error
+   * @param lnvae the lexer exception
+   */
+  @Override
+  public void recover(LexerNoViableAltException lnvae) {
+    CharStream charStream = lnvae.getInputStream();
+    int startIndex = lnvae.getStartIndex();
+    String text = charStream.getText(Interval.of(startIndex, charStream.index()));
+
+    ParseException parseException = new ParseException("unexpected character '" + getErrorDisplay(text) + "'" +
+        " on line (" + _tokenStartLine + ") position (" + _tokenStartCharPositionInLine + ")", _tokenStartCharIndex);
+    parseException.initCause(lnvae);
+    throw new RuntimeException(parseException);
+  }
+}
diff --git a/lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptLexer.java b/lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptLexer.java
index b23f191..8a61829 100644
--- a/lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptLexer.java
+++ b/lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptLexer.java
@@ -1,2225 +1,199 @@
 // ANTLR GENERATED CODE: DO NOT EDIT
-
 package org.apache.lucene.expressions.js;
-
-import java.text.ParseException;
-
-
-import org.antlr.runtime.*;
-import java.util.Stack;
-import java.util.List;
-import java.util.ArrayList;
-
-@SuppressWarnings("all")
+import org.antlr.v4.runtime.Lexer;
+import org.antlr.v4.runtime.CharStream;
+import org.antlr.v4.runtime.Token;
+import org.antlr.v4.runtime.TokenStream;
+import org.antlr.v4.runtime.*;
+import org.antlr.v4.runtime.atn.*;
+import org.antlr.v4.runtime.dfa.DFA;
+import org.antlr.v4.runtime.misc.*;
+
+@SuppressWarnings({"all", "warnings", "unchecked", "unused", "cast"})
 class JavascriptLexer extends Lexer {
-  public static final int EOF=-1;
-  public static final int ARRAY=4;
-  public static final int AT_ADD=5;
-  public static final int AT_BIT_AND=6;
-  public static final int AT_BIT_NOT=7;
-  public static final int AT_BIT_OR=8;
-  public static final int AT_BIT_SHL=9;
-  public static final int AT_BIT_SHR=10;
-  public static final int AT_BIT_SHU=11;
-  public static final int AT_BIT_XOR=12;
-  public static final int AT_BOOL_AND=13;
-  public static final int AT_BOOL_NOT=14;
-  public static final int AT_BOOL_OR=15;
-  public static final int AT_CALL=16;
-  public static final int AT_COLON=17;
-  public static final int AT_COMMA=18;
-  public static final int AT_COMP_EQ=19;
-  public static final int AT_COMP_GT=20;
-  public static final int AT_COMP_GTE=21;
-  public static final int AT_COMP_LT=22;
-  public static final int AT_COMP_LTE=23;
-  public static final int AT_COMP_NEQ=24;
-  public static final int AT_COND_QUE=25;
-  public static final int AT_DIVIDE=26;
-  public static final int AT_DOT=27;
-  public static final int AT_LPAREN=28;
-  public static final int AT_MODULO=29;
-  public static final int AT_MULTIPLY=30;
-  public static final int AT_NEGATE=31;
-  public static final int AT_RPAREN=32;
-  public static final int AT_SUBTRACT=33;
-  public static final int DECIMAL=34;
-  public static final int DECIMALDIGIT=35;
-  public static final int DECIMALINTEGER=36;
-  public static final int DOUBLE_STRING_CHAR=37;
-  public static final int EXPONENT=38;
-  public static final int HEX=39;
-  public static final int HEXDIGIT=40;
-  public static final int ID=41;
-  public static final int OBJECT=42;
-  public static final int OCTAL=43;
-  public static final int OCTALDIGIT=44;
-  public static final int SINGLE_STRING_CHAR=45;
-  public static final int STRING=46;
-  public static final int VARIABLE=47;
-  public static final int WS=48;
-
-
-  @Override
-  public void displayRecognitionError(String[] tokenNames, RecognitionException re) {  
-      String message = " unexpected character '" + (char)re.c 
-                     + "' at position (" + re.charPositionInLine + ").";
-      ParseException parseException = new ParseException(message, re.charPositionInLine);
-      parseException.initCause(re);
-      throw new RuntimeException(parseException);
-  }
-
-
-
-  // delegates
-  // delegators
-  public Lexer[] getDelegates() {
-    return new Lexer[] {};
-  }
-
-  public JavascriptLexer() {} 
-  public JavascriptLexer(CharStream input) {
-    this(input, new RecognizerSharedState());
-  }
-  public JavascriptLexer(CharStream input, RecognizerSharedState state) {
-    super(input,state);
-  }
-  @Override public String getGrammarFileName() { return "src/java/org/apache/lucene/expressions/js/Javascript.g"; }
-
-  // $ANTLR start "AT_ADD"
-  public final void mAT_ADD() throws RecognitionException {
-    try {
-      int _type = AT_ADD;
-      int _channel = DEFAULT_TOKEN_CHANNEL;
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:25:8: ( '+' )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:25:10: '+'
-      {
-      match('+'); 
-      }
-
-      state.type = _type;
-      state.channel = _channel;
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "AT_ADD"
-
-  // $ANTLR start "AT_BIT_AND"
-  public final void mAT_BIT_AND() throws RecognitionException {
-    try {
-      int _type = AT_BIT_AND;
-      int _channel = DEFAULT_TOKEN_CHANNEL;
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:26:12: ( '&' )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:26:14: '&'
-      {
-      match('&'); 
-      }
-
-      state.type = _type;
-      state.channel = _channel;
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "AT_BIT_AND"
-
-  // $ANTLR start "AT_BIT_NOT"
-  public final void mAT_BIT_NOT() throws RecognitionException {
-    try {
-      int _type = AT_BIT_NOT;
-      int _channel = DEFAULT_TOKEN_CHANNEL;
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:27:12: ( '~' )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:27:14: '~'
-      {
-      match('~'); 
-      }
-
-      state.type = _type;
-      state.channel = _channel;
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "AT_BIT_NOT"
-
-  // $ANTLR start "AT_BIT_OR"
-  public final void mAT_BIT_OR() throws RecognitionException {
-    try {
-      int _type = AT_BIT_OR;
-      int _channel = DEFAULT_TOKEN_CHANNEL;
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:28:11: ( '|' )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:28:13: '|'
-      {
-      match('|'); 
-      }
-
-      state.type = _type;
-      state.channel = _channel;
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "AT_BIT_OR"
-
-  // $ANTLR start "AT_BIT_SHL"
-  public final void mAT_BIT_SHL() throws RecognitionException {
-    try {
-      int _type = AT_BIT_SHL;
-      int _channel = DEFAULT_TOKEN_CHANNEL;
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:29:12: ( '<<' )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:29:14: '<<'
-      {
-      match("<<"); 
-
-      }
-
-      state.type = _type;
-      state.channel = _channel;
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "AT_BIT_SHL"
-
-  // $ANTLR start "AT_BIT_SHR"
-  public final void mAT_BIT_SHR() throws RecognitionException {
-    try {
-      int _type = AT_BIT_SHR;
-      int _channel = DEFAULT_TOKEN_CHANNEL;
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:30:12: ( '>>' )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:30:14: '>>'
-      {
-      match(">>"); 
-
-      }
-
-      state.type = _type;
-      state.channel = _channel;
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "AT_BIT_SHR"
-
-  // $ANTLR start "AT_BIT_SHU"
-  public final void mAT_BIT_SHU() throws RecognitionException {
-    try {
-      int _type = AT_BIT_SHU;
-      int _channel = DEFAULT_TOKEN_CHANNEL;
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:31:12: ( '>>>' )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:31:14: '>>>'
-      {
-      match(">>>"); 
-
-      }
-
-      state.type = _type;
-      state.channel = _channel;
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "AT_BIT_SHU"
-
-  // $ANTLR start "AT_BIT_XOR"
-  public final void mAT_BIT_XOR() throws RecognitionException {
-    try {
-      int _type = AT_BIT_XOR;
-      int _channel = DEFAULT_TOKEN_CHANNEL;
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:32:12: ( '^' )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:32:14: '^'
-      {
-      match('^'); 
-      }
-
-      state.type = _type;
-      state.channel = _channel;
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "AT_BIT_XOR"
-
-  // $ANTLR start "AT_BOOL_AND"
-  public final void mAT_BOOL_AND() throws RecognitionException {
-    try {
-      int _type = AT_BOOL_AND;
-      int _channel = DEFAULT_TOKEN_CHANNEL;
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:33:13: ( '&&' )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:33:15: '&&'
-      {
-      match("&&"); 
-
-      }
-
-      state.type = _type;
-      state.channel = _channel;
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "AT_BOOL_AND"
-
-  // $ANTLR start "AT_BOOL_NOT"
-  public final void mAT_BOOL_NOT() throws RecognitionException {
-    try {
-      int _type = AT_BOOL_NOT;
-      int _channel = DEFAULT_TOKEN_CHANNEL;
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:34:13: ( '!' )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:34:15: '!'
-      {
-      match('!'); 
-      }
-
-      state.type = _type;
-      state.channel = _channel;
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "AT_BOOL_NOT"
-
-  // $ANTLR start "AT_BOOL_OR"
-  public final void mAT_BOOL_OR() throws RecognitionException {
-    try {
-      int _type = AT_BOOL_OR;
-      int _channel = DEFAULT_TOKEN_CHANNEL;
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:35:12: ( '||' )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:35:14: '||'
-      {
-      match("||"); 
-
-      }
-
-      state.type = _type;
-      state.channel = _channel;
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "AT_BOOL_OR"
-
-  // $ANTLR start "AT_COLON"
-  public final void mAT_COLON() throws RecognitionException {
-    try {
-      int _type = AT_COLON;
-      int _channel = DEFAULT_TOKEN_CHANNEL;
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:36:10: ( ':' )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:36:12: ':'
-      {
-      match(':'); 
-      }
-
-      state.type = _type;
-      state.channel = _channel;
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "AT_COLON"
-
-  // $ANTLR start "AT_COMMA"
-  public final void mAT_COMMA() throws RecognitionException {
-    try {
-      int _type = AT_COMMA;
-      int _channel = DEFAULT_TOKEN_CHANNEL;
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:37:10: ( ',' )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:37:12: ','
-      {
-      match(','); 
-      }
-
-      state.type = _type;
-      state.channel = _channel;
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "AT_COMMA"
-
-  // $ANTLR start "AT_COMP_EQ"
-  public final void mAT_COMP_EQ() throws RecognitionException {
-    try {
-      int _type = AT_COMP_EQ;
-      int _channel = DEFAULT_TOKEN_CHANNEL;
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:38:12: ( '==' )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:38:14: '=='
-      {
-      match("=="); 
-
-      }
-
-      state.type = _type;
-      state.channel = _channel;
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "AT_COMP_EQ"
-
-  // $ANTLR start "AT_COMP_GT"
-  public final void mAT_COMP_GT() throws RecognitionException {
-    try {
-      int _type = AT_COMP_GT;
-      int _channel = DEFAULT_TOKEN_CHANNEL;
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:39:12: ( '>' )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:39:14: '>'
-      {
-      match('>'); 
-      }
-
-      state.type = _type;
-      state.channel = _channel;
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "AT_COMP_GT"
-
-  // $ANTLR start "AT_COMP_GTE"
-  public final void mAT_COMP_GTE() throws RecognitionException {
-    try {
-      int _type = AT_COMP_GTE;
-      int _channel = DEFAULT_TOKEN_CHANNEL;
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:40:13: ( '>=' )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:40:15: '>='
-      {
-      match(">="); 
-
-      }
-
-      state.type = _type;
-      state.channel = _channel;
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "AT_COMP_GTE"
-
-  // $ANTLR start "AT_COMP_LT"
-  public final void mAT_COMP_LT() throws RecognitionException {
-    try {
-      int _type = AT_COMP_LT;
-      int _channel = DEFAULT_TOKEN_CHANNEL;
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:41:12: ( '<' )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:41:14: '<'
-      {
-      match('<'); 
-      }
-
-      state.type = _type;
-      state.channel = _channel;
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "AT_COMP_LT"
-
-  // $ANTLR start "AT_COMP_LTE"
-  public final void mAT_COMP_LTE() throws RecognitionException {
-    try {
-      int _type = AT_COMP_LTE;
-      int _channel = DEFAULT_TOKEN_CHANNEL;
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:42:13: ( '<=' )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:42:15: '<='
-      {
-      match("<="); 
-
-      }
-
-      state.type = _type;
-      state.channel = _channel;
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "AT_COMP_LTE"
-
-  // $ANTLR start "AT_COMP_NEQ"
-  public final void mAT_COMP_NEQ() throws RecognitionException {
-    try {
-      int _type = AT_COMP_NEQ;
-      int _channel = DEFAULT_TOKEN_CHANNEL;
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:43:13: ( '!=' )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:43:15: '!='
-      {
-      match("!="); 
-
-      }
-
-      state.type = _type;
-      state.channel = _channel;
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "AT_COMP_NEQ"
-
-  // $ANTLR start "AT_COND_QUE"
-  public final void mAT_COND_QUE() throws RecognitionException {
-    try {
-      int _type = AT_COND_QUE;
-      int _channel = DEFAULT_TOKEN_CHANNEL;
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:44:13: ( '?' )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:44:15: '?'
-      {
-      match('?'); 
-      }
-
-      state.type = _type;
-      state.channel = _channel;
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "AT_COND_QUE"
-
-  // $ANTLR start "AT_DIVIDE"
-  public final void mAT_DIVIDE() throws RecognitionException {
-    try {
-      int _type = AT_DIVIDE;
-      int _channel = DEFAULT_TOKEN_CHANNEL;
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:45:11: ( '/' )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:45:13: '/'
-      {
-      match('/'); 
-      }
-
-      state.type = _type;
-      state.channel = _channel;
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "AT_DIVIDE"
-
-  // $ANTLR start "AT_DOT"
-  public final void mAT_DOT() throws RecognitionException {
-    try {
-      int _type = AT_DOT;
-      int _channel = DEFAULT_TOKEN_CHANNEL;
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:46:8: ( '.' )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:46:10: '.'
-      {
-      match('.'); 
-      }
-
-      state.type = _type;
-      state.channel = _channel;
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "AT_DOT"
-
-  // $ANTLR start "AT_LPAREN"
-  public final void mAT_LPAREN() throws RecognitionException {
-    try {
-      int _type = AT_LPAREN;
-      int _channel = DEFAULT_TOKEN_CHANNEL;
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:47:11: ( '(' )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:47:13: '('
-      {
-      match('('); 
-      }
-
-      state.type = _type;
-      state.channel = _channel;
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "AT_LPAREN"
-
-  // $ANTLR start "AT_MODULO"
-  public final void mAT_MODULO() throws RecognitionException {
-    try {
-      int _type = AT_MODULO;
-      int _channel = DEFAULT_TOKEN_CHANNEL;
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:48:11: ( '%' )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:48:13: '%'
-      {
-      match('%'); 
-      }
-
-      state.type = _type;
-      state.channel = _channel;
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "AT_MODULO"
-
-  // $ANTLR start "AT_MULTIPLY"
-  public final void mAT_MULTIPLY() throws RecognitionException {
-    try {
-      int _type = AT_MULTIPLY;
-      int _channel = DEFAULT_TOKEN_CHANNEL;
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:49:13: ( '*' )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:49:15: '*'
-      {
-      match('*'); 
-      }
-
-      state.type = _type;
-      state.channel = _channel;
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "AT_MULTIPLY"
-
-  // $ANTLR start "AT_RPAREN"
-  public final void mAT_RPAREN() throws RecognitionException {
-    try {
-      int _type = AT_RPAREN;
-      int _channel = DEFAULT_TOKEN_CHANNEL;
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:50:11: ( ')' )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:50:13: ')'
-      {
-      match(')'); 
-      }
-
-      state.type = _type;
-      state.channel = _channel;
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "AT_RPAREN"
-
-  // $ANTLR start "AT_SUBTRACT"
-  public final void mAT_SUBTRACT() throws RecognitionException {
-    try {
-      int _type = AT_SUBTRACT;
-      int _channel = DEFAULT_TOKEN_CHANNEL;
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:51:13: ( '-' )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:51:15: '-'
-      {
-      match('-'); 
-      }
-
-      state.type = _type;
-      state.channel = _channel;
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "AT_SUBTRACT"
-
-  // $ANTLR start "VARIABLE"
-  public final void mVARIABLE() throws RecognitionException {
-    try {
-      int _type = VARIABLE;
-      int _channel = DEFAULT_TOKEN_CHANNEL;
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:334:5: ( OBJECT ( AT_DOT OBJECT )* )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:334:7: OBJECT ( AT_DOT OBJECT )*
-      {
-      mOBJECT(); 
-
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:334:14: ( AT_DOT OBJECT )*
-      loop1:
-      while (true) {
-        int alt1=2;
-        int LA1_0 = input.LA(1);
-        if ( (LA1_0=='.') ) {
-          alt1=1;
-        }
-
-        switch (alt1) {
-        case 1 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:334:15: AT_DOT OBJECT
-          {
-          mAT_DOT(); 
-
-          mOBJECT(); 
-
-          }
-          break;
-
-        default :
-          break loop1;
-        }
-      }
-
-      }
-
-      state.type = _type;
-      state.channel = _channel;
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "VARIABLE"
-
-  // $ANTLR start "OBJECT"
-  public final void mOBJECT() throws RecognitionException {
-    try {
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:340:5: ( ID ( ARRAY )* )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:340:7: ID ( ARRAY )*
-      {
-      mID(); 
-
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:340:10: ( ARRAY )*
-      loop2:
-      while (true) {
-        int alt2=2;
-        int LA2_0 = input.LA(1);
-        if ( (LA2_0=='[') ) {
-          alt2=1;
-        }
-
-        switch (alt2) {
-        case 1 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:340:10: ARRAY
-          {
-          mARRAY(); 
-
-          }
-          break;
-
-        default :
-          break loop2;
-        }
-      }
-
-      }
-
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "OBJECT"
-
-  // $ANTLR start "ARRAY"
-  public final void mARRAY() throws RecognitionException {
-    try {
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:345:5: ( '[' STRING ']' | '[' DECIMALINTEGER ']' )
-      int alt3=2;
-      int LA3_0 = input.LA(1);
-      if ( (LA3_0=='[') ) {
-        int LA3_1 = input.LA(2);
-        if ( (LA3_1=='\"'||LA3_1=='\'') ) {
-          alt3=1;
-        }
-        else if ( ((LA3_1 >= '0' && LA3_1 <= '9')) ) {
-          alt3=2;
-        }
-
-        else {
-          int nvaeMark = input.mark();
-          try {
-            input.consume();
-            NoViableAltException nvae =
-              new NoViableAltException("", 3, 1, input);
-            throw nvae;
-          } finally {
-            input.rewind(nvaeMark);
-          }
-        }
-
-      }
-
-      else {
-        NoViableAltException nvae =
-          new NoViableAltException("", 3, 0, input);
-        throw nvae;
-      }
-
-      switch (alt3) {
-        case 1 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:345:7: '[' STRING ']'
-          {
-          match('['); 
-          mSTRING(); 
-
-          match(']'); 
-          }
-          break;
-        case 2 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:346:7: '[' DECIMALINTEGER ']'
-          {
-          match('['); 
-          mDECIMALINTEGER(); 
-
-          match(']'); 
-          }
-          break;
-
-      }
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "ARRAY"
-
-  // $ANTLR start "ID"
-  public final void mID() throws RecognitionException {
-    try {
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:351:5: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '$' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' | '$' )* )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:351:7: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '$' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' | '$' )*
-      {
-      if ( input.LA(1)=='$'||(input.LA(1) >= 'A' && input.LA(1) <= 'Z')||input.LA(1)=='_'||(input.LA(1) >= 'a' && input.LA(1) <= 'z') ) {
-        input.consume();
-      }
-      else {
-        MismatchedSetException mse = new MismatchedSetException(null,input);
-        recover(mse);
-        throw mse;
-      }
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:351:35: ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' | '$' )*
-      loop4:
-      while (true) {
-        int alt4=2;
-        int LA4_0 = input.LA(1);
-        if ( (LA4_0=='$'||(LA4_0 >= '0' && LA4_0 <= '9')||(LA4_0 >= 'A' && LA4_0 <= 'Z')||LA4_0=='_'||(LA4_0 >= 'a' && LA4_0 <= 'z')) ) {
-          alt4=1;
-        }
-
-        switch (alt4) {
-        case 1 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:
-          {
-          if ( input.LA(1)=='$'||(input.LA(1) >= '0' && input.LA(1) <= '9')||(input.LA(1) >= 'A' && input.LA(1) <= 'Z')||input.LA(1)=='_'||(input.LA(1) >= 'a' && input.LA(1) <= 'z') ) {
-            input.consume();
-          }
-          else {
-            MismatchedSetException mse = new MismatchedSetException(null,input);
-            recover(mse);
-            throw mse;
-          }
-          }
-          break;
-
-        default :
-          break loop4;
-        }
-      }
-
-      }
-
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "ID"
-
-  // $ANTLR start "STRING"
-  public final void mSTRING() throws RecognitionException {
-    try {
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:356:5: ( '\\'' ( SINGLE_STRING_CHAR )* '\\'' | '\"' ( DOUBLE_STRING_CHAR )* '\"' )
-      int alt7=2;
-      int LA7_0 = input.LA(1);
-      if ( (LA7_0=='\'') ) {
-        alt7=1;
-      }
-      else if ( (LA7_0=='\"') ) {
-        alt7=2;
-      }
-
-      else {
-        NoViableAltException nvae =
-          new NoViableAltException("", 7, 0, input);
-        throw nvae;
-      }
-
-      switch (alt7) {
-        case 1 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:356:7: '\\'' ( SINGLE_STRING_CHAR )* '\\''
-          {
-          match('\''); 
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:356:12: ( SINGLE_STRING_CHAR )*
-          loop5:
-          while (true) {
-            int alt5=2;
-            int LA5_0 = input.LA(1);
-            if ( ((LA5_0 >= '\u0000' && LA5_0 <= '&')||(LA5_0 >= '(' && LA5_0 <= '\uFFFF')) ) {
-              alt5=1;
-            }
-
-            switch (alt5) {
-            case 1 :
-              // src/java/org/apache/lucene/expressions/js/Javascript.g:356:12: SINGLE_STRING_CHAR
-              {
-              mSINGLE_STRING_CHAR(); 
-
-              }
-              break;
-
-            default :
-              break loop5;
-            }
-          }
-
-          match('\''); 
-           
-          }
-          break;
-        case 2 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:357:7: '\"' ( DOUBLE_STRING_CHAR )* '\"'
-          {
-          match('\"'); 
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:357:11: ( DOUBLE_STRING_CHAR )*
-          loop6:
-          while (true) {
-            int alt6=2;
-            int LA6_0 = input.LA(1);
-            if ( ((LA6_0 >= '\u0000' && LA6_0 <= '!')||(LA6_0 >= '#' && LA6_0 <= '\uFFFF')) ) {
-              alt6=1;
-            }
-
-            switch (alt6) {
-            case 1 :
-              // src/java/org/apache/lucene/expressions/js/Javascript.g:357:11: DOUBLE_STRING_CHAR
-              {
-              mDOUBLE_STRING_CHAR(); 
-
-              }
-              break;
-
-            default :
-              break loop6;
-            }
-          }
-
-          match('\"'); 
-          }
-          break;
-
-      }
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "STRING"
-
-  // $ANTLR start "SINGLE_STRING_CHAR"
-  public final void mSINGLE_STRING_CHAR() throws RecognitionException {
-    try {
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:362:5: ( '\\\\\\'' | '\\\\\\\\' |~ ( '\\\\' | '\\'' ) )
-      int alt8=3;
-      int LA8_0 = input.LA(1);
-      if ( (LA8_0=='\\') ) {
-        int LA8_1 = input.LA(2);
-        if ( (LA8_1=='\'') ) {
-          alt8=1;
-        }
-        else if ( (LA8_1=='\\') ) {
-          alt8=2;
-        }
-
-        else {
-          int nvaeMark = input.mark();
-          try {
-            input.consume();
-            NoViableAltException nvae =
-              new NoViableAltException("", 8, 1, input);
-            throw nvae;
-          } finally {
-            input.rewind(nvaeMark);
-          }
-        }
-
-      }
-      else if ( ((LA8_0 >= '\u0000' && LA8_0 <= '&')||(LA8_0 >= '(' && LA8_0 <= '[')||(LA8_0 >= ']' && LA8_0 <= '\uFFFF')) ) {
-        alt8=3;
-      }
-
-      else {
-        NoViableAltException nvae =
-          new NoViableAltException("", 8, 0, input);
-        throw nvae;
-      }
-
-      switch (alt8) {
-        case 1 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:362:7: '\\\\\\''
-          {
-          match("\\'"); 
-
-          }
-          break;
-        case 2 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:363:7: '\\\\\\\\'
-          {
-          match("\\\\"); 
-
-          }
-          break;
-        case 3 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:364:7: ~ ( '\\\\' | '\\'' )
-          {
-          if ( (input.LA(1) >= '\u0000' && input.LA(1) <= '&')||(input.LA(1) >= '(' && input.LA(1) <= '[')||(input.LA(1) >= ']' && input.LA(1) <= '\uFFFF') ) {
-            input.consume();
-          }
-          else {
-            MismatchedSetException mse = new MismatchedSetException(null,input);
-            recover(mse);
-            throw mse;
-          }
-          }
-          break;
-
-      }
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "SINGLE_STRING_CHAR"
-
-  // $ANTLR start "DOUBLE_STRING_CHAR"
-  public final void mDOUBLE_STRING_CHAR() throws RecognitionException {
-    try {
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:369:5: ( '\\\\\"' | '\\\\\\\\' |~ ( '\\\\' | '\"' ) )
-      int alt9=3;
-      int LA9_0 = input.LA(1);
-      if ( (LA9_0=='\\') ) {
-        int LA9_1 = input.LA(2);
-        if ( (LA9_1=='\"') ) {
-          alt9=1;
-        }
-        else if ( (LA9_1=='\\') ) {
-          alt9=2;
-        }
-
-        else {
-          int nvaeMark = input.mark();
-          try {
-            input.consume();
-            NoViableAltException nvae =
-              new NoViableAltException("", 9, 1, input);
-            throw nvae;
-          } finally {
-            input.rewind(nvaeMark);
-          }
-        }
-
-      }
-      else if ( ((LA9_0 >= '\u0000' && LA9_0 <= '!')||(LA9_0 >= '#' && LA9_0 <= '[')||(LA9_0 >= ']' && LA9_0 <= '\uFFFF')) ) {
-        alt9=3;
-      }
-
-      else {
-        NoViableAltException nvae =
-          new NoViableAltException("", 9, 0, input);
-        throw nvae;
-      }
-
-      switch (alt9) {
-        case 1 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:369:7: '\\\\\"'
-          {
-          match("\\\""); 
-
-          }
-          break;
-        case 2 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:370:7: '\\\\\\\\'
-          {
-          match("\\\\"); 
-
-          }
-          break;
-        case 3 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:371:7: ~ ( '\\\\' | '\"' )
-          {
-          if ( (input.LA(1) >= '\u0000' && input.LA(1) <= '!')||(input.LA(1) >= '#' && input.LA(1) <= '[')||(input.LA(1) >= ']' && input.LA(1) <= '\uFFFF') ) {
-            input.consume();
-          }
-          else {
-            MismatchedSetException mse = new MismatchedSetException(null,input);
-            recover(mse);
-            throw mse;
-          }
-          }
-          break;
-
-      }
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "DOUBLE_STRING_CHAR"
-
-  // $ANTLR start "WS"
-  public final void mWS() throws RecognitionException {
-    try {
-      int _type = WS;
-      int _channel = DEFAULT_TOKEN_CHANNEL;
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:374:5: ( ( ' ' | '\\t' | '\\n' | '\\r' )+ )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:374:7: ( ' ' | '\\t' | '\\n' | '\\r' )+
-      {
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:374:7: ( ' ' | '\\t' | '\\n' | '\\r' )+
-      int cnt10=0;
-      loop10:
-      while (true) {
-        int alt10=2;
-        int LA10_0 = input.LA(1);
-        if ( ((LA10_0 >= '\t' && LA10_0 <= '\n')||LA10_0=='\r'||LA10_0==' ') ) {
-          alt10=1;
-        }
-
-        switch (alt10) {
-        case 1 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:
-          {
-          if ( (input.LA(1) >= '\t' && input.LA(1) <= '\n')||input.LA(1)=='\r'||input.LA(1)==' ' ) {
-            input.consume();
-          }
-          else {
-            MismatchedSetException mse = new MismatchedSetException(null,input);
-            recover(mse);
-            throw mse;
-          }
-          }
-          break;
-
-        default :
-          if ( cnt10 >= 1 ) break loop10;
-          EarlyExitException eee = new EarlyExitException(10, input);
-          throw eee;
-        }
-        cnt10++;
-      }
-
-      skip();
-      }
-
-      state.type = _type;
-      state.channel = _channel;
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "WS"
-
-  // $ANTLR start "DECIMAL"
-  public final void mDECIMAL() throws RecognitionException {
-    try {
-      int _type = DECIMAL;
-      int _channel = DEFAULT_TOKEN_CHANNEL;
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:378:5: ( DECIMALINTEGER AT_DOT ( DECIMALDIGIT )* ( EXPONENT )? | AT_DOT ( DECIMALDIGIT )+ ( EXPONENT )? | DECIMALINTEGER ( EXPONENT )? )
-      int alt16=3;
-      alt16 = dfa16.predict(input);
-      switch (alt16) {
-        case 1 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:378:7: DECIMALINTEGER AT_DOT ( DECIMALDIGIT )* ( EXPONENT )?
-          {
-          mDECIMALINTEGER(); 
-
-          mAT_DOT(); 
-
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:378:29: ( DECIMALDIGIT )*
-          loop11:
-          while (true) {
-            int alt11=2;
-            int LA11_0 = input.LA(1);
-            if ( ((LA11_0 >= '0' && LA11_0 <= '9')) ) {
-              alt11=1;
-            }
-
-            switch (alt11) {
-            case 1 :
-              // src/java/org/apache/lucene/expressions/js/Javascript.g:
-              {
-              if ( (input.LA(1) >= '0' && input.LA(1) <= '9') ) {
-                input.consume();
-              }
-              else {
-                MismatchedSetException mse = new MismatchedSetException(null,input);
-                recover(mse);
-                throw mse;
-              }
-              }
-              break;
-
-            default :
-              break loop11;
-            }
-          }
-
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:378:43: ( EXPONENT )?
-          int alt12=2;
-          int LA12_0 = input.LA(1);
-          if ( (LA12_0=='E'||LA12_0=='e') ) {
-            alt12=1;
-          }
-          switch (alt12) {
-            case 1 :
-              // src/java/org/apache/lucene/expressions/js/Javascript.g:378:43: EXPONENT
-              {
-              mEXPONENT(); 
-
-              }
-              break;
-
-          }
-
-          }
-          break;
-        case 2 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:379:7: AT_DOT ( DECIMALDIGIT )+ ( EXPONENT )?
-          {
-          mAT_DOT(); 
-
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:379:14: ( DECIMALDIGIT )+
-          int cnt13=0;
-          loop13:
-          while (true) {
-            int alt13=2;
-            int LA13_0 = input.LA(1);
-            if ( ((LA13_0 >= '0' && LA13_0 <= '9')) ) {
-              alt13=1;
-            }
-
-            switch (alt13) {
-            case 1 :
-              // src/java/org/apache/lucene/expressions/js/Javascript.g:
-              {
-              if ( (input.LA(1) >= '0' && input.LA(1) <= '9') ) {
-                input.consume();
-              }
-              else {
-                MismatchedSetException mse = new MismatchedSetException(null,input);
-                recover(mse);
-                throw mse;
-              }
-              }
-              break;
-
-            default :
-              if ( cnt13 >= 1 ) break loop13;
-              EarlyExitException eee = new EarlyExitException(13, input);
-              throw eee;
-            }
-            cnt13++;
-          }
-
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:379:28: ( EXPONENT )?
-          int alt14=2;
-          int LA14_0 = input.LA(1);
-          if ( (LA14_0=='E'||LA14_0=='e') ) {
-            alt14=1;
-          }
-          switch (alt14) {
-            case 1 :
-              // src/java/org/apache/lucene/expressions/js/Javascript.g:379:28: EXPONENT
-              {
-              mEXPONENT(); 
-
-              }
-              break;
-
-          }
-
-          }
-          break;
-        case 3 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:380:7: DECIMALINTEGER ( EXPONENT )?
-          {
-          mDECIMALINTEGER(); 
-
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:380:22: ( EXPONENT )?
-          int alt15=2;
-          int LA15_0 = input.LA(1);
-          if ( (LA15_0=='E'||LA15_0=='e') ) {
-            alt15=1;
-          }
-          switch (alt15) {
-            case 1 :
-              // src/java/org/apache/lucene/expressions/js/Javascript.g:380:22: EXPONENT
-              {
-              mEXPONENT(); 
-
-              }
-              break;
-
-          }
-
-          }
-          break;
-
-      }
-      state.type = _type;
-      state.channel = _channel;
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "DECIMAL"
-
-  // $ANTLR start "OCTAL"
-  public final void mOCTAL() throws RecognitionException {
-    try {
-      int _type = OCTAL;
-      int _channel = DEFAULT_TOKEN_CHANNEL;
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:384:5: ( '0' ( OCTALDIGIT )+ )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:384:7: '0' ( OCTALDIGIT )+
-      {
-      match('0'); 
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:384:11: ( OCTALDIGIT )+
-      int cnt17=0;
-      loop17:
-      while (true) {
-        int alt17=2;
-        int LA17_0 = input.LA(1);
-        if ( ((LA17_0 >= '0' && LA17_0 <= '7')) ) {
-          alt17=1;
-        }
-
-        switch (alt17) {
-        case 1 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:
-          {
-          if ( (input.LA(1) >= '0' && input.LA(1) <= '7') ) {
-            input.consume();
-          }
-          else {
-            MismatchedSetException mse = new MismatchedSetException(null,input);
-            recover(mse);
-            throw mse;
-          }
-          }
-          break;
-
-        default :
-          if ( cnt17 >= 1 ) break loop17;
-          EarlyExitException eee = new EarlyExitException(17, input);
-          throw eee;
-        }
-        cnt17++;
-      }
-
-      }
-
-      state.type = _type;
-      state.channel = _channel;
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "OCTAL"
-
-  // $ANTLR start "HEX"
-  public final void mHEX() throws RecognitionException {
-    try {
-      int _type = HEX;
-      int _channel = DEFAULT_TOKEN_CHANNEL;
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:388:5: ( ( '0x' | '0X' ) ( HEXDIGIT )+ )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:388:7: ( '0x' | '0X' ) ( HEXDIGIT )+
-      {
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:388:7: ( '0x' | '0X' )
-      int alt18=2;
-      int LA18_0 = input.LA(1);
-      if ( (LA18_0=='0') ) {
-        int LA18_1 = input.LA(2);
-        if ( (LA18_1=='x') ) {
-          alt18=1;
-        }
-        else if ( (LA18_1=='X') ) {
-          alt18=2;
-        }
-
-        else {
-          int nvaeMark = input.mark();
-          try {
-            input.consume();
-            NoViableAltException nvae =
-              new NoViableAltException("", 18, 1, input);
-            throw nvae;
-          } finally {
-            input.rewind(nvaeMark);
-          }
-        }
-
-      }
-
-      else {
-        NoViableAltException nvae =
-          new NoViableAltException("", 18, 0, input);
-        throw nvae;
-      }
-
-      switch (alt18) {
-        case 1 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:388:8: '0x'
-          {
-          match("0x"); 
-
-          }
-          break;
-        case 2 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:388:13: '0X'
-          {
-          match("0X"); 
-
-          }
-          break;
-
-      }
-
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:388:19: ( HEXDIGIT )+
-      int cnt19=0;
-      loop19:
-      while (true) {
-        int alt19=2;
-        int LA19_0 = input.LA(1);
-        if ( ((LA19_0 >= '0' && LA19_0 <= '9')||(LA19_0 >= 'A' && LA19_0 <= 'F')||(LA19_0 >= 'a' && LA19_0 <= 'f')) ) {
-          alt19=1;
-        }
-
-        switch (alt19) {
-        case 1 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:
-          {
-          if ( (input.LA(1) >= '0' && input.LA(1) <= '9')||(input.LA(1) >= 'A' && input.LA(1) <= 'F')||(input.LA(1) >= 'a' && input.LA(1) <= 'f') ) {
-            input.consume();
-          }
-          else {
-            MismatchedSetException mse = new MismatchedSetException(null,input);
-            recover(mse);
-            throw mse;
-          }
-          }
-          break;
-
-        default :
-          if ( cnt19 >= 1 ) break loop19;
-          EarlyExitException eee = new EarlyExitException(19, input);
-          throw eee;
-        }
-        cnt19++;
-      }
-
-      }
-
-      state.type = _type;
-      state.channel = _channel;
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "HEX"
-
-  // $ANTLR start "DECIMALINTEGER"
-  public final void mDECIMALINTEGER() throws RecognitionException {
-    try {
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:394:5: ( '0' | '1' .. '9' ( DECIMALDIGIT )* )
-      int alt21=2;
-      int LA21_0 = input.LA(1);
-      if ( (LA21_0=='0') ) {
-        alt21=1;
-      }
-      else if ( ((LA21_0 >= '1' && LA21_0 <= '9')) ) {
-        alt21=2;
-      }
-
-      else {
-        NoViableAltException nvae =
-          new NoViableAltException("", 21, 0, input);
-        throw nvae;
-      }
-
-      switch (alt21) {
-        case 1 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:394:7: '0'
-          {
-          match('0'); 
-          }
-          break;
-        case 2 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:395:7: '1' .. '9' ( DECIMALDIGIT )*
-          {
-          matchRange('1','9'); 
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:395:16: ( DECIMALDIGIT )*
-          loop20:
-          while (true) {
-            int alt20=2;
-            int LA20_0 = input.LA(1);
-            if ( ((LA20_0 >= '0' && LA20_0 <= '9')) ) {
-              alt20=1;
-            }
-
-            switch (alt20) {
-            case 1 :
-              // src/java/org/apache/lucene/expressions/js/Javascript.g:
-              {
-              if ( (input.LA(1) >= '0' && input.LA(1) <= '9') ) {
-                input.consume();
-              }
-              else {
-                MismatchedSetException mse = new MismatchedSetException(null,input);
-                recover(mse);
-                throw mse;
-              }
-              }
-              break;
-
-            default :
-              break loop20;
-            }
-          }
-
-          }
-          break;
-
-      }
-    }
-    finally {
-      // do for sure before leaving
-    }
-  }
-  // $ANTLR end "DECIMALINTEGER"
-
-  // $ANTLR start "EXPONENT"
-  public final void mEXPONENT() throws RecognitionException {
-    try {
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:400:5: ( ( 'e' | 'E' ) ( '+' | '-' )? ( DECIMALDIGIT )+ )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:400:7: ( 'e' | 'E' ) ( '+' | '-' )? ( DECIMALDIGIT )+
-      {
-      if ( input.LA(1)=='E'||input.LA(1)=='e' ) {
-        input.consume();
-      }
-      else {
-        MismatchedSetException mse = new MismatchedSetException(null,input);
-        recover(mse);
-        throw mse;
-      }
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:400:17: ( '+' | '-' )?
-      int alt22=2;
-      int LA22_0 = input.LA(1);
-      if ( (LA22_0=='+'||LA22_0=='-') ) {
-        alt22=1;
-      }
-      switch (alt22) {
-        case 1 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:
-          {
-          if ( input.LA(1)=='+'||input.LA(1)=='-' ) {
-            input.consume();
-          }
-          else {
-            MismatchedSetException mse = new MismatchedSetException(null,input);
-            recover(mse);
-            throw mse;
-          }
-          }
-          break;
-
-      }
+  static { RuntimeMetaData.checkVersion("4.5", RuntimeMetaData.VERSION); }
+
+  protected static final DFA[] _decisionToDFA;
+  protected static final PredictionContextCache _sharedContextCache =
+    new PredictionContextCache();
+  public static final int
+    LP=1, RP=2, COMMA=3, BOOLNOT=4, BWNOT=5, MUL=6, DIV=7, REM=8, ADD=9, SUB=10, 
+    LSH=11, RSH=12, USH=13, LT=14, LTE=15, GT=16, GTE=17, EQ=18, NE=19, BWAND=20, 
+    BWXOR=21, BWOR=22, BOOLAND=23, BOOLOR=24, COND=25, COLON=26, WS=27, VARIABLE=28, 
+    OCTAL=29, HEX=30, DECIMAL=31;
+  public static String[] modeNames = {
+    "DEFAULT_MODE"
+  };
 
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:400:28: ( DECIMALDIGIT )+
-      int cnt23=0;
-      loop23:
-      while (true) {
-        int alt23=2;
-        int LA23_0 = input.LA(1);
-        if ( ((LA23_0 >= '0' && LA23_0 <= '9')) ) {
-          alt23=1;
-        }
+  public static final String[] ruleNames = {
+    "LP", "RP", "COMMA", "BOOLNOT", "BWNOT", "MUL", "DIV", "REM", "ADD", "SUB", 
+    "LSH", "RSH", "USH", "LT", "LTE", "GT", "GTE", "EQ", "NE", "BWAND", "BWXOR", 
+    "BWOR", "BOOLAND", "BOOLOR", "COND", "COLON", "WS", "VARIABLE", "ARRAY", 
+    "ID", "STRING", "OCTAL", "HEX", "DECIMAL", "INTEGER"
+  };
 
-        switch (alt23) {
-        case 1 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:
-          {
-          if ( (input.LA(1) >= '0' && input.LA(1) <= '9') ) {
-            input.consume();
-          }
-          else {
-            MismatchedSetException mse = new MismatchedSetException(null,input);
-            recover(mse);
-            throw mse;
-          }
-          }
-          break;
+  private static final String[] _LITERAL_NAMES = {
+    null, null, null, null, null, null, null, null, null, null, null, "'<<'", 
+    "'>>'", "'>>>'", null, "'<='", null, "'>='", "'=='", "'!='", null, null, 
+    null, "'&&'", "'||'"
+  };
+  private static final String[] _SYMBOLIC_NAMES = {
+    null, "LP", "RP", "COMMA", "BOOLNOT", "BWNOT", "MUL", "DIV", "REM", "ADD", 
+    "SUB", "LSH", "RSH", "USH", "LT", "LTE", "GT", "GTE", "EQ", "NE", "BWAND", 
+    "BWXOR", "BWOR", "BOOLAND", "BOOLOR", "COND", "COLON", "WS", "VARIABLE", 
+    "OCTAL", "HEX", "DECIMAL"
+  };
+  public static final Vocabulary VOCABULARY = new VocabularyImpl(_LITERAL_NAMES, _SYMBOLIC_NAMES);
 
-        default :
-          if ( cnt23 >= 1 ) break loop23;
-          EarlyExitException eee = new EarlyExitException(23, input);
-          throw eee;
-        }
-        cnt23++;
+  /**
+   * @deprecated Use {@link #VOCABULARY} instead.
+   */
+  @Deprecated
+  public static final String[] tokenNames;
+  static {
+    tokenNames = new String[_SYMBOLIC_NAMES.length];
+    for (int i = 0; i < tokenNames.length; i++) {
+      tokenNames[i] = VOCABULARY.getLiteralName(i);
+      if (tokenNames[i] == null) {
+        tokenNames[i] = VOCABULARY.getSymbolicName(i);
       }
 
+      if (tokenNames[i] == null) {
+        tokenNames[i] = "<INVALID>";
       }
-
-    }
-    finally {
-      // do for sure before leaving
     }
   }
-  // $ANTLR end "EXPONENT"
-
-  // $ANTLR start "DECIMALDIGIT"
-  public final void mDECIMALDIGIT() throws RecognitionException {
-    try {
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:405:5: ( '0' .. '9' )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:
-      {
-      if ( (input.LA(1) >= '0' && input.LA(1) <= '9') ) {
-        input.consume();
-      }
-      else {
-        MismatchedSetException mse = new MismatchedSetException(null,input);
-        recover(mse);
-        throw mse;
-      }
-      }
 
-    }
-    finally {
-      // do for sure before leaving
-    }
+  @Override
+  @Deprecated
+  public String[] getTokenNames() {
+    return tokenNames;
   }
-  // $ANTLR end "DECIMALDIGIT"
 
-  // $ANTLR start "HEXDIGIT"
-  public final void mHEXDIGIT() throws RecognitionException {
-    try {
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:410:5: ( DECIMALDIGIT | 'a' .. 'f' | 'A' .. 'F' )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:
-      {
-      if ( (input.LA(1) >= '0' && input.LA(1) <= '9')||(input.LA(1) >= 'A' && input.LA(1) <= 'F')||(input.LA(1) >= 'a' && input.LA(1) <= 'f') ) {
-        input.consume();
-      }
-      else {
-        MismatchedSetException mse = new MismatchedSetException(null,input);
-        recover(mse);
-        throw mse;
-      }
-      }
+  @Override
 
-    }
-    finally {
-      // do for sure before leaving
-    }
+  public Vocabulary getVocabulary() {
+    return VOCABULARY;
   }
-  // $ANTLR end "HEXDIGIT"
 
-  // $ANTLR start "OCTALDIGIT"
-  public final void mOCTALDIGIT() throws RecognitionException {
-    try {
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:417:5: ( '0' .. '7' )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:
-      {
-      if ( (input.LA(1) >= '0' && input.LA(1) <= '7') ) {
-        input.consume();
-      }
-      else {
-        MismatchedSetException mse = new MismatchedSetException(null,input);
-        recover(mse);
-        throw mse;
-      }
-      }
 
-    }
-    finally {
-      // do for sure before leaving
-    }
+  public JavascriptLexer(CharStream input) {
+    super(input);
+    _interp = new LexerATNSimulator(this,_ATN,_decisionToDFA,_sharedContextCache);
   }
-  // $ANTLR end "OCTALDIGIT"
 
   @Override
-  public void mTokens() throws RecognitionException {
-    // src/java/org/apache/lucene/expressions/js/Javascript.g:1:8: ( AT_ADD | AT_BIT_AND | AT_BIT_NOT | AT_BIT_OR | AT_BIT_SHL | AT_BIT_SHR | AT_BIT_SHU | AT_BIT_XOR | AT_BOOL_AND | AT_BOOL_NOT | AT_BOOL_OR | AT_COLON | AT_COMMA | AT_COMP_EQ | AT_COMP_GT | AT_COMP_GTE | AT_COMP_LT | AT_COMP_LTE | AT_COMP_NEQ | AT_COND_QUE | AT_DIVIDE | AT_DOT | AT_LPAREN | AT_MODULO | AT_MULTIPLY | AT_RPAREN | AT_SUBTRACT | VARIABLE | WS | DECIMAL | OCTAL | HEX )
-    int alt24=32;
-    switch ( input.LA(1) ) {
-    case '+':
-      {
-      alt24=1;
-      }
-      break;
-    case '&':
-      {
-      int LA24_2 = input.LA(2);
-      if ( (LA24_2=='&') ) {
-        alt24=9;
-      }
-
-      else {
-        alt24=2;
-      }
-
-      }
-      break;
-    case '~':
-      {
-      alt24=3;
-      }
-      break;
-    case '|':
-      {
-      int LA24_4 = input.LA(2);
-      if ( (LA24_4=='|') ) {
-        alt24=11;
-      }
-
-      else {
-        alt24=4;
-      }
-
-      }
-      break;
-    case '<':
-      {
-      switch ( input.LA(2) ) {
-      case '<':
-        {
-        alt24=5;
-        }
-        break;
-      case '=':
-        {
-        alt24=18;
-        }
-        break;
-      default:
-        alt24=17;
-      }
-      }
-      break;
-    case '>':
-      {
-      switch ( input.LA(2) ) {
-      case '>':
-        {
-        int LA24_31 = input.LA(3);
-        if ( (LA24_31=='>') ) {
-          alt24=7;
-        }
-
-        else {
-          alt24=6;
-        }
-
-        }
-        break;
-      case '=':
-        {
-        alt24=16;
-        }
-        break;
-      default:
-        alt24=15;
-      }
-      }
-      break;
-    case '^':
-      {
-      alt24=8;
-      }
-      break;
-    case '!':
-      {
-      int LA24_8 = input.LA(2);
-      if ( (LA24_8=='=') ) {
-        alt24=19;
-      }
-
-      else {
-        alt24=10;
-      }
-
-      }
-      break;
-    case ':':
-      {
-      alt24=12;
-      }
-      break;
-    case ',':
-      {
-      alt24=13;
-      }
-      break;
-    case '=':
-      {
-      alt24=14;
-      }
-      break;
-    case '?':
-      {
-      alt24=20;
-      }
-      break;
-    case '/':
-      {
-      alt24=21;
-      }
-      break;
-    case '.':
-      {
-      int LA24_14 = input.LA(2);
-      if ( ((LA24_14 >= '0' && LA24_14 <= '9')) ) {
-        alt24=30;
-      }
-
-      else {
-        alt24=22;
-      }
-
-      }
-      break;
-    case '(':
-      {
-      alt24=23;
-      }
-      break;
-    case '%':
-      {
-      alt24=24;
-      }
-      break;
-    case '*':
-      {
-      alt24=25;
-      }
-      break;
-    case ')':
-      {
-      alt24=26;
-      }
-      break;
-    case '-':
-      {
-      alt24=27;
-      }
-      break;
-    case '$':
-    case 'A':
-    case 'B':
-    case 'C':
-    case 'D':
-    case 'E':
-    case 'F':
-    case 'G':
-    case 'H':
-    case 'I':
-    case 'J':
-    case 'K':
-    case 'L':
-    case 'M':
-    case 'N':
-    case 'O':
-    case 'P':
-    case 'Q':
-    case 'R':
-    case 'S':
-    case 'T':
-    case 'U':
-    case 'V':
-    case 'W':
-    case 'X':
-    case 'Y':
-    case 'Z':
-    case '_':
-    case 'a':
-    case 'b':
-    case 'c':
-    case 'd':
-    case 'e':
-    case 'f':
-    case 'g':
-    case 'h':
-    case 'i':
-    case 'j':
-    case 'k':
-    case 'l':
-    case 'm':
-    case 'n':
-    case 'o':
-    case 'p':
-    case 'q':
-    case 'r':
-    case 's':
-    case 't':
-    case 'u':
-    case 'v':
-    case 'w':
-    case 'x':
-    case 'y':
-    case 'z':
-      {
-      alt24=28;
-      }
-      break;
-    case '\t':
-    case '\n':
-    case '\r':
-    case ' ':
-      {
-      alt24=29;
-      }
-      break;
-    case '0':
-      {
-      switch ( input.LA(2) ) {
-      case 'X':
-      case 'x':
-        {
-        alt24=32;
-        }
-        break;
-      case '0':
-      case '1':
-      case '2':
-      case '3':
-      case '4':
-      case '5':
-      case '6':
-      case '7':
-        {
-        alt24=31;
-        }
-        break;
-      default:
-        alt24=30;
-      }
-      }
-      break;
-    case '1':
-    case '2':
-    case '3':
-    case '4':
-    case '5':
-    case '6':
-    case '7':
-    case '8':
-    case '9':
-      {
-      alt24=30;
-      }
-      break;
-    default:
-      NoViableAltException nvae =
-        new NoViableAltException("", 24, 0, input);
-      throw nvae;
-    }
-    switch (alt24) {
-      case 1 :
-        // src/java/org/apache/lucene/expressions/js/Javascript.g:1:10: AT_ADD
-        {
-        mAT_ADD(); 
-
-        }
-        break;
-      case 2 :
-        // src/java/org/apache/lucene/expressions/js/Javascript.g:1:17: AT_BIT_AND
-        {
-        mAT_BIT_AND(); 
-
-        }
-        break;
-      case 3 :
-        // src/java/org/apache/lucene/expressions/js/Javascript.g:1:28: AT_BIT_NOT
-        {
-        mAT_BIT_NOT(); 
-
-        }
-        break;
-      case 4 :
-        // src/java/org/apache/lucene/expressions/js/Javascript.g:1:39: AT_BIT_OR
-        {
-        mAT_BIT_OR(); 
-
-        }
-        break;
-      case 5 :
-        // src/java/org/apache/lucene/expressions/js/Javascript.g:1:49: AT_BIT_SHL
-        {
-        mAT_BIT_SHL(); 
-
-        }
-        break;
-      case 6 :
-        // src/java/org/apache/lucene/expressions/js/Javascript.g:1:60: AT_BIT_SHR
-        {
-        mAT_BIT_SHR(); 
-
-        }
-        break;
-      case 7 :
-        // src/java/org/apache/lucene/expressions/js/Javascript.g:1:71: AT_BIT_SHU
-        {
-        mAT_BIT_SHU(); 
-
-        }
-        break;
-      case 8 :
-        // src/java/org/apache/lucene/expressions/js/Javascript.g:1:82: AT_BIT_XOR
-        {
-        mAT_BIT_XOR(); 
-
-        }
-        break;
-      case 9 :
-        // src/java/org/apache/lucene/expressions/js/Javascript.g:1:93: AT_BOOL_AND
-        {
-        mAT_BOOL_AND(); 
-
-        }
-        break;
-      case 10 :
-        // src/java/org/apache/lucene/expressions/js/Javascript.g:1:105: AT_BOOL_NOT
-        {
-        mAT_BOOL_NOT(); 
-
-        }
-        break;
-      case 11 :
-        // src/java/org/apache/lucene/expressions/js/Javascript.g:1:117: AT_BOOL_OR
-        {
-        mAT_BOOL_OR(); 
-
-        }
-        break;
-      case 12 :
-        // src/java/org/apache/lucene/expressions/js/Javascript.g:1:128: AT_COLON
-        {
-        mAT_COLON(); 
-
-        }
-        break;
-      case 13 :
-        // src/java/org/apache/lucene/expressions/js/Javascript.g:1:137: AT_COMMA
-        {
-        mAT_COMMA(); 
-
-        }
-        break;
-      case 14 :
-        // src/java/org/apache/lucene/expressions/js/Javascript.g:1:146: AT_COMP_EQ
-        {
-        mAT_COMP_EQ(); 
-
-        }
-        break;
-      case 15 :
-        // src/java/org/apache/lucene/expressions/js/Javascript.g:1:157: AT_COMP_GT
-        {
-        mAT_COMP_GT(); 
-
-        }
-        break;
-      case 16 :
-        // src/java/org/apache/lucene/expressions/js/Javascript.g:1:168: AT_COMP_GTE
-        {
-        mAT_COMP_GTE(); 
-
-        }
-        break;
-      case 17 :
-        // src/java/org/apache/lucene/expressions/js/Javascript.g:1:180: AT_COMP_LT
-        {
-        mAT_COMP_LT(); 
-
-        }
-        break;
-      case 18 :
-        // src/java/org/apache/lucene/expressions/js/Javascript.g:1:191: AT_COMP_LTE
-        {
-        mAT_COMP_LTE(); 
-
-        }
-        break;
-      case 19 :
-        // src/java/org/apache/lucene/expressions/js/Javascript.g:1:203: AT_COMP_NEQ
-        {
-        mAT_COMP_NEQ(); 
-
-        }
-        break;
-      case 20 :
-        // src/java/org/apache/lucene/expressions/js/Javascript.g:1:215: AT_COND_QUE
-        {
-        mAT_COND_QUE(); 
-
-        }
-        break;
-      case 21 :
-        // src/java/org/apache/lucene/expressions/js/Javascript.g:1:227: AT_DIVIDE
-        {
-        mAT_DIVIDE(); 
-
-        }
-        break;
-      case 22 :
-        // src/java/org/apache/lucene/expressions/js/Javascript.g:1:237: AT_DOT
-        {
-        mAT_DOT(); 
-
-        }
-        break;
-      case 23 :
-        // src/java/org/apache/lucene/expressions/js/Javascript.g:1:244: AT_LPAREN
-        {
-        mAT_LPAREN(); 
-
-        }
-        break;
-      case 24 :
-        // src/java/org/apache/lucene/expressions/js/Javascript.g:1:254: AT_MODULO
-        {
-        mAT_MODULO(); 
-
-        }
-        break;
-      case 25 :
-        // src/java/org/apache/lucene/expressions/js/Javascript.g:1:264: AT_MULTIPLY
-        {
-        mAT_MULTIPLY(); 
-
-        }
-        break;
-      case 26 :
-        // src/java/org/apache/lucene/expressions/js/Javascript.g:1:276: AT_RPAREN
-        {
-        mAT_RPAREN(); 
-
-        }
-        break;
-      case 27 :
-        // src/java/org/apache/lucene/expressions/js/Javascript.g:1:286: AT_SUBTRACT
-        {
-        mAT_SUBTRACT(); 
-
-        }
-        break;
-      case 28 :
-        // src/java/org/apache/lucene/expressions/js/Javascript.g:1:298: VARIABLE
-        {
-        mVARIABLE(); 
-
-        }
-        break;
-      case 29 :
-        // src/java/org/apache/lucene/expressions/js/Javascript.g:1:307: WS
-        {
-        mWS(); 
-
-        }
-        break;
-      case 30 :
-        // src/java/org/apache/lucene/expressions/js/Javascript.g:1:310: DECIMAL
-        {
-        mDECIMAL(); 
-
-        }
-        break;
-      case 31 :
-        // src/java/org/apache/lucene/expressions/js/Javascript.g:1:318: OCTAL
-        {
-        mOCTAL(); 
-
-        }
-        break;
-      case 32 :
-        // src/java/org/apache/lucene/expressions/js/Javascript.g:1:324: HEX
-        {
-        mHEX(); 
-
-        }
-        break;
-
-    }
-  }
+  public String getGrammarFileName() { return "Javascript.g"; }
 
+  @Override
+  public String[] getRuleNames() { return ruleNames; }
 
-  protected DFA16 dfa16 = new DFA16(this);
-  static final String DFA16_eotS =
-    "\1\uffff\2\4\3\uffff\1\4";
-  static final String DFA16_eofS =
-    "\7\uffff";
-  static final String DFA16_minS =
-    "\3\56\3\uffff\1\56";
-  static final String DFA16_maxS =
-    "\1\71\1\56\1\71\3\uffff\1\71";
-  static final String DFA16_acceptS =
-    "\3\uffff\1\2\1\3\1\1\1\uffff";
-  static final String DFA16_specialS =
-    "\7\uffff}>";
-  static final String[] DFA16_transitionS = {
-      "\1\3\1\uffff\1\1\11\2",
-      "\1\5",
-      "\1\5\1\uffff\12\6",
-      "",
-      "",
-      "",
-      "\1\5\1\uffff\12\6"
-  };
+  @Override
+  public String getSerializedATN() { return _serializedATN; }
 
-  static final short[] DFA16_eot = DFA.unpackEncodedString(DFA16_eotS);
-  static final short[] DFA16_eof = DFA.unpackEncodedString(DFA16_eofS);
-  static final char[] DFA16_min = DFA.unpackEncodedStringToUnsignedChars(DFA16_minS);
-  static final char[] DFA16_max = DFA.unpackEncodedStringToUnsignedChars(DFA16_maxS);
-  static final short[] DFA16_accept = DFA.unpackEncodedString(DFA16_acceptS);
-  static final short[] DFA16_special = DFA.unpackEncodedString(DFA16_specialS);
-  static final short[][] DFA16_transition;
+  @Override
+  public String[] getModeNames() { return modeNames; }
 
+  @Override
+  public ATN getATN() { return _ATN; }
+
+  public static final String _serializedATN =
+    "\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd\2!\u00fe\b\1\4\2\t"+
+    "\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7\4\b\t\b\4\t\t\t\4\n\t\n\4\13"+
+    "\t\13\4\f\t\f\4\r\t\r\4\16\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22"+
+    "\4\23\t\23\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31\t\31"+
+    "\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36\4\37\t\37\4 \t \4!"+
+    "\t!\4\"\t\"\4#\t#\4$\t$\3\2\3\2\3\3\3\3\3\4\3\4\3\5\3\5\3\6\3\6\3\7\3"+
+    "\7\3\b\3\b\3\t\3\t\3\n\3\n\3\13\3\13\3\f\3\f\3\f\3\r\3\r\3\r\3\16\3\16"+
+    "\3\16\3\16\3\17\3\17\3\20\3\20\3\20\3\21\3\21\3\22\3\22\3\22\3\23\3\23"+
+    "\3\23\3\24\3\24\3\24\3\25\3\25\3\26\3\26\3\27\3\27\3\30\3\30\3\30\3\31"+
+    "\3\31\3\31\3\32\3\32\3\33\3\33\3\34\6\34\u0089\n\34\r\34\16\34\u008a\3"+
+    "\34\3\34\3\35\3\35\7\35\u0091\n\35\f\35\16\35\u0094\13\35\3\35\3\35\3"+
+    "\35\7\35\u0099\n\35\f\35\16\35\u009c\13\35\7\35\u009e\n\35\f\35\16\35"+
+    "\u00a1\13\35\3\36\3\36\3\36\5\36\u00a6\n\36\3\36\3\36\3\37\3\37\7\37\u00ac"+
+    "\n\37\f\37\16\37\u00af\13\37\3 \3 \3 \3 \3 \3 \7 \u00b7\n \f \16 \u00ba"+
+    "\13 \3 \3 \3 \3 \3 \3 \3 \7 \u00c3\n \f \16 \u00c6\13 \3 \5 \u00c9\n "+
+    "\3!\3!\6!\u00cd\n!\r!\16!\u00ce\3\"\3\"\3\"\6\"\u00d4\n\"\r\"\16\"\u00d5"+
+    "\3#\3#\3#\7#\u00db\n#\f#\16#\u00de\13#\5#\u00e0\n#\3#\3#\6#\u00e4\n#\r"+
+    "#\16#\u00e5\5#\u00e8\n#\3#\3#\5#\u00ec\n#\3#\6#\u00ef\n#\r#\16#\u00f0"+
+    "\5#\u00f3\n#\3$\3$\3$\7$\u00f8\n$\f$\16$\u00fb\13$\5$\u00fd\n$\4\u00b8"+
+    "\u00c4\2%\3\3\5\4\7\5\t\6\13\7\r\b\17\t\21\n\23\13\25\f\27\r\31\16\33"+
+    "\17\35\20\37\21!\22#\23%\24\'\25)\26+\27-\30/\31\61\32\63\33\65\34\67"+
+    "\359\36;\2=\2?\2A\37C E!G\2\3\2%\3\2**\3\2++\3\2..\3\2##\3\2\u0080\u0080"+
+    "\3\2,,\3\2\61\61\3\2\'\'\3\2--\3\2//\3\2>>\3\2@@\3\2((\3\2``\3\2~~\3\2"+
+    "AA\3\2<<\5\2\13\f\17\17\"\"\3\2\60\60\3\2]]\3\2^_\6\2&&C\\aac|\7\2&&\62"+
+    ";C\\aac|\3\2))\4\2))^^\3\2$$\4\2$$^^\3\2\62\62\3\2\629\4\2ZZzz\5\2\62"+
+    ";CHch\3\2\62;\4\2GGgg\4\2--//\3\2\63;\u0111\2\3\3\2\2\2\2\5\3\2\2\2\2"+
+    "\7\3\2\2\2\2\t\3\2\2\2\2\13\3\2\2\2\2\r\3\2\2\2\2\17\3\2\2\2\2\21\3\2"+
+    "\2\2\2\23\3\2\2\2\2\25\3\2\2\2\2\27\3\2\2\2\2\31\3\2\2\2\2\33\3\2\2\2"+
+    "\2\35\3\2\2\2\2\37\3\2\2\2\2!\3\2\2\2\2#\3\2\2\2\2%\3\2\2\2\2\'\3\2\2"+
+    "\2\2)\3\2\2\2\2+\3\2\2\2\2-\3\2\2\2\2/\3\2\2\2\2\61\3\2\2\2\2\63\3\2\2"+
+    "\2\2\65\3\2\2\2\2\67\3\2\2\2\29\3\2\2\2\2A\3\2\2\2\2C\3\2\2\2\2E\3\2\2"+
+    "\2\3I\3\2\2\2\5K\3\2\2\2\7M\3\2\2\2\tO\3\2\2\2\13Q\3\2\2\2\rS\3\2\2\2"+
+    "\17U\3\2\2\2\21W\3\2\2\2\23Y\3\2\2\2\25[\3\2\2\2\27]\3\2\2\2\31`\3\2\2"+
+    "\2\33c\3\2\2\2\35g\3\2\2\2\37i\3\2\2\2!l\3\2\2\2#n\3\2\2\2%q\3\2\2\2\'"+
+    "t\3\2\2\2)w\3\2\2\2+y\3\2\2\2-{\3\2\2\2/}\3\2\2\2\61\u0080\3\2\2\2\63"+
+    "\u0083\3\2\2\2\65\u0085\3\2\2\2\67\u0088\3\2\2\29\u008e\3\2\2\2;\u00a2"+
+    "\3\2\2\2=\u00a9\3\2\2\2?\u00c8\3\2\2\2A\u00ca\3\2\2\2C\u00d0\3\2\2\2E"+
+    "\u00e7\3\2\2\2G\u00fc\3\2\2\2IJ\t\2\2\2J\4\3\2\2\2KL\t\3\2\2L\6\3\2\2"+
+    "\2MN\t\4\2\2N\b\3\2\2\2OP\t\5\2\2P\n\3\2\2\2QR\t\6\2\2R\f\3\2\2\2ST\t"+
+    "\7\2\2T\16\3\2\2\2UV\t\b\2\2V\20\3\2\2\2WX\t\t\2\2X\22\3\2\2\2YZ\t\n\2"+
+    "\2Z\24\3\2\2\2[\\\t\13\2\2\\\26\3\2\2\2]^\7>\2\2^_\7>\2\2_\30\3\2\2\2"+
+    "`a\7@\2\2ab\7@\2\2b\32\3\2\2\2cd\7@\2\2de\7@\2\2ef\7@\2\2f\34\3\2\2\2"+
+    "gh\t\f\2\2h\36\3\2\2\2ij\7>\2\2jk\7?\2\2k \3\2\2\2lm\t\r\2\2m\"\3\2\2"+
+    "\2no\7@\2\2op\7?\2\2p$\3\2\2\2qr\7?\2\2rs\7?\2\2s&\3\2\2\2tu\7#\2\2uv"+
+    "\7?\2\2v(\3\2\2\2wx\t\16\2\2x*\3\2\2\2yz\t\17\2\2z,\3\2\2\2{|\t\20\2\2"+
+    "|.\3\2\2\2}~\7(\2\2~\177\7(\2\2\177\60\3\2\2\2\u0080\u0081\7~\2\2\u0081"+
+    "\u0082\7~\2\2\u0082\62\3\2\2\2\u0083\u0084\t\21\2\2\u0084\64\3\2\2\2\u0085"+
+    "\u0086\t\22\2\2\u0086\66\3\2\2\2\u0087\u0089\t\23\2\2\u0088\u0087\3\2"+
+    "\2\2\u0089\u008a\3\2\2\2\u008a\u0088\3\2\2\2\u008a\u008b\3\2\2\2\u008b"+
+    "\u008c\3\2\2\2\u008c\u008d\b\34\2\2\u008d8\3\2\2\2\u008e\u0092\5=\37\2"+
+    "\u008f\u0091\5;\36\2\u0090\u008f\3\2\2\2\u0091\u0094\3\2\2\2\u0092\u0090"+
+    "\3\2\2\2\u0092\u0093\3\2\2\2\u0093\u009f\3\2\2\2\u0094\u0092\3\2\2\2\u0095"+
+    "\u0096\t\24\2\2\u0096\u009a\5=\37\2\u0097\u0099\5;\36\2\u0098\u0097\3"+
+    "\2\2\2\u0099\u009c\3\2\2\2\u009a\u0098\3\2\2\2\u009a\u009b\3\2\2\2\u009b"+
+    "\u009e\3\2\2\2\u009c\u009a\3\2\2\2\u009d\u0095\3\2\2\2\u009e\u00a1\3\2"+
+    "\2\2\u009f\u009d\3\2\2\2\u009f\u00a0\3\2\2\2\u00a0:\3\2\2\2\u00a1\u009f"+
+    "\3\2\2\2\u00a2\u00a5\t\25\2\2\u00a3\u00a6\5? \2\u00a4\u00a6\5G$\2\u00a5"+
+    "\u00a3\3\2\2\2\u00a5\u00a4\3\2\2\2\u00a6\u00a7\3\2\2\2\u00a7\u00a8\t\26"+
+    "\2\2\u00a8<\3\2\2\2\u00a9\u00ad\t\27\2\2\u00aa\u00ac\t\30\2\2\u00ab\u00aa"+
+    "\3\2\2\2\u00ac\u00af\3\2\2\2\u00ad\u00ab\3\2\2\2\u00ad\u00ae\3\2\2\2\u00ae"+
+    ">\3\2\2\2\u00af\u00ad\3\2\2\2\u00b0\u00b8\t\31\2\2\u00b1\u00b2\7^\2\2"+
+    "\u00b2\u00b7\7)\2\2\u00b3\u00b4\7^\2\2\u00b4\u00b7\7^\2\2\u00b5\u00b7"+
+    "\n\32\2\2\u00b6\u00b1\3\2\2\2\u00b6\u00b3\3\2\2\2\u00b6\u00b5\3\2\2\2"+
+    "\u00b7\u00ba\3\2\2\2\u00b8\u00b9\3\2\2\2\u00b8\u00b6\3\2\2\2\u00b9\u00bb"+
+    "\3\2\2\2\u00ba\u00b8\3\2\2\2\u00bb\u00c9\t\31\2\2\u00bc\u00c4\t\33\2\2"+
+    "\u00bd\u00be\7^\2\2\u00be\u00c3\7$\2\2\u00bf\u00c0\7^\2\2\u00c0\u00c3"+
+    "\7^\2\2\u00c1\u00c3\n\34\2\2\u00c2\u00bd\3\2\2\2\u00c2\u00bf\3\2\2\2\u00c2"+
+    "\u00c1\3\2\2\2\u00c3\u00c6\3\2\2\2\u00c4\u00c5\3\2\2\2\u00c4\u00c2\3\2"+
+    "\2\2\u00c5\u00c7\3\2\2\2\u00c6\u00c4\3\2\2\2\u00c7\u00c9\t\33\2\2\u00c8"+
+    "\u00b0\3\2\2\2\u00c8\u00bc\3\2\2\2\u00c9@\3\2\2\2\u00ca\u00cc\t\35\2\2"+
+    "\u00cb\u00cd\t\36\2\2\u00cc\u00cb\3\2\2\2\u00cd\u00ce\3\2\2\2\u00ce\u00cc"+
+    "\3\2\2\2\u00ce\u00cf\3\2\2\2\u00cfB\3\2\2\2\u00d0\u00d1\t\35\2\2\u00d1"+
+    "\u00d3\t\37\2\2\u00d2\u00d4\t \2\2\u00d3\u00d2\3\2\2\2\u00d4\u00d5\3\2"+
+    "\2\2\u00d5\u00d3\3\2\2\2\u00d5\u00d6\3\2\2\2\u00d6D\3\2\2\2\u00d7\u00df"+
+    "\5G$\2\u00d8\u00dc\t\24\2\2\u00d9\u00db\t!\2\2\u00da\u00d9\3\2\2\2\u00db"+
+    "\u00de\3\2\2\2\u00dc\u00da\3\2\2\2\u00dc\u00dd\3\2\2\2\u00dd\u00e0\3\2"+
+    "\2\2\u00de\u00dc\3\2\2\2\u00df\u00d8\3\2\2\2\u00df\u00e0\3\2\2\2\u00e0"+
+    "\u00e8\3\2\2\2\u00e1\u00e3\t\24\2\2\u00e2\u00e4\t!\2\2\u00e3\u00e2\3\2"+
+    "\2\2\u00e4\u00e5\3\2\2\2\u00e5\u00e3\3\2\2\2\u00e5\u00e6\3\2\2\2\u00e6"+
+    "\u00e8\3\2\2\2\u00e7\u00d7\3\2\2\2\u00e7\u00e1\3\2\2\2\u00e8\u00f2\3\2"+
+    "\2\2\u00e9\u00eb\t\"\2\2\u00ea\u00ec\t#\2\2\u00eb\u00ea\3\2\2\2\u00eb"+
+    "\u00ec\3\2\2\2\u00ec\u00ee\3\2\2\2\u00ed\u00ef\t!\2\2\u00ee\u00ed\3\2"+
+    "\2\2\u00ef\u00f0\3\2\2\2\u00f0\u00ee\3\2\2\2\u00f0\u00f1\3\2\2\2\u00f1"+
+    "\u00f3\3\2\2\2\u00f2\u00e9\3\2\2\2\u00f2\u00f3\3\2\2\2\u00f3F\3\2\2\2"+
+    "\u00f4\u00fd\t\35\2\2\u00f5\u00f9\t$\2\2\u00f6\u00f8\t!\2\2\u00f7\u00f6"+
+    "\3\2\2\2\u00f8\u00fb\3\2\2\2\u00f9\u00f7\3\2\2\2\u00f9\u00fa\3\2\2\2\u00fa"+
+    "\u00fd\3\2\2\2\u00fb\u00f9\3\2\2\2\u00fc\u00f4\3\2\2\2\u00fc\u00f5\3\2"+
+    "\2\2\u00fdH\3\2\2\2\31\2\u008a\u0092\u009a\u009f\u00a5\u00ad\u00b6\u00b8"+
+    "\u00c2\u00c4\u00c8\u00ce\u00d5\u00dc\u00df\u00e5\u00e7\u00eb\u00f0\u00f2"+
+    "\u00f9\u00fc\3\b\2\2";
+  public static final ATN _ATN =
+    new ATNDeserializer().deserialize(_serializedATN.toCharArray());
   static {
-    int numStates = DFA16_transitionS.length;
-    DFA16_transition = new short[numStates][];
-    for (int i=0; i<numStates; i++) {
-      DFA16_transition[i] = DFA.unpackEncodedString(DFA16_transitionS[i]);
+    _decisionToDFA = new DFA[_ATN.getNumberOfDecisions()];
+    for (int i = 0; i < _ATN.getNumberOfDecisions(); i++) {
+      _decisionToDFA[i] = new DFA(_ATN.getDecisionState(i), i);
     }
   }
-
-  protected class DFA16 extends DFA {
-
-    public DFA16(BaseRecognizer recognizer) {
-      this.recognizer = recognizer;
-      this.decisionNumber = 16;
-      this.eot = DFA16_eot;
-      this.eof = DFA16_eof;
-      this.min = DFA16_min;
-      this.max = DFA16_max;
-      this.accept = DFA16_accept;
-      this.special = DFA16_special;
-      this.transition = DFA16_transition;
-    }
-    @Override
-    public String getDescription() {
-      return "377:1: DECIMAL : ( DECIMALINTEGER AT_DOT ( DECIMALDIGIT )* ( EXPONENT )? | AT_DOT ( DECIMALDIGIT )+ ( EXPONENT )? | DECIMALINTEGER ( EXPONENT )? );";
-    }
-  }
-
 }
diff --git a/lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptLexer.tokens b/lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptLexer.tokens
new file mode 100644
index 0000000..01e31ee
--- /dev/null
+++ b/lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptLexer.tokens
@@ -0,0 +1,40 @@
+LP=1
+RP=2
+COMMA=3
+BOOLNOT=4
+BWNOT=5
+MUL=6
+DIV=7
+REM=8
+ADD=9
+SUB=10
+LSH=11
+RSH=12
+USH=13
+LT=14
+LTE=15
+GT=16
+GTE=17
+EQ=18
+NE=19
+BWAND=20
+BWXOR=21
+BWOR=22
+BOOLAND=23
+BOOLOR=24
+COND=25
+COLON=26
+WS=27
+VARIABLE=28
+OCTAL=29
+HEX=30
+DECIMAL=31
+'<<'=11
+'>>'=12
+'>>>'=13
+'<='=15
+'>='=17
+'=='=18
+'!='=19
+'&&'=23
+'||'=24
diff --git a/lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptParser.java b/lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptParser.java
index 0bc00b4..e93486b 100644
--- a/lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptParser.java
+++ b/lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptParser.java
@@ -1,1971 +1,749 @@
 // ANTLR GENERATED CODE: DO NOT EDIT
-
 package org.apache.lucene.expressions.js;
-    
-import java.text.ParseException;
-
-
-import org.antlr.runtime.*;
-import java.util.Stack;
+import org.antlr.v4.runtime.atn.*;
+import org.antlr.v4.runtime.dfa.DFA;
+import org.antlr.v4.runtime.*;
+import org.antlr.v4.runtime.misc.*;
+import org.antlr.v4.runtime.tree.*;
 import java.util.List;
+import java.util.Iterator;
 import java.util.ArrayList;
 
-import org.antlr.runtime.tree.*;
-
-
-@SuppressWarnings("all")
+@SuppressWarnings({"all", "warnings", "unchecked", "unused", "cast"})
 class JavascriptParser extends Parser {
-  public static final String[] tokenNames = new String[] {
-    "<invalid>", "<EOR>", "<DOWN>", "<UP>", "ARRAY", "AT_ADD", "AT_BIT_AND", 
-    "AT_BIT_NOT", "AT_BIT_OR", "AT_BIT_SHL", "AT_BIT_SHR", "AT_BIT_SHU", "AT_BIT_XOR", 
-    "AT_BOOL_AND", "AT_BOOL_NOT", "AT_BOOL_OR", "AT_CALL", "AT_COLON", "AT_COMMA", 
-    "AT_COMP_EQ", "AT_COMP_GT", "AT_COMP_GTE", "AT_COMP_LT", "AT_COMP_LTE", 
-    "AT_COMP_NEQ", "AT_COND_QUE", "AT_DIVIDE", "AT_DOT", "AT_LPAREN", "AT_MODULO", 
-    "AT_MULTIPLY", "AT_NEGATE", "AT_RPAREN", "AT_SUBTRACT", "DECIMAL", "DECIMALDIGIT", 
-    "DECIMALINTEGER", "DOUBLE_STRING_CHAR", "EXPONENT", "HEX", "HEXDIGIT", 
-    "ID", "OBJECT", "OCTAL", "OCTALDIGIT", "SINGLE_STRING_CHAR", "STRING", 
-    "VARIABLE", "WS"
+  static { RuntimeMetaData.checkVersion("4.5", RuntimeMetaData.VERSION); }
+
+  protected static final DFA[] _decisionToDFA;
+  protected static final PredictionContextCache _sharedContextCache =
+    new PredictionContextCache();
+  public static final int
+    LP=1, RP=2, COMMA=3, BOOLNOT=4, BWNOT=5, MUL=6, DIV=7, REM=8, ADD=9, SUB=10, 
+    LSH=11, RSH=12, USH=13, LT=14, LTE=15, GT=16, GTE=17, EQ=18, NE=19, BWAND=20, 
+    BWXOR=21, BWOR=22, BOOLAND=23, BOOLOR=24, COND=25, COLON=26, WS=27, VARIABLE=28, 
+    OCTAL=29, HEX=30, DECIMAL=31;
+  public static final int
+    RULE_compile = 0, RULE_expression = 1;
+  public static final String[] ruleNames = {
+    "compile", "expression"
   };
-  public static final int EOF=-1;
-  public static final int ARRAY=4;
-  public static final int AT_ADD=5;
-  public static final int AT_BIT_AND=6;
-  public static final int AT_BIT_NOT=7;
-  public static final int AT_BIT_OR=8;
-  public static final int AT_BIT_SHL=9;
-  public static final int AT_BIT_SHR=10;
-  public static final int AT_BIT_SHU=11;
-  public static final int AT_BIT_XOR=12;
-  public static final int AT_BOOL_AND=13;
-  public static final int AT_BOOL_NOT=14;
-  public static final int AT_BOOL_OR=15;
-  public static final int AT_CALL=16;
-  public static final int AT_COLON=17;
-  public static final int AT_COMMA=18;
-  public static final int AT_COMP_EQ=19;
-  public static final int AT_COMP_GT=20;
-  public static final int AT_COMP_GTE=21;
-  public static final int AT_COMP_LT=22;
-  public static final int AT_COMP_LTE=23;
-  public static final int AT_COMP_NEQ=24;
-  public static final int AT_COND_QUE=25;
-  public static final int AT_DIVIDE=26;
-  public static final int AT_DOT=27;
-  public static final int AT_LPAREN=28;
-  public static final int AT_MODULO=29;
-  public static final int AT_MULTIPLY=30;
-  public static final int AT_NEGATE=31;
-  public static final int AT_RPAREN=32;
-  public static final int AT_SUBTRACT=33;
-  public static final int DECIMAL=34;
-  public static final int DECIMALDIGIT=35;
-  public static final int DECIMALINTEGER=36;
-  public static final int DOUBLE_STRING_CHAR=37;
-  public static final int EXPONENT=38;
-  public static final int HEX=39;
-  public static final int HEXDIGIT=40;
-  public static final int ID=41;
-  public static final int OBJECT=42;
-  public static final int OCTAL=43;
-  public static final int OCTALDIGIT=44;
-  public static final int SINGLE_STRING_CHAR=45;
-  public static final int STRING=46;
-  public static final int VARIABLE=47;
-  public static final int WS=48;
-
-  // delegates
-  public Parser[] getDelegates() {
-    return new Parser[] {};
-  }
 
-  // delegators
+  private static final String[] _LITERAL_NAMES = {
+    null, null, null, null, null, null, null, null, null, null, null, "'<<'", 
+    "'>>'", "'>>>'", null, "'<='", null, "'>='", "'=='", "'!='", null, null, 
+    null, "'&&'", "'||'"
+  };
+  private static final String[] _SYMBOLIC_NAMES = {
+    null, "LP", "RP", "COMMA", "BOOLNOT", "BWNOT", "MUL", "DIV", "REM", "ADD", 
+    "SUB", "LSH", "RSH", "USH", "LT", "LTE", "GT", "GTE", "EQ", "NE", "BWAND", 
+    "BWXOR", "BWOR", "BOOLAND", "BOOLOR", "COND", "COLON", "WS", "VARIABLE", 
+    "OCTAL", "HEX", "DECIMAL"
+  };
+  public static final Vocabulary VOCABULARY = new VocabularyImpl(_LITERAL_NAMES, _SYMBOLIC_NAMES);
 
+  /**
+   * @deprecated Use {@link #VOCABULARY} instead.
+   */
+  @Deprecated
+  public static final String[] tokenNames;
+  static {
+    tokenNames = new String[_SYMBOLIC_NAMES.length];
+    for (int i = 0; i < tokenNames.length; i++) {
+      tokenNames[i] = VOCABULARY.getLiteralName(i);
+      if (tokenNames[i] == null) {
+        tokenNames[i] = VOCABULARY.getSymbolicName(i);
+      }
 
-  public JavascriptParser(TokenStream input) {
-    this(input, new RecognizerSharedState());
-  }
-  public JavascriptParser(TokenStream input, RecognizerSharedState state) {
-    super(input, state);
+      if (tokenNames[i] == null) {
+        tokenNames[i] = "<INVALID>";
+      }
+    }
   }
 
-  protected TreeAdaptor adaptor = new CommonTreeAdaptor();
-
-  public void setTreeAdaptor(TreeAdaptor adaptor) {
-    this.adaptor = adaptor;
-  }
-  public TreeAdaptor getTreeAdaptor() {
-    return adaptor;
+  @Override
+  @Deprecated
+  public String[] getTokenNames() {
+    return tokenNames;
   }
-  @Override public String[] getTokenNames() { return JavascriptParser.tokenNames; }
-  @Override public String getGrammarFileName() { return "src/java/org/apache/lucene/expressions/js/Javascript.g"; }
-
-
 
   @Override
-  public void displayRecognitionError(String[] tokenNames, RecognitionException re) {
-      String message;
 
-      if (re.token == null) {
-          message = " unknown error (missing token).";
-      }
-      else if (re instanceof UnwantedTokenException) {
-          message = " extraneous " + getReadableTokenString(re.token)
-                  +  " at position (" + re.charPositionInLine + ").";
-      }
-      else if (re instanceof MissingTokenException) {
-          message = " missing " + getReadableTokenString(re.token)
-                  +  " at position (" + re.charPositionInLine + ").";
-      }
-      else if (re instanceof NoViableAltException) {
-          switch (re.token.getType()) {
-          case EOF:
-              message = " unexpected end of expression.";
-              break;
-          default:
-              message = " invalid sequence of tokens near " + getReadableTokenString(re.token)
-                      +  " at position (" + re.charPositionInLine + ").";
-              break;
-          }
-      }
-      else {
-          message = " unexpected token " + getReadableTokenString(re.token) 
-                  +  " at position (" + re.charPositionInLine + ").";
-      }
-      ParseException parseException = new ParseException(message, re.charPositionInLine);
-      parseException.initCause(re);
-      throw new RuntimeException(parseException);
+  public Vocabulary getVocabulary() {
+    return VOCABULARY;
   }
 
-  public static String getReadableTokenString(Token token) {
-      if (token == null) {
-          return "unknown token";
-      }
+  @Override
+  public String getGrammarFileName() { return "Javascript.g"; }
 
-      switch (token.getType()) {
-      case AT_LPAREN:
-          return "open parenthesis '('";
-      case AT_RPAREN:
-          return "close parenthesis ')'";
-      case AT_COMP_LT:
-          return "less than '<'";
-      case AT_COMP_LTE:
-          return "less than or equal '<='";
-      case AT_COMP_GT:
-          return "greater than '>'";
-      case AT_COMP_GTE:
-          return "greater than or equal '>='";
-      case AT_COMP_EQ:
-          return "equal '=='";
-      case AT_NEGATE:
-          return "negate '!='";
-      case AT_BOOL_NOT:
-          return "boolean not '!'";
-      case AT_BOOL_AND:
-          return "boolean and '&&'";
-      case AT_BOOL_OR:
-          return "boolean or '||'";
-      case AT_COND_QUE:
-          return "conditional '?'";
-      case AT_ADD:
-          return "addition '+'";
-      case AT_SUBTRACT:
-          return "subtraction '-'";
-      case AT_MULTIPLY:
-          return "multiplication '*'";
-      case AT_DIVIDE:
-          return "division '/'";
-      case AT_MODULO:
-          return "modulo '%'";
-      case AT_BIT_SHL:
-          return "bit shift left '<<'";
-      case AT_BIT_SHR:
-          return "bit shift right '>>'";
-      case AT_BIT_SHU:
-          return "unsigned bit shift right '>>>'";
-      case AT_BIT_AND:
-          return "bitwise and '&'";
-      case AT_BIT_OR:
-          return "bitwise or '|'";
-      case AT_BIT_XOR:
-          return "bitwise xor '^'";
-      case AT_BIT_NOT:
-          return "bitwise not '~'";
-      case ID:
-          return "identifier '" + token.getText() + "'";
-      case DECIMAL:
-          return "decimal '" + token.getText() + "'";
-      case OCTAL:
-          return "octal '" + token.getText() + "'";
-      case HEX:
-          return "hex '" + token.getText() + "'";
-      case EOF:
-          return "end of expression";
-      default:
-          return "'" + token.getText() + "'";
-      }
-  }
+  @Override
+  public String[] getRuleNames() { return ruleNames; }
 
+  @Override
+  public String getSerializedATN() { return _serializedATN; }
 
+  @Override
+  public ATN getATN() { return _ATN; }
 
-  public static class expression_return extends ParserRuleReturnScope {
-    CommonTree tree;
+  public JavascriptParser(TokenStream input) {
+    super(input);
+    _interp = new ParserATNSimulator(this,_ATN,_decisionToDFA,_sharedContextCache);
+  }
+  public static class CompileContext extends ParserRuleContext {
+    public ExpressionContext expression() {
+      return getRuleContext(ExpressionContext.class,0);
+    }
+    public TerminalNode EOF() { return getToken(JavascriptParser.EOF, 0); }
+    public CompileContext(ParserRuleContext parent, int invokingState) {
+      super(parent, invokingState);
+    }
+    @Override public int getRuleIndex() { return RULE_compile; }
     @Override
-    public CommonTree getTree() { return tree; }
-  };
-
-
-  // $ANTLR start "expression"
-  // src/java/org/apache/lucene/expressions/js/Javascript.g:250:1: expression : conditional EOF !;
-  public final JavascriptParser.expression_return expression() throws RecognitionException {
-    JavascriptParser.expression_return retval = new JavascriptParser.expression_return();
-    retval.start = input.LT(1);
-
-    CommonTree root_0 = null;
-
-    Token EOF2=null;
-    ParserRuleReturnScope conditional1 =null;
-
-    CommonTree EOF2_tree=null;
+    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
+      if ( visitor instanceof JavascriptVisitor ) return ((JavascriptVisitor<? extends T>)visitor).visitCompile(this);
+      else return visitor.visitChildren(this);
+    }
+  }
 
+  public final CompileContext compile() throws RecognitionException {
+    CompileContext _localctx = new CompileContext(_ctx, getState());
+    enterRule(_localctx, 0, RULE_compile);
     try {
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:251:5: ( conditional EOF !)
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:251:7: conditional EOF !
+      enterOuterAlt(_localctx, 1);
       {
-      root_0 = (CommonTree)adaptor.nil();
-
-
-      pushFollow(FOLLOW_conditional_in_expression737);
-      conditional1=conditional();
-      state._fsp--;
-
-      adaptor.addChild(root_0, conditional1.getTree());
-
-      EOF2=(Token)match(input,EOF,FOLLOW_EOF_in_expression739); 
+      setState(4);
+      expression(0);
+      setState(5);
+      match(EOF);
       }
-
-      retval.stop = input.LT(-1);
-
-      retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
-      adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
-
     }
     catch (RecognitionException re) {
-      reportError(re);
-      recover(input,re);
-      retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+      _localctx.exception = re;
+      _errHandler.reportError(this, re);
+      _errHandler.recover(this, re);
     }
     finally {
-      // do for sure before leaving
+      exitRule();
     }
-    return retval;
+    return _localctx;
   }
-  // $ANTLR end "expression"
-
 
-  public static class conditional_return extends ParserRuleReturnScope {
-    CommonTree tree;
+  public static class ExpressionContext extends ParserRuleContext {
+    public ExpressionContext(ParserRuleContext parent, int invokingState) {
+      super(parent, invokingState);
+    }
+    @Override public int getRuleIndex() { return RULE_expression; }
+   
+    public ExpressionContext() { }
+    public void copyFrom(ExpressionContext ctx) {
+      super.copyFrom(ctx);
+    }
+  }
+  public static class ConditionalContext extends ExpressionContext {
+    public List<ExpressionContext> expression() {
+      return getRuleContexts(ExpressionContext.class);
+    }
+    public ExpressionContext expression(int i) {
+      return getRuleContext(ExpressionContext.class,i);
+    }
+    public TerminalNode COND() { return getToken(JavascriptParser.COND, 0); }
+    public TerminalNode COLON() { return getToken(JavascriptParser.COLON, 0); }
+    public ConditionalContext(ExpressionContext ctx) { copyFrom(ctx); }
     @Override
-    public CommonTree getTree() { return tree; }
-  };
-
-
-  // $ANTLR start "conditional"
-  // src/java/org/apache/lucene/expressions/js/Javascript.g:254:1: conditional : logical_or ( AT_COND_QUE ^ conditional AT_COLON ! conditional )? ;
-  public final JavascriptParser.conditional_return conditional() throws RecognitionException {
-    JavascriptParser.conditional_return retval = new JavascriptParser.conditional_return();
-    retval.start = input.LT(1);
-
-    CommonTree root_0 = null;
-
-    Token AT_COND_QUE4=null;
-    Token AT_COLON6=null;
-    ParserRuleReturnScope logical_or3 =null;
-    ParserRuleReturnScope conditional5 =null;
-    ParserRuleReturnScope conditional7 =null;
-
-    CommonTree AT_COND_QUE4_tree=null;
-    CommonTree AT_COLON6_tree=null;
-
-    try {
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:255:5: ( logical_or ( AT_COND_QUE ^ conditional AT_COLON ! conditional )? )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:255:7: logical_or ( AT_COND_QUE ^ conditional AT_COLON ! conditional )?
-      {
-      root_0 = (CommonTree)adaptor.nil();
-
-
-      pushFollow(FOLLOW_logical_or_in_conditional757);
-      logical_or3=logical_or();
-      state._fsp--;
-
-      adaptor.addChild(root_0, logical_or3.getTree());
-
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:255:18: ( AT_COND_QUE ^ conditional AT_COLON ! conditional )?
-      int alt1=2;
-      int LA1_0 = input.LA(1);
-      if ( (LA1_0==AT_COND_QUE) ) {
-        alt1=1;
-      }
-      switch (alt1) {
-        case 1 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:255:19: AT_COND_QUE ^ conditional AT_COLON ! conditional
-          {
-          AT_COND_QUE4=(Token)match(input,AT_COND_QUE,FOLLOW_AT_COND_QUE_in_conditional760); 
-          AT_COND_QUE4_tree = (CommonTree)adaptor.create(AT_COND_QUE4);
-          root_0 = (CommonTree)adaptor.becomeRoot(AT_COND_QUE4_tree, root_0);
-
-          pushFollow(FOLLOW_conditional_in_conditional763);
-          conditional5=conditional();
-          state._fsp--;
-
-          adaptor.addChild(root_0, conditional5.getTree());
-
-          AT_COLON6=(Token)match(input,AT_COLON,FOLLOW_AT_COLON_in_conditional765); 
-          pushFollow(FOLLOW_conditional_in_conditional768);
-          conditional7=conditional();
-          state._fsp--;
-
-          adaptor.addChild(root_0, conditional7.getTree());
-
-          }
-          break;
-
-      }
-
-      }
-
-      retval.stop = input.LT(-1);
-
-      retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
-      adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
-
+    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
+      if ( visitor instanceof JavascriptVisitor ) return ((JavascriptVisitor<? extends T>)visitor).visitConditional(this);
+      else return visitor.visitChildren(this);
     }
-    catch (RecognitionException re) {
-      reportError(re);
-      recover(input,re);
-      retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+  }
+  public static class BoolorContext extends ExpressionContext {
+    public List<ExpressionContext> expression() {
+      return getRuleContexts(ExpressionContext.class);
     }
-    finally {
-      // do for sure before leaving
+    public ExpressionContext expression(int i) {
+      return getRuleContext(ExpressionContext.class,i);
+    }
+    public TerminalNode BOOLOR() { return getToken(JavascriptParser.BOOLOR, 0); }
+    public BoolorContext(ExpressionContext ctx) { copyFrom(ctx); }
+    @Override
+    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
+      if ( visitor instanceof JavascriptVisitor ) return ((JavascriptVisitor<? extends T>)visitor).visitBoolor(this);
+      else return visitor.visitChildren(this);
     }
-    return retval;
   }
-  // $ANTLR end "conditional"
-
-
-  public static class logical_or_return extends ParserRuleReturnScope {
-    CommonTree tree;
+  public static class BoolcompContext extends ExpressionContext {
+    public List<ExpressionContext> expression() {
+      return getRuleContexts(ExpressionContext.class);
+    }
+    public ExpressionContext expression(int i) {
+      return getRuleContext(ExpressionContext.class,i);
+    }
+    public TerminalNode LT() { return getToken(JavascriptParser.LT, 0); }
+    public TerminalNode LTE() { return getToken(JavascriptParser.LTE, 0); }
+    public TerminalNode GT() { return getToken(JavascriptParser.GT, 0); }
+    public TerminalNode GTE() { return getToken(JavascriptParser.GTE, 0); }
+    public BoolcompContext(ExpressionContext ctx) { copyFrom(ctx); }
     @Override
-    public CommonTree getTree() { return tree; }
-  };
-
-
-  // $ANTLR start "logical_or"
-  // src/java/org/apache/lucene/expressions/js/Javascript.g:258:1: logical_or : logical_and ( AT_BOOL_OR ^ logical_and )* ;
-  public final JavascriptParser.logical_or_return logical_or() throws RecognitionException {
-    JavascriptParser.logical_or_return retval = new JavascriptParser.logical_or_return();
-    retval.start = input.LT(1);
-
-    CommonTree root_0 = null;
-
-    Token AT_BOOL_OR9=null;
-    ParserRuleReturnScope logical_and8 =null;
-    ParserRuleReturnScope logical_and10 =null;
-
-    CommonTree AT_BOOL_OR9_tree=null;
-
-    try {
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:259:5: ( logical_and ( AT_BOOL_OR ^ logical_and )* )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:259:7: logical_and ( AT_BOOL_OR ^ logical_and )*
-      {
-      root_0 = (CommonTree)adaptor.nil();
-
-
-      pushFollow(FOLLOW_logical_and_in_logical_or787);
-      logical_and8=logical_and();
-      state._fsp--;
-
-      adaptor.addChild(root_0, logical_and8.getTree());
-
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:259:19: ( AT_BOOL_OR ^ logical_and )*
-      loop2:
-      while (true) {
-        int alt2=2;
-        int LA2_0 = input.LA(1);
-        if ( (LA2_0==AT_BOOL_OR) ) {
-          alt2=1;
-        }
-
-        switch (alt2) {
-        case 1 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:259:20: AT_BOOL_OR ^ logical_and
-          {
-          AT_BOOL_OR9=(Token)match(input,AT_BOOL_OR,FOLLOW_AT_BOOL_OR_in_logical_or790); 
-          AT_BOOL_OR9_tree = (CommonTree)adaptor.create(AT_BOOL_OR9);
-          root_0 = (CommonTree)adaptor.becomeRoot(AT_BOOL_OR9_tree, root_0);
-
-          pushFollow(FOLLOW_logical_and_in_logical_or793);
-          logical_and10=logical_and();
-          state._fsp--;
-
-          adaptor.addChild(root_0, logical_and10.getTree());
-
-          }
-          break;
-
-        default :
-          break loop2;
-        }
-      }
-
-      }
-
-      retval.stop = input.LT(-1);
-
-      retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
-      adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
-
+    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
+      if ( visitor instanceof JavascriptVisitor ) return ((JavascriptVisitor<? extends T>)visitor).visitBoolcomp(this);
+      else return visitor.visitChildren(this);
     }
-    catch (RecognitionException re) {
-      reportError(re);
-      recover(input,re);
-      retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+  }
+  public static class NumericContext extends ExpressionContext {
+    public TerminalNode OCTAL() { return getToken(JavascriptParser.OCTAL, 0); }
+    public TerminalNode HEX() { return getToken(JavascriptParser.HEX, 0); }
+    public TerminalNode DECIMAL() { return getToken(JavascriptParser.DECIMAL, 0); }
+    public NumericContext(ExpressionContext ctx) { copyFrom(ctx); }
+    @Override
+    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
+      if ( visitor instanceof JavascriptVisitor ) return ((JavascriptVisitor<? extends T>)visitor).visitNumeric(this);
+      else return visitor.visitChildren(this);
     }
-    finally {
-      // do for sure before leaving
+  }
+  public static class AddsubContext extends ExpressionContext {
+    public List<ExpressionContext> expression() {
+      return getRuleContexts(ExpressionContext.class);
+    }
+    public ExpressionContext expression(int i) {
+      return getRuleContext(ExpressionContext.class,i);
+    }
+    public TerminalNode ADD() { return getToken(JavascriptParser.ADD, 0); }
+    public TerminalNode SUB() { return getToken(JavascriptParser.SUB, 0); }
+    public AddsubContext(ExpressionContext ctx) { copyFrom(ctx); }
+    @Override
+    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
+      if ( visitor instanceof JavascriptVisitor ) return ((JavascriptVisitor<? extends T>)visitor).visitAddsub(this);
+      else return visitor.visitChildren(this);
     }
-    return retval;
   }
-  // $ANTLR end "logical_or"
-
-
-  public static class logical_and_return extends ParserRuleReturnScope {
-    CommonTree tree;
+  public static class UnaryContext extends ExpressionContext {
+    public ExpressionContext expression() {
+      return getRuleContext(ExpressionContext.class,0);
+    }
+    public TerminalNode BOOLNOT() { return getToken(JavascriptParser.BOOLNOT, 0); }
+    public TerminalNode BWNOT() { return getToken(JavascriptParser.BWNOT, 0); }
+    public TerminalNode ADD() { return getToken(JavascriptParser.ADD, 0); }
+    public TerminalNode SUB() { return getToken(JavascriptParser.SUB, 0); }
+    public UnaryContext(ExpressionContext ctx) { copyFrom(ctx); }
     @Override
-    public CommonTree getTree() { return tree; }
-  };
-
-
-  // $ANTLR start "logical_and"
-  // src/java/org/apache/lucene/expressions/js/Javascript.g:262:1: logical_and : bitwise_or ( AT_BOOL_AND ^ bitwise_or )* ;
-  public final JavascriptParser.logical_and_return logical_and() throws RecognitionException {
-    JavascriptParser.logical_and_return retval = new JavascriptParser.logical_and_return();
-    retval.start = input.LT(1);
-
-    CommonTree root_0 = null;
-
-    Token AT_BOOL_AND12=null;
-    ParserRuleReturnScope bitwise_or11 =null;
-    ParserRuleReturnScope bitwise_or13 =null;
+    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
+      if ( visitor instanceof JavascriptVisitor ) return ((JavascriptVisitor<? extends T>)visitor).visitUnary(this);
+      else return visitor.visitChildren(this);
+    }
+  }
+  public static class PrecedenceContext extends ExpressionContext {
+    public TerminalNode LP() { return getToken(JavascriptParser.LP, 0); }
+    public ExpressionContext expression() {
+      return getRuleContext(ExpressionContext.class,0);
+    }
+    public TerminalNode RP() { return getToken(JavascriptParser.RP, 0); }
+    public PrecedenceContext(ExpressionContext ctx) { copyFrom(ctx); }
+    @Override
+    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
+      if ( visitor instanceof JavascriptVisitor ) return ((JavascriptVisitor<? extends T>)visitor).visitPrecedence(this);
+      else return visitor.visitChildren(this);
+    }
+  }
+  public static class MuldivContext extends ExpressionContext {
+    public List<ExpressionContext> expression() {
+      return getRuleContexts(ExpressionContext.class);
+    }
+    public ExpressionContext expression(int i) {
+      return getRuleContext(ExpressionContext.class,i);
+    }
+    public TerminalNode MUL() { return getToken(JavascriptParser.MUL, 0); }
+    public TerminalNode DIV() { return getToken(JavascriptParser.DIV, 0); }
+    public TerminalNode REM() { return getToken(JavascriptParser.REM, 0); }
+    public MuldivContext(ExpressionContext ctx) { copyFrom(ctx); }
+    @Override
+    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
+      if ( visitor instanceof JavascriptVisitor ) return ((JavascriptVisitor<? extends T>)visitor).visitMuldiv(this);
+      else return visitor.visitChildren(this);
+    }
+  }
+  public static class ExternalContext extends ExpressionContext {
+    public TerminalNode VARIABLE() { return getToken(JavascriptParser.VARIABLE, 0); }
+    public TerminalNode LP() { return getToken(JavascriptParser.LP, 0); }
+    public TerminalNode RP() { return getToken(JavascriptParser.RP, 0); }
+    public List<ExpressionContext> expression() {
+      return getRuleContexts(ExpressionContext.class);
+    }
+    public ExpressionContext expression(int i) {
+      return getRuleContext(ExpressionContext.class,i);
+    }
+    public List<TerminalNode> COMMA() { return getTokens(JavascriptParser.COMMA); }
+    public TerminalNode COMMA(int i) {
+      return getToken(JavascriptParser.COMMA, i);
+    }
+    public ExternalContext(ExpressionContext ctx) { copyFrom(ctx); }
+    @Override
+    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
+      if ( visitor instanceof JavascriptVisitor ) return ((JavascriptVisitor<? extends T>)visitor).visitExternal(this);
+      else return visitor.visitChildren(this);
+    }
+  }
+  public static class BwshiftContext extends ExpressionContext {
+    public List<ExpressionContext> expression() {
+      return getRuleContexts(ExpressionContext.class);
+    }
+    public ExpressionContext expression(int i) {
+      return getRuleContext(ExpressionContext.class,i);
+    }
+    public TerminalNode LSH() { return getToken(JavascriptParser.LSH, 0); }
+    public TerminalNode RSH() { return getToken(JavascriptParser.RSH, 0); }
+    public TerminalNode USH() { return getToken(JavascriptParser.USH, 0); }
+    public BwshiftContext(ExpressionContext ctx) { copyFrom(ctx); }
+    @Override
+    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
+      if ( visitor instanceof JavascriptVisitor ) return ((JavascriptVisitor<? extends T>)visitor).visitBwshift(this);
+      else return visitor.visitChildren(this);
+    }
+  }
+  public static class BworContext extends ExpressionContext {
+    public List<ExpressionContext> expression() {
+      return getRuleContexts(ExpressionContext.class);
+    }
+    public ExpressionContext expression(int i) {
+      return getRuleContext(ExpressionContext.class,i);
+    }
+    public TerminalNode BWOR() { return getToken(JavascriptParser.BWOR, 0); }
+    public BworContext(ExpressionContext ctx) { copyFrom(ctx); }
+    @Override
+    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
+      if ( visitor instanceof JavascriptVisitor ) return ((JavascriptVisitor<? extends T>)visitor).visitBwor(this);
+      else return visitor.visitChildren(this);
+    }
+  }
+  public static class BoolandContext extends ExpressionContext {
+    public List<ExpressionContext> expression() {
+      return getRuleContexts(ExpressionContext.class);
+    }
+    public ExpressionContext expression(int i) {
+      return getRuleContext(ExpressionContext.class,i);
+    }
+    public TerminalNode BOOLAND() { return getToken(JavascriptParser.BOOLAND, 0); }
+    public BoolandContext(ExpressionContext ctx) { copyFrom(ctx); }
+    @Override
+    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
+      if ( visitor instanceof JavascriptVisitor ) return ((JavascriptVisitor<? extends T>)visitor).visitBooland(this);
+      else return visitor.visitChildren(this);
+    }
+  }
+  public static class BwxorContext extends ExpressionContext {
+    public List<ExpressionContext> expression() {
+      return getRuleContexts(ExpressionContext.class);
+    }
+    public ExpressionContext expression(int i) {
+      return getRuleContext(ExpressionContext.class,i);
+    }
+    public TerminalNode BWXOR() { return getToken(JavascriptParser.BWXOR, 0); }
+    public BwxorContext(ExpressionContext ctx) { copyFrom(ctx); }
+    @Override
+    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
+      if ( visitor instanceof JavascriptVisitor ) return ((JavascriptVisitor<? extends T>)visitor).visitBwxor(this);
+      else return visitor.visitChildren(this);
+    }
+  }
+  public static class BwandContext extends ExpressionContext {
+    public List<ExpressionContext> expression() {
+      return getRuleContexts(ExpressionContext.class);
+    }
+    public ExpressionContext expression(int i) {
+      return getRuleContext(ExpressionContext.class,i);
+    }
+    public TerminalNode BWAND() { return getToken(JavascriptParser.BWAND, 0); }
+    public BwandContext(ExpressionContext ctx) { copyFrom(ctx); }
+    @Override
+    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
+      if ( visitor instanceof JavascriptVisitor ) return ((JavascriptVisitor<? extends T>)visitor).visitBwand(this);
+      else return visitor.visitChildren(this);
+    }
+  }
+  public static class BooleqneContext extends ExpressionContext {
+    public List<ExpressionContext> expression() {
+      return getRuleContexts(ExpressionContext.class);
+    }
+    public ExpressionContext expression(int i) {
+      return getRuleContext(ExpressionContext.class,i);
+    }
+    public TerminalNode EQ() { return getToken(JavascriptParser.EQ, 0); }
+    public TerminalNode NE() { return getToken(JavascriptParser.NE, 0); }
+    public BooleqneContext(ExpressionContext ctx) { copyFrom(ctx); }
+    @Override
+    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
+      if ( visitor instanceof JavascriptVisitor ) return ((JavascriptVisitor<? extends T>)visitor).visitBooleqne(this);
+      else return visitor.visitChildren(this);
+    }
+  }
 
-    CommonTree AT_BOOL_AND12_tree=null;
+  public final ExpressionContext expression() throws RecognitionException {
+    return expression(0);
+  }
 
+  private ExpressionContext expression(int _p) throws RecognitionException {
+    ParserRuleContext _parentctx = _ctx;
+    int _parentState = getState();
+    ExpressionContext _localctx = new ExpressionContext(_ctx, _parentState);
+    ExpressionContext _prevctx = _localctx;
+    int _startState = 2;
+    enterRecursionRule(_localctx, 2, RULE_expression, _p);
+    int _la;
     try {
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:263:5: ( bitwise_or ( AT_BOOL_AND ^ bitwise_or )* )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:263:7: bitwise_or ( AT_BOOL_AND ^ bitwise_or )*
+      int _alt;
+      enterOuterAlt(_localctx, 1);
       {
-      root_0 = (CommonTree)adaptor.nil();
-
-
-      pushFollow(FOLLOW_bitwise_or_in_logical_and812);
-      bitwise_or11=bitwise_or();
-      state._fsp--;
-
-      adaptor.addChild(root_0, bitwise_or11.getTree());
+      setState(30);
+      switch (_input.LA(1)) {
+      case BOOLNOT:
+      case BWNOT:
+      case ADD:
+      case SUB:
+        {
+        _localctx = new UnaryContext(_localctx);
+        _ctx = _localctx;
+        _prevctx = _localctx;
 
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:263:18: ( AT_BOOL_AND ^ bitwise_or )*
-      loop3:
-      while (true) {
-        int alt3=2;
-        int LA3_0 = input.LA(1);
-        if ( (LA3_0==AT_BOOL_AND) ) {
-          alt3=1;
+        setState(8);
+        _la = _input.LA(1);
+        if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << BOOLNOT) | (1L << BWNOT) | (1L << ADD) | (1L << SUB))) != 0)) ) {
+        _errHandler.recoverInline(this);
+        } else {
+          consume();
         }
-
-        switch (alt3) {
-        case 1 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:263:19: AT_BOOL_AND ^ bitwise_or
+        setState(9);
+        expression(12);
+        }
+        break;
+      case LP:
+        {
+        _localctx = new PrecedenceContext(_localctx);
+        _ctx = _localctx;
+        _prevctx = _localctx;
+        setState(10);
+        match(LP);
+        setState(11);
+        expression(0);
+        setState(12);
+        match(RP);
+        }
+        break;
+      case OCTAL:
+      case HEX:
+      case DECIMAL:
+        {
+        _localctx = new NumericContext(_localctx);
+        _ctx = _localctx;
+        _prevctx = _localctx;
+        setState(14);
+        _la = _input.LA(1);
+        if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << OCTAL) | (1L << HEX) | (1L << DECIMAL))) != 0)) ) {
+        _errHandler.recoverInline(this);
+        } else {
+          consume();
+        }
+        }
+        break;
+      case VARIABLE:
+        {
+        _localctx = new ExternalContext(_localctx);
+        _ctx = _localctx;
+        _prevctx = _localctx;
+        setState(15);
+        match(VARIABLE);
+        setState(28);
+        switch ( getInterpreter().adaptivePredict(_input,2,_ctx) ) {
+        case 1:
           {
-          AT_BOOL_AND12=(Token)match(input,AT_BOOL_AND,FOLLOW_AT_BOOL_AND_in_logical_and815); 
-          AT_BOOL_AND12_tree = (CommonTree)adaptor.create(AT_BOOL_AND12);
-          root_0 = (CommonTree)adaptor.becomeRoot(AT_BOOL_AND12_tree, root_0);
-
-          pushFollow(FOLLOW_bitwise_or_in_logical_and818);
-          bitwise_or13=bitwise_or();
-          state._fsp--;
-
-          adaptor.addChild(root_0, bitwise_or13.getTree());
+          setState(16);
+          match(LP);
+          setState(25);
+          _la = _input.LA(1);
+          if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << LP) | (1L << BOOLNOT) | (1L << BWNOT) | (1L << ADD) | (1L << SUB) | (1L << VARIABLE) | (1L << OCTAL) | (1L << HEX) | (1L << DECIMAL))) != 0)) {
+            {
+            setState(17);
+            expression(0);
+            setState(22);
+            _errHandler.sync(this);
+            _la = _input.LA(1);
+            while (_la==COMMA) {
+              {
+              {
+              setState(18);
+              match(COMMA);
+              setState(19);
+              expression(0);
+              }
+              }
+              setState(24);
+              _errHandler.sync(this);
+              _la = _input.LA(1);
+            }
+            }
+          }
 
+          setState(27);
+          match(RP);
           }
           break;
-
-        default :
-          break loop3;
         }
+        }
+        break;
+      default:
+        throw new NoViableAltException(this);
+      }
+      _ctx.stop = _input.LT(-1);
+      setState(70);
+      _errHandler.sync(this);
+      _alt = getInterpreter().adaptivePredict(_input,5,_ctx);
+      while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {
+        if ( _alt==1 ) {
+          if ( _parseListeners!=null ) triggerExitRuleEvent();
+          _prevctx = _localctx;
+          {
+          setState(68);
+          switch ( getInterpreter().adaptivePredict(_input,4,_ctx) ) {
+          case 1:
+            {
+            _localctx = new MuldivContext(new ExpressionContext(_parentctx, _parentState));
+            pushNewRecursionContext(_localctx, _startState, RULE_expression);
+            setState(32);
+            if (!(precpred(_ctx, 11))) throw new FailedPredicateException(this, "precpred(_ctx, 11)");
+            setState(33);
+            _la = _input.LA(1);
+            if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << MUL) | (1L << DIV) | (1L << REM))) != 0)) ) {
+            _errHandler.recoverInline(this);
+            } else {
+              consume();
+            }
+            setState(34);
+            expression(12);
+            }
+            break;
+          case 2:
+            {
+            _localctx = new AddsubContext(new ExpressionContext(_parentctx, _parentState));
+            pushNewRecursionContext(_localctx, _startState, RULE_expression);
+            setState(35);
+            if (!(precpred(_ctx, 10))) throw new FailedPredicateException(this, "precpred(_ctx, 10)");
+            setState(36);
+            _la = _input.LA(1);
+            if ( !(_la==ADD || _la==SUB) ) {
+            _errHandler.recoverInline(this);
+            } else {
+              consume();
+            }
+            setState(37);
+            expression(11);
+            }
+            break;
+          case 3:
+            {
+            _localctx = new BwshiftContext(new ExpressionContext(_parentctx, _parentState));
+            pushNewRecursionContext(_localctx, _startState, RULE_expression);
+            setState(38);
+            if (!(precpred(_ctx, 9))) throw new FailedPredicateException(this, "precpred(_ctx, 9)");
+            setState(39);
+            _la = _input.LA(1);
+            if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << LSH) | (1L << RSH) | (1L << USH))) != 0)) ) {
+            _errHandler.recoverInline(this);
+            } else {
+              consume();
+            }
+            setState(40);
+            expression(10);
+            }
+            break;
+          case 4:
+            {
+            _localctx = new BoolcompContext(new ExpressionContext(_parentctx, _parentState));
+            pushNewRecursionContext(_localctx, _startState, RULE_expression);
+            setState(41);
+            if (!(precpred(_ctx, 8))) throw new FailedPredicateException(this, "precpred(_ctx, 8)");
+            setState(42);
+            _la = _input.LA(1);
+            if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << LT) | (1L << LTE) | (1L << GT) | (1L << GTE))) != 0)) ) {
+            _errHandler.recoverInline(this);
+            } else {
+              consume();
+            }
+            setState(43);
+            expression(9);
+            }
+            break;
+          case 5:
+            {
+            _localctx = new BooleqneContext(new ExpressionContext(_parentctx, _parentState));
+            pushNewRecursionContext(_localctx, _startState, RULE_expression);
+            setState(44);
+            if (!(precpred(_ctx, 7))) throw new FailedPredicateException(this, "precpred(_ctx, 7)");
+            setState(45);
+            _la = _input.LA(1);
+            if ( !(_la==EQ || _la==NE) ) {
+            _errHandler.recoverInline(this);
+            } else {
+              consume();
+            }
+            setState(46);
+            expression(8);
+            }
+            break;
+          case 6:
+            {
+            _localctx = new BwandContext(new ExpressionContext(_parentctx, _parentState));
+            pushNewRecursionContext(_localctx, _startState, RULE_expression);
+            setState(47);
+            if (!(precpred(_ctx, 6))) throw new FailedPredicateException(this, "precpred(_ctx, 6)");
+            setState(48);
+            match(BWAND);
+            setState(49);
+            expression(7);
+            }
+            break;
+          case 7:
+            {
+            _localctx = new BwxorContext(new ExpressionContext(_parentctx, _parentState));
+            pushNewRecursionContext(_localctx, _startState, RULE_expression);
+            setState(50);
+            if (!(precpred(_ctx, 5))) throw new FailedPredicateException(this, "precpred(_ctx, 5)");
+            setState(51);
+            match(BWXOR);
+            setState(52);
+            expression(6);
+            }
+            break;
+          case 8:
+            {
+            _localctx = new BworContext(new ExpressionContext(_parentctx, _parentState));
+            pushNewRecursionContext(_localctx, _startState, RULE_expression);
+            setState(53);
+            if (!(precpred(_ctx, 4))) throw new FailedPredicateException(this, "precpred(_ctx, 4)");
+            setState(54);
+            match(BWOR);
+            setState(55);
+            expression(5);
+            }
+            break;
+          case 9:
+            {
+            _localctx = new BoolandContext(new ExpressionContext(_parentctx, _parentState));
+            pushNewRecursionContext(_localctx, _startState, RULE_expression);
+            setState(56);
+            if (!(precpred(_ctx, 3))) throw new FailedPredicateException(this, "precpred(_ctx, 3)");
+            setState(57);
+            match(BOOLAND);
+            setState(58);
+            expression(4);
+            }
+            break;
+          case 10:
+            {
+            _localctx = new BoolorContext(new ExpressionContext(_parentctx, _parentState));
+            pushNewRecursionContext(_localctx, _startState, RULE_expression);
+            setState(59);
+            if (!(precpred(_ctx, 2))) throw new FailedPredicateException(this, "precpred(_ctx, 2)");
+            setState(60);
+            match(BOOLOR);
+            setState(61);
+            expression(3);
+            }
+            break;
+          case 11:
+            {
+            _localctx = new ConditionalContext(new ExpressionContext(_parentctx, _parentState));
+            pushNewRecursionContext(_localctx, _startState, RULE_expression);
+            setState(62);
+            if (!(precpred(_ctx, 1))) throw new FailedPredicateException(this, "precpred(_ctx, 1)");
+            setState(63);
+            match(COND);
+            setState(64);
+            expression(0);
+            setState(65);
+            match(COLON);
+            setState(66);
+            expression(1);
+            }
+            break;
+          }
+          } 
+        }
+        setState(72);
+        _errHandler.sync(this);
+        _alt = getInterpreter().adaptivePredict(_input,5,_ctx);
       }
-
       }
-
-      retval.stop = input.LT(-1);
-
-      retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
-      adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
-
     }
     catch (RecognitionException re) {
-      reportError(re);
-      recover(input,re);
-      retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+      _localctx.exception = re;
+      _errHandler.reportError(this, re);
+      _errHandler.recover(this, re);
     }
     finally {
-      // do for sure before leaving
+      unrollRecursionContexts(_parentctx);
     }
-    return retval;
+    return _localctx;
   }
-  // $ANTLR end "logical_and"
 
-
-  public static class bitwise_or_return extends ParserRuleReturnScope {
-    CommonTree tree;
-    @Override
-    public CommonTree getTree() { return tree; }
-  };
-
-
-  // $ANTLR start "bitwise_or"
-  // src/java/org/apache/lucene/expressions/js/Javascript.g:266:1: bitwise_or : bitwise_xor ( AT_BIT_OR ^ bitwise_xor )* ;
-  public final JavascriptParser.bitwise_or_return bitwise_or() throws RecognitionException {
-    JavascriptParser.bitwise_or_return retval = new JavascriptParser.bitwise_or_return();
-    retval.start = input.LT(1);
-
-    CommonTree root_0 = null;
-
-    Token AT_BIT_OR15=null;
-    ParserRuleReturnScope bitwise_xor14 =null;
-    ParserRuleReturnScope bitwise_xor16 =null;
-
-    CommonTree AT_BIT_OR15_tree=null;
-
-    try {
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:267:5: ( bitwise_xor ( AT_BIT_OR ^ bitwise_xor )* )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:267:7: bitwise_xor ( AT_BIT_OR ^ bitwise_xor )*
-      {
-      root_0 = (CommonTree)adaptor.nil();
-
-
-      pushFollow(FOLLOW_bitwise_xor_in_bitwise_or837);
-      bitwise_xor14=bitwise_xor();
-      state._fsp--;
-
-      adaptor.addChild(root_0, bitwise_xor14.getTree());
-
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:267:19: ( AT_BIT_OR ^ bitwise_xor )*
-      loop4:
-      while (true) {
-        int alt4=2;
-        int LA4_0 = input.LA(1);
-        if ( (LA4_0==AT_BIT_OR) ) {
-          alt4=1;
-        }
-
-        switch (alt4) {
-        case 1 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:267:20: AT_BIT_OR ^ bitwise_xor
-          {
-          AT_BIT_OR15=(Token)match(input,AT_BIT_OR,FOLLOW_AT_BIT_OR_in_bitwise_or840); 
-          AT_BIT_OR15_tree = (CommonTree)adaptor.create(AT_BIT_OR15);
-          root_0 = (CommonTree)adaptor.becomeRoot(AT_BIT_OR15_tree, root_0);
-
-          pushFollow(FOLLOW_bitwise_xor_in_bitwise_or843);
-          bitwise_xor16=bitwise_xor();
-          state._fsp--;
-
-          adaptor.addChild(root_0, bitwise_xor16.getTree());
-
-          }
-          break;
-
-        default :
-          break loop4;
-        }
-      }
-
-      }
-
-      retval.stop = input.LT(-1);
-
-      retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
-      adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
-
-    }
-    catch (RecognitionException re) {
-      reportError(re);
-      recover(input,re);
-      retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
-    }
-    finally {
-      // do for sure before leaving
-    }
-    return retval;
-  }
-  // $ANTLR end "bitwise_or"
-
-
-  public static class bitwise_xor_return extends ParserRuleReturnScope {
-    CommonTree tree;
-    @Override
-    public CommonTree getTree() { return tree; }
-  };
-
-
-  // $ANTLR start "bitwise_xor"
-  // src/java/org/apache/lucene/expressions/js/Javascript.g:270:1: bitwise_xor : bitwise_and ( AT_BIT_XOR ^ bitwise_and )* ;
-  public final JavascriptParser.bitwise_xor_return bitwise_xor() throws RecognitionException {
-    JavascriptParser.bitwise_xor_return retval = new JavascriptParser.bitwise_xor_return();
-    retval.start = input.LT(1);
-
-    CommonTree root_0 = null;
-
-    Token AT_BIT_XOR18=null;
-    ParserRuleReturnScope bitwise_and17 =null;
-    ParserRuleReturnScope bitwise_and19 =null;
-
-    CommonTree AT_BIT_XOR18_tree=null;
-
-    try {
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:271:5: ( bitwise_and ( AT_BIT_XOR ^ bitwise_and )* )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:271:7: bitwise_and ( AT_BIT_XOR ^ bitwise_and )*
-      {
-      root_0 = (CommonTree)adaptor.nil();
-
-
-      pushFollow(FOLLOW_bitwise_and_in_bitwise_xor862);
-      bitwise_and17=bitwise_and();
-      state._fsp--;
-
-      adaptor.addChild(root_0, bitwise_and17.getTree());
-
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:271:19: ( AT_BIT_XOR ^ bitwise_and )*
-      loop5:
-      while (true) {
-        int alt5=2;
-        int LA5_0 = input.LA(1);
-        if ( (LA5_0==AT_BIT_XOR) ) {
-          alt5=1;
-        }
-
-        switch (alt5) {
-        case 1 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:271:20: AT_BIT_XOR ^ bitwise_and
-          {
-          AT_BIT_XOR18=(Token)match(input,AT_BIT_XOR,FOLLOW_AT_BIT_XOR_in_bitwise_xor865); 
-          AT_BIT_XOR18_tree = (CommonTree)adaptor.create(AT_BIT_XOR18);
-          root_0 = (CommonTree)adaptor.becomeRoot(AT_BIT_XOR18_tree, root_0);
-
-          pushFollow(FOLLOW_bitwise_and_in_bitwise_xor868);
-          bitwise_and19=bitwise_and();
-          state._fsp--;
-
-          adaptor.addChild(root_0, bitwise_and19.getTree());
-
-          }
-          break;
-
-        default :
-          break loop5;
-        }
-      }
-
-      }
-
-      retval.stop = input.LT(-1);
-
-      retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
-      adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
-
-    }
-    catch (RecognitionException re) {
-      reportError(re);
-      recover(input,re);
-      retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
-    }
-    finally {
-      // do for sure before leaving
-    }
-    return retval;
-  }
-  // $ANTLR end "bitwise_xor"
-
-
-  public static class bitwise_and_return extends ParserRuleReturnScope {
-    CommonTree tree;
-    @Override
-    public CommonTree getTree() { return tree; }
-  };
-
-
-  // $ANTLR start "bitwise_and"
-  // src/java/org/apache/lucene/expressions/js/Javascript.g:274:1: bitwise_and : equality ( AT_BIT_AND ^ equality )* ;
-  public final JavascriptParser.bitwise_and_return bitwise_and() throws RecognitionException {
-    JavascriptParser.bitwise_and_return retval = new JavascriptParser.bitwise_and_return();
-    retval.start = input.LT(1);
-
-    CommonTree root_0 = null;
-
-    Token AT_BIT_AND21=null;
-    ParserRuleReturnScope equality20 =null;
-    ParserRuleReturnScope equality22 =null;
-
-    CommonTree AT_BIT_AND21_tree=null;
-
-    try {
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:275:5: ( equality ( AT_BIT_AND ^ equality )* )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:275:8: equality ( AT_BIT_AND ^ equality )*
-      {
-      root_0 = (CommonTree)adaptor.nil();
-
-
-      pushFollow(FOLLOW_equality_in_bitwise_and888);
-      equality20=equality();
-      state._fsp--;
-
-      adaptor.addChild(root_0, equality20.getTree());
-
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:275:17: ( AT_BIT_AND ^ equality )*
-      loop6:
-      while (true) {
-        int alt6=2;
-        int LA6_0 = input.LA(1);
-        if ( (LA6_0==AT_BIT_AND) ) {
-          alt6=1;
-        }
-
-        switch (alt6) {
-        case 1 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:275:18: AT_BIT_AND ^ equality
-          {
-          AT_BIT_AND21=(Token)match(input,AT_BIT_AND,FOLLOW_AT_BIT_AND_in_bitwise_and891); 
-          AT_BIT_AND21_tree = (CommonTree)adaptor.create(AT_BIT_AND21);
-          root_0 = (CommonTree)adaptor.becomeRoot(AT_BIT_AND21_tree, root_0);
-
-          pushFollow(FOLLOW_equality_in_bitwise_and894);
-          equality22=equality();
-          state._fsp--;
-
-          adaptor.addChild(root_0, equality22.getTree());
-
-          }
-          break;
-
-        default :
-          break loop6;
-        }
-      }
-
-      }
-
-      retval.stop = input.LT(-1);
-
-      retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
-      adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
-
-    }
-    catch (RecognitionException re) {
-      reportError(re);
-      recover(input,re);
-      retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
-    }
-    finally {
-      // do for sure before leaving
-    }
-    return retval;
-  }
-  // $ANTLR end "bitwise_and"
-
-
-  public static class equality_return extends ParserRuleReturnScope {
-    CommonTree tree;
-    @Override
-    public CommonTree getTree() { return tree; }
-  };
-
-
-  // $ANTLR start "equality"
-  // src/java/org/apache/lucene/expressions/js/Javascript.g:278:1: equality : relational ( ( AT_COMP_EQ | AT_COMP_NEQ ) ^ relational )* ;
-  public final JavascriptParser.equality_return equality() throws RecognitionException {
-    JavascriptParser.equality_return retval = new JavascriptParser.equality_return();
-    retval.start = input.LT(1);
-
-    CommonTree root_0 = null;
-
-    Token set24=null;
-    ParserRuleReturnScope relational23 =null;
-    ParserRuleReturnScope relational25 =null;
-
-    CommonTree set24_tree=null;
-
-    try {
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:279:5: ( relational ( ( AT_COMP_EQ | AT_COMP_NEQ ) ^ relational )* )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:279:7: relational ( ( AT_COMP_EQ | AT_COMP_NEQ ) ^ relational )*
-      {
-      root_0 = (CommonTree)adaptor.nil();
-
-
-      pushFollow(FOLLOW_relational_in_equality913);
-      relational23=relational();
-      state._fsp--;
-
-      adaptor.addChild(root_0, relational23.getTree());
-
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:279:18: ( ( AT_COMP_EQ | AT_COMP_NEQ ) ^ relational )*
-      loop7:
-      while (true) {
-        int alt7=2;
-        int LA7_0 = input.LA(1);
-        if ( (LA7_0==AT_COMP_EQ||LA7_0==AT_COMP_NEQ) ) {
-          alt7=1;
-        }
-
-        switch (alt7) {
-        case 1 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:279:19: ( AT_COMP_EQ | AT_COMP_NEQ ) ^ relational
-          {
-          set24=input.LT(1);
-          set24=input.LT(1);
-          if ( input.LA(1)==AT_COMP_EQ||input.LA(1)==AT_COMP_NEQ ) {
-            input.consume();
-            root_0 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(set24), root_0);
-            state.errorRecovery=false;
-          }
-          else {
-            MismatchedSetException mse = new MismatchedSetException(null,input);
-            throw mse;
-          }
-          pushFollow(FOLLOW_relational_in_equality925);
-          relational25=relational();
-          state._fsp--;
-
-          adaptor.addChild(root_0, relational25.getTree());
-
-          }
-          break;
-
-        default :
-          break loop7;
-        }
-      }
-
-      }
-
-      retval.stop = input.LT(-1);
-
-      retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
-      adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
-
-    }
-    catch (RecognitionException re) {
-      reportError(re);
-      recover(input,re);
-      retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
-    }
-    finally {
-      // do for sure before leaving
-    }
-    return retval;
-  }
-  // $ANTLR end "equality"
-
-
-  public static class relational_return extends ParserRuleReturnScope {
-    CommonTree tree;
-    @Override
-    public CommonTree getTree() { return tree; }
-  };
-
-
-  // $ANTLR start "relational"
-  // src/java/org/apache/lucene/expressions/js/Javascript.g:282:1: relational : shift ( ( AT_COMP_LT | AT_COMP_GT | AT_COMP_LTE | AT_COMP_GTE ) ^ shift )* ;
-  public final JavascriptParser.relational_return relational() throws RecognitionException {
-    JavascriptParser.relational_return retval = new JavascriptParser.relational_return();
-    retval.start = input.LT(1);
-
-    CommonTree root_0 = null;
-
-    Token set27=null;
-    ParserRuleReturnScope shift26 =null;
-    ParserRuleReturnScope shift28 =null;
-
-    CommonTree set27_tree=null;
-
-    try {
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:283:5: ( shift ( ( AT_COMP_LT | AT_COMP_GT | AT_COMP_LTE | AT_COMP_GTE ) ^ shift )* )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:283:7: shift ( ( AT_COMP_LT | AT_COMP_GT | AT_COMP_LTE | AT_COMP_GTE ) ^ shift )*
-      {
-      root_0 = (CommonTree)adaptor.nil();
-
-
-      pushFollow(FOLLOW_shift_in_relational944);
-      shift26=shift();
-      state._fsp--;
-
-      adaptor.addChild(root_0, shift26.getTree());
-
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:283:13: ( ( AT_COMP_LT | AT_COMP_GT | AT_COMP_LTE | AT_COMP_GTE ) ^ shift )*
-      loop8:
-      while (true) {
-        int alt8=2;
-        int LA8_0 = input.LA(1);
-        if ( ((LA8_0 >= AT_COMP_GT && LA8_0 <= AT_COMP_LTE)) ) {
-          alt8=1;
-        }
-
-        switch (alt8) {
-        case 1 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:283:14: ( AT_COMP_LT | AT_COMP_GT | AT_COMP_LTE | AT_COMP_GTE ) ^ shift
-          {
-          set27=input.LT(1);
-          set27=input.LT(1);
-          if ( (input.LA(1) >= AT_COMP_GT && input.LA(1) <= AT_COMP_LTE) ) {
-            input.consume();
-            root_0 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(set27), root_0);
-            state.errorRecovery=false;
-          }
-          else {
-            MismatchedSetException mse = new MismatchedSetException(null,input);
-            throw mse;
-          }
-          pushFollow(FOLLOW_shift_in_relational964);
-          shift28=shift();
-          state._fsp--;
-
-          adaptor.addChild(root_0, shift28.getTree());
-
-          }
-          break;
-
-        default :
-          break loop8;
-        }
-      }
-
-      }
-
-      retval.stop = input.LT(-1);
-
-      retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
-      adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
-
-    }
-    catch (RecognitionException re) {
-      reportError(re);
-      recover(input,re);
-      retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
-    }
-    finally {
-      // do for sure before leaving
-    }
-    return retval;
-  }
-  // $ANTLR end "relational"
-
-
-  public static class shift_return extends ParserRuleReturnScope {
-    CommonTree tree;
-    @Override
-    public CommonTree getTree() { return tree; }
-  };
-
-
-  // $ANTLR start "shift"
-  // src/java/org/apache/lucene/expressions/js/Javascript.g:286:1: shift : additive ( ( AT_BIT_SHL | AT_BIT_SHR | AT_BIT_SHU ) ^ additive )* ;
-  public final JavascriptParser.shift_return shift() throws RecognitionException {
-    JavascriptParser.shift_return retval = new JavascriptParser.shift_return();
-    retval.start = input.LT(1);
-
-    CommonTree root_0 = null;
-
-    Token set30=null;
-    ParserRuleReturnScope additive29 =null;
-    ParserRuleReturnScope additive31 =null;
-
-    CommonTree set30_tree=null;
-
-    try {
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:287:5: ( additive ( ( AT_BIT_SHL | AT_BIT_SHR | AT_BIT_SHU ) ^ additive )* )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:287:7: additive ( ( AT_BIT_SHL | AT_BIT_SHR | AT_BIT_SHU ) ^ additive )*
-      {
-      root_0 = (CommonTree)adaptor.nil();
-
-
-      pushFollow(FOLLOW_additive_in_shift983);
-      additive29=additive();
-      state._fsp--;
-
-      adaptor.addChild(root_0, additive29.getTree());
-
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:287:16: ( ( AT_BIT_SHL | AT_BIT_SHR | AT_BIT_SHU ) ^ additive )*
-      loop9:
-      while (true) {
-        int alt9=2;
-        int LA9_0 = input.LA(1);
-        if ( ((LA9_0 >= AT_BIT_SHL && LA9_0 <= AT_BIT_SHU)) ) {
-          alt9=1;
-        }
-
-        switch (alt9) {
-        case 1 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:287:17: ( AT_BIT_SHL | AT_BIT_SHR | AT_BIT_SHU ) ^ additive
-          {
-          set30=input.LT(1);
-          set30=input.LT(1);
-          if ( (input.LA(1) >= AT_BIT_SHL && input.LA(1) <= AT_BIT_SHU) ) {
-            input.consume();
-            root_0 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(set30), root_0);
-            state.errorRecovery=false;
-          }
-          else {
-            MismatchedSetException mse = new MismatchedSetException(null,input);
-            throw mse;
-          }
-          pushFollow(FOLLOW_additive_in_shift999);
-          additive31=additive();
-          state._fsp--;
-
-          adaptor.addChild(root_0, additive31.getTree());
-
-          }
-          break;
-
-        default :
-          break loop9;
-        }
-      }
-
-      }
-
-      retval.stop = input.LT(-1);
-
-      retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
-      adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
-
-    }
-    catch (RecognitionException re) {
-      reportError(re);
-      recover(input,re);
-      retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
-    }
-    finally {
-      // do for sure before leaving
-    }
-    return retval;
-  }
-  // $ANTLR end "shift"
-
-
-  public static class additive_return extends ParserRuleReturnScope {
-    CommonTree tree;
-    @Override
-    public CommonTree getTree() { return tree; }
-  };
-
-
-  // $ANTLR start "additive"
-  // src/java/org/apache/lucene/expressions/js/Javascript.g:290:1: additive : multiplicative ( ( AT_ADD | AT_SUBTRACT ) ^ multiplicative )* ;
-  public final JavascriptParser.additive_return additive() throws RecognitionException {
-    JavascriptParser.additive_return retval = new JavascriptParser.additive_return();
-    retval.start = input.LT(1);
-
-    CommonTree root_0 = null;
-
-    Token set33=null;
-    ParserRuleReturnScope multiplicative32 =null;
-    ParserRuleReturnScope multiplicative34 =null;
-
-    CommonTree set33_tree=null;
-
-    try {
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:291:5: ( multiplicative ( ( AT_ADD | AT_SUBTRACT ) ^ multiplicative )* )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:291:7: multiplicative ( ( AT_ADD | AT_SUBTRACT ) ^ multiplicative )*
-      {
-      root_0 = (CommonTree)adaptor.nil();
-
-
-      pushFollow(FOLLOW_multiplicative_in_additive1018);
-      multiplicative32=multiplicative();
-      state._fsp--;
-
-      adaptor.addChild(root_0, multiplicative32.getTree());
-
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:291:22: ( ( AT_ADD | AT_SUBTRACT ) ^ multiplicative )*
-      loop10:
-      while (true) {
-        int alt10=2;
-        int LA10_0 = input.LA(1);
-        if ( (LA10_0==AT_ADD||LA10_0==AT_SUBTRACT) ) {
-          alt10=1;
-        }
-
-        switch (alt10) {
-        case 1 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:291:23: ( AT_ADD | AT_SUBTRACT ) ^ multiplicative
-          {
-          set33=input.LT(1);
-          set33=input.LT(1);
-          if ( input.LA(1)==AT_ADD||input.LA(1)==AT_SUBTRACT ) {
-            input.consume();
-            root_0 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(set33), root_0);
-            state.errorRecovery=false;
-          }
-          else {
-            MismatchedSetException mse = new MismatchedSetException(null,input);
-            throw mse;
-          }
-          pushFollow(FOLLOW_multiplicative_in_additive1030);
-          multiplicative34=multiplicative();
-          state._fsp--;
-
-          adaptor.addChild(root_0, multiplicative34.getTree());
-
-          }
-          break;
-
-        default :
-          break loop10;
-        }
-      }
-
-      }
-
-      retval.stop = input.LT(-1);
-
-      retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
-      adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
-
-    }
-    catch (RecognitionException re) {
-      reportError(re);
-      recover(input,re);
-      retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
-    }
-    finally {
-      // do for sure before leaving
-    }
-    return retval;
-  }
-  // $ANTLR end "additive"
-
-
-  public static class multiplicative_return extends ParserRuleReturnScope {
-    CommonTree tree;
-    @Override
-    public CommonTree getTree() { return tree; }
-  };
-
-
-  // $ANTLR start "multiplicative"
-  // src/java/org/apache/lucene/expressions/js/Javascript.g:294:1: multiplicative : unary ( ( AT_MULTIPLY | AT_DIVIDE | AT_MODULO ) ^ unary )* ;
-  public final JavascriptParser.multiplicative_return multiplicative() throws RecognitionException {
-    JavascriptParser.multiplicative_return retval = new JavascriptParser.multiplicative_return();
-    retval.start = input.LT(1);
-
-    CommonTree root_0 = null;
-
-    Token set36=null;
-    ParserRuleReturnScope unary35 =null;
-    ParserRuleReturnScope unary37 =null;
-
-    CommonTree set36_tree=null;
-
-    try {
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:295:5: ( unary ( ( AT_MULTIPLY | AT_DIVIDE | AT_MODULO ) ^ unary )* )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:295:7: unary ( ( AT_MULTIPLY | AT_DIVIDE | AT_MODULO ) ^ unary )*
-      {
-      root_0 = (CommonTree)adaptor.nil();
-
-
-      pushFollow(FOLLOW_unary_in_multiplicative1049);
-      unary35=unary();
-      state._fsp--;
-
-      adaptor.addChild(root_0, unary35.getTree());
-
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:295:13: ( ( AT_MULTIPLY | AT_DIVIDE | AT_MODULO ) ^ unary )*
-      loop11:
-      while (true) {
-        int alt11=2;
-        int LA11_0 = input.LA(1);
-        if ( (LA11_0==AT_DIVIDE||(LA11_0 >= AT_MODULO && LA11_0 <= AT_MULTIPLY)) ) {
-          alt11=1;
-        }
-
-        switch (alt11) {
-        case 1 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:295:14: ( AT_MULTIPLY | AT_DIVIDE | AT_MODULO ) ^ unary
-          {
-          set36=input.LT(1);
-          set36=input.LT(1);
-          if ( input.LA(1)==AT_DIVIDE||(input.LA(1) >= AT_MODULO && input.LA(1) <= AT_MULTIPLY) ) {
-            input.consume();
-            root_0 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(set36), root_0);
-            state.errorRecovery=false;
-          }
-          else {
-            MismatchedSetException mse = new MismatchedSetException(null,input);
-            throw mse;
-          }
-          pushFollow(FOLLOW_unary_in_multiplicative1065);
-          unary37=unary();
-          state._fsp--;
-
-          adaptor.addChild(root_0, unary37.getTree());
-
-          }
-          break;
-
-        default :
-          break loop11;
-        }
-      }
-
-      }
-
-      retval.stop = input.LT(-1);
-
-      retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
-      adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
-
-    }
-    catch (RecognitionException re) {
-      reportError(re);
-      recover(input,re);
-      retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
-    }
-    finally {
-      // do for sure before leaving
-    }
-    return retval;
-  }
-  // $ANTLR end "multiplicative"
-
-
-  public static class unary_return extends ParserRuleReturnScope {
-    CommonTree tree;
-    @Override
-    public CommonTree getTree() { return tree; }
-  };
-
-
-  // $ANTLR start "unary"
-  // src/java/org/apache/lucene/expressions/js/Javascript.g:298:1: unary : ( postfix | AT_ADD ! unary | unary_operator ^ unary );
-  public final JavascriptParser.unary_return unary() throws RecognitionException {
-    JavascriptParser.unary_return retval = new JavascriptParser.unary_return();
-    retval.start = input.LT(1);
-
-    CommonTree root_0 = null;
-
-    Token AT_ADD39=null;
-    ParserRuleReturnScope postfix38 =null;
-    ParserRuleReturnScope unary40 =null;
-    ParserRuleReturnScope unary_operator41 =null;
-    ParserRuleReturnScope unary42 =null;
-
-    CommonTree AT_ADD39_tree=null;
-
-    try {
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:299:5: ( postfix | AT_ADD ! unary | unary_operator ^ unary )
-      int alt12=3;
-      switch ( input.LA(1) ) {
-      case AT_LPAREN:
-      case DECIMAL:
-      case HEX:
-      case OCTAL:
-      case VARIABLE:
-        {
-        alt12=1;
-        }
-        break;
-      case AT_ADD:
-        {
-        alt12=2;
-        }
-        break;
-      case AT_BIT_NOT:
-      case AT_BOOL_NOT:
-      case AT_SUBTRACT:
-        {
-        alt12=3;
-        }
-        break;
-      default:
-        NoViableAltException nvae =
-          new NoViableAltException("", 12, 0, input);
-        throw nvae;
-      }
-      switch (alt12) {
-        case 1 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:299:7: postfix
-          {
-          root_0 = (CommonTree)adaptor.nil();
-
-
-          pushFollow(FOLLOW_postfix_in_unary1084);
-          postfix38=postfix();
-          state._fsp--;
-
-          adaptor.addChild(root_0, postfix38.getTree());
-
-          }
-          break;
-        case 2 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:300:7: AT_ADD ! unary
-          {
-          root_0 = (CommonTree)adaptor.nil();
-
-
-          AT_ADD39=(Token)match(input,AT_ADD,FOLLOW_AT_ADD_in_unary1092); 
-          pushFollow(FOLLOW_unary_in_unary1095);
-          unary40=unary();
-          state._fsp--;
-
-          adaptor.addChild(root_0, unary40.getTree());
-
-          }
-          break;
-        case 3 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:301:7: unary_operator ^ unary
-          {
-          root_0 = (CommonTree)adaptor.nil();
-
-
-          pushFollow(FOLLOW_unary_operator_in_unary1103);
-          unary_operator41=unary_operator();
-          state._fsp--;
-
-          root_0 = (CommonTree)adaptor.becomeRoot(unary_operator41.getTree(), root_0);
-          pushFollow(FOLLOW_unary_in_unary1106);
-          unary42=unary();
-          state._fsp--;
-
-          adaptor.addChild(root_0, unary42.getTree());
-
-          }
-          break;
-
-      }
-      retval.stop = input.LT(-1);
-
-      retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
-      adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
-
-    }
-    catch (RecognitionException re) {
-      reportError(re);
-      recover(input,re);
-      retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
-    }
-    finally {
-      // do for sure before leaving
-    }
-    return retval;
-  }
-  // $ANTLR end "unary"
-
-
-  public static class unary_operator_return extends ParserRuleReturnScope {
-    CommonTree tree;
-    @Override
-    public CommonTree getTree() { return tree; }
-  };
-
-
-  // $ANTLR start "unary_operator"
-  // src/java/org/apache/lucene/expressions/js/Javascript.g:304:1: unary_operator : ( AT_SUBTRACT -> AT_NEGATE | AT_BIT_NOT | AT_BOOL_NOT );
-  public final JavascriptParser.unary_operator_return unary_operator() throws RecognitionException {
-    JavascriptParser.unary_operator_return retval = new JavascriptParser.unary_operator_return();
-    retval.start = input.LT(1);
-
-    CommonTree root_0 = null;
-
-    Token AT_SUBTRACT43=null;
-    Token AT_BIT_NOT44=null;
-    Token AT_BOOL_NOT45=null;
-
-    CommonTree AT_SUBTRACT43_tree=null;
-    CommonTree AT_BIT_NOT44_tree=null;
-    CommonTree AT_BOOL_NOT45_tree=null;
-    RewriteRuleTokenStream stream_AT_SUBTRACT=new RewriteRuleTokenStream(adaptor,"token AT_SUBTRACT");
-
-    try {
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:305:5: ( AT_SUBTRACT -> AT_NEGATE | AT_BIT_NOT | AT_BOOL_NOT )
-      int alt13=3;
-      switch ( input.LA(1) ) {
-      case AT_SUBTRACT:
-        {
-        alt13=1;
-        }
-        break;
-      case AT_BIT_NOT:
-        {
-        alt13=2;
-        }
-        break;
-      case AT_BOOL_NOT:
-        {
-        alt13=3;
-        }
-        break;
-      default:
-        NoViableAltException nvae =
-          new NoViableAltException("", 13, 0, input);
-        throw nvae;
-      }
-      switch (alt13) {
-        case 1 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:305:7: AT_SUBTRACT
-          {
-          AT_SUBTRACT43=(Token)match(input,AT_SUBTRACT,FOLLOW_AT_SUBTRACT_in_unary_operator1123);  
-          stream_AT_SUBTRACT.add(AT_SUBTRACT43);
-
-          // AST REWRITE
-          // elements: 
-          // token labels: 
-          // rule labels: retval
-          // token list labels: 
-          // rule list labels: 
-          // wildcard labels: 
-          retval.tree = root_0;
-          RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
-
-          root_0 = (CommonTree)adaptor.nil();
-          // 305:19: -> AT_NEGATE
-          {
-            adaptor.addChild(root_0, (CommonTree)adaptor.create(AT_NEGATE, "AT_NEGATE"));
-          }
-
-
-          retval.tree = root_0;
-
-          }
-          break;
-        case 2 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:306:7: AT_BIT_NOT
-          {
-          root_0 = (CommonTree)adaptor.nil();
-
-
-          AT_BIT_NOT44=(Token)match(input,AT_BIT_NOT,FOLLOW_AT_BIT_NOT_in_unary_operator1135); 
-          AT_BIT_NOT44_tree = (CommonTree)adaptor.create(AT_BIT_NOT44);
-          adaptor.addChild(root_0, AT_BIT_NOT44_tree);
-
-          }
-          break;
-        case 3 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:307:7: AT_BOOL_NOT
-          {
-          root_0 = (CommonTree)adaptor.nil();
-
-
-          AT_BOOL_NOT45=(Token)match(input,AT_BOOL_NOT,FOLLOW_AT_BOOL_NOT_in_unary_operator1143); 
-          AT_BOOL_NOT45_tree = (CommonTree)adaptor.create(AT_BOOL_NOT45);
-          adaptor.addChild(root_0, AT_BOOL_NOT45_tree);
-
-          }
-          break;
-
-      }
-      retval.stop = input.LT(-1);
-
-      retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
-      adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
-
-    }
-    catch (RecognitionException re) {
-      reportError(re);
-      recover(input,re);
-      retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
-    }
-    finally {
-      // do for sure before leaving
-    }
-    return retval;
-  }
-  // $ANTLR end "unary_operator"
-
-
-  public static class postfix_return extends ParserRuleReturnScope {
-    CommonTree tree;
-    @Override
-    public CommonTree getTree() { return tree; }
-  };
-
-
-  // $ANTLR start "postfix"
-  // src/java/org/apache/lucene/expressions/js/Javascript.g:310:1: postfix : ( primary | VARIABLE arguments -> ^( AT_CALL VARIABLE ( arguments )? ) );
-  public final JavascriptParser.postfix_return postfix() throws RecognitionException {
-    JavascriptParser.postfix_return retval = new JavascriptParser.postfix_return();
-    retval.start = input.LT(1);
-
-    CommonTree root_0 = null;
-
-    Token VARIABLE47=null;
-    ParserRuleReturnScope primary46 =null;
-    ParserRuleReturnScope arguments48 =null;
-
-    CommonTree VARIABLE47_tree=null;
-    RewriteRuleTokenStream stream_VARIABLE=new RewriteRuleTokenStream(adaptor,"token VARIABLE");
-    RewriteRuleSubtreeStream stream_arguments=new RewriteRuleSubtreeStream(adaptor,"rule arguments");
-
-    try {
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:311:5: ( primary | VARIABLE arguments -> ^( AT_CALL VARIABLE ( arguments )? ) )
-      int alt14=2;
-      int LA14_0 = input.LA(1);
-      if ( (LA14_0==VARIABLE) ) {
-        int LA14_1 = input.LA(2);
-        if ( (LA14_1==EOF||(LA14_1 >= AT_ADD && LA14_1 <= AT_BIT_AND)||(LA14_1 >= AT_BIT_OR && LA14_1 <= AT_BOOL_AND)||LA14_1==AT_BOOL_OR||(LA14_1 >= AT_COLON && LA14_1 <= AT_DIVIDE)||(LA14_1 >= AT_MODULO && LA14_1 <= AT_MULTIPLY)||(LA14_1 >= AT_RPAREN && LA14_1 <= AT_SUBTRACT)) ) {
-          alt14=1;
-        }
-        else if ( (LA14_1==AT_LPAREN) ) {
-          alt14=2;
-        }
-
-        else {
-          int nvaeMark = input.mark();
-          try {
-            input.consume();
-            NoViableAltException nvae =
-              new NoViableAltException("", 14, 1, input);
-            throw nvae;
-          } finally {
-            input.rewind(nvaeMark);
-          }
-        }
-
-      }
-      else if ( (LA14_0==AT_LPAREN||LA14_0==DECIMAL||LA14_0==HEX||LA14_0==OCTAL) ) {
-        alt14=1;
-      }
-
-      else {
-        NoViableAltException nvae =
-          new NoViableAltException("", 14, 0, input);
-        throw nvae;
-      }
-
-      switch (alt14) {
-        case 1 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:311:7: primary
-          {
-          root_0 = (CommonTree)adaptor.nil();
-
-
-          pushFollow(FOLLOW_primary_in_postfix1160);
-          primary46=primary();
-          state._fsp--;
-
-          adaptor.addChild(root_0, primary46.getTree());
-
-          }
-          break;
-        case 2 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:312:7: VARIABLE arguments
-          {
-          VARIABLE47=(Token)match(input,VARIABLE,FOLLOW_VARIABLE_in_postfix1168);  
-          stream_VARIABLE.add(VARIABLE47);
-
-          pushFollow(FOLLOW_arguments_in_postfix1170);
-          arguments48=arguments();
-          state._fsp--;
-
-          stream_arguments.add(arguments48.getTree());
-          // AST REWRITE
-          // elements: VARIABLE, arguments
-          // token labels: 
-          // rule labels: retval
-          // token list labels: 
-          // rule list labels: 
-          // wildcard labels: 
-          retval.tree = root_0;
-          RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
-
-          root_0 = (CommonTree)adaptor.nil();
-          // 312:26: -> ^( AT_CALL VARIABLE ( arguments )? )
-          {
-            // src/java/org/apache/lucene/expressions/js/Javascript.g:312:29: ^( AT_CALL VARIABLE ( arguments )? )
-            {
-            CommonTree root_1 = (CommonTree)adaptor.nil();
-            root_1 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(AT_CALL, "AT_CALL"), root_1);
-            adaptor.addChild(root_1, stream_VARIABLE.nextNode());
-            // src/java/org/apache/lucene/expressions/js/Javascript.g:312:48: ( arguments )?
-            if ( stream_arguments.hasNext() ) {
-              adaptor.addChild(root_1, stream_arguments.nextTree());
-            }
-            stream_arguments.reset();
-
-            adaptor.addChild(root_0, root_1);
-            }
-
-          }
-
-
-          retval.tree = root_0;
-
-          }
-          break;
-
-      }
-      retval.stop = input.LT(-1);
-
-      retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
-      adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
-
-    }
-    catch (RecognitionException re) {
-      reportError(re);
-      recover(input,re);
-      retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
-    }
-    finally {
-      // do for sure before leaving
-    }
-    return retval;
-  }
-  // $ANTLR end "postfix"
-
-
-  public static class primary_return extends ParserRuleReturnScope {
-    CommonTree tree;
-    @Override
-    public CommonTree getTree() { return tree; }
-  };
-
-
-  // $ANTLR start "primary"
-  // src/java/org/apache/lucene/expressions/js/Javascript.g:315:1: primary : ( VARIABLE | numeric | AT_LPAREN ! conditional AT_RPAREN !);
-  public final JavascriptParser.primary_return primary() throws RecognitionException {
-    JavascriptParser.primary_return retval = new JavascriptParser.primary_return();
-    retval.start = input.LT(1);
-
-    CommonTree root_0 = null;
-
-    Token VARIABLE49=null;
-    Token AT_LPAREN51=null;
-    Token AT_RPAREN53=null;
-    ParserRuleReturnScope numeric50 =null;
-    ParserRuleReturnScope conditional52 =null;
-
-    CommonTree VARIABLE49_tree=null;
-    CommonTree AT_LPAREN51_tree=null;
-    CommonTree AT_RPAREN53_tree=null;
-
-    try {
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:316:5: ( VARIABLE | numeric | AT_LPAREN ! conditional AT_RPAREN !)
-      int alt15=3;
-      switch ( input.LA(1) ) {
-      case VARIABLE:
-        {
-        alt15=1;
-        }
-        break;
-      case DECIMAL:
-      case HEX:
-      case OCTAL:
-        {
-        alt15=2;
-        }
-        break;
-      case AT_LPAREN:
-        {
-        alt15=3;
-        }
-        break;
-      default:
-        NoViableAltException nvae =
-          new NoViableAltException("", 15, 0, input);
-        throw nvae;
-      }
-      switch (alt15) {
-        case 1 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:316:7: VARIABLE
-          {
-          root_0 = (CommonTree)adaptor.nil();
-
-
-          VARIABLE49=(Token)match(input,VARIABLE,FOLLOW_VARIABLE_in_primary1198); 
-          VARIABLE49_tree = (CommonTree)adaptor.create(VARIABLE49);
-          adaptor.addChild(root_0, VARIABLE49_tree);
-
-          }
-          break;
-        case 2 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:317:7: numeric
-          {
-          root_0 = (CommonTree)adaptor.nil();
-
-
-          pushFollow(FOLLOW_numeric_in_primary1206);
-          numeric50=numeric();
-          state._fsp--;
-
-          adaptor.addChild(root_0, numeric50.getTree());
-
-          }
-          break;
-        case 3 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:318:7: AT_LPAREN ! conditional AT_RPAREN !
-          {
-          root_0 = (CommonTree)adaptor.nil();
-
-
-          AT_LPAREN51=(Token)match(input,AT_LPAREN,FOLLOW_AT_LPAREN_in_primary1214); 
-          pushFollow(FOLLOW_conditional_in_primary1217);
-          conditional52=conditional();
-          state._fsp--;
-
-          adaptor.addChild(root_0, conditional52.getTree());
-
-          AT_RPAREN53=(Token)match(input,AT_RPAREN,FOLLOW_AT_RPAREN_in_primary1219); 
-          }
-          break;
-
-      }
-      retval.stop = input.LT(-1);
-
-      retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
-      adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
-
-    }
-    catch (RecognitionException re) {
-      reportError(re);
-      recover(input,re);
-      retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
-    }
-    finally {
-      // do for sure before leaving
+  public boolean sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
+    switch (ruleIndex) {
+    case 1:
+      return expression_sempred((ExpressionContext)_localctx, predIndex);
     }
-    return retval;
+    return true;
   }
-  // $ANTLR end "primary"
-
-
-  public static class arguments_return extends ParserRuleReturnScope {
-    CommonTree tree;
-    @Override
-    public CommonTree getTree() { return tree; }
-  };
-
-
-  // $ANTLR start "arguments"
-  // src/java/org/apache/lucene/expressions/js/Javascript.g:321:1: arguments : AT_LPAREN ! ( conditional ( AT_COMMA ! conditional )* )? AT_RPAREN !;
-  public final JavascriptParser.arguments_return arguments() throws RecognitionException {
-    JavascriptParser.arguments_return retval = new JavascriptParser.arguments_return();
-    retval.start = input.LT(1);
-
-    CommonTree root_0 = null;
-
-    Token AT_LPAREN54=null;
-    Token AT_COMMA56=null;
-    Token AT_RPAREN58=null;
-    ParserRuleReturnScope conditional55 =null;
-    ParserRuleReturnScope conditional57 =null;
-
-    CommonTree AT_LPAREN54_tree=null;
-    CommonTree AT_COMMA56_tree=null;
-    CommonTree AT_RPAREN58_tree=null;
-
-    try {
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:322:5: ( AT_LPAREN ! ( conditional ( AT_COMMA ! conditional )* )? AT_RPAREN !)
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:322:7: AT_LPAREN ! ( conditional ( AT_COMMA ! conditional )* )? AT_RPAREN !
-      {
-      root_0 = (CommonTree)adaptor.nil();
-
-
-      AT_LPAREN54=(Token)match(input,AT_LPAREN,FOLLOW_AT_LPAREN_in_arguments1237); 
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:322:18: ( conditional ( AT_COMMA ! conditional )* )?
-      int alt17=2;
-      int LA17_0 = input.LA(1);
-      if ( (LA17_0==AT_ADD||LA17_0==AT_BIT_NOT||LA17_0==AT_BOOL_NOT||LA17_0==AT_LPAREN||(LA17_0 >= AT_SUBTRACT && LA17_0 <= DECIMAL)||LA17_0==HEX||LA17_0==OCTAL||LA17_0==VARIABLE) ) {
-        alt17=1;
-      }
-      switch (alt17) {
-        case 1 :
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:322:19: conditional ( AT_COMMA ! conditional )*
-          {
-          pushFollow(FOLLOW_conditional_in_arguments1241);
-          conditional55=conditional();
-          state._fsp--;
-
-          adaptor.addChild(root_0, conditional55.getTree());
-
-          // src/java/org/apache/lucene/expressions/js/Javascript.g:322:31: ( AT_COMMA ! conditional )*
-          loop16:
-          while (true) {
-            int alt16=2;
-            int LA16_0 = input.LA(1);
-            if ( (LA16_0==AT_COMMA) ) {
-              alt16=1;
-            }
-
-            switch (alt16) {
-            case 1 :
-              // src/java/org/apache/lucene/expressions/js/Javascript.g:322:32: AT_COMMA ! conditional
-              {
-              AT_COMMA56=(Token)match(input,AT_COMMA,FOLLOW_AT_COMMA_in_arguments1244); 
-              pushFollow(FOLLOW_conditional_in_arguments1247);
-              conditional57=conditional();
-              state._fsp--;
-
-              adaptor.addChild(root_0, conditional57.getTree());
-
-              }
-              break;
-
-            default :
-              break loop16;
-            }
-          }
-
-          }
-          break;
-
-      }
-
-      AT_RPAREN58=(Token)match(input,AT_RPAREN,FOLLOW_AT_RPAREN_in_arguments1253); 
-      }
-
-      retval.stop = input.LT(-1);
-
-      retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
-      adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
-
-    }
-    catch (RecognitionException re) {
-      reportError(re);
-      recover(input,re);
-      retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
-    }
-    finally {
-      // do for sure before leaving
-    }
-    return retval;
+  private boolean expression_sempred(ExpressionContext _localctx, int predIndex) {
+    switch (predIndex) {
+    case 0:
+      return precpred(_ctx, 11);
+    case 1:
+      return precpred(_ctx, 10);
+    case 2:
+      return precpred(_ctx, 9);
+    case 3:
+      return precpred(_ctx, 8);
+    case 4:
+      return precpred(_ctx, 7);
+    case 5:
+      return precpred(_ctx, 6);
+    case 6:
+      return precpred(_ctx, 5);
+    case 7:
+      return precpred(_ctx, 4);
+    case 8:
+      return precpred(_ctx, 3);
+    case 9:
+      return precpred(_ctx, 2);
+    case 10:
+      return precpred(_ctx, 1);
+    }
+    return true;
   }
-  // $ANTLR end "arguments"
-
-
-  public static class numeric_return extends ParserRuleReturnScope {
-    CommonTree tree;
-    @Override
-    public CommonTree getTree() { return tree; }
-  };
-
-
-  // $ANTLR start "numeric"
-  // src/java/org/apache/lucene/expressions/js/Javascript.g:325:1: numeric : ( HEX | OCTAL | DECIMAL );
-  public final JavascriptParser.numeric_return numeric() throws RecognitionException {
-    JavascriptParser.numeric_return retval = new JavascriptParser.numeric_return();
-    retval.start = input.LT(1);
-
-    CommonTree root_0 = null;
-
-    Token set59=null;
-
-    CommonTree set59_tree=null;
-
-    try {
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:326:5: ( HEX | OCTAL | DECIMAL )
-      // src/java/org/apache/lucene/expressions/js/Javascript.g:
-      {
-      root_0 = (CommonTree)adaptor.nil();
-
-
-      set59=input.LT(1);
-      if ( input.LA(1)==DECIMAL||input.LA(1)==HEX||input.LA(1)==OCTAL ) {
-        input.consume();
-        adaptor.addChild(root_0, (CommonTree)adaptor.create(set59));
-        state.errorRecovery=false;
-      }
-      else {
-        MismatchedSetException mse = new MismatchedSetException(null,input);
-        throw mse;
-      }
-      }
-
-      retval.stop = input.LT(-1);
-
-      retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
-      adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
 
+  public static final String _serializedATN =
+    "\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd\3!L\4\2\t\2\4\3\t\3"+
+    "\3\2\3\2\3\2\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\7\3\27"+
+    "\n\3\f\3\16\3\32\13\3\5\3\34\n\3\3\3\5\3\37\n\3\5\3!\n\3\3\3\3\3\3\3\3"+
+    "\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3"+
+    "\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\7\3G\n\3"+
+    "\f\3\16\3J\13\3\3\3\2\3\4\4\2\4\2\t\4\2\6\7\13\f\3\2\37!\3\2\b\n\3\2\13"+
+    "\f\3\2\r\17\3\2\20\23\3\2\24\25Z\2\6\3\2\2\2\4 \3\2\2\2\6\7\5\4\3\2\7"+
+    "\b\7\2\2\3\b\3\3\2\2\2\t\n\b\3\1\2\n\13\t\2\2\2\13!\5\4\3\16\f\r\7\3\2"+
+    "\2\r\16\5\4\3\2\16\17\7\4\2\2\17!\3\2\2\2\20!\t\3\2\2\21\36\7\36\2\2\22"+
+    "\33\7\3\2\2\23\30\5\4\3\2\24\25\7\5\2\2\25\27\5\4\3\2\26\24\3\2\2\2\27"+
+    "\32\3\2\2\2\30\26\3\2\2\2\30\31\3\2\2\2\31\34\3\2\2\2\32\30\3\2\2\2\33"+
+    "\23\3\2\2\2\33\34\3\2\2\2\34\35\3\2\2\2\35\37\7\4\2\2\36\22\3\2\2\2\36"+
+    "\37\3\2\2\2\37!\3\2\2\2 \t\3\2\2\2 \f\3\2\2\2 \20\3\2\2\2 \21\3\2\2\2"+
+    "!H\3\2\2\2\"#\f\r\2\2#$\t\4\2\2$G\5\4\3\16%&\f\f\2\2&\'\t\5\2\2\'G\5\4"+
+    "\3\r()\f\13\2\2)*\t\6\2\2*G\5\4\3\f+,\f\n\2\2,-\t\7\2\2-G\5\4\3\13./\f"+
+    "\t\2\2/\60\t\b\2\2\60G\5\4\3\n\61\62\f\b\2\2\62\63\7\26\2\2\63G\5\4\3"+
+    "\t\64\65\f\7\2\2\65\66\7\27\2\2\66G\5\4\3\b\678\f\6\2\289\7\30\2\29G\5"+
+    "\4\3\7:;\f\5\2\2;<\7\31\2\2<G\5\4\3\6=>\f\4\2\2>?\7\32\2\2?G\5\4\3\5@"+
+    "A\f\3\2\2AB\7\33\2\2BC\5\4\3\2CD\7\34\2\2DE\5\4\3\3EG\3\2\2\2F\"\3\2\2"+
+    "\2F%\3\2\2\2F(\3\2\2\2F+\3\2\2\2F.\3\2\2\2F\61\3\2\2\2F\64\3\2\2\2F\67"+
+    "\3\2\2\2F:\3\2\2\2F=\3\2\2\2F@\3\2\2\2GJ\3\2\2\2HF\3\2\2\2HI\3\2\2\2I"+
+    "\5\3\2\2\2JH\3\2\2\2\b\30\33\36 FH";
+  public static final ATN _ATN =
+    new ATNDeserializer().deserialize(_serializedATN.toCharArray());
+  static {
+    _decisionToDFA = new DFA[_ATN.getNumberOfDecisions()];
+    for (int i = 0; i < _ATN.getNumberOfDecisions(); i++) {
+      _decisionToDFA[i] = new DFA(_ATN.getDecisionState(i), i);
     }
-    catch (RecognitionException re) {
-      reportError(re);
-      recover(input,re);
-      retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
-    }
-    finally {
-      // do for sure before leaving
-    }
-    return retval;
   }
-  // $ANTLR end "numeric"
-
-  // Delegated rules
-
-
-
-  public static final BitSet FOLLOW_conditional_in_expression737 = new BitSet(new long[]{0x0000000000000000L});
-  public static final BitSet FOLLOW_EOF_in_expression739 = new BitSet(new long[]{0x0000000000000002L});
-  public static final BitSet FOLLOW_logical_or_in_conditional757 = new BitSet(new long[]{0x0000000002000002L});
-  public static final BitSet FOLLOW_AT_COND_QUE_in_conditional760 = new BitSet(new long[]{0x00008886100040A0L});
-  public static final BitSet FOLLOW_conditional_in_conditional763 = new BitSet(new long[]{0x0000000000020000L});
-  public static final BitSet FOLLOW_AT_COLON_in_conditional765 = new BitSet(new long[]{0x00008886100040A0L});
-  public static final BitSet FOLLOW_conditional_in_conditional768 = new BitSet(new long[]{0x0000000000000002L});
-  public static final BitSet FOLLOW_logical_and_in_logical_or787 = new BitSet(new long[]{0x0000000000008002L});
-  public static final BitSet FOLLOW_AT_BOOL_OR_in_logical_or790 = new BitSet(new long[]{0x00008886100040A0L});
-  public static final BitSet FOLLOW_logical_and_in_logical_or793 = new BitSet(new long[]{0x0000000000008002L});
-  public static final BitSet FOLLOW_bitwise_or_in_logical_and812 = new BitSet(new long[]{0x0000000000002002L});
-  public static final BitSet FOLLOW_AT_BOOL_AND_in_logical_and815 = new BitSet(new long[]{0x00008886100040A0L});
-  public static final BitSet FOLLOW_bitwise_or_in_logical_and818 = new BitSet(new long[]{0x0000000000002002L});
-  public static final BitSet FOLLOW_bitwise_xor_in_bitwise_or837 = new BitSet(new long[]{0x0000000000000102L});
-  public static final BitSet FOLLOW_AT_BIT_OR_in_bitwise_or840 = new BitSet(new long[]{0x00008886100040A0L});
-  public static final BitSet FOLLOW_bitwise_xor_in_bitwise_or843 = new BitSet(new long[]{0x0000000000000102L});
-  public static final BitSet FOLLOW_bitwise_and_in_bitwise_xor862 = new BitSet(new long[]{0x0000000000001002L});
-  public static final BitSet FOLLOW_AT_BIT_XOR_in_bitwise_xor865 = new BitSet(new long[]{0x00008886100040A0L});
-  public static final BitSet FOLLOW_bitwise_and_in_bitwise_xor868 = new BitSet(new long[]{0x0000000000001002L});
-  public static final BitSet FOLLOW_equality_in_bitwise_and888 = new BitSet(new long[]{0x0000000000000042L});
-  public static final BitSet FOLLOW_AT_BIT_AND_in_bitwise_and891 = new BitSet(new long[]{0x00008886100040A0L});
-  public static final BitSet FOLLOW_equality_in_bitwise_and894 = new BitSet(new long[]{0x0000000000000042L});
-  public static final BitSet FOLLOW_relational_in_equality913 = new BitSet(new long[]{0x0000000001080002L});
-  public static final BitSet FOLLOW_set_in_equality916 = new BitSet(new long[]{0x00008886100040A0L});
-  public static final BitSet FOLLOW_relational_in_equality925 = new BitSet(new long[]{0x0000000001080002L});
-  public static final BitSet FOLLOW_shift_in_relational944 = new BitSet(new long[]{0x0000000000F00002L});
-  public static final BitSet FOLLOW_set_in_relational947 = new BitSet(new long[]{0x00008886100040A0L});
-  public static final BitSet FOLLOW_shift_in_relational964 = new BitSet(new long[]{0x0000000000F00002L});
-  public static final BitSet FOLLOW_additive_in_shift983 = new BitSet(new long[]{0x0000000000000E02L});
-  public static final BitSet FOLLOW_set_in_shift986 = new BitSet(new long[]{0x00008886100040A0L});
-  public static final BitSet FOLLOW_additive_in_shift999 = new BitSet(new long[]{0x0000000000000E02L});
-  public static final BitSet FOLLOW_multiplicative_in_additive1018 = new BitSet(new long[]{0x0000000200000022L});
-  public static final BitSet FOLLOW_set_in_additive1021 = new BitSet(new long[]{0x00008886100040A0L});
-  public static final BitSet FOLLOW_multiplicative_in_additive1030 = new BitSet(new long[]{0x0000000200000022L});
-  public static final BitSet FOLLOW_unary_in_multiplicative1049 = new BitSet(new long[]{0x0000000064000002L});
-  public static final BitSet FOLLOW_set_in_multiplicative1052 = new BitSet(new long[]{0x00008886100040A0L});
-  public static final BitSet FOLLOW_unary_in_multiplicative1065 = new BitSet(new long[]{0x0000000064000002L});
-  public static final BitSet FOLLOW_postfix_in_unary1084 = new BitSet(new long[]{0x0000000000000002L});
-  public static final BitSet FOLLOW_AT_ADD_in_unary1092 = new BitSet(new long[]{0x00008886100040A0L});
-  public static final BitSet FOLLOW_unary_in_unary1095 = new BitSet(new long[]{0x0000000000000002L});
-  public static final BitSet FOLLOW_unary_operator_in_unary1103 = new BitSet(new long[]{0x00008886100040A0L});
-  public static final BitSet FOLLOW_unary_in_unary1106 = new BitSet(new long[]{0x0000000000000002L});
-  public static final BitSet FOLLOW_AT_SUBTRACT_in_unary_operator1123 = new BitSet(new long[]{0x0000000000000002L});
-  public static final BitSet FOLLOW_AT_BIT_NOT_in_unary_operator1135 = new BitSet(new long[]{0x0000000000000002L});
-  public static final BitSet FOLLOW_AT_BOOL_NOT_in_unary_operator1143 = new BitSet(new long[]{0x0000000000000002L});
-  public static final BitSet FOLLOW_primary_in_postfix1160 = new BitSet(new long[]{0x0000000000000002L});
-  public static final BitSet FOLLOW_VARIABLE_in_postfix1168 = new BitSet(new long[]{0x0000000010000000L});
-  public static final BitSet FOLLOW_arguments_in_postfix1170 = new BitSet(new long[]{0x0000000000000002L});
-  public static final BitSet FOLLOW_VARIABLE_in_primary1198 = new BitSet(new long[]{0x0000000000000002L});
-  public static final BitSet FOLLOW_numeric_in_primary1206 = new BitSet(new long[]{0x0000000000000002L});
-  public static final BitSet FOLLOW_AT_LPAREN_in_primary1214 = new BitSet(new long[]{0x00008886100040A0L});
-  public static final BitSet FOLLOW_conditional_in_primary1217 = new BitSet(new long[]{0x0000000100000000L});
-  public static final BitSet FOLLOW_AT_RPAREN_in_primary1219 = new BitSet(new long[]{0x0000000000000002L});
-  public static final BitSet FOLLOW_AT_LPAREN_in_arguments1237 = new BitSet(new long[]{0x00008887100040A0L});
-  public static final BitSet FOLLOW_conditional_in_arguments1241 = new BitSet(new long[]{0x0000000100040000L});
-  public static final BitSet FOLLOW_AT_COMMA_in_arguments1244 = new BitSet(new long[]{0x00008886100040A0L});
-  public static final BitSet FOLLOW_conditional_in_arguments1247 = new BitSet(new long[]{0x0000000100040000L});
-  public static final BitSet FOLLOW_AT_RPAREN_in_arguments1253 = new BitSet(new long[]{0x0000000000000002L});
 }
diff --git a/lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptParserErrorStrategy.java b/lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptParserErrorStrategy.java
new file mode 100644
index 0000000..2b1392d
--- /dev/null
+++ b/lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptParserErrorStrategy.java
@@ -0,0 +1,92 @@
+package org.apache.lucene.expressions.js;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.text.ParseException;
+
+import org.antlr.v4.runtime.DefaultErrorStrategy;
+import org.antlr.v4.runtime.InputMismatchException;
+import org.antlr.v4.runtime.NoViableAltException;
+import org.antlr.v4.runtime.Parser;
+import org.antlr.v4.runtime.RecognitionException;
+import org.antlr.v4.runtime.Token;
+
+/**
+ * Allows for proper error handling in the ANTLR 4 parser
+ */
+class JavascriptParserErrorStrategy extends DefaultErrorStrategy {
+  /**
+   * Ensures the ANTLR parser will throw an exception after the first error
+   *
+   * @param recognizer the parser being used
+   * @param re the original exception from the parser
+   */
+  @Override
+  public void recover(Parser recognizer, RecognitionException re) {
+    Token token = re.getOffendingToken();
+    String message;
+
+    if (token == null) {
+      message = "error " + getTokenErrorDisplay(token);
+    } else if (re instanceof InputMismatchException) {
+       message = "unexpected token " + getTokenErrorDisplay(token) +
+           " on line (" + token.getLine() + ") position (" + token.getCharPositionInLine() + ")" +
+           " was expecting one of " + re.getExpectedTokens().toString(recognizer.getVocabulary());
+    } else if (re instanceof NoViableAltException) {
+      if (token.getType() == JavascriptParser.EOF) {
+        message = "unexpected end of expression";
+      } else {
+        message = "invalid sequence of tokens near " + getTokenErrorDisplay(token) +
+            " on line (" + token.getLine() + ") position (" + token.getCharPositionInLine() + ")";
+      }
+    } else {
+      message = " unexpected token near " + getTokenErrorDisplay(token) +
+          " on line (" + token.getLine() + ") position (" + token.getCharPositionInLine() + ")";
+    }
+
+    ParseException parseException = new ParseException(message, token.getStartIndex());
+    parseException.initCause(re);
+    throw new RuntimeException(parseException);
+  }
+
+  /**
+   * Ensures the ANTLR parser will throw an exception after the first error
+   *
+   * @param recognizer the parser being used
+   * @return no actual return value
+   * @throws RecognitionException not used as a ParseException wrapped in a RuntimeException is thrown instead
+   */
+  @Override
+  public Token recoverInline(Parser recognizer) throws RecognitionException {
+    Token token = recognizer.getCurrentToken();
+    String message = "unexpected token " + getTokenErrorDisplay(token) +
+        " on line (" + token.getLine() + ") position (" + token.getCharPositionInLine() + ")" +
+        " was expecting one of " + recognizer.getExpectedTokens().toString(recognizer.getVocabulary());
+    ParseException parseException = new ParseException(message, token.getStartIndex());
+    throw new RuntimeException(parseException);
+  }
+
+  /**
+   * Do not allow syncing after errors to ensure the ANTLR parser will throw an exception
+   *
+   * @param recognizer the parser being used
+   */
+  @Override
+  public void sync(Parser recognizer) {
+  }
+}
diff --git a/lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptVisitor.java b/lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptVisitor.java
new file mode 100644
index 0000000..797f564
--- /dev/null
+++ b/lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptVisitor.java
@@ -0,0 +1,125 @@
+// ANTLR GENERATED CODE: DO NOT EDIT
+package org.apache.lucene.expressions.js;
+import org.antlr.v4.runtime.misc.NotNull;
+import org.antlr.v4.runtime.tree.ParseTreeVisitor;
+
+/**
+ * This interface defines a complete generic visitor for a parse tree produced
+ * by {@link JavascriptParser}.
+ *
+ * @param <T> The return type of the visit operation. Use {@link Void} for
+ * operations with no return type.
+ */
+interface JavascriptVisitor<T> extends ParseTreeVisitor<T> {
+  /**
+   * Visit a parse tree produced by {@link JavascriptParser#compile}.
+   * @param ctx the parse tree
+   * @return the visitor result
+   */
+  T visitCompile(JavascriptParser.CompileContext ctx);
+  /**
+   * Visit a parse tree produced by the {@code conditional}
+   * labeled alternative in {@link JavascriptParser#expression}.
+   * @param ctx the parse tree
+   * @return the visitor result
+   */
+  T visitConditional(JavascriptParser.ConditionalContext ctx);
+  /**
+   * Visit a parse tree produced by the {@code boolor}
+   * labeled alternative in {@link JavascriptParser#expression}.
+   * @param ctx the parse tree
+   * @return the visitor result
+   */
+  T visitBoolor(JavascriptParser.BoolorContext ctx);
+  /**
+   * Visit a parse tree produced by the {@code boolcomp}
+   * labeled alternative in {@link JavascriptParser#expression}.
+   * @param ctx the parse tree
+   * @return the visitor result
+   */
+  T visitBoolcomp(JavascriptParser.BoolcompContext ctx);
+  /**
+   * Visit a parse tree produced by the {@code numeric}
+   * labeled alternative in {@link JavascriptParser#expression}.
+   * @param ctx the parse tree
+   * @return the visitor result
+   */
+  T visitNumeric(JavascriptParser.NumericContext ctx);
+  /**
+   * Visit a parse tree produced by the {@code addsub}
+   * labeled alternative in {@link JavascriptParser#expression}.
+   * @param ctx the parse tree
+   * @return the visitor result
+   */
+  T visitAddsub(JavascriptParser.AddsubContext ctx);
+  /**
+   * Visit a parse tree produced by the {@code unary}
+   * labeled alternative in {@link JavascriptParser#expression}.
+   * @param ctx the parse tree
+   * @return the visitor result
+   */
+  T visitUnary(JavascriptParser.UnaryContext ctx);
+  /**
+   * Visit a parse tree produced by the {@code precedence}
+   * labeled alternative in {@link JavascriptParser#expression}.
+   * @param ctx the parse tree
+   * @return the visitor result
+   */
+  T visitPrecedence(JavascriptParser.PrecedenceContext ctx);
+  /**
+   * Visit a parse tree produced by the {@code muldiv}
+   * labeled alternative in {@link JavascriptParser#expression}.
+   * @param ctx the parse tree
+   * @return the visitor result
+   */
+  T visitMuldiv(JavascriptParser.MuldivContext ctx);
+  /**
+   * Visit a parse tree produced by the {@code external}
+   * labeled alternative in {@link JavascriptParser#expression}.
+   * @param ctx the parse tree
+   * @return the visitor result
+   */
+  T visitExternal(JavascriptParser.ExternalContext ctx);
+  /**
+   * Visit a parse tree produced by the {@code bwshift}
+   * labeled alternative in {@link JavascriptParser#expression}.
+   * @param ctx the parse tree
+   * @return the visitor result
+   */
+  T visitBwshift(JavascriptParser.BwshiftContext ctx);
+  /**
+   * Visit a parse tree produced by the {@code bwor}
+   * labeled alternative in {@link JavascriptParser#expression}.
+   * @param ctx the parse tree
+   * @return the visitor result
+   */
+  T visitBwor(JavascriptParser.BworContext ctx);
+  /**
+   * Visit a parse tree produced by the {@code booland}
+   * labeled alternative in {@link JavascriptParser#expression}.
+   * @param ctx the parse tree
+   * @return the visitor result
+   */
+  T visitBooland(JavascriptParser.BoolandContext ctx);
+  /**
+   * Visit a parse tree produced by the {@code bwxor}
+   * labeled alternative in {@link JavascriptParser#expression}.
+   * @param ctx the parse tree
+   * @return the visitor result
+   */
+  T visitBwxor(JavascriptParser.BwxorContext ctx);
+  /**
+   * Visit a parse tree produced by the {@code bwand}
+   * labeled alternative in {@link JavascriptParser#expression}.
+   * @param ctx the parse tree
+   * @return the visitor result
+   */
+  T visitBwand(JavascriptParser.BwandContext ctx);
+  /**
+   * Visit a parse tree produced by the {@code booleqne}
+   * labeled alternative in {@link JavascriptParser#expression}.
+   * @param ctx the parse tree
+   * @return the visitor result
+   */
+  T visitBooleqne(JavascriptParser.BooleqneContext ctx);
+}
diff --git a/lucene/expressions/src/test/org/apache/lucene/expressions/js/TestJavascriptCompiler.java b/lucene/expressions/src/test/org/apache/lucene/expressions/js/TestJavascriptCompiler.java
index 4c304d8..45275c0 100644
--- a/lucene/expressions/src/test/org/apache/lucene/expressions/js/TestJavascriptCompiler.java
+++ b/lucene/expressions/src/test/org/apache/lucene/expressions/js/TestJavascriptCompiler.java
@@ -18,11 +18,12 @@ package org.apache.lucene.expressions.js;
 
 import java.text.ParseException;
 
+import org.antlr.v4.runtime.RecognitionException;
 import org.apache.lucene.expressions.Expression;
 import org.apache.lucene.util.LuceneTestCase;
 
 public class TestJavascriptCompiler extends LuceneTestCase {
-  
+
   public void testValidCompiles() throws Exception {
     assertNotNull(JavascriptCompiler.compile("100"));
     assertNotNull(JavascriptCompiler.compile("valid0+100"));
@@ -99,6 +100,15 @@ public class TestJavascriptCompiler extends LuceneTestCase {
     }
   }
 
+  public void testInvalidLexer() throws Exception {
+    try {
+      JavascriptCompiler.compile("\n .");
+      fail();
+    } catch (ParseException pe) {
+      assertTrue(pe.getMessage().contains("unexpected character '.' on line (2) position (1)"));
+    }
+  }
+
   public void testInvalidCompiles() throws Exception {
     try {
       JavascriptCompiler.compile("100 100");
diff --git a/lucene/ivy-versions.properties b/lucene/ivy-versions.properties
index 9f8fa34..f5a093b 100644
--- a/lucene/ivy-versions.properties
+++ b/lucene/ivy-versions.properties
@@ -90,7 +90,6 @@ com.sun.jersey.version = 1.9
 /net.sourceforge.argparse4j/argparse4j = 0.4.3
 /net.sourceforge.jmatio/jmatio = 1.0
 /net.sourceforge.nekohtml/nekohtml = 1.9.17
-/org.antlr/antlr-runtime = 3.5
 /org.antlr/antlr4-runtime = 4.5
 
 /org.apache.ant/ant = 1.8.2
diff --git a/lucene/licenses/antlr-runtime-3.5.jar.sha1 b/lucene/licenses/antlr-runtime-3.5.jar.sha1
deleted file mode 100644
index d90b777..0000000
--- a/lucene/licenses/antlr-runtime-3.5.jar.sha1
+++ /dev/null
@@ -1 +0,0 @@
-0baa82bff19059401e90e1b90020beb9c96305d7
diff --git a/lucene/licenses/antlr-runtime-LICENSE-BSD_LIKE.txt b/lucene/licenses/antlr-runtime-LICENSE-BSD_LIKE.txt
deleted file mode 100644
index a6e3ad0..0000000
--- a/lucene/licenses/antlr-runtime-LICENSE-BSD_LIKE.txt
+++ /dev/null
@@ -1,7 +0,0 @@
-Copyright (c) 2012 Terence Parr and Sam Harwell
-All rights reserved.
-Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
-Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
-Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
-Neither the name of the author nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/lucene/licenses/antlr-runtime-NOTICE.txt b/lucene/licenses/antlr-runtime-NOTICE.txt
deleted file mode 100644
index 8d1c8b6..0000000
--- a/lucene/licenses/antlr-runtime-NOTICE.txt
+++ /dev/null
@@ -1 +0,0 @@
- 
diff --git a/lucene/licenses/antlr4-runtime-4.5.jar.sha1 b/lucene/licenses/antlr4-runtime-4.5.jar.sha1
new file mode 100644
index 0000000..5299c19
--- /dev/null
+++ b/lucene/licenses/antlr4-runtime-4.5.jar.sha1
@@ -0,0 +1 @@
+29e48af049f17dd89153b83a7ad5d01b3b4bcdda
diff --git a/lucene/licenses/antlr4-runtime-LICENSE-BSD.txt b/lucene/licenses/antlr4-runtime-LICENSE-BSD.txt
new file mode 100644
index 0000000..95d0a25
--- /dev/null
+++ b/lucene/licenses/antlr4-runtime-LICENSE-BSD.txt
@@ -0,0 +1,26 @@
+[The "BSD license"]
+Copyright (c) 2015 Terence Parr, Sam Harwell
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+ 1. Redistributions of source code must retain the above copyright
+    notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in the
+    documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+    derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/lucene/licenses/antlr4-runtime-NOTICE.txt b/lucene/licenses/antlr4-runtime-NOTICE.txt
new file mode 100644
index 0000000..e69de29
diff --git a/solr/core/ivy.xml b/solr/core/ivy.xml
index fbaefa8..3384571 100644
--- a/solr/core/ivy.xml
+++ b/solr/core/ivy.xml
@@ -37,7 +37,7 @@
     <dependency org="commons-lang" name="commons-lang" rev="${/commons-lang/commons-lang}" conf="compile"/>
     <dependency org="com.google.guava" name="guava" rev="${/com.google.guava/guava}" conf="compile"/>
     <dependency org="com.spatial4j" name="spatial4j" rev="${/com.spatial4j/spatial4j}" conf="compile"/>
-    <dependency org="org.antlr" name="antlr-runtime" rev="${/org.antlr/antlr-runtime}" conf="compile"/>
+    <dependency org="org.antlr" name="antlr4-runtime" rev="${/org.antlr/antlr4-runtime}"/>
     <dependency org="org.apache.commons" name="commons-math3" rev="${/org.apache.commons/commons-math3}" conf="test"/>
     <dependency org="org.ow2.asm" name="asm" rev="${/org.ow2.asm/asm}" conf="compile"/>
     <dependency org="org.ow2.asm" name="asm-commons" rev="${/org.ow2.asm/asm-commons}" conf="compile"/>
@@ -132,7 +132,6 @@
     <!-- SQL Parser -->
 
     <dependency org="com.facebook.presto" name="presto-parser" rev="${/com.facebook.presto/presto-parser}"/>
-    <dependency org="org.antlr" name="antlr4-runtime" rev="${/org.antlr/antlr4-runtime}"/>
     <dependency org="io.airlift" name="slice" rev="${/io.airlift/slice}"/>
 
     <exclude org="*" ext="*" matcher="regexp" type="${ivy.exclude.types}"/> 
diff --git a/solr/licenses/antlr-runtime-3.5.jar.sha1 b/solr/licenses/antlr-runtime-3.5.jar.sha1
deleted file mode 100644
index d90b777..0000000
--- a/solr/licenses/antlr-runtime-3.5.jar.sha1
+++ /dev/null
@@ -1 +0,0 @@
-0baa82bff19059401e90e1b90020beb9c96305d7
diff --git a/solr/licenses/antlr-runtime-LICENSE-BSD_LIKE.txt b/solr/licenses/antlr-runtime-LICENSE-BSD_LIKE.txt
deleted file mode 100644
index a6e3ad0..0000000
--- a/solr/licenses/antlr-runtime-LICENSE-BSD_LIKE.txt
+++ /dev/null
@@ -1,7 +0,0 @@
-Copyright (c) 2012 Terence Parr and Sam Harwell
-All rights reserved.
-Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
-Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
-Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
-Neither the name of the author nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/solr/licenses/antlr-runtime-NOTICE.txt b/solr/licenses/antlr-runtime-NOTICE.txt
deleted file mode 100644
index 8d1c8b6..0000000
--- a/solr/licenses/antlr-runtime-NOTICE.txt
+++ /dev/null
@@ -1 +0,0 @@
- 

