GitDiffStart: 7ce333d639265d8d40943bda5ea6c9ebc2189455 | Thu Oct 1 21:11:39 2009 +0000
diff --git a/CHANGES.txt b/CHANGES.txt
index 07ed0dd..bf3d350 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -18,6 +18,10 @@ API Changes
   attribute interface and no cast needed anymore.  (Uwe Schindler,
   Michael Busch, Robert Muir, Adriano Crestani)
 
+* LUCENE-1857: Convert NumericRangeQuery API to Generics. NumericRangeQuery
+  and NumericRangeFilter now have Integer, Long, Float, Double as type param.
+  (Uwe Schindler)
+
 Bug fixes
 
 New features
diff --git a/src/java/org/apache/lucene/analysis/NumericTokenStream.java b/src/java/org/apache/lucene/analysis/NumericTokenStream.java
index 4fb15a9..abb8b11 100644
--- a/src/java/org/apache/lucene/analysis/NumericTokenStream.java
+++ b/src/java/org/apache/lucene/analysis/NumericTokenStream.java
@@ -195,14 +195,14 @@ public final class NumericTokenStream extends TokenStream {
     return this;
   }
   
-  // @Override
+  @Override
   public void reset() {
     if (valSize == 0)
       throw new IllegalStateException("call set???Value() before usage");
     shift = 0;
   }
 
-  // @Override
+  @Override
   public boolean incrementToken() {
     if (valSize == 0)
       throw new IllegalStateException("call set???Value() before usage");
@@ -233,7 +233,7 @@ public final class NumericTokenStream extends TokenStream {
     return true;
   }
   
-  // @Override
+  @Override
   public String toString() {
     final StringBuffer sb = new StringBuffer("(numeric,valSize=").append(valSize);
     sb.append(",precisionStep=").append(precisionStep).append(')');
diff --git a/src/java/org/apache/lucene/document/NumericField.java b/src/java/org/apache/lucene/document/NumericField.java
index 56eadd7..abfad52 100644
--- a/src/java/org/apache/lucene/document/NumericField.java
+++ b/src/java/org/apache/lucene/document/NumericField.java
@@ -212,6 +212,7 @@ public final class NumericField extends AbstractField {
   }
   
   /** Returns always <code>null</code> for numeric fields */
+  @Override
   public byte[] getBinaryValue(byte[] result){
     return null;
   }
@@ -251,7 +252,7 @@ public final class NumericField extends AbstractField {
    */
   public NumericField setIntValue(final int value) {
     tokenStream.setIntValue(value);
-    fieldsData = new Integer(value);
+    fieldsData = Integer.valueOf(value);
     return this;
   }
   
@@ -263,7 +264,7 @@ public final class NumericField extends AbstractField {
    */
   public NumericField setDoubleValue(final double value) {
     tokenStream.setDoubleValue(value);
-    fieldsData = new Double(value);
+    fieldsData = Double.valueOf(value);
     return this;
   }
   
@@ -275,7 +276,7 @@ public final class NumericField extends AbstractField {
    */
   public NumericField setFloatValue(final float value) {
     tokenStream.setFloatValue(value);
-    fieldsData = new Float(value);
+    fieldsData = Float.valueOf(value);
     return this;
   }
 
diff --git a/src/java/org/apache/lucene/search/MultiTermQuery.java b/src/java/org/apache/lucene/search/MultiTermQuery.java
index b8f93d8..2a284ce 100644
--- a/src/java/org/apache/lucene/search/MultiTermQuery.java
+++ b/src/java/org/apache/lucene/search/MultiTermQuery.java
@@ -264,11 +264,13 @@ public abstract class MultiTermQuery extends Query {
       }
     }
     
+    @Override
     public int hashCode() {
       final int prime = 1279;
       return (int) (prime * termCountCutoff + Double.doubleToLongBits(docCountPercent));
     }
 
+    @Override
     public boolean equals(Object obj) {
       if (this == obj)
         return true;
@@ -303,10 +305,12 @@ public abstract class MultiTermQuery extends Query {
    *  instance; you'll need to create a private instance
    *  instead. */
   public final static RewriteMethod CONSTANT_SCORE_AUTO_REWRITE_DEFAULT = new ConstantScoreAutoRewrite() {
+    @Override
     public void setTermCountCutoff(int count) {
       throw new UnsupportedOperationException("Please create a private instance");
     }
 
+    @Override
     public void setDocCountPercent(double percent) {
       throw new UnsupportedOperationException("Please create a private instance");
     }
@@ -387,6 +391,7 @@ public abstract class MultiTermQuery extends Query {
    * Implemented for back compat in case MultiTermQuery
    * subclasses do no implement.
    */
+  @Override
   public String toString(String field) {
     StringBuffer buffer = new StringBuffer();
     if (term != null) {
@@ -417,7 +422,7 @@ public abstract class MultiTermQuery extends Query {
     rewriteMethod = method;
   }
 
-  //@Override
+  @Override
   public int hashCode() {
     final int prime = 31;
     int result = 1;
@@ -427,7 +432,7 @@ public abstract class MultiTermQuery extends Query {
     return result;
   }
 
-  //@Override
+  @Override
   public boolean equals(Object obj) {
     if (this == obj)
       return true;
diff --git a/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter.java b/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter.java
index b3a974b..68360c3 100644
--- a/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter.java
+++ b/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter.java
@@ -51,13 +51,13 @@ public class MultiTermQueryWrapperFilter extends Filter {
       this.query = query;
   }
   
-  //@Override
+  @Override
   public String toString() {
     // query.toString should be ok for the filter, too, if the query boost is 1.0f
     return query.toString();
   }
 
-  //@Override
+  @Override
   public final boolean equals(final Object o) {
     if (o==this) return true;
     if (o==null) return false;
@@ -67,7 +67,7 @@ public class MultiTermQueryWrapperFilter extends Filter {
     return false;
   }
 
-  //@Override
+  @Override
   public final int hashCode() {
     return query.hashCode();
   }
@@ -135,7 +135,7 @@ public class MultiTermQueryWrapperFilter extends Filter {
    * not.
    * @deprecated Use {@link #getDocIdSet(IndexReader)} instead.
    */
-  //@Override
+  @Override
   public BitSet bits(IndexReader reader) throws IOException {
     final TermEnum enumerator = query.getEnum(reader);
     try {
@@ -155,7 +155,7 @@ public class MultiTermQueryWrapperFilter extends Filter {
    * Returns a DocIdSet with documents that should be
    * permitted in search results.
    */
-  //@Override
+  @Override
   public DocIdSet getDocIdSet(IndexReader reader) throws IOException {
     final TermEnum enumerator = query.getEnum(reader);
     try {
diff --git a/src/java/org/apache/lucene/search/NumericRangeFilter.java b/src/java/org/apache/lucene/search/NumericRangeFilter.java
index 55f2a24..025c341 100644
--- a/src/java/org/apache/lucene/search/NumericRangeFilter.java
+++ b/src/java/org/apache/lucene/search/NumericRangeFilter.java
@@ -31,9 +31,7 @@ import org.apache.lucene.util.NumericUtils; // for javadocs
  * factory methods, eg:
  *
  * <pre>
- * Filter f = NumericRangeFilter.newFloatRange("weight",
- *                                             new Float(0.3f), new Float(0.10f),
- *                                             true, true);
+ * Filter f = NumericRangeFilter.newFloatRange("weight", 0.3f, 0.10f, true, true);
  * </pre>
  *
  * accepts all documents whose float valued "weight" field
@@ -47,9 +45,9 @@ import org.apache.lucene.util.NumericUtils; // for javadocs
  *
  * @since 2.9
  **/
-public final class NumericRangeFilter extends MultiTermQueryWrapperFilter {
+public final class NumericRangeFilter<T extends Number> extends MultiTermQueryWrapperFilter {
 
-  private NumericRangeFilter(final NumericRangeQuery query) {
+  private NumericRangeFilter(final NumericRangeQuery<T> query) {
     super(query);
   }
   
@@ -60,10 +58,10 @@ public final class NumericRangeFilter extends MultiTermQueryWrapperFilter {
    * by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
    * match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
    */
-  public static NumericRangeFilter newLongRange(final String field, final int precisionStep,
+  public static NumericRangeFilter<Long> newLongRange(final String field, final int precisionStep,
     Long min, Long max, final boolean minInclusive, final boolean maxInclusive
   ) {
-    return new NumericRangeFilter(
+    return new NumericRangeFilter<Long>(
       NumericRangeQuery.newLongRange(field, precisionStep, min, max, minInclusive, maxInclusive)
     );
   }
@@ -75,10 +73,10 @@ public final class NumericRangeFilter extends MultiTermQueryWrapperFilter {
    * by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
    * match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
    */
-  public static NumericRangeFilter newLongRange(final String field,
+  public static NumericRangeFilter<Long> newLongRange(final String field,
     Long min, Long max, final boolean minInclusive, final boolean maxInclusive
   ) {
-    return new NumericRangeFilter(
+    return new NumericRangeFilter<Long>(
       NumericRangeQuery.newLongRange(field, min, max, minInclusive, maxInclusive)
     );
   }
@@ -90,10 +88,10 @@ public final class NumericRangeFilter extends MultiTermQueryWrapperFilter {
    * by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
    * match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
    */
-  public static NumericRangeFilter newIntRange(final String field, final int precisionStep,
+  public static NumericRangeFilter<Integer> newIntRange(final String field, final int precisionStep,
     Integer min, Integer max, final boolean minInclusive, final boolean maxInclusive
   ) {
-    return new NumericRangeFilter(
+    return new NumericRangeFilter<Integer>(
       NumericRangeQuery.newIntRange(field, precisionStep, min, max, minInclusive, maxInclusive)
     );
   }
@@ -105,10 +103,10 @@ public final class NumericRangeFilter extends MultiTermQueryWrapperFilter {
    * by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
    * match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
    */
-  public static NumericRangeFilter newIntRange(final String field,
+  public static NumericRangeFilter<Integer> newIntRange(final String field,
     Integer min, Integer max, final boolean minInclusive, final boolean maxInclusive
   ) {
-    return new NumericRangeFilter(
+    return new NumericRangeFilter<Integer>(
       NumericRangeQuery.newIntRange(field, min, max, minInclusive, maxInclusive)
     );
   }
@@ -120,10 +118,10 @@ public final class NumericRangeFilter extends MultiTermQueryWrapperFilter {
    * by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
    * match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
    */
-  public static NumericRangeFilter newDoubleRange(final String field, final int precisionStep,
+  public static NumericRangeFilter<Double> newDoubleRange(final String field, final int precisionStep,
     Double min, Double max, final boolean minInclusive, final boolean maxInclusive
   ) {
-    return new NumericRangeFilter(
+    return new NumericRangeFilter<Double>(
       NumericRangeQuery.newDoubleRange(field, precisionStep, min, max, minInclusive, maxInclusive)
     );
   }
@@ -135,10 +133,10 @@ public final class NumericRangeFilter extends MultiTermQueryWrapperFilter {
    * by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
    * match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
    */
-  public static NumericRangeFilter newDoubleRange(final String field,
+  public static NumericRangeFilter<Double> newDoubleRange(final String field,
     Double min, Double max, final boolean minInclusive, final boolean maxInclusive
   ) {
-    return new NumericRangeFilter(
+    return new NumericRangeFilter<Double>(
       NumericRangeQuery.newDoubleRange(field, min, max, minInclusive, maxInclusive)
     );
   }
@@ -150,10 +148,10 @@ public final class NumericRangeFilter extends MultiTermQueryWrapperFilter {
    * by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
    * match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
    */
-  public static NumericRangeFilter newFloatRange(final String field, final int precisionStep,
+  public static NumericRangeFilter<Float> newFloatRange(final String field, final int precisionStep,
     Float min, Float max, final boolean minInclusive, final boolean maxInclusive
   ) {
-    return new NumericRangeFilter(
+    return new NumericRangeFilter<Float>(
       NumericRangeQuery.newFloatRange(field, precisionStep, min, max, minInclusive, maxInclusive)
     );
   }
@@ -165,27 +163,32 @@ public final class NumericRangeFilter extends MultiTermQueryWrapperFilter {
    * by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
    * match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
    */
-  public static NumericRangeFilter newFloatRange(final String field,
+  public static NumericRangeFilter<Float> newFloatRange(final String field,
     Float min, Float max, final boolean minInclusive, final boolean maxInclusive
   ) {
-    return new NumericRangeFilter(
+    return new NumericRangeFilter<Float>(
       NumericRangeQuery.newFloatRange(field, min, max, minInclusive, maxInclusive)
     );
   }
   
   /** Returns the field name for this filter */
-  public String getField() { return ((NumericRangeQuery)query).getField(); }
+  @SuppressWarnings("unchecked")
+  public String getField() { return ((NumericRangeQuery<T>)query).getField(); }
 
   /** Returns <code>true</code> if the lower endpoint is inclusive */
-  public boolean includesMin() { return ((NumericRangeQuery)query).includesMin(); }
+  @SuppressWarnings("unchecked")
+  public boolean includesMin() { return ((NumericRangeQuery<T>)query).includesMin(); }
   
   /** Returns <code>true</code> if the upper endpoint is inclusive */
-  public boolean includesMax() { return ((NumericRangeQuery)query).includesMax(); }
+  @SuppressWarnings("unchecked")
+  public boolean includesMax() { return ((NumericRangeQuery<T>)query).includesMax(); }
 
   /** Returns the lower value of this range filter */
-  public Number getMin() { return ((NumericRangeQuery)query).getMin(); }
+  @SuppressWarnings("unchecked")
+  public T getMin() { return ((NumericRangeQuery<T>)query).getMin(); }
 
   /** Returns the upper value of this range filter */
-  public Number getMax() { return ((NumericRangeQuery)query).getMax(); }
+  @SuppressWarnings("unchecked")
+  public T getMax() { return ((NumericRangeQuery<T>)query).getMax(); }
   
 }
diff --git a/src/java/org/apache/lucene/search/NumericRangeQuery.java b/src/java/org/apache/lucene/search/NumericRangeQuery.java
index 0e405e4..48d67ba 100644
--- a/src/java/org/apache/lucene/search/NumericRangeQuery.java
+++ b/src/java/org/apache/lucene/search/NumericRangeQuery.java
@@ -41,9 +41,7 @@ import org.apache.lucene.index.Term;
  * factory methods, eg:
  *
  * <pre>
- * Query q = NumericRangeQuery.newFloatRange("weight",
- *                                           new Float(0.3f), new Float(0.10f),
- *                                           true, true);
+ * Query q = NumericRangeQuery.newFloatRange("weight", 0.3f, 0.10f, true, true);
  * </pre>
  *
  * matches all documents whose float valued "weight" field
@@ -154,10 +152,10 @@ import org.apache.lucene.index.Term;
  *
  * @since 2.9
  **/
-public final class NumericRangeQuery extends MultiTermQuery {
+public final class NumericRangeQuery<T extends Number> extends MultiTermQuery {
 
   private NumericRangeQuery(final String field, final int precisionStep, final int valSize,
-    Number min, Number max, final boolean minInclusive, final boolean maxInclusive
+    T min, T max, final boolean minInclusive, final boolean maxInclusive
   ) {
     assert (valSize == 32 || valSize == 64);
     if (precisionStep < 1)
@@ -200,10 +198,10 @@ public final class NumericRangeQuery extends MultiTermQuery {
    * by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
    * match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
    */
-  public static NumericRangeQuery newLongRange(final String field, final int precisionStep,
+  public static NumericRangeQuery<Long> newLongRange(final String field, final int precisionStep,
     Long min, Long max, final boolean minInclusive, final boolean maxInclusive
   ) {
-    return new NumericRangeQuery(field, precisionStep, 64, min, max, minInclusive, maxInclusive);
+    return new NumericRangeQuery<Long>(field, precisionStep, 64, min, max, minInclusive, maxInclusive);
   }
   
   /**
@@ -213,10 +211,10 @@ public final class NumericRangeQuery extends MultiTermQuery {
    * by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
    * match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
    */
-  public static NumericRangeQuery newLongRange(final String field,
+  public static NumericRangeQuery<Long> newLongRange(final String field,
     Long min, Long max, final boolean minInclusive, final boolean maxInclusive
   ) {
-    return new NumericRangeQuery(field, NumericUtils.PRECISION_STEP_DEFAULT, 64, min, max, minInclusive, maxInclusive);
+    return new NumericRangeQuery<Long>(field, NumericUtils.PRECISION_STEP_DEFAULT, 64, min, max, minInclusive, maxInclusive);
   }
   
   /**
@@ -226,10 +224,10 @@ public final class NumericRangeQuery extends MultiTermQuery {
    * by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
    * match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
    */
-  public static NumericRangeQuery newIntRange(final String field, final int precisionStep,
+  public static NumericRangeQuery<Integer> newIntRange(final String field, final int precisionStep,
     Integer min, Integer max, final boolean minInclusive, final boolean maxInclusive
   ) {
-    return new NumericRangeQuery(field, precisionStep, 32, min, max, minInclusive, maxInclusive);
+    return new NumericRangeQuery<Integer>(field, precisionStep, 32, min, max, minInclusive, maxInclusive);
   }
   
   /**
@@ -239,10 +237,10 @@ public final class NumericRangeQuery extends MultiTermQuery {
    * by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
    * match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
    */
-  public static NumericRangeQuery newIntRange(final String field,
+  public static NumericRangeQuery<Integer> newIntRange(final String field,
     Integer min, Integer max, final boolean minInclusive, final boolean maxInclusive
   ) {
-    return new NumericRangeQuery(field, NumericUtils.PRECISION_STEP_DEFAULT, 32, min, max, minInclusive, maxInclusive);
+    return new NumericRangeQuery<Integer>(field, NumericUtils.PRECISION_STEP_DEFAULT, 32, min, max, minInclusive, maxInclusive);
   }
   
   /**
@@ -252,10 +250,10 @@ public final class NumericRangeQuery extends MultiTermQuery {
    * by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
    * match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
    */
-  public static NumericRangeQuery newDoubleRange(final String field, final int precisionStep,
+  public static NumericRangeQuery<Double> newDoubleRange(final String field, final int precisionStep,
     Double min, Double max, final boolean minInclusive, final boolean maxInclusive
   ) {
-    return new NumericRangeQuery(field, precisionStep, 64, min, max, minInclusive, maxInclusive);
+    return new NumericRangeQuery<Double>(field, precisionStep, 64, min, max, minInclusive, maxInclusive);
   }
   
   /**
@@ -265,10 +263,10 @@ public final class NumericRangeQuery extends MultiTermQuery {
    * by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
    * match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
    */
-  public static NumericRangeQuery newDoubleRange(final String field,
+  public static NumericRangeQuery<Double> newDoubleRange(final String field,
     Double min, Double max, final boolean minInclusive, final boolean maxInclusive
   ) {
-    return new NumericRangeQuery(field, NumericUtils.PRECISION_STEP_DEFAULT, 64, min, max, minInclusive, maxInclusive);
+    return new NumericRangeQuery<Double>(field, NumericUtils.PRECISION_STEP_DEFAULT, 64, min, max, minInclusive, maxInclusive);
   }
   
   /**
@@ -278,10 +276,10 @@ public final class NumericRangeQuery extends MultiTermQuery {
    * by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
    * match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
    */
-  public static NumericRangeQuery newFloatRange(final String field, final int precisionStep,
+  public static NumericRangeQuery<Float> newFloatRange(final String field, final int precisionStep,
     Float min, Float max, final boolean minInclusive, final boolean maxInclusive
   ) {
-    return new NumericRangeQuery(field, precisionStep, 32, min, max, minInclusive, maxInclusive);
+    return new NumericRangeQuery<Float>(field, precisionStep, 32, min, max, minInclusive, maxInclusive);
   }
   
   /**
@@ -291,13 +289,13 @@ public final class NumericRangeQuery extends MultiTermQuery {
    * by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
    * match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
    */
-  public static NumericRangeQuery newFloatRange(final String field,
+  public static NumericRangeQuery<Float> newFloatRange(final String field,
     Float min, Float max, final boolean minInclusive, final boolean maxInclusive
   ) {
-    return new NumericRangeQuery(field, NumericUtils.PRECISION_STEP_DEFAULT, 32, min, max, minInclusive, maxInclusive);
+    return new NumericRangeQuery<Float>(field, NumericUtils.PRECISION_STEP_DEFAULT, 32, min, max, minInclusive, maxInclusive);
   }
   
-  //@Override
+  @Override
   protected FilteredTermEnum getEnum(final IndexReader reader) throws IOException {
     return new NumericRangeTermEnum(reader);
   }
@@ -312,12 +310,12 @@ public final class NumericRangeQuery extends MultiTermQuery {
   public boolean includesMax() { return maxInclusive; }
 
   /** Returns the lower value of this range query */
-  public Number getMin() { return min; }
+  public T getMin() { return min; }
 
   /** Returns the upper value of this range query */
-  public Number getMax() { return max; }
+  public T getMax() { return max; }
   
-  //@Override
+  @Override
   public String toString(final String field) {
     final StringBuffer sb = new StringBuffer();
     if (!this.field.equals(field)) sb.append(this.field).append(':');
@@ -330,7 +328,7 @@ public final class NumericRangeQuery extends MultiTermQuery {
       .toString();
   }
 
-  //@Override
+  @Override
   public final boolean equals(final Object o) {
     if (o==this) return true;
     if (!super.equals(o))
@@ -349,7 +347,7 @@ public final class NumericRangeQuery extends MultiTermQuery {
     return false;
   }
 
-  //@Override
+  @Override
   public final int hashCode() {
     int hash = super.hashCode();
     hash += field.hashCode()^0x4565fd66 + precisionStep^0x64365465;
@@ -363,7 +361,7 @@ public final class NumericRangeQuery extends MultiTermQuery {
   // members (package private, to be also fast accessible by NumericRangeTermEnum)
   final String field;
   final int precisionStep, valSize;
-  final Number min, max;
+  final T min, max;
   final boolean minInclusive,maxInclusive;
 
   /**
@@ -379,7 +377,7 @@ public final class NumericRangeQuery extends MultiTermQuery {
   private final class NumericRangeTermEnum extends FilteredTermEnum {
 
     private final IndexReader reader;
-    private final LinkedList/*<String>*/ rangeBounds = new LinkedList/*<String>*/();
+    private final LinkedList<String> rangeBounds = new LinkedList<String>();
     private String currentUpperBound = null;
 
     NumericRangeTermEnum(final IndexReader reader) throws IOException {
@@ -412,7 +410,7 @@ public final class NumericRangeQuery extends MultiTermQuery {
           }
           
           NumericUtils.splitLongRange(new NumericUtils.LongRangeBuilder() {
-            //@Override
+            @Override
             public final void addRange(String minPrefixCoded, String maxPrefixCoded) {
               rangeBounds.add(minPrefixCoded);
               rangeBounds.add(maxPrefixCoded);
@@ -447,7 +445,7 @@ public final class NumericRangeQuery extends MultiTermQuery {
           }
           
           NumericUtils.splitIntRange(new NumericUtils.IntRangeBuilder() {
-            //@Override
+            @Override
             public final void addRange(String minPrefixCoded, String maxPrefixCoded) {
               rangeBounds.add(minPrefixCoded);
               rangeBounds.add(maxPrefixCoded);
@@ -465,13 +463,13 @@ public final class NumericRangeQuery extends MultiTermQuery {
       next();
     }
 
-    //@Override
+    @Override
     public float difference() {
       return 1.0f;
     }
     
     /** this is a dummy, it is not used by this class. */
-    //@Override
+    @Override
     protected boolean endEnum() {
       assert false; // should never be called
       return (currentTerm != null);
@@ -484,13 +482,13 @@ public final class NumericRangeQuery extends MultiTermQuery {
      * of <code>false</code> ends iterating the current enum
      * and forwards to the next sub-range.
      */
-    //@Override
+    @Override
     protected boolean termCompare(Term term) {
       return (term.field() == field && term.text().compareTo(currentUpperBound) <= 0);
     }
     
     /** Increments the enumeration to the next element.  True if one exists. */
-    //@Override
+    @Override
     public boolean next() throws IOException {
       // if a current term exists, the actual enum is initialized:
       // try change to next term, if no such term exists, fall-through
@@ -510,8 +508,8 @@ public final class NumericRangeQuery extends MultiTermQuery {
         actualEnum.close();
         actualEnum = null;
       }
-      final String lowerBound = (String)rangeBounds.removeFirst();
-      this.currentUpperBound = (String)rangeBounds.removeFirst();
+      final String lowerBound = rangeBounds.removeFirst();
+      this.currentUpperBound = rangeBounds.removeFirst();
       // this call recursively uses next(), if no valid term in
       // next enum found.
       // if this behavior is changed/modified in the superclass,
@@ -521,7 +519,7 @@ public final class NumericRangeQuery extends MultiTermQuery {
     }
 
     /** Closes the enumeration to further activity, freeing resources.  */
-    //@Override
+    @Override
     public void close() throws IOException {
       rangeBounds.clear();
       currentUpperBound = null;
diff --git a/src/test/org/apache/lucene/search/TestMultiValuedNumericRangeQuery.java b/src/test/org/apache/lucene/search/TestMultiValuedNumericRangeQuery.java
index 4588f1d..e137298 100644
--- a/src/test/org/apache/lucene/search/TestMultiValuedNumericRangeQuery.java
+++ b/src/test/org/apache/lucene/search/TestMultiValuedNumericRangeQuery.java
@@ -66,7 +66,7 @@ public class TestMultiValuedNumericRangeQuery extends LuceneTestCase {
         int a=lower; lower=upper; upper=a;
       }
       TermRangeQuery cq=new TermRangeQuery("asc", format.format(lower), format.format(upper), true, true);
-      NumericRangeQuery tq=NumericRangeQuery.newIntRange("trie", new Integer(lower), new Integer(upper), true, true);
+      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange("trie", lower, upper, true, true);
       TopDocs trTopDocs = searcher.search(cq, 1);
       TopDocs nrTopDocs = searcher.search(tq, 1);
       assertEquals("Returned count for NumericRangeQuery and TermRangeQuery must be equal", trTopDocs.totalHits, nrTopDocs.totalHits );
diff --git a/src/test/org/apache/lucene/search/TestNumericRangeQuery32.java b/src/test/org/apache/lucene/search/TestNumericRangeQuery32.java
index 77ad927..d93a34e 100644
--- a/src/test/org/apache/lucene/search/TestNumericRangeQuery32.java
+++ b/src/test/org/apache/lucene/search/TestNumericRangeQuery32.java
@@ -91,8 +91,8 @@ public class TestNumericRangeQuery32 extends LuceneTestCase {
     String field="field"+precisionStep;
     int count=3000;
     int lower=(distance*3/2)+startOffset, upper=lower + count*distance + (distance/3);
-    NumericRangeQuery q = NumericRangeQuery.newIntRange(field, precisionStep, new Integer(lower), new Integer(upper), true, true);
-    NumericRangeFilter f = NumericRangeFilter.newIntRange(field, precisionStep, new Integer(lower), new Integer(upper), true, true);
+    NumericRangeQuery<Integer> q = NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);
+    NumericRangeFilter<Integer> f = NumericRangeFilter.newIntRange(field, precisionStep, lower, upper, true, true);
     int lastTerms = 0;
     for (byte i=0; i<3; i++) {
       TopDocs topDocs;
@@ -149,12 +149,12 @@ public class TestNumericRangeQuery32 extends LuceneTestCase {
   }
   
   public void testInverseRange() throws Exception {
-    NumericRangeFilter f = NumericRangeFilter.newIntRange("field8", 8, new Integer(1000), new Integer(-1000), true, true);
+    NumericRangeFilter<Integer> f = NumericRangeFilter.newIntRange("field8", 8, 1000, -1000, true, true);
     assertSame("A inverse range should return the EMPTY_DOCIDSET instance", DocIdSet.EMPTY_DOCIDSET, f.getDocIdSet(searcher.getIndexReader()));
-    f = NumericRangeFilter.newIntRange("field8", 8, new Integer(Integer.MAX_VALUE), null, false, false);
+    f = NumericRangeFilter.newIntRange("field8", 8, Integer.MAX_VALUE, null, false, false);
     assertSame("A exclusive range starting with Integer.MAX_VALUE should return the EMPTY_DOCIDSET instance",
       DocIdSet.EMPTY_DOCIDSET, f.getDocIdSet(searcher.getIndexReader()));
-    f = NumericRangeFilter.newIntRange("field8", 8, null, new Integer(Integer.MIN_VALUE), false, false);
+    f = NumericRangeFilter.newIntRange("field8", 8, null, Integer.MIN_VALUE, false, false);
     assertSame("A exclusive range ending with Integer.MIN_VALUE should return the EMPTY_DOCIDSET instance",
       DocIdSet.EMPTY_DOCIDSET, f.getDocIdSet(searcher.getIndexReader()));
   }
@@ -163,7 +163,7 @@ public class TestNumericRangeQuery32 extends LuceneTestCase {
     String field="field"+precisionStep;
     int count=3000;
     int upper=(count-1)*distance + (distance/3) + startOffset;
-    NumericRangeQuery q=NumericRangeQuery.newIntRange(field, precisionStep, null, new Integer(upper), true, true);
+    NumericRangeQuery<Integer> q=NumericRangeQuery.newIntRange(field, precisionStep, null, upper, true, true);
     TopDocs topDocs = searcher.search(q, null, noDocs, Sort.INDEXORDER);
     System.out.println("Found "+q.getTotalNumberOfTerms()+" distinct terms in left open range for field '"+field+"'.");
     ScoreDoc[] sd = topDocs.scoreDocs;
@@ -191,7 +191,7 @@ public class TestNumericRangeQuery32 extends LuceneTestCase {
     String field="field"+precisionStep;
     int count=3000;
     int lower=(count-1)*distance + (distance/3) +startOffset;
-    NumericRangeQuery q=NumericRangeQuery.newIntRange(field, precisionStep, new Integer(lower), null, true, true);
+    NumericRangeQuery<Integer> q=NumericRangeQuery.newIntRange(field, precisionStep, lower, null, true, true);
     TopDocs topDocs = searcher.search(q, null, noDocs, Sort.INDEXORDER);
     System.out.println("Found "+q.getTotalNumberOfTerms()+" distinct terms in right open range for field '"+field+"'.");
     ScoreDoc[] sd = topDocs.scoreDocs;
@@ -226,7 +226,7 @@ public class TestNumericRangeQuery32 extends LuceneTestCase {
         int a=lower; lower=upper; upper=a;
       }
       // test inclusive range
-      NumericRangeQuery tq=NumericRangeQuery.newIntRange(field, precisionStep, new Integer(lower), new Integer(upper), true, true);
+      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);
       TermRangeQuery cq=new TermRangeQuery(field, NumericUtils.intToPrefixCoded(lower), NumericUtils.intToPrefixCoded(upper), true, true);
       TopDocs tTopDocs = searcher.search(tq, 1);
       TopDocs cTopDocs = searcher.search(cq, 1);
@@ -234,7 +234,7 @@ public class TestNumericRangeQuery32 extends LuceneTestCase {
       termCountT += tq.getTotalNumberOfTerms();
       termCountC += cq.getTotalNumberOfTerms();
       // test exclusive range
-      tq=NumericRangeQuery.newIntRange(field, precisionStep, new Integer(lower), new Integer(upper), false, false);
+      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);
       cq=new TermRangeQuery(field, NumericUtils.intToPrefixCoded(lower), NumericUtils.intToPrefixCoded(upper), false, false);
       tTopDocs = searcher.search(tq, 1);
       cTopDocs = searcher.search(cq, 1);
@@ -242,7 +242,7 @@ public class TestNumericRangeQuery32 extends LuceneTestCase {
       termCountT += tq.getTotalNumberOfTerms();
       termCountC += cq.getTotalNumberOfTerms();
       // test left exclusive range
-      tq=NumericRangeQuery.newIntRange(field, precisionStep, new Integer(lower), new Integer(upper), false, true);
+      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);
       cq=new TermRangeQuery(field, NumericUtils.intToPrefixCoded(lower), NumericUtils.intToPrefixCoded(upper), false, true);
       tTopDocs = searcher.search(tq, 1);
       cTopDocs = searcher.search(cq, 1);
@@ -250,7 +250,7 @@ public class TestNumericRangeQuery32 extends LuceneTestCase {
       termCountT += tq.getTotalNumberOfTerms();
       termCountC += cq.getTotalNumberOfTerms();
       // test right exclusive range
-      tq=NumericRangeQuery.newIntRange(field, precisionStep, new Integer(lower), new Integer(upper), true, false);
+      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);
       cq=new TermRangeQuery(field, NumericUtils.intToPrefixCoded(lower), NumericUtils.intToPrefixCoded(upper), true, false);
       tTopDocs = searcher.search(tq, 1);
       cTopDocs = searcher.search(cq, 1);
@@ -294,19 +294,19 @@ public class TestNumericRangeQuery32 extends LuceneTestCase {
         int a=lower; lower=upper; upper=a;
       }
       // test inclusive range
-      Query tq=NumericRangeQuery.newIntRange(field, precisionStep, new Integer(lower), new Integer(upper), true, true);
+      Query tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);
       TopDocs tTopDocs = searcher.search(tq, 1);
       assertEquals("Returned count of range query must be equal to inclusive range length", upper-lower+1, tTopDocs.totalHits );
       // test exclusive range
-      tq=NumericRangeQuery.newIntRange(field, precisionStep, new Integer(lower), new Integer(upper), false, false);
+      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);
       tTopDocs = searcher.search(tq, 1);
       assertEquals("Returned count of range query must be equal to exclusive range length", Math.max(upper-lower-1, 0), tTopDocs.totalHits );
       // test left exclusive range
-      tq=NumericRangeQuery.newIntRange(field, precisionStep, new Integer(lower), new Integer(upper), false, true);
+      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);
       tTopDocs = searcher.search(tq, 1);
       assertEquals("Returned count of range query must be equal to half exclusive range length", upper-lower, tTopDocs.totalHits );
       // test right exclusive range
-      tq=NumericRangeQuery.newIntRange(field, precisionStep, new Integer(lower), new Integer(upper), true, false);
+      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);
       tTopDocs = searcher.search(tq, 1);
       assertEquals("Returned count of range query must be equal to half exclusive range length", upper-lower, tTopDocs.totalHits );
     }
@@ -330,12 +330,12 @@ public class TestNumericRangeQuery32 extends LuceneTestCase {
     final int lower=-1000, upper=+2000;
     
     Query tq=NumericRangeQuery.newFloatRange(field, precisionStep,
-      new Float(NumericUtils.sortableIntToFloat(lower)), new Float(NumericUtils.sortableIntToFloat(upper)), true, true);
+      NumericUtils.sortableIntToFloat(lower), NumericUtils.sortableIntToFloat(upper), true, true);
     TopDocs tTopDocs = searcher.search(tq, 1);
     assertEquals("Returned count of range query must be equal to inclusive range length", upper-lower+1, tTopDocs.totalHits );
     
     Filter tf=NumericRangeFilter.newFloatRange(field, precisionStep,
-      new Float(NumericUtils.sortableIntToFloat(lower)), new Float(NumericUtils.sortableIntToFloat(upper)), true, true);
+      NumericUtils.sortableIntToFloat(lower), NumericUtils.sortableIntToFloat(upper), true, true);
     tTopDocs = searcher.search(new MatchAllDocsQuery(), tf, 1);
     assertEquals("Returned count of range filter must be equal to inclusive range length", upper-lower+1, tTopDocs.totalHits );
   }
@@ -363,7 +363,7 @@ public class TestNumericRangeQuery32 extends LuceneTestCase {
       if (lower>upper) {
         int a=lower; lower=upper; upper=a;
       }
-      Query tq=NumericRangeQuery.newIntRange(field, precisionStep, new Integer(lower), new Integer(upper), true, true);
+      Query tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);
       TopDocs topDocs = searcher.search(tq, null, noDocs, new Sort(new SortField(field, SortField.INT, true)));
       if (topDocs.totalHits==0) continue;
       ScoreDoc[] sd = topDocs.scoreDocs;
@@ -390,40 +390,40 @@ public class TestNumericRangeQuery32 extends LuceneTestCase {
   }
   
   public void testEqualsAndHash() throws Exception {
-    QueryUtils.checkHashEquals(NumericRangeQuery.newIntRange("test1", 4, new Integer(10), new Integer(20), true, true));
-    QueryUtils.checkHashEquals(NumericRangeQuery.newIntRange("test2", 4, new Integer(10), new Integer(20), false, true));
-    QueryUtils.checkHashEquals(NumericRangeQuery.newIntRange("test3", 4, new Integer(10), new Integer(20), true, false));
-    QueryUtils.checkHashEquals(NumericRangeQuery.newIntRange("test4", 4, new Integer(10), new Integer(20), false, false));
-    QueryUtils.checkHashEquals(NumericRangeQuery.newIntRange("test5", 4, new Integer(10), null, true, true));
-    QueryUtils.checkHashEquals(NumericRangeQuery.newIntRange("test6", 4, null, new Integer(20), true, true));
+    QueryUtils.checkHashEquals(NumericRangeQuery.newIntRange("test1", 4, 10, 20, true, true));
+    QueryUtils.checkHashEquals(NumericRangeQuery.newIntRange("test2", 4, 10, 20, false, true));
+    QueryUtils.checkHashEquals(NumericRangeQuery.newIntRange("test3", 4, 10, 20, true, false));
+    QueryUtils.checkHashEquals(NumericRangeQuery.newIntRange("test4", 4, 10, 20, false, false));
+    QueryUtils.checkHashEquals(NumericRangeQuery.newIntRange("test5", 4, 10, null, true, true));
+    QueryUtils.checkHashEquals(NumericRangeQuery.newIntRange("test6", 4, null, 20, true, true));
     QueryUtils.checkHashEquals(NumericRangeQuery.newIntRange("test7", 4, null, null, true, true));
     QueryUtils.checkEqual(
-      NumericRangeQuery.newIntRange("test8", 4, new Integer(10), new Integer(20), true, true), 
-      NumericRangeQuery.newIntRange("test8", 4, new Integer(10), new Integer(20), true, true)
+      NumericRangeQuery.newIntRange("test8", 4, 10, 20, true, true), 
+      NumericRangeQuery.newIntRange("test8", 4, 10, 20, true, true)
     );
     QueryUtils.checkUnequal(
-      NumericRangeQuery.newIntRange("test9", 4, new Integer(10), new Integer(20), true, true), 
-      NumericRangeQuery.newIntRange("test9", 8, new Integer(10), new Integer(20), true, true)
+      NumericRangeQuery.newIntRange("test9", 4, 10, 20, true, true), 
+      NumericRangeQuery.newIntRange("test9", 8, 10, 20, true, true)
     );
     QueryUtils.checkUnequal(
-      NumericRangeQuery.newIntRange("test10a", 4, new Integer(10), new Integer(20), true, true), 
-      NumericRangeQuery.newIntRange("test10b", 4, new Integer(10), new Integer(20), true, true)
+      NumericRangeQuery.newIntRange("test10a", 4, 10, 20, true, true), 
+      NumericRangeQuery.newIntRange("test10b", 4, 10, 20, true, true)
     );
     QueryUtils.checkUnequal(
-      NumericRangeQuery.newIntRange("test11", 4, new Integer(10), new Integer(20), true, true), 
-      NumericRangeQuery.newIntRange("test11", 4, new Integer(20), new Integer(10), true, true)
+      NumericRangeQuery.newIntRange("test11", 4, 10, 20, true, true), 
+      NumericRangeQuery.newIntRange("test11", 4, 20, 10, true, true)
     );
     QueryUtils.checkUnequal(
-      NumericRangeQuery.newIntRange("test12", 4, new Integer(10), new Integer(20), true, true), 
-      NumericRangeQuery.newIntRange("test12", 4, new Integer(10), new Integer(20), false, true)
+      NumericRangeQuery.newIntRange("test12", 4, 10, 20, true, true), 
+      NumericRangeQuery.newIntRange("test12", 4, 10, 20, false, true)
     );
     QueryUtils.checkUnequal(
-      NumericRangeQuery.newIntRange("test13", 4, new Integer(10), new Integer(20), true, true), 
-      NumericRangeQuery.newFloatRange("test13", 4, new Float(10f), new Float(20f), true, true)
+      NumericRangeQuery.newIntRange("test13", 4, 10, 20, true, true), 
+      NumericRangeQuery.newFloatRange("test13", 4, 10f, 20f, true, true)
     );
     // the following produces a hash collision, because Long and Integer have the same hashcode, so only test equality:
-    Query q1 = NumericRangeQuery.newIntRange("test14", 4, new Integer(10), new Integer(20), true, true);
-    Query q2 = NumericRangeQuery.newLongRange("test14", 4, new Long(10L), new Long(20L), true, true);
+    Query q1 = NumericRangeQuery.newIntRange("test14", 4, 10, 20, true, true);
+    Query q2 = NumericRangeQuery.newLongRange("test14", 4, 10L, 20L, true, true);
     assertFalse(q1.equals(q2));
     assertFalse(q2.equals(q1));
   }
diff --git a/src/test/org/apache/lucene/search/TestNumericRangeQuery64.java b/src/test/org/apache/lucene/search/TestNumericRangeQuery64.java
index 67f0d65..4f42aa0 100644
--- a/src/test/org/apache/lucene/search/TestNumericRangeQuery64.java
+++ b/src/test/org/apache/lucene/search/TestNumericRangeQuery64.java
@@ -95,8 +95,8 @@ public class TestNumericRangeQuery64 extends LuceneTestCase {
     String field="field"+precisionStep;
     int count=3000;
     long lower=(distance*3/2)+startOffset, upper=lower + count*distance + (distance/3);
-    NumericRangeQuery q = NumericRangeQuery.newLongRange(field, precisionStep, new Long(lower), new Long(upper), true, true);
-    NumericRangeFilter f = NumericRangeFilter.newLongRange(field, precisionStep, new Long(lower), new Long(upper), true, true);
+    NumericRangeQuery<Long> q = NumericRangeQuery.newLongRange(field, precisionStep, lower, upper, true, true);
+    NumericRangeFilter<Long> f = NumericRangeFilter.newLongRange(field, precisionStep, lower, upper, true, true);
     int lastTerms = 0;
     for (byte i=0; i<3; i++) {
       TopDocs topDocs;
@@ -157,12 +157,12 @@ public class TestNumericRangeQuery64 extends LuceneTestCase {
   }
   
   public void testInverseRange() throws Exception {
-    NumericRangeFilter f = NumericRangeFilter.newLongRange("field8", 8, new Long(1000L), new Long(-1000L), true, true);
+    NumericRangeFilter<Long> f = NumericRangeFilter.newLongRange("field8", 8, 1000L, -1000L, true, true);
     assertSame("A inverse range should return the EMPTY_DOCIDSET instance", DocIdSet.EMPTY_DOCIDSET, f.getDocIdSet(searcher.getIndexReader()));
-    f = NumericRangeFilter.newLongRange("field8", 8, new Long(Long.MAX_VALUE), null, false, false);
+    f = NumericRangeFilter.newLongRange("field8", 8, Long.MAX_VALUE, null, false, false);
     assertSame("A exclusive range starting with Long.MAX_VALUE should return the EMPTY_DOCIDSET instance",
       DocIdSet.EMPTY_DOCIDSET, f.getDocIdSet(searcher.getIndexReader()));
-    f = NumericRangeFilter.newLongRange("field8", 8, null, new Long(Long.MIN_VALUE), false, false);
+    f = NumericRangeFilter.newLongRange("field8", 8, null, Long.MIN_VALUE, false, false);
     assertSame("A exclusive range ending with Long.MIN_VALUE should return the EMPTY_DOCIDSET instance",
       DocIdSet.EMPTY_DOCIDSET, f.getDocIdSet(searcher.getIndexReader()));
   }
@@ -171,7 +171,7 @@ public class TestNumericRangeQuery64 extends LuceneTestCase {
     String field="field"+precisionStep;
     int count=3000;
     long upper=(count-1)*distance + (distance/3) + startOffset;
-    NumericRangeQuery q=NumericRangeQuery.newLongRange(field, precisionStep, null, new Long(upper), true, true);
+    NumericRangeQuery<Long> q=NumericRangeQuery.newLongRange(field, precisionStep, null, upper, true, true);
     TopDocs topDocs = searcher.search(q, null, noDocs, Sort.INDEXORDER);
     System.out.println("Found "+q.getTotalNumberOfTerms()+" distinct terms in left open range for field '"+field+"'.");
     ScoreDoc[] sd = topDocs.scoreDocs;
@@ -203,7 +203,7 @@ public class TestNumericRangeQuery64 extends LuceneTestCase {
     String field="field"+precisionStep;
     int count=3000;
     long lower=(count-1)*distance + (distance/3) +startOffset;
-    NumericRangeQuery q=NumericRangeQuery.newLongRange(field, precisionStep, new Long(lower), null, true, true);
+    NumericRangeQuery<Long> q=NumericRangeQuery.newLongRange(field, precisionStep, lower, null, true, true);
     TopDocs topDocs = searcher.search(q, null, noDocs, Sort.INDEXORDER);
     System.out.println("Found "+q.getTotalNumberOfTerms()+" distinct terms in right open range for field '"+field+"'.");
     ScoreDoc[] sd = topDocs.scoreDocs;
@@ -242,7 +242,7 @@ public class TestNumericRangeQuery64 extends LuceneTestCase {
         long a=lower; lower=upper; upper=a;
       }
       // test inclusive range
-      NumericRangeQuery tq=NumericRangeQuery.newLongRange(field, precisionStep, new Long(lower), new Long(upper), true, true);
+      NumericRangeQuery<Long> tq=NumericRangeQuery.newLongRange(field, precisionStep, lower, upper, true, true);
       TermRangeQuery cq=new TermRangeQuery(field, NumericUtils.longToPrefixCoded(lower), NumericUtils.longToPrefixCoded(upper), true, true);
       TopDocs tTopDocs = searcher.search(tq, 1);
       TopDocs cTopDocs = searcher.search(cq, 1);
@@ -250,7 +250,7 @@ public class TestNumericRangeQuery64 extends LuceneTestCase {
       termCountT += tq.getTotalNumberOfTerms();
       termCountC += cq.getTotalNumberOfTerms();
       // test exclusive range
-      tq=NumericRangeQuery.newLongRange(field, precisionStep, new Long(lower), new Long(upper), false, false);
+      tq=NumericRangeQuery.newLongRange(field, precisionStep, lower, upper, false, false);
       cq=new TermRangeQuery(field, NumericUtils.longToPrefixCoded(lower), NumericUtils.longToPrefixCoded(upper), false, false);
       tTopDocs = searcher.search(tq, 1);
       cTopDocs = searcher.search(cq, 1);
@@ -258,7 +258,7 @@ public class TestNumericRangeQuery64 extends LuceneTestCase {
       termCountT += tq.getTotalNumberOfTerms();
       termCountC += cq.getTotalNumberOfTerms();
       // test left exclusive range
-      tq=NumericRangeQuery.newLongRange(field, precisionStep, new Long(lower), new Long(upper), false, true);
+      tq=NumericRangeQuery.newLongRange(field, precisionStep, lower, upper, false, true);
       cq=new TermRangeQuery(field, NumericUtils.longToPrefixCoded(lower), NumericUtils.longToPrefixCoded(upper), false, true);
       tTopDocs = searcher.search(tq, 1);
       cTopDocs = searcher.search(cq, 1);
@@ -266,7 +266,7 @@ public class TestNumericRangeQuery64 extends LuceneTestCase {
       termCountT += tq.getTotalNumberOfTerms();
       termCountC += cq.getTotalNumberOfTerms();
       // test right exclusive range
-      tq=NumericRangeQuery.newLongRange(field, precisionStep, new Long(lower), new Long(upper), true, false);
+      tq=NumericRangeQuery.newLongRange(field, precisionStep, lower, upper, true, false);
       cq=new TermRangeQuery(field, NumericUtils.longToPrefixCoded(lower), NumericUtils.longToPrefixCoded(upper), true, false);
       tTopDocs = searcher.search(tq, 1);
       cTopDocs = searcher.search(cq, 1);
@@ -314,19 +314,19 @@ public class TestNumericRangeQuery64 extends LuceneTestCase {
         long a=lower; lower=upper; upper=a;
       }
       // test inclusive range
-      Query tq=NumericRangeQuery.newLongRange(field, precisionStep, new Long(lower), new Long(upper), true, true);
+      Query tq=NumericRangeQuery.newLongRange(field, precisionStep, lower, upper, true, true);
       TopDocs tTopDocs = searcher.search(tq, 1);
       assertEquals("Returned count of range query must be equal to inclusive range length", upper-lower+1, tTopDocs.totalHits );
       // test exclusive range
-      tq=NumericRangeQuery.newLongRange(field, precisionStep, new Long(lower), new Long(upper), false, false);
+      tq=NumericRangeQuery.newLongRange(field, precisionStep, lower, upper, false, false);
       tTopDocs = searcher.search(tq, 1);
       assertEquals("Returned count of range query must be equal to exclusive range length", Math.max(upper-lower-1, 0), tTopDocs.totalHits );
       // test left exclusive range
-      tq=NumericRangeQuery.newLongRange(field, precisionStep, new Long(lower), new Long(upper), false, true);
+      tq=NumericRangeQuery.newLongRange(field, precisionStep, lower, upper, false, true);
       tTopDocs = searcher.search(tq, 1);
       assertEquals("Returned count of range query must be equal to half exclusive range length", upper-lower, tTopDocs.totalHits );
       // test right exclusive range
-      tq=NumericRangeQuery.newLongRange(field, precisionStep, new Long(lower), new Long(upper), true, false);
+      tq=NumericRangeQuery.newLongRange(field, precisionStep, lower, upper, true, false);
       tTopDocs = searcher.search(tq, 1);
       assertEquals("Returned count of range query must be equal to half exclusive range length", upper-lower, tTopDocs.totalHits );
     }
@@ -354,12 +354,12 @@ public class TestNumericRangeQuery64 extends LuceneTestCase {
     final long lower=-1000L, upper=+2000L;
     
     Query tq=NumericRangeQuery.newDoubleRange(field, precisionStep,
-      new Double(NumericUtils.sortableLongToDouble(lower)), new Double(NumericUtils.sortableLongToDouble(upper)), true, true);
+      NumericUtils.sortableLongToDouble(lower), NumericUtils.sortableLongToDouble(upper), true, true);
     TopDocs tTopDocs = searcher.search(tq, 1);
     assertEquals("Returned count of range query must be equal to inclusive range length", upper-lower+1, tTopDocs.totalHits );
     
     Filter tf=NumericRangeFilter.newDoubleRange(field, precisionStep,
-      new Double(NumericUtils.sortableLongToDouble(lower)), new Double(NumericUtils.sortableLongToDouble(upper)), true, true);
+      NumericUtils.sortableLongToDouble(lower), NumericUtils.sortableLongToDouble(upper), true, true);
     tTopDocs = searcher.search(new MatchAllDocsQuery(), tf, 1);
     assertEquals("Returned count of range filter must be equal to inclusive range length", upper-lower+1, tTopDocs.totalHits );
   }
@@ -391,7 +391,7 @@ public class TestNumericRangeQuery64 extends LuceneTestCase {
       if (lower>upper) {
         long a=lower; lower=upper; upper=a;
       }
-      Query tq=NumericRangeQuery.newLongRange(field, precisionStep, new Long(lower), new Long(upper), true, true);
+      Query tq=NumericRangeQuery.newLongRange(field, precisionStep, lower, upper, true, true);
       TopDocs topDocs = searcher.search(tq, null, noDocs, new Sort(new SortField(field, SortField.LONG, true)));
       if (topDocs.totalHits==0) continue;
       ScoreDoc[] sd = topDocs.scoreDocs;
@@ -422,36 +422,36 @@ public class TestNumericRangeQuery64 extends LuceneTestCase {
   }
   
   public void testEqualsAndHash() throws Exception {
-    QueryUtils.checkHashEquals(NumericRangeQuery.newLongRange("test1", 4, new Long(10L), new Long(20L), true, true));
-    QueryUtils.checkHashEquals(NumericRangeQuery.newLongRange("test2", 4, new Long(10L), new Long(20L), false, true));
-    QueryUtils.checkHashEquals(NumericRangeQuery.newLongRange("test3", 4, new Long(10L), new Long(20L), true, false));
-    QueryUtils.checkHashEquals(NumericRangeQuery.newLongRange("test4", 4, new Long(10L), new Long(20L), false, false));
-    QueryUtils.checkHashEquals(NumericRangeQuery.newLongRange("test5", 4, new Long(10L), null, true, true));
-    QueryUtils.checkHashEquals(NumericRangeQuery.newLongRange("test6", 4, null, new Long(20L), true, true));
+    QueryUtils.checkHashEquals(NumericRangeQuery.newLongRange("test1", 4, 10L, 20L, true, true));
+    QueryUtils.checkHashEquals(NumericRangeQuery.newLongRange("test2", 4, 10L, 20L, false, true));
+    QueryUtils.checkHashEquals(NumericRangeQuery.newLongRange("test3", 4, 10L, 20L, true, false));
+    QueryUtils.checkHashEquals(NumericRangeQuery.newLongRange("test4", 4, 10L, 20L, false, false));
+    QueryUtils.checkHashEquals(NumericRangeQuery.newLongRange("test5", 4, 10L, null, true, true));
+    QueryUtils.checkHashEquals(NumericRangeQuery.newLongRange("test6", 4, null, 20L, true, true));
     QueryUtils.checkHashEquals(NumericRangeQuery.newLongRange("test7", 4, null, null, true, true));
     QueryUtils.checkEqual(
-      NumericRangeQuery.newLongRange("test8", 4, new Long(10L), new Long(20L), true, true), 
-      NumericRangeQuery.newLongRange("test8", 4, new Long(10L), new Long(20L), true, true)
+      NumericRangeQuery.newLongRange("test8", 4, 10L, 20L, true, true), 
+      NumericRangeQuery.newLongRange("test8", 4, 10L, 20L, true, true)
     );
     QueryUtils.checkUnequal(
-      NumericRangeQuery.newLongRange("test9", 4, new Long(10L), new Long(20L), true, true), 
-      NumericRangeQuery.newLongRange("test9", 8, new Long(10L), new Long(20L), true, true)
+      NumericRangeQuery.newLongRange("test9", 4, 10L, 20L, true, true), 
+      NumericRangeQuery.newLongRange("test9", 8, 10L, 20L, true, true)
     );
     QueryUtils.checkUnequal(
-      NumericRangeQuery.newLongRange("test10a", 4, new Long(10L), new Long(20L), true, true), 
-      NumericRangeQuery.newLongRange("test10b", 4, new Long(10L), new Long(20L), true, true)
+      NumericRangeQuery.newLongRange("test10a", 4, 10L, 20L, true, true), 
+      NumericRangeQuery.newLongRange("test10b", 4, 10L, 20L, true, true)
     );
     QueryUtils.checkUnequal(
-      NumericRangeQuery.newLongRange("test11", 4, new Long(10L), new Long(20L), true, true), 
-      NumericRangeQuery.newLongRange("test11", 4, new Long(20L), new Long(10L), true, true)
+      NumericRangeQuery.newLongRange("test11", 4, 10L, 20L, true, true), 
+      NumericRangeQuery.newLongRange("test11", 4, 20L, 10L, true, true)
     );
     QueryUtils.checkUnequal(
-      NumericRangeQuery.newLongRange("test12", 4, new Long(10L), new Long(20L), true, true), 
-      NumericRangeQuery.newLongRange("test12", 4, new Long(10L), new Long(20L), false, true)
+      NumericRangeQuery.newLongRange("test12", 4, 10L, 20L, true, true), 
+      NumericRangeQuery.newLongRange("test12", 4, 10L, 20L, false, true)
     );
     QueryUtils.checkUnequal(
-      NumericRangeQuery.newLongRange("test13", 4, new Long(10L), new Long(20L), true, true), 
-      NumericRangeQuery.newFloatRange("test13", 4, new Float(10f), new Float(20f), true, true)
+      NumericRangeQuery.newLongRange("test13", 4, 10L, 20L, true, true), 
+      NumericRangeQuery.newFloatRange("test13", 4, 10f, 20f, true, true)
     );
      // difference to int range is tested in TestNumericRangeQuery32
   }

