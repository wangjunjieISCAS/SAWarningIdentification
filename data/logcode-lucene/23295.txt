GitDiffStart: 4374e2e88a9260080aa61a454ecca63eba142fe0 | Wed Dec 13 19:04:23 2006 +0000
diff --git a/contrib/gdata-server/build.xml b/contrib/gdata-server/build.xml
index 462f808..d568e4f 100644
--- a/contrib/gdata-server/build.xml
+++ b/contrib/gdata-server/build.xml
@@ -17,40 +17,51 @@
  
 -->
 
-<project name="gdata-server" default="default">
+<project name="gdata-server" default="compile-core">
 	<description>  
         Serverside Google Data API implementation  
     </description>
 	<import file="gdata-build/get-dependencies.xml" />
-	<import file="gdata-build/ioc-container.xml" />
-	<import file="gdata-build/gom-build.xml" />
 	<property name="javac.source" value="1.5" />
 	<property name="javac.target" value="1.5" />
-	<property name="gdata.war.name" value="gdata-server" />
+
 	<property name="gdata.lib.dir" value="lib" />
 	<property name="gdata.external.lib.dir" value="./ext-libs" />
-	<property name="db4o.jar" value="db4o-5.2-java5.jar" />
+	<property name="db4o.jar" value="db4o-5.5-java5.jar" />
+	<!-- properties for war task -->
+	<property name="ioc.descriptors.dir" value="./src/hivemind/descriptor" />
+	<property name="ioc.descriptors.excludes" value="" />
+	<property name="ioc.descriptors.includes" value="**/*.xml" />
+	
+	<property name="gdata.war.name" value="gdata-server" />
+	
+	<property name="jar.name.core" value="lucene-core-${version}" />
+	<property name="jar.name.gom" value="lucene-gom-${version}" />
+	<property name="jar.name.hivemind" value="lucene-hivemind-${version}" />
+
+	<fileset id="hivemind.jars" dir="${gdata.external.lib.dir}">
+		<include name="hivemind-1.1.jar" />
+		<include name="hivemind-jmx-1.1.jar" />
+		<include name="hivemind-lib-1.1.jar" />
+		<include name="javassist-3.0.jar" />
+		<include name="oro-2.0.6.jar" />
+		<include name="hessian-3.0.20.jar" />
+	</fileset>
+
+	<fileset id="gom.jars" dir="${gdata.external.lib.dir}">
+		<include name="stax-1.1.2-dev.jar" />
+		<include name="stax-api-1.0.1.jar" />
+	</fileset>
+
+
 	<!-- set property for third party jars -->
-	<available property="db4o.jar.present" type="file" file="${gdata.lib.dir}/${db4o.jar}" value="test" />
+	<available property="db4o.jar.present" type="file" file="${gdata.external.lib.dir}/${db4o.jar}" value="test" />
 	<condition property="junit.excludes" value="**/db4o/**/*.java">
 		<not>
 			<isset property="db4o.jar.present" />
 		</not>
 	</condition>
-	<path id="additional.dependencies">
-		<fileset dir="${gdata.lib.dir}">
-			<include name="servlet-api.jar" />
-			<include name="commons-logging-1.1.jar" />
-			<include name="gdata-client-1.0.jar" />
-			<include name="commons-digester-1.7.jar" />
-			<include name="commons-beanutils.jar" />
-			<include name="commons-collections-3.2.jar" />
-			<include name="nekohtml.jar" />
-			<include name="xercesImpl.jar" />
-			<include name="${db4o.jar}" if="db4o.jar.present" />
-		</fileset>
-	</path>
-	
+
 	<condition property="do.download">
 		<not>
 			<and>
@@ -65,74 +76,40 @@
 			</and>
 		</not>
 	</condition>
+	<target name="jar-core" description="Packages the JAR file">
+		<ant dir="src/core" target="jar-core" inheritRefs="true" />
+		<ant dir="src/hivemind" target="jar-core" inheritRefs="true" />
+		<ant dir="src/gom" target="jar-core" inheritRefs="true" />
+	</target>
 
 
-	<!-- redefine compile-core and compile-test to exclude 3rd party dependend sources -->
-	<target name="compile-core" depends="init, download">
-		<echo>Use gdata - compile-core task </echo>
-		<compile srcdir="src/core/java" destdir="${build.dir}/classes/java">
-			<classpath>
-				<path refid="classpath"/>
-				<path refid="build.path"/>
-			</classpath>
-			<exclude name="org/apache/lucene/gdata/storage/db4o/**" unless="db4o.jar.present" />
-		</compile>
-		<antcall target="compile-IoC-container"/>
-		<antcall target="compile-gom"/>
+	<target name="test">
+		<ant dir="src/core" target="test" inheritRefs="true" />
+		<ant dir="src/gom" target="test" inheritRefs="true" />
+		<ant dir="src/hivemind" target="test" inheritRefs="true" />
+	</target>
+	
+	<target name="compile-core" depends="download">
+		<ant dir="src/core" target="compile-core" inheritRefs="true" />
+		<ant dir="src/hivemind" target="compile-core" inheritRefs="true" />
+		<ant dir="src/gom" target="compile-core" inheritRefs="true" />
 	</target>
 
 	<target name="compile-test" depends="compile-core, download">
-		<echo>Use gdata - compile-test task </echo>
-		<compile srcdir="src/core/test" destdir="${build.dir}/classes/test">
-			<classpath>
-				<path refid="test.build.path"/>
-				<path refid="test.classpath"/>
-			</classpath>
-			<exclude name="org/apache/lucene/gdata/storage/db4o/**" unless="db4o.jar.present" />
-		</compile>
-		<copy todir="${build.dir}/classes/core/test">
-			<fileset dir="src/test" excludes="**/*.java" />
-		</copy>
-		<antcall target="compile-IoC-container-test"/>
-		<antcall target="compile-gom-test"/>
+		<ant dir="src/core" target="compile-test" inheritRefs="true" />
+		<ant dir="src/hivemind" target="compile-test" inheritRefs="true" />
+		<ant dir="src/gom" target="compile-test" inheritRefs="true" />
 	</target>
 
-	<pathconvert property="project.classpath" targetos="unix" refid="additional.dependencies" />
-	<import file="../contrib-build.xml" />
-
-	<target name="prepare-dist" depends="jar-core,jar-IoC-container,jar-gom">
-		<echo>Prepare dist directory</echo>
-		<delete dir="${dist.dir}" />
-		<mkdir dir="${dist.dir}" />
+	<target name="clean">
+		<ant dir="src/core" target="clean" inheritRefs="true" />
+		<ant dir="src/hivemind" target="clean" inheritRefs="true" />
+		<ant dir="src/gom" target="clean" inheritRefs="true" />
 	</target>
 
-	<target name="war-gdata" depends="prepare-dist,download">
-		<echo>Distributing GData War </echo>
-		<war destfile="${dist.dir}/${gdata.war.name}.war" webxml="webroot/WEB-INF/web.xml">
-			<metainf dir="webroot/meta-inf" />
-			<fileset dir="webroot" defaultexcludes="true">
-				<exclude name="meta-inf/context.xml" />
-				<exclude name="meta-inf/" />
-				<exclude name="WEB-INF/web.xml" />
-			</fileset>
-			<fileset dir="${ioc.descriptors.dir}" excludes="${ioc.descriptors.excludes}" includes="${ioc.descriptors.includes}"/>
-			<lib dir="${gdata.lib.dir}">
-				<include name="commons-logging-1.1.jar" />
-				<include name="gdata-client-1.0.jar" />
-				<include name="commons-digester-1.7.jar" />
-				<include name="commons-beanutils.jar" />
-				<include name="commons-collections-3.2.jar" />
-				<include name="nekohtml.jar" />
-				<include name="xercesImpl.jar" />
-				<include name="${db4o.jar}" if="db4o.jar.present" />
-			</lib>
-			<lib refid="ioc-container-jars"/>
-			<lib refid="gom-jars"/>
-			<lib dir="${build.dir}" includes="${final.name}.jar" />
-			<lib dir="${build.dir}" includes="${final.name}${ioc.container.jar.suffix}" />
-			<lib dir="${build.dir}" includes="${final.name}${gom.jar.suffix}" />
-			<lib file="${lucene.jar}" />
-		</war>
+	<target name="war-gdata" depends="clean,jar-core">
+		<ant dir="src/core" target="war-gdata" inheritRefs="true" />
 	</target>
 
+
 </project>
\ No newline at end of file
diff --git a/contrib/gdata-server/gdata-build/gom-build.xml b/contrib/gdata-server/gdata-build/gom-build.xml
deleted file mode 100644
index d00ac01..0000000
--- a/contrib/gdata-server/gdata-build/gom-build.xml
+++ /dev/null
@@ -1,86 +0,0 @@
-<?xml version="1.0"?>
-<!-- 
-  Licensed to the Apache Software Foundation (ASF) under one or more
-  contributor license agreements.  See the NOTICE file distributed with
-  this work for additional information regarding copyright ownership.
-  The ASF licenses this file to You under the Apache License, Version 2.0
-  (the "License"); you may not use this file except in compliance with
-  the License.  You may obtain a copy of the License at
- 
-      http://www.apache.org/licenses/LICENSE-2.0
- 
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
- 
--->
-<project name="gdata-server-gom" >
-<property name="gom.jar.suffix" value="-gom.jar"/>
-	<description>  
-       Compiles and Jars the gom dependencies for gdata-server
-    </description>
-    <target name="prepare-gom">
-    	<available file="${build.dir}/${final.name}.jar" property="gdata.core.jar.present"/>
-		<fail if="${gdata.core.jar.present}" message="Must gdata core jar first. run build.xml - 'jar-core' task"/>
-		<path id="gom.build.path">
-	    	<fileset id="gom-jars" dir="${gdata.external.lib.dir}">
-	   			<include name="stax-1.1.2-dev.jar"/>
-	   			<include name="stax-api-1.0.1.jar"/>
-	   		</fileset>
-		</path>
-    	<path id="gom.test.path">
-    		<pathelement location="${build.dir}/classes/gom/java"/>
-    	</path>
-	</target>
-	
-	
-	<target name="compile-gom" depends="prepare-gom">
-		<echo>Compile GData object model classes</echo>
-		<compile srcdir="src/gom/java" destdir="${build.dir}/classes/gom/java">
-			<classpath>
-				<path refid="gom.build.path"/>				
-			</classpath>
-		</compile>
-	</target>
-	
-	<target name="compile-gom-test" depends="compile-gom">
-		<echo>Compile GData object model test classes </echo>
-		<compile srcdir="src/gom/test" destdir="${build.dir}/classes/test">
-			<classpath>
-				<path refid="test.build.path"/>
-				<path refid="gom.test.path"/>
-				<path refid="gom.build.path"/>		
-			</classpath>
-		</compile>
-		<copy todir="${build.dir}/classes/test">
-			<fileset dir="src/gom/test" excludes="**/*.java" />
-		</copy>
-	</target>
-	
-
-	<target name="jar-gom" depends="compile-gom">
-		<echo>Jar GOM classes and metadata</echo>
-		<jar
-	      destfile="${build.dir}/${final.name}${gom.jar.suffix}"
-	      basedir="${build.dir}/classes/gom/java">
-	      <manifest>
-	        <attribute name="Created-By" value="Apache Jakarta"/>
-	        <section name="org/apache/lucene/">
-	            <attribute name="Specification-Title" value="Lucene GData Object Model"/>
-	   	          <attribute name="Specification-Version" value="${version}"/>
-	   	          <attribute name="Specification-Vendor" value="Lucene GData Server"/>
-	   	          <attribute name="Implementation-Title" value="org.apache.lucene.gdata"/>
-	   	          <attribute name="Implementation-Version" value="build ${DSTAMP}"/>
-	   	          <attribute name="Implementation-Vendor" value="Lucene"/>
-	        </section>
-	      </manifest>
-	    </jar>
-	</target>
-	
-	
-	
-
-
-</project>
\ No newline at end of file
diff --git a/contrib/gdata-server/gdata-build/hivemind-build.xml b/contrib/gdata-server/gdata-build/hivemind-build.xml
deleted file mode 100644
index f8ba819..0000000
--- a/contrib/gdata-server/gdata-build/hivemind-build.xml
+++ /dev/null
@@ -1,97 +0,0 @@
-<?xml version="1.0"?>
-<!-- 
-  Licensed to the Apache Software Foundation (ASF) under one or more
-  contributor license agreements.  See the NOTICE file distributed with
-  this work for additional information regarding copyright ownership.
-  The ASF licenses this file to You under the Apache License, Version 2.0
-  (the "License"); you may not use this file except in compliance with
-  the License.  You may obtain a copy of the License at
- 
-      http://www.apache.org/licenses/LICENSE-2.0
- 
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
- 
--->
-<project name="gdata-server-hivemind" >
-<property name="ioc.container.jar.suffix" value="-hivemind.jar"/>
-<property name="ioc.descriptors.dir" value="./src/hivemind/descriptor"/>
-<property name="ioc.descriptors.excludes" value=""/>
-<property name="ioc.descriptors.includes" value="**/*.xml"/>
-	<description>  
-       Compiles and Jars the hivemind dependencies for gdata-server
-    </description>
-    <target name="prepare-IoC-container">
-    	<available file="${build.dir}/${final.name}.jar" property="gdata.core.jar.present"/>
-		<fail if="${gdata.core.jar.present}" message="Must gdata core jar first. run build.xml - 'jar-core' task"/>
-		<path id="IoC.container.build.path">
-	    	<fileset dir="${build.dir}">
-	   			<include name="${final.name}.jar"/>
-	   		</fileset>
-		</path>
-    	<path id="IoC.container.test.path">
-    		<pathelement location="${build.dir}/classes/hivemind/java"/>
-    	</path>
-    	<fileset id="ioc-container-jars" dir="${gdata.external.lib.dir}">
-			<include name="hivemind-1.1.jar" />
-			<include name="hivemind-jmx-1.1.jar" />
-			<include name="hivemind-lib-1.1.jar" />				
-			<include name="javassist-3.0.jar"/>
-			<include name="oro-2.0.6.jar"/>
-			<include name="hessian-3.0.20.jar"/>
-   		</fileset>
-	</target>
-	<!-- redefine compile-core and compile-test to exclude 3rd party dependend sources -->
-	<target name="compile-IoC-container" depends="prepare-IoC-container">
-		<echo>Compile IoC Container classes</echo>
-		<compile srcdir="src/hivemind/java" destdir="${build.dir}/classes/hivemind/java">
-			<classpath>
-				<path refid="classpath"/>
-				<path refid="build.path"/>
-				<path refid="IoC.container.build.path"/>				
-			</classpath>
-		</compile>
-	</target>
-	
-	<target name="compile-IoC-container-test" depends="compile-IoC-container">
-		<echo>Compile IoC Container test classes </echo>
-		<compile srcdir="src/hivemind/test" destdir="${build.dir}/classes/test">
-			<classpath>
-				<path refid="test.build.path"/>
-				<path refid="test.classpath"/>
-				<path refid="IoC.container.test.path"/>
-			</classpath>
-		</compile>
-		<copy todir="${build.dir}/classes/test">
-			<fileset dir="src/hivemind/test" excludes="**/*.java" />
-		</copy>
-	</target>
-	
-
-	<target name="jar-IoC-container" depends="compile-IoC-container">
-		<echo>Jar IoC Container classes and metadata</echo>
-		<jar
-	      destfile="${build.dir}/${final.name}${ioc.container.jar.suffix}"
-	      basedir="${build.dir}/classes/hivemind/java">
-	      <manifest>
-	        <attribute name="Created-By" value="Apache Jakarta"/>
-	        <section name="org/apache/lucene/">
-	          <attribute name="Specification-Title" value="Lucene GData IoC Container"/>
-	          <attribute name="Specification-Version" value="${version}"/>
-	          <attribute name="Specification-Vendor" value="Lucene GData Server"/>
-	          <attribute name="Implementation-Title" value="org.apache.lucene.gdata"/>
-	          <attribute name="Implementation-Version" value="build ${DSTAMP}"/>
-	          <attribute name="Implementation-Vendor" value="Lucene"/>
-	        </section>
-	      </manifest>
-	    </jar>
-	</target>
-	
-	
-	
-
-
-</project>
\ No newline at end of file
diff --git a/contrib/gdata-server/gdata-build/ioc-container.xml b/contrib/gdata-server/gdata-build/ioc-container.xml
deleted file mode 100644
index 17f28a7..0000000
--- a/contrib/gdata-server/gdata-build/ioc-container.xml
+++ /dev/null
@@ -1,22 +0,0 @@
-<?xml version="1.0"?>
-<!-- 
-  Licensed to the Apache Software Foundation (ASF) under one or more
-  contributor license agreements.  See the NOTICE file distributed with
-  this work for additional information regarding copyright ownership.
-  The ASF licenses this file to You under the Apache License, Version 2.0
-  (the "License"); you may not use this file except in compliance with
-  the License.  You may obtain a copy of the License at
- 
-      http://www.apache.org/licenses/LICENSE-2.0
- 
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
- 
--->
-<project name="gdata-ioc-container">
-	<!-- specify your IOC container build file here -->
-	<import file="hivemind-build.xml"/>
-</project>
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/build.xml b/contrib/gdata-server/src/core/build.xml
new file mode 100644
index 0000000..f3dd898
--- /dev/null
+++ b/contrib/gdata-server/src/core/build.xml
@@ -0,0 +1,78 @@
+<?xml version="1.0"?>
+<!-- 
+  Licensed to the Apache Software Foundation (ASF) under one or more
+  contributor license agreements.  See the NOTICE file distributed with
+  this work for additional information regarding copyright ownership.
+  The ASF licenses this file to You under the Apache License, Version 2.0
+  (the "License"); you may not use this file except in compliance with
+  the License.  You may obtain a copy of the License at
+ 
+      http://www.apache.org/licenses/LICENSE-2.0
+ 
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+ 
+-->
+<project name="gdata-core" default="default">
+
+	<description>
+		Lucene gdata server core build file
+	</description>
+	
+	<path id="additional.dependencies">
+			<fileset dir="../../${gdata.lib.dir}">
+				<include name="servlet-api.jar" />
+				<include name="commons-logging-1.1.jar" />
+				<include name="gdata-client-1.0.jar" />
+				<include name="commons-digester-1.7.jar" />
+				<include name="commons-beanutils.jar" />
+				<include name="commons-collections-3.2.jar" />
+				<include name="nekohtml.jar" />
+				<include name="xercesImpl.jar" />
+			</fileset>
+			<fileset dir="../../${gdata.external.lib.dir}">
+				<include name="easymock-1.2_Java1.5.jar" />
+				<include name="${db4o.jar}" if="db4o.jar.present" />
+			</fileset>
+		</path>
+	<property name="build.dir" location="../../../build/contrib/gdata-server/core" />
+	<property name="dist.dir" location="../../../dist/contrib/gdata-server/core" />
+
+	<pathconvert property="project.classpath" targetos="unix" refid="additional.dependencies" />
+	<import file="../../../contrib-build.xml" />
+
+
+
+	<target name="war-gdata" depends="jar-core">
+		<echo>Distributing GData War </echo>
+		<war destfile="${build.dir}/${gdata.war.name}.war" webxml="../../webroot/WEB-INF/web.xml">
+			<metainf dir="../../webroot/meta-inf" />
+			<fileset dir="../../webroot" defaultexcludes="true">
+				<exclude name="meta-inf/context.xml" />
+				<exclude name="meta-inf/" />
+				<exclude name="WEB-INF/web.xml" />
+			</fileset>
+			<fileset dir="../../${ioc.descriptors.dir}" excludes="${ioc.descriptors.excludes}" includes="${ioc.descriptors.includes}" />
+			<lib dir="../../${gdata.lib.dir}">
+				<include name="commons-logging-1.1.jar" />
+				<include name="gdata-client-1.0.jar" />
+				<include name="commons-digester-1.7.jar" />
+				<include name="commons-beanutils.jar" />
+				<include name="commons-collections-3.2.jar" />
+				<include name="nekohtml.jar" />
+				<include name="xercesImpl.jar" />
+				<include name="${db4o.jar}" if="db4o.jar.present" />
+			</lib>
+			<lib refid="hivemind.jars" />
+			<lib refid="gom.jars" />
+			<lib dir="${build.dir}" includes="${jar.name.core}.jar" />
+			<lib dir="${build.dir}/../gom" includes="${jar.name.gom}.jar" />
+			<lib dir="${build.dir}/../hivemind" includes="${jar.name.hivemind}.jar" />
+			<lib file="${lucene.jar}" />
+		</war>
+	</target>
+
+</project>
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/data/GDataAccount.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/data/GDataAccount.java
deleted file mode 100644
index 4674fd8..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/data/GDataAccount.java
+++ /dev/null
@@ -1,340 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-
-package org.apache.lucene.gdata.data;
-
-import java.net.URL;
-import java.util.HashSet;
-import java.util.Set;
-
-import com.google.gdata.data.Person;
-
-/**
- * The GData-Server system provides acccount to be associated with registered
- * feed. Every feed has an owner account. The account holder is automaticaly in
- * role to modify his feeds. One account can own <i>n</i> feeds having <i>m</i>
- * entries.
- * <p>
- * Additionally an account can be in role to modify other feeds, create accounts
- * or feeds. See {@link AccountRole} for detailed infomation about roles. One
- * account can also have more than one role. All roles in {@link AccountRole}
- * can be combined
- * </p>
- * <p>
- * For each account values for author name, author email and author link can be
- * set at creation time or during an update. These values will be used as the
- * corresponding values for the feed
- * {@link org.apache.lucene.gdata.data.ServerBaseFeed#addAuthor(Person)} if no
- * value for the feed has be specified.
- * </p>
- * 
- * @author Simon Willnauer
- * 
- */
-public class GDataAccount {
-    private String name;
-
-    private String authorname;
-
-    private String authorMail;
-
-    private URL authorLink;
-
-    private String password;
-
-    private Set<AccountRole> roles = new HashSet<AccountRole>(4);
-
-    /**
-     * Creates a new GDataAccount. The default role {@link AccountRole#USER}
-     * will be set.
-     * 
-     */
-    public GDataAccount() {
-        this.roles.add(AccountRole.USER);
-
-    }
-
-    /**
-     * @return - the password
-     */
-    public String getPassword() {
-        return this.password;
-    }
-
-    /**
-     * @param password -
-     *            the account Password
-     */
-    public void setPassword(String password) {
-        this.password = password;
-    }
-
-    /**
-     * @return - the account name
-     */
-    public String getName() {
-        return this.name;
-    }
-
-    /**
-     * @param name
-     *            The name to set.
-     */
-    public void setName(String name) {
-        this.name = name;
-    }
-
-    /**
-     * @return - the http link specified for the author
-     */
-    public URL getAuthorLink() {
-        return this.authorLink;
-    }
-
-    /**
-     * @param authorLink -
-     *            the http link specified for the author
-     */
-    public void setAuthorLink(URL authorLink) {
-        this.authorLink = authorLink;
-    }
-
-    /**
-     * @return - the authors mail address
-     */
-    public String getAuthorMail() {
-        return this.authorMail;
-    }
-
-    /**
-     * @param authorMail -
-     *            the authors mail address
-     */
-    public void setAuthorMail(String authorMail) {
-        this.authorMail = authorMail;
-    }
-
-    /**
-     * @return - the name specified as being the author name
-     */
-    public String getAuthorname() {
-        return this.authorname;
-    }
-
-    /**
-     * @param authorname -
-     *            the name specified as being the author name
-     */
-    public void setAuthorname(String authorname) {
-        this.authorname = authorname;
-    }
-
-    /**
-     * Adds the given role to the role list
-     * 
-     * @param role -
-     *            the role to add to the role list
-     */
-    public void setRole(AccountRole role) {
-        if (role == null)
-            return;
-        this.roles.add(role);
-    }
-
-    /**
-     * @return - the set containing all roles
-     */
-    public Set<AccountRole> getRoles() {
-        return this.roles;
-    }
-
-    /**
-     * @param role -
-     *            the role to check
-     * @return <code>true</code> if the role list contains the given role
-     */
-    public boolean isUserInRole(AccountRole role) {
-        if (role == null)
-            return false;
-        return this.roles.contains(role);
-    }
-
-    /**
-     * @see GDataAccount#setRolesAsInt(int)
-     * @return - the integer representation for the user roles
-     */
-    public int getRolesAsInt() {
-        // 1 as the Userrole is always set
-        int bits = 1;
-        for (AccountRole role : this.roles) {
-            if (role == AccountRole.ENTRYAMINISTRATOR)
-                bits ^= 2;
-            else if (role == AccountRole.FEEDAMINISTRATOR)
-                bits ^= 4;
-            else if (role == AccountRole.USERADMINISTRATOR)
-                bits ^= 8;
-
-        }
-        return bits;
-
-    }
-
-    /**
-     * Sets the roles from a int representation.
-     * <ol>
-     * <li>The fist bit set indicates a {@link AccountRole#USER} - int value 1</li>
-     * <li>The second bit set indicates a {@link AccountRole#ENTRYAMINISTRATOR} -
-     * int value 2</li>
-     * <li>The third bit set indicates a {@link AccountRole#FEEDAMINISTRATOR} -
-     * int value 4</li>
-     * <li>The forth bit set indicates a {@link AccountRole#USERADMINISTRATOR} -
-     * int value 8</li>
-     * <ol>
-     * This method will only set roles, will not remove roles! A combination of
-     * roles is also possible e.g. the int value 6 combines
-     * {@link AccountRole#ENTRYAMINISTRATOR} and
-     * {@link AccountRole#FEEDAMINISTRATOR}.
-     * 
-     * @param i -
-     *            the integer used to set the roles
-     */
-    public void setRolesAsInt(int i) {
-
-        if ((i & 2) > 0)
-            this.roles.add(AccountRole.ENTRYAMINISTRATOR);
-        if ((i & 4) > 0)
-            this.roles.add(AccountRole.FEEDAMINISTRATOR);
-        if ((i & 8) > 0)
-            this.roles.add(AccountRole.USERADMINISTRATOR);
-
-    }
-
-    /**
-     * @see java.lang.Object#equals(java.lang.Object)
-     */
-    public boolean equals(Object o) {
-        if(this.name == null)
-            return super.equals(o);
-        if(o == null)
-            return false;
-        if (this == o)
-            return true;
-        if (!(o instanceof GDataAccount))
-            return false;
-        GDataAccount toCompare = (GDataAccount) o;
-        if (this.name.equals(toCompare.name))
-            return true;
-        return false;
-
-    }
-
-    /**
-     * @see java.lang.Object#hashCode()
-     */
-    public int hashCode() {
-        if(this.name == null)
-            return super.hashCode();
-        int ret = 37;
-        ret = 9 * ret + this.name.hashCode();
-        return ret;
-    }
-
-    /**
-     * Checks the requiered values for creating an account are set. Required
-     * values are <tt>name</tt> and <tt>password</tt> the minimum length of
-     * these values is 6.
-     * 
-     * @return <code>true</code> if an only if password and name are not <code>null</code> and the length is <tt>> 5</tt>
-     */
-    public boolean requiredValuesSet() {
-        return (this.name != null && this.password != null
-                && this.name.length() > 5 && this.password.length() > 5);
-    }
-    
-    /**
-     * @see java.lang.Object#toString()
-     */
-    public String toString(){
-        StringBuilder builder = new StringBuilder("GdataAccount: ");
-        builder.append("name: ").append(this.name);
-        builder.append(" password: ").append((this.password!= null?" length: "+this.password.length():null));
-        builder.append(" author: ").append(this.authorname);
-        builder.append(" author email: ").append(this.authorMail);
-        builder.append(" author link: ").append(this.authorLink!=null?"":this.authorLink);
-        return builder.toString();
-    }
-    
-    /**
-     * checks whether the given integer matches the account role.
-     * @param intRole - integer representation of a role
-     * @param role - the account role to match
-     * @return <code>true</code> if and only if the given roles match, otherwise <code>false</code>
-     */
-    public static boolean isInRole(int intRole, AccountRole role){
-        if(role == AccountRole.USER)
-            return (intRole&1)>0;
-        if (role == AccountRole.ENTRYAMINISTRATOR)
-            return (intRole&2) >0 ;
-        else if (role == AccountRole.FEEDAMINISTRATOR)
-            return (intRole&4) >0 ;
-        else if (role == AccountRole.USERADMINISTRATOR)
-            return (intRole&8) >0 ;
-        return false;
-    }
-    
-    /**
-     * @return - a new Administrator account 
-     */
-    public static final GDataAccount createAdminAccount(){
-        GDataAccount retVal = new GDataAccount();
-        retVal.setName("administrator");
-        retVal.setPassword("password");
-        retVal.setRole(AccountRole.USERADMINISTRATOR);
-        retVal.setRole(AccountRole.FEEDAMINISTRATOR);
-        retVal.setRole(AccountRole.ENTRYAMINISTRATOR);
-        return retVal;
-    }
-    
-
-
-    /**
-     * This enum respesents all account roles an account can have.
-     * 
-     * @author Simon Willnauer
-     * 
-     */
-    public enum AccountRole {
-
-        /**
-         * Can create / alter user
-         */
-        USERADMINISTRATOR,
-
-        /**
-         * Can create / alter feeds
-         */
-        FEEDAMINISTRATOR,
-        /**
-         * Can create / alter entries
-         */
-        ENTRYAMINISTRATOR,
-        /**
-         * can create / alter his own feed entries
-         */
-        USER
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/data/ServerBaseEntry.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/data/ServerBaseEntry.java
deleted file mode 100644
index 1f983c2..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/data/ServerBaseEntry.java
+++ /dev/null
@@ -1,642 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.data;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.Reader;
-import java.util.List;
-import java.util.Set;
-
-import org.apache.lucene.gdata.server.registry.ProvidedService;
-
-import com.google.gdata.client.Service;
-import com.google.gdata.data.BaseEntry;
-import com.google.gdata.data.Content;
-import com.google.gdata.data.DateTime;
-import com.google.gdata.data.Entry;
-import com.google.gdata.data.Extension;
-import com.google.gdata.data.ExtensionProfile;
-import com.google.gdata.data.Link;
-import com.google.gdata.data.Source;
-import com.google.gdata.data.TextConstruct;
-import com.google.gdata.util.ParseException;
-import com.google.gdata.util.ServiceException;
-import com.google.gdata.util.XmlBlob;
-import com.google.gdata.util.common.xml.XmlWriter;
-
-/**
- * The GData-Server uses the GDATA-Client API for an interal representation of
- * entries. These entities have dynamic elements like Links being generated
- * using the requested URL.<br/> Some components of the server also need
- * additional infomation like the service type
- * {@link org.apache.lucene.gdata.server.registry.ProvidedService} of the entry
- * and the feedid a entry belongs to. All these information are
- * encapsulated in the ServerBaseEntry decorating a concrete sub class of <tt>BaseEntry</tt>. The actual
- * {@link com.google.gdata.data.BaseEntry} will be passed to the ServerBaseEntry
- * at creation time via the constructor. To use the ServerBaseFeed for generation a provided format like
- * RSS/ATOM the corresponding {@link com.google.gdata.data.ExtensionProfile} has
- * to be provided to the generation method.
- * <p> For a general overview of the generic BaseFeed class see the gdata-client API documentation</p>
- * 
- * @see com.google.gdata.data.ExtensionProfile
- * @see com.google.gdata.data.BaseFeed
- * 
- * @author Simon Willnauer
- * 
- */
-public class ServerBaseEntry {
-    private String feedId;
-
-    private String serviceType;
-
-    private ProvidedService serviceConfig;
-    private BaseEntry entry;
-    private static final int DEFAULTVERSION = 1;
-    private int version;
-
-    
-   
-    /**
-     * @return - the provided service for the source entry 
-     */
-    public ProvidedService getServiceConfig() {
-        return this.serviceConfig;
-    }
-
-    /**
-     * @param serviceConfig - the provided service for the source entry
-     */
-    public void setServiceConfig(ProvidedService serviceConfig) {
-        this.serviceConfig = serviceConfig;
-        if (serviceConfig != null)
-            this.serviceType = serviceConfig.getName();
-    }
-
-    /**
-     * @return - the name of the service related of the feed containing this entry
-     */
-    public String getServiceType() {
-        return this.serviceType;
-    }
-
-    /**
-     *  Constructs a new ServerBaseEntry.
-     *  To provide a concrete entry to decorate after object creation use {@link ServerBaseEntry#setEntry(BaseEntry)}  
-     *  
-     */
-    @SuppressWarnings("unchecked")
-    public ServerBaseEntry() {
-        this(new Entry());
-        
-    }
-
-    /**
-     * @param arg0 - the source entry
-     */
-    @SuppressWarnings("unchecked")
-    public ServerBaseEntry(BaseEntry arg0) {
-        this.entry = arg0;
-        this.setVersion(DEFAULTVERSION);
-    }
-
-
-    /**
-     * @param link - a link added to this entry
-     */
-    @SuppressWarnings("unchecked")
-    public void addLink(final Link link) {
-        this.entry.getLinks().add(link);
-    }
-
-    /**
-     * @return - the id of the owning feed
-     */
-    public String getFeedId() {
-        return this.feedId;
-    }
-
-    /**
-     * @param feedId - the id of the owning feed
-     */
-    public void setFeedId(String feedId) {
-        this.feedId = feedId;
-    }
-    /**
-     * @return - the decorated entry
-     */
-    public BaseEntry getEntry(){
-        return this.entry;
-    }
-    /**
-     * @param entry - the entry to decorate
-     */
-    public void setEntry(BaseEntry entry){
-        this.entry = entry;
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#addHtmlLink(java.lang.String, java.lang.String, java.lang.String)
-     */
-    public void addHtmlLink(String arg0, String arg1, String arg2) {
-        
-        this.entry.addHtmlLink(arg0, arg1, arg2);
-    }
-
-
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#generateAtom(com.google.gdata.util.common.xml.XmlWriter, com.google.gdata.data.ExtensionProfile)
-     */
-    
-    public void generateAtom(XmlWriter arg0, ExtensionProfile arg1) throws IOException {
-        
-        this.entry.generateAtom(arg0, arg1);
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#generateRss(com.google.gdata.util.common.xml.XmlWriter, com.google.gdata.data.ExtensionProfile)
-     */
-    
-    public void generateRss(XmlWriter arg0, ExtensionProfile arg1) throws IOException {
-        
-        this.entry.generateRss(arg0, arg1);
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#getAuthors()
-     */
-    
-    public List getAuthors() {
-        
-        return this.entry.getAuthors();
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#getCanEdit()
-     */
-    
-    public boolean getCanEdit() {
-        
-        return this.entry.getCanEdit();
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#getCategories()
-     */
-    
-    public Set getCategories() {
-        
-        return this.entry.getCategories();
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#getContent()
-     */
-    
-    public Content getContent() {
-        
-        return this.entry.getContent();
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#getContributors()
-     */
-    
-    public List getContributors() {
-        
-        return this.entry.getContributors();
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#getEditLink()
-     */
-    
-    public Link getEditLink() {
-        
-        return this.entry.getEditLink();
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#getHtmlLink()
-     */
-    
-    public Link getHtmlLink() {
-        
-        return this.entry.getHtmlLink();
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#getId()
-     */
-    
-    public String getId() {
-        
-        return this.entry.getId();
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#getLink(java.lang.String, java.lang.String)
-     */
-    
-    public Link getLink(String arg0, String arg1) {
-        
-        return this.entry.getLink(arg0, arg1);
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#getLinks()
-     */
-    
-    public List getLinks() {
-        
-        return this.entry.getLinks();
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#getPublished()
-     */
-    
-    public DateTime getPublished() {
-        
-        return this.entry.getPublished();
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#getRights()
-     */
-    
-    public TextConstruct getRights() {
-        
-        return this.entry.getRights();
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#getSelf()
-     */
-    
-    public BaseEntry getSelf() throws IOException, ServiceException {
-        
-        return this.entry.getSelf();
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#getSelfLink()
-     */
-    
-    public Link getSelfLink() {
-        
-        return this.entry.getSelfLink();
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#getService()
-     */
-    
-    public Service getService() {
-        
-        return this.entry.getService();
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#getSource()
-     */
-    
-    public Source getSource() {
-        
-        return this.entry.getSource();
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#getSummary()
-     */
-    
-    public TextConstruct getSummary() {
-        
-        return this.entry.getSummary();
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#getTitle()
-     */
-    
-    public TextConstruct getTitle() {
-        
-        return this.entry.getTitle();
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#getUpdated()
-     */
-    
-    public DateTime getUpdated() {
-        
-        return this.entry.getUpdated();
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#getVersionId()
-     */
-    
-    public String getVersionId() {
-        
-        return this.entry.getVersionId();
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#isDraft()
-     */
-    
-    public boolean isDraft() {
-        
-        return this.entry.isDraft();
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#parseAtom(com.google.gdata.data.ExtensionProfile, java.io.InputStream)
-     */
-    
-    public void parseAtom(ExtensionProfile arg0, InputStream arg1) throws IOException, ParseException {
-        
-        this.entry.parseAtom(arg0, arg1);
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#parseAtom(com.google.gdata.data.ExtensionProfile, java.io.Reader)
-     */
-    
-    public void parseAtom(ExtensionProfile arg0, Reader arg1) throws IOException, ParseException {
-        
-        this.entry.parseAtom(arg0, arg1);
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#setCanEdit(boolean)
-     */
-    
-    public void setCanEdit(boolean arg0) {
-        
-        this.entry.setCanEdit(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#setContent(com.google.gdata.data.Content)
-     */
-    
-    public void setContent(Content arg0) {
-        
-        this.entry.setContent(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#setContent(com.google.gdata.data.TextConstruct)
-     */
-    
-    public void setContent(TextConstruct arg0) {
-        
-        this.entry.setContent(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#setDraft(boolean)
-     */
-    
-    public void setDraft(boolean arg0) {
-        
-        this.entry.setDraft(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#setId(java.lang.String)
-     */
-    
-    public void setId(String arg0) {
-        
-        this.entry.setId(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#setPublished(com.google.gdata.data.DateTime)
-     */
-    
-    public void setPublished(DateTime arg0) {
-        
-        this.entry.setPublished(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#setRights(com.google.gdata.data.TextConstruct)
-     */
-    
-    public void setRights(TextConstruct arg0) {
-        
-        this.entry.setRights(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#setService(com.google.gdata.client.Service)
-     */
-    
-    public void setService(Service arg0) {
-        
-        this.entry.setService(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#setSource(com.google.gdata.data.Source)
-     */
-    
-    public void setSource(Source arg0) {
-        
-        this.entry.setSource(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#setSummary(com.google.gdata.data.TextConstruct)
-     */
-    
-    public void setSummary(TextConstruct arg0) {
-        
-        this.entry.setSummary(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#setTitle(com.google.gdata.data.TextConstruct)
-     */
-    
-    public void setTitle(TextConstruct arg0) {
-        
-        this.entry.setTitle(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#setUpdated(com.google.gdata.data.DateTime)
-     */
-    
-    public void setUpdated(DateTime arg0) {
-        
-        this.entry.setUpdated(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#setVersionId(java.lang.String)
-     */
-    
-    public void setVersionId(String arg0) {
-        
-        this.entry.setVersionId(arg0);
-    }
-
- 
-    /**
-     * @see com.google.gdata.data.ExtensionPoint#addExtension(com.google.gdata.data.Extension)
-     */
-    
-    public void addExtension(Extension arg0) {
-        
-        this.entry.addExtension(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.ExtensionPoint#addRepeatingExtension(com.google.gdata.data.Extension)
-     */
-    
-    public void addRepeatingExtension(Extension arg0) {
-        
-        this.entry.addRepeatingExtension(arg0);
-    }
-
-   
-
-    /**
-     * @see com.google.gdata.data.ExtensionPoint#generateCumulativeXmlBlob(com.google.gdata.data.ExtensionProfile)
-     */
-    
-    public XmlBlob generateCumulativeXmlBlob(ExtensionProfile arg0) throws IOException {
-        
-        return this.entry.generateCumulativeXmlBlob(arg0);
-    }
-
-  
-   
-    /**
-     * @see com.google.gdata.data.ExtensionPoint#getRepeatingExtension(java.lang.Class)
-     */
-    
-    public <T extends Extension> List<T> getRepeatingExtension(Class<T> arg0) {
-        
-        return this.entry.getRepeatingExtension(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.ExtensionPoint#getXmlBlob()
-     */
-    
-    public XmlBlob getXmlBlob() {
-        
-        return this.entry.getXmlBlob();
-    }
-
-  
-
-    /**
-     * @see com.google.gdata.data.ExtensionPoint#parseCumulativeXmlBlob(com.google.gdata.util.XmlBlob, com.google.gdata.data.ExtensionProfile, java.lang.Class)
-     */
-    
-    public void parseCumulativeXmlBlob(XmlBlob arg0, ExtensionProfile arg1, Class arg2) throws IOException, ParseException {
-        
-        this.entry.parseCumulativeXmlBlob(arg0, arg1, arg2);
-    }
-
-    /**
-     * @see com.google.gdata.data.ExtensionPoint#removeExtension(java.lang.Class)
-     */
-    
-    public void removeExtension(Class arg0) {
-        
-        this.entry.removeExtension(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.ExtensionPoint#removeExtension(com.google.gdata.data.Extension)
-     */
-    
-    public void removeExtension(Extension arg0) {
-        
-        this.entry.removeExtension(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.ExtensionPoint#removeRepeatingExtension(com.google.gdata.data.Extension)
-     */
-    
-    public void removeRepeatingExtension(Extension arg0) {
-        
-        this.entry.removeRepeatingExtension(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.ExtensionPoint#setExtension(com.google.gdata.data.Extension)
-     */
-    
-    public void setExtension(Extension arg0) {
-        
-        this.entry.setExtension(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.ExtensionPoint#setXmlBlob(com.google.gdata.util.XmlBlob)
-     */
-    
-    public void setXmlBlob(XmlBlob arg0) {
-        
-        this.entry.setXmlBlob(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseEntry#declareExtensions(com.google.gdata.data.ExtensionProfile)
-     */
-    
-    public void declareExtensions(ExtensionProfile arg0) {
-        this.entry.declareExtensions(arg0);
-    }
-
-    /**
-     * @return Returns the version.
-     */
-    public int getVersion() {
-        return this.version;
-    }
-
-    /**
-     * @param version The version to set.
-     */
-    public void setVersion(int version) {
-        if(version < this.version)
-            throw new IllegalArgumentException("Version must be greater than the current version -- current version: "+this.version);
-        this.version = version;
-        setVersionId(""+this.version);
-    }
-    
-    
-    
-    
-    
-    
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/data/ServerBaseFeed.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/data/ServerBaseFeed.java
deleted file mode 100644
index 5ae81a2..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/data/ServerBaseFeed.java
+++ /dev/null
@@ -1,684 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.data;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.Reader;
-import java.util.Collection;
-import java.util.List;
-import java.util.Set;
-
-import org.apache.lucene.gdata.server.registry.ProvidedService;
-
-import com.google.gdata.client.Service;
-import com.google.gdata.data.BaseEntry;
-import com.google.gdata.data.BaseFeed;
-import com.google.gdata.data.Category;
-import com.google.gdata.data.DateTime;
-import com.google.gdata.data.Extension;
-import com.google.gdata.data.ExtensionProfile;
-import com.google.gdata.data.Feed;
-import com.google.gdata.data.Generator;
-import com.google.gdata.data.Link;
-import com.google.gdata.data.Person;
-import com.google.gdata.data.TextConstruct;
-import com.google.gdata.util.ParseException;
-import com.google.gdata.util.ServiceException;
-import com.google.gdata.util.XmlBlob;
-import com.google.gdata.util.common.xml.XmlWriter;
-
-/**
- * The GData-Server uses the GDATA-Client API for an interal representation of
- * entries. These entities have dynamic elements like Links being generated
- * using the requested URL.<br/> Some components of the server also need
- * additional infomation like the service type
- * {@link org.apache.lucene.gdata.server.registry.ProvidedService} of the feed.
- * All these information are
- * encapsulated in the ServerBaseFeed decoration a concrete subl class of <tt>BaseFeed</tt>. The type of the 
- * {@link com.google.gdata.data.BaseEntry} contained it this feed will be passed to the ServerBaseFeed
- * at creation time via the constructor. To retrieve the original entry call
- * {@link ServerBaseFeed#getFeed()} returns a
- * {@link com.google.gdata.data.BaseFeed} instance which can be casted into the
- * actual type. To use the ServerBaseEntry for generation a provided format like
- * RSS/ATOM the corresponding {@link com.google.gdata.data.ExtensionProfile} has
- * to be provided to the generation method.
- * 
- * @author Simon Willnauer
- * 
- */
-public class ServerBaseFeed  {
-
-    private String serviceType;
-
-    private ProvidedService serviceConfig;
-    
-    private GDataAccount account;
-    
-    private BaseFeed feed;
-    /**
-     * @return Returns the account.
-     */
-    public GDataAccount getAccount() {
-        return this.account;
-    }
-
-    /**
-     * @param account The account to set.
-     */
-    public void setAccount(GDataAccount account) {
-        this.account = account;
-    }
-
-    /**
-     * Creates a new ServerBaseFeed and decorates a basic instance of {@link Feed}
-     */
-    @SuppressWarnings("unchecked")
-    public ServerBaseFeed() {
-        this.feed = new Feed();
-        
-    }
-    /**
-     * @param feed - the feed to decorate
-     *            
-     */
-    @SuppressWarnings("unchecked")
-    public ServerBaseFeed(BaseFeed feed) {
-        this.feed = feed;
-        
-    }
-
-    /**
-     * @return Returns the feed.
-     */
-    public BaseFeed getFeed() {
-        return this.feed;
-    }
-
-    /**
-     * @param feed The feed to set.
-     */
-    public void setFeed(BaseFeed feed) {
-        this.feed = feed;
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseFeed#declareExtensions(com.google.gdata.data.ExtensionProfile)
-     */
-    public void declareExtensions(ExtensionProfile extProfile) {
-
-      this.feed.declareExtensions(extProfile);
-    }
-
-    /**
-     * @param link -
-     *            a link added to the link list of the feed
-     */
-    @SuppressWarnings("unchecked")
-    public void addLink(final Link link) {
-        this.feed.getLinks().add(link);
-    }
-
-    /**
-     * @param collection -
-     *            a collection of <code>Link</code> instance to be added to
-     *            the feeds link list
-     */
-    public void addLinks(final Collection<Link> collection) {
-        this.feed.getLinks().addAll(collection);
-    }
-
-    /**
-     * @return - the name of the service related of the feed represented by this
-     *         ServerBaseFeed
-     */
-    public String getServiceType() {
-        return this.serviceType;
-    }
-
-    /**
-     * @param serviceType -
-     *            the name of the service related of the feed represented by
-     *            this ServerBaseFeed
-     */
-    public void setServiceType(String serviceType) {
-        this.serviceType = serviceType;
-    }
-
-    /**
-     * @return - the provided service
-     */
-    public ProvidedService getServiceConfig() {
-        return this.serviceConfig;
-    }
-
-    /**
-     * @param serviceConfig - -
-     *            the provided service
-     */
-    public void setServiceConfig(ProvidedService serviceConfig) {
-        this.serviceConfig = serviceConfig;
-        if (serviceConfig != null)
-            this.serviceType = this.serviceConfig.getName();
-
-    }
-
-    /**
-     * @param person -
-     *            adds an author to the feed
-     */
-    public void addAuthor(final Person person) {
-        this.feed.getAuthors().add(person);
-    }
-    
-    /**
-     * @see com.google.gdata.data.BaseFeed#createEntry()
-     */
-    
-    public BaseEntry createEntry() {
-        
-        return this.feed.createEntry();
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseFeed#generateAtom(com.google.gdata.util.common.xml.XmlWriter, com.google.gdata.data.ExtensionProfile)
-     */
-    
-    public void generateAtom(XmlWriter arg0, ExtensionProfile arg1) throws IOException {
-        
-        this.feed.generateAtom(arg0, arg1);
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseFeed#generateAtomColl(com.google.gdata.util.common.xml.XmlWriter)
-     */
-    
-    public void generateAtomColl(XmlWriter arg0) throws IOException {
-        
-        this.feed.generateAtomColl(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseFeed#generateRss(com.google.gdata.util.common.xml.XmlWriter, com.google.gdata.data.ExtensionProfile)
-     */
-    
-    public void generateRss(XmlWriter arg0, ExtensionProfile arg1) throws IOException {
-        
-        this.feed.generateRss(arg0, arg1);
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseFeed#getCanPost()
-     */
-    
-    public boolean getCanPost() {
-        
-        return this.feed.getCanPost();
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseFeed#getEntries()
-     */
-    
-    public List getEntries() {
-        
-        return this.feed.getEntries();
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseFeed#getEntryPostLink()
-     */
-    
-    public Link getEntryPostLink() {
-        
-        return this.feed.getEntryPostLink();
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseFeed#getItemsPerPage()
-     */
-    
-    public int getItemsPerPage() {
-        
-        return this.feed.getItemsPerPage();
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseFeed#getSelf()
-     */
-    
-    public BaseFeed getSelf() throws IOException, ServiceException {
-        
-        return this.feed.getSelf();
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseFeed#getSelfLink()
-     */
-    
-    public Link getSelfLink() {
-        
-        return this.feed.getSelfLink();
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseFeed#getService()
-     */
-    
-    public Service getService() {
-        
-        return this.feed.getService();
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseFeed#getStartIndex()
-     */
-    
-    public int getStartIndex() {
-        
-        return this.feed.getStartIndex();
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseFeed#getTotalResults()
-     */
-    
-    public int getTotalResults() {
-        
-        return this.feed.getTotalResults();
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseFeed#insert(E)
-     */
-    
-    public BaseEntry insert(BaseEntry arg0) throws ServiceException, IOException {
-        
-        return this.feed.insert(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseFeed#parseAtom(com.google.gdata.data.ExtensionProfile, java.io.InputStream)
-     */
-    
-    public void parseAtom(ExtensionProfile arg0, InputStream arg1) throws IOException, ParseException {
-        
-        this.feed.parseAtom(arg0, arg1);
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseFeed#parseAtom(com.google.gdata.data.ExtensionProfile, java.io.Reader)
-     */
-    
-    public void parseAtom(ExtensionProfile arg0, Reader arg1) throws IOException, ParseException {
-        
-        this.feed.parseAtom(arg0, arg1);
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseFeed#setCanPost(boolean)
-     */
-    
-    public void setCanPost(boolean arg0) {
-        
-        this.feed.setCanPost(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseFeed#setItemsPerPage(int)
-     */
-    
-    public void setItemsPerPage(int arg0) {
-        
-        this.feed.setItemsPerPage(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseFeed#setService(com.google.gdata.client.Service)
-     */
-    
-    public void setService(Service arg0) {
-        
-        this.feed.setService(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseFeed#setStartIndex(int)
-     */
-    
-    public void setStartIndex(int arg0) {
-        
-        this.feed.setStartIndex(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.BaseFeed#setTotalResults(int)
-     */
-    
-    public void setTotalResults(int arg0) {
-        
-        this.feed.setTotalResults(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.Source#addHtmlLink(java.lang.String, java.lang.String, java.lang.String)
-     */
-    
-    public void addHtmlLink(String arg0, String arg1, String arg2) {
-        
-        this.feed.addHtmlLink(arg0, arg1, arg2);
-    }
-
-    /**
-     * @see com.google.gdata.data.Source#getAuthors()
-     */
-    
-    public List<Person> getAuthors() {
-        
-        return this.feed.getAuthors();
-    }
-
-    /**
-     * @see com.google.gdata.data.Source#getCategories()
-     */
-    
-    public Set<Category> getCategories() {
-        
-        return this.feed.getCategories();
-    }
-
-    /**
-     * @see com.google.gdata.data.Source#getContributors()
-     */
-    
-    public List<Person> getContributors() {
-        
-        return this.feed.getContributors();
-    }
-
-    /**
-     * @see com.google.gdata.data.Source#getGenerator()
-     */
-    
-    public Generator getGenerator() {
-        
-        return this.feed.getGenerator();
-    }
-
-    /**
-     * @see com.google.gdata.data.Source#getHtmlLink()
-     */
-    
-    public Link getHtmlLink() {
-        
-        return this.feed.getHtmlLink();
-    }
-
-    /**
-     * @see com.google.gdata.data.Source#getIcon()
-     */
-    
-    public String getIcon() {
-        
-        return this.feed.getIcon();
-    }
-
-    /**
-     * @see com.google.gdata.data.Source#getId()
-     */
-    
-    public String getId() {
-        
-        return this.feed.getId();
-    }
-
-    /**
-     * @see com.google.gdata.data.Source#getLink(java.lang.String, java.lang.String)
-     */
-    
-    public Link getLink(String arg0, String arg1) {
-        
-        return this.feed.getLink(arg0, arg1);
-    }
-
-    /**
-     * @see com.google.gdata.data.Source#getLinks()
-     */
-    
-    public List<Link> getLinks() {
-        
-        return this.feed.getLinks();
-    }
-
-    /**
-     * @see com.google.gdata.data.Source#getLogo()
-     */
-    
-    public String getLogo() {
-        
-        return this.feed.getLogo();
-    }
-
-    /**
-     * @see com.google.gdata.data.Source#getRights()
-     */
-    
-    public TextConstruct getRights() {
-        
-        return this.feed.getRights();
-    }
-
-    /**
-     * @see com.google.gdata.data.Source#getSubtitle()
-     */
-    
-    public TextConstruct getSubtitle() {
-        
-        return this.feed.getSubtitle();
-    }
-
-    /**
-     * @see com.google.gdata.data.Source#getTitle()
-     */
-    
-    public TextConstruct getTitle() {
-        
-        return this.feed.getTitle();
-    }
-
-    /**
-     * @see com.google.gdata.data.Source#getUpdated()
-     */
-    
-    public DateTime getUpdated() {
-        
-        return this.feed.getUpdated();
-    }
-
-    /**
-     * @see com.google.gdata.data.Source#setGenerator(com.google.gdata.data.Generator)
-     */
-    
-    public void setGenerator(Generator arg0) {
-        
-        this.feed.setGenerator(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.Source#setIcon(java.lang.String)
-     */
-    
-    public void setIcon(String arg0) {
-        
-        this.feed.setIcon(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.Source#setId(java.lang.String)
-     */
-    
-    public void setId(String arg0) {
-        
-        this.feed.setId(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.Source#setLogo(java.lang.String)
-     */
-    
-    public void setLogo(String arg0) {
-        
-        this.feed.setLogo(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.Source#setRights(com.google.gdata.data.TextConstruct)
-     */
-    
-    public void setRights(TextConstruct arg0) {
-        
-        this.feed.setRights(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.Source#setSubtitle(com.google.gdata.data.TextConstruct)
-     */
-    
-    public void setSubtitle(TextConstruct arg0) {
-        
-        this.feed.setSubtitle(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.Source#setTitle(com.google.gdata.data.TextConstruct)
-     */
-    
-    public void setTitle(TextConstruct arg0) {
-        
-        this.feed.setTitle(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.Source#setUpdated(com.google.gdata.data.DateTime)
-     */
-    
-    public void setUpdated(DateTime arg0) {
-        
-        this.feed.setUpdated(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.ExtensionPoint#addExtension(com.google.gdata.data.Extension)
-     */
-    
-    public void addExtension(Extension arg0) {
-        
-        this.feed.addExtension(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.ExtensionPoint#addRepeatingExtension(com.google.gdata.data.Extension)
-     */
-    
-    public void addRepeatingExtension(Extension arg0) {
-        
-        this.feed.addRepeatingExtension(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.ExtensionPoint#getExtension(java.lang.Class)
-     */
-    
-    public <T extends Extension> T getExtension(Class<T> arg0) {
-        
-        return this.feed.getExtension(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.ExtensionPoint#getRepeatingExtension(java.lang.Class)
-     */
-    
-    public <T extends Extension> List<T> getRepeatingExtension(Class<T> arg0) {
-        
-        return this.feed.getRepeatingExtension(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.ExtensionPoint#getXmlBlob()
-     */
-    
-    public XmlBlob getXmlBlob() {
-        
-        return this.feed.getXmlBlob();
-    }
-
-    /**
-     * @see com.google.gdata.data.ExtensionPoint#parseCumulativeXmlBlob(com.google.gdata.util.XmlBlob, com.google.gdata.data.ExtensionProfile, java.lang.Class)
-     */
-    
-    public void parseCumulativeXmlBlob(XmlBlob arg0, ExtensionProfile arg1, Class arg2) throws IOException, ParseException {
-        
-        this.feed.parseCumulativeXmlBlob(arg0, arg1, arg2);
-    }
-
-    /**
-     * @see com.google.gdata.data.ExtensionPoint#removeExtension(java.lang.Class)
-     */
-    
-    public void removeExtension(Class arg0) {
-        
-        this.feed.removeExtension(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.ExtensionPoint#removeExtension(com.google.gdata.data.Extension)
-     */
-    
-    public void removeExtension(Extension arg0) {
-        
-        this.feed.removeExtension(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.ExtensionPoint#removeRepeatingExtension(com.google.gdata.data.Extension)
-     */
-    
-    public void removeRepeatingExtension(Extension arg0) {
-        
-        this.feed.removeRepeatingExtension(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.ExtensionPoint#setExtension(com.google.gdata.data.Extension)
-     */
-    
-    public void setExtension(Extension arg0) {
-        
-        this.feed.setExtension(arg0);
-    }
-
-    /**
-     * @see com.google.gdata.data.ExtensionPoint#setXmlBlob(com.google.gdata.util.XmlBlob)
-     */
-    
-    public void setXmlBlob(XmlBlob arg0) {
-        
-        this.feed.setXmlBlob(arg0);
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/data/package.html b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/data/package.html
deleted file mode 100644
index 10c3ef5..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/data/package.html
+++ /dev/null
@@ -1,10 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
-<html> 
-<head> 
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
-   <meta name="Author" content="Simon Willnauer"> 
-</head> 
-<body> 
-Contains classes for the internal representation of GData feeds and entries. 
-</body> 
-</html> 
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/package.html b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/package.html
deleted file mode 100644
index 0ea30d2..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/package.html
+++ /dev/null
@@ -1 +0,0 @@
-<html><body>Top-level package.</body></html> 
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/GDataSearcher.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/GDataSearcher.java
deleted file mode 100755
index f4bd72b..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/GDataSearcher.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.search;
-
-import java.io.IOException;
-import java.util.List;
-
-import org.apache.lucene.search.Query;
-
-/**
- * @author Simon Willnauer
- * @param <T> 
- *
- */
-public interface GDataSearcher <T>{
-
-    /**
-     * executes an Query and returns a list of defined return values of type T
-     * @param query - the query to apply to the searcher
-     * @param hitcount - the amount of hits returned by this search
-     * @param offset - the hit count offset 
-     * @param feedId 
-     * @return List of T
-     * @throws IOException - if the underlying lucene searcher throws an IO Exception 
-     */
-    public List<T> search(Query query,int hitcount, int offset, String feedId)throws IOException;
-    /**
-     * Destroys this Searcher
-     */
-    public abstract void close();
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/SearchComponent.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/SearchComponent.java
deleted file mode 100755
index 407944b..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/SearchComponent.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.search;
-
-import org.apache.lucene.gdata.server.registry.ProvidedService;
-import org.apache.lucene.gdata.server.registry.ServerComponent;
-
-/**
- * TODO document this when Search comes into play
- * 
- * @author Simon Willnauer
- * 
- */
-public interface SearchComponent extends ServerComponent {
-    /**
-     * TODO document this when Search comes into play
-     * 
-     * @param service
-     * 
-     * @return a GDataSearcher
-     */
-    public abstract GDataSearcher<String> getServiceSearcher(ProvidedService service);
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/StandardGdataSearcher.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/StandardGdataSearcher.java
deleted file mode 100755
index 34db075..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/StandardGdataSearcher.java
+++ /dev/null
@@ -1,136 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.search;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.atomic.AtomicBoolean;
-
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.gdata.search.index.IndexDocument;
-import org.apache.lucene.gdata.utils.ReferenceCounter;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.Hits;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.QueryFilter;
-import org.apache.lucene.search.TermQuery;
-
-/**
- * Standard implementation of
- * {@link org.apache.lucene.gdata.search.GDataSearcher}
- * 
- * @author Simon Willnauer
- * 
- */
-public class StandardGdataSearcher implements GDataSearcher<String> {
-    private final AtomicBoolean isClosed = new AtomicBoolean(false);
-
-    private final ReferenceCounter<IndexSearcher> searcher;
-
-    private static final Map<String, QueryFilter> queryFilterCache = new HashMap<String, QueryFilter>();
-
-    /** constructs a new GdataSearcher
-     * @param searcher - the current lucene searcher instance
-     */
-    public StandardGdataSearcher(ReferenceCounter<IndexSearcher> searcher) {
-        if (searcher == null)
-            throw new IllegalArgumentException("searcher must not be null");
-
-        this.searcher = searcher;
-
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.search.GDataSearcher#search(org.apache.lucene.search.Query,
-     *      int, int, java.lang.String)
-     */
-    public List<String> search(Query query, int hitcount, int offset,
-            String feedId) throws IOException {
-        if (hitcount < 0 || offset < 0)
-            throw new IllegalArgumentException(
-                    "hit count and offset must not be less than 0");
-        if (this.isClosed.get())
-            throw new IllegalStateException("Searcher is closed");
-        if (query == null)
-            throw new RuntimeException("query is null can not apply search");
-        if (feedId == null)
-            throw new IllegalArgumentException("feed id must not be null");
-        QueryFilter filter = null;
-        synchronized (queryFilterCache) {
-            filter = queryFilterCache.get(feedId);
-        
-        if (filter == null)
-            filter = new QueryFilter(new TermQuery(new Term(
-                    IndexDocument.FIELD_FEED_ID, feedId)));
-            queryFilterCache.put(feedId, filter);
-        }
-        IndexSearcher indexSearcher = this.searcher.get();
-        Hits hits = indexSearcher.search(query, filter);
-        
-        return collectHits(hits, hitcount, offset);
-
-    }
-
-    protected List<String> collectHits(Hits hits, int hitcount, int offset)
-            throws IOException {
-        int hitLength = hits.length();
-        if (hitLength < offset || hitLength == 0)
-            return new ArrayList<String>(0);
-        if (offset > 0)
-            --offset;
-        /*
-         * include the offset
-         */
-        int remainingHits = hitLength - offset;
-        int returnSize = remainingHits > hitcount ? hitcount : remainingHits;
-        List<String> retVal = new ArrayList<String>(returnSize);
-        for (int i = 0; i < returnSize; i++) {
-            Document doc = hits.doc(offset++);
-            /*
-             * the entry id is sufficient to retrieve the entry from the
-             * storage. the result will be ordered by score (default)
-             */
-            Field field = doc.getField(IndexDocument.FIELD_ENTRY_ID);
-            retVal.add(i, field.stringValue());
-        }
-        return retVal;
-
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.search.GDataSearcher#close()
-     */
-    public void close() {
-        this.isClosed.set(true);
-        this.searcher.decrementRef();
-
-    }
-
-    static void flushFilterCache() {
-        synchronized (queryFilterCache) {
-            queryFilterCache.clear();
-        }
-        
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/ContentStrategy.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/ContentStrategy.java
deleted file mode 100755
index 8951a9c..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/ContentStrategy.java
+++ /dev/null
@@ -1,179 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.search.analysis;
-
-import org.apache.lucene.document.Field;
-import org.apache.lucene.document.Field.Index;
-import org.apache.lucene.document.Field.Store;
-import org.apache.lucene.gdata.data.ServerBaseEntry;
-import org.apache.lucene.gdata.search.config.IndexSchemaField;
-import org.apache.lucene.gdata.search.config.IndexSchemaField.ContentType;
-import org.apache.lucene.gdata.search.index.GdataIndexerException;
-import org.apache.lucene.gdata.utils.ReflectionUtils;
-import org.w3c.dom.Node;
-
-/**
- * Creating Indexable document requires processing of incoming entities as
- * GData Entries. Entries in the GData protocol might have very different
- * structures and content. They all have on thing in common as they are atom xml
- * format. To retrieve the configured elements of the atom format and process the
- * actual content might differ from element to element.
- * <p>
- * Each predefined ContentStrategy can be used to retrieve certain content from
- * the defined element. Which element to process is defined using a XPath
- * expression in the gdata-config.xml file.
- * </p>
- * <p>
- * <tt>ContentStrategy</tt> implementation should not be accessed directly. To
- * get a <tt>ContentStrategy</tt> for a specific
- * {@link org.apache.lucene.gdata.search.config.IndexSchemaField.ContentType}
- * use the {@link ContentStrategy#getFieldStrategy} factory method. This method
- * expects a IndexSchemaField instance with a set <tt>ContentType</tt>. The
- * return value is a new <tt>ContentStrategy</tt> instance for the defined
- * <tt>ContentType</tt>.
- * </p>
- * 
- * @see org.apache.lucene.gdata.search.config.IndexSchemaField.ContentType
- * @see org.apache.lucene.gdata.search.index.IndexDocumentBuilder
- * 
- * @author Simon Willnauer
- */
-public abstract class ContentStrategy {
-    protected final Store store;
-
-    protected final Index index;
-
-    protected final IndexSchemaField config;
-
-    protected String content;
-
-    protected String fieldName;
-
-    protected ContentStrategy(IndexSchemaField fieldConfiguration) {
-        this(null, null, fieldConfiguration);
-    }
-
-    protected ContentStrategy(Index index, Store store,
-            IndexSchemaField fieldConfig) {
-        if(fieldConfig == null)
-            throw new IllegalArgumentException("IndexSchemaField must not be null");
-        this.config = fieldConfig;
-        this.fieldName = fieldConfig.getName();
-        if (index != null) {
-            this.index = index;
-        } else {
-            this.index = fieldConfig.getIndex() == null ? IndexSchemaField.DEFAULT_INDEX_STRATEGY
-                    : fieldConfig.getIndex();
-        }
-        if (store != null) {
-            this.store = store;
-        } else {
-            this.store = fieldConfig.getStore() == null ? IndexSchemaField.DEFAULT_STORE_STRATEGY
-                    : fieldConfig.getStore();
-        }
-
-    }
-
-    /**
-     * @param indexable
-     * @throws NotIndexableException
-     */
-    public abstract void processIndexable(
-            Indexable<? extends Node, ? extends ServerBaseEntry> indexable)
-            throws NotIndexableException;
-
-    /**
-     * This method creates a lucene field from the retrieved content of the
-     * entity. Values for Field.Index, Field.Store, the field name and the boost
-     * factor are configured in the <tt>IndexSchemaField</tt> passed by the
-     * constructor e.g the factory method. This method might be overwritten by
-     * subclasses.
-     * 
-     * @return the Lucene {@link Field}
-     */
-    public Field[] createLuceneField() {
-        /*
-         * should I test the content for being empty?!
-         * does that make any difference if empty fields are indexed?!
-         */
-        if(this.fieldName==null|| this.content == null)
-            throw new GdataIndexerException("Required field not set fieldName: "+this.fieldName+" content: "+this.content);
-        if(this.content.length()==0){
-            return new Field[0];
-        }
-        Field retValue = new Field(this.fieldName, this.content, this.store,
-                this.index);
-        float boost = this.config.getBoost();
-        if (boost != 1.0f)
-            retValue.setBoost(boost);
-        return new Field[]{retValue};
-        
-    }
-
-    /**
-     * This factory method creates the <tt>ContentStrategy</tt> corresponding
-     * to the set <tt>ContentType</tt> value in the <tt>IndexSchemaField</tt>
-     * passed to the method as the single parameter.
-     * <p>
-     * The ContentType must not be null
-     * </p>
-     * 
-     * @param fieldConfig -
-     *            the field config to use to identify the corresponding
-     *            <tt>ContentStrategy</tt>
-     * @return - a new <tt>ContentStrategy</tt> instance
-     */
-    public static ContentStrategy getFieldStrategy(IndexSchemaField fieldConfig) {
-        if (fieldConfig == null)
-            throw new IllegalArgumentException(
-                    "field configuration must not be null");
-        ContentType type = fieldConfig.getContentType();
-        if (type == null)
-            throw new IllegalArgumentException(
-                    "ContentType in IndexSchemaField must not be null");
-        fieldConfig.getAnalyzerClass();
-
-        switch (type) {
-        case CATEGORY:
-            return new GdataCategoryStrategy(fieldConfig);
-        case HTML:
-            return new HTMLStrategy(fieldConfig);
-        case XHTML:
-            return new XHtmlStrategy(fieldConfig);
-        case GDATADATE:
-            return new GdataDateStrategy(fieldConfig);
-        case TEXT:
-            return new PlainTextStrategy(fieldConfig);
-        case KEYWORD:
-            return new KeywordStrategy(fieldConfig);
-        case CUSTOM:
-            /*
-             * check if this class can be created with default constructor is checked
-             * in IndexSchemaField#setFieldClass and throws RuntimeEx if not. So
-             * server can not start up.
-             */
-            return ReflectionUtils.getDefaultInstance(fieldConfig
-                    .getFieldClass());
-        case MIXED:
-            return new MixedContentStrategy(fieldConfig);
-        default:
-            throw new RuntimeException("No content strategy found for " + type);
-        }
-
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/DomIndexable.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/DomIndexable.java
deleted file mode 100755
index 477e085..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/DomIndexable.java
+++ /dev/null
@@ -1,110 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.search.analysis;
-
-import java.io.IOException;
-import java.io.StringReader;
-import java.io.StringWriter;
-
-import javax.xml.parsers.DocumentBuilder;
-import javax.xml.parsers.DocumentBuilderFactory;
-import javax.xml.parsers.ParserConfigurationException;
-import javax.xml.xpath.XPath;
-import javax.xml.xpath.XPathConstants;
-import javax.xml.xpath.XPathExpressionException;
-import javax.xml.xpath.XPathFactory;
-
-import org.apache.lucene.gdata.data.ServerBaseEntry;
-import org.w3c.dom.Document;
-import org.w3c.dom.Node;
-import org.xml.sax.InputSource;
-import org.xml.sax.SAXException;
-
-import com.google.gdata.data.ExtensionProfile;
-import com.google.gdata.util.common.xml.XmlWriter;
-
-/**
- * <tt>Indexable</tt> implementation using the W3C Dom API and JAXP XPath
- * engine
- * 
- * @author Simon Willnauer
- * @param <R> -
- *            a subtype of {@link org.w3c.dom.Node} returned by the applyPath
- *            method
- * @param <I> -
- *            a subtype of {@link org.apache.lucene.gdata.data.ServerBaseEntry}
- */
-public class DomIndexable<R extends Node, I extends ServerBaseEntry> extends
-        Indexable<R, I> {
-    private final Document document;
-
-    private final XPath xPath;
-
-    /**
-     * @param applyAble
-     * @throws NotIndexableException
-     */
-    public DomIndexable(I applyAble) throws NotIndexableException {
-        super(applyAble);
-        if (this.applyAble.getServiceConfig() == null)
-            throw new NotIndexableException("ServiceConfig is not set");
-        try {
-            this.document = buildDomDocument();
-        } catch (ParserConfigurationException e) {
-            throw new NotIndexableException("Can not create document builder",
-                    e);
-
-        } catch (IOException e) {
-            throw new NotIndexableException(
-                    "IO Exception occurred while building indexable", e);
-
-        } catch (SAXException e) {
-            throw new NotIndexableException("Can not parse entry", e);
-
-        }
-        this.xPath = XPathFactory.newInstance().newXPath();
-
-    }
-
-    private Document buildDomDocument() throws ParserConfigurationException,
-            IOException, SAXException {
-        StringWriter stringWriter = new StringWriter();
-        ExtensionProfile profile = this.applyAble.getServiceConfig()
-                .getExtensionProfile();
-        if (profile == null)
-            throw new IllegalStateException("ExtensionProfile is not set");
-        XmlWriter writer = new XmlWriter(stringWriter);
-        this.applyAble.generateAtom(writer, profile);
-        DocumentBuilder builder = DocumentBuilderFactory.newInstance()
-                .newDocumentBuilder();
-        return builder.parse(new InputSource(new StringReader(stringWriter
-                .toString())));
-
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.search.analysis.Indexable#applyPath(java.lang.String)
-     */
-    @SuppressWarnings("unchecked")
-    @Override
-    public R applyPath(String expression) throws XPathExpressionException {
-
-        return (R) this.xPath.evaluate(expression, this.document,
-                XPathConstants.NODE);
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/GdataCategoryStrategy.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/GdataCategoryStrategy.java
deleted file mode 100755
index d4e0a7c..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/GdataCategoryStrategy.java
+++ /dev/null
@@ -1,167 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.search.analysis;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import javax.xml.xpath.XPathExpressionException;
-
-import org.apache.lucene.document.Field;
-import org.apache.lucene.gdata.data.ServerBaseEntry;
-import org.apache.lucene.gdata.search.config.IndexSchemaField;
-import org.apache.lucene.gdata.search.index.GdataIndexerException;
-import org.w3c.dom.NamedNodeMap;
-import org.w3c.dom.Node;
-
-/**
- * This strategy retrieves the category term and and the scheme from a category
- * element. The content is represented by the term which can be configured via
- * the configuration file.
- * <p>
- * The category element has at least one attribute with the name "scheme" which
- * is not mandatory. The term can be the default attribute "term" or the text
- * content of the element, this is configured via the path of the field.
- * </p>
- * <p>
- * <tt>&lt;category scheme="http://www.example.com/type" term="blog.post"/&gt;<tt>
- * </p>
- * TODO extend javadoc for search info
- * @author Simon Willnauer
- *
- */
-public class GdataCategoryStrategy extends ContentStrategy {
-    protected String categoryScheme;
-
-    protected String categorySchemeField;
-
-    private static final String LABEL = "label";
-
-    private static final String SCHEME = "scheme";
-
-    private static final String TERM = "term";
-
-    /**
-     * the string to search a schema if no schema is specified
-     */
-    public static final String CATEGORY_SCHEMA_NULL_VALUE = "LUCISCHEMANULL";
-
-    /**
-     * Schema field suffix
-     */
-    public static final String CATEGORY_SCHEMA_FIELD_SUFFIX = "-schema";
-
-    protected GdataCategoryStrategy(IndexSchemaField fieldConfiguration) {
-        super(fieldConfiguration);
-        this.categorySchemeField = new StringBuilder(this.fieldName).append(
-                CATEGORY_SCHEMA_FIELD_SUFFIX).toString();
-
-    }
-
-    /**
-     * @throws NotIndexableException
-     * @see org.apache.lucene.gdata.search.analysis.ContentStrategy#processIndexable(org.apache.lucene.gdata.search.analysis.Indexable)
-     */
-    @Override
-    public void processIndexable(
-            Indexable<? extends Node, ? extends ServerBaseEntry> indexable)
-            throws NotIndexableException {
-        String contentPath = this.config.getPath();
-        Node node = null;
-        try {
-            node = indexable.applyPath(contentPath);
-        } catch (XPathExpressionException e) {
-
-            throw new NotIndexableException("Can not apply path");
-        }
-        if (node == null)
-            throw new NotIndexableException(
-                    "Could not retrieve content for schema field: "
-                            + this.config);
-
-        StringBuilder contentBuilder = new StringBuilder();
-        StringBuilder schemeBuilder = new StringBuilder();
-        String nodeName = node.getNodeName();
-        /*
-         * enable more than one category element -- check the node name if
-         * category strategy is used with an element not named "category"
-         */
-        while (node != null && nodeName != null
-                && nodeName.equals(node.getNodeName())) {
-            NamedNodeMap attributeMap = node.getAttributes();
-            if (attributeMap == null)
-                throw new NotIndexableException(
-                        "category term attribute not present");
-            /*
-             * the "term" is the internal string used by the software to
-             * identify the category, while the "label" is the human-readable
-             * string presented to a user in a user interface.
-             */
-            Node termNode = attributeMap.getNamedItem(TERM);
-            if (termNode == null)
-                throw new NotIndexableException(
-                        "category term attribute not present");
-            contentBuilder.append(termNode.getTextContent()).append(" ");
-
-            Node labelNode = attributeMap.getNamedItem(LABEL);
-            if (labelNode != null)
-                contentBuilder.append(labelNode.getTextContent()).append(" ");
-
-            Node schemeNode = attributeMap.getNamedItem(SCHEME);
-            if (schemeNode != null)
-                schemeBuilder.append(schemeNode.getTextContent());
-            node = node.getNextSibling();
-        }
-
-        this.content = contentBuilder.toString();
-        this.categoryScheme = schemeBuilder.toString();
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.search.analysis.ContentStrategy#createLuceneField()
-     */
-    @Override
-    public Field[] createLuceneField() {
-        List<Field> retValue = new ArrayList<Field>(2);
-        if (this.fieldName == null)
-            throw new GdataIndexerException("Required field 'name' is null -- "
-                    + this.config);
-        if (this.content == null)
-            throw new GdataIndexerException(
-                    "Required field 'content' is null -- " + this.config);
-
-        Field categoryTerm = new Field(this.fieldName, this.content,
-                this.store, this.index);
-        float boost = this.config.getBoost();
-        if (boost != 1.0f)
-            categoryTerm.setBoost(boost);
-        retValue.add(categoryTerm);
-        /*
-         * if schema is not set index null value to enable search for categories
-         * without a schema
-         */
-        if (this.categoryScheme == null || this.categoryScheme.length() == 0) {
-            this.categoryScheme = CATEGORY_SCHEMA_NULL_VALUE;
-        }
-        Field categoryURN = new Field(this.categorySchemeField,
-                this.categoryScheme, Field.Store.YES, Field.Index.UN_TOKENIZED);
-        retValue.add(categoryURN);
-        return retValue.toArray(new Field[0]);
-
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/GdataDateStrategy.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/GdataDateStrategy.java
deleted file mode 100755
index 775215b..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/GdataDateStrategy.java
+++ /dev/null
@@ -1,99 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.search.analysis;
-
-import javax.xml.xpath.XPathExpressionException;
-
-import org.apache.lucene.document.Field;
-import org.apache.lucene.gdata.data.ServerBaseEntry;
-import org.apache.lucene.gdata.search.config.IndexSchemaField;
-import org.apache.lucene.gdata.search.index.GdataIndexerException;
-import org.w3c.dom.Node;
-
-import com.google.gdata.data.DateTime;
-
-/**
- * This content strategy retrieves a so called GData Date from a RFC 3339
- * timestamp format. The format will be parsed and indexed as a timestamp value.
- * 
- * @author Simon Willnauer
- * 
- */
-public class GdataDateStrategy extends ContentStrategy {
-
-    protected GdataDateStrategy(IndexSchemaField fieldConfiguration) {
-        super(fieldConfiguration);
-
-    }
-
-    /**
-     * @throws NotIndexableException
-     * @see org.apache.lucene.gdata.search.analysis.ContentStrategy#processIndexable(org.apache.lucene.gdata.search.analysis.Indexable)
-     */
-    @Override
-    public void processIndexable(
-            Indexable<? extends Node, ? extends ServerBaseEntry> indexable)
-            throws NotIndexableException {
-        String path = this.config.getPath();
-        Node node;
-        try {
-            node = indexable.applyPath(path);
-        } catch (XPathExpressionException e1) {
-            throw new NotIndexableException("Can not apply path -- " + path
-                    + " FieldConfig: " + this.config);
-        }
-        if (node == null)
-            throw new NotIndexableException(
-                    "Could not retrieve content for schema field: "
-                            + this.config);
-        String textContent = node.getTextContent();
-        try {
-            this.content = getTimeStamp(textContent);
-        } catch (NumberFormatException e) {
-            throw new NotIndexableException("Can not parse GData date -- "
-                    + textContent);
-        }
-
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.search.analysis.ContentStrategy#createLuceneField()
-     */
-    @Override
-    public Field[] createLuceneField() {
-        if(this.fieldName == null)
-            throw new GdataIndexerException(
-                    "Required field 'name' is null -- " +this.config);
-        if(this.content == null)
-            throw new GdataIndexerException(
-                    "Required field 'content' is null -- " +this.config);
-        if(this.content.length()==0)
-            return new Field[0];
-            Field retValue = new Field(this.fieldName, this.content,
-                    Field.Store.YES, Field.Index.UN_TOKENIZED);
-            float boost = this.config.getBoost();
-            if (boost != 1.0f)
-                retValue.setBoost(boost);
-            return new Field[] { retValue };
-        
-    }
-
-    private static String getTimeStamp(String dateString) {
-        return Long.toString(DateTime.parseDateTimeChoice(dateString).getValue());
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/HTMLStrategy.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/HTMLStrategy.java
deleted file mode 100755
index b057c5c..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/HTMLStrategy.java
+++ /dev/null
@@ -1,99 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.search.analysis;
-
-import java.io.IOException;
-import java.io.StringReader;
-import java.io.StringWriter;
-
-import javax.xml.xpath.XPathExpressionException;
-
-import org.apache.lucene.gdata.data.ServerBaseEntry;
-import org.apache.lucene.gdata.search.config.IndexSchemaField;
-import org.apache.xerces.xni.XNIException;
-import org.apache.xerces.xni.parser.XMLDocumentFilter;
-import org.apache.xerces.xni.parser.XMLInputSource;
-import org.apache.xerces.xni.parser.XMLParserConfiguration;
-import org.cyberneko.html.HTMLConfiguration;
-import org.cyberneko.html.filters.ElementRemover;
-import org.cyberneko.html.filters.Writer;
-import org.w3c.dom.Node;
-
-/**
- * This ContentStrategy applies the path to the Indexable and retrieves the
- * plain string content from the returning node. All of the nodes text content
- * will cleaned from any html tags.
- * 
- * @author Simon Willnauer
- * 
- */
-public class HTMLStrategy extends
-        org.apache.lucene.gdata.search.analysis.ContentStrategy {
-    private static final String REMOVE_SCRIPT = "script";
-
-    private static final String CHAR_ENCODING = "UTF-8";
-
-    protected HTMLStrategy(IndexSchemaField fieldConfiguration) {
-        super(fieldConfiguration);
-
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.search.analysis.ContentStrategy#processIndexable(org.apache.lucene.gdata.search.analysis.Indexable)
-     */
-    @Override
-    public void processIndexable(Indexable<? extends Node, ? extends ServerBaseEntry> indexable)
-            throws NotIndexableException {
-        String path = this.config.getPath();
-        Node node = null;
-        try {
-            node = indexable.applyPath(path);
-        } catch (XPathExpressionException e1) {
-            throw new NotIndexableException("Can not apply path -- " + path);
-
-        }
-        if(node == null)
-            throw new NotIndexableException("Could not retrieve content for schema field: "+this.config);
-        StringReader contentReader = new StringReader(node.getTextContent());
-        /*
-         * remove all elements and script parts
-         */
-        ElementRemover remover = new ElementRemover();
-        remover.removeElement(REMOVE_SCRIPT);
-        StringWriter contentWriter = new StringWriter();
-        Writer writer = new Writer(contentWriter, CHAR_ENCODING);
-        XMLDocumentFilter[] filters = { remover, writer, };
-        XMLParserConfiguration parser = new HTMLConfiguration();
-        parser.setProperty("http://cyberneko.org/html/properties/filters",
-                filters);
-        XMLInputSource source = new XMLInputSource(null, null, null,
-                contentReader, CHAR_ENCODING);
-        try {
-            parser.parse(source);
-        } catch (XNIException e) {
-            throw new NotIndexableException("Can not parse html -- ", e);
-
-        } catch (IOException e) {
-            throw new NotIndexableException("Can not parse html -- ", e);
-
-        }
-        this.content = contentWriter.toString();
-    }
-
-    
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/Indexable.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/Indexable.java
deleted file mode 100755
index ae800b36..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/Indexable.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.search.analysis;
-
-import javax.xml.xpath.XPathExpressionException;
-
-import org.apache.lucene.gdata.data.ServerBaseEntry;
-import org.w3c.dom.Node;
-
-/**
- * This class wraps the access to the GData entities to access them via xpath
- * expressions. An arbitrary valid Xpath expression can be passed to the
- * <tt>applyPath</tt> method to access an element, attribute etc. in the gdata
- * entity.
- * 
- * @author Simon Willnauer
- * @param <R> -
- *            a subtype of {@link org.w3c.dom.Node} returned by the applyPath
- *            method
- * @param <I> -
- *            a subtype of {@link org.apache.lucene.gdata.data.ServerBaseEntry}
- */
-public abstract class Indexable<R extends Node, I extends ServerBaseEntry> {
-    protected ServerBaseEntry applyAble;
-
-    /**
-     * @param applyAble
-     */
-    Indexable(I applyAble) {
-        this.applyAble = applyAble;
-    }
-
-    /**
-     * @param xPath -
-     *            a valid xpath expression
-     * @return - the requested element <b>R</b>
-     * @throws XPathExpressionException
-     */
-    public abstract R applyPath(String xPath) throws XPathExpressionException;
-
-    /**
-     * Factory method to create new <tt>Indexable</tt> instances.
-     * 
-     * @param <R> -
-     *            a subtype of {@link org.w3c.dom.Node} returned by the
-     *            applyPath method
-     * @param <I> -
-     *            a subtype of
-     *            {@link org.apache.lucene.gdata.data.ServerBaseEntry}
-     * @param entry -
-     *            the entry to wrap in a <tt>Indexable</tt>
-     * @return - a new instance of <tt>Indexable</tt> to access the entry via
-     *         Xpath
-     * @throws NotIndexableException - if <b>I<b> can not be parsed. 
-     */
-    public static <R extends Node, I extends ServerBaseEntry> Indexable<R, I> getIndexable(
-            I entry) throws NotIndexableException {
-        return new DomIndexable<R, I>(entry);
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/KeywordStrategy.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/KeywordStrategy.java
deleted file mode 100755
index 273140f..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/KeywordStrategy.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.search.analysis;
-
-import javax.xml.xpath.XPathExpressionException;
-
-import org.apache.lucene.document.Field;
-import org.apache.lucene.gdata.data.ServerBaseEntry;
-import org.apache.lucene.gdata.search.config.IndexSchemaField;
-import org.w3c.dom.Node;
-
-/**
- * @author Simon Willnauer
- *
- */
-public class KeywordStrategy extends ContentStrategy {
-
-    /**
-     * @param fieldConfig
-     */
-    public KeywordStrategy(IndexSchemaField fieldConfig) {
-        super(Field.Index.UN_TOKENIZED,Field.Store.YES,fieldConfig);
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.search.analysis.ContentStrategy#processIndexable(org.apache.lucene.gdata.search.analysis.Indexable)
-     */
-    @Override
-    public void processIndexable(Indexable<? extends Node, ? extends ServerBaseEntry> indexable) throws NotIndexableException {
-        String path = this.config.getPath();
-        try {
-            Node node = indexable.applyPath(path);
-            if(node == null)
-                throw new NotIndexableException("Could not retrieve content for schema field: "+this.config);
-            this.content = node.getTextContent();
-        } catch (XPathExpressionException e) {
-            throw new NotIndexableException("Can not apply Path", e);
-        }
-
-    }
-
-   
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/MixedContentStrategy.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/MixedContentStrategy.java
deleted file mode 100755
index 0037c5e..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/MixedContentStrategy.java
+++ /dev/null
@@ -1,97 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.search.analysis;
-
-import javax.xml.xpath.XPathExpressionException;
-
-import org.apache.lucene.document.Field;
-import org.apache.lucene.gdata.data.ServerBaseEntry;
-import org.apache.lucene.gdata.search.config.IndexSchemaField;
-import org.apache.lucene.gdata.search.config.IndexSchemaField.ContentType;
-import org.w3c.dom.Node;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class MixedContentStrategy extends ContentStrategy {
-    protected ContentStrategy strategy;
-
-    protected MixedContentStrategy(IndexSchemaField fieldConfiguration) {
-        super(fieldConfiguration);
-
-    }
-
-    /**
-     * @throws NotIndexableException
-     * @see org.apache.lucene.gdata.search.analysis.ContentStrategy#processIndexable(org.apache.lucene.gdata.search.analysis.Indexable)
-     */
-    @Override
-    public void processIndexable(
-            Indexable<? extends Node, ? extends ServerBaseEntry> indexable)
-            throws NotIndexableException {
-        String path = this.config.getTypePath();
-
-        try {
-            Node node = indexable.applyPath(path);
-            if (node == null)
-                this.strategy = new PlainTextStrategy(this.config);
-            else {
-                String contentType = node.getTextContent();
-
-                this.strategy = chooseStrategy(contentType, this.config);
-            }
-            this.strategy.processIndexable(indexable);
-        } catch (XPathExpressionException e) {
-            throw new NotIndexableException("Can not apply path -- " + path);
-
-        }
-    }
-    
-    /**
-     * @see org.apache.lucene.gdata.search.analysis.ContentStrategy#createLuceneField()
-     */
-    @Override
-    public Field[] createLuceneField() {
-        
-        return this.strategy.createLuceneField();
-    }
-
-    private static ContentStrategy chooseStrategy(final String contentType,
-            final IndexSchemaField config) {
-        ContentType type = null;
-        try {
-            type = ContentType.valueOf(contentType==null?"TEXT":contentType.toUpperCase());
-        } catch (Throwable e) {
-            type = ContentType.TEXT;
-        }
-
-        switch (type) {
-        case HTML:
-            return new HTMLStrategy(config);
-
-        case XHTML:
-            return new XHtmlStrategy(config);
-
-        default:
-            return new PlainTextStrategy(config);
-
-        }
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/NotIndexableException.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/NotIndexableException.java
deleted file mode 100755
index 83d7d9f..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/NotIndexableException.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.search.analysis;
-
-/**
- * This exception will be thrown by ContentStrategy instances if an exception
- * occurs while retrieving content from entries
- * 
- * @author Simon Willnauer
- * 
- */
-public class NotIndexableException extends Exception {
-
-    /**
-     * 
-     */
-    private static final long serialVersionUID = 1538388864181786380L;
-
-    /**
-     * Constructs a new NotIndexableException
-     */
-    public NotIndexableException() {
-        super();
-
-    }
-
-    /**
-     * Constructs a new NotIndexableException with the specified detail message.
-     * 
-     * @param arg0 -
-     *            detail message
-     */
-    public NotIndexableException(String arg0) {
-        super(arg0);
-
-    }
-
-    /**
-     * Constructs a new NotIndexableException with the specified detail message
-     * and nested exception.
-     * 
-     * @param arg0 -
-     *            detail message
-     * @param arg1 -
-     *            nested exception
-     */
-    public NotIndexableException(String arg0, Throwable arg1) {
-        super(arg0, arg1);
-
-    }
-
-    /**
-     * Constructs a new NotIndexableException with a nested exception caused
-     * this exception.
-     * 
-     * @param arg0 -
-     *            nested exception
-     */
-    public NotIndexableException(Throwable arg0) {
-        super(arg0);
-
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/PlainTextStrategy.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/PlainTextStrategy.java
deleted file mode 100755
index ef0305b..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/PlainTextStrategy.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.search.analysis;
-
-import javax.xml.xpath.XPathExpressionException;
-
-import org.apache.lucene.gdata.data.ServerBaseEntry;
-import org.apache.lucene.gdata.search.config.IndexSchemaField;
-import org.w3c.dom.Node;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class PlainTextStrategy extends ContentStrategy {
-
-    protected PlainTextStrategy(IndexSchemaField fieldConfiguration) {
-        super(fieldConfiguration);
-        
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.search.analysis.ContentStrategy#processIndexable(org.apache.lucene.gdata.search.analysis.Indexable)
-     */
-    @Override
-    public void processIndexable(Indexable<? extends Node, ? extends ServerBaseEntry> indexable)
-            throws NotIndexableException {
-        String path = this.config.getPath();
-        try {
-            Node node = indexable.applyPath(path);
-            if(node == null)
-                throw new NotIndexableException("Could not retrieve content for schema field: "+this.config);
-            this.content = node.getTextContent();
-            
-        } catch (XPathExpressionException e) {
-            throw new NotIndexableException("Can not apply Path", e);
-        }
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/XHtmlStrategy.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/XHtmlStrategy.java
deleted file mode 100755
index 39d0f5b..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/XHtmlStrategy.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.search.analysis;
-
-import org.apache.lucene.gdata.search.config.IndexSchemaField;
-
-
-/**
- * @author Simon Willnauer
- * @see org.apache.lucene.gdata.search.analysis.TestHTMLStrategy
- */
-public class XHtmlStrategy extends HTMLStrategy {
-
-	
-
-    /**
-     * @param fieldConfig
-     */
-    public XHtmlStrategy(IndexSchemaField fieldConfig) {
-     super(fieldConfig);
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/package.html b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/package.html
deleted file mode 100755
index 8851e77..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/analysis/package.html
+++ /dev/null
@@ -1,10 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
-<html> 
-<head> 
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
-   <meta name="Author" content="Simon Willnauer"> 
-</head> 
-<body> 
-Classes used for extracting content from entries and building lucene documents.
-</body> 
-</html> 
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/config/IndexSchema.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/config/IndexSchema.java
deleted file mode 100755
index 1535229..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/config/IndexSchema.java
+++ /dev/null
@@ -1,525 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.search.config;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Set;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.analysis.PerFieldAnalyzerWrapper;
-import org.apache.lucene.analysis.standard.StandardAnalyzer;
-import org.apache.lucene.gdata.search.index.IndexDocument;
-import org.apache.lucene.gdata.utils.ReflectionUtils;
-
-/**
- * This class is used to configure the indexing and search component. Each
- * service on the GData server will have an own search index. For this purpose
- * one single index schema will be configured in the gdata-config.xml file. This
- * file will be mapped on this class on startup.
- * <p>
- * This class breaks some encapsulation of general java classes to be
- * configurable via the xml configuration file. The will be very less type and
- * value checking of the properties inside this file. Mandatory values must be
- * set in the configuration file. The server won't start up if these values are
- * missing. See definition in the xml schema file. If this class is instantiated
- * manually the value for the name of the schema should be set before this is
- * passed to the IndexController.
- * </p>
- * <p>
- * One IndexSchema consists of multiple instances of
- * {@link org.apache.lucene.gdata.search.config.IndexSchemaField} each of this
- * instances describes a single field in the index and all schema informations
- * about the field.
- * <p>
- * 
- * 
- * @see org.apache.lucene.gdata.search.config.IndexSchemaField
- * 
- * 
- * @author Simon Willnauer
- */
-public class IndexSchema {
-    private final Set<String> searchableFieldNames = new HashSet<String>();
-
-    private static final Log LOG = LogFactory.getLog(IndexSchema.class);
-
-    /**
-     * a static final value for properties are not set by the configuration file
-     * this value will be set to all long and int properties by default
-     */
-    public static final int NOT_SET_VALUE = -1;
-    private static final int DEFAULT_OPTIMIZE_COUNT = 1;
-    private static final int DEFAULT_COMMIT_COUNT = 1;
-
-    private String indexLocation;
-
-    /*
-     * this should be final change it if possible --> see commons digester /
-     * RegistryBuilder
-     */
-    private String name;
-
-    private boolean useTimedIndexer;
-
-    private long indexerIdleTime = NOT_SET_VALUE;
-
-    private Analyzer serviceAnalyzer;
-
-    private String defaultSearchField;
-
-    private PerFieldAnalyzerWrapper perFieldAnalyzer;
-
-    private Collection<IndexSchemaField> schemaFields;
-
-    private int maxBufferedDocs = NOT_SET_VALUE;
-
-    private int maxMergeDocs = NOT_SET_VALUE;
-
-    private int mergeFactor = NOT_SET_VALUE;
-
-    private int maxFieldLength = NOT_SET_VALUE;
-
-    private long writeLockTimeout = NOT_SET_VALUE;
-
-    private long commitLockTimeout = NOT_SET_VALUE;
-
-    private int commitAfterDocuments = DEFAULT_COMMIT_COUNT;
-    
-    private int optimizeAfterCommit = DEFAULT_OPTIMIZE_COUNT;
-    
-    private boolean useCompoundFile = false;
-
-    /**
-     * Creates a new IndexSchema and initialize the standard service analyzer to
-     * {@link StandardAnalyzer}
-     * 
-     */
-    public IndexSchema() {
-        this.schemaFields = new ArrayList<IndexSchemaField>();
-        /*
-         * keep as standard if omitted in the configuration
-         */
-        this.serviceAnalyzer = new StandardAnalyzer();
-
-    }
-
-    /**
-     * Initialize the schema and checks all required values
-     */
-    public void initialize() {
-        for (IndexSchemaField field : this.schemaFields) {
-            if (!field.checkRequieredValues())
-                throw new RuntimeException("Required Value for field: "
-                        + field.getName() + " is missing");
-        }
-        if (this.defaultSearchField == null)
-            throw new RuntimeException("DefaulSearchField must not be null");
-        if (this.name == null)
-            throw new RuntimeException(
-                    "Schema field is not set -- must not be null");
-        if (this.indexLocation == null)
-            throw new RuntimeException("IndexLocation must not be null");
-        if(!this.searchableFieldNames.contains(this.defaultSearchField)){
-            throw new RuntimeException("the default search field: "+this.defaultSearchField+" is registered as a field");
-        }
-
-    }
-
-    /**
-     * @return Returns the useCompoundFile.
-     */
-    public boolean isUseCompoundFile() {
-        return this.useCompoundFile;
-    }
-
-    /**
-     * @param useCompoundFile
-     *            The useCompoundFile to set.
-     */
-    public void setUseCompoundFile(boolean useCompoundFile) {
-        this.useCompoundFile = useCompoundFile;
-    }
-
-    /**
-     * Adds a new {@link IndexSchemaField} to the schema. if the fields name
-     * equals {@link IndexDocument#FIELD_ENTRY_ID} or the field is
-     * <code>null</code> it will simply ignored
-     * 
-     * @param field -
-     *            the index schema field to add as a field of this schema.
-     */
-    public void addSchemaField(final IndexSchemaField field) {
-        if (field == null)
-            return;
-        /*
-         * skip fields configured in the gdata-config.xml file if their names
-         * match a primary key field id of the IndexDocument
-         */
-        if (field.getName().equals(IndexDocument.FIELD_ENTRY_ID)
-                || field.getName().equals(IndexDocument.FIELD_FEED_ID))
-            return;
-        if (field.getAnalyzerClass() != null) {
-            /*
-             * enable per field analyzer if one is set.
-             */
-            Analyzer analyzer = getAnalyzerInstance(field.getAnalyzerClass());
-            /*
-             * null values will be omitted here
-             */
-            buildPerFieldAnalyzerWrapper(analyzer, field.getName());
-        }
-        this.schemaFields.add(field);
-        this.searchableFieldNames.add(field.getName());
-    }
-
-
-    /**
-     * @return Returns the fieldConfiguration.
-     */
-    public Collection<IndexSchemaField> getFields() {
-        return this.schemaFields;
-    }
-
-    /**
-     * @return - the analyzer instance to be used for this schema
-     */
-    public Analyzer getSchemaAnalyzer() {
-        if (this.perFieldAnalyzer == null)
-            return this.serviceAnalyzer;
-        return this.perFieldAnalyzer;
-    }
-
-    /**
-     * @return Returns the serviceAnalyzer.
-     */
-    public Analyzer getServiceAnalyzer() {
-        return this.serviceAnalyzer;
-    }
-
-    /**
-     * @param serviceAnalyzer
-     *            The serviceAnalyzer to set.
-     */
-    public void setServiceAnalyzer(Analyzer serviceAnalyzer) {
-        if (serviceAnalyzer == null)
-            return;
-        this.serviceAnalyzer = serviceAnalyzer;
-
-    }
-
-    /**
-     * @return Returns the commitLockTimout.
-     */
-    public long getCommitLockTimeout() {
-        return this.commitLockTimeout;
-    }
-
-    /**
-     * 
-     * @param commitLockTimeout
-     *            The commitLockTimeout to set.
-     */
-    public void setCommitLockTimeout(long commitLockTimeout) {
-        // TODO enable this in config
-        this.commitLockTimeout = commitLockTimeout;
-    }
-
-    /**
-     * @return Returns the maxBufferedDocs.
-     */
-    public int getMaxBufferedDocs() {
-
-        return this.maxBufferedDocs;
-    }
-
-    /**
-     * @param maxBufferedDocs
-     *            The maxBufferedDocs to set.
-     */
-    public void setMaxBufferedDocs(int maxBufferedDocs) {
-        this.maxBufferedDocs = maxBufferedDocs;
-    }
-
-    /**
-     * @return Returns the maxFieldLength.
-     */
-    public int getMaxFieldLength() {
-        return this.maxFieldLength;
-    }
-
-    /**
-     * @param maxFieldLength
-     *            The maxFieldLength to set.
-     */
-    public void setMaxFieldLength(int maxFieldLength) {
-        this.maxFieldLength = maxFieldLength;
-    }
-
-    /**
-     * @return Returns the maxMergeDocs.
-     */
-    public int getMaxMergeDocs() {
-        return this.maxMergeDocs;
-    }
-
-    /**
-     * @param maxMergeDocs
-     *            The maxMergeDocs to set.
-     */
-    public void setMaxMergeDocs(int maxMergeDocs) {
-        this.maxMergeDocs = maxMergeDocs;
-    }
-
-    /**
-     * @return Returns the mergeFactor.
-     */
-    public int getMergeFactor() {
-        return this.mergeFactor;
-    }
-
-    /**
-     * @param mergeFactor
-     *            The mergeFactor to set.
-     */
-    public void setMergeFactor(int mergeFactor) {
-        this.mergeFactor = mergeFactor;
-    }
-
-    /**
-     * @return Returns the writeLockTimeout.
-     */
-    public long getWriteLockTimeout() {
-        return this.writeLockTimeout;
-    }
-
-    /**
-     * @param writeLockTimeout
-     *            The writeLockTimeout to set.
-     */
-    public void setWriteLockTimeout(long writeLockTimeout) {
-        this.writeLockTimeout = writeLockTimeout;
-    }
-
-    /**
-     * @param fields
-     *            The fieldConfiguration to set.
-     */
-    public void setSchemaFields(Collection<IndexSchemaField> fields) {
-        this.schemaFields = fields;
-    }
-
-    /**
-     * @return Returns the name.
-     */
-    public String getName() {
-        return this.name;
-    }
-
-    /**
-     * @see java.lang.Object#equals(java.lang.Object)
-     */
-    @Override
-    public boolean equals(Object object) {
-        if (this == object)
-            return true;
-        if (object == null)
-            return false;
-        if (object instanceof IndexSchema) {
-           if(this.name ==null)
-               return super.equals(object);
-            return this.name.equals(((IndexSchema) object).getName());
-        }
-        return false;
-    }
-
-    /**
-     * @see java.lang.Object#hashCode()
-     */
-    @Override
-    public int hashCode() {
-        if (this.name == null)
-            return super.hashCode();
-        return this.name.hashCode();
-    }
-
-    private void buildPerFieldAnalyzerWrapper(Analyzer anazlyer, String field) {
-        if (anazlyer == null || field == null || field.length() == 0)
-            return;
-        if (this.perFieldAnalyzer == null)
-            this.perFieldAnalyzer = new PerFieldAnalyzerWrapper(
-                    this.serviceAnalyzer);
-        this.perFieldAnalyzer.addAnalyzer(field, anazlyer);
-    }
-
-    private static Analyzer getAnalyzerInstance(Class<? extends Analyzer> clazz) {
-        if (!ReflectionUtils.extendsType(clazz, Analyzer.class)) {
-            LOG.warn("Can not create analyzer for class " + clazz.getName());
-            return null;
-        }
-        try {
-            return clazz.newInstance();
-        } catch (Exception e) {
-            LOG.warn("Can not create analyzer for class " + clazz.getName());
-        }
-        return null;
-    }
-
-    /**
-     * @param name
-     *            The name to set.
-     */
-    public void setName(String name) {
-        this.name = name;
-    }
-
-    /**
-     * @return Returns the indexLocation.
-     */
-    public String getIndexLocation() {
-        return this.indexLocation;
-    }
-
-    /**
-     * @param indexLocation
-     *            The indexLocation to set.
-     */
-    public void setIndexLocation(String indexLocation) {
-        this.indexLocation = indexLocation;
-    }
-
-    /**
-     * @return Returns the defaultField.
-     */
-    public String getDefaultSearchField() {
-        return this.defaultSearchField;
-    }
-
-    /**
-     * @param defaultField
-     *            The defaultField to set.
-     */
-    public void setDefaultSearchField(String defaultField) {
-        this.defaultSearchField = defaultField;
-    }
-
-    /**
-     * @return Returns the indexerIdleTime.
-     */
-    public long getIndexerIdleTime() {
-        return this.indexerIdleTime;
-    }
-
-    /**
-     * @param indexerIdleTime
-     *            The indexerIdleTime to set.
-     */
-    public void setIndexerIdleTime(long indexerIdleTime) {
-        this.indexerIdleTime = indexerIdleTime;
-    }
-
-    /**
-     * @return Returns the useTimedIndexer.
-     */
-    public boolean isUseTimedIndexer() {
-        return this.useTimedIndexer;
-    }
-
-    /**
-     * @param useTimedIndexer
-     *            The useTimedIndexer to set.
-     */
-    public void setUseTimedIndexer(boolean useTimedIndexer) {
-        this.useTimedIndexer = useTimedIndexer;
-    }
-
-    /**
-     * @see java.lang.Object#toString()
-     */
-    @Override
-    public String toString() {
-        StringBuilder builder = new StringBuilder(this.getClass().getName())
-                .append(" ");
-        builder.append("Name: ").append(this.name).append(" ");
-        builder.append("MaxBufferedDocs: ").append(this.maxBufferedDocs)
-                .append(" ");
-        builder.append("MaxFieldLength: ").append(this.maxFieldLength).append(
-                " ");
-        builder.append("MaxMergeDocs: ").append(this.maxMergeDocs).append(" ");
-        builder.append("MergeFactor: ").append(this.mergeFactor).append(" ");
-        builder.append("CommitLockTimeout: ").append(this.commitLockTimeout)
-                .append(" ");
-        builder.append("WriteLockTimeout: ").append(this.writeLockTimeout)
-                .append(" ");
-        builder.append("indexerIdleTime: ").append(this.indexerIdleTime)
-                .append(" ");
-        builder.append("useCompoundFile: ").append(this.useCompoundFile)
-                .append(" ");
-        builder.append("Added SchemaField instances: ").append(
-                this.schemaFields.size()).append(" ");
-
-        builder.append("IndexLocation: ").append(this.indexLocation)
-                .append(" ");
-        return builder.toString();
-
-    }
-
-    /**
-     * @return Returns the searchableFieldNames.
-     */
-    public Set<String> getSearchableFieldNames() {
-        return this.searchableFieldNames;
-    }
-
-    /**
-     * Defines after how many added,removed or updated document the indexer should commit.
-     * @return Returns the commitAfterDocuments.
-     */
-    public int getCommitAfterDocuments() {
-        return this.commitAfterDocuments;
-    }
-
-    /**
-     * @param commitAfterDocuments The commitAfterDocuments to set.
-     */
-    public void setCommitAfterDocuments(int commitAfterDocuments) {
-        if(commitAfterDocuments < DEFAULT_COMMIT_COUNT)
-            return;
-        this.commitAfterDocuments = commitAfterDocuments;
-    }
-
-    /**
-     * Defines after how many commits the indexer should optimize the index
-     * @return Returns the optimizeAfterCommit.
-     */
-    public int getOptimizeAfterCommit() {
-        
-        return this.optimizeAfterCommit;
-    }
-
-    /**
-     * @param optimizeAfterCommit The optimizeAfterCommit to set.
-     */
-    public void setOptimizeAfterCommit(int optimizeAfterCommit) {
-        if(optimizeAfterCommit < DEFAULT_OPTIMIZE_COUNT )
-            return;
-        this.optimizeAfterCommit = optimizeAfterCommit;
-    }
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/config/IndexSchemaField.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/config/IndexSchemaField.java
deleted file mode 100755
index c499fdf..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/config/IndexSchemaField.java
+++ /dev/null
@@ -1,380 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.search.config;
-
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.document.Field.Index;
-import org.apache.lucene.document.Field.Store;
-import org.apache.lucene.gdata.search.analysis.ContentStrategy;
-import org.apache.lucene.gdata.search.analysis.GdataCategoryStrategy;
-import org.apache.lucene.gdata.search.analysis.GdataDateStrategy;
-import org.apache.lucene.gdata.search.analysis.HTMLStrategy;
-import org.apache.lucene.gdata.search.analysis.KeywordStrategy;
-import org.apache.lucene.gdata.search.analysis.MixedContentStrategy;
-import org.apache.lucene.gdata.search.analysis.PlainTextStrategy;
-import org.apache.lucene.gdata.search.analysis.XHtmlStrategy;
-import org.apache.lucene.gdata.utils.ReflectionUtils;
-
-/**
- * Each field in the search index is defined by a instance of
- * {@link IndexSchemaField}. The schema definition will be loaded at startup
- * and the defined values will be set to instances of this class. Each
- * constructed field will be passed to an instance of
- * {@link org.apache.lucene.gdata.search.config.IndexSchema}.
- * <p>
- * IndexSchemaField contains all informations about how the content from
- * incoming entries has to be extracted and how the actual content has to be
- * index into the lucene index.
- * </p>
- * <p>
- * Each field will have a defined
- * {@link org.apache.lucene.gdata.search.analysis.ContentStrategy} which does
- * process the extraction of the field content from an incoming entry.
- * </p>
- * @see org.apache.lucene.gdata.search.analysis.ContentStrategy
- * @see org.apache.lucene.gdata.search.config.IndexSchema
- * 
- * @author Simon Willnauer
- * 
- */
-public class IndexSchemaField {
-    /**
-     * Default value for Field.Store 
-     * @see org.apache.lucene.document.Field
-     */
-    public static final Store DEFAULT_STORE_STRATEGY = Field.Store.NO;
-    /**
-     * Default value for Field.Index
-     * @see org.apache.lucene.document.Field
-     */
-    public static final Index DEFAULT_INDEX_STRATEGY = Field.Index.TOKENIZED;
-    private static final float DEFAULT_BOOST = 1.0f;
-    private static final float MINIMAL_BOOST = 0.1f;
-    private float boost = DEFAULT_BOOST;
-
-    private String name;
-
-    private ContentType contentType;
-
-    private Index index = DEFAULT_INDEX_STRATEGY;
-
-    private Store store = DEFAULT_STORE_STRATEGY;
-
-    private String path;
-
-    private String typePath;
-
-    private Class<? extends Analyzer> analyzerClass;
-
-    private Class<? extends ContentStrategy> fieldClass;
-
-    /**
-     * Constructs a new SchemaField <br>
-     * Default values:
-     * <ol>
-     * <li>boost: <i>1.0</i></li>
-     * <li>index: <i>TOKENIZED</i></li>
-     * <li>store: <i>NO</i></li>
-     * </ol>
-     */
-    public IndexSchemaField() {
-        super();
-    }
-    boolean checkRequieredValues(){
-        /*
-         * This class will be inst. by the reg builder.
-         * Check all values to be set. otherwise return false.
-         * false will cause a runtime exception in IndexSchema
-         */
-        boolean returnValue = (this.name != null&&this.path!=null&&this.contentType!=null&&this.index!=null&&this.store!=null&&this.boost>=MINIMAL_BOOST);
-        if(this.contentType == ContentType.CUSTOM)
-            returnValue &=this.fieldClass!=null;
-        else if(this.contentType == ContentType.MIXED)
-            returnValue &=this.typePath!=null;
-        
-        return returnValue;
-    }
-    /**
-     * @return Returns the alanyzerClass.
-     */
-    public Class<? extends Analyzer> getAnalyzerClass() {
-        return this.analyzerClass;
-    }
-
-    /**
-     * @param alanyzerClass
-     *            The alanyzerClass to set.
-     */
-    public void setAnalyzerClass(Class<? extends Analyzer> alanyzerClass) {
-        this.analyzerClass = alanyzerClass;
-    }
-
-    /**
-     * @return Returns the fieldClass.
-     */
-    public Class<? extends ContentStrategy> getFieldClass() {
-        return this.fieldClass;
-    }
-
-    /**
-     * Sets the class or strategy is used to extract this field Attention: this
-     * method set the contentTyp to {@link ContentType#CUSTOM}
-     * 
-     * @param fieldClass
-     *            The fieldClass to set.
-     */
-    public void setFieldClass(Class<? extends ContentStrategy> fieldClass) {
-        if(fieldClass == null)
-            throw new IllegalArgumentException("ContentStrategy must not be null");
-        if(!ReflectionUtils.extendsType(fieldClass,ContentStrategy.class))
-            throw new RuntimeException("The configured ContentStrategy does not extend ContentStrategy, can not use as a custom strategy -- "+fieldClass.getName());
-        if(!ReflectionUtils.hasDesiredConstructor(fieldClass,new Class[]{IndexSchemaField.class}))
-            throw new RuntimeException("Can not create instance of "+fieldClass.getName());
-        this.fieldClass = fieldClass;
-        /*
-         * set custom - field class is only needed by custom
-         */
-        this.contentType = ContentType.CUSTOM;
-    }
-
-    /**
-     * @return Returns the index.
-     */
-    public Index getIndex() {
-        return this.index;
-    }
-
-    /**
-     * @param index
-     *            The index to set.
-     */
-    public void setIndex(Index index) {
-        this.index = index;
-    }
-
-    /**
-     * @return Returns the name.
-     */
-    public String getName() {
-        return this.name;
-    }
-
-    /**
-     * @param name
-     *            The name to set.
-     */
-    public void setName(String name) {
-        this.name = name;
-    }
-
-    /**
-     * @return Returns the path.
-     */
-    public String getPath() {
-        return this.path;
-    }
-
-    /**
-     * @param path
-     *            The path to set.
-     */
-    public void setPath(String path) {
-        this.path = path;
-    }
-
-    /**
-     * @return Returns the store.
-     */
-    public Store getStore() {
-        return this.store;
-    }
-
-    /**
-     * @param store
-     *            The store to set.
-     */
-    public void setStore(Store store) {
-        this.store = store;
-    }
-
-    /**
-     * @return Returns the type.
-     */
-    public ContentType getContentType() {
-        return this.contentType;
-    }
-
-    /**
-     * @param type
-     *            The type to set.
-     */
-    public void setContentType(ContentType type) {
-        this.contentType = type;
-
-    }
-
-    /**
-     * Sets the content type of this field by the name of the enum type. This
-     * method is not case sensitive.
-     * 
-     * @param type -
-     *            type name as string
-     */
-    public void setType(String type) {
-        ContentType[] types = ContentType.class.getEnumConstants();
-        for (int i = 0; i < types.length; i++) {
-            if (types[i].name().toLowerCase().equals(type)) {
-                this.contentType = types[i];
-                break;
-            }
-
-        }
-    }
-
-    /**
-     * Defines the {@link ContentStrategy} to use for a
-     * <tt>IndexSchemaField</tt> to extract the content from the entry
-     * 
-     * @author Simon Willnauer
-     * 
-     */
-    public enum ContentType {
-       
-        /**
-         * HTML content strategy {@link HTMLStrategy }
-         */
-        HTML,
-        /**
-         * XHTML content strategy {@link XHtmlStrategy }
-         */
-        XHTML,
-        /**
-         * Text content strategy {@link PlainTextStrategy }
-         */
-        TEXT,
-        /**
-         * GDataDate content strategy {@link GdataDateStrategy }
-         */
-        GDATADATE,
-        /**
-         * KEYWORD content strategy {@link KeywordStrategy }
-         */
-        KEYWORD,
-        /**
-         * Category content strategy {@link GdataCategoryStrategy }
-         */
-        CATEGORY,
-        /**
-         * Custom content strategy (user defined)
-         */
-        CUSTOM,
-        /**
-         * Mixed content strategy {@link MixedContentStrategy }
-         */
-        MIXED
-
-    }
-
-    /**
-     * @return Returns the boost.
-     */
-    public float getBoost() {
-        return this.boost;
-    }
-
-    /**
-     * @param boost
-     *            The boost to set.
-     */
-    public void setBoost(float boost) {
-        if (boost <= 0)
-            return;
-        this.boost = boost;
-    }
-
-    /**
-     * @see java.lang.Object#toString()
-     */
-    @Override
-    public String toString() {
-        StringBuilder builder = new StringBuilder(this.getClass()
-                .getSimpleName()).append(" ");
-        builder.append("field name: ").append(this.name).append(" ");
-        builder.append("path: ").append(this.path).append(" ");
-        builder.append("content type ").append(this.contentType).append(" ");
-        builder.append("field class: ").append(this.fieldClass).append(" ");
-        builder.append("analyzer: ").append(this.analyzerClass).append(" ");
-        builder.append("boost: ").append(this.boost).append(" ");
-        builder.append("INDEX: ").append(this.index).append(" ");
-        builder.append("STORE: ").append(this.store);
-        return builder.toString();
-    }
-
-    /**
-     * Sets the Store class by simple name
-     * 
-     * @param name -
-     *            one of yes, no, compress
-     */
-    public void setStoreByName(String name) {
-        if (name.toLowerCase().equals("yes"))
-            this.store = Field.Store.YES;
-        else if (name.toLowerCase().equals("no"))
-            this.store = Field.Store.NO;
-        else if (name.toLowerCase().equals("compress"))
-            this.store = Field.Store.COMPRESS;
-    }
-
-    /**
-     * Sets the Index class by simple name
-     * 
-     * @param name -
-     *            un_tokenized, tokenized, no, no_norms
-     */
-    public void setIndexByName(String name) {
-        if (name.toLowerCase().equals("un_tokenized"))
-            this.index = Field.Index.UN_TOKENIZED;
-        else if (name.toLowerCase().equals("tokenized"))
-            this.index = Field.Index.TOKENIZED;
-        else if (name.toLowerCase().equals("no_norms"))
-            this.index = Field.Index.NO_NORMS;
-        else if (name.toLowerCase().equals("no"))
-            this.index = Field.Index.NO;
-    }
-
-    /**
-     * @return Returns the typePath.
-     */
-    public String getTypePath() {
-        return this.typePath;
-    }
-
-    /**
-     * @param typePath
-     *            The typePath to set.
-     */
-    public void setTypePath(String typePath) {
-        this.typePath = typePath;
-        /*
-         * set Mixed - this property is only needed by mixed type
-         */
-        setContentType(ContentType.MIXED);
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/config/package.html b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/config/package.html
deleted file mode 100755
index 2bb6076..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/config/package.html
+++ /dev/null
@@ -1,10 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
-<html> 
-<head> 
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
-   <meta name="Author" content="Simon Willnauer"> 
-</head> 
-<body> 
-All classes used for index and search configuration
-</body> 
-</html> 
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/GDataIndexDocument.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/GDataIndexDocument.java
deleted file mode 100755
index 1e2054c..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/GDataIndexDocument.java
+++ /dev/null
@@ -1,167 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.search.index;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.gdata.search.analysis.ContentStrategy;
-import org.apache.lucene.index.Term;
-
-/**
- * Simple implementation
- * 
- * @author Simon Willnauer
- * @see org.apache.lucene.gdata.search.index.IndexDocument
- */
-class GDataIndexDocument implements IndexDocument {
-    private final IndexAction action;
-
-    private final boolean commitAfter;
-
-    private final boolean optimizeAfter;
-
-    private String id;
-
-    protected Collection<ContentStrategy> fields;
-
-    private final String feedId;
-
-    GDataIndexDocument(final IndexAction action, final String entryId,final String feedId,final boolean commitAfter,final boolean optimizeAfter) {
-        this.action = action;
-        this.id = entryId;
-        this.feedId = feedId;
-        this.fields = new ArrayList<ContentStrategy>(10);
-        this.commitAfter = commitAfter;
-        this.optimizeAfter = optimizeAfter;
-    }
-
-    /**
-     * Adds a new field e.g. <tt>ContentStrategy</tt> to the IndexDocument
-     * 
-     * @param field -
-     *            the strategy to add
-     */
-    public void addField(ContentStrategy field) {
-        if (field == null)
-            return;
-        this.fields.add(field);
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.search.index.IndexDocument#getWriteable()
-     */
-    public Document getWriteable() {
-        Document retVal = new Document();
-        retVal.add(new Field(FIELD_ENTRY_ID, this.id, Field.Store.YES,
-                Field.Index.UN_TOKENIZED));
-        retVal.add(new Field(FIELD_FEED_ID, this.feedId, Field.Store.YES,
-                Field.Index.UN_TOKENIZED));
-        for (ContentStrategy strategy : this.fields) {
-            Field[] fieldArray = strategy.createLuceneField();
-            for (int i = 0; i < fieldArray.length; i++) {
-                retVal.add(fieldArray[i]);
-            }
-            
-        }
-        return retVal;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.search.index.IndexDocument#getDeletealbe()
-     */
-    public Term getDeletealbe() {
-
-        return new Term(IndexDocument.FIELD_ENTRY_ID, this.id);
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.search.index.IndexDocument#isUpdate()
-     */
-    public boolean isUpdate() {
-
-        return isAction(IndexAction.UPDATE);
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.search.index.IndexDocument#isDelete()
-     */
-    public boolean isDelete() {
-
-        return isAction(IndexAction.DELETE);
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.search.index.IndexDocument#isInsert()
-     */
-    public boolean isInsert() {
-
-        return isAction(IndexAction.INSERT);
-    }
-
-    private boolean isAction(IndexAction indexAction) {
-        return this.action == indexAction;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.search.index.IndexDocument#commitAfter()
-     */
-    public boolean commitAfter() {
-
-        return this.commitAfter;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.search.index.IndexDocument#optimizeAfter()
-     */
-    public boolean optimizeAfter() {
-
-        return this.optimizeAfter;
-    }
-
-    /**
-     * @see java.lang.Object#equals(java.lang.Object)
-     */
-    @Override
-    public final boolean equals(Object obj) {
-        if(obj == null)
-            return false;
-        if(this == obj)
-            return true;
-        if(obj instanceof GDataIndexDocument){
-            GDataIndexDocument other = (GDataIndexDocument)obj; 
-            if(this.id == null)
-                return false;
-            return this.id.equals(other.id);
-        }
-        return false; 
-    }
-
-    /**
-     * @see java.lang.Object#hashCode()
-     */
-    @Override
-    public final int hashCode() {
-        if(this.id == null)
-            return super.hashCode();
-        return this.id.hashCode();
-    }
-    
-    
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/GDataIndexWriter.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/GDataIndexWriter.java
deleted file mode 100755
index cffe493..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/GDataIndexWriter.java
+++ /dev/null
@@ -1,104 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.search.index;
-
-import java.io.IOException;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.analysis.standard.StandardAnalyzer;
-import org.apache.lucene.gdata.search.config.IndexSchema;
-import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.store.Directory;
-
-/**
- * Configurable decorator for a lucene {@link IndexWriter}
- * 
- * @author Simon Willnauer
- * 
- */
-public class GDataIndexWriter extends IndexWriter {
-    private static final Log LOG = LogFactory.getLog(GDataIndexWriter.class);
-
-    private String serviceName;
-
-    private void initialize(IndexSchema config) {
-        this.serviceName = config.getName();
-        setUseCompoundFile(config.isUseCompoundFile());
-        if (config.getMaxBufferedDocs() != IndexSchema.NOT_SET_VALUE)
-            setMaxBufferedDocs(config.getMaxBufferedDocs());
-        if (config.getMaxMergeDocs() != IndexSchema.NOT_SET_VALUE)
-            setMaxMergeDocs(config.getMaxMergeDocs());
-        if (config.getMergeFactor() != IndexSchema.NOT_SET_VALUE)
-            setMergeFactor(config.getMergeFactor());
-        if (config.getMaxFieldLength() != IndexSchema.NOT_SET_VALUE)
-            setMaxFieldLength(config.getMaxFieldLength());
-        if (config.getWriteLockTimeout() != IndexSchema.NOT_SET_VALUE)
-            setWriteLockTimeout(config.getWriteLockTimeout());
-        //no commit lock anymore
-        //TODO fix this
-//        if (config.getCommitLockTimeout() != IndexSchema.NOT_SET_VALUE)
-//            setCommitLockTimeout(config.getCommitLockTimeout());
-    }
-
-    /**
-     * Creates and configures a new GdataIndexWriter
-     * 
-     * @param arg0 -
-     *            the index directory
-     * @param arg1 -
-     *            create index
-     * @param arg2 -
-     *            the index schema configuration including all parameter to set
-     *            up the index writer
-     * @throws IOException
-     *             -if the directory cannot be read/written to, or if it does
-     *             not exist, and <code>create</code> is <code>false</code>
-     */
-    protected GDataIndexWriter(Directory arg0, boolean arg1, IndexSchema arg2)
-            throws IOException {
-        /*
-         * Use Schema Analyzer rather than service analyzer. 
-         * Schema analyzer returns either the service analyzer or a per field analyzer if configured.
-         */
-        super(arg0, (arg2 == null ? new StandardAnalyzer() : arg2.getSchemaAnalyzer()), arg1);
-        if (arg2 == null) {
-            /*
-             * if no schema throw exception - schema is mandatory for the index writer.
-             */
-            try {
-                this.close();
-            } catch (IOException e) {
-                //
-            }
-            throw new IllegalArgumentException("configuration must not be null");
-
-        }
-        this.initialize(arg2);
-    }
-
-    /**
-     * @see org.apache.lucene.index.IndexWriter#close()
-     */
-    @Override
-    public void close() throws IOException {
-        super.close();
-        LOG.info("Closing GdataIndexWriter for service " + this.serviceName);
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/GDataIndexer.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/GDataIndexer.java
deleted file mode 100755
index 7cb8885..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/GDataIndexer.java
+++ /dev/null
@@ -1,510 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.search.index;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.search.config.IndexSchema;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.index.TermDocs;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.store.Directory;
-
-/**
- * A GDataIndexer encapsulates every writing access to the search index.
- * <p>
- * Insert, updates and deletes to the index happens inside this class. All
- * modification will be base on an instance of
- * {@link org.apache.lucene.gdata.search.index.IndexDocument} which contains all
- * informations and command for the indexer.<br>
- * Although this class provides methods to add, remove and update document in
- * the index all <tt>IndexDocument</tt> instances should be added to the task
- * queue via the {@link GDataIndexer#addIndexableDocumentTask(Future)} method.
- * Inside this class runs an instance of
- * {@link org.apache.lucene.gdata.search.index.IndexTask} listening on this
- * queue. The analysis of the actual documents happens inside the
- * {@link com.sun.corba.se.impl.orbutil.closure.Future} object added to the
- * queue. This enables the indexer to do his actual work. Documents will be
- * build / analyzed concurrently while already finished tasks can be added to
- * the index.
- * </p>
- * 
- * 
- * 
- * @author Simon Willnauer
- */
-public class GDataIndexer {
-    private static final Log LOG = LogFactory.getLog(GDataIndexer.class);
-
-    protected IndexWriter writer;
-
-    protected IndexSearcher searcher;
-
-    protected AtomicInteger committed = new AtomicInteger(0);
-
-    protected AtomicInteger optimized = new AtomicInteger(0);
-
-    private AtomicBoolean isDestroyed = new AtomicBoolean(false);
-
-    protected AtomicInteger docsAdded = new AtomicInteger();
-
-    protected AtomicInteger docsUpdated = new AtomicInteger();
-
-    protected AtomicInteger docsDeleted = new AtomicInteger();
-
-    private final Directory dir;
-
-    private final List<IndexEventListener> listeners = new ArrayList<IndexEventListener>();
-
-    protected final BlockingQueue<Future<IndexDocument>> futurQueue = new LinkedBlockingQueue<Future<IndexDocument>>(
-            100);
-
-    private final IndexSchema serviceConfiguration;
-
-    private final ExecutorService indexTaskExecutor;
-
-    protected IndexTask indexTask;
-
-    private static final Integer ZERO = new Integer(0);
-
-    private static final Integer ONE = new Integer(1);
-
-    private final Map<IndexDocument, Integer> action;
-
-    protected GDataIndexer(final IndexSchema schema, Directory dir,
-            boolean create) throws IOException {
-        if (schema == null)
-            throw new IllegalArgumentException(
-                    "IndexServiceConfiguration must not be null");
-        if (dir == null)
-            throw new IllegalArgumentException(
-                    "IndexDirectory must not be null");
-
-        this.serviceConfiguration = schema;
-        this.dir = dir;
-        openWriter(create);
-        this.indexTaskExecutor = Executors.newSingleThreadExecutor();
-        this.action = new HashMap<IndexDocument, Integer>(128);
-
-    }
-
-    protected void setIndexTask(final IndexTask task) {
-        if (task != null && this.indexTask == null)
-            this.indexTask = task;
-    }
-
-    protected void init() {
-        if (this.indexTask == null)
-            this.indexTask = new IndexTask(this, this.futurQueue);
-        this.indexTaskExecutor.execute(this.indexTask);
-
-    }
-
-    /**
-     * Adds the given future task to the queue, and waits if the queue is full.
-     * The queue size is set to 100 by default.
-     * 
-     * @param task -
-     *            the task to be scheduled
-     * @throws InterruptedException -
-     *             if the queue is interrupted
-     */
-    public void addIndexableDocumentTask(final Future<IndexDocument> task)
-            throws InterruptedException {
-        if (this.isDestroyed.get())
-            throw new IllegalStateException(
-                    "Indexer has already been destroyed");
-        this.futurQueue.put(task);
-    }
-
-    /*
-     * a added doc should not be in the index, be sure and delete possible
-     * duplicates
-     */
-    protected synchronized void addDocument(IndexDocument indexable)
-            throws IOException {
-        if (!indexable.isInsert())
-            throw new GdataIndexerException(
-                    "Index action must be set to insert");
-        setAction(indexable);
-        doWrite(indexable);
-        this.docsAdded.incrementAndGet();
-
-    }
-
-    private void setAction(IndexDocument doc) {
-        Integer docCountToKeep = this.action.get(doc);
-        if (!doc.isDelete() && (docCountToKeep == null || docCountToKeep == 0)) {
-            /*
-             * add a ONE for ONE documents to keep for this IndexDocument when
-             * doDelete. doDelete will keep the latest added document and
-             * deletes all other documents for this IndexDocument e.g. all
-             * duplicates
-             */
-            this.action.put(doc, ONE);
-        } else if (doc.isDelete()
-                && (docCountToKeep == null || docCountToKeep > 0)) {
-            /*
-             * add a zero for zero documents to keep for this IndexDocument when
-             * doDelete
-             */
-            this.action.put(doc, ZERO);
-        }
-    }
-
-    protected synchronized void updateDocument(IndexDocument indexable)
-            throws IOException {
-        if (!indexable.isUpdate())
-            throw new GdataIndexerException(
-                    "Index action must be set to update");
-        setAction(indexable);
-        doWrite(indexable);
-        this.docsUpdated.incrementAndGet();
-    }
-
-    protected synchronized void deleteDocument(IndexDocument indexable) {
-        if (!indexable.isDelete())
-            throw new GdataIndexerException(
-                    "Index action must be set to delete");
-
-        setAction(indexable);
-        this.docsDeleted.incrementAndGet();
-    }
-
-    /**
-     * This method commits all changes to the index and closes all open
-     * resources (e.g. IndexWriter and IndexReader). This method notifies all
-     * registered Commit listeners if invoked.
-     * 
-     * @param optimize -
-     *            <code>true</code> if the index should be optimized on this
-     *            commit
-     * @throws IOException -
-     *             if an IOException occurs
-     */
-    protected synchronized void commit(boolean optimize) throws IOException {
-        if (LOG.isInfoEnabled())
-            LOG.info("Commit called with optimize = " + optimize);
-
-        int changes = this.docsAdded.intValue() + this.docsDeleted.intValue()
-                + this.docsUpdated.intValue();
-        /*
-         * don't call listeners to prevent unnecessary close / open of searchers
-         */
-        if (changes == 0)
-            return;
-        this.committed.incrementAndGet();
-        if(optimize)
-            this.optimized.incrementAndGet();
-        doDeltete();
-        if (optimize) {
-            closeSearcher();
-            openWriter();
-            this.writer.optimize();
-        }
-        closeSearcher();
-        closeWriter();
-        this.docsAdded.set(0);
-        this.docsDeleted.set(0);
-        this.docsUpdated.set(0);
-        notifyCommitListeners(this.serviceConfiguration.getName());
-
-    }
-
-    /**
-     * Registers a new IndexEventListener. All registered listeners will be
-     * notified if the index has been committed.
-     * 
-     * @param listener -
-     *            the listener to register
-     * 
-     */
-    public void registerIndexEventListener(IndexEventListener listener) {
-        if (listener == null || this.listeners.contains(listener))
-            return;
-        this.listeners.add(listener);
-    }
-
-    /**
-     * Removes a registered IndexEventListener
-     * 
-     * @param listener -
-     *            the listener to remove
-     */
-    public void removeIndexEventListener(IndexEventListener listener) {
-
-        if (listener == null || !this.listeners.contains(listener))
-            return;
-        this.listeners.remove(listener);
-    }
-
-    protected void notifyCommitListeners(String serviceId) {
-        if (LOG.isInfoEnabled())
-            LOG.info("notify commit event listeners for service id: "
-                    + serviceId + " --  current size of registered listeners: "
-                    + this.listeners.size());
-        for (IndexEventListener listener : this.listeners) {
-            listener.commitCallBack(serviceId);
-        }
-    }
-
-    protected void closeWriter() throws IOException {
-        try {
-            if (this.writer != null)
-                this.writer.close();
-        } finally {
-            this.writer = null;
-        }
-    }
-
-    protected void closeSearcher() throws IOException {
-        try {
-            if (this.searcher != null)
-                this.searcher.close();
-        } finally {
-            this.searcher = null;
-        }
-    }
-
-    protected void openSearcher() throws IOException {
-        if (this.searcher == null)
-            this.searcher = new IndexSearcher(this.dir);
-    }
-
-    protected void openWriter() throws IOException {
-        openWriter(false);
-    }
-
-    private void openWriter(boolean create) throws IOException {
-        if (this.writer == null)
-            this.writer = new GDataIndexWriter(this.dir, create,
-                    this.serviceConfiguration);
-    }
-
-    /*
-     * This should only be called in a synchronized block
-     */
-    protected void doWrite(IndexDocument document) throws IOException {
-        closeSearcher();
-        openWriter();
-        this.writer.addDocument(document.getWriteable());
-
-    }
-
-    // only access synchronized
-    int[] documentNumber;
-
-    /*
-     * This should only be called in a synchronized block
-     */
-    protected void doDeltete() throws IOException {
-        if (this.action.size() == 0)
-            return;
-        if (LOG.isInfoEnabled())
-            LOG
-                    .info("Deleting documents and duplicates from index, size of IndexDocuments "
-                            + this.action.size());
-        closeWriter();
-        openSearcher();
-
-        IndexReader reader = this.searcher.getIndexReader();
-        TermDocs termDocs = reader.termDocs();
-        for (Map.Entry<IndexDocument, Integer> entry : this.action.entrySet()) {
-            IndexDocument indexDocument = entry.getKey();
-            Integer docToKeep = entry.getValue();
-            // extend the array if needed
-            if (this.documentNumber == null
-                    || docToKeep > this.documentNumber.length)
-                this.documentNumber = new int[docToKeep];
-
-            for (int i = 0; i < this.documentNumber.length; i++) {
-
-                this.documentNumber[i] = -1;
-            }
-            /*
-             * get the term to find the document from the document itself
-             */
-            termDocs.seek(indexDocument.getDeletealbe());
-
-            int pos = 0;
-
-            while (termDocs.next()) {
-                /*
-                 * if this is a pure delete just delete it an continue
-                 */
-                if (docToKeep == 0) {
-                    reader.deleteDocument(termDocs.doc());
-                    continue;
-                }
-
-                int prev = this.documentNumber[pos];
-                this.documentNumber[pos] = termDocs.doc();
-                if (prev != -1) {
-                    reader.deleteDocument(prev);
-                }
-
-                if (++pos >= docToKeep)
-                    pos = 0;
-
-            }
-        }
-        /*
-         * clear the map after all documents are processed
-         */
-        this.action.clear();
-        closeSearcher();
-    }
-
-    protected synchronized void destroy() throws IOException {
-        this.isDestroyed.set(true);
-        if (!this.indexTask.isStopped())
-            this.indexTask.stop();
-        this.futurQueue.add(new FinishingFuture());
-        this.indexTaskExecutor.shutdown();
-        closeWriter();
-        closeSearcher();
-        if (LOG.isInfoEnabled())
-            LOG.info("Destroying GdataIndexer for service -- "
-                    + this.serviceConfiguration.getName());
-
-    }
-
-    /**
-     * This factory method creates a new GDataIndexer using a instance of
-     * {@link IndexTask}
-     * 
-     * @param config -
-     *            the config to be used to configure the indexer
-     * @param dir -
-     *            the directory to index to
-     * @param create -
-     *            <code>true</code> to create a new index, <code>false</code>
-     *            to use the existing one.
-     * @return - a new GDataIndexer instance
-     * @throws IOException -
-     *             if an IOException occurs while initializing the indexer
-     */
-    public static synchronized GDataIndexer createGdataIndexer(
-            final IndexSchema config, Directory dir, boolean create)
-            throws IOException {
-        GDataIndexer retVal = new GDataIndexer(config, dir, create);
-        retVal.setIndexTask(new IndexTask(retVal, retVal.futurQueue));
-        retVal.init();
-        return retVal;
-    }
-
-    /**
-     * This factory method creates a new GDataIndexer using a instance of
-     * {@link TimedIndexTask}. This indexer will automatically commit the index
-     * if no modification to the index occur for the given time. The used time
-     * unit is {@link TimeUnit#SECONDS}. Values less than the default value
-     * will be ignored. For the default value see {@link TimedIndexTask}.
-     * 
-     * @param config -
-     *            the config to be used to configure the indexer
-     * @param dir -
-     *            the directory to index to
-     * @param create -
-     *            <code>true</code> to create a new index, <code>false</code>
-     *            to use the existing one.
-     * @param commitTimeout -
-     *            the amount of seconds to wait until a commit should be
-     *            scheduled
-     * @return - a new GDataIndexer instance
-     * @throws IOException -
-     *             if an IOException occurs while initializing the indexer
-     */
-    public static synchronized GDataIndexer createTimedGdataIndexer(
-            final IndexSchema config, Directory dir, boolean create,
-            long commitTimeout) throws IOException {
-
-        GDataIndexer retVal = new GDataIndexer(config, dir, create);
-        retVal.setIndexTask(new TimedIndexTask(retVal, retVal.futurQueue,
-                commitTimeout));
-        retVal.init();
-        return retVal;
-    }
-
-    @SuppressWarnings("unused")
-    static final class FinishingFuture implements Future<IndexDocument> {
-
-        /**
-         * @see java.util.concurrent.Future#cancel(boolean)
-         */
-        public boolean cancel(boolean arg0) {
-
-            return false;
-        }
-
-        /**
-         * @see java.util.concurrent.Future#isCancelled()
-         */
-        public boolean isCancelled() {
-
-            return false;
-        }
-
-        /**
-         * @see java.util.concurrent.Future#isDone()
-         */
-        public boolean isDone() {
-
-            return true;
-        }
-
-        /**
-         * @see java.util.concurrent.Future#get()
-         */
-        @SuppressWarnings("unused")
-        public IndexDocument get() throws InterruptedException,
-                ExecutionException {
-
-            return null;
-        }
-
-        /**
-         * @see java.util.concurrent.Future#get(long,
-         *      java.util.concurrent.TimeUnit)
-         */
-        @SuppressWarnings("unused")
-        public IndexDocument get(long arg0, TimeUnit arg1)
-                throws InterruptedException, ExecutionException,
-                TimeoutException {
-
-            return null;
-        }
-
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/GdataIndexerException.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/GdataIndexerException.java
deleted file mode 100755
index 037b8f8..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/GdataIndexerException.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.search.index;
-
-/**
- * This exception will be thrown if an exception in the indexing component
- * occurs
- * 
- * @author Simon Willnauer
- * 
- */
-public class GdataIndexerException extends RuntimeException {
-
-    private static final long serialVersionUID = -8245420079471690182L;
-
-    /**
-     * Creates a new GdataIndexerException
-     */
-    public GdataIndexerException() {
-        super();
-
-    }
-
-    /**
-     * Creates a new GdataIndexerException with a new exception message
-     * 
-     * @param arg0 -
-     *            exception message
-     */
-    public GdataIndexerException(String arg0) {
-        super(arg0);
-
-    }
-
-    /**
-     * Creates a new GdataIndexerException with a new exception message and a
-     * root cause
-     * 
-     * @param arg0 -
-     *            exception message
-     * @param arg1 -
-     *            the root cause
-     */
-    public GdataIndexerException(String arg0, Throwable arg1) {
-        super(arg0, arg1);
-
-    }
-
-    /**
-     * Creates a new GdataIndexerException with a root cause
-     * 
-     * @param arg0 -
-     *            the root cause
-     */
-    public GdataIndexerException(Throwable arg0) {
-        super(arg0);
-
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/IndexAction.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/IndexAction.java
deleted file mode 100755
index 55c17ed..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/IndexAction.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.search.index;
-
-/**
- * This enum defines all possible actions on a GData index.
- * 
- * @see org.apache.lucene.gdata.search.index.IndexDocument
- * @see org.apache.lucene.gdata.search.index.IndexDocumentBuilderTask
- * @author Simon Willnauer
- * 
- */
-public enum IndexAction {
-    /**
-     * update action
-     */
-    UPDATE, /**
-             * delete action
-             */
-    DELETE, /**
-             * insert / add action
-             */
-    INSERT
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/IndexController.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/IndexController.java
deleted file mode 100755
index 5fad024..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/IndexController.java
+++ /dev/null
@@ -1,547 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.search.index;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.Collection;
-import java.util.Map;
-import java.util.Set;
-import java.util.Map.Entry;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReentrantLock;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.data.ServerBaseEntry;
-import org.apache.lucene.gdata.data.ServerBaseFeed;
-import org.apache.lucene.gdata.search.GDataSearcher;
-import org.apache.lucene.gdata.search.SearchComponent;
-import org.apache.lucene.gdata.search.StandardGdataSearcher;
-import org.apache.lucene.gdata.search.config.IndexSchema;
-import org.apache.lucene.gdata.server.registry.Component;
-import org.apache.lucene.gdata.server.registry.ComponentType;
-import org.apache.lucene.gdata.server.registry.EntryEventListener;
-import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
-import org.apache.lucene.gdata.server.registry.ProvidedService;
-import org.apache.lucene.gdata.utils.ReferenceCounter;
-import org.apache.lucene.index.IndexFileNameFilter;
-import org.apache.lucene.search.Filter;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.FSDirectory;
-
-/**
- * Default implementation of the {@link SearchComponent} interface. All actions
- * on the index will be controlled from this class. Only this class grants read
- * or write actions access to the index.
- * 
- * @author Simon Willnauer
- * 
- */
-@Component(componentType = ComponentType.SEARCHCONTROLLER)
-public class IndexController implements SearchComponent, IndexEventListener,
-        EntryEventListener {
-    static final Log LOG = LogFactory.getLog(IndexController.class);
-
-    private final AtomicBoolean isInitialized = new AtomicBoolean(false);
-
-    private final AtomicBoolean destroyed = new AtomicBoolean(false);
-
-    protected Map<String, ServiceIndex> indexerMap;
-
-    private final ExecutorService taskExecutor;
-
-    /**
-     * Creates a new IndexController -- call
-     * {@link IndexController#initialize()} to set up the controller.
-     */
-    public IndexController() {
-        this.taskExecutor = Executors.newCachedThreadPool();
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.search.SearchComponent#initialize()
-     */
-    public synchronized void initialize() {
-        if (this.isInitialized.get())
-            throw new IllegalStateException(
-                    "IndexController is already initialized");
-        this.destroyed.set(false);
-        /*
-         * if this fails the server must not startup --> throw runtime exception
-         */
-        GDataServerRegistry.getRegistry().registerEntryEventListener(this);
-
-        GDataServerRegistry.getRegistry().registerEntryEventListener(this);
-        Collection<ProvidedService> services = GDataServerRegistry
-                .getRegistry().getServices();
-        this.indexerMap = new ConcurrentHashMap<String, ServiceIndex>(services
-                .size());
-       
-        for (ProvidedService service : services) {
-            IndexSchema schema = service.getIndexSchema();
-            /*
-             * initialize will fail if mandatory values are not set. This is
-             * just a
-             */
-            schema.initialize();
-            addIndexSchema(schema);
-        }
-        this.isInitialized.set(true);
-        
-
-    }
-
-    /*
-     * add a schema to the index controller and create the indexer. create
-     * directories and check out existing indexes
-     */
-    protected void addIndexSchema(final IndexSchema schema) {
-        checkDestroyed();
-        if (schema.getName() == null)
-            throw new IllegalStateException(
-                    "schema has no name -- is not associated with any service");
-        if (this.indexerMap.containsKey(schema.getName()))
-            throw new IllegalStateException("schema for service "
-                    + schema.getName() + " is already registered");
-        if (LOG.isInfoEnabled())
-            LOG.info("add new IndexSchema for service " + schema.getName()
-                    + " -- " + schema);
-        try {
-            ServiceIndex bean = createIndexer(schema);
-            ReferenceCounter<IndexSearcher> searcher = getNewServiceSearcher(bean.getDirectory());
-            bean.setSearcher(searcher);
-            this.indexerMap.put(schema.getName(), bean);
-        } catch (IOException e) {
-            LOG.error("Can not create indexer for service " + schema.getName(),
-                    e);
-            throw new GdataIndexerException(
-                    "Can not create indexer for service " + schema.getName(), e);
-        }
-
-    }
-
-    protected ServiceIndex createIndexer(final IndexSchema schema) throws IOException {
-        GDataIndexer indexer;
-        File indexLocation = createIndexLocation(schema.getIndexLocation(),
-                schema.getName());
-        boolean create = createIndexDirectory(indexLocation);
-        Directory dir = FSDirectory.getDirectory(indexLocation, create);
-        if (LOG.isInfoEnabled())
-            LOG.info("Create new Indexer for IndexSchema: " + schema);
-        /*
-         * timed or committed indexer?! keep the possibility to let users decide
-         * to use scheduled commits
-         */
-        if (schema.isUseTimedIndexer())
-            indexer = GDataIndexer.createTimedGdataIndexer(schema, dir, create,
-                    schema.getIndexerIdleTime());
-        else
-            indexer = GDataIndexer.createGdataIndexer(schema, dir, create);
-        indexer.registerIndexEventListener(this);
-        return new ServiceIndex(schema, indexer, dir);
-    }
-
-    /*
-     * if this fails the server must not startup!!
-     */
-    protected File createIndexLocation(final String path,final  String name) {
-        if (path == null || name == null)
-            throw new GdataIndexerException(
-                    "Path or Name of the index location is not set Path: "
-                            + path + " name: " + name);
-        /*
-         * check if parent e.g. the configured path is a directory
-         */
-        File parent = new File(path);
-        if (!parent.isDirectory())
-            throw new IllegalArgumentException(
-                    "the given path is not a directory -- " + path);
-        /*
-         * try to create and throw ex if fail
-         */
-        if (!parent.exists())
-            if (!parent.mkdir())
-                throw new RuntimeException("Can not create directory -- "
-                        + path);
-        /*
-         * try to create and throw ex if fail
-         */
-        File file = new File(parent, name);
-        if (file.isFile())
-            throw new IllegalArgumentException(
-                    "A file with the name"
-                            + name
-                            + " already exists in "
-                            + path
-                            + " -- a file of the name of the service must not exist in the index location");
-
-        if (!file.exists()) {
-            if (!file.mkdir())
-                throw new RuntimeException("Can not create directory -- "
-                        + file.getAbsolutePath());
-        }
-        return file;
-    }
-
-    protected boolean createIndexDirectory(final File file) {
-        /*
-         * use a lucene filename filter to figure out if there is an existing
-         * index in the defined directory
-         */
-        String[] luceneFiles = file.list(new IndexFileNameFilter());
-        return !(luceneFiles.length > 0);
-
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.search.index.IndexEventListener#commitCallBack(java.lang.String)
-     */
-    public synchronized void commitCallBack(final String service) {
-        checkDestroyed();
-        if(LOG.isInfoEnabled())
-            LOG.info("CommitCallback triggered - register new searcher for service: "+service);
-        /*
-         * get the old searcher and replace it if possible.
-         */
-        ServiceIndex index = this.indexerMap.get(service);
-        ReferenceCounter<IndexSearcher> searcher = index.getSearcher();
-
-        try {
-            index.setSearcher(getNewServiceSearcher(index.getDirectory()));
-        } catch (IOException e) {
-            LOG.fatal("Can not create new Searcher -- keep the old one ", e);
-            return;
-        }
-        /*
-         * if new searcher if registered decrement old one to get it destroyed if unused
-         */
-        searcher.decrementRef();
-    }
-    /*
-     * create a new ReferenceCounter for the indexSearcher.
-     * The reference is already incremented before returned
-     */
-    private ReferenceCounter<IndexSearcher> getNewServiceSearcher(final Directory dir)
-            throws IOException {
-        if(LOG.isInfoEnabled())
-            LOG.info("Create new ServiceSearcher");
-        IndexSearcher searcher = new IndexSearcher(dir);
-        ReferenceCounter<IndexSearcher> holder = new ReferenceCounter<IndexSearcher>(
-                searcher) {
-
-            @Override
-            protected void close() {
-                try {
-                    LOG
-                            .info("Close IndexSearcher -- Zero references remaining");
-                    this.resource.close();
-                } catch (IOException e) {
-                    LOG.warn("Can not close IndexSearcher -- ", e);
-                }
-            }
-
-        };
-        holder.increamentReference();
-        return holder;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.registry.EntryEventListener#fireUpdateEvent(org.apache.lucene.gdata.data.ServerBaseEntry)
-     */
-    public void fireUpdateEvent(final ServerBaseEntry entry) {
-        createNewIndexerTask(entry, IndexAction.UPDATE);
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.registry.EntryEventListener#fireInsertEvent(org.apache.lucene.gdata.data.ServerBaseEntry)
-     */
-    public void fireInsertEvent(final ServerBaseEntry entry) {
-        createNewIndexerTask(entry, IndexAction.INSERT);
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.registry.EntryEventListener#fireDeleteEvent(org.apache.lucene.gdata.data.ServerBaseEntry)
-     */
-    public void fireDeleteEvent(final ServerBaseEntry entry) {
-        createNewIndexerTask(entry, IndexAction.DELETE);
-
-    }
-    
-    /**
-     * @see org.apache.lucene.gdata.server.registry.EntryEventListener#fireDeleteAllEntries(org.apache.lucene.gdata.data.ServerBaseFeed)
-     */
-    public void fireDeleteAllEntries(final ServerBaseFeed feed) {
-        createNewDeleteAllEntriesTask(feed);
-    }
-    
-    private void createNewDeleteAllEntriesTask(final ServerBaseFeed feed){
-        checkDestroyed();
-        checkInitialized();
-        if(LOG.isInfoEnabled())
-            LOG.info("Deleting all entries for feed dispatch new IndexDocumentBuilder -- "+feed.getId());
-        String serviceName = feed.getServiceConfig().getName();
-        ServiceIndex bean = this.indexerMap.get(serviceName);
-        if (bean == null)
-            throw new RuntimeException("no indexer for service " + serviceName
-                    + " registered");
-        Lock lock = bean.getLock();
-        lock.lock();
-        try{
-            IndexDocumentBuilder<IndexDocument> callable = new IndexFeedDeleteTask(feed.getId());
-            sumbitTask(callable,bean.getIndexer());
-        }finally{
-            lock.unlock();
-        }
-            
-        
-    }
-
-    // TODO add test for this method!!
-    private void createNewIndexerTask(final ServerBaseEntry entry, final IndexAction action) {
-        checkDestroyed();
-        checkInitialized();
-        String serviceName = entry.getServiceConfig().getName();
-        if (LOG.isInfoEnabled())
-            LOG.info("New Indexer Task submitted - Action: " + action
-                    + " for service: " + serviceName);
-        ServiceIndex bean = this.indexerMap.get(serviceName);
-        if (bean == null)
-            throw new RuntimeException("no indexer for service " + serviceName
-                    + " registered");
-        /*
-         * lock on service to synchronize the event order. This lock has
-         * fairness parameter set to true. Grant access to the longest waiting
-         * thread. Using fairness is slower but is acceptable in this context
-         */
-        Lock lock = bean.getLock();
-        lock.lock();
-        try {
-            IndexSchema schema = bean.getSchema();
-            boolean commitAfter = bean.incrementActionAndReset(schema.getCommitAfterDocuments());
-            IndexDocumentBuilder<IndexDocument> callable = new IndexDocumentBuilderTask<IndexDocument>(
-                    entry, bean.getSchema(), action, commitAfter,bean.getOptimize(schema.getOptimizeAfterCommit()));
-            sumbitTask(callable,bean.getIndexer());
-        } finally {
-            /*
-             * make sure to unlock
-             */
-            lock.unlock();
-        }
-
-    }
-
-    private void sumbitTask(final Callable<IndexDocument> callable, final GDataIndexer indexer){
-        Future<IndexDocument> task = this.taskExecutor.submit(callable);
-        try {
-            indexer.addIndexableDocumentTask(task);
-        } catch (InterruptedException e) {
-            throw new GdataIndexerException(
-                    "Can not accept any index tasks -- interrupted. ", e);
-
-        }
-    }    
-
-    /**
-     * @see org.apache.lucene.gdata.search.SearchComponent#getServiceSearcher(org.apache.lucene.gdata.server.registry.ProvidedService)
-     */
-    public GDataSearcher<String> getServiceSearcher(final ProvidedService service) {
-        checkDestroyed();
-        checkInitialized();
-
-        /*
-         * get and increment. searcher will be decremented if GdataSearcher is
-         * closed
-         */
-        ReferenceCounter<IndexSearcher> searcher;
-        synchronized (this) {
-            ServiceIndex serviceIndex = this.indexerMap.get(service.getName());
-            if(serviceIndex == null)
-                throw new RuntimeException("no index for service "+service.getName());
-            searcher = serviceIndex.getSearcher();
-            searcher.increamentReference();
-        }
-
-        return new StandardGdataSearcher(searcher);
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.search.SearchComponent#destroy()
-     */
-    public synchronized void destroy() {
-        checkDestroyed();
-        if(!this.isInitialized.get())
-            return;
-        this.destroyed.set(true);
-        this.isInitialized.set(false);
-        LOG.info("Shutting down IndexController -- destroy has been called");
-        Set<Entry<String, ServiceIndex>> entrySet = this.indexerMap.entrySet();
-        for (Entry<String, ServiceIndex> entry : entrySet) {
-            ServiceIndex bean = entry.getValue();
-            bean.getSearcher().decrementRef();
-            GDataIndexer indexer = bean.getIndexer();
-            try {
-                indexer.destroy();
-            } catch (IOException e) {
-                LOG.warn("Can not destroy indexer for service: "
-                        + bean.getSchema().getName(), e);
-            }
-        }
-        this.taskExecutor.shutdown();
-        this.indexerMap.clear();
-    }
-
-    private void checkDestroyed(){
-        if (this.destroyed.get())
-            throw new IllegalStateException(
-                    "IndexController has been destroyed");   
-    }
-    private void checkInitialized(){
-        if(!this.isInitialized.get())
-            throw new IllegalStateException(
-            "IndexController has not been initialized");
-    }   
-    
-    
-    final static class ServiceIndex {
-        private AtomicInteger actionCount = new AtomicInteger(0);
-        
-        private AtomicInteger commitCount = new AtomicInteger(0);
-        
-        private final Lock lock;
-
-        private final IndexSchema schema;
-
-        private final GDataIndexer indexer;
-
-        private final Directory directory;
-        
-        private Filter addedDocumentFilter;
-        
-        private ReferenceCounter<IndexSearcher> searcher;
-
-        // private final Map<String,IndexAction> actionMap;
-
-       
-
-        ServiceIndex(final IndexSchema schema, GDataIndexer indexer,
-                Directory directory) {
-            this.schema = schema;
-            this.indexer = indexer;
-            this.lock = new ReentrantLock(true);
-            this.directory = directory;
-            // this.actionMap = new HashMap<String,IndexAction>(128);
-        }
-
-        Lock getLock() {
-            return this.lock;
-        }
-
-        /**
-         * @return Returns the indexer.
-         */
-        GDataIndexer getIndexer() {
-            return this.indexer;
-        }
-
-        /**
-         * @return Returns the schema.
-         */
-        IndexSchema getSchema() {
-            return this.schema;
-        }
-
-        // public void addAction(IndexAction action,ServerBaseEntry entry){
-        //            
-        // }
-        /**
-         * Counts how many actions have been executed on this index
-         * 
-         * @param reset - count mod reset value equals 0 causes a commit
-         *            
-         * @return <code>true</code> if the count mod reset value equals 0, otherwise
-         *         false;
-         */
-        boolean incrementActionAndReset(int reset) {
-            if (this.actionCount.incrementAndGet()%reset == 0) {
-                return true;
-            }
-            return false;
-        }
-
-        /**
-         * @return Returns the directory.
-         */
-        public Directory getDirectory() {
-            return this.directory;
-        }
-        /**
-         * @return Returns the addedDocumentFilter.
-         */
-        public Filter getAddedDocumentFilter() {
-            return this.addedDocumentFilter;
-        }
-
-        /**
-         * @param addedDocumentFilter The addedDocumentFilter to set.
-         */
-        public void setAddedDocumentFilter(Filter addedDocumentFilter) {
-            this.addedDocumentFilter = addedDocumentFilter;
-        }
-
-        /**
-         * @return Returns the searcher.
-         */
-        public ReferenceCounter<IndexSearcher> getSearcher() {
-            return this.searcher;
-        }
-
-        /**
-         * @param searcher The searcher to set.
-         */
-        public void setSearcher(ReferenceCounter<IndexSearcher> searcher) {
-            this.searcher = searcher;
-        }
-
-        /**
-         * @return Returns the commitCount.
-         */
-        public int commitCountIncrement() {
-            return this.commitCount.incrementAndGet();
-        }
-        /**
-         * @param reset - the number after how many commits the index should be optimized
-         * @return <code>true</code> if and only if the commit count mod reset equals 0, otherwise <code>false</code>.
-         */
-        public boolean getOptimize(int reset){
-            if(this.commitCount.get()%reset == 0){
-                return true;
-            }
-            return false;
-        }
-    }
-
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/IndexDocument.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/IndexDocument.java
deleted file mode 100755
index feee6c5..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/IndexDocument.java
+++ /dev/null
@@ -1,100 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.search.index;
-
-import org.apache.lucene.document.Document;
-import org.apache.lucene.index.Term;
-
-/**
- * IndexDocument encapsulates the acual entity to store, update or delete. All
- * infomation to process the action on this document are provided via this
- * interface.
- * <p>
- * This enables the GDataIndexer to index every kind of document. All the
- * processing of the original document happens somewhere behind this facade.
- * {@link org.apache.lucene.gdata.search.index.IndexDocumentBuilderTask} passed
- * to the {@link org.apache.lucene.gdata.search.index.GDataIndexer} task queue
- * produce instances of this interface concurrently.
- * </p>
- * 
- * @author Simon Willnauer
- * 
- * 
- */
-public interface IndexDocument {
-    /**
-     * the index field to identify a document in the index. This acts as a
-     * primary key to fetch the entire entry from the storage
-     */
-    public static final String FIELD_ENTRY_ID = "enryId";
-    /**
-     * the index field to associate a document with a specific feed 
-     */
-    public static final String FIELD_FEED_ID = "feedId";
-    public static final String GDATA_MANDATORY_FIELD_UPDATED = "updated";
-    public static final String GDATA_MANDATORY_FIELD_CATEGORY = "category";
-
-    /**
-     * @return <code>true</code> if and only if this document is an update,
-     *         otherwise <code>false</code>
-     */
-    public abstract boolean isUpdate();
-
-    /**
-     * @return <code>true</code> if and only if this document is a delete,
-     *         otherwise <code>false</code>
-     */
-    public abstract boolean isDelete();
-
-    /**
-     * @return <code>true</code> if and only if this document is an insert,
-     *         otherwise <code>false</code>
-     */
-    public abstract boolean isInsert();
-
-    /**
-     * 
-     * @return - the lucene document to write to the index if the action is
-     *         insert or updated, otherwise it will return <code>null</code>;
-     */
-    public abstract Document getWriteable();
-
-    /**
-     * @return - a term that identifies this document in the index to delete
-     *         this document on a update or delete
-     */
-    public abstract Term getDeletealbe();
-
-    /**
-     * Indicates that the index should be commited after this document has been
-     * processed
-     * 
-     * @return <code>true</code> if the index should be commited after this
-     *         document, otherwise <code>false</code>
-     */
-    public abstract boolean commitAfter();
-
-    /**
-     * Indicates that the index should be optimized after this document has been
-     * processed
-     * 
-     * 
-     * @return <code>true</code> if the index should be optimized after this
-     *         document, otherwise <code>false</code>
-     */
-    public abstract boolean optimizeAfter();
-    
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/IndexDocumentBuilder.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/IndexDocumentBuilder.java
deleted file mode 100755
index 77df6ae..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/IndexDocumentBuilder.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.search.index;
-
-import java.util.concurrent.Callable;
-
-/**
- * Interface for DocumentBuilders
- * @author Simon Willnauer
- * @param <T> IndexDocument implementation
- *
- */
-public interface IndexDocumentBuilder<T extends IndexDocument> extends Callable<T>{
-    /**
-     * @see java.util.concurrent.Callable#call()
-     */
-    public T call() throws GdataIndexerException; 
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/IndexDocumentBuilderTask.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/IndexDocumentBuilderTask.java
deleted file mode 100755
index 75e0690..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/IndexDocumentBuilderTask.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.search.index;
-
-import java.util.Collection;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.data.ServerBaseEntry;
-import org.apache.lucene.gdata.search.analysis.ContentStrategy;
-import org.apache.lucene.gdata.search.analysis.Indexable;
-import org.apache.lucene.gdata.search.analysis.NotIndexableException;
-import org.apache.lucene.gdata.search.config.IndexSchema;
-import org.apache.lucene.gdata.search.config.IndexSchemaField;
-
-/**
- * This callable does all of the entiti processing concurrently while added to
- * the {@link org.apache.lucene.gdata.search.index.GDataIndexer} task queue;
- * 
- * @see org.apache.lucene.gdata.search.analysis.Indexable
- * @see org.apache.lucene.gdata.search.analysis.ContentStrategy
- * @author Simon Willnauer
- * 
- */
-class IndexDocumentBuilderTask<T extends IndexDocument> implements IndexDocumentBuilder<T> {
-    private static final Log LOG = LogFactory
-            .getLog(IndexDocumentBuilderTask.class);
-
-    private final ServerBaseEntry entry;
-
-    private final IndexSchema schema;
-
-    private final IndexAction action;
-
-    private final boolean commitAfter;
-    private final boolean optimizeAfter;
-    protected IndexDocumentBuilderTask(final ServerBaseEntry entry,
-            final IndexSchema schema, IndexAction action, boolean commitAfter, boolean optimizeAfter) {
-        /*
-         * omit check for null parameter this happens in the controller.
-         */
-        this.schema = schema;
-        this.entry = entry;
-        this.action = action;
-        this.commitAfter = commitAfter;
-        this.optimizeAfter = optimizeAfter;
-    }
-
-    /**
-     * @see java.util.concurrent.Callable#call()
-     */
-    @SuppressWarnings("unchecked")
-    public T call() throws GdataIndexerException {
-        
-        Collection<IndexSchemaField> fields = this.schema.getFields();
-        GDataIndexDocument document = new GDataIndexDocument(this.action,
-                this.entry.getId(),this.entry.getFeedId(), this.commitAfter,this.optimizeAfter);
-        if(this.action != IndexAction.DELETE){
-        int addedFields = 0;
-        for (IndexSchemaField field : fields) {
-            /*
-             * get the strategy to process the field
-             */
-            ContentStrategy strategy = ContentStrategy.getFieldStrategy(field);
-            if (LOG.isInfoEnabled())
-                LOG.info("Process indexable for " + field);
-            try {
-                /*
-                 * get the indexable via the factory method to enable new /
-                 * different implementation of the interface (this could be a
-                 * faster dom impl e.g. dom4j)
-                 */
-                strategy.processIndexable(Indexable.getIndexable(this.entry));
-                addedFields++;
-            } catch (NotIndexableException e) {
-                LOG.warn("Can not create field for " + field+" field will be skipped -- reason: ", e);
-                continue;
-            }
-         
-            document.addField(strategy);
-
-        }
-        if(addedFields == 0)
-            throw new GdataIndexerException("No field added to document for Schema: "+this.schema); 
-        }
-        return (T)document;
-    }
-
-    
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/IndexEventListener.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/IndexEventListener.java
deleted file mode 100755
index 249ecaf..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/IndexEventListener.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.search.index;
-
-/**
- * This interface should be implemented by classes need to be notified when an
- * index is commited
- * 
- * @author Simon Willnauer
- * 
- */
-public interface IndexEventListener {
-
-    /**
-     * This method will be invoked by an instance of {@link GDataIndexer} if the
-     * index is commited
-     * 
-     * @param service -
-     *            the name of the service the invoking indexer runs for
-     */
-    public abstract void commitCallBack(String service);
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/IndexFeedDeleteTask.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/IndexFeedDeleteTask.java
deleted file mode 100755
index 5e8fec2..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/IndexFeedDeleteTask.java
+++ /dev/null
@@ -1,140 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.search.index;
-
-import org.apache.lucene.document.Document;
-import org.apache.lucene.index.Term;
-
-/**
- * This IndexDocumentBuilder deletes a entire feed form the index the builder is
- * passed to if the feed has any entries in the search index. Each created and
- * passed IndexFeedDeleteTask forces a commit.
- * 
- * @author Simon Willnauer
- * 
- */
-public class IndexFeedDeleteTask implements IndexDocumentBuilder<IndexDocument> {
-    private final String feedId;
-
-    IndexFeedDeleteTask(String feedId) {
-        if (feedId == null)
-            throw new IllegalArgumentException("feedId must not be null");
-        this.feedId = feedId;
-
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.search.index.IndexDocumentBuilder#call()
-     */
-    public IndexDocument call() throws GdataIndexerException {
-        return new FeedDeleteDocument(this.feedId);
-        
-    }
-
-    private static class FeedDeleteDocument implements IndexDocument {
-        private final Term deleteTerm;
-
-        FeedDeleteDocument(String feedId) {
-            this.deleteTerm = new Term(FIELD_FEED_ID, feedId);
-        }
-
-        /**
-         * @see org.apache.lucene.gdata.search.index.IndexDocument#isUpdate()
-         */
-        public boolean isUpdate() {
-
-            return false;
-        }
-
-        /**
-         * @see org.apache.lucene.gdata.search.index.IndexDocument#isDelete()
-         */
-        public boolean isDelete() {
-
-            return true;
-        }
-
-        /**
-         * @see org.apache.lucene.gdata.search.index.IndexDocument#isInsert()
-         */
-        public boolean isInsert() {
-
-            return false;
-        }
-
-        /**
-         * @see org.apache.lucene.gdata.search.index.IndexDocument#getWriteable()
-         */
-        public Document getWriteable() {
-
-            return null;
-        }
-
-        /**
-         * @see org.apache.lucene.gdata.search.index.IndexDocument#getDeletealbe()
-         */
-        public Term getDeletealbe() {
-
-            return this.deleteTerm;
-        }
-
-        /**
-         * @see org.apache.lucene.gdata.search.index.IndexDocument#commitAfter()
-         */
-        public boolean commitAfter() {
-            /*
-             * force commit after delete a entire feed and its entries
-             */
-            return true;
-        }
-
-        /**
-         * @see org.apache.lucene.gdata.search.index.IndexDocument#optimizeAfter()
-         */
-        public boolean optimizeAfter() {
-
-            return false;
-        }
-
-    }
-
-    /**
-     * @see java.lang.Object#equals(java.lang.Object)
-     */
-    @Override
-    public boolean equals(Object obj) {
-        if(obj == null)
-            return false;
-        if (obj instanceof IndexFeedDeleteTask) {
-            IndexFeedDeleteTask other = (IndexFeedDeleteTask) obj;
-            return this.feedId.equals(other.feedId);
-            
-        }
-        return false;
-    }
-
-    /**
-     * @see java.lang.Object#hashCode()
-     */
-    @Override
-    public int hashCode() {
-        
-        return this.feedId.hashCode();
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/IndexLogReader.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/IndexLogReader.java
deleted file mode 100755
index 1dfa608..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/IndexLogReader.java
+++ /dev/null
@@ -1,169 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.search.index;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.Map;
-
-import org.xml.sax.Attributes;
-import org.xml.sax.ContentHandler;
-import org.xml.sax.InputSource;
-import org.xml.sax.Locator;
-import org.xml.sax.SAXException;
-import org.xml.sax.XMLReader;
-import org.xml.sax.helpers.XMLReaderFactory;
-
-/**
- * @author Simon Willnauer
- * 
- */
-class IndexLogReader {
-
-     static Map<String,IndexAction> readIndexLog(File indexLogFile, Map<String,IndexAction> contentMap) throws SAXException,IOException{
-        XMLReader reader = XMLReaderFactory.createXMLReader();
-        
-        Map<String, IndexAction> logContent = contentMap;
-        if(logContent == null)
-            logContent = new HashMap<String,IndexAction>(64);
-        
-        reader.setContentHandler(new IndexLogContentHandler(logContent));
-        InputSource source = new InputSource(new FileInputStream(indexLogFile));
-        try{
-        reader.parse(source);
-        }catch (SAXException e) {
-            /*
-             * try to append the Root element end
-             * this happens if the server crashes.
-             * If it dies while writing an entry the log file has to be fixed manually
-             */
-            IndexLogWriter.tryCloseRoot(indexLogFile);
-            source = new InputSource(new FileInputStream(indexLogFile));
-            reader.parse(source);
-        }
-        return logContent;
-    }
-    
-
-    private static class IndexLogContentHandler implements ContentHandler {
-        private final Map<String, IndexAction> logContent;
-        private String currentID;
-        private String currentAction;
-        private boolean isId;
-        private boolean isAction;
-        IndexLogContentHandler(final Map<String, IndexAction> content) {
-            this.logContent = content;
-        }
-
-        /**
-         * @see org.xml.sax.ContentHandler#setDocumentLocator(org.xml.sax.Locator)
-         */
-        public void setDocumentLocator(Locator locator) {
-        }
-
-        /**
-         * @see org.xml.sax.ContentHandler#startDocument()
-         */
-        public void startDocument() throws SAXException {
-        }
-
-        /**
-         * @see org.xml.sax.ContentHandler#endDocument()
-         */
-        public void endDocument() throws SAXException {
-        }
-
-        /**
-         * @see org.xml.sax.ContentHandler#startPrefixMapping(java.lang.String, java.lang.String)
-         */
-        public void startPrefixMapping(String prefix, String uri)
-                throws SAXException {
-        }
-
-        /**
-         * @see org.xml.sax.ContentHandler#endPrefixMapping(java.lang.String)
-         */
-        public void endPrefixMapping(String prefix) throws SAXException {
-        }
-
-        /**
-         * @see org.xml.sax.ContentHandler#startElement(java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes)
-         */
-        public void startElement(String uri, String localName, String qName,
-                Attributes atts) throws SAXException {
-            if(localName.equals("entryid")){
-                this.isId = true;
-            }else if(localName.equals("action")){
-                this.isAction = true;
-            }
-        }
-
-        /**
-         * @see org.xml.sax.ContentHandler#endElement(java.lang.String, java.lang.String, java.lang.String)
-         */
-        public void endElement(String uri, String localName, String qName)
-                throws SAXException {
-            if(localName.equals("entryid")){
-                this.isId = false;
-            }else if(localName.equals("action")){
-                this.isAction = false;
-            }else if(localName.equals("indexentry")){
-                this.logContent.put(this.currentID,IndexAction.valueOf(this.currentAction));
-            }
-        }
-
-        /**
-         * @see org.xml.sax.ContentHandler#characters(char[], int, int)
-         */
-        public void characters(char[] ch, int start, int length)
-                throws SAXException {
-            if(this.isId)
-                this.currentID = new String(ch,start,length);
-            if(this.isAction)
-                this.currentAction = new String(ch,start,length);
-            
-        }
-
-        /**
-         * @see org.xml.sax.ContentHandler#ignorableWhitespace(char[], int, int)
-         */
-        public void ignorableWhitespace(char[] ch, int start, int length)
-                throws SAXException {
-        }
-
-        /**
-         * @see org.xml.sax.ContentHandler#processingInstruction(java.lang.String, java.lang.String)
-         */
-        public void processingInstruction(String target, String data)
-                throws SAXException {
-        }
-
-        /**
-         * @see org.xml.sax.ContentHandler#skippedEntity(java.lang.String)
-         */
-        public void skippedEntity(String name) throws SAXException {
-        }
-        
-        
-
-    }
-    
-   
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/IndexLogWriter.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/IndexLogWriter.java
deleted file mode 100755
index 54e53c4..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/IndexLogWriter.java
+++ /dev/null
@@ -1,113 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.search.index;
-
-import java.io.BufferedWriter;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.OutputStreamWriter;
-import java.io.RandomAccessFile;
-import java.util.concurrent.atomic.AtomicBoolean;
-
-/**
- * @author Simon Willnauer
- * 
- */
-class IndexLogWriter {
-    private static final String LINE_BREAK = System
-            .getProperty("line.separator");
-
-    private static final String XMLHEADER = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
-            + LINE_BREAK;
-    private static final String CHARSET = "UTF-8";
-    private static final String ROOT_BEGIN = "<indexlog>" + LINE_BREAK;
-
-    private static final String ROOT_END = "</indexlog>";
-
-    
-
-    private final BufferedWriter writer;
-
-    private final AtomicBoolean isClosed;
-
-    /**
-     * @param file
-     * @throws IOException
-     * 
-     */
-    public IndexLogWriter(File file) throws IOException {
-
-        this.writer = new BufferedWriter(new OutputStreamWriter(
-                new FileOutputStream(file), CHARSET));
-        this.writer.write(XMLHEADER);
-        this.writer.write(ROOT_BEGIN);
-        this.writer.flush();
-        this.isClosed = new AtomicBoolean(false);
-
-    }
-
-    synchronized void writeAction(String id, IndexAction action)
-            throws IOException {
-        if (this.isClosed.get())
-            throw new IllegalStateException("Writer is already closed");
-        this.writer.write(buildElement(id, action.name()));
-        this.writer.flush();
-    }
-
-    static synchronized void tryCloseRoot(File file) throws IOException {
-        /*
-         * try to append the Root element end
-         * this happens if the server crashes.
-         * If it dies while writing an entry the log file has to be fixed manually
-         */
-        RandomAccessFile raFile = new RandomAccessFile(file, "rw");
-        raFile.seek(raFile.length());
-        raFile.write(IndexLogWriter.ROOT_END.getBytes(CHARSET));
-        raFile.close();
-        
-
-    }
-
-    private static String buildElement(String id, String action) {
-        StringBuilder builder = new StringBuilder("\t<indexentry>")
-                .append(LINE_BREAK);
-        builder.append("\t\t<entryid>");
-        builder.append(id);
-        builder.append("</entryid>").append(LINE_BREAK);
-        builder.append("\t\t<action>");
-        builder.append(action);
-        builder.append("</action>").append(LINE_BREAK);
-        builder.append("\t</indexentry>").append(LINE_BREAK);
-        return builder.toString();
-
-    }
-
-    synchronized void close() throws IOException {
-        if (!this.isClosed.compareAndSet(false,true))
-            throw new IllegalStateException("Writer is already closed");
-        try {
-            this.writer.write(ROOT_END);
-            this.writer.flush();
-        } finally {
-            this.writer.close();
-        }
-
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/IndexTask.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/IndexTask.java
deleted file mode 100755
index 92bebaa..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/IndexTask.java
+++ /dev/null
@@ -1,175 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.search.index;
-
-import java.io.IOException;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-import java.util.concurrent.atomic.AtomicBoolean;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-
-/**
- * 
- * Class to be used inside a
- * {@link org.apache.lucene.gdata.search.index.GDataIndexer} to process the task
- * queue. This class calls the commit method of the indexer if commit is
- * scheduled.
- * 
- * @author Simon Willnauer
- * 
- */
-class IndexTask implements Runnable {
-    private static final Log INNERLOG = LogFactory.getLog(IndexTask.class);
-
-    private AtomicBoolean stopped = new AtomicBoolean(false);
-
-    private final GDataIndexer indexer;
-
-    protected AtomicBoolean commit = new AtomicBoolean(false);
-    
-    protected AtomicBoolean optimize = new AtomicBoolean(false);
-
-    /*
-     * keep protected for subclassing
-     */
-    protected final BlockingQueue<Future<IndexDocument>> taskQueue;
-
-    IndexTask(final GDataIndexer indexer,
-            final BlockingQueue<Future<IndexDocument>> taskQueue) {
-        this.indexer = indexer;
-        this.taskQueue = taskQueue;
-    }
-
-    /**
-     * @see java.lang.Runnable#run()
-     */
-    public void run() {
-
-        while (!this.stopped.get() || this.taskQueue.size() != 0) {
-
-            try {
-                /*
-                 * get the future from the queue and wait until processing has
-                 * been done
-                 */
-                Future<IndexDocument> future = getTask();
-                if (future != null) {
-                    IndexDocument document = future.get();
-                    setOptimize(document);
-                    processDocument(document); 
-                    /*
-                     * the document contains the info for commit or optimize -->
-                     * this comes from the controller
-                     */
-                    if (document == null || document.commitAfter())
-                        this.indexer.commit(document == null ? false : this.optimize.getAndSet(false));
-                }
-                if (this.commit.getAndSet(false))
-                    this.indexer.commit(this.optimize.getAndSet(false));
-
-            } catch (InterruptedException e) {
-                INNERLOG.warn("Queue is interrupted exiting IndexTask -- ", e);
-
-            } catch (GdataIndexerException e) {
-                /*
-                 * 
-                 * TODO fire callback here as well
-                 */
-                INNERLOG.error("can not retrieve Field from IndexDocument  ", e);
-            } catch (ExecutionException e) {
-                /*
-                 * TODO callback for fail this exception is caused by an
-                 * exception while processing the document. call back for failed
-                 * docs should be placed here
-                 */
-                INNERLOG.error("Future throws execution exception ", e);
-
-            } catch (IOException e) {
-                INNERLOG.error("IOException thrown while processing document ",
-                        e);
-
-            } catch (Throwable e) {
-                /*
-                 * catch all to prevent the thread from dieing
-                 */
-                INNERLOG.error(
-                        "Unexpected exception while processing document -- "
-                                + e.getMessage(), e);
-            }
-        }
-        try {
-            this.indexer.commit(this.optimize.getAndSet(false));
-        } catch (IOException e) {
-            INNERLOG.warn("commit on going down failed - "+e.getMessage(),e);
-            
-        }
-        this.stop();
-    }
-    protected void setOptimize(IndexDocument document){
-        if(document == null)
-            return;
-        this.optimize.set(document.optimizeAfter());
-    }
-
-    /*
-     * keep this protected for subclassing see TimedIndexTask!
-     */
-    protected Future<IndexDocument> getTask() throws InterruptedException {
-        return this.taskQueue.take();
-    }
-
-    private void processDocument(IndexDocument document) throws IOException {
-        /*
-         * a null document is used for waking up the task if the indexer has
-         * been destroyed to finish up and commit. should I change this?! -->
-         * see TimedIndexTask#getTask() also!!
-         */
-        if (document == null) {
-            INNERLOG.warn("Can not process document -- is null -- run commit");
-            return;
-        }
-        if (document.isDelete()) {
-            this.indexer.deleteDocument(document);
-            return;
-        } else if (document.isInsert()) {
-            this.indexer.addDocument(document);
-            return;
-        } else if (document.isUpdate()) {
-            this.indexer.updateDocument(document);
-            return;
-        }
-        /*
-         * that should not happen -- anyway skip the document and write it to
-         * the log
-         */
-        INNERLOG.warn("IndexDocument has no Action " + document);
-
-    }
-
-    protected boolean isStopped() {
-        return this.stopped.get();
-    }
-
-    protected void stop() {
-        this.stopped.set(true);
-    }
-
-}
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/TimedIndexTask.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/TimedIndexTask.java
deleted file mode 100755
index f191c62..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/TimedIndexTask.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.search.index;
-
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-
-/**
- * This {@link IndexTask} will idle the given time if no task is on the queue.
- * If the idle time exceeds the task will force a commit on the index. The timer
- * will be reset if a task is on the queue.
- * 
- * @author Simon Willnauer
- * 
- */
-class TimedIndexTask extends IndexTask {
-    protected final static TimeUnit TIME_UNIT = TimeUnit.SECONDS;
-
-    protected final static long DEFAULT_IDLE_TIME = 30;
-
-    private final long idleTime;
-
-    TimedIndexTask(final GDataIndexer indexer,
-            final BlockingQueue<Future<IndexDocument>> taskQueue,
-            final long idleTime) {
-        super(indexer, taskQueue);
-        this.idleTime = idleTime < DEFAULT_IDLE_TIME ? DEFAULT_IDLE_TIME
-                : idleTime;
-
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.search.index.IndexTask#getTask()
-     */
-    @Override
-    protected Future<IndexDocument> getTask() throws InterruptedException {
-        /*
-         * wait for a certain time and return null if no task is on the queue.
-         * If return null --> commit will be called
-         */
-        Future<IndexDocument> retVal = this.taskQueue.poll(this.idleTime, TIME_UNIT);
-        if(retVal== null)
-            this.commit.set(true);
-        return retVal;
-        
-    }
-    
-    protected long getIdleTime(){
-        return this.idleTime;
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/package.html b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/package.html
deleted file mode 100755
index 7257463..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/index/package.html
+++ /dev/null
@@ -1,10 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
-<html> 
-<head> 
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
-   <meta name="Author" content="Simon Willnauer"> 
-</head> 
-<body> 
-Contains classes processing of documents and accessing the search index of the server
-</body> 
-</html> 
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/package.html b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/package.html
deleted file mode 100755
index 4480952..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/package.html
+++ /dev/null
@@ -1,10 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
-<html> 
-<head> 
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
-   <meta name="Author" content="Simon Willnauer"> 
-</head> 
-<body> 
-Classes used for query the lucene index for a specific feed instance
-</body> 
-</html> 
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/query/GDataQueryParser.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/query/GDataQueryParser.java
deleted file mode 100755
index ee63c4d..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/query/GDataQueryParser.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.search.query;
-
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.gdata.search.config.IndexSchema;
-import org.apache.lucene.queryParser.QueryParser;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class GDataQueryParser extends QueryParser {
-
-    /**
-     * Creates a new QueryParser instance and sets the default operator to
-     * {@link Operator#AND}
-     * 
-     * @param field -
-     *            the parser field
-     * @param analyzer -
-     *            the parser analyzer
-     */
-    public GDataQueryParser(String field, Analyzer analyzer) {
-        super(field, analyzer);
-        this.setDefaultOperator(Operator.AND);
-    }
-
-    /**
-     * Creates a new QueryParser instance and sets the default operator to
-     * {@link Operator#AND}. The parser will use
-     * {@link IndexSchema#getDefaultSearchField} as the field and
-     * {@link IndexSchema#getSchemaAnalyzer()} as the analyzer.
-     * 
-     * @param schema -
-     *            the schema to set the default fields
-     */
-    public GDataQueryParser(IndexSchema schema) {
-        this(schema.getDefaultSearchField(), schema.getSchemaAnalyzer());
-
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/query/QueryTranslator.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/query/QueryTranslator.java
deleted file mode 100755
index 174a8f9..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/search/query/QueryTranslator.java
+++ /dev/null
@@ -1,135 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.search.query;
-
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Set;
-
-import org.apache.lucene.gdata.search.config.IndexSchema;
-
-import com.google.gdata.data.DateTime;
-
-/**
- * Simple static methods to translate the http query to a lucene query string.
- * @author Simon Willnauer
- * 
- */
-public class QueryTranslator {
-    private static final Set<String> STANDARD_REQUEST_PARAMETER = new HashSet<String>(3);
-    private static final String GDATA_DEFAULT_SEARCH_PARAMETER = "q";
-    private static final String UPDATED_MIN = Long.toString(0);
-    private static final String UPDATED_MAX = Long.toString(Long.MAX_VALUE);
-//    private static final String GDATA_CATEGORY_FIEL = 
-
-    
-    
-    static{
-        STANDARD_REQUEST_PARAMETER.add("max-results");
-        STANDARD_REQUEST_PARAMETER.add("start-index");
-        STANDARD_REQUEST_PARAMETER.add("alt");
-    }
-    /**
-     * This method does a little preprocessing of the query. Basically it will map the given request parameters to a lucene syntax. Each
-     * parameter matching a index field in the given schema will be translated into a grouped query string according to the lucene query syntax. 
-     * <p>
-     * <ol>
-     * <li>title=foo bar AND "FooBar" will be title:(foo bar AND "FooBar)</i>
-     * <li>updated-min=2005-08-09T10:57:00-08:00 will be translated to updated:[1123613820000 TO 9223372036854775807] according to the gdata protocol</i>
-     * </ol>
-     * </p>
-     * @param schema the index schema for the queried service
-     * @param parameterMap - the http parameter map returning String[] instances as values
-     * @param categoryQuery - the parsed category query from the request
-     * @return - a lucene syntax query string
-     */
-    public static String translateHttpSearchRequest(IndexSchema schema,
-            Map<String, String[]> parameterMap, String categoryQuery) {
-        Set<String> searchableFieldNames = schema.getSearchableFieldNames();
-        Set<String> parameterSet = parameterMap.keySet();
-        StringBuilder translatedQuery = new StringBuilder();
-        if(categoryQuery != null){
-           translatedQuery.append(translateCategory(translatedQuery,categoryQuery));
-        }
-        String updateMin = null;
-        String updateMax = null;
-        for (String parameterName : parameterSet) {
-            if (STANDARD_REQUEST_PARAMETER.contains(parameterName))
-                continue;
-            if (searchableFieldNames.contains(parameterName)) {
-                translatedQuery.append(parameterName).append(":(");
-                translatedQuery.append(parameterMap.get(parameterName)[0]);
-                translatedQuery.append(") ");
-                continue;
-            }
-            if(parameterName.equals(GDATA_DEFAULT_SEARCH_PARAMETER)){
-                translatedQuery.append(schema.getDefaultSearchField());
-                translatedQuery.append(":(");
-                translatedQuery.append(parameterMap.get(parameterName)[0]);
-                translatedQuery.append(") ");
-                continue;
-                
-            }
-            if(parameterName.endsWith("updated-min")){
-                updateMin = parameterMap.get(parameterName)[0];
-                continue;
-            }
-            if(parameterName.endsWith("updated-max")){
-                updateMax = parameterMap.get(parameterName)[0];
-                continue;
-            }
-            throw new RuntimeException("Can not apply parameter -- invalid -- "
-                    + parameterName);
-        }
-        if(updateMax!=null || updateMin!= null)
-            translatedQuery.append(translateUpdate(updateMin,updateMax));
-            
-        return translatedQuery.length() == 0?null:translatedQuery.toString();
-    }
-    
-    
-     static String translateUpdate(String updateMin, String updateMax){
-        StringBuilder builder = new StringBuilder("updated:[");
-        if(updateMin != null)
-            builder.append(Long.toString(DateTime.parseDateTime(updateMin).getValue()));
-        else
-            builder.append(UPDATED_MIN);
-        builder.append(" TO ");
-        if(updateMax != null)
-            builder.append(Long.toString(DateTime.parseDateTime(updateMax).getValue()-1));
-        else
-            builder.append(UPDATED_MAX);
-        builder.append("]");
-        return builder.toString();
-        
-        
-    }
-     
-     static String translateCategory(StringBuilder builder, String categoryQuery){
-         return categoryQuery;
-         //TODO Implement this
-//         GDataCategoryQueryParser parser = new GDataCategoryQueryParser()
-         
-        
-     }
-     
-     
-     
-    
-    
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/FeedNotFoundException.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/FeedNotFoundException.java
deleted file mode 100644
index 5ebe60d..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/FeedNotFoundException.java
+++ /dev/null
@@ -1,57 +0,0 @@
-package org.apache.lucene.gdata.server; 
- 
- 
-/** 
- * Will be thrown if a requested feed could not be found or is not 
- * registerd. 
- *  
- * @author Simon Willnauer 
- *  
- */ 
-public class FeedNotFoundException extends ServiceException { 
- 
-    private static final long serialVersionUID = 1L; 
- 
-    /**
-     * Constructs a new FeedNotFoundException
-     * @param errorCode - gdata request errorcode
-     */
-    public FeedNotFoundException(int errorCode) {
-        super(errorCode);
-        
-
-    }
-
-    /**
-     * Constructs a new FeedNotFoundException
-     * @param arg0 - the exception message
-     * @param errorCode - gdata request errorcode
-     */
-    public FeedNotFoundException(String arg0,int errorCode) {
-        super(arg0, errorCode);
-        
-    }
-
-    /**
-     * Constructs a new FeedNotFoundException
-     * @param arg0 - the exceptin message
-     * @param arg1 - the exception cause
-     * @param errorCode - gdata request errorcode
-     */
-    public FeedNotFoundException(String arg0, Throwable arg1,int errorCode) {
-        super(arg0, arg1, errorCode);
-        
-        
-    }
-
-    /**
-     * Constructs a new FeedNotFoundException
-     * @param arg0 - the exception cause
-     * @param errorCode - gdata request errorcode
-     */
-    public FeedNotFoundException(Throwable arg0,int errorCode) {
-        super(arg0, errorCode);
-        
-    }
- 
-} 
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/GDataEntityBuilder.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/GDataEntityBuilder.java
deleted file mode 100644
index 62e8584..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/GDataEntityBuilder.java
+++ /dev/null
@@ -1,171 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.server;
-
-import java.io.IOException;
-import java.io.Reader;
-
-import org.apache.lucene.gdata.server.registry.ProvidedService;
-
-import com.google.gdata.data.BaseEntry;
-import com.google.gdata.data.BaseFeed;
-import com.google.gdata.util.ParseException;
-
-/**
- * {@link com.google.gdata.data.BaseFeed},
- * {@link com.google.gdata.data.BaseEntry} instances have to be build from a
- * {@link java.io.Reader} instance as they come in from a client request or out
- * of a storage.
- * <p>
- * To provide a generic builder class the {@link GDataEntityBuilder} requests
- * the type of the feed / entry and the corresponding
- * {@link com.google.gdata.data.ExtensionProfile} form the global
- * {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry} and
- * builds the instances from the provided reader.
- * </p>
- * <p>
- * This build will not returne the abstract base classes.
- * </p>
- * 
- * @author Simon Willnauer
- * 
- */
-public class GDataEntityBuilder {
-
-    /**
-     * Builds a {@link BaseFeed} instance from the {@link Reader} provided by
-     * the {@link GDataRequest}
-     * 
-     * @param request -
-     *            the request to build the instance from
-     * @return - a BaseFeed instance
-     * 
-     * @throws IOException -
-     *             if an I/O Exception occures on the provided reader
-     * @throws ParseException -
-     *             if the feed could not be parsed
-     */
-    public static BaseFeed buildFeed(final GDataRequest request)
-            throws IOException, ParseException {
-        if (request == null)
-            throw new IllegalArgumentException("request must not be null");
-        ProvidedService config = request.getConfigurator();
-        return buildFeed(request.getReader(), config);
-    }
-
-    /**
-     * Builds a {@link BaseFeed} from the provided {@link Reader}
-     * 
-     * 
-     * @param reader -
-     *            the reader to build the feed from
-     * @param config -
-     *            the feed instance config containing the extension profile to
-     *            parse the resource
-     * @return - a BaseFeed instance
-     * 
-     * @throws IOException -
-     *             if an I/O Exception occures on the provided reader
-     * @throws ParseException -
-     *             if the feed could not be parsed
-     */
-    public static BaseFeed buildFeed(final Reader reader,
-            final ProvidedService config) throws ParseException, IOException {
-
-        BaseFeed retVal = null;
-        retVal = createEntityInstance(config);
-        retVal.parseAtom(config.getExtensionProfile(), reader);
-      
-        return retVal;
-    }
-
-    /**
-     * Builds a {@link BaseEntry} instance from the {@link Reader} provided by
-     * the {@link GDataRequest}
-     * 
-     * @param request -
-     *            the request to build the instance from
-     * @return - a BaseEntry instance
-     * 
-     * @throws IOException -
-     *             if an I/O Exception occures on the provided reader
-     * @throws ParseException -
-     *             if the entry could not be parsed
-     */
-    public static BaseEntry buildEntry(final GDataRequest request)
-            throws IOException, ParseException {
-        if (request == null)
-            throw new IllegalArgumentException("request must not be null");
-        ProvidedService config = request.getConfigurator();
-        return buildEntry(request.getReader(), config);
-    }
-
-    /**
-     * Builds a {@link BaseFeed} instance from the {@link Reader} provided by
-     * the {@link GDataRequest}
-     * 
-     * @param reader -
-     *            the reader to build the feed from
-     * @param config -
-     *            the instance config containing the extension profile to parse
-     *            the resource
-     * @return - a BaseFeed instance
-     * 
-     * @throws IOException -
-     *             if an I/O Exception occures on the provided reader
-     * @throws ParseException -
-     *             if the entry could not be parsed
-     */
-    public static BaseEntry buildEntry(final Reader reader,
-            final ProvidedService config) throws ParseException, IOException {
-       
-        BaseEntry e = createEntityInstance(config).createEntry();
-        e.parseAtom(config.getExtensionProfile(), reader);
-        return e;
-    }
-
-    private static BaseFeed createEntityInstance(
-            final ProvidedService config) {
-        if(config.getFeedType() == null)
-            throw new IllegalArgumentException("feedtype is null in ProvidedService");
-        
-        BaseFeed retVal = null;
-        try {
-            retVal = (BaseFeed) config.getFeedType().newInstance();
-        } catch (Exception e) {
-            throw new EntityBuilderException("Can't instanciate Feed for feedType "+config.getFeedType().getName(),e);
-        }
-        return retVal;
-    }
-    static class EntityBuilderException extends RuntimeException{
-
-        /**
-         * 
-         */
-        private static final long serialVersionUID = 7224011324202237951L;
-
-        EntityBuilderException(String arg0) {
-            super(arg0);
-           
-        }
-
-        EntityBuilderException(String arg0, Throwable arg1) {
-            super(arg0, arg1);
-           
-        }
-        
-    }
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/GDataRequest.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/GDataRequest.java
deleted file mode 100644
index addd86e..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/GDataRequest.java
+++ /dev/null
@@ -1,598 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-
-package org.apache.lucene.gdata.server;
-
-import java.io.IOException;
-import java.io.Reader;
-import java.util.Enumeration;
-import java.util.Map;
-import java.util.StringTokenizer;
-
-import javax.servlet.http.Cookie;
-import javax.servlet.http.HttpServletRequest;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.search.config.IndexSchema;
-import org.apache.lucene.gdata.search.query.QueryTranslator;
-import org.apache.lucene.gdata.server.authentication.AuthenticationController;
-import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
-import org.apache.lucene.gdata.server.registry.ProvidedService;
-
-/**
- * The GDataRequest Class wraps the incoming HttpServletRequest. Needed
- * information coming with the HttpServletRequest can be accessed directly. It
- * represents an abstraction on the plain HttpServletRequest. Every GData
- * specific data coming from the client will be available and can be accessed
- * via the GDataRequest.
- * <p>
- * GDataRequest instances will be passed to any action requested by the client.
- * This class also holds the logic to retrieve important information like
- * response format, the requested feed instance and query parameters.
- * 
- * </p>
- * 
- * @author Simon Willnauer
- * 
- */
-/* this class might be extracted as an interface in later development */
-public class GDataRequest {
-    
-    
-    private static final Log LOG = LogFactory.getLog(GDataRequest.class);
-
-    private static final String RESPONSE_FORMAT_PARAMETER = "alt";
-
-    private static final String RESPONSE_FORMAT_PARAMETER_RSS = "rss";
-    private static final String RESPONSE_FORMAT_PARAMETER_HTML = "html";
-
-    private static final int DEFAULT_ITEMS_PER_PAGE = 25;
-
-    private static final int DEFAULT_START_INDEX = 1;
-
-    private static final String START_INDEX_NEXT_PAGE_PARAMETER = "start-index";
-
-    private static final String ITEMS_PER_PAGE_PARAMETER = "max-results";
-
-    private String contextPath;
-
-    @SuppressWarnings("unused")
-    private static final String RESPONSE_FORMAT_PARAMETER_ATOM = "atom";
-
-    private static final String HTTP_HEADER_IF_MODIFIED_SINCE = "If-Modified-Since";
-
-    private static final String HTTP_HEADER_AUTH = "Authorization";
-
-    private static final Object CATEGORY_QUERY_INDICATOR = "-";
-
-    // Atom is the default response format
-    private OutputFormat responseFormat = OutputFormat.ATOM;
-
-    private final HttpServletRequest request;
-
-    private String feedId = null;
-
-    private String entryId = null;
-
-    private String service = null;
-
-    private ProvidedService configurator = null;
-
-    private boolean isSearchRequest = false;
-
-    private String entryVersion = null;
-
-    private GDataRequestType type;
-
-    private String categoryQuery;
-    
-    private String translatedSearchQuery;
-
-    private boolean isFeedRequest = false;
-
-    /**
-     * Creates a new FeedRequest
-     * 
-     * @param requst -
-     *            the incoming HttpServletReqeust
-     * @param type -
-     *            the request type
-     * 
-     */
-    public GDataRequest(final HttpServletRequest requst,
-            final GDataRequestType type) {
-        if (requst == null)
-            throw new IllegalArgumentException("request must not be null ");
-        if (type == null)
-            throw new IllegalArgumentException("request type must not be null ");
-        this.request = requst;
-        this.type = type;
-
-    }
-
-    /**
-     * Initialize the GDataRequest. This will initialize all needed values /
-     * attributes in this request.
-     * 
-     * @throws GDataRequestException
-     */
-    public void initializeRequest() throws GDataRequestException {
-        generateIdentificationProperties();
-        setOutputFormat();
-        
-        try {
-            /*
-             * ExtensionProfile and the type is used for building the Entry /
-             * Feed Instances from an input stream or reader
-             * 
-             */
-            this.configurator = GDataServerRegistry.getRegistry()
-                    .getProvidedService(this.service);
-            
-            if (this.configurator == null)
-                throw new GDataRequestException(
-                        "no Provided Service found for service id: "+this.service,GDataResponse.NOT_FOUND);
-            applyRequestParameter();
-            if(this.translatedSearchQuery != null)
-                this.isSearchRequest = true;
-        } catch(GDataRequestException ex){
-            throw ex;
-        } catch (Exception e) {
-            throw new GDataRequestException(
-                    "failed to initialize GDataRequest -- "
-                            + e.getMessage(), e,GDataResponse.SERVER_ERROR);
-        }
-        
-    }
-    
-    @SuppressWarnings("unchecked")
-    private void applyRequestParameter() throws GDataRequestException{
-        IndexSchema schema = this.configurator.getIndexSchema();
-        try{
-        this.translatedSearchQuery = QueryTranslator.translateHttpSearchRequest(schema,this.request.getParameterMap(),this.categoryQuery);
-        }catch (Exception e) {
-            throw new GDataRequestException("Can not translate user query to search query",e,GDataResponse.BAD_REQUEST);
-        }
-    }
-
-    /**
-     * @return - the id of the requested feed
-     */
-    public String getFeedId() {
-
-        return this.feedId;
-    }
-
-    /**
-     * @return - the entry id of the requested Entry if specified, otherwise
-     *         <code>null</code>
-     */
-    public String getEntryId() {
-
-        return this.entryId;
-    }
-
-    /**
-     * @return the version Id of the requested Entry if specified, otherwise
-     *         <code>null</code>
-     */
-    public String getEntryVersion() {
-        return this.entryVersion;
-    }
-
-    /**
-     * A Reader instance to read form the client input stream
-     * 
-     * @return - the HttpServletRequest {@link Reader}
-     * @throws IOException -
-     *             if an I/O Exception occurs
-     */
-    public Reader getReader() throws IOException {
-        return this.request.getReader();
-    }
-
-    /**
-     * Returns the {@link HttpServletRequest} parameter map containing all
-     * <i>GET</i> request parameters.
-     * 
-     * @return the parameter map
-     */
-    @SuppressWarnings("unchecked")
-    public Map<String, String[]> getQueryParameter() {
-        return this.request.getParameterMap();
-    }
-
-    /**
-     * The {@link HttpServletRequest} request parameter names
-     * 
-     * @return parameter names enumeration
-     */
-    @SuppressWarnings("unchecked")
-    public Enumeration<String> getQueryParameterNames() {
-        return this.request.getParameterNames();
-    }
-
-    /**
-     * Either <i>Atom</i> or <i>RSS</i>
-     * 
-     * @return - The output format requested by the client
-     */
-    public OutputFormat getRequestedResponseFormat() {
-
-        return this.responseFormat;
-    }
-
-    private void generateIdentificationProperties()
-            throws GDataRequestException {
-        /* generate all needed data to identify the requested feed/entry */
-        String pathInfo = this.request.getPathInfo();
-              if (pathInfo.length() <= 1)
-            throw new GDataRequestException(
-                    "No feed or entry specified for this request",GDataResponse.BAD_REQUEST);
-        StringTokenizer tokenizer = new StringTokenizer(pathInfo, "/");
-        this.service = tokenizer.nextToken();
-        if (!tokenizer.hasMoreTokens())
-            throw new GDataRequestException(
-                    "Can not find feed id in requested path " + pathInfo,GDataResponse.BAD_REQUEST);
-        this.feedId = tokenizer.nextToken();
-
-        String appendix = tokenizer.hasMoreTokens() ? tokenizer.nextToken()
-                : null;
-        if (appendix == null){
-            this.isFeedRequest = true;
-            return;
-        }
-        if (appendix.equals(CATEGORY_QUERY_INDICATOR)) {
-            StringBuilder builder = new StringBuilder();
-            while (tokenizer.hasMoreTokens())
-                builder.append("/").append(tokenizer.nextToken());
-            this.categoryQuery = builder.toString();
-        } else {
-            this.entryId = appendix;
-            this.entryVersion = tokenizer.hasMoreTokens() ? tokenizer
-                    .nextToken() : "";
-        }
-        this.isFeedRequest = (this.type == GDataRequestType.GET && (this.entryId == null
-                || this.entryId.length() == 0 || (this.entryId.equals('/'))));
-    }
-
-    private void setOutputFormat() {
-        String formatParameter = this.request
-                .getParameter(RESPONSE_FORMAT_PARAMETER);
-        if (formatParameter == null)
-            return;
-        if (formatParameter.equalsIgnoreCase(RESPONSE_FORMAT_PARAMETER_RSS))
-            this.responseFormat = OutputFormat.RSS;
-        if (formatParameter.equalsIgnoreCase(RESPONSE_FORMAT_PARAMETER_HTML))
-            this.responseFormat = OutputFormat.HTML;
-
-    }
-
-    /**
-     * @return - the number of returned items per page
-     */
-    public int getItemsPerPage() {
-
-        if (this.request.getParameter(ITEMS_PER_PAGE_PARAMETER) == null)
-            return DEFAULT_ITEMS_PER_PAGE;
-        int retval = -1;
-        try {
-            retval = new Integer(this.request
-                    .getParameter(ITEMS_PER_PAGE_PARAMETER)).intValue();
-        } catch (Exception e) {
-            LOG.warn("Items per page could not be parsed - " + e.getMessage(),
-                    e);
-        }
-
-        return retval < 0 ? DEFAULT_ITEMS_PER_PAGE : retval;
-    }
-
-    /**
-     * Start index represents the number of the first entry of the query -
-     * result. The order depends on the query. Is the query a search query the
-     * this value will be assigned to the score in a common feed query the value
-     * will be assigned to the update time of the entries.
-     * 
-     * @return - the requested start index
-     */
-    public int getStartIndex() {
-        String startIndex = this.request.getParameter(START_INDEX_NEXT_PAGE_PARAMETER);
-        if (startIndex == null)
-            return DEFAULT_START_INDEX;
-        int retval = -1;
-        try {
-            retval = new Integer(startIndex).intValue();
-        } catch (Exception e) {
-            LOG.warn("Start-index could not be parsed - not an integer - " + e.getMessage());
-        }
-        return retval < 0 ? DEFAULT_START_INDEX : retval;
-    }
-
-    /**
-     * The self id is the feeds <i>href</i> pointing to the requested resource
-     * 
-     * @return - the self id
-     */
-    public String getSelfId() {
-        StringBuilder builder = new StringBuilder();
-        builder.append(buildRequestIDString(false));
-        builder.append("?");
-        builder.append(getQueryString());
-
-        return builder.toString();
-    }
-    
-    /**
-       * The previous id is the feeds <i>href</i> pointing to the previous result of the requested resource
-     * 
-     * @return - the self id
-     */
-    public String getPreviousId(){
-        
-        int startIndex = getStartIndex();
-        if(startIndex == DEFAULT_START_INDEX )
-            return null;
-        StringBuilder builder = new StringBuilder();
-        builder.append(buildRequestIDString(false));
-        startIndex = startIndex-getItemsPerPage();
-        builder.append(getPreparedQueryString(startIndex<1?DEFAULT_START_INDEX:startIndex));
-        return builder.toString();
-    }
-  
-
-    
-    private String getPreparedQueryString(int startIndex){
-        String queryString = this.request.getQueryString();
-        String startIndexValue = this.request.getParameter(START_INDEX_NEXT_PAGE_PARAMETER);
-        String maxResultsValue = this.request.getParameter(ITEMS_PER_PAGE_PARAMETER);
-        
-        StringBuilder builder = new StringBuilder("?");
-        if(maxResultsValue == null){
-            builder.append(ITEMS_PER_PAGE_PARAMETER).append("=").append(DEFAULT_ITEMS_PER_PAGE);
-            builder.append("&");
-        }
-        if(startIndexValue== null){
-            builder.append(START_INDEX_NEXT_PAGE_PARAMETER).append("=");
-            builder.append(Integer.toString(startIndex));
-            if(queryString!=null){
-                builder.append("&");
-                builder.append(queryString);
-            }
-        }else{
-            builder.append(queryString.replaceAll("start-index=[\\d]*",START_INDEX_NEXT_PAGE_PARAMETER+"="+Integer.toString(startIndex)));
-        }
-        return builder.toString();
-    }
-    /**
-     * The <i>href</i> id of the next page of the requested resource.
-     * 
-     * @return the id of the next page
-     */
-    public String getNextId() {
-        int startIndex = getStartIndex();
-        StringBuilder builder = new StringBuilder();
-        builder.append(buildRequestIDString(false));
-        startIndex = startIndex+getItemsPerPage();
-        builder.append(getPreparedQueryString(startIndex));
-        return builder.toString();
-
-    }
-
-    private String buildRequestIDString(boolean endingSlash) {
-        StringBuilder builder = new StringBuilder("http://");
-        builder.append(this.request.getHeader("Host"));
-        builder.append(this.request.getRequestURI());
-        if (!endingSlash && builder.charAt(builder.length() - 1) == '/')
-            builder.setLength(builder.length() - 1);
-        if (endingSlash && builder.charAt(builder.length() - 1) != '/')
-            builder.append("/");
-
-        return builder.toString();
-    }
-
-    /**
-     * This will return the current query string including all parameters.
-     * Additionally the <code>max-resul</code> parameter will be added if not
-     * specified.
-     * <p>
-     * <code>max-resul</code> indicates the number of results returned to the
-     * client. The default value is 25.
-     * </p>
-     * 
-     * @return - the query string including all parameters
-     */
-    public String getQueryString() {
-        String retVal = this.request.getQueryString();
-
-        if (this.request.getParameter(ITEMS_PER_PAGE_PARAMETER) != null)
-            return retVal;
-        String tempString = (retVal == null ? ITEMS_PER_PAGE_PARAMETER + "="
-                + DEFAULT_ITEMS_PER_PAGE : "&" + ITEMS_PER_PAGE_PARAMETER + "="
-                + DEFAULT_ITEMS_PER_PAGE);
-
-        return retVal == null ? tempString : retVal + tempString;
-
-    }
-
-    /**
-     * This enum represents the OutputFormat of the GDATA Server
-     * 
-     * @author Simon Willnauer
-     * 
-     */
-    public static enum OutputFormat {
-        /**
-         * Output format ATOM. ATOM is the default response format.
-         */
-        ATOM,
-        /**
-         * Output format RSS
-         */
-        RSS,
-        /**
-         * Output format html if user defined xsl style sheet is present 
-         */
-        HTML
-    }
-
-    /**
-     * Returns the requested path including the domain name and the requested
-     * resource <i>http://www.apache.org/path/resource/</i>
-     * 
-     * @return the context path
-     */
-    public String getContextPath() {
-        if (this.contextPath == null)
-            this.contextPath = buildRequestIDString(true);
-        return this.contextPath;
-    }
-
-    /**
-     * Indicates the request type
-     * 
-     * @author Simon Willnauer
-     * 
-     */
-    public enum GDataRequestType {
-        /**
-         * Type FeedRequest
-         */
-        GET,
-        /**
-         * Type UpdateRequest
-         */
-        UPDATE,
-        /**
-         * Type DeleteRequest
-         */
-        DELETE,
-        /**
-         * Type InsertRequest
-         */
-        INSERT
-    }
-
-    /**
-     * {@link GDataRequestType}
-     * 
-     * @return the current request type
-     */
-    public GDataRequestType getType() {
-        return this.type;
-    }
-
-    /**
-     * If the request is a {@link GDataRequestType#GET} request and there is no
-     * entry id specified, the requested resource is a feed.
-     * 
-     * @return - <code>true</code> if an only if the requested resource is a
-     *         feed
-     */
-    public boolean isFeedRequested() {
-
-        return this.isFeedRequest ;
-    }
-
-    /**
-     * * If the request is a {@link GDataRequestType#GET} request and there is
-     * an entry id specified, the requested resource is an entry.
-     * 
-     * @return - <code>true</code> if an only if the requested resource is an
-     *         entry
-     */
-    public boolean isEntryRequested() {
-        return !this.isFeedRequested();
-    }
-    /**
-     * @return - <code>true</code> if an only if the user request is a search request, otherwise <code>false</code>
-     */
-    public boolean isSearchRequested(){
-        return this.isSearchRequest;
-    }
-
-    /**
-     * @return the configuration for this request
-     */
-    public ProvidedService getConfigurator() {
-        return this.configurator;
-    }
-
-    /**
-     * @return - Returns the Internet Protocol (IP) address of the client or
-     *         last proxy that sent the request.
-     */
-    public String getRemoteAddress() {
-        return this.request.getRemoteAddr();
-    }
-
-    /**
-     * @return - the value for the send auth token. The auth token will be send
-     *         as a request <tt>Authentication</tt> header.
-     */
-    public String getAuthToken() {
-        String token = this.request.getHeader(HTTP_HEADER_AUTH);
-        if (token == null)
-            return null;
-        token = token.substring(token.indexOf("=") + 1);
-        return token;
-    }
-
-    /**
-     * @return - Returns an array containing all of the Cookie objects the
-     *         client sent with underlying HttpServletRequest.
-     */
-    public Cookie[] getCookies() {
-        return this.request.getCookies();
-    }
-
-    /**
-     * @return - the cookie set instead of the authentication token or
-     *         <code>null</code> if no auth cookie is set
-     */
-    public Cookie getAuthCookie() {
-        Cookie[] cookies = this.request.getCookies();
-        if (cookies == null)
-            return null;
-        for (int i = 0; i < cookies.length; i++) {
-            if (cookies[i].getName().equals(AuthenticationController.TOKEN_KEY))
-                return cookies[i];
-        }
-        return null;
-    }
-
-    /**
-     * @return - the date string of the <tt>If-Modified-Since</tt> HTTP
-     *         request header, or null if header is not set
-     */
-    public String getModifiedSince() {
-        return this.request.getHeader(HTTP_HEADER_IF_MODIFIED_SINCE);
-    }
-
-    /**
-     * @return - the underlying HttpServletRequest
-     */
-    public HttpServletRequest getHttpServletRequest() {
-
-        return this.request;
-    }
-    
-    protected String getTranslatedQuery(){
-        return this.translatedSearchQuery;
-    }
-
- 
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/GDataRequestException.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/GDataRequestException.java
deleted file mode 100644
index 8f783f3..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/GDataRequestException.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */ 
- 
-package org.apache.lucene.gdata.server; 
- 
-/** 
- * This exception wraps all exceptions occur inside the {@link org.apache.lucene.gdata.server.GDataRequest} 
- * @author Simon Willnauer 
- * 
- */ 
-public class GDataRequestException extends Exception { 
-    private final int errorCode;
-    /** 
-     * Serial version ID. -> Implements Serializable 
-     */ 
-    private static final long serialVersionUID = -4440777051466950723L; 
- 
-    /** 
-       /**
-     * Constructs a new GDataRequestException
-     * @param errorCode - gdata request error code
-     */
-    public GDataRequestException(int errorCode) {
-        super();
-        this.errorCode = errorCode;
-
-    }
-
-    /**
-     * Constructs a new GDataRequestException
-     * @param arg0 - the exception message
-     * @param errorCode - gdata request error code
-     */
-    public GDataRequestException(String arg0,int errorCode) {
-        super(arg0);
-        this.errorCode = errorCode;
-    }
-
-    /**
-     * Constructs a new GDataRequestException
-     * @param arg0 - the exception message
-     * @param arg1 - the exception cause
-     * @param errorCode - gdata request error code
-     */
-    public GDataRequestException(String arg0, Throwable arg1,int errorCode) {
-        super(arg0, arg1);
-        this.errorCode = errorCode;
-        
-    }
-
-    /**
-     * Constructs a new GDataRequestException
-     * @param arg0 - the exception cause
-     * @param errorCode - gdata request error code
-     */
-    public GDataRequestException(Throwable arg0,int errorCode) {
-        super(arg0);
-        this.errorCode = errorCode;
-    }
-
-    /**
-     * @return Returns the errorCode.
-     */
-    public int getErrorCode() {
-        return this.errorCode;
-    }
-} 
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/GDataResponse.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/GDataResponse.java
deleted file mode 100644
index 384f1be..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/GDataResponse.java
+++ /dev/null
@@ -1,449 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-
-package org.apache.lucene.gdata.server;
-
-import java.io.IOException;
-import java.io.StringReader;
-import java.io.StringWriter;
-import java.io.Writer;
-import java.util.Date;
-
-import javax.servlet.http.HttpServletResponse;
-import javax.xml.transform.Source;
-import javax.xml.transform.Templates;
-import javax.xml.transform.Transformer;
-import javax.xml.transform.TransformerException;
-import javax.xml.transform.stream.StreamResult;
-import javax.xml.transform.stream.StreamSource;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.server.GDataRequest.OutputFormat;
-import org.apache.lucene.gdata.server.registry.ProvidedService;
-import org.apache.lucene.gdata.utils.DateFormater;
-
-import com.google.gdata.data.BaseEntry;
-import com.google.gdata.data.BaseFeed;
-import com.google.gdata.data.DateTime;
-import com.google.gdata.data.ExtensionProfile;
-import com.google.gdata.util.common.xml.XmlWriter;
-import com.google.gdata.util.common.xml.XmlWriter.Namespace;
-
-/**
- * The FeedRequest Class wraps the current HttpServletResponse. Any action on the
- * HttpServletRequest will be executed via this class. This represents an
- * abstraction on the plain {@link HttpServletResponse}. Any action which has
- * to be performed on the underlying {@link HttpServletResponse} will be
- * executed within this class.
- * <p>
- * The GData basically writes two different kinds of response to the output
- * stream.
- * <ol>
- * <li>update, delete or insert requests will respond with a status code and if
- * successful the feed entry modified or created</li>
- * <li>get requests will respond with a status code and if successful the
- * requested feed</li>
- * </ol>
- * 
- * For this purpose the {@link GDataResponse} class provides the overloaded
- * method
- * {@link org.apache.lucene.gdata.server.GDataResponse#sendResponse(BaseEntry, ExtensionProfile)}
- * which sends the entry e.g feed to the output stream.
- * </p>
- * <p>
- * This class will set the HTTP <tt>Last-Modified</tt> Header to enable
- * clients to send <tt>If-Modified-Since</tt> request header to avoid
- * retrieving the content again if it hasn't changed. If the content hasn't
- * changed since the If-Modified-Since time, then the GData service returns a
- * 304 (Not Modified) HTTP response.
- * </p>
- * 
- * 
- * 
- * 
- * @author Simon Willnauer
- * 
- */
-public class GDataResponse {
-    /**
-     * Response code bad request
-     */
-    public static final int BAD_REQUEST = HttpServletResponse.SC_BAD_REQUEST;
-    /**
-     * Response code version conflict
-     */
-    public static final int CONFLICT = HttpServletResponse.SC_CONFLICT;
-    /**
-     * Response code forbidden access
-     */
-    public static final int FORBIDDEN = HttpServletResponse.SC_FORBIDDEN;
-    /**
-     * Response code internal server error
-     */
-    public static final int SERVER_ERROR = HttpServletResponse.SC_INTERNAL_SERVER_ERROR;
-    /**
-     * Response code not found
-     */
-    public static final int NOT_FOUND = HttpServletResponse.SC_NOT_FOUND;
-    /**
-     * Response code not modified since
-     */
-    public static final int NOT_MODIFIED = HttpServletResponse.SC_NOT_MODIFIED;
-    /**
-     * Response code created
-     */
-    public static final int CREATED = HttpServletResponse.SC_CREATED;
-    /**
-     * Response code unauthorized access
-     */
-    public static final int UNAUTHORIZED = HttpServletResponse.SC_UNAUTHORIZED;
-    
-    
-    static final Log LOG = LogFactory.getLog(GDataResponse.class);
-    private int error;
-
-    private boolean isError = false;
-
-    private String encoding;
-
-    private OutputFormat outputFormat;
-
-    private final HttpServletResponse response;
-
-    protected static final String XMLMIME_ATOM = "text/xml";
-
-    protected static final String XMLMIME_RSS = "text/xml";
-
-    private static final String HEADER_LASTMODIFIED = "Last-Modified";
-
-    /**
-     * Creates a new GDataResponse
-     * 
-     * @param response -
-     *            The underlying {@link HttpServletResponse}
-     */
-    public GDataResponse(HttpServletResponse response) {
-        if (response == null)
-            throw new IllegalArgumentException("response must not be null");
-        this.response = response;
-
-    }
-
-    /**
-     * Sets an error code to this FeedResponse.
-     * 
-     * @param errorCode -
-     *            {@link HttpServletResponse} error code
-     */
-    public void setError(int errorCode) {
-        this.isError = true;
-        this.error = errorCode;
-    }
-
-    /**
-     * Sets the status of the underlying response
-     * 
-     * @see HttpServletResponse
-     * @param responseCode -
-     *            the status of the response
-     */
-    public void setResponseCode(int responseCode) {
-        this.response.setStatus(responseCode);
-    }
-
-    /**
-     * This method sends the specified error to the user if set
-     * 
-     * @throws IOException -
-     *             if an I/O Exception occurs
-     */
-    public void sendError() throws IOException {
-        if (this.isError)
-            this.response.sendError(this.error);
-        
-    }
-
-    /**
-     * @return - the {@link HttpServletResponse} writer
-     * @throws IOException -
-     *             If an I/O exception occurs
-     */
-    public Writer getWriter() throws IOException {
-        return this.response.getWriter();
-    }
-
-    /**
-     * Sends a response for a get e.g. query request. This method must not
-     * invoked in a case of an error performing the requested action.
-     * 
-     * @param feed -
-     *            the feed to respond to the client
-     * @param service - the service to render the feed
-     * 
-     * @throws IOException -
-     *             if an I/O exception occurs, often caused by an already
-     *             closed Writer or OutputStream
-     * 
-     */
-    public void sendResponse(final BaseFeed feed, final ProvidedService service)
-            throws IOException {
-        if (feed == null)
-            throw new IllegalArgumentException("feed must not be null");
-        if (service == null)
-            throw new IllegalArgumentException(
-                    "provided service must not be null");
-        DateTime time = feed.getUpdated();
-        if (time != null)
-            setLastModifiedHeader(time.getValue());
-        FormatWriter writer = FormatWriter.getFormatWriter(this,service);
-        writer.generateOutputFormat(feed,this.response);
-
-    }
-
-    /**
-     * 
-     * Sends a response for an update, insert or delete request. This method
-     * must not invoked in a case of an error performing the requested action. If
-     * the specified response format is ATOM the default namespace will be set
-     * to ATOM.
-     * 
-     * @param entry -
-     *            the modified / created entry to send
-     * @param service - the service to render the feed
-     * @throws IOException -
-     *             if an I/O exception occurs, often caused by an already
-     *             closed Writer or OutputStream
-     */
-    public void sendResponse(BaseEntry entry, ProvidedService service)
-            throws IOException {
-        if (entry == null)
-            throw new IllegalArgumentException("entry must not be null");
-        if (service == null)
-            throw new IllegalArgumentException(
-                    "service must not be null");
-        DateTime time = entry.getUpdated();
-        if (time != null)
-            setLastModifiedHeader(time.getValue());
-        FormatWriter writer = FormatWriter.getFormatWriter(this,service);
-        writer.generateOutputFormat(entry,this.response);
-
-        
-    }
-
-
-    /**
-     * This encoding will be used to encode the xml representation of feed or
-     * entry written to the {@link HttpServletResponse} output stream.
-     * 
-     * @return - the entry / feed encoding
-     */
-    public String getEncoding() {
-        return this.encoding;
-    }
-
-    /**
-     * This encoding will be used to encode the xml representation of feed or
-     * entry written to the {@link HttpServletResponse} output stream. <i>UTF-8</i>
-     * <i>ISO-8859-1</i>
-     * 
-     * @param encoding -
-     *            string represents the encoding
-     */
-    public void setEncoding(String encoding) {
-        this.encoding = encoding;
-    }
-
-    /**
-     * @return - the response
-     *         {@link org.apache.lucene.gdata.server.GDataRequest.OutputFormat}
-     */
-    public OutputFormat getOutputFormat() {
-        return this.outputFormat;
-    }
-
-    /**
-     * @param outputFormat -
-     *            the response
-     *            {@link org.apache.lucene.gdata.server.GDataRequest.OutputFormat}
-     */
-    public void setOutputFormat(OutputFormat outputFormat) {
-        this.outputFormat = outputFormat;
-    }
-
-    /**
-     * @see Object#toString()
-     */
-    @Override
-    public String toString() {
-        StringBuilder builder = new StringBuilder(" GDataResponse: ");
-        builder.append("Error: ").append(this.error);
-        builder.append(" outputFormat: ").append(getOutputFormat());
-        builder.append(" encoding: ").append(this.encoding);
-
-        return builder.toString();
-
-    }
-
-    protected void setLastModifiedHeader(long lastModified) {
-        String lastMod = DateFormater.formatDate(new Date(lastModified),
-                DateFormater.HTTP_HEADER_DATE_FORMAT);
-        this.response.setHeader(HEADER_LASTMODIFIED, lastMod);
-    }
-    
-    /**
-     * @see HttpServletResponse#setStatus(int)
-     * @param status - the request status code
-     */
-    public void setStatus(int status){
-        this.response.setStatus(status);
-    }
-
-    private static abstract class FormatWriter{
-        
-        static FormatWriter getFormatWriter(final GDataResponse response, final ProvidedService service ){
-            OutputFormat format = response.getOutputFormat();
-            if(format == OutputFormat.HTML){
-                return new HTMLFormatWriter(service);
-            }
-            return new SyndicateFormatWriter(service,format,response.getEncoding());
-        }
-        
-        abstract void generateOutputFormat(final BaseFeed feed, final HttpServletResponse response) throws IOException;
-        abstract void generateOutputFormat(final BaseEntry entry, final HttpServletResponse response) throws IOException;
-        
-        private static class HTMLFormatWriter extends FormatWriter{
-            private static final String CONTENT_TYPE = "text/html";
-            private final ProvidedService service;
-            
-            HTMLFormatWriter(final ProvidedService service){
-                this.service = service;
-            }
-            @Override
-            void generateOutputFormat(BaseFeed feed, final HttpServletResponse response) throws IOException {
-                Templates template = this.service.getTransformTemplate();
-                response.setContentType(CONTENT_TYPE);
-                if(template == null){
-                    sendNotAvailable(response);
-                    return;
-                }
-                StringWriter writer = new StringWriter();
-                XmlWriter xmlWriter = new XmlWriter(writer);
-                feed.generateAtom(xmlWriter,this.service.getExtensionProfile());
-                try {
-                    writeHtml(template,response.getWriter(),writer);
-                } catch (TransformerException e) {
-                 LOG.error("Can not transform feed for service "+this.service.getName(),e);
-                 sendNotAvailable(response);
-                    
-                }
-            }
-
-            @Override
-            void generateOutputFormat(BaseEntry entry, final HttpServletResponse response)  throws IOException{
-                Templates template = this.service.getTransformTemplate();
-                response.setContentType(CONTENT_TYPE);
-                if(template == null){
-                    sendNotAvailable(response);
-                    return;
-                }
-                StringWriter writer = new StringWriter();
-                XmlWriter xmlWriter = new XmlWriter(writer);
-                entry.generateAtom(xmlWriter,this.service.getExtensionProfile());
-                try {
-                    writeHtml(template,response.getWriter(),writer);
-                } catch (TransformerException e) {
-                 LOG.error("Can not transform feed for service "+this.service.getName(),e);
-                 sendNotAvailable(response);
-                    
-                }
-
-            }
-            
-            private void writeHtml(final Templates template, final Writer writer, final StringWriter source ) throws TransformerException{
-                Transformer transformer = template.newTransformer();
-                Source tranformSource = new StreamSource(new StringReader(source.toString())); 
-                transformer.transform(tranformSource,new StreamResult(writer));
-            }
-            
-            private void sendNotAvailable(final HttpServletResponse response) throws IOException{
-                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE, "No transformation stylesheet available");
-            }
-            
-        }
-        private static class SyndicateFormatWriter extends FormatWriter{
-            private static final String DEFAUL_NAMESPACE_URI = "http://www.w3.org/2005/Atom";
-
-            private static final Namespace DEFAULT_NAMESPACE = new Namespace("",
-                    DEFAUL_NAMESPACE_URI);
-            private final ProvidedService service;
-            private final String encoding;
-            private final OutputFormat format;
-            
-            SyndicateFormatWriter(final ProvidedService service,final OutputFormat format, String encoding){
-                this.service = service;
-                this.format = format;
-                this.encoding = encoding;
-                
-            }
-            @Override
-            void generateOutputFormat(final BaseFeed feed, final HttpServletResponse response) throws IOException {
-                XmlWriter writer = null;
-                try{
-                 writer = createWriter(response.getWriter());
-                if (this.format == OutputFormat.ATOM) {
-                    response.setContentType(XMLMIME_ATOM);
-                    feed.generateAtom(writer, this.service.getExtensionProfile());
-                } else {
-                    response.setContentType(XMLMIME_RSS);
-                    feed.generateRss(writer, this.service.getExtensionProfile());
-                }
-                }finally{
-                    if(writer != null)
-                        writer.close();
-                }
-            }
-
-            @Override
-            void generateOutputFormat(final BaseEntry entry, final HttpServletResponse response) throws IOException {
-                XmlWriter writer = null;
-                try{
-                 writer = createWriter(response.getWriter());
-                if (this.format == OutputFormat.ATOM) {
-                    response.setContentType(XMLMIME_ATOM);
-                    entry.generateAtom(writer, this.service.getExtensionProfile());
-                } else {
-                    response.setContentType(XMLMIME_RSS);
-                    entry.generateRss(writer, this.service.getExtensionProfile());
-                }
-                }finally{
-                    if(writer != null)
-                        writer.close();
-                }
-            }
-            private XmlWriter createWriter(final Writer target) throws IOException {
-                XmlWriter writer = new XmlWriter(target, this.encoding);
-                // set the default namespace to Atom if Atom is the response format
-                if (this.format == OutputFormat.ATOM)
-                    writer.setDefaultNamespace(DEFAULT_NAMESPACE);
-                return writer;
-            }
-        }
-    }
-    
-    
-    
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/GDataSearchService.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/GDataSearchService.java
deleted file mode 100755
index fd28f4d..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/GDataSearchService.java
+++ /dev/null
@@ -1,114 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.server;
-
-import java.io.IOException;
-import java.util.List;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.data.ServerBaseEntry;
-import org.apache.lucene.gdata.data.ServerBaseFeed;
-import org.apache.lucene.gdata.search.GDataSearcher;
-import org.apache.lucene.gdata.search.SearchComponent;
-import org.apache.lucene.gdata.search.query.GDataQueryParser;
-import org.apache.lucene.gdata.server.registry.ComponentType;
-import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
-import org.apache.lucene.gdata.server.registry.ProvidedService;
-import org.apache.lucene.gdata.storage.StorageException;
-import org.apache.lucene.queryParser.ParseException;
-import org.apache.lucene.queryParser.QueryParser;
-import org.apache.lucene.search.Query;
-
-import com.google.gdata.data.BaseEntry;
-import com.google.gdata.data.BaseFeed;
-
-/**
- * @author Simon Willnauer
- *
- */
-public class GDataSearchService extends GDataService {
-    private static final Log LOG = LogFactory.getLog(GDataSearchService.class);
-    private static SearchComponent SEARCHCOMPONENT;
-    private GDataSearcher<String> searcher;
-    protected GDataSearchService() throws ServiceException {
-        if(SEARCHCOMPONENT == null)
-            SEARCHCOMPONENT = GDataServerRegistry.getRegistry().lookup(SearchComponent.class,ComponentType.SEARCHCONTROLLER);
-        
-       
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.GDataService#getFeed(org.apache.lucene.gdata.server.GDataRequest, org.apache.lucene.gdata.server.GDataResponse)
-     */
-    @SuppressWarnings("unchecked")
-    @Override
-    public BaseFeed getFeed(GDataRequest request, GDataResponse response) throws ServiceException {
-        String translatedQuery = request.getTranslatedQuery();
-        ProvidedService service = request.getConfigurator();
-        
-        QueryParser parser = new GDataQueryParser(service.getIndexSchema());
-        Query query;
-        try {
-            query = parser.parse(translatedQuery);
-           
-        } catch (ParseException e1) {
-            throw new ServiceException("Search Failed -- Can not parse query",e1,GDataResponse.BAD_REQUEST);
-        }
-        if(LOG.isInfoEnabled())
-            LOG.info("Fire search for user query  query: "+query.toString());
-        this.searcher = SEARCHCOMPONENT.getServiceSearcher(service);
-        List<String> result;
-        try {
-            result = this.searcher.search(query,request.getItemsPerPage(),request.getStartIndex(),request.getFeedId());
-        } catch (IOException e) {
-           throw new ServiceException("Search Failed -- Searcher throws IOException",e,GDataResponse.SERVER_ERROR); 
-           
-        }
-        if(LOG.isInfoEnabled())
-            LOG.info("Fetching results for user query result size: "+result.size());
-        ServerBaseFeed requestFeed = new ServerBaseFeed();
-        requestFeed.setServiceConfig(service);
-        requestFeed.setStartIndex(0);
-        requestFeed.setItemsPerPage(0);
-        requestFeed.setId(request.getFeedId());
-        BaseFeed feed = null;
-        try{
-         feed = this.storage.getFeed(requestFeed);
-        }catch (StorageException e) {
-            throw new ServiceException("Search Failed -- can not get feed, feed not stored ",e,GDataResponse.NOT_FOUND);
-        }
-        for (String entryId : result) {
-            ServerBaseEntry requestEntry = new ServerBaseEntry();
-            requestEntry.setId(entryId);
-            requestEntry.setServiceConfig(service);
-            try{
-            BaseEntry entry = this.storage.getEntry(requestEntry);
-            feed.getEntries().add(entry);
-            }catch (StorageException e) {
-                
-                LOG.error("StorageException caught while fetching query results -- skip entry -- "+e.getMessage(),e);
-            }
-        }
-        dynamicElementFeedStragey(feed,request);
-        return feed;
-    }
-
-    
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/GDataService.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/GDataService.java
deleted file mode 100644
index 0151394..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/GDataService.java
+++ /dev/null
@@ -1,450 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.server;
-
-import java.io.IOException;
-import java.util.Date;
-import java.util.List;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.data.ServerBaseEntry;
-import org.apache.lucene.gdata.data.ServerBaseFeed;
-import org.apache.lucene.gdata.server.registry.ComponentType;
-import org.apache.lucene.gdata.server.registry.EntryEventMediator;
-import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
-import org.apache.lucene.gdata.storage.ModificationConflictException;
-import org.apache.lucene.gdata.storage.ResourceNotFoundException;
-import org.apache.lucene.gdata.storage.Storage;
-import org.apache.lucene.gdata.storage.StorageController;
-import org.apache.lucene.gdata.storage.StorageException;
-
-import com.google.gdata.data.BaseEntry;
-import com.google.gdata.data.BaseFeed;
-import com.google.gdata.data.DateTime;
-import com.google.gdata.data.Generator;
-import com.google.gdata.data.Link;
-import com.google.gdata.util.ParseException;
-
-/**
- * default implementation of the {@link org.apache.lucene.gdata.server.Service}
- * interface.
- * 
- * @author Simon Willnauer
- * 
- */
-public class GDataService implements Service {
-    private static final Log LOG = LogFactory.getLog(GDataService.class);
-
-    protected Storage storage;
-
-    protected GDataServerRegistry registry = GDataServerRegistry.getRegistry();
-
-    private static final Generator generator;
-
-    private static final String generatorName = "Lucene GData-Server";
-
-    private static final String generatorURI = "http://lucene.apache.org";
-
-    private static final String XMLMIME = "application/atom+xml";
-    
-    protected final EntryEventMediator entryEventMediator;
-    static {
-        generator = new Generator();
-        generator.setName(generatorName);
-        generator.setUri(generatorURI);
-        generator.setVersion("0.1");
-    }
-
-    protected GDataService() throws ServiceException {
-        try {
-            StorageController controller = GDataServerRegistry.getRegistry()
-                    .lookup(StorageController.class,
-                            ComponentType.STORAGECONTROLLER);
-            if (controller == null)
-                throw new StorageException(
-                        "StorageController is not registered");
-            this.storage = controller.getStorage();
-            this.entryEventMediator = GDataServerRegistry.getRegistry().getEntryEventMediator();
-        } catch (StorageException e) {
-            LOG
-                    .fatal(
-                            "Can't get Storage Instance -- can't serve any requests",
-                            e);
-            ServiceException ex = new ServiceException(
-                    "Can't get Storage instance" + e.getMessage(), e,GDataResponse.SERVER_ERROR);
-            ex.setStackTrace(e.getStackTrace());
-            throw ex;
-        }
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.Service#createEntry(org.apache.lucene.gdata.server.GDataRequest,
-     *      org.apache.lucene.gdata.server.GDataResponse)
-     */
-
-    public BaseEntry createEntry(GDataRequest request, GDataResponse response)
-            throws ServiceException {
-
-        if (LOG.isInfoEnabled())
-            LOG.info("create Entry for feedId: " + request.getFeedId());
-
-        ServerBaseEntry entry = buildEntry(request, response);
-        entry.setFeedId(request.getFeedId());
-        entry.setServiceConfig(request.getConfigurator());
-        BaseEntry tempEntry = entry.getEntry();
-        tempEntry.setPublished(getCurrentDateTime());
-        tempEntry.setUpdated(getCurrentDateTime());
-        BaseEntry retVal = null;
-        removeDynamicElements(entry.getEntry());
-        try {
-            retVal = this.storage.storeEntry(entry);
-        } catch (Exception e) {
-            
-            ServiceException ex = new ServiceException("Could not store entry",
-                    e,GDataResponse.SERVER_ERROR);
-            ex.setStackTrace(e.getStackTrace());
-            throw ex;
-        }
-        this.entryEventMediator.entryAdded(entry);
-        return retVal;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.Service#deleteEntry(org.apache.lucene.gdata.server.GDataRequest,
-     *      org.apache.lucene.gdata.server.GDataResponse)
-     */
-
-    public BaseEntry deleteEntry(GDataRequest request, GDataResponse response)
-            throws ServiceException {
-
-        ServerBaseEntry entry = new ServerBaseEntry();
-        entry.setServiceConfig(request.getConfigurator());
-        entry.setFeedId(request.getFeedId());
-        entry.setId(request.getEntryId());
-        setVersionId(entry,request,response);
-        if (entry.getId() == null)
-            throw new ServiceException(
-                    "entry id is null -- can not delete null entry",GDataResponse.SERVER_ERROR);
-        try {
-            this.storage.deleteEntry(entry);
-            
-        } catch (ResourceNotFoundException e) {
-            
-            ServiceException ex = new ServiceException(
-                    "Could not delete entry", e,GDataResponse.BAD_REQUEST);
-            ex.setStackTrace(e.getStackTrace());
-            throw ex;
-        }catch (ModificationConflictException e) {
-            
-            ServiceException ex = new ServiceException(
-                    "Could not delete entry - version conflict",e, GDataResponse.CONFLICT);
-            ex.setStackTrace(e.getStackTrace());
-            throw ex;  
-        }catch (StorageException e) {
-            
-            ServiceException ex = new ServiceException(
-                    "Could not delete entry", e,GDataResponse.SERVER_ERROR);
-            ex.setStackTrace(e.getStackTrace());
-            throw ex;
-        }
-        this.entryEventMediator.entryDeleted(entry);
-        //TODO change ret value
-        return null;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.Service#updateEntry(org.apache.lucene.gdata.server.GDataRequest,
-     *      org.apache.lucene.gdata.server.GDataResponse)
-     */
-
-    public BaseEntry updateEntry(GDataRequest request, GDataResponse response)
-            throws ServiceException {
-
-        ServerBaseEntry entry = buildEntry(request, response);
-        entry.setFeedId(request.getFeedId());
-        setVersionId(entry,request,response);
-        entry.setServiceConfig(request.getConfigurator());
-        if (LOG.isInfoEnabled())
-            LOG.info("update Entry" + entry.getId() + " for feedId: "
-                    + request.getFeedId());
-        if (entry.getId() == null) {
-            throw new ServiceException("Entry id is null can not update entry",GDataResponse.BAD_REQUEST);
-        }
-        if (!entry.getId().equals(request.getEntryId())) {
-            if (LOG.isInfoEnabled())
-                LOG
-                        .info("Entry id in the entry xml does not match the requested resource -- XML-ID:"
-                                + entry.getId()
-                                + "; Requested resource: "
-                                + request.getEntryId());
-
-            throw new ServiceException(
-                    "Entry id in the entry xml does not match the requested resource",GDataResponse.BAD_REQUEST);
-        }
-        BaseEntry tempEntry = entry.getEntry();
-        tempEntry.setUpdated(getCurrentDateTime());
-        removeDynamicElements(entry.getEntry());
-        
-        BaseEntry retVal = null;
-     
-        try {
-            retVal = this.storage.updateEntry(entry);
-        } catch (ResourceNotFoundException e) {
-            
-            ServiceException ex = new ServiceException(
-                    "Could not update entry", e,GDataResponse.BAD_REQUEST);
-            ex.setStackTrace(e.getStackTrace());
-            throw ex;
-        }catch (ModificationConflictException e) {
-            ServiceException ex = new ServiceException(
-                    "Could not update entry - version conflict", e,GDataResponse.CONFLICT);
-            ex.setStackTrace(e.getStackTrace());
-            throw ex;
-        }catch (StorageException e) {
-
-            ServiceException ex = new ServiceException(
-                    "Could not update entry", e,GDataResponse.SERVER_ERROR);
-            ex.setStackTrace(e.getStackTrace());
-            throw ex;
-        }
-        this.entryEventMediator.entryUpdated(entry);
-        return retVal;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.Service#getFeed(org.apache.lucene.gdata.server.GDataRequest,
-     *      org.apache.lucene.gdata.server.GDataResponse)
-     */
-    @SuppressWarnings("unchecked")
-    public BaseFeed getFeed(GDataRequest request, GDataResponse response)
-            throws ServiceException {
-
-        ServerBaseFeed feed = new ServerBaseFeed();
-        feed.setId(request.getFeedId());
-        feed.setStartIndex(request.getStartIndex());
-        feed.setItemsPerPage(request.getItemsPerPage());
-        feed.setServiceConfig(request.getConfigurator());
-        try {
-            /*
-             * the strategy executes either a search or a direct access.
-             */
-            BaseFeed retVal = this.storage.getFeed(feed);
-            dynamicElementFeedStragey(retVal, request);
-
-            return retVal;
-            /*
-             * Resource not found will be detected in Gdata request.
-             * the request queries the storage for the feed to get the service for the feed
-             */
-        } catch (StorageException e) {
-            ServiceException ex = new ServiceException("Could not get feed", e,GDataResponse.NOT_FOUND);
-            ex.setStackTrace(e.getStackTrace());
-            throw ex;
-        }
-
-    }
-
-    private Link buildLink(String rel, String type, String href) {
-        Link retVal = new Link();
-        retVal.setHref(href);
-        retVal.setRel(rel);
-        retVal.setType(type);
-        return retVal;
-    }
-
-    private ServerBaseEntry buildEntry(final GDataRequest request,
-            final GDataResponse response) throws ServiceException {
-        try {
-            ServerBaseEntry entry = new ServerBaseEntry(GDataEntityBuilder
-                    .buildEntry(request));
-            return entry;
-
-        } catch (ParseException e) {
-            ServiceException ex = new ServiceException(
-                    "Could not parse entry from incoming request", e, GDataResponse.BAD_REQUEST);
-            ex.setStackTrace(e.getStackTrace());
-            throw ex;
-        } catch (IOException e) {
-            ServiceException ex = new ServiceException(
-                    "Could not read or open input stream", e, GDataResponse.BAD_REQUEST);
-            ex.setStackTrace(e.getStackTrace());
-            throw ex;
-        }
-    }
-
-
-    /**
-     * @see org.apache.lucene.gdata.server.Service#getSingleEntry(org.apache.lucene.gdata.server.GDataRequest,
-     *      org.apache.lucene.gdata.server.GDataResponse)
-     */
-
-    public BaseEntry getSingleEntry(GDataRequest request, GDataResponse response)
-            throws ServiceException {
-
-        try {
-            ServerBaseEntry entry = new ServerBaseEntry();
-            entry.setServiceConfig(request.getConfigurator());
-            entry.setFeedId(request.getFeedId());
-            entry.setId(request.getEntryId());
-
-            
-            if(entry.getId() == null){
-                throw new ServiceException("entry is null can't get entry", GDataResponse.BAD_REQUEST);
-            }
-                
-            BaseEntry retVal = null;
-            retVal = this.storage.getEntry(entry);
-            dynamicElementEntryStragey(retVal, request);
-            return retVal;
-        } catch (ResourceNotFoundException e) {
-            ServiceException ex = new ServiceException(
-                    "Could not get entry", e, GDataResponse.BAD_REQUEST);
-            ex.setStackTrace(e.getStackTrace());
-            throw ex;
-        } catch (StorageException e) {
-            ServiceException ex = new ServiceException("Could not get entry", e, GDataResponse.SERVER_ERROR);
-            ex.setStackTrace(e.getStackTrace());
-            throw ex;
-        }
-    }
-
-    /*
-     * adds all dynamic element to the entry
-     */
-    private void dynamicElementEntryStragey(final BaseEntry entry,
-            final GDataRequest request) {
-        setSelfLink(entry, request.getContextPath());
-    }
-
-    /*
-     * adds all dynamic element to the feed entries
-     */
-    @SuppressWarnings("unchecked")
-    protected void dynamicElementFeedStragey(final BaseFeed feed,
-            final GDataRequest request) {
-         buildDynamicFeedElements(request, feed);
-        List<BaseEntry> entryList = feed.getEntries();
-        for (BaseEntry entry : entryList) {
-            String id = new StringBuilder(request.getContextPath()).append(entry.getId()).append("/").toString();
-            setSelfLink(entry, id);
-        }
-
-    }
-
-    /*
-     * The selfLink is build from a prefix and the entry id. The prefix is the
-     * context path of the requested feed. This will be used to request the
-     * entry directly
-     */@SuppressWarnings("unchecked")
-    private BaseEntry setSelfLink(final BaseEntry entry, String id) {
-        Link self = buildLink(Link.Rel.SELF, XMLMIME, id);
-        StringBuilder builder = new StringBuilder(id);
-        builder.append(entry.getVersionId());
-        Link edit = buildLink(Link.Rel.ENTRY_EDIT,XMLMIME,builder.toString());
-        List<Link> list = entry.getLinks();
-        list.add(edit);
-        list.add(self);
-        return entry;
-    }
-
-    /*
-     * build the dynamic elements like self link and next link
-     */
-    private void buildDynamicFeedElements(final GDataRequest request,
-            final BaseFeed feed) {
-        feed.setGenerator(generator);
-        feed.setItemsPerPage(request.getItemsPerPage());
-        feed.setStartIndex(request.getStartIndex());
-        feed.setId(request.getContextPath());
-        List<Link> links = feed.getLinks();
-        links.add(
-                buildLink(Link.Rel.SELF, Link.Type.ATOM, request.getSelfId()));
-        links.add(
-                buildLink(Link.Rel.NEXT, XMLMIME, request.getNextId()));
-        String prevLink = request.getPreviousId();
-        if(prevLink != null)
-            links.add(buildLink(Link.Rel.PREVIOUS,XMLMIME,prevLink));
-        
-
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.Service#close()
-     */
-    public void close() {
-        this.storage.close();
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.Service#getFeedLastModified(java.lang.String)
-     */
-    public Date getFeedLastModified(final String feedId) throws ServiceException {
-        try {
-            return new Date(this.storage.getFeedLastModified(feedId));
-           
-        } catch (StorageException e) {
-            ServiceException ex = new ServiceException(
-                    "Could not get Last update for feed -- "+feedId, e, GDataResponse.SERVER_ERROR);
-            ex.setStackTrace(e.getStackTrace());
-            throw ex;
-        }
-
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.Service#getEntryLastModified(java.lang.String, java.lang.String)
-     */
-    public Date getEntryLastModified(final String entryId,final String feedId) throws ServiceException {
-            try {
-                return new Date(this.storage.getEntryLastModified(entryId, feedId));
-            } catch (StorageException e) {
-                ServiceException ex = new ServiceException(
-                        "Could not get Last update for entry  -- "+entryId, e, GDataResponse.SERVER_ERROR);
-                ex.setStackTrace(e.getStackTrace());
-                throw ex;
-            }
-        
-    }
-    private ServerBaseEntry setVersionId(final ServerBaseEntry entry, final GDataRequest request, final GDataResponse response)throws ServiceException{
-        try{
-            entry.setVersion(Integer.parseInt(request.getEntryVersion()));
-            return entry;
-        }catch (Exception e) {
-            LOG.error("Can not parse entry version -- version is not an integer -- versionid: "+request.getEntryVersion(),e);
-            throw new ServiceException("Can not parse entry version -- version is not an integer -- versionid: "+request.getEntryVersion(),e, GDataResponse.BAD_REQUEST);
-           
-        }
-    }
-    /*
-     * provide current time to set as published / updated values
-     * always use servertime to prevent client / server time lag
-     * Timezoneshift is 0
-     */
-    protected DateTime getCurrentDateTime(){
-        return new DateTime(System.currentTimeMillis(),0);
-    }
-    
-    private void removeDynamicElements(BaseEntry entry){
-        Link selfLink = entry.getSelfLink();
-        if(selfLink != null)
-            entry.getLinks().remove(selfLink);
-        Link editLink = entry.getEditLink();
-        if(editLink != null)
-            entry.getLinks().remove(editLink);
-    }
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/Service.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/Service.java
deleted file mode 100644
index a3d7d8d..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/Service.java
+++ /dev/null
@@ -1,162 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */ 
- 
-package org.apache.lucene.gdata.server; 
- 
-import java.util.Date;
-
-import com.google.gdata.data.BaseEntry; 
-import com.google.gdata.data.BaseFeed; 
- 
- 
-/** 
- * The Service class represents an interface to access the GData service 
- * componentes of the GData-Server. It encapsulates all interactions with the 
- * GData client. 
- * <p> 
- * This class provides the base level common functionality required to access 
- * the GData components. It is also designed to act as a base class that can be 
- * extended for specific types of underlaying server components as different 
- * indexing or storage components. 
- * </p> 
- * <p> 
- * It could also encapsulate caching mechanismn build on top of the storage to 
- * reduce load on the storage component 
- * </p> 
- *  
- * @author Simon Willnauer 
- *  
- *  
- */ 
-public interface Service { 
- 
-    /** 
-     * Service method to create an entry in an already created and existing 
-     * feed. This method will create the entry and passes the entry to the 
-     * indexing component to make the new entry accessable via <i>get-queries</i>. 
-     * The response and the corresponding http status code will be added to the 
-     * given <code>FeedResponse</code>. 
-     *  
-     * @param request - 
-     *            the current FeedRequest 
-     * @param response - 
-     *            the current FeedResponse 
-     * @return - the entry which has been created  
-     * @throws ServiceException - 
-     *             if the corresponding feed does not exist or the storage can 
-     *             not be accessed 
-     */ 
-    public abstract BaseEntry createEntry(final GDataRequest request, 
-            final GDataResponse response) throws ServiceException; 
- 
-    /** 
-     * Service Method to delete an entry specified in the given FeedRequest. 
-     * This method will remove the entry permanently. There will be no 
-     * possiblity to restore the entry. The response and the corresponding http 
-     * status code will be added to the given <code>FeedResponse</code>. 
-     *  
-     * @param request - 
-     *            the current FeedRequest 
-     * @param response - 
-     *            the current FeedResponse 
-     * @return - the entry wich has been deleted 
-     * @throws ServiceException - 
-     *             if the entry does not exist or the storage can not be 
-     *             accessed 
-     */ 
-    public abstract BaseEntry deleteEntry(GDataRequest request, final GDataResponse response) 
-            throws ServiceException; 
- 
-    /** 
-     * Service method to update an existing entry in a existing feed context. 
-     * The entry version will be checked and a <code>ServiceException</code> 
-     * will be thrown if the version to update is outdated. The new entry will 
-     * be passed to the indexing component to make the version accessable via 
-     * <i>get-queries</i>. 
-     *  
-     * @param request - 
-     *            the current FeedRequest 
-     * @param response - 
-     *            the current FeedResponse 
-     * @return - the entry wich has been updated 
-     * @throws ServiceException - 
-     *             if the corresponding feed does not exist, the storage can not 
-     *             be accessed or the version to update is out of date. 
-     */ 
-    public abstract BaseEntry  updateEntry(final GDataRequest request, 
-            final GDataResponse response) throws ServiceException; 
- 
-    /** 
-     * Service method to retrieve a requested Feed. The feed will also be added to 
-     * the given <code>FeedResponse</code> instance and can also be accessed 
-     * via the <code>FeedResponse</code> object. 
-     *  
-     * @param request - 
-     *            the current FeedRequest 
-     * @param response - 
-     *            the current FeedResponse 
-     * @return - the requested feed 
-     *  
-     * @throws ServiceException - 
-     *             If the storage can not be accessed or the requested feed does 
-     *             not exist. 
-     */ 
-    public abstract BaseFeed getFeed(final GDataRequest request, final GDataResponse response) 
-            throws ServiceException; 
- 
-    /** 
-     * Service method to retrieve a requested entry. The entry will also be added to 
-     * the given <code>FeedResponse</code> instance and can also be accessed 
-     * via the <code>FeedResponse</code> object. 
-     *  
-     * @param request - 
-     *            the current FeedRequest 
-     * @param response - 
-     *            the current FeedResponse 
-     * @return - the requested entry 
-     *  
-     * @throws ServiceException - 
-     *             If the storage can not be accessed or the requested entry does 
-     *             not exist. 
-     */ 
-    public abstract BaseEntry getSingleEntry(final GDataRequest request, final GDataResponse response) 
-            throws ServiceException; 
-     
-    /**
-     * will close the Service - service should not be used after this method has been called
-     */
-    public void close();
-
-    /**
-     * Retruns the date of the last modification for the given feed id
-     * @param feedId - the id of the feed 
-     * @return - the last modified date or the current date if the date can not be retrieved
-     * @throws ServiceException - if the storage can not be accessed
-     */
-    public abstract Date getFeedLastModified(String feedId)throws ServiceException;
-
-    /**
-     * Retruns the date of the last modification for the given entry id
-     * @param entryId - the id of the entry
-     * @param feedId  - the feed id this entry belongs to
-     * @return - the last modified date or the current date if the date can not be retrieved
-     * @throws ServiceException - if the storage can not be accessed 
-     */
-    public abstract Date getEntryLastModified(String entryId, String feedId)throws ServiceException;
-     
- 
- 
-} 
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/ServiceException.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/ServiceException.java
deleted file mode 100644
index 9643e2b..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/ServiceException.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-
-package org.apache.lucene.gdata.server;
-
-
-/**
- * The ServiceException is used to encapsulate all {@link java.lang.Exception}
- * throw by underlying layers of the
- * {@link org.apache.lucene.gdata.server.Service} layer.
- * 
- * @author Simon Willnauer
- * 
- */
-public class ServiceException extends Exception {
-    
-    private int errorCode;
-    /**
-     * 
-     */
-    private static final long serialVersionUID = -7099825107871876584L;
-
-    /**
-     * Constructs a new ServiceException
-     * @param errorCode - gdata request error code
-     */
-    public ServiceException(int errorCode) {
-        super();
-        this.errorCode = errorCode;
-
-    }
-
-    /**
-     * Constructs a new ServiceException
-     * @param arg0 - the exception message
-     * @param errorCode - gdata request error code
-     */
-    public ServiceException(String arg0,int errorCode) {
-        super(arg0);
-        this.errorCode = errorCode;
-    }
-
-    /**
-     * Constructs a new ServiceException
-     * @param arg0 - the exception message
-     * @param arg1 - the exception cause
-     * @param errorCode - gdata request error code
-     */
-    public ServiceException(String arg0, Throwable arg1,int errorCode) {
-        super(arg0, arg1);
-        this.errorCode = errorCode;
-        
-    }
-
-    /**
-     * Constructs a new ServiceException
-     * @param arg0 - the exception cause
-     * @param errorCode - gdata request error code
-     */
-    public ServiceException(Throwable arg0,int errorCode) {
-        super(arg0);
-        this.errorCode = errorCode;
-    }
-
-    /**
-     * @return Returns the errorCode.
-     */
-    public int getErrorCode() {
-        return this.errorCode;
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/ServiceFactory.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/ServiceFactory.java
deleted file mode 100644
index 9476695..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/ServiceFactory.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.server;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.server.administration.AdminService;
-import org.apache.lucene.gdata.server.administration.GDataAdminService;
-import org.apache.lucene.gdata.server.registry.Component;
-import org.apache.lucene.gdata.server.registry.ComponentType;
-import org.apache.lucene.gdata.server.registry.ServerComponent;
-
-
-/**
- * The {@link ServiceFactory} creates {@link Service} implementations to access
- * the GData - Server components.
- * This class should not be access directy. The class will be registered in the {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry}.
- * Use {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry#lookup(Class, ComponentType)}
- * 
- * @author Simon Willnauer
- * 
- */
-@Component(componentType=ComponentType.SERVICEFACTORY)
-public class ServiceFactory implements ServerComponent {
-
-    private static final Log LOG = LogFactory.getLog(ServiceFactory.class);
-
-	
-
-	/**
-	 * public constructor to enable loading via the registry
-     * @see org.apache.lucene.gdata.server.registry.Component
-     * @see org.apache.lucene.gdata.server.registry.GDataServerRegistry
-	 */
-	public ServiceFactory() {
-		//
-	}
-
-	/**
-	 * Creates a {@link Service} instance.
-	 * @param request - the request for this service
-	 * 
-	 * @return a Service instance
-	 */
-	public Service getService(GDataRequest request) {
-		try{
-            if(request.isSearchRequested())
-                return new GDataSearchService();
-		return new GDataService();
-        }catch (Exception e) {
-            //
-        }
-        return null;
-	}
-    
-    /**
-     * Creates a {@link AdminService} instance
-     * @return a AdminService instance
-     */
-    public AdminService getAdminService(){
-        try {
-            return new GDataAdminService();
-        } catch (ServiceException e) {
-           LOG.warn("Factory method can not create GDataAdminService returning null-- "+e.getMessage(),e);
-        }
-        return null;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.registry.ServerComponent#initialize()
-     */
-    public void initialize() {
-        //
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.registry.ServerComponent#destroy()
-     */
-    public void destroy() {
-        //
-    }
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/administration/AccountBuilder.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/administration/AccountBuilder.java
deleted file mode 100644
index af823f2..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/administration/AccountBuilder.java
+++ /dev/null
@@ -1,84 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.server.administration;
-
-import java.io.IOException;
-import java.io.Reader;
-import java.net.URL;
-
-
-
-import org.apache.commons.digester.Digester;
-import org.apache.lucene.gdata.data.GDataAccount;
-import org.apache.lucene.gdata.utils.SimpleSaxErrorHandler;
-import org.apache.xerces.parsers.SAXParser;
-import org.xml.sax.SAXException;
-
-/**
- * Helper class to create {@link org.apache.lucene.gdata.data.GDataAccount}
- * instances from a xml stream provided via a {@link Reader} instance.
- * 
- * @author Simon Willnauer
- * 
- */
-public class AccountBuilder {
-
-    /**
-     * Reads the xml from the provided reader and binds the values to the 
-     * @param reader - the reader to read the xml from
-     * @return - the GDataAccount 
-     * @throws IOException - if an IOException occurs
-     * @throws SAXException - if the xml can not be parsed by the sax reader
-     */
-    public static GDataAccount buildAccount(final Reader reader) throws IOException,
-            SAXException {
-        if (reader == null)
-            throw new IllegalArgumentException("Reader must not be null");
-        URL resource = AccountBuilder.class.getResource("/gdata-account.xsd");
-        if(resource == null)
-            throw new RuntimeException("can not find xml schema file 'gdata-account.xsd' -- file must be present on the classpath");
-        String schemaFile = resource.getFile();
-        GDataAccount account = null;
-        /*
-         * Force using apache xerces parser for digester
-         */
-        SAXParser parser = new SAXParser();
-        parser.setFeature("http://apache.org/xml/features/validation/schema-full-checking",true);
-        parser.setFeature("http://apache.org/xml/features/validation/schema",true);
-        parser.setFeature("http://xml.org/sax/features/validation",true); 
-        parser.setProperty("http://apache.org/xml/properties/schema/external-noNamespaceSchemaLocation",schemaFile);
-        Digester digester = new Digester(parser);
-        digester.setValidating(true);
-        digester.setErrorHandler(new SimpleSaxErrorHandler());
-        digester.setSchema(schemaFile);
-        digester.addObjectCreate("account", GDataAccount.class);
-        digester.addBeanPropertySetter("account/account-name", "name");
-        digester.addBeanPropertySetter("account/password", "password");
-        digester.addBeanPropertySetter("account/account-role", "rolesAsInt");
-        digester.addBeanPropertySetter("account/account-owner/name",
-                "authorname");
-        digester.addBeanPropertySetter("account/account-owner/email-address",
-                "authorMail");
-        digester.addBeanPropertySetter("account/account-owner/url",
-                "authorLink");
-
-        account = (GDataAccount) digester.parse(reader);
-        return account;
-    }
-    
-    
-  
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/administration/AdminService.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/administration/AdminService.java
deleted file mode 100644
index b6e81b2..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/administration/AdminService.java
+++ /dev/null
@@ -1,123 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.server.administration;
-
-import org.apache.lucene.gdata.data.GDataAccount;
-import org.apache.lucene.gdata.data.ServerBaseFeed;
-import org.apache.lucene.gdata.server.Service;
-import org.apache.lucene.gdata.server.ServiceException;
-
-/**
- * The AdminService interface extends the Service interface to serve common
- * administrator requests. Common users can not create feed or user instances.
- * This interface provides all actions for create, delete or update Users and
- * Feeds. Each Feed has an associated Feed - Name which acts as an ID. Feed will
- * be identified by the feed name e.g. {@link com.google.gdata.data.Source#getId()}
- * <p>User accounts are supposed to have a unique username attribute as the username acts as a primary key for the storage</p>
- *  
- * 
- * @author Simon Willnauer
- * 
- */
-public interface AdminService extends Service {
-
-    /**
-     * Creates a new feed instance.
-     * 
-     * @param feed -
-     *            the feed to create
-     * @param account - the account who own this feed
-     * @throws ServiceException -
-     *             if the feed can not be created
-     */
-    public abstract void createFeed(final ServerBaseFeed feed,
-            final GDataAccount account) throws ServiceException;
-
-    /**
-     * Updates the given feed
-     * 
-     * @param feed -
-     *            the feed to update
-     * @param account - the account who own this feed
-     * 
-     * @throws ServiceException -
-     *             if the feed can not be updated or does not exist.
-     */
-    public abstract void updateFeed(final ServerBaseFeed feed,
-            final GDataAccount account) throws ServiceException;
-
-    /**
-     * Deletes the given feed and all containing entries from the storage. The feed will not be accessable
-     * anymore.
-     * 
-     * @param feed -
-     *            the feed to deltete
-     * 
-     * @throws ServiceException -
-     *             if the feed can not be deleted or does not exist
-     */
-    public abstract void deleteFeed(final ServerBaseFeed feed) throws ServiceException;
-
-    /**
-     * Creates a new account accout.
-     * 
-     * @param account -
-     *            the account to create
-     * @throws ServiceException -
-     *             if the account can not be created or the account does already
-     *             exist.
-     */
-    public abstract void createAccount(final GDataAccount account)
-            throws ServiceException;
-
-    /**
-     * Deletes the given account from the storage. it will also delete all
-     * accociated feeds.
-     * 
-     * @param account
-     *            the account to delete
-     * @throws ServiceException -
-     *             if the account does not exist or the account can not be deleted
-     */
-    public abstract void deleteAccount(final GDataAccount account)
-            throws ServiceException;
-
-    /**
-     * Updates the given account if the account already exists.
-     * 
-     * @param account - the account to update 
-     * @throws ServiceException - if the account can not be updated or the account does not exist
-     */
-    public abstract void updateAccount(final GDataAccount account)
-            throws ServiceException;
-
-    /**
-     * Returns the account for the given account name or <code>null</code> if the account does not exist 
-     * 
-     * @param account - account name
-     * @return - the account for the given account name or <code>null</code> if the account does not exist
-     * @throws ServiceException - if the account can not be accessed
-     */
-    public abstract GDataAccount getAccount(String account) throws ServiceException;
-    
-    /**
-     * Returns the account associated with the feed for the given feed id
-     * @param feedId - the feed id
-     * @return - the GdataAccount assoziated with the feed for the given feed Id or <code>null</code> if there is no feed for the given feed Id
-     * @throws ServiceException - if the storage can not be accessed
-     */
-    public abstract GDataAccount getFeedOwningAccount(String feedId) throws ServiceException;
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/administration/GDataAdminService.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/administration/GDataAdminService.java
deleted file mode 100644
index a4df68e..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/administration/GDataAdminService.java
+++ /dev/null
@@ -1,231 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.server.administration;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.data.GDataAccount;
-import org.apache.lucene.gdata.data.ServerBaseFeed;
-import org.apache.lucene.gdata.server.GDataResponse;
-import org.apache.lucene.gdata.server.GDataService;
-import org.apache.lucene.gdata.server.ServiceException;
-import org.apache.lucene.gdata.server.registry.ProvidedService;
-import org.apache.lucene.gdata.storage.StorageException;
-
-/**
- * default implementation of the
- * {@link org.apache.lucene.gdata.server.administration.AdminService} interface.
- * 
- * @author Simon Willnauer
- * 
- */
-public class GDataAdminService extends GDataService implements AdminService {
-    private static final Log LOG = LogFactory.getLog(GDataAdminService.class);
-
-    /**
-     * @throws ServiceException
-     */
-    public GDataAdminService() throws ServiceException {
-        super();
-
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.administration.AdminService#createFeed(org.apache.lucene.gdata.data.ServerBaseFeed,
-     *      org.apache.lucene.gdata.data.GDataAccount)
-     */
-    public void createFeed(final ServerBaseFeed feed, final GDataAccount account)
-            throws ServiceException {
-        if (feed == null)
-            throw new ServiceException("Can not create feed -- feed is null",
-                    GDataResponse.BAD_REQUEST);
-        if (account == null)
-            throw new ServiceException(
-                    "Can not create feed -- account is null",
-                    GDataResponse.UNAUTHORIZED);
-        if (feed.getId() == null)
-            throw new ServiceException("Feed ID is null can not create feed",
-                    GDataResponse.BAD_REQUEST);
-        if (account.getName() == null)
-            throw new ServiceException(
-                    "Account name is null -- can't create feed",
-                    GDataResponse.UNAUTHORIZED);
-        try {
-            feed.setUpdated(getCurrentDateTime());
-            feed.setAccount(account);
-            this.storage.storeFeed(feed, account.getName());
-        } catch (StorageException e) {
-            if (LOG.isInfoEnabled())
-                LOG.info("Can not save feed -- " + e.getMessage(), e);
-            throw new ServiceException("Can not save feed", e,
-                    GDataResponse.BAD_REQUEST);
-        }
-
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.administration.AdminService#updateFeed(org.apache.lucene.gdata.data.ServerBaseFeed,
-     *      org.apache.lucene.gdata.data.GDataAccount)
-     */
-    public void updateFeed(ServerBaseFeed feed, GDataAccount account)
-            throws ServiceException {
-        if (feed == null)
-            throw new ServiceException("Can not update null feed",
-                    GDataResponse.BAD_REQUEST);
-        if (account == null)
-            throw new ServiceException(
-                    "Can not update feed -- account is null",
-                    GDataResponse.UNAUTHORIZED);
-        if (feed.getId() == null)
-            throw new ServiceException("Feed ID is null can not update feed",
-                    GDataResponse.BAD_REQUEST);
-        if (account.getName() == null)
-            throw new ServiceException(
-                    "Account name is null -- can't update feed",
-                    GDataResponse.UNAUTHORIZED);
-        try {
-            feed.setAccount(account);
-            feed.setUpdated(getCurrentDateTime());
-            this.storage.updateFeed(feed, account.getName());
-        } catch (StorageException e) {
-            if (LOG.isInfoEnabled())
-                LOG.info("Can not update feed -- " + e.getMessage(), e);
-            throw new ServiceException("Can not update feed", e,
-                    GDataResponse.BAD_REQUEST);
-        }
-
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.administration.AdminService#deleteFeed(org.apache.lucene.gdata.data.ServerBaseFeed)
-     */
-    public void deleteFeed(ServerBaseFeed feed) throws ServiceException {
-        if (feed == null)
-            throw new ServiceException("Can not delete null feed",
-                    GDataResponse.BAD_REQUEST);
-        if (feed.getId() == null)
-            throw new ServiceException("Feed ID is null can not delete feed",
-                    GDataResponse.BAD_REQUEST);
-        String serviceid = null;
-        try {
-            serviceid = this.storage.getServiceForFeed(feed.getId());
-            this.storage.deleteFeed(feed.getId());
-        } catch (StorageException e) {
-            if (LOG.isInfoEnabled())
-                LOG.info("Can not delete feed -- " + e.getMessage(), e);
-            throw new ServiceException("Can not delete feed", e,
-                    GDataResponse.BAD_REQUEST);
-        }
-        ProvidedService service = this.registry.getProvidedService(serviceid);
-        feed.setServiceConfig(service);
-        this.entryEventMediator.allEntriesDeleted(feed);
-
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.administration.AdminService#createAccount(org.apache.lucene.gdata.data.GDataAccount)
-     */
-    public void createAccount(GDataAccount account) throws ServiceException {
-        if (account == null)
-            throw new ServiceException("Can not save null account",
-                    GDataResponse.BAD_REQUEST);
-        try {
-            this.storage.storeAccount(account);
-        } catch (StorageException e) {
-            if (LOG.isInfoEnabled())
-                LOG.info("Can not save account -- " + e.getMessage(), e);
-            throw new ServiceException("Can not save account", e,
-                    GDataResponse.BAD_REQUEST);
-        }
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.administration.AdminService#deleteAccount(org.apache.lucene.gdata.data.GDataAccount)
-     */
-    public void deleteAccount(GDataAccount account) throws ServiceException {
-        if (account == null)
-            throw new ServiceException("Can not delete null account",
-                    GDataResponse.BAD_REQUEST);
-        try {
-            this.storage.deleteAccount(account.getName());
-        } catch (StorageException e) {
-            if (LOG.isInfoEnabled())
-                LOG.info("Can not save account -- " + e.getMessage(), e);
-            throw new ServiceException("Can not save account", e,
-                    GDataResponse.BAD_REQUEST);
-        }
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.administration.AdminService#updateAccount(org.apache.lucene.gdata.data.GDataAccount)
-     */
-    public void updateAccount(GDataAccount account) throws ServiceException {
-        if (account == null)
-            throw new ServiceException("Can not update null account",
-                    GDataResponse.BAD_REQUEST);
-        try {
-            this.storage.updateAccount(account);
-        } catch (StorageException e) {
-            if (LOG.isInfoEnabled())
-                LOG.info("Can not save account -- " + e.getMessage(), e);
-            throw new ServiceException("Can not save account", e,
-                    GDataResponse.BAD_REQUEST);
-        }
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.administration.AdminService#getAccount(java.lang.String)
-     */
-    public GDataAccount getAccount(String accountName) throws ServiceException {
-        if (accountName == null)
-            throw new ServiceException("Can not get null account",
-                    GDataResponse.BAD_REQUEST);
-        try {
-            return this.storage.getAccount(accountName);
-        } catch (StorageException e) {
-            if (LOG.isInfoEnabled())
-                LOG.info("Can not get account -- " + e.getMessage(), e);
-            throw new ServiceException("Can not get account", e,
-                    GDataResponse.BAD_REQUEST);
-        }
-
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.administration.AdminService#getFeedOwningAccount(java.lang.String)
-     */
-    public GDataAccount getFeedOwningAccount(String feedId)
-            throws ServiceException {
-        if (feedId == null)
-            throw new ServiceException(
-                    "Can not get account - feed id must not be null",
-                    GDataResponse.BAD_REQUEST);
-        try {
-            String accountName = this.storage.getAccountNameForFeedId(feedId);
-            return this.storage.getAccount(accountName);
-
-        } catch (StorageException e) {
-            if (LOG.isInfoEnabled())
-                LOG.info(
-                        "Can not get account for feed Id -- " + e.getMessage(),
-                        e);
-            throw new ServiceException(
-                    "Can not get account for the given feed id", e,
-                    GDataResponse.BAD_REQUEST);
-        }
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/administration/package.html b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/administration/package.html
deleted file mode 100644
index 3ea9939..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/administration/package.html
+++ /dev/null
@@ -1,10 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
-<html> 
-<head> 
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
-   <meta name="Author" content="Simon Willnauer"> 
-</head> 
-<body> 
-Classes and Services used for user and feed configuration
-</body> 
-</html> 
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/authentication/AuthenticationController.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/authentication/AuthenticationController.java
deleted file mode 100644
index 6102735..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/authentication/AuthenticationController.java
+++ /dev/null
@@ -1,123 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.server.authentication;
-
-import org.apache.lucene.gdata.data.GDataAccount;
-import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
-import org.apache.lucene.gdata.server.registry.ServerComponent;
-
-/**
- * Implementations of the AuthenticationController interface contain all the
- * logic for processing token based authentification. A token is an encoded
- * unique <tt>String</tt> value passed back to the client if successfully
- * authenticated. Clients provide account name, password, the requested service
- * and the name of the application used for accessing the the gdata service.
- * <p>
- * The algorithmn to create and reauthenticate the token can be choosen by the
- * implementor. <br/> This interface extends
- * {@link org.apache.lucene.gdata.server.registry.ServerComponent} e.g.
- * implementing classes can be registered as a
- * {@link org.apache.lucene.gdata.server.registry.Component} in the
- * {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry} to be
- * accessed via the provided lookup service
- * </p>
- * 
- * @see org.apache.lucene.gdata.server.authentication.BlowfishAuthenticationController
- * @author Simon Willnauer
- * 
- */
-public interface AuthenticationController extends ServerComponent {
-
-    /**
-     * The header name containing the authentication token provided by the
-     * client
-     */
-    public static final String AUTHORIZATION_HEADER = "Authorization";
-
-    /**
-     * Authentication parameter for the account name. Provided by the client to
-     * recieve the auth token.
-     */
-    public static final String ACCOUNT_PARAMETER = "Email";
-
-    /**
-     * Authentication parameter for the account password. Provided by the client
-     * to recieve the auth token.
-     */
-    public static final String PASSWORD_PARAMETER = "Passwd";
-
-    /**
-     * Authentication parameter for the requested service. Provided by the
-     * client to recieve the auth token.
-     */
-    public static final String SERVICE_PARAMETER = "service";
-
-    /**
-     * Authentication parameter for the application name of the clients
-     * application. This is just used for loggin purposes
-     */
-    public static final String APPLICATION_PARAMETER = "source";
-
-    /**
-     * The key used for respond the auth token to the client. Either as a cookie
-     * (key as cookie name) or as plain response (TOKEN_KEY=TOKEN)
-     */
-    public final static String TOKEN_KEY = "Auth";
-
-    /**
-     * Creates a authentication token for the given account. The token will be
-     * calculated based on a part of the clients ip address, the account role
-     * and the account name and the time in millisecond at the point of
-     * creation.
-     * 
-     * @param account -
-     *            the account to create the token for
-     * @param requestIp -
-     *            the clients request ip address
-     * @return - a BASE64 encoded authentification token
-     */
-    public abstract String authenticatAccount(GDataAccount account,
-            String requestIp);
-
-    /**
-     * Authenticates the given auth token and checks the given parameter for
-     * matching the information contained inside the token.
-     * <p>
-     * if the given account name is <code>null</code> the authentication will
-     * ignore the account name and the decision whether the token is valid or
-     * not will be based on the given role compared to the role inside the token
-     * </p>
-     * 
-     * @param token -
-     *            the token to authenticate
-     * @param requestIp -
-     *            the client request IP address
-     * @param role -
-     *            the required role
-     * @param accountName -
-     *            the name of the account
-     * @return <code>true</code> if the given values match the values inside
-     *         the token and if the timestamp plus the configured timeout is
-     *         greater than the current time, if one of the values does not
-     *         match or the token has timed out it will return
-     *         <code>false</code>
-     */
-    public abstract boolean authenticateToken(final String token,
-            final String requestIp, AccountRole role, String accountName);
-
-}
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/authentication/AuthenticationException.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/authentication/AuthenticationException.java
deleted file mode 100644
index 40fa489..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/authentication/AuthenticationException.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.server.authentication;
-
-/**
- * 
- * @author Simon Willnauer
- *
- */
-public class AuthenticationException extends Exception {
-
-    /**
-     * 
-     */
-    private static final long serialVersionUID = 5467768078178612671L;
-
-    /**
-     * Constructs a new Authentication Exception
-     */
-    public AuthenticationException() {
-        super();
-       
-    }
-
-    /**
-     * Constructs a new Authentication Exception with the specified detail message 
-     * @param arg0 - detail message
-     */
-    public AuthenticationException(String arg0) {
-        super(arg0);
-       
-    }
-
-    /**
-     * Constructs a new Authentication Exception with the specified detail message and
-     * nested exception caused this exception.
-      * @param arg0 -
-     *            detail message
-     * @param arg1 -
-     *            nested exception
-     */
-    public AuthenticationException(String arg0, Throwable arg1) {
-        super(arg0, arg1);
-       
-    }
-
-    /**
-     * Constructs a new Authentication Exception with a nested exception caused this exception
-     * @param arg0 - nested exception
-     */
-    public AuthenticationException(Throwable arg0) {
-        super(arg0);
-       
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/authentication/AuthenticatorException.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/authentication/AuthenticatorException.java
deleted file mode 100644
index ca972bc..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/authentication/AuthenticatorException.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.server.authentication;
-
-/**
- * This exception will be thrown by
- * {@link org.apache.lucene.gdata.server.authentication.AuthenticationController}
- * implementations if an error while de/encrypting the token occures.
- * 
- * @author Simon Willnauer
- * 
- */
-public class AuthenticatorException extends RuntimeException {
-
-    private static final long serialVersionUID = -5690495392712564651L;
-
-    /**
-     * Constructs a new Authenticator Exception
-     */ 
-    public AuthenticatorException() {
-        super();
-        
-    }
-
-    /**
-     * Constructs a new Authenticator Exception with the specified detail message.
-     * @param arg0 - detail message
-     */
-    public AuthenticatorException(String arg0) {
-        super(arg0);
-        
-    }
-
-    /**
-     * Constructs a new Authenticator Exception with the specified detail message and
-     * nested exception.
-     * 
-     * @param arg0 -
-     *            detail message
-     * @param arg1 -
-     *            nested exception
-     */
-    public AuthenticatorException(String arg0, Throwable arg1) {
-        super(arg0, arg1);
-        
-    }
-
-    /**
-     * Constructs a new Authenticator Exception with a nested exception caused this exception.
-     * @param arg0 - nested exception
-     */
-    public AuthenticatorException(Throwable arg0) {
-        super(arg0);
-        
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/authentication/BlowfishAuthenticationController.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/authentication/BlowfishAuthenticationController.java
deleted file mode 100644
index 8c04ec6..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/authentication/BlowfishAuthenticationController.java
+++ /dev/null
@@ -1,277 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.server.authentication;
-
-import java.io.IOException;
-import java.io.UnsupportedEncodingException;
-import java.security.Provider;
-import java.security.Security;
-import java.util.StringTokenizer;
-import java.util.concurrent.locks.ReentrantLock;
-
-import javax.crypto.BadPaddingException;
-import javax.crypto.Cipher;
-import javax.crypto.IllegalBlockSizeException;
-import javax.crypto.KeyGenerator;
-import javax.crypto.spec.SecretKeySpec;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.data.GDataAccount;
-import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
-import org.apache.lucene.gdata.server.registry.Component;
-import org.apache.lucene.gdata.server.registry.ComponentType;
-import org.apache.lucene.gdata.server.registry.configuration.Requiered;
-
-import sun.misc.BASE64Decoder;
-import sun.misc.BASE64Encoder;
-
-/**
- * A
- * {@link org.apache.lucene.gdata.server.authentication.AuthenticationController}
- * implmentation using a <i>Blowfish</i> algorithmn to en/decrpyt the
- * authentification token. The <i>Blowfish</i> algorithmn enables a stateless
- * authetication of the client. The token contains all information to
- * authenticate the client on possible other hosts.
- * <p>
- * The token contains the first 32 bit of the client ip (e.g. 192.168.0),
- * account name, {@link org.apache.lucene.gdata.data.GDataAccount.AccountRole}
- * and the cration time as a timestamp. The timestamp will be checked on every
- * subsequent request. If the timestamp plus the configured timeout is less
- * than the current time the client has to reauthenticate again.
- * </p>
- * <p>
- * The auth token returned by the
- * {@link BlowfishAuthenticationController#authenticatAccount(GDataAccount, String)}
- * method is a BASE64 encoded string.
- * </p>
- * 
- * @see javax.crypto.Cipher
- * @see sun.misc.BASE64Encoder
- * @see sun.misc.BASE64Decoder
- * @author Simon Willnauer
- * 
- */
-@Component(componentType = ComponentType.AUTHENTICATIONCONTROLLER)
-public class BlowfishAuthenticationController implements
-        AuthenticationController {
-    private static final Log LOG = LogFactory
-            .getLog(BlowfishAuthenticationController.class);
-
-    private static final String ALG = "Blowfish";
-
-    private static final String TOKEN_LIMITER = "#";
-
-    private static final String ENCODING = "UTF-8";
-
-    private Cipher deCrypt;
-
-    private Cipher enCrypt;
-
-    private int minuteOffset = 30;
-
-    private long milisecondOffset;
-
-    private BASE64Encoder encoder = new BASE64Encoder();
-
-    private BASE64Decoder decoder = new BASE64Decoder();
-
-    private ReentrantLock lock = new ReentrantLock();
-
-    
-    private  String key;
-
-    /**
-     * @see org.apache.lucene.gdata.server.authentication.AuthenticationController#initialize()
-     */
-    public void initialize() {
-        if (this.key == null)
-            throw new IllegalArgumentException("Auth key must not be null");
-        if (this.key.length() < 5 || this.key.length() > 16)
-            throw new IllegalArgumentException(
-                    "Auth key length must be greater than 4 and less than 17");
-
-        try {
-            Provider sunJce = new com.sun.crypto.provider.SunJCE();
-            Security.addProvider(sunJce);
-            KeyGenerator kgen = KeyGenerator.getInstance(ALG);
-            kgen.init(448); // 448 Bit^M
-            byte[] raw = this.key.getBytes();
-            SecretKeySpec skeySpec = new SecretKeySpec(raw, ALG);
-            this.deCrypt = Cipher.getInstance(ALG);
-            this.enCrypt = Cipher.getInstance(ALG);
-            this.deCrypt.init(Cipher.DECRYPT_MODE, skeySpec);
-            this.enCrypt.init(Cipher.ENCRYPT_MODE, skeySpec);
-        } catch (Exception e) {
-            throw new AuthenticatorException(
-                    "Can't initialize BlowfishAuthenticationController -- "
-                            + e.getMessage(), e);
-
-        }
-        calculateTimeOffset();
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.authentication.AuthenticationController#authenticatAccount(org.apache.lucene.gdata.data.GDataAccount,
-     *      java.lang.String)
-     */
-    public String authenticatAccount(GDataAccount account, String requestIp) {
-        try {
-            String passIp = requestIp.substring(0, requestIp.lastIndexOf('.'));
-            String role = Integer.toString(account.getRolesAsInt());
-
-            return calculateAuthToken(passIp, role, account.getName());
-        } catch (Exception e) {
-            throw new AuthenticatorException("Can not authenticat account -- "
-                    + e.getMessage(), e);
-
-        }
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.authentication.AuthenticationController#authenticateToken(java.lang.String,
-     *      java.lang.String,
-     *      org.apache.lucene.gdata.data.GDataAccount.AccountRole,
-     *      java.lang.String)
-     */
-    public boolean authenticateToken(final String token,
-            final String requestIp, AccountRole role, String accountName) {
-        if (LOG.isInfoEnabled())
-            LOG.info("authenticate Token " + token + " for requestIp: "
-                    + requestIp);
-        if (token == null || requestIp == null)
-            return false;
-        String passIp = requestIp.substring(0, requestIp.lastIndexOf('.'));
-        String authString = null;
-        try {
-            authString = deCryptAuthToken(token);
-        } catch (Exception e) {
-            throw new AuthenticatorException("Can not decrypt token -- "
-                    + e.getMessage(), e);
-        }
-        if (authString == null)
-            return false;
-        try {
-            StringTokenizer tokenizer = new StringTokenizer(authString,
-                    TOKEN_LIMITER);
-            if (!tokenizer.nextToken().equals(passIp))
-                return false;
-            String tempAccountName = tokenizer.nextToken();
-            int intRole = Integer.parseInt(tokenizer.nextToken());
-            /*
-             * Authentication goes either for a account role or a account. For
-             * entry manipulation the account name will be retrieved by the
-             * feedId otherwise it will be null If it is null the authentication
-             * goes against the account role
-             */
-            if (tempAccountName == null
-                    || (!tempAccountName.equals(accountName) && !GDataAccount
-                            .isInRole(intRole, role)))
-                return false;
-            long timeout = Long.parseLong(tokenizer.nextToken());
-
-            return (timeout + this.milisecondOffset) > System
-                    .currentTimeMillis();
-        } catch (Exception e) {
-            LOG.error("Error occured while encrypting token " + e.getMessage(),
-                    e);
-            return false;
-        }
-
-    }
-
-    private void calculateTimeOffset() {
-        this.milisecondOffset = this.minuteOffset * 60 * 1000;
-    }
-
-    protected String calculateAuthToken(final String ipAddress,
-            final String role, String accountName)
-            throws IllegalBlockSizeException, BadPaddingException,
-            UnsupportedEncodingException {
-        StringBuilder builder = new StringBuilder();
-        builder.append(ipAddress).append(TOKEN_LIMITER);
-        builder.append(accountName).append(TOKEN_LIMITER);
-        builder.append(role).append(TOKEN_LIMITER);
-        builder.append(System.currentTimeMillis());
-
-        this.lock.lock();
-        try {
-            byte[] toencode = builder.toString().getBytes(ENCODING);
-            byte[] result = this.enCrypt.doFinal(toencode);
-            return this.encoder.encode(result);
-        } finally {
-            this.lock.unlock();
-
-        }
-
-    }
-
-    protected String deCryptAuthToken(final String authToken)
-            throws IOException, IllegalBlockSizeException, BadPaddingException {
-        this.lock.lock();
-        try {
-            byte[] input = this.decoder.decodeBuffer(authToken);
-            byte[] result = this.deCrypt.doFinal(input);
-            return new String(result, ENCODING);
-        } finally {
-            this.lock.unlock();
-        }
-
-    }
-
-    /**
-     * @return Returns the minuteOffset.
-     */
-    @Requiered
-    public int getLoginTimeout() {
-        return this.minuteOffset;
-    }
-
-    /**
-     * @param minuteOffset
-     *            The minuteOffset to set.
-     */
-    @Requiered
-    public void setLoginTimeout(int minuteOffset) {
-        this.minuteOffset = minuteOffset;
-        calculateTimeOffset();
-    }
-
-    /**
-     * @return Returns the key.
-     */
-    public String getKey() {
-        return this.key;
-    }
-
-    /**
-     * @param key
-     *            The key to set.
-     */
-    public void setKey(String key) {
-        this.key = key;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.registry.ServerComponent#destroy()
-     */
-    public void destroy() {
-        //
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/authentication/GDataHttpAuthenticator.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/authentication/GDataHttpAuthenticator.java
deleted file mode 100644
index 5062e75..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/authentication/GDataHttpAuthenticator.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.server.authentication;
-
-import javax.servlet.http.HttpServletRequest;
-
-import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
-import org.apache.lucene.gdata.server.GDataRequest;
-
-/**
- * The GData protocol is based on the widly know REST approach and therefor
- * client authentication will mostly be provided via a REST interface.
- * <p>
- * This interface describes internally used authentication methods to be
- * implemented by http based authenticator implementations. The GData Server
- * basically has 2 different REST interfaces need authentication. One is for
- * altering feed entries and the other for administration actions.
- * </p>
- * <p>The interface altering entries work with {@link com.google.gdata.client.Service.GDataRequest} object created by the handler and passed to the {@link org.apache.lucene.gdata.server.Service} instance.
- * Administration interfaces use the plain {@link javax.servlet.http.HttpServletRequest} inside the handler.
- * For each type of interface a authentication type a method has to be provided by implementing classes.</p> 
- * 
- * @author Simon Willnauer
- * 
- */
-public interface GDataHttpAuthenticator {
-
-    /**
-     * Authenticates the client request based on the given GdataRequst and required account role
-     * @param request - the gdata request
-     * @param role - the required role for passing the authentication
-     * 
-     * @return <code>true</code> if the request successfully authenticates, otherwise <code>false</code>
-     */
-    public boolean authenticateAccount(final GDataRequest request,
-            AccountRole role);
-
-    /**
-     * Authenticates the client request based on the given requst and required account role
-     * @param request - the client request
-     * @param role - the required role for passing the authentication
-     * @return <code>true</code> if the request successfully authenticates, otherwise <code>false</code>
-     */
-    public boolean authenticateAccount(final HttpServletRequest request,
-            AccountRole role);
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/authentication/package.html b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/authentication/package.html
deleted file mode 100644
index 2b5672b..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/authentication/package.html
+++ /dev/null
@@ -1,10 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
-<html> 
-<head> 
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
-   <meta name="Author" content="Simon Willnauer"> 
-</head> 
-<body> 
-Classes and Exceptions used for client authentification.
-</body> 
-</html> 
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/package.html b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/package.html
deleted file mode 100644
index 6363daf..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/package.html
+++ /dev/null
@@ -1,10 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
-<html> 
-<head> 
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
-   <meta name="Author" content="Simon Willnauer"> 
-</head> 
-<body> 
-GData-Server classes encapsulation all protocol-level interactions and underlaying GData components. 
-</body> 
-</html> 
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/Component.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/Component.java
deleted file mode 100644
index 4733cdd..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/Component.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.server.registry;
-
-import static java.lang.annotation.ElementType.TYPE;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-import java.lang.annotation.Retention;
-import java.lang.annotation.Target;
-
-/**
- * The {@link Component} annotation is used to annotate a class as a
- * server-component of the GDATA-Server. Annotated class can be configured via
- * the gdata-config.xml file to be looked up by aribaty classes at runtime via
- * the
- * {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry#lookup(Class, ComponentType)}
- * method.
- * <p>
- * Classes annotated with the Component annotation need to provide a default
- * constructor to be instanciated via reflection. Components of the GData-Server
- * are definded in the
- * {@link org.apache.lucene.gdata.server.registry.ComponentType} enumeration.
- * Each of the enum types are annotated with a
- * {@link org.apache.lucene.gdata.server.registry.SuperType} annotation. This
- * annotation specifies the super class or interface of the component. A class
- * annotated with the Component annotation must implement or extends this
- * defined super-type. This enables developers to use custom implemetations of
- * the component like a custom {@link org.apache.lucene.gdata.storage.Storage}.
- * </p>
- * <p>
- * Each ComponentType can only registerd once as the
- * {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry} does not
- * provide multipe instances of a ComponentType.
- * </p>
- * <p>
- * This annotation can only annotate types and can be accessed at runtime.
- * {@link java.lang.annotation.Target} ==
- * {@link java.lang.annotation.ElementType#TYPE} and
- * {@link java.lang.annotation.Retention} ==
- * {@link java.lang.annotation.RetentionPolicy#RUNTIME}.
- * 
- * @see org.apache.lucene.gdata.server.registry.GDataServerRegistry
- * @see org.apache.lucene.gdata.server.registry.ComponentType
- * @see org.apache.lucene.gdata.server.registry.SuperType
- * 
- * 
- * @author Simon Willnauer
- * 
- */
-@Target( { TYPE })
-@Retention(value = RUNTIME)
-public @interface Component {
-
-    /**
-     * @see ComponentType
-     * @return - the component type
-     */
-    ComponentType componentType();
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/ComponentType.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/ComponentType.java
deleted file mode 100644
index 29d3698..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/ComponentType.java
+++ /dev/null
@@ -1,53 +0,0 @@
-package org.apache.lucene.gdata.server.registry;
-
-import org.apache.lucene.gdata.search.SearchComponent;
-import org.apache.lucene.gdata.server.ServiceFactory;
-import org.apache.lucene.gdata.server.authentication.AuthenticationController;
-import org.apache.lucene.gdata.servlet.handler.RequestHandlerFactory;
-import org.apache.lucene.gdata.storage.StorageController;
-
-/**
- * The enumeration {@link ComponentType} defines the GDATA-Server Components 
- * available via {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry#lookup(Class, ComponentType)} 
- * method.
- * @see org.apache.lucene.gdata.server.registry.Component
- * @see org.apache.lucene.gdata.server.registry.GDataServerRegistry 
- * @author Simon Willnauer
- *
- */
-public enum ComponentType {
-    /**
-     * StorageController Type
-     * 
-     * @see StorageController
-     */
-    @SuperType(superType = StorageController.class)
-    STORAGECONTROLLER,
-    /**
-     * RequestHandlerFactory Type
-     * 
-     * @see RequestHandlerFactory
-     */
-    @SuperType(superType = RequestHandlerFactory.class)
-    REQUESTHANDLERFACTORY,
-    /**
-     * SearchComponent Type
-     * @see SearchComponent
-     */
-    @SuperType(superType = SearchComponent.class)
-    SEARCHCONTROLLER,
-    /**
-     * ServiceFactory Type
-     * 
-     * @see ServiceFactory
-     */
-    @SuperType(superType = ServiceFactory.class)
-    SERVICEFACTORY,
-    /**
-     * Super type for AuthenticationController implementations
-     * @see AuthenticationController
-     */
-    @SuperType(superType = AuthenticationController.class)
-    AUTHENTICATIONCONTROLLER
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/DataBuilderException.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/DataBuilderException.java
deleted file mode 100644
index e69de29..0000000
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/EntryEventListener.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/EntryEventListener.java
deleted file mode 100755
index 36e283e..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/EntryEventListener.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.server.registry;
-
-import org.apache.lucene.gdata.data.ServerBaseEntry;
-import org.apache.lucene.gdata.data.ServerBaseFeed;
-
-/**
- * The EntryEventListener interface should be implemented by any class needs to be informed about any changes on entries.
- * To register a class as a EntryEventListener use:
- * <p>
- * <tt>
- * GdataServerRegistry.registerEntryEventListener(EntryEventListener);
- * <tt>
- * </p>
- * @author Simon Willnauer
- *
- */
-public interface EntryEventListener {
-    /**
-     * will be invoked on every successful update on every entry
-     * @param entry the updated entry
-     */
-    public abstract void fireUpdateEvent(ServerBaseEntry entry);
-    /**
-     * will be invoked on every successful entry insert
-     * @param entry
-     */
-    public abstract void fireInsertEvent(ServerBaseEntry entry);
-    /**
-     * will be invoked on every successful entry delete
-     * @param entry
-     */
-    public abstract void fireDeleteEvent(ServerBaseEntry entry);
-    
-    /**
-     * will be invoked on every successful feed delete
-     * @param feed - the feed containing the feed id to delete all entries for
-     */
-    public abstract void fireDeleteAllEntries(ServerBaseFeed feed);
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/EntryEventMediator.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/EntryEventMediator.java
deleted file mode 100755
index 27d7d76..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/EntryEventMediator.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.server.registry;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.lucene.gdata.data.ServerBaseEntry;
-import org.apache.lucene.gdata.data.ServerBaseFeed;
-
-/**
- * This class will be informed about every successful entry event and
- * distributes all event to all registered
- * {@link org.apache.lucene.gdata.server.registry.EntryEventListener}
- * 
- * @author Simon Willnauer
- * 
- */
-public abstract class EntryEventMediator {
-
-    private final List<EntryEventListener> entryEventListener = new ArrayList<EntryEventListener>(
-            5);
-
-    /**
-     * @return - a entry event mediator instance
-     */
-    public abstract EntryEventMediator getEntryEventMediator();
-
-    /**
-     * Registers a {@link EntryEventListener}. This listener will be fired if an
-     * entry update, insert or delete occurs
-     * 
-     * @param listener -
-     *            listener to register
-     */
-    public void registerEntryEventListener(final EntryEventListener listener) {
-        if (listener == null || this.entryEventListener.contains(listener))
-            return;
-        this.entryEventListener.add(listener);
-    }
-
-    /**
-     * @param entry -
-     *            the updated entry
-     */
-    public void entryUpdated(final ServerBaseEntry entry) {
-        for (EntryEventListener listener : this.entryEventListener) {
-            listener.fireUpdateEvent(entry);
-        }
-    }
-
-    /**
-     * @param entry -
-     *            the added entry
-     */
-    public void entryAdded(final ServerBaseEntry entry) {
-        for (EntryEventListener listener : this.entryEventListener) {
-            listener.fireInsertEvent(entry);
-        }
-    }
-    
-    /**
-     * @param feed - the feed to delete all entries for
-     */
-    public void allEntriesDeleted(final ServerBaseFeed feed){
-        for (EntryEventListener listener : this.entryEventListener) {
-            listener.fireDeleteAllEntries(feed);
-        }
-    }
-
-    /**
-     * @param entry -
-     *            the deleted entry
-     */
-    public void entryDeleted(final ServerBaseEntry entry) {
-        for (EntryEventListener listener : this.entryEventListener) {
-            listener.fireDeleteEvent(entry);
-        }
-    }
-    
-    /**
-     * checks if the listener is already registered.
-     * @param listner - the listener to check
-     * @return <code>true</code> if and only if the given listener is already registered, otherwise <code>false</code>.
-     */
-    public boolean isListenerRegistered(final EntryEventListener listner){
-        return listner!=null&&this.entryEventListener.contains(listner);
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/FeedInstanceConfigurator.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/FeedInstanceConfigurator.java
deleted file mode 100644
index e69de29..0000000
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/GDataRequestListener.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/GDataRequestListener.java
deleted file mode 100755
index 661b7b9..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/GDataRequestListener.java
+++ /dev/null
@@ -1,92 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.server.registry;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import javax.servlet.ServletRequestEvent;
-import javax.servlet.ServletRequestListener;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.server.registry.Scope.ScopeType;
-
-/**
- * This <tt>ServletRequestListener</tt> is used by the registry to notify
- * registered {@link org.apache.lucene.gdata.server.registry.ScopeVisitor}
- * implementations when a request is initialized e.g destroyed.
- * 
- * 
- * @see org.apache.lucene.gdata.server.registry.ScopeVisitable
- * @see javax.servlet.ServletRequestListener
- * @author Simon Willnauer
- * 
- */
-@Scope(scope = ScopeType.REQUEST)
-public class GDataRequestListener implements ServletRequestListener,
-        ScopeVisitable {
-    private final GDataServerRegistry registry;
-
-    private final List<ScopeVisitor> visitors = new ArrayList<ScopeVisitor>(5);
-
-    private static final Log LOG = LogFactory
-            .getLog(GDataRequestListener.class);
-
-    /**
-     * @throws RegistryException
-     * 
-     */
-    public GDataRequestListener() throws RegistryException {
-        this.registry = GDataServerRegistry.getRegistry();
-        this.registry.registerScopeVisitable(this);
-
-    }
-
-    /**
-     * @see javax.servlet.ServletRequestListener#requestDestroyed(javax.servlet.ServletRequestEvent)
-     */
-    public void requestDestroyed(ServletRequestEvent arg0) {
-        for (ScopeVisitor visitor : this.visitors) {
-            visitor.visiteDestroy();
-        }
-
-    }
-
-    /**
-     * @see javax.servlet.ServletRequestListener#requestInitialized(javax.servlet.ServletRequestEvent)
-     */
-    public void requestInitialized(ServletRequestEvent arg0) {
-        for (ScopeVisitor visitor : this.visitors) {
-            visitor.visiteInitialize();
-        }
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.registry.ScopeVisitable#accept(org.apache.lucene.gdata.server.registry.ScopeVisitor)
-     */
-    public void accept(ScopeVisitor visitor) {
-
-        if (!this.visitors.contains(visitor) && visitor != null) {
-            this.visitors.add(visitor);
-            if(LOG.isDebugEnabled())
-                LOG.debug("visitor added -- " + visitor.getClass());
-        }
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/GDataServerRegistry.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/GDataServerRegistry.java
deleted file mode 100644
index 0059347..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/GDataServerRegistry.java
+++ /dev/null
@@ -1,378 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.server.registry;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.server.registry.configuration.ComponentConfiguration;
-import org.apache.lucene.gdata.server.registry.configuration.PropertyInjector;
-import org.apache.lucene.gdata.utils.ReflectionUtils;
-
-/**
- * 
- * The GDataServerRegistry represents the registry component of the GData
- * Server. All provided services and server components will be registered here.
- * The GData Server serves RSS / ATOM feeds for defined services. Each service
- * provides <i>n</i> feeds of a defined subclass of
- * {@link com.google.gdata.data.BaseFeed}. Each feed contains <i>m</i> entries
- * of a defined subclass of {@link com.google.gdata.data.BaseEntry}. To
- * generate RSS / ATOM formates a class of the type
- * {@link com.google.gdata.data.ExtensionProfile} is also defined for a service.
- * <p>
- * The entry,feed and the ExtensionProfile classes are defined in the
- * gdata-config.xml and will be loaded when the server starts up.
- * </p>
- * <p>
- * The components defined in the gdata-config.xml will also be loaded and
- * instantiated at startup. If a component can not be loaded or an Exception
- * occurs the server will not start up. To cause of the exception or error will
- * be logged to the standard server output.
- * </p>
- * <p>
- * The GDataServerRegistry is a Singleton
- * </p>
- * 
- * 
- * @author Simon Willnauer
- * 
- */
-public class GDataServerRegistry extends EntryEventMediator{
-    private static GDataServerRegistry INSTANCE;
-
-    private static final Log LOG = LogFactory
-            .getLog(GDataServerRegistry.class);
-
-    private ScopeVisitable requestVisitable;
-
-    private ScopeVisitable sessionVisitable;
-
-    // not available yet
-    private ScopeVisitable contextVisitable;
-
-    private List<ScopeVisitor> visitorBuffer = new ArrayList<ScopeVisitor>(5);
-
-    private final Map<String, ProvidedService> serviceTypeMap = new HashMap<String, ProvidedService>();
-
-    private final Map<ComponentType, ComponentBean> componentMap = new HashMap<ComponentType, ComponentBean>(
-            ComponentType.values().length);
-
-    private GDataServerRegistry() {
-        // private - singleton
-    }
-
-    /**
-     * @return a Singleton registry instance
-     */
-    public static synchronized GDataServerRegistry getRegistry() {
-        if (INSTANCE == null)
-            INSTANCE = new GDataServerRegistry();
-        return INSTANCE;
-    }
-
-    /**
-     * Registers a {@link ProvidedService}
-     * 
-     * @param configurator -
-     *            the configurator to register in the registry
-     */
-    public void registerService(ProvidedService configurator) {
-        if (configurator == null) {
-            LOG.warn("Feed configurator is null -- skip registration");
-            return;
-        }
-        this.serviceTypeMap.put(configurator.getName(), configurator);
-    }
-
-    /**
-     * @param visitor -
-     *            the visitor to register
-     * @throws RegistryException
-     */
-    public synchronized void registerScopeVisitor(final ScopeVisitor visitor)
-            throws RegistryException {
-        if (visitor == null)
-            throw new IllegalArgumentException("visitor must not be null");
-        Scope scope = visitor.getClass().getAnnotation(Scope.class);
-        if (scope == null)
-            throw new RegistryException("Visitor has not Scope");
-        if (LOG.isInfoEnabled())
-            LOG.info("Register scope visitor -- " + visitor.getClass());
-        if (scope.scope().equals(Scope.ScopeType.REQUEST)
-                && this.requestVisitable != null)
-            this.requestVisitable.accept(visitor);
-        else if (scope.scope() == Scope.ScopeType.SESSION
-                && this.sessionVisitable != null)
-            this.sessionVisitable.accept(visitor);
-        else if (scope.scope() == Scope.ScopeType.CONTEXT
-                && this.contextVisitable != null)
-            this.sessionVisitable.accept(visitor);
-        else if (!this.visitorBuffer.contains(visitor))
-            this.visitorBuffer.add(visitor);
-    }
-
-    /**
-     * @param visitable -
-     *            the instance to register
-     * @throws RegistryException
-     * @see ScopeVisitable
-     */
-    public synchronized void registerScopeVisitable(
-            final ScopeVisitable visitable) throws RegistryException {
-        if (visitable == null)
-            throw new IllegalArgumentException("visitable must not be null");
-
-        Scope scope = visitable.getClass().getAnnotation(Scope.class);
-        if (scope == null)
-            throw new RegistryException("Visitable has not Scope");
-        if (LOG.isInfoEnabled())
-            LOG.info("Register scope visitable -- " + visitable.getClass());
-        if (scope.scope() == Scope.ScopeType.REQUEST
-                && this.requestVisitable == null)
-            this.requestVisitable = visitable;
-        else if (scope.scope() == Scope.ScopeType.SESSION
-                && this.sessionVisitable == null)
-            this.sessionVisitable = visitable;
-        else if (scope.scope() == Scope.ScopeType.CONTEXT
-                && this.contextVisitable == null)
-            this.sessionVisitable = visitable;
-
-        if (!this.visitorBuffer.isEmpty()) {
-
-            List<ScopeVisitor> tempList = this.visitorBuffer;
-            this.visitorBuffer = new ArrayList<ScopeVisitor>(5);
-            for (ScopeVisitor visitor : tempList) {
-                registerScopeVisitor(visitor);
-            }
-            tempList.clear();
-
-        }
-
-    }
-
-    /**
-     * Looks up the {@link ProvidedServiceConfig} by the given service name.
-     * 
-     * @param service
-     * @return - the {@link ProvidedServiceConfig} or <code>null</code> if the
-     *         no configuration for this service has been registered
-     */
-    public ProvidedService getProvidedService(String service) {
-        if (service == null)
-            throw new IllegalArgumentException(
-                    "Service is null - must not be null to get registered feed type");
-        return this.serviceTypeMap.get(service);
-    }
-
-    protected void flushRegistry() {
-        Collection<ProvidedService> services = this.serviceTypeMap.values();
-        for (ProvidedService service : services) {
-            service.destroy();
-        }
-        this.serviceTypeMap.clear();
-        this.componentMap.clear();
-    }
-
-    /**
-     * @param service -
-     *            the name of the service
-     * @return - <code>true</code> if and only if the service is registered,
-     *         otherwise <code>false</code>.
-     */
-    public boolean isServiceRegistered(String service) {
-        return this.serviceTypeMap.containsKey(service);
-
-    }
-
-    /**
-     * Destroys the registry and release all resources
-     */
-    public void destroy() {
-        for (ComponentBean component : this.componentMap.values()) {
-            component.getObject().destroy();
-        }
-
-        flushRegistry();
-
-    }
-
-    /**
-     * This method is the main interface to the Component Lookup Service of the
-     * registry. Every GDATA - Server component like STORAGE or the INDEXER
-     * component will be accessible via this method. To get a Component from the
-     * lookup service specify the expected Class as an argument and the
-     * component type of the component to return. For a lookup of the
-     * STORAGECONTORLER the code looks like:
-     * <p>
-     * <code> registryInstance.lookup(StorageController.class,ComponentType.STORAGECONTROLLER);</code>
-     * </p>
-     * 
-     * @param <R>
-     *            the type of the expected return value
-     * @param clazz -
-     *            Class object of the expected return value
-     * @param compType -
-     *            The component type
-     * @return the registered component or <code>null</code> if the component
-     *         can not looked up.
-     */
-    @SuppressWarnings("unchecked")
-    public <R> R lookup(Class<R> clazz, ComponentType compType) {
-        ComponentBean bean = this.componentMap.get(compType);
-        if (bean == null)
-            return null;
-        if (bean.getSuperType().equals(clazz))
-            return (R) bean.getObject();
-        return null;
-    }
-
-    /**
-     * All registered {@link ServerComponent} registered via this method are
-     * available via the
-     * {@link GDataServerRegistry#lookup(Class, ComponentType)} method. For each
-     * {@link ComponentType} there will be one single instance registered in the
-     * registry.
-     * <p>
-     * Eventually this method invokes the initialize method of the
-     * ServerComponent interface to prepare the component to be available via
-     * the lookup service
-     * </p>
-     * 
-     * @param <E> -
-     *            The interface of the component to register
-     * @param componentClass -
-     *            a implementation of a ServerComponent interface to register in
-     *            the registry
-     * @param configuration -
-     *            the component configuration {@link ComponentConfiguration}
-     * @throws RegistryException -
-     *             if the provided class does not implement the
-     *             {@link ServerComponent} interface, if the mandatory
-     *             annotations not visible at runtime or not set, if the super
-     *             type provided by the {@link ComponentType} for the class to
-     *             register is not a super type of the class or if the
-     *             invocation of the {@link ServerComponent#initialize()} method
-     *             throws an exception.
-     */
-    @SuppressWarnings("unchecked")
-    public <E extends ServerComponent> void registerComponent(
-            final Class<E> componentClass,
-            final ComponentConfiguration configuration)
-            throws RegistryException {
-
-        if (componentClass == null)
-            throw new IllegalArgumentException(
-                    "component class must not be null");
-
-        if (!ReflectionUtils.implementsType(componentClass,
-                ServerComponent.class))
-            throw new RegistryException(
-                    "can not register component. the given class does not implement ServerComponent interface -- "
-                            + componentClass.getName());
-        try {
-
-            Component annotation = componentClass
-                    .getAnnotation(Component.class);
-            if (annotation == null)
-                throw new RegistryException(
-                        "can not register component. the given class is not a component -- "
-                                + componentClass.getName());
-            ComponentType type = annotation.componentType();
-            if (this.componentMap.containsKey(type))
-                throw new RegistryException("component already registered -- "
-                        + type.name());
-            Class superType = type.getClass().getField(type.name())
-                    .getAnnotation(SuperType.class).superType();
-            if (!ReflectionUtils.isTypeOf(componentClass, superType))
-                throw new RegistryException("Considered super type <"
-                        + superType.getName() + "> is not a super type of <"
-                        + componentClass + ">");
-            ServerComponent comp = componentClass.newInstance();
-            if (configuration == null) {
-                if (LOG.isInfoEnabled())
-                    LOG.info("no configuration for ComponentType: "
-                            + type.name());
-            } else
-                configureComponent(comp, type, configuration);
-            comp.initialize();
-            ComponentBean bean = new ComponentBean(comp, superType);
-
-            this.componentMap.put(type, bean);
-            if (ReflectionUtils.implementsType(componentClass,
-                    ScopeVisitor.class))
-                this.registerScopeVisitor((ScopeVisitor) comp);
-        } catch (Exception e) {
-            throw new RegistryException("Can not register component -- "
-                    + e.getMessage(), e);
-        }
-
-    }
-
-    /*
-     * Injects the configured properties located in the configuration into the
-     * given server component
-     */
-    private void configureComponent(final ServerComponent component,
-            final ComponentType type, final ComponentConfiguration configuration) {
-        PropertyInjector injector = new PropertyInjector();
-        injector.setTargetObject(component);
-        injector.injectProperties(configuration);
-    }
-
-    private static class ComponentBean {
-        private final Class superType;
-
-        private final ServerComponent object;
-
-        ComponentBean(final ServerComponent object, final Class superType) {
-            this.superType = superType;
-            this.object = object;
-        }
-
-        ServerComponent getObject() {
-            return this.object;
-        }
-
-        Class getSuperType() {
-            return this.superType;
-        }
-
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.registry.EntryEventMediator#getEntryEventMediator()
-     */
-    @Override
-    public EntryEventMediator getEntryEventMediator() {
-        
-        return this;
-    }
-
-    /**
-     * @return - all registered services
-     */
-    public Collection<ProvidedService> getServices() {
-        
-        return this.serviceTypeMap.values();
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/ProvidedService.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/ProvidedService.java
deleted file mode 100644
index 2d51f67..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/ProvidedService.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */ 
-package org.apache.lucene.gdata.server.registry;
-
-import javax.xml.transform.Templates;
-
-import org.apache.lucene.gdata.search.config.IndexSchema;
-
-import com.google.gdata.data.ExtensionProfile;
-
-/**
- * This interface describes a service provided by the GData-Server.
- * @see org.apache.lucene.gdata.server.registry.GDataServerRegistry 
- * @author Simon Willnauer
- *
- */
-public interface ProvidedService {
-
-    /** 
-     * @return Returns the feedType. 
-     */
-    public abstract Class getFeedType();
-
-    /** 
-     * @return - the extension profile for this feed 
-     */
-    public abstract ExtensionProfile getExtensionProfile();
-
-    /**
-     * @return the entry Type configured for this Service
-     */
-    public abstract Class getEntryType();
-
-    /**
-     * @return - the service name
-     */
-    public abstract String getName();
-
-    /**
-     * releases all dependencies and resources
-     */
-    public abstract void destroy();
-    /**
-     * @return the index schema configuration for this service
-     */
-    public abstract IndexSchema getIndexSchema();
-    /**
-     * @return the compiled xslt stylesheet to transform the feed / entry for preview
-     */
-    public abstract Templates getTransformTemplate();
-    
-}
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/ProvidedServiceConfig.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/ProvidedServiceConfig.java
deleted file mode 100644
index 95f3f29..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/ProvidedServiceConfig.java
+++ /dev/null
@@ -1,364 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.server.registry;
-
-import java.lang.reflect.Constructor;
-
-import javax.xml.transform.Templates;
-import javax.xml.transform.TransformerConfigurationException;
-import javax.xml.transform.TransformerFactory;
-import javax.xml.transform.stream.StreamSource;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.search.config.IndexSchema;
-import org.apache.lucene.gdata.utils.Pool;
-import org.apache.lucene.gdata.utils.PoolObjectFactory;
-import org.apache.lucene.gdata.utils.SimpleObjectPool;
-
-import com.google.gdata.data.BaseEntry;
-import com.google.gdata.data.BaseFeed;
-import com.google.gdata.data.ExtensionProfile;
-
-/**
- * Standard implementation of
- * {@link org.apache.lucene.gdata.server.registry.ProvidedService} to be used
- * inside the
- * {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry}
- * <p>
- * ExtensionProfiles are used to generate and parse xml by the gdata api. For
- * that case all methods are synchronized. This will slow down the application
- * when performing lots of xml generation concurrently. For that case the
- * extensionProfile for a specific service will be pooled and reused.
- * </p>
- * 
- * 
- * @author Simon Willnauer
- * 
- */
-@Scope(scope = Scope.ScopeType.REQUEST)
-public class ProvidedServiceConfig implements ProvidedService, ScopeVisitor {
-    private final static Log LOG = LogFactory
-            .getLog(ProvidedServiceConfig.class);
-
-    private static final int DEFAULT_POOL_SIZE = 5;
-    private IndexSchema indexSchema;
-    /*
-     * To ensure a extension profile instance will not be shared within multiple
-     * threads each thread requesting a config will have one instance for the
-     * entire request.
-     */
-    protected final ThreadLocal<ExtensionProfile> extProfThreadLocal = new ThreadLocal<ExtensionProfile>();
-
-    /*
-     * ExtensionProfiles are used to generate and parse xml by the gdata api.
-     * For that case all methodes are synchronized. This will slow down the
-     * application when performing lots of xml generation concurrently. for that
-     * case the extensionProfile for a specific service will be pooled and
-     * reused.
-     */
-    private Pool<ExtensionProfile> profilPool;
-
-    private String serviceName;
-
-    private Class<? extends BaseEntry> entryType;
-
-    private Class<? extends BaseFeed> feedType;
-
-    private ExtensionProfile extensionProfile;
-
-    private int poolSize = DEFAULT_POOL_SIZE;
-    
-    private Templates transformerTemplate;
-    
-
-    /**
-     * @return Returns the poolSize.
-     */
-    public int getPoolSize() {
-        return this.poolSize;
-    }
-
-    /**
-     * @param poolSize
-     *            The poolSize to set.
-     */
-    public void setPoolSize(int poolSize) {
-        
-        this.poolSize = poolSize >= DEFAULT_POOL_SIZE ? poolSize
-                : DEFAULT_POOL_SIZE;
-    }
-
-    /**
-     * Default constructor to instantiate via reflection
-     */
-    public ProvidedServiceConfig() {
-        try {
-            GDataServerRegistry.getRegistry().registerScopeVisitor(this);
-        } catch (RegistryException e) {
-            throw new RuntimeException("Can not register ScopeVisitor -- "
-                    + e.getMessage(), e);
-        }
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.registry.ProvidedService#getFeedType()
-     */
-    public Class getFeedType() {
-        return this.feedType;
-    }
-
-    /**
-     * @param feedType
-     *            The feedType to set.
-     */
-    public void setFeedType(Class feedType) {
-        this.feedType = feedType;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.registry.ProvidedService#getExtensionProfile()
-     */
-    public ExtensionProfile getExtensionProfile() {
-        ExtensionProfile ext = this.extProfThreadLocal.get();
-        if (ext != null) {
-            return ext;
-        }
-        if(this.extensionProfile == null)
-            return null;
-        if (this.profilPool == null)
-            createProfilePool();
-        ext = this.profilPool.aquire();
-        this.extProfThreadLocal.set(ext);
-        return ext;
-    }
-
-    /**
-     * @param extensionProfil -
-     *            the extension profile for this feed configuration
-     */
-    @SuppressWarnings("unchecked")
-    public void setExtensionProfile(ExtensionProfile extensionProfil) {
-        if (extensionProfil == null)
-            throw new IllegalArgumentException(
-                    "ExtensionProfile  must not be null");
-        if (this.extensionProfile != null)
-            return;
-        this.extensionProfile = extensionProfil;
-
-    }
-
-    private void createProfilePool() {
-        if (LOG.isInfoEnabled())
-            LOG.info("Create ExtensionProfile pool with pool size:"
-                    + this.poolSize + " for service " + this.serviceName);
-        this.profilPool = new SimpleObjectPool<ExtensionProfile>(this.poolSize,
-                new ExtensionProfileFactory<ExtensionProfile>(
-                        this.extensionProfile.getClass(),this.entryType,this.feedType));
-    }
-
-    /**
-     * TODO add comment
-     * 
-     * @param <E>
-     * @param extensionProfileClass
-     * @throws InstantiationException
-     * @throws IllegalAccessException
-     */
-    public <E extends ExtensionProfile> void setExtensionProfileClass(
-            Class<E> extensionProfileClass) throws InstantiationException,
-            IllegalAccessException {
-        if (extensionProfileClass == null)
-            throw new IllegalArgumentException(
-                    "ExtensionProfile class must not be null");
-
-        setExtensionProfile(extensionProfileClass.newInstance());
-
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.registry.ProvidedService#getEntryType()
-     */
-    public Class getEntryType() {
-        return this.entryType;
-    }
-
-    /**
-     * @param entryType
-     */
-    public void setEntryType(Class entryType) {
-        this.entryType = entryType;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.registry.ProvidedService#getName()
-     */
-    public String getName() {
-        return this.serviceName;
-    }
-
-    /**
-     * @param serviceName
-     */
-    public void setName(String serviceName) {
-        this.serviceName = serviceName;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.registry.ProvidedService#destroy()
-     */
-    public void destroy() {
-        if (this.profilPool != null)
-            this.profilPool.destroy();
-        if (LOG.isInfoEnabled())
-            LOG.info("Destroy Service " + this.serviceName
-                    + " -- release all resources");
-        this.feedType = null;
-        this.entryType = null;
-        this.extensionProfile = null;
-    }
-
-    private static class ExtensionProfileFactory<Type extends ExtensionProfile>
-            implements PoolObjectFactory<Type> {
-        private final Class<? extends ExtensionProfile> clazz;
-
-        private final Constructor<? extends ExtensionProfile> constructor;
-
-        private static final Object[] constArray = new Object[0];
-        
-        private BaseEntry entry;
-        private BaseFeed feed;
-
-        ExtensionProfileFactory(Class<? extends ExtensionProfile> clazz, Class<? extends BaseEntry> entryClass, Class<? extends BaseFeed> feedClass) {
-            this.clazz = clazz;
-            try {
-                this.constructor = clazz.getConstructor(new Class[0]);
-                this.entry = entryClass.newInstance();
-                this.feed = feedClass.newInstance();
-            } catch (Exception e) {
-                throw new IllegalArgumentException(
-                        "The given class has no default constructor -- can not use as a ExtensionProfile -- "
-                                + this.clazz.getName(), e);
-            }
-        }
-
-        /**
-         * @see org.apache.lucene.gdata.utils.PoolObjectFactory#getInstance()
-         */
-        @SuppressWarnings("unchecked")
-        public Type getInstance() {
-
-            try {
-                Type retValue = (Type) this.constructor.newInstance(constArray);
-                this.entry.declareExtensions(retValue);
-                this.feed.declareExtensions(retValue);
-                return retValue; 
-            } catch (Exception e) {
-                throw new RuntimeException(
-                        "Can not instantiate new ExtensionProfile -- ", e);
-
-            }
-        }
-
-        /**
-         * @param type -
-         *            the ExtensionProfile to destroy
-         * @see org.apache.lucene.gdata.utils.PoolObjectFactory#destroyInstance(Object)
-         */
-        public void destroyInstance(Type type) {
-            //
-        }
-
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.registry.ScopeVisitor#visiteInitialize()
-     */
-    public void visiteInitialize() {
-        if(this.profilPool == null)
-            createProfilePool();
-        /*
-         * don't set a extension profile for each thread. The current thread
-         * might use another service and does not need the extension profile of
-         * this service
-         */
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.registry.ScopeVisitor#visiteDestroy()
-     */
-    public void visiteDestroy() {
-        /*
-         * Check every thread after request destroyed to release all profiles to
-         * the pool
-         */
-        ExtensionProfile ext = this.extProfThreadLocal.get();
-        if (ext == null) {
-            if(LOG.isDebugEnabled())
-            LOG.debug("ThreadLocal owns no ExtensionProfile in requestDestroy for service "
-                            + this.serviceName);
-            return;
-        }
-        this.extProfThreadLocal.set(null);
-        this.profilPool.release(ext);
-    }
-
-    /**
-     * @return Returns the indexSchema.
-     */
-    public IndexSchema getIndexSchema() {
-        return this.indexSchema;
-    }
-
-    /**
-     * @param indexSchema The indexSchema to set.
-     */
-    public void setIndexSchema(IndexSchema indexSchema) {
-        this.indexSchema = indexSchema;
-        if(this.indexSchema != null)
-            this.indexSchema.setName(this.serviceName);
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.registry.ProvidedService#getTransformTemplate()
-     */
-    public Templates getTransformTemplate() {
-        
-        return this.transformerTemplate;
-    }
-    
-    /**
-     * Sets and creates the preview transformer xslt template to provide a html formate for feeds and entries.
-     * The given file name must be available in the classpath. 
-     * @param filename - the name of the file in the classpath
-     */
-    public void setXsltStylesheet(String filename){
-        if(filename == null || filename.length() == 0){
-            LOG.info("No preview stylesheet configured for service "+this.serviceName);
-            return;
-        }
-        
-        TransformerFactory factory = TransformerFactory.newInstance();
-        
-        try {
-            this.transformerTemplate = factory.newTemplates(new StreamSource(ProvidedServiceConfig.class.getResourceAsStream(filename.startsWith("/")?filename:"/"+filename)));
-        } catch (TransformerConfigurationException e) {
-            throw new RuntimeException("Can not compile xslt stylesheet path: "+filename,e);
-        }
-        
-    }
-    
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/RegistryBuilder.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/RegistryBuilder.java
deleted file mode 100644
index 146131c..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/RegistryBuilder.java
+++ /dev/null
@@ -1,154 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.server.registry;
-
-import java.io.IOException;
-
-import org.apache.commons.digester.Digester;
-import org.apache.lucene.gdata.search.config.IndexSchema;
-import org.apache.lucene.gdata.search.config.IndexSchemaField;
-import org.apache.lucene.gdata.server.registry.configuration.ComponentConfiguration;
-import org.apache.lucene.gdata.utils.SimpleSaxErrorHandler;
-import org.apache.xerces.parsers.SAXParser;
-import org.xml.sax.SAXException;
-
-/**
- * Reads the configuration file and creates the
- * {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry} singleton
- * instance. All services and components will be instantiated and registered in
- * the registry.
- * 
- * @author Simon Willnauer
- * 
- */
-class RegistryBuilder {
-
-    /**
-     * builds the {@link GDataServerRegistry} accessible via the
-     * {@link GDataServerRegistry#getRegistry()} method
-     * 
-     * @throws IOException -
-     *             if an IOException occurs while reading the config file
-     * @throws SAXException -
-     *             if the config file can not be parsed
-     */
-    static void buildRegistry() throws IOException, SAXException {
-        String schemaFile = RegistryBuilder.class.getResource("/gdata-config.xsd").getFile();
-        /*
-         * Force using apache xerces parser for digester
-         */
-        SAXParser parser = new SAXParser();
-        parser.setFeature("http://apache.org/xml/features/validation/schema-full-checking",true);
-        parser.setFeature("http://apache.org/xml/features/validation/schema",true);
-        parser.setFeature("http://xml.org/sax/features/validation",true); 
-        parser.setProperty("http://apache.org/xml/properties/schema/external-noNamespaceSchemaLocation",schemaFile);
-        Digester digester = new Digester(parser);
-        buildFromConfiguration(digester, GDataServerRegistry
-                .getRegistry(),schemaFile);
-
-    }
-
-    private static void buildFromConfiguration(Digester digester,
-            GDataServerRegistry registry, String schemaURL) throws IOException, SAXException {
-        digester.setValidating(true);
-        digester.setSchema(schemaURL);
-        digester.setErrorHandler(new SimpleSaxErrorHandler());
-        digester.push(registry);
-        /*
-         * register services
-         */
-        digester.addObjectCreate("gdata/service", ProvidedServiceConfig.class);
-        digester.addSetProperties("gdata/service");
-        digester.addSetNext("gdata/service", "registerService");
-        digester.addBeanPropertySetter("gdata/service/feed-class", "feedType");
-        digester.addBeanPropertySetter("gdata/service/entry-class", "entryType");
-        digester.addBeanPropertySetter("gdata/service/extension-profile",
-                "extensionProfileClass");
-        digester.addBeanPropertySetter("gdata/service/previewStyleSheet","xsltStylesheet");
-        addIndexRule(digester);
-        /*
-         * load components and configurations
-         */
-        digester.addCallMethod("gdata/server-components/component",
-                "registerComponent", 2, new Class[] { Class.class , ComponentConfiguration.class});
-        digester.addCallParam("gdata/server-components/component/class",0);
-            digester.addObjectCreate("gdata/server-components/component/configuration",ComponentConfiguration.class);
-            digester.addCallMethod("gdata/server-components/component/configuration/property","set",2,new Class[]{String.class,String.class});
-            digester.addCallParam("gdata/server-components/component/configuration/property",0,"name");
-            digester.addCallParam("gdata/server-components/component/configuration/property",1);
-        //second parameter on registerComponent -- top of the stack (Component configuration)
-        digester.addCallParam("gdata/server-components/component/configuration",1,0);    
-        digester.parse(RegistryBuilder.class
-                .getResourceAsStream("/gdata-config.xml"));
-        
-    }
-    
-    
-    private static void addIndexRule(Digester digester){
-        digester.addObjectCreate("gdata/service/index-schema", IndexSchema.class);
-        digester.addSetNext("gdata/service/index-schema", "setIndexSchema");
-        digester.addSetProperties("gdata/service/index-schema");
-        digester.addSetProperties("gdata/service/index-schema/index");
-        digester.addBeanPropertySetter("gdata/service/index-schema/index/maxMergeDocs");
-        digester.addBeanPropertySetter("gdata/service/index-schema/index/maxBufferedDocs");
-        digester.addBeanPropertySetter("gdata/service/index-schema/index/maxFieldLength");
-        digester.addBeanPropertySetter("gdata/service/index-schema/index/mergeFactor");
-        digester.addBeanPropertySetter("gdata/service/index-schema/index/indexLocation");
-        digester.addBeanPropertySetter("gdata/service/index-schema/index/useCompoundFile");
-        digester.addCallMethod("gdata/service/index-schema/index/defaultAnalyzer", "serviceAnalyzer",1,new Class[]{Class.class});
-        
-        //call method on top of the stack addSchemaField
-        digester.addCallMethod("gdata/service/index-schema/field","addSchemaField",1,new Class[]{IndexSchemaField.class});
-        digester.addObjectCreate("gdata/service/index-schema/field",IndexSchemaField.class);
-        //set parameter for method call -- parameter is IndexSchemaField
-        digester.addCallParam("gdata/service/index-schema/field",0,0);
-        digester.addSetProperties("gdata/service/index-schema/field");
-        digester.addBeanPropertySetter("gdata/service/index-schema/field/path");
-        digester.addBeanPropertySetter("gdata/service/index-schema/field/store","storeByName");
-        digester.addBeanPropertySetter("gdata/service/index-schema/field/index","indexByName");
-        digester.addBeanPropertySetter("gdata/service/index-schema/field/analyzer","analyzerClass");
-        
-//      call method on top of the stack addSchemaField
-        digester.addCallMethod("gdata/service/index-schema/custom","addSchemaField",1,new Class[]{IndexSchemaField.class});
-        digester.addObjectCreate("gdata/service/index-schema/custom",IndexSchemaField.class);
-        //set parameter for method call -- parameter is IndexSchemaField
-        digester.addCallParam("gdata/service/index-schema/custom",0,0);
-        digester.addSetProperties("gdata/service/index-schema/custom");
-        digester.addBeanPropertySetter("gdata/service/index-schema/custom/path");
-        digester.addBeanPropertySetter("gdata/service/index-schema/custom/store","storeByName");
-        digester.addBeanPropertySetter("gdata/service/index-schema/custom/index","indexByName");
-        digester.addBeanPropertySetter("gdata/service/index-schema/custom/analyzer","analyzerClass");
-        digester.addBeanPropertySetter("gdata/service/index-schema/custom/field-class","fieldClass");
-//        digester.addCallMethod("gdata/service/index-schema/custom/field-class","fieldClass",1,new Class[]{Class.class});
-     
-     
-//      call method on top of the stack addSchemaField
-        digester.addCallMethod("gdata/service/index-schema/mixed","addSchemaField",1,new Class[]{IndexSchemaField.class});
-        digester.addObjectCreate("gdata/service/index-schema/mixed",IndexSchemaField.class);
-        //set parameter for method call -- parameter is IndexSchemaField
-        digester.addCallParam("gdata/service/index-schema/mixed",0,0);
-        digester.addSetProperties("gdata/service/index-schema/mixed");
-        digester.addBeanPropertySetter("gdata/service/index-schema/mixed","type");
-        digester.addBeanPropertySetter("gdata/service/index-schema/mixed/path");
-        digester.addBeanPropertySetter("gdata/service/index-schema/mixed/store","storeByName");
-        digester.addBeanPropertySetter("gdata/service/index-schema/mixed/index","indexByName");
-        digester.addBeanPropertySetter("gdata/service/index-schema/mixed/contenttype","typePath");
-        digester.addBeanPropertySetter("gdata/service/index-schema/mixed/analyzer","analyzerClass");
-        
-    }
-
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/RegistryContextListener.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/RegistryContextListener.java
deleted file mode 100644
index 40016e2..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/RegistryContextListener.java
+++ /dev/null
@@ -1,90 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.server.registry;
-
-import javax.servlet.ServletContextEvent;
-import javax.servlet.ServletContextListener;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-
-/**
- * This Listener creates the
- * {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry} when the
- * context is loaded. The registry will be loaded before the
- * {@link org.apache.lucene.gdata.servlet.RequestControllerServlet} is loaded.
- * The Registry will be loaded and set up before the REST interface is available.
- * <p>
- * This ContextListener has to be configured in the <code>web.xml</code>
- * deployment descriptor.
- * </p>
- * <p>
- * When the
- * {@link javax.servlet.ServletContextListener#contextDestroyed(javax.servlet.ServletContextEvent)}
- * method is called the registry will be destroyed using
- * {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry#destroy()}
- * method.
- * 
- * 
- * @author Simon Willnauer
- * 
- */
-public class RegistryContextListener implements ServletContextListener {
-    private GDataServerRegistry serverRegistry;
-
-    private static final Log LOG = LogFactory
-            .getLog(RegistryContextListener.class);
-
-    /**
-     * @see javax.servlet.ServletContextListener#contextInitialized(javax.servlet.ServletContextEvent)
-     */
-    public void contextInitialized(ServletContextEvent arg0) {
-        LOG.info("RegistryContextListener has been loaded");
-
-        try {
-            RegistryBuilder.buildRegistry();
-            this.serverRegistry = GDataServerRegistry.getRegistry();
-            /*
-             * catch all exceptions and destroy the registry to release all resources.
-             * some components start lots of threads, the will remain running if the registry is not destroyed
-             */
-        } catch (Throwable e) {
-            GDataServerRegistry.getRegistry().destroy();
-            LOG.error("can not register required components", e);
-            throw new RuntimeException("Can not register required components",
-                    e);
-        }
-     
-
-    }
-
-    /**
-     * @see javax.servlet.ServletContextListener#contextDestroyed(javax.servlet.ServletContextEvent)
-     */
-    public void contextDestroyed(ServletContextEvent arg0) {
-        LOG.info("Destroying context");
-        /*
-         * this might be null if startup fails
-         * --> prevent null pointer exception
-         */
-        if(this.serverRegistry != null)
-            this.serverRegistry.destroy();
-
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/RegistryException.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/RegistryException.java
deleted file mode 100644
index 81a5db1..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/RegistryException.java
+++ /dev/null
@@ -1,51 +0,0 @@
-package org.apache.lucene.gdata.server.registry;
-
-/**
- * This exception is thrown by the
- * {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry} if
- * registering a service or a component fails.
- * 
- * @author Simon Willnauer
- * 
- */
-public class RegistryException extends Exception {
-
- 
-    private static final long serialVersionUID = -3563720639871194466L;
-
-    /**
-     * Constructs a new Registry Exception.
-     */
-    public RegistryException() {
-        super();
-        
-    }
-
-    /**
-     * Constructs a new Registry Exception with the specified detail message.
-     * @param arg0 - detail message
-     */
-    public RegistryException(String arg0) {
-        super(arg0);
-        
-    }
-
-    /**
-     * Constructs a new Registry Exception with the specified detail message and nested exception.
-     * @param arg0 - detail message
-     * @param arg1 - nested exception
-     */
-    public RegistryException(String arg0, Throwable arg1) {
-        super(arg0, arg1);
-        
-    }
-
-    /** Constructs a new Registry Exception with a nested exception.
-     * @param arg0 - nested exception
-     */
-    public RegistryException(Throwable arg0) {
-        super(arg0);
-        
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/Scope.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/Scope.java
deleted file mode 100755
index ed5ec03..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/Scope.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.server.registry;
-
-import static java.lang.annotation.ElementType.TYPE;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-import java.lang.annotation.Retention;
-import java.lang.annotation.Target;
-
-/**
- * The Scope annotation is used in
- * {@link org.apache.lucene.gdata.server.registry.ScopeVisitable} and
- * {@link org.apache.lucene.gdata.server.registry.ScopeVisitor} implementations
- * to indicate which scope should be visited.
- * 
- * @author Simon Willnauer
- * 
- */
-@Target( { TYPE })
-@Retention(value = RUNTIME)
-public @interface Scope {
-    /**
-     * @return - the scope type the class was annotated with
-     */
-    ScopeType scope();
-
-    /**
-     * Defines a Scope for {@link Scope} annotations
-     * 
-     * @author Simon Willnauer
-     * 
-     */
-    public static enum ScopeType {
-        /**
-         * Request scope
-         */
-        REQUEST,
-        /**
-         * Session scope
-         */
-        SESSION,
-        /**
-         * Context scope
-         */
-        CONTEXT
-
-    }
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/ScopeVisitable.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/ScopeVisitable.java
deleted file mode 100755
index 6f406ac..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/ScopeVisitable.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.server.registry;
-
-/**
- * Implementation of this interface accept
- * {@link org.apache.lucene.gdata.server.registry.ScopeVisitor} objects and call
- * their methods on the desired action.
- * 
- * @author Simon Willnauer
- * 
- */
-public interface ScopeVisitable {
-    /**
-     * @param visitor -
-     *            the visitor to accept
-     */
-    public abstract void accept(ScopeVisitor visitor);
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/ScopeVisitor.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/ScopeVisitor.java
deleted file mode 100755
index b2fc87e..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/ScopeVisitor.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.server.registry;
-
-/**
- * <p>
- * <code>ScopeVisitor</code> is used to implement the <code>Visitor</code>
- * pattern in GDATAServer. An object of this interface can be passed to a
- * <code>ScopeVistable</code> which will then call its methods. <br/>
- * {@link org.apache.lucene.gdata.server.registry.Component} Classes registered
- * in the {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry}
- * will be added to the Visitableimplementation automatically. Please refer to
- * the <i>Gang of Four </i> book of Design Patterns for more details on the
- * <code>Visitor</code> pattern.
- * </p>
- * <p>
- * A scope can be Session, Request or Context if one of the ScopeVisitors for
- * the desired scope is available by the registry.
- * </p>
- * <p>
- * This <a href="http://www.patterndepot.com/put/8/JavaPatterns.htm">site </a>
- * has further discussion on design patterns and links to the GOF book. This <a
- * href="http://www.patterndepot.com/put/8/visitor.pdf">link </a> describes the
- * Visitor pattern in detail.
- * </p>
- * 
- * @author Simon Willnauer
- * 
- */
-public interface ScopeVisitor {
-    /**
-     * Visites the initialization of the scope
-     */
-    public abstract void visiteInitialize();
-
-    /**
-     * Visites the destory of the scope
-     * 
-     */
-    public abstract void visiteDestroy();
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/ServerComponent.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/ServerComponent.java
deleted file mode 100644
index 2d1e20b..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/ServerComponent.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.server.registry;
-
-/**
- * To Register a class as a component in the
- * {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry} the class
- * or a super class must implements this interface.
- * <p>
- * <tt>ServerComponent</tt> defines a method <tt>initialize</tt> and
- * <tt>destroy</tt>. <tt>initialize</tt> will be called when the component
- * is registered and <tt>destroy</tt> when the registry is destroyed (usually
- * at server shut down).</p>
- * @see org.apache.lucene.gdata.server.registry.GDataServerRegistry
- * @author Simon Willnauer
- * 
- */
-public interface ServerComponent {
-    /**
-     * will be call when the component is registered.
-     * if this fails the server must not startup.
-     */
-    public abstract void initialize();
-
-    /**
-     * will be called when the registry is going down e.g. when the  {@link GDataServerRegistry#destroy()} method is called.
-     */
-    public abstract void destroy();
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/SuperType.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/SuperType.java
deleted file mode 100644
index 9c6eb05..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/SuperType.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.server.registry;
-
-import static java.lang.annotation.ElementType.FIELD;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-import java.lang.annotation.Retention;
-import java.lang.annotation.Target;
-
-/**
- * This Annotation is use to annotate
- * {@link org.apache.lucene.gdata.server.registry.ComponentType} elements to
- * specify an interface e.g. super type of a defined component.
- * <p>This annotation will be visible at runtime</p>
- * @see org.apache.lucene.gdata.server.registry.Component
- * @see org.apache.lucene.gdata.server.registry.GDataServerRegistry
- * 
- * @author Simon Willnauer
- * 
- */
-@Target( { FIELD })
-@Retention(value = RUNTIME)
-public @interface SuperType {
-    /**
-     * 
-     * @return the specified super type
-     */
-    Class superType();
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/configuration/ComponentConfiguration.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/configuration/ComponentConfiguration.java
deleted file mode 100755
index 2898bf9..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/configuration/ComponentConfiguration.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.server.registry.configuration;
-
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * Simple configuration class storing properties as key with defined property
- * values as values in a <code>Map<String,String></code>. As a map cannot
- * contain duplicate keys the first use of a key can not be replaced. If a key
- * is used twice a {@link java.lang.IllegalArgumentException} will be thrown.
- * @see Map
- * @author Simon Willnauer
- * 
- */
-public class ComponentConfiguration {
-    private final Map<String, String> configMap;
-
-    /**
-     * Creates a new ComponentConfiguration object and initializes the internal
-     * map.
-     */
-    public ComponentConfiguration() {
-        super();
-        this.configMap = new HashMap<String, String>();
-    }
-
-    /**
-     * Stores a key / value pair as a property. If a key is used twice the first
-     * call will set the key / value pair. Any subsequent calls with a already
-     * set key will throw a IllegalArgumentException.
-     * 
-     * @param key -
-     *            the property as a key
-     * @param value -
-     *            the value for the key
-     *@see Map#put(Object, Object)
-     */
-    public void set(final String key, final String value) {
-        if (this.configMap.containsKey(key))
-            throw new IllegalArgumentException("key has already been used");
-        this.configMap.put(key, value);
-    }
-
-    /**
-     * Returns the value of the key or <code>null</code> if the key is not set.
-     * @param key - the key
-     * @return - the value for the key or <code>null</code> if the key is not set.
-     * @see Map#get(java.lang.Object) 
-     */
-    public String get(final String key) {
-        return this.configMap.get(key);
-    }
-
-    /**
-     * @param key - a string key
-     * @return - <code>true</code> if the key is set, otherwise <code>false</code>
-     * @see Map#containsKey(java.lang.Object)
-     */
-    public boolean contains(String key) {
-        return this.configMap.containsKey(key);
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/configuration/InjectionException.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/configuration/InjectionException.java
deleted file mode 100755
index b6c96dd..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/configuration/InjectionException.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.server.registry.configuration;
-
-/**
- * Will be throw if an exception occures while injecting properties, a type or
- * cast exception occures or a
- * {@link org.apache.lucene.gdata.server.registry.configuration.Requiered}
- * property is not available.
- * 
- * @author Simon Willnauer
- * 
- */
-public class InjectionException extends RuntimeException {
-
-    /**
-     * 
-     */
-    private static final long serialVersionUID = 3559845601111510210L;
-
-    /**
-     * Constructs a new InjectionException
-     */
-    public InjectionException() {
-        super();
-    }
-
-    /**
-     * Constructs a new InjectionException
-     * 
-     * @param message -
-     *            the exception message
-     */
-    public InjectionException(String message) {
-        super(message);
-
-    }
-
-    /**
-     * Constructs a new InjectionException
-     * 
-     * @param message -
-     *            the exception message
-     * @param cause -
-     *            the root cause of this exception
-     */
-    public InjectionException(String message, Throwable cause) {
-        super(message, cause);
-
-    }
-
-    /**
-     * Constructs a new InjectionException
-     * 
-     * @param cause -
-     *            the root cause of this exception
-     */
-    public InjectionException(Throwable cause) {
-        super(cause);
-
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/configuration/PropertyInjector.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/configuration/PropertyInjector.java
deleted file mode 100755
index 7837ad5..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/configuration/PropertyInjector.java
+++ /dev/null
@@ -1,262 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.server.registry.configuration;
-
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Method;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Set;
-import java.util.Map.Entry;
-
-import org.apache.lucene.gdata.utils.ReflectionUtils;
-
-/**
- * PropertyInjector is used to set member variables / properties of classes via
- * <i>setter</i> methods using the
- * {@link org.apache.lucene.gdata.server.registry.configuration.ComponentConfiguration}
- * class.
- * <p>
- * To populate a object with properties from a ComponentConfiguration instance
- * the class or a superclass of the object to populate has to provide at least
- * one setter method with a single parameter. The object to populate is set via
- * the {@link PropertyInjector#setTargetObject} method. The class of the object
- * will be analyzed for setter methods having a "set" prefix in their method
- * name. If one of the found setter methods is annotated with
- * {@link org.apache.lucene.gdata.server.registry.configuration.Requiered} this
- * property is interpreted as a mandatory property. Mandatory properties must be
- * available in the provided ComponentConfiguration, if not the injection will
- * fail.<br>
- * The
- * {@link org.apache.lucene.gdata.server.registry.configuration.ComponentConfiguration}
- * contains key / value pairs where the key must match the signature of the
- * setter method without the 'set' prefix and must begin with a lower case
- * character. <span>Key<code>bufferSize</code> does match a method signature
- * of <code>setBufferSize</code></span> The type of the parameter will be
- * reflected via the Reflection API and instantiated with the given value if
- * possible.
- * </p>
- * <p>
- * Setter methods without a <code>Required</code> annotation will be set if
- * the property is present in the ComponentConfiguration
- * </p>
- * <p>This class does not support overloaded setter methods.</p>
- * @author Simon Willnauer
- * @see org.apache.lucene.gdata.server.registry.configuration.Requiered
- * @see org.apache.lucene.gdata.server.registry.configuration.ComponentConfiguration
- */
-public class PropertyInjector {
-    private static final String SETTER_PREFIX = "set";
-
-    private Class targetClass;
-
-    private Object target;
-
-    private Map<String, Method> requieredProperties = new HashMap<String, Method>();
-
-    private Map<String, Method> optionalProperties = new HashMap<String, Method>();
-
-    /**
-     * Sets the object to be populated with the properties provided in the ComponentConfiguration.
-     * @param o - the object to populate
-     */
-    public void setTargetObject(final Object o) {
-        if (o == null)
-            throw new IllegalArgumentException("TargetObject must not be null");
-        this.target = o;
-        this.targetClass = o.getClass();
-        try {
-            registerProperties(this.targetClass);
-        } catch (Exception e) {
-            throw new InjectionException("can access field -- "
-                    + e.getMessage(), e);
-
-        }
-        if (this.requieredProperties.isEmpty()
-                && this.optionalProperties.isEmpty())
-            throw new InjectionException(
-                    "Given type has no public setter methods -- "
-                            + o.getClass().getName());
-
-    }
-
-    protected int getRequiredSize() {
-        return this.requieredProperties.size();
-    }
-
-    protected int getOptionalSize() {
-        return this.optionalProperties.size();
-    }
-
-    private void registerProperties(final Class clazz)
-            throws SecurityException, NoSuchFieldException {
-        if (clazz == null)
-            return;
-        Method[] methodes = clazz.getMethods();
-        for (int i = 0; i < methodes.length; i++) {
-            if (methodes[i].getName()
-                    .startsWith(PropertyInjector.SETTER_PREFIX)) {
-                String methodName = methodes[i].getName();
-                String fieldName = getFieldName(methodName);
-                if (methodes[i].getAnnotation(Requiered.class) != null)
-                    this.requieredProperties.put(fieldName, methodes[i]);
-                else
-                    this.optionalProperties.put(fieldName, methodes[i]);
-
-            }
-
-        }
-        registerProperties(clazz.getSuperclass());
-    }
-
-    private String getFieldName(final String setterMethodName) {
-        // remove 'set' prefix --> first char as lowerCase
-        String retVal = setterMethodName.substring(3);
-        String firstLetter = retVal.substring(0, 1);
-        retVal = retVal.replaceFirst(firstLetter, firstLetter.toLowerCase());
-        return retVal;
-    }
-
-    /**
-     * Injects the properties stored in the <code>ComponentConfiguration</code>
-     * to the corresponding methods of the target object
-     * @param bean - configuration bean containing all properties to set.
-     * 
-     */
-    public void injectProperties(final ComponentConfiguration bean) {
-        if (bean == null)
-            throw new IllegalArgumentException("bean must not be null");
-        if (this.target == null)
-            throw new IllegalStateException("target is not set -- null");
-        Set<Entry<String, Method>> requiered = this.requieredProperties
-                .entrySet();
-        // set required properties
-        for (Entry<String, Method> entry : requiered) {
-            if (!bean.contains(entry.getKey()))
-                throw new InjectionException(
-                        "Required property can not be set -- value not in configuration bean; Property: "
-                                + entry.getKey()
-                                + "for class "
-                                + this.targetClass.getName());
-            populate(bean, entry);
-
-        }
-        Set<Entry<String, Method>> optinal = this.optionalProperties.entrySet();
-        // set optional properties
-        for (Entry<String, Method> entry : optinal) {
-            if (bean.contains(entry.getKey()))
-                populate(bean, entry);
-        }
-
-    }
-
-    private void populate(ComponentConfiguration bean,
-            Entry<String, Method> entry) {
-        String value = bean.get(entry.getKey());
-        Method m = entry.getValue();
-        Class<?>[] parameterTypes = m.getParameterTypes();
-        if (parameterTypes.length > 1)
-            throw new InjectionException("Setter has more than one parameter "
-                    + m.getName() + " -- can not invoke method -- ");
-        Object parameter = null;
-        try {
-
-            parameter = createObject(value, parameterTypes[0]);
-        } catch (InjectionException e) {
-            throw new InjectionException(
-                    "parameter object creation failed for method "
-                            + m.getName() + " in class: "
-                            + this.targetClass.getName(), e);
-        }
-        // only setters with one parameter are supported
-        Object[] parameters = { parameter };
-        try {
-            m.invoke(this.target, parameters);
-        } catch (Exception e) {
-            throw new InjectionException("Can not set value of type "
-                    + value.getClass().getName()
-                    + " -- can not invoke method -- " + e.getMessage(), e);
-
-        }
-    }
-
-    private Object createObject(String s, Class<?> clazz) {
-
-        try {
-            // if class is requested use s as fully qualified class name
-            if (clazz == Class.class)
-                return Class.forName(s);
-            // check for primitive type
-            if (clazz.isPrimitive())
-                clazz = ReflectionUtils.getPrimitiveWrapper(clazz);
-            boolean defaultConst = false;
-            boolean stringConst = false;
-            Constructor[] constructors = clazz.getConstructors();
-            if (constructors.length == 0)
-                defaultConst = true;
-            for (int i = 0; i < constructors.length; i++) {
-                if (constructors[i].getParameterTypes().length == 0) {
-                    defaultConst = true;
-                    continue;
-                }
-                if (constructors[i].getParameterTypes().length == 1
-                        && constructors[i].getParameterTypes()[0]
-                                .equals(String.class))
-                    stringConst = true;
-            }
-            /*
-             * if there is a string constructor use the string as a parameter
-             */
-            if (stringConst) {
-                Constructor constructor = clazz
-                        .getConstructor(new Class[] { String.class });
-                return constructor.newInstance(new Object[] { s });
-            }
-            /*
-             * if no string const. but a default const. -- use the string as a
-             * class name
-             */
-            if (defaultConst)
-                return Class.forName(s).newInstance();
-            throw new InjectionException(
-                    "Parameter can not be created -- no default or String constructor found for class "
-                            + clazz.getName());
-
-        } catch (Exception e) {
-
-            throw new InjectionException("can not create object for setter", e);
-        }
-
-    }
-
-    /**
-     * Sets all members to their default values and clears the internal used
-     * {@link Map} instances
-     * 
-     * @see Map#clear()
-     */
-    public void clear() {
-        this.target = null;
-        this.targetClass = null;
-        this.optionalProperties.clear();
-        this.requieredProperties.clear();
-    }
-
-    
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/configuration/Requiered.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/configuration/Requiered.java
deleted file mode 100755
index 366a72f..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/configuration/Requiered.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.server.registry.configuration;
-
-import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-import java.lang.annotation.Retention;
-import java.lang.annotation.Target;
-
-/**
- * This annotation is used to define mandatory properties via their setter
- * methodes. It will be present at runtime.
- * 
- * @see org.apache.lucene.gdata.server.registry.configuration.PropertyInjector
- * @see org.apache.lucene.gdata.server.registry.configuration.ComponentConfiguration
- * @author Simon Willnauer
- * 
- */
-@Target( { METHOD })
-@Retention(value = RUNTIME)
-public @interface Requiered {
-//
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/package.html b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/package.html
deleted file mode 100644
index dc9b7a6..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/package.html
+++ /dev/null
@@ -1,10 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
-<html> 
-<head> 
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
-   <meta name="Author" content="Simon Willnauer"> 
-</head> 
-<body> 
-Internal registry - registering services and server components
-</body> 
-</html> 
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/AbstractGdataServlet.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/AbstractGdataServlet.java
deleted file mode 100644
index dfda9df..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/AbstractGdataServlet.java
+++ /dev/null
@@ -1,115 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */ 
- 
-package org.apache.lucene.gdata.servlet; 
- 
-import java.io.IOException; 
- 
-import javax.servlet.ServletConfig;
-import javax.servlet.ServletException; 
-import javax.servlet.http.HttpServlet; 
-import javax.servlet.http.HttpServletRequest; 
-import javax.servlet.http.HttpServletResponse; 
-
-import org.apache.lucene.gdata.server.registry.ComponentType;
-import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
-import org.apache.lucene.gdata.servlet.handler.RequestHandlerFactory;
- 
-/** 
- *  
- * Provides an abstract class to be subclassed to create an GDATA servlet 
- * suitable for a GDATA serverside implementation. 
- *  
- * @see javax.servlet.http.HttpServlet 
- *  
- * @author Simon Willnauer 
- *  
- */ 
-public abstract class AbstractGdataServlet extends HttpServlet { 
-    private static final String METHOD_HEADER_NAME = "x-http-method-override"; 
- 
-    private static final String METHOD_DELETE = "DELETE"; 
- 
-    private static final String METHOD_GET = "GET"; 
- 
-    private static final String METHOD_POST = "POST"; 
- 
-    private static final String METHOD_PUT = "PUT";
-
-    protected static RequestHandlerFactory HANDLER_FACTORY = null; 
- 
-    /** 
-     * This overwrites the protected <code>service</code> method to dispatch 
-     * the request to the correponding <code>do</code> method. There is 
-     * ususaly no need for overwriting this method. The GData protool and the 
-     * Google GData API uses the <code>x-http-method-override</code> header to 
-     * get through firewalls. The http method will be overritten by the 
-     * <code>x-http-method-override</code> and dispatched to the 
-     * <code>do</code><i>Xxx</i> methods defined in this class. This method 
-     * is an GDATA-specific version of the {@link javax.servlet.Servlet#service} 
-     * method. 
-     *  
-     * @see HttpServlet#service(javax.servlet.http.HttpServletRequest, 
-     *      javax.servlet.http.HttpServletResponse) 
-     */ 
-    @Override 
-    protected void service(HttpServletRequest arg0, HttpServletResponse arg1) 
-            throws ServletException, IOException { 
-        if (arg0.getHeader(METHOD_HEADER_NAME) == null) { 
-            super.service(arg0, arg1); 
-            return; 
-        } 
-        overrideMethod(arg0, arg1); 
- 
-    } 
- 
-    private void overrideMethod(HttpServletRequest arg0, 
-            HttpServletResponse arg1) throws ServletException, IOException { 
-        final String method = arg0.getMethod(); 
-        final String overrideHeaderMethod = arg0.getHeader(METHOD_HEADER_NAME); 
-        if (overrideHeaderMethod.equals(method)) { 
-            super.service(arg0, arg1); 
-            return; 
-        } 
-        // These methodes are use by GDATA Client APIs 
-        if (overrideHeaderMethod.equals(METHOD_DELETE)) { 
-            doDelete(arg0, arg1); 
-        } else if (overrideHeaderMethod.equals(METHOD_GET)) { 
-            doGet(arg0, arg1); 
-        } else if (overrideHeaderMethod.equals(METHOD_POST)) { 
-            doPost(arg0, arg1); 
-        } else if (overrideHeaderMethod.equals(METHOD_PUT)) { 
-            doPut(arg0, arg1); 
-        } else { 
-            // if another method has been overwritten follow the HttpServlet 
-            // implementation 
-            super.service(arg0, arg1); 
-        } 
- 
-    }
-
-    /**
-     * 
-     * @see javax.servlet.GenericServlet#init(javax.servlet.ServletConfig)
-     */
-    public void init(ServletConfig arg0) throws ServletException {
-        HANDLER_FACTORY = GDataServerRegistry.getRegistry().lookup(RequestHandlerFactory.class,ComponentType.REQUESTHANDLERFACTORY);
-        if(HANDLER_FACTORY == null)
-            throw new ServletException("service not available");
-        
-    } 
- 
-} 
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/AccountAdministrationServlet.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/AccountAdministrationServlet.java
deleted file mode 100644
index 9e1d5cb..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/AccountAdministrationServlet.java
+++ /dev/null
@@ -1,74 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.servlet;
-
-import java.io.IOException;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.servlet.handler.GDataRequestHandler;
-
-/**
- * This Servlet provides an REST interface to create / update and delete user instances.
- * @author Simon Willnauer
- *
- */
-public class AccountAdministrationServlet extends AbstractGdataServlet {
-   
-    private static final Log LOGGER = LogFactory.getLog(AccountAdministrationServlet.class);
-
-    /**
-     * 
-     */
-    private static final long serialVersionUID = 8215863212137543185L;
-
-    @Override
-    protected void doDelete(HttpServletRequest arg0, HttpServletResponse arg1) throws ServletException, IOException {
-        GDataRequestHandler handler = HANDLER_FACTORY.getDeleteAccountHandler();
-        if(LOGGER.isInfoEnabled())
-            LOGGER.info("Process delete Account request");
-        handler.processRequest(arg0,arg1);
-       
-    }
-
-    @Override
-    protected void doPost(HttpServletRequest arg0, HttpServletResponse arg1) throws ServletException, IOException {
-        GDataRequestHandler handler = HANDLER_FACTORY.getInsertAccountHandler();
-        if(LOGGER.isInfoEnabled())
-            LOGGER.info("Process insert Account request");
-        handler.processRequest(arg0,arg1);        
-       
-    }
-
-    @Override
-    protected void doPut(HttpServletRequest arg0, HttpServletResponse arg1) throws ServletException, IOException {
-        
-        GDataRequestHandler handler = HANDLER_FACTORY.getUpdateAccountHandler();
-        if(LOGGER.isInfoEnabled())
-            LOGGER.info("Process update Account request");
-        handler.processRequest(arg0,arg1);  
-    }
-    
-   
-   
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/AuthenticationServlet.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/AuthenticationServlet.java
deleted file mode 100644
index eb68a1e..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/AuthenticationServlet.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.servlet;
-
-import java.io.IOException;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServlet;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.apache.lucene.gdata.servlet.handler.AuthenticationHandler;
-
-/**
- * REST interface for handling authentification requests from clients to get a
- * auth token either as a cookie or as a plain auth token. This Servlet uses a
- * single {@link org.apache.lucene.gdata.servlet.handler.AuthenticationHandler}
- * instance to handle the incoming requests.
- * 
- * @author Simon Willnauer
- * 
- */
-public class AuthenticationServlet extends HttpServlet {
-
-    private final AuthenticationHandler handler = new AuthenticationHandler();
-
-    private static final long serialVersionUID = 7132478125868917848L;
-
-    @SuppressWarnings("unused")
-    @Override
-    protected void doPost(HttpServletRequest request,
-            HttpServletResponse response) throws ServletException, IOException {
-        this.handler.processRequest(request, response);
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/FeedAdministrationServlet.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/FeedAdministrationServlet.java
deleted file mode 100644
index 0ada64e..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/FeedAdministrationServlet.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.servlet;
-
-import java.io.IOException;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.servlet.handler.GDataRequestHandler;
-
-/**
- * This Servlet provides an REST interface to create / update and delete Feed instances.
- *  
- * @author Simon Willnauer
- *
- */
-public class FeedAdministrationServlet extends AbstractGdataServlet {
-    private static final Log LOGGER = LogFactory.getLog(FeedAdministrationServlet.class);
-    /**
-     * 
-     */
-    private static final long serialVersionUID = -905586350743277032L;
-
-    @Override
-    protected void doDelete(HttpServletRequest arg0, HttpServletResponse arg1) throws ServletException, IOException {
-        GDataRequestHandler handler = HANDLER_FACTORY.getDeleteFeedHandler();
-        if(LOGGER.isInfoEnabled())
-            LOGGER.info("Process delete feed request");
-        handler.processRequest(arg0,arg1);
-     
-    }
-
-    @Override
-    protected void doPost(HttpServletRequest arg0, HttpServletResponse arg1) throws ServletException, IOException {
-        GDataRequestHandler handler = HANDLER_FACTORY.getInsertFeedHandler();
-        if(LOGGER.isInfoEnabled())
-            LOGGER.info("Process insert feed request");
-        handler.processRequest(arg0,arg1);
-     
-    }
-
-    @Override
-    protected void doPut(HttpServletRequest arg0, HttpServletResponse arg1) throws ServletException, IOException {
-        GDataRequestHandler handler = HANDLER_FACTORY.getUpdateFeedHandler();
-        if(LOGGER.isInfoEnabled())
-            LOGGER.info("Process update feed request");
-        handler.processRequest(arg0,arg1);
-     
-    }
-
-  
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/RequestControllerServlet.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/RequestControllerServlet.java
deleted file mode 100644
index 58c4553..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/RequestControllerServlet.java
+++ /dev/null
@@ -1,103 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.servlet;
-
-import java.io.IOException;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.servlet.handler.GDataRequestHandler;
-
-/**
- * Provides a clean basic interface for GDATA Client API and requests to the
- * GDATA Server. This Servlet dispatches the incoming requests to defined GDATA
- * request handlers. Each of the handler processes the incoming request and
- * responds according to the requested action.
- * 
- * @author Simon Willnauer
- * 
- */
-public class RequestControllerServlet extends AbstractGdataServlet {
-    private static final Log LOGGER = LogFactory.getLog(RequestControllerServlet.class);
-
-    /**
-     * Version ID since this class implements
-     * 
-     * @see java.io.Serializable
-     */
-    private static final long serialVersionUID = 7540810742476175576L;
-
-    /**
-     * @see javax.servlet.http.HttpServlet#doDelete(javax.servlet.http.HttpServletRequest,
-     *      javax.servlet.http.HttpServletResponse)
-     */
-    @Override
-	protected void doDelete(HttpServletRequest arg0, HttpServletResponse arg1)
-            throws ServletException, IOException {
-        GDataRequestHandler hanlder = HANDLER_FACTORY.getEntryDeleteHandler();
-        if(LOGGER.isInfoEnabled())
-            LOGGER.info("Process DELETE request");
-        
-        hanlder.processRequest(arg0, arg1);
-    }
-
-    /**
-     * @see javax.servlet.http.HttpServlet#doGet(javax.servlet.http.HttpServletRequest,
-     *      javax.servlet.http.HttpServletResponse)
-     */
-    @Override
-	protected void doGet(HttpServletRequest arg0, HttpServletResponse arg1)
-            throws ServletException, IOException {
-        GDataRequestHandler hanlder = HANDLER_FACTORY.getFeedQueryHandler();
-        if(LOGGER.isInfoEnabled())
-            LOGGER.info("Process GET request");
-        hanlder.processRequest(arg0, arg1);
-    }
-
-    /**
-     * @see javax.servlet.http.HttpServlet#doPost(javax.servlet.http.HttpServletRequest,
-     *      javax.servlet.http.HttpServletResponse)
-     */
-    @Override
-	protected void doPost(HttpServletRequest arg0, HttpServletResponse arg1)
-            throws ServletException, IOException {
-        GDataRequestHandler hanlder = HANDLER_FACTORY.getEntryInsertHandler();
-        if(LOGGER.isInfoEnabled())
-            LOGGER.info("Process POST request");
-        hanlder.processRequest(arg0, arg1);
-    }
-
-    /**
-     * @see javax.servlet.http.HttpServlet#doPut(javax.servlet.http.HttpServletRequest,
-     *      javax.servlet.http.HttpServletResponse)
-     */
-    @Override
-	protected void doPut(HttpServletRequest arg0, HttpServletResponse arg1)
-            throws ServletException, IOException {
-        GDataRequestHandler hanlder = HANDLER_FACTORY.getEntryUpdateHandler();
-        if(LOGGER.isInfoEnabled())
-            LOGGER.info("Process PUT request");
-        hanlder.processRequest(arg0, arg1);
-    }
-    
-  
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/AbstractAccountHandler.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/AbstractAccountHandler.java
deleted file mode 100644
index 7f857ac..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/AbstractAccountHandler.java
+++ /dev/null
@@ -1,193 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.servlet.handler;
-
-import java.io.IOException;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.data.GDataAccount;
-import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
-import org.apache.lucene.gdata.server.GDataResponse;
-import org.apache.lucene.gdata.server.ServiceException;
-import org.apache.lucene.gdata.server.ServiceFactory;
-import org.apache.lucene.gdata.server.administration.AccountBuilder;
-import org.apache.lucene.gdata.server.administration.AdminService;
-import org.apache.lucene.gdata.server.registry.ComponentType;
-import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
-import org.xml.sax.SAXException;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public abstract class AbstractAccountHandler extends RequestAuthenticator
-        implements GDataRequestHandler {
-    private static final Log LOG = LogFactory
-            .getLog(AbstractAccountHandler.class);
-
-    private boolean authenticated = false;
-
-    private int error;
-
-    private String errorMessage = "";
-
-    private boolean isError = false;
-
-    protected AdminService service;
-
-    /**
-     * @see org.apache.lucene.gdata.servlet.handler.GDataRequestHandler#processRequest(javax.servlet.http.HttpServletRequest,
-     *      javax.servlet.http.HttpServletResponse)
-     */
-    @SuppressWarnings("unused")
-    public void processRequest(HttpServletRequest request,
-            HttpServletResponse response) throws ServletException, IOException {
-      try{  
-            this.authenticated = authenticateAccount(request,
-                AccountRole.USERADMINISTRATOR);
-        
-        if (this.authenticated) {
-            GDataServerRegistry registry = GDataServerRegistry.getRegistry();
-            ServiceFactory factory = registry.lookup(ServiceFactory.class,
-                    ComponentType.SERVICEFACTORY);
-            try {
-
-                GDataAccount account = getAccountFromRequest(request);
-                if (!account.requiredValuesSet()) {
-                    setError(GDataResponse.SERVER_ERROR,
-                            "Required server component not available");
-                    throw new AccountHandlerException(
-                            "Required values are not set -- account can not be saved -- "
-                                    + account);
-                }
-                this.service = factory.getAdminService();
-                processServiceAction(account);
-            } catch (ServiceException e) {
-                LOG.error("Can't process account action -- " + e.getMessage(),
-                        e);
-                setError(e.getErrorCode(), "");
-            } 
-            catch (AccountHandlerException e) {
-                LOG.error("Can't process account action -- " + e.getMessage(),
-                        e);
-            }
-        }else{
-            setError(GDataResponse.UNAUTHORIZED,"Authorization failed");
-        }
-        sendResponse(response);
-      }finally{
-          if(this.service!=null)
-              this.service.close();
-      }
-
-    }
-    
-    
-    
-
-    protected GDataAccount getAccountFromRequest(
-            final HttpServletRequest request) throws AccountHandlerException {
-        try {
-            GDataAccount account = AccountBuilder.buildAccount(request
-                    .getReader());
-            if (account == null) {
-                setError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "");
-                throw new AccountHandlerException(
-                        "unexpected value -- parsed account is null");
-            }
-            return account;
-        } catch (IOException e) {
-            setError(HttpServletResponse.SC_BAD_REQUEST, "can not read input");
-            throw new AccountHandlerException("Can't read from request reader",
-                    e);
-        } catch (SAXException e) {
-            setError(HttpServletResponse.SC_BAD_REQUEST,
-                    "can not parse gdata account");
-            throw new AccountHandlerException(
-                    "Can not parse incoming gdata account", e);
-        }
-    }
-
-    protected void sendResponse(HttpServletResponse response) {
-
-        if (!this.isError)
-            return;
-        try {
-            response.sendError(this.error, this.errorMessage);
-        } catch (IOException e) {
-            LOG.warn("can send error in RequestHandler ", e);
-        }
-    }
-
-    protected void setError(int error, String message) {
-        this.error = error;
-        this.errorMessage = message;
-        this.isError = true;
-    }
-
-    protected int getErrorCode() {
-        return this.error;
-    }
-
-    protected String getErrorMessage() {
-        return this.errorMessage;
-    }
-
-    protected abstract void processServiceAction(final GDataAccount account)
-            throws ServiceException;
-
-    static class AccountHandlerException extends Exception {
-
-        /**
-         * 
-         */
-        private static final long serialVersionUID = 3140463271122190694L;
-
-        /**
-         * Constructs a new <tt>AccountHandlerException</tt> with an exception
-         * message and the exception caused this exception.
-         * 
-         * @param arg0 -
-         *            the exception message
-         * @param arg1 -
-         *            the exception cause
-         */
-        public AccountHandlerException(String arg0, Throwable arg1) {
-            super(arg0, arg1);
-
-        }
-
-        /**
-         * Constructs a new <tt>AccountHandlerException</tt> with an exception
-         * message.
-         * 
-         * @param arg0 -
-         *            the exception message
-         */
-        public AccountHandlerException(String arg0) {
-            super(arg0);
-
-        }
-
-    }
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/AbstractFeedHandler.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/AbstractFeedHandler.java
deleted file mode 100644
index 10ce873..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/AbstractFeedHandler.java
+++ /dev/null
@@ -1,175 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.servlet.handler;
-
-import java.io.IOException;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.data.GDataAccount;
-import org.apache.lucene.gdata.data.ServerBaseFeed;
-import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
-import org.apache.lucene.gdata.server.GDataEntityBuilder;
-import org.apache.lucene.gdata.server.GDataResponse;
-import org.apache.lucene.gdata.server.ServiceException;
-import org.apache.lucene.gdata.server.ServiceFactory;
-import org.apache.lucene.gdata.server.administration.AdminService;
-import org.apache.lucene.gdata.server.registry.ComponentType;
-import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
-import org.apache.lucene.gdata.server.registry.ProvidedService;
-
-import com.google.gdata.util.ParseException;
-
-/**
- * 
- * @author Simon Willnauer
- *
- */
-public abstract class AbstractFeedHandler extends RequestAuthenticator implements GDataRequestHandler {
-    private static final Log LOG = LogFactory.getLog(AbstractFeedHandler.class);
-
-    protected static final String PARAMETER_ACCOUNT = "account";
-
-    protected static final String PARAMETER_SERVICE = "service";
-    private int error;
-    protected boolean authenticated = false;
-    
-      private String errorMessage = "";
-      private boolean isError = false;
-      
-    /**
-     * @see org.apache.lucene.gdata.servlet.handler.GDataRequestHandler#processRequest(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
-     */
-    @SuppressWarnings("unused")
-    public void processRequest(HttpServletRequest request,
-            HttpServletResponse response) throws ServletException, IOException {
-            this.authenticated = authenticateAccount(request,AccountRole.FEEDAMINISTRATOR);
-            if(!this.authenticated)
-                setError(GDataResponse.UNAUTHORIZED,"Authorization failed");
-        
-    }
-    
-    protected ServerBaseFeed createFeedFromRequest(HttpServletRequest request) throws ParseException, IOException, FeedHandlerException{
-        GDataServerRegistry registry = GDataServerRegistry.getRegistry();
-        String providedService = request.getParameter(PARAMETER_SERVICE);
-        if(!registry.isServiceRegistered(providedService)){
-            setError(GDataResponse.NOT_FOUND,"no such service");
-            throw new FeedHandlerException("ProvicdedService is not registered -- Name: "+providedService);
-         }
-        ProvidedService provServiceInstance = registry.getProvidedService(providedService);  
-        if(providedService == null){
-            setError(GDataResponse.BAD_REQUEST,"no such service");
-            throw new FeedHandlerException("no such service registered -- "+providedService);
-        }
-        try{
-            ServerBaseFeed retVal = new ServerBaseFeed(GDataEntityBuilder.buildFeed(request.getReader(),provServiceInstance));
-            retVal.setServiceConfig(provServiceInstance);
-        return retVal;
-        }catch (IOException e) {
-            if(LOG.isInfoEnabled())
-                LOG.info("Can not read from input stream - ",e);
-            setError(GDataResponse.BAD_REQUEST,"Can not read from input stream");
-            throw e;
-        }catch (ParseException e) {
-            if(LOG.isInfoEnabled())
-                LOG.info("feed can not be parsed - ",e);
-            setError(GDataResponse.BAD_REQUEST,"incoming feed can not be parsed");
-            throw e;
-        }
-        
-    }
-    
-    
-    protected GDataAccount createRequestedAccount(HttpServletRequest request) throws FeedHandlerException{
-        GDataServerRegistry registry = GDataServerRegistry.getRegistry();
-           ServiceFactory serviceFactory = registry.lookup(ServiceFactory.class,ComponentType.SERVICEFACTORY);
-        
-        if(serviceFactory == null){
-            setError(GDataResponse.SERVER_ERROR, "Required server component not available");
-            throw new FeedHandlerException("Required server component not available -- "+ServiceFactory.class.getName());
-        }
-        AdminService service = serviceFactory.getAdminService();
-        String account = request.getParameter(PARAMETER_ACCOUNT);
-        try{
-        return service.getAccount(account);
-        }catch (ServiceException e) {
-            if(LOG.isInfoEnabled())
-                LOG.info("no account for requested account - "+account,e);
-            setError(HttpServletResponse.SC_BAD_REQUEST,"no such account");
-            throw new FeedHandlerException(e.getMessage(),e);
-        }
-    }
-    
-    protected void sendResponse(HttpServletResponse response){
-        
-        if(!this.isError)
-            return;
-        try{
-        response.sendError(this.error,this.errorMessage);
-        }catch (IOException e) {
-            LOG.warn("can send error in RequestHandler ",e);
-        }
-    }
-    
-    protected void setError(int error, String message){
-        this.error = error;
-        this.errorMessage = message;
-        this.isError = true;
-    }
-    protected int getErrorCode(){
-        return this.error;
-    }
-    
-    protected String getErrorMessage(){
-        return this.errorMessage;
-    }
-    
-    static class FeedHandlerException extends Exception{
-
-        /**
-         * 
-         */
-        private static final long serialVersionUID = 1L;
-
-        /**
-         * Creates a new FeedHandlerException with a exception message and the exception cause this ex.
-         * @param arg0 - the message
-         * @param arg1 - the cause
-         */
-        public FeedHandlerException(String arg0, Throwable arg1) {
-            super(arg0, arg1);
-       
-        }
-
-        /**
-         * Creates a new FeedHandlerException with a exception message.
-         * @param arg0 - message
-         */
-        public FeedHandlerException(String arg0) {
-            super(arg0 );
-            
-        }
-        
-    }
-    
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/AbstractGdataRequestHandler.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/AbstractGdataRequestHandler.java
deleted file mode 100644
index d914014..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/AbstractGdataRequestHandler.java
+++ /dev/null
@@ -1,110 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.servlet.handler;
-
-import java.io.IOException;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.server.GDataRequest;
-import org.apache.lucene.gdata.server.GDataRequestException;
-import org.apache.lucene.gdata.server.GDataResponse;
-import org.apache.lucene.gdata.server.Service;
-import org.apache.lucene.gdata.server.ServiceFactory;
-import org.apache.lucene.gdata.server.GDataRequest.GDataRequestType;
-import org.apache.lucene.gdata.server.registry.ComponentType;
-import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public abstract class AbstractGdataRequestHandler extends RequestAuthenticator implements
-        GDataRequestHandler {
-    private final static Log LOG = LogFactory
-            .getLog(AbstractGdataRequestHandler.class);
-    /*
-     * UTF-8 is the encoding used in the client API to send the entries to the server
-     */
-    private final static String ENCODING = "UTF-8";
-    protected Service service;
-    protected GDataRequest feedRequest;
-    protected GDataResponse feedResponse;
-
-    /**
-     * @see org.apache.lucene.gdata.servlet.handler.GDataRequestHandler#processRequest(javax.servlet.http.HttpServletRequest,
-     *      javax.servlet.http.HttpServletResponse)
-     */
-    public abstract void processRequest(HttpServletRequest request,
-            HttpServletResponse response) throws ServletException, IOException;
-
-    protected void initializeRequestHandler(final HttpServletRequest request, final HttpServletResponse response, final GDataRequestType type)
-            throws GDataRequestException, ServletException {
-        this.feedRequest = new GDataRequest(request, type);
-        this.feedResponse = new GDataResponse(response);
-        this.feedResponse.setEncoding(ENCODING);
-        
-        try {       
-            this.feedRequest.initializeRequest();
-        } catch (GDataRequestException e) {
-            setError(e.getErrorCode());
-            LOG.warn("Couldn't initialize FeedRequest - " + e.getMessage(), e);
-            throw e;
-        }
-        getService(this.feedRequest);
-    }
-
-    
-
-    protected void sendError() throws IOException {
-        this.feedResponse.sendError();
-        
-    }
-
-	protected void setFeedResponseFormat() {
-		this.feedResponse.setOutputFormat(this.feedRequest.getRequestedResponseFormat());
-	}
-
-	protected void setFeedResponseStatus(int status) {
-		this.feedResponse.setResponseCode(status);
-	}
-
-	protected void setError(int error) {
-		this.feedResponse.setError(error);
-	}
-
-    private void getService(GDataRequest request) throws ServletException {
-        GDataServerRegistry registry = GDataServerRegistry.getRegistry();
-        ServiceFactory serviceFactory = registry.lookup(ServiceFactory.class,ComponentType.SERVICEFACTORY);
-        this.service = serviceFactory.getService(request);
-        if(this.service == null)
-            throw new ServletException("Service not available"); 
-        
-    }
-    
-    protected void closeService(){
-        this.service.close();
-    }
-
-
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/AuthenticationHandler.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/AuthenticationHandler.java
deleted file mode 100644
index 6161fbe..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/AuthenticationHandler.java
+++ /dev/null
@@ -1,132 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.servlet.handler;
-
-import java.io.IOException;
-import java.io.Writer;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.Cookie;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.data.GDataAccount;
-import org.apache.lucene.gdata.server.GDataResponse;
-import org.apache.lucene.gdata.server.ServiceException;
-import org.apache.lucene.gdata.server.ServiceFactory;
-import org.apache.lucene.gdata.server.administration.AdminService;
-import org.apache.lucene.gdata.server.authentication.AuthenticationController;
-import org.apache.lucene.gdata.server.authentication.AuthenticationException;
-import org.apache.lucene.gdata.server.registry.ComponentType;
-import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
-
-
-
-/**
- * @author Simon Willnauer
- *
- */
-public class AuthenticationHandler implements GDataRequestHandler {
-    private static final Log LOG = LogFactory.getLog(AuthenticationHandler.class);
-    private final AuthenticationController controller;
-    private final static String errorKey = "Error";
-    private final static char seperatory = '=';
-    private final ServiceFactory serviceFactory;
-    private final GDataServerRegistry registry;
-    /**
-     * 
-     */
-    public AuthenticationHandler() {
-        this.registry = GDataServerRegistry.getRegistry();
-        this.controller = this.registry.lookup(AuthenticationController.class, ComponentType.AUTHENTICATIONCONTROLLER);
-        this.serviceFactory = this.registry.lookup(ServiceFactory.class, ComponentType.SERVICEFACTORY);
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.servlet.handler.GDataRequestHandler#processRequest(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
-     */
-    @SuppressWarnings("unused")
-    public void processRequest(HttpServletRequest request,
-            HttpServletResponse response) throws ServletException, IOException {
-        
-        try {
-        String serviceName = request.getParameter(AuthenticationController.SERVICE_PARAMETER);
-        if(LOG.isInfoEnabled()){
-            String application = request.getParameter(AuthenticationController.APPLICATION_PARAMETER);
-            LOG.info("Authentication request for service: "+serviceName+"; Application name: "+application);
-        }
-        
-        if(!this.registry.isServiceRegistered(serviceName))
-            throw new AuthenticationException("requested Service "+serviceName+"is not registered");
-        String password = request.getParameter(AuthenticationController.PASSWORD_PARAMETER);
-        String accountName = request.getParameter(AuthenticationController.ACCOUNT_PARAMETER);
-        String clientIp = request.getRemoteHost();
-        
-       
-        
-        GDataAccount  account = getAccount(accountName);
-        if(account == null || !account.getPassword().equals(password))
-            throw new AuthenticationException("Account is null or password does not match");
-        
-        String token = this.controller.authenticatAccount(account,clientIp);
-        sendToken(response,token);
-        if(LOG.isInfoEnabled()){
-            
-            LOG.info("Account authenticated -- "+account);
-        }
-        } catch (AuthenticationException e){
-            LOG.error("BadAuthentication -- "+e.getMessage(),e);
-            sendError(response, GDataResponse.FORBIDDEN,"BadAuthentication");
-        }catch (Exception e) {
-            LOG.error("Unexpected Exception -- SERVERERROR -- "+e.getMessage(),e);
-            sendError(response,GDataResponse.SERVER_ERROR, "Service not available");
-        }
-    }
-    
-    
-   private GDataAccount getAccount(String accountName) throws ServiceException{
-       
-       AdminService service = this.serviceFactory.getAdminService();
-       try{
-       return service.getAccount(accountName);
-       }finally{
-            service.close();
-       }
-            
-        
-    }
-   private void sendError(HttpServletResponse response, int code, String message)throws IOException{
-       Writer writer = response.getWriter();
-       writer.write(errorKey);
-       writer.write(seperatory);
-       writer.write(message);
-       response.sendError(code);
-   }
-   
-   private void sendToken(HttpServletResponse response, String token) throws IOException{
-       Writer responseWriter = response.getWriter();
-       Cookie cookie = new Cookie(AuthenticationController.TOKEN_KEY,token);
-       response.addCookie(cookie);
-       responseWriter.write(AuthenticationController.TOKEN_KEY);
-       responseWriter.write(seperatory);
-       responseWriter.write(token);
-       responseWriter.close();
-   }
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/DefaultDeleteHandler.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/DefaultDeleteHandler.java
deleted file mode 100644
index 7d33bdb..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/DefaultDeleteHandler.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.servlet.handler;
-
-import java.io.IOException;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
-import org.apache.lucene.gdata.server.GDataRequestException;
-import org.apache.lucene.gdata.server.GDataResponse;
-import org.apache.lucene.gdata.server.ServiceException;
-import org.apache.lucene.gdata.server.GDataRequest.GDataRequestType;
-
-/**
- * Default Handler implementation. This handler processes the incoming
- * {@link org.apache.lucene.gdata.server.GDataRequest} and deletes the requested
- * feed entry from the storage and the search component.
- * <p>
- * The handler sends following response to the client:
- * </p>
- * <ol>
- * <li>if the entry could be deleted - HTTP status code <i>200 OK</i></li>
- * <li>if an error occurs - HTTP status code <i>500 INTERNAL SERVER ERROR</i></li>
- * <li>if the resource could not found - HTTP status code <i>404 NOT FOUND</i></li>
- * </ol>
- *  
- * @author Simon Willnauer
- * 
- */
-public class DefaultDeleteHandler extends AbstractGdataRequestHandler {
-	private static final Log LOG = LogFactory
-			.getLog(DefaultDeleteHandler.class);
-
-	/**
-	 * @throws ServletException 
-	 * @see org.apache.lucene.gdata.servlet.handler.AbstractGdataRequestHandler#processRequest(javax.servlet.http.HttpServletRequest,
-	 *      javax.servlet.http.HttpServletResponse)
-	 */
-	@Override
-	public void processRequest(HttpServletRequest request,
-			HttpServletResponse response) throws IOException, ServletException {
-		try {
-			initializeRequestHandler(request, response,GDataRequestType.DELETE);
-		} catch (GDataRequestException e) {
-			sendError();
-			return;
-		}
-        if(!authenticateAccount(request,AccountRole.ENTRYAMINISTRATOR)){
-            setError(GDataResponse.UNAUTHORIZED);
-            sendError();
-            return;
-        }
-		
-		try {
-			this.service.deleteEntry(this.feedRequest, this.feedResponse);
-		
-		} catch (ServiceException e) {
-			LOG.error("Could not process DeleteFeed request - "
-					+ e.getMessage(), e);
-            setError(e.getErrorCode());
-			sendError();
-		}finally{
-        closeService();
-        }
-	}
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/DefaultGetHandler.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/DefaultGetHandler.java
deleted file mode 100644
index d1fed95..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/DefaultGetHandler.java
+++ /dev/null
@@ -1,140 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.servlet.handler;
-
-import java.io.IOException;
-import java.util.Date;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.server.GDataRequestException;
-import org.apache.lucene.gdata.server.Service;
-import org.apache.lucene.gdata.server.ServiceException;
-import org.apache.lucene.gdata.server.GDataRequest.GDataRequestType;
-import org.apache.lucene.gdata.utils.DateFormater;
-
-import com.google.gdata.data.BaseEntry;
-import com.google.gdata.data.BaseFeed;
-
-/**
- * Default Handler implementation. This handler processes the incoming
- * {@link org.apache.lucene.gdata.server.GDataRequest} and retrieves the
- * requested feed from the underlying storage.
- * <p>
- * This hander also processes search queries and retrieves the search hits from
- * the underlying search component. The user query will be accessed via the
- * {@link org.apache.lucene.gdata.server.GDataRequest} instance passed to the
- * {@link Service} class.
- * </p>
- * <p>
- * The DefaultGetHandler supports HTTP Conditional GET. It set the Last-Modified
- * response header based upon the value of the <atom:updated> element in the
- * returned feed or entry. A client can send this value back as the value of the
- * If-Modified-Since request header to avoid retrieving the content again if it
- * hasn't changed. If the content hasn't changed since the If-Modified-Since
- * time, then the GData service returns a 304 (Not Modified) HTTP response.</p>
- * 
- * 
- * @author Simon Willnauer
- * 
- */
-public class DefaultGetHandler extends AbstractGdataRequestHandler {
-    private static final Log LOG = LogFactory.getLog(DefaultGetHandler.class);
-
-    /**
-     * @see org.apache.lucene.gdata.servlet.handler.AbstractGdataRequestHandler#processRequest(javax.servlet.http.HttpServletRequest,
-     *      javax.servlet.http.HttpServletResponse)
-     */
-    @Override
-    public void processRequest(HttpServletRequest request,
-            HttpServletResponse response) throws IOException, ServletException {
-        try {
-            initializeRequestHandler(request, response, GDataRequestType.GET);
-        } catch (GDataRequestException e) {
-            sendError();
-            return;
-        }
-
-        try {
-            String modifiedSince = this.feedRequest.getModifiedSince();
-            if (!checkIsModified(modifiedSince)) {
-                this.feedResponse
-                        .setStatus(HttpServletResponse.SC_NOT_MODIFIED);
-                return;
-            }
-            if (LOG.isInfoEnabled())
-                LOG.info("Requested output formate: "
-                        + this.feedRequest.getRequestedResponseFormat());
-            this.feedResponse.setOutputFormat(this.feedRequest
-                    .getRequestedResponseFormat());
-            if (this.feedRequest.isFeedRequested()) {
-                BaseFeed feed = this.service.getFeed(this.feedRequest,
-                        this.feedResponse);
-
-                this.feedResponse.sendResponse(feed, this.feedRequest
-                        .getConfigurator());
-            } else {
-                BaseEntry entry = this.service.getSingleEntry(this.feedRequest,
-                        this.feedResponse);
-                this.feedResponse.sendResponse(entry, this.feedRequest
-                        .getConfigurator());
-            }
-
-        } catch (ServiceException e) {
-            LOG.error("Could not process GetFeed request - " + e.getMessage(),
-                    e);
-            setError(e.getErrorCode());
-            sendError();
-        }finally{
-        closeService();
-        }
-    }
-
-    /**
-     * 
-     * returns true if the resource has been modified since the specified
-     * request header value
-     */
-    protected boolean checkIsModified(String lastModified)
-            throws ServiceException {
-        if (lastModified == null)
-            return true;
-        try {
-            Date clientDate = DateFormater.parseDate(lastModified,DateFormater.HTTP_HEADER_DATE_FORMAT,DateFormater.HTTP_HEADER_DATE_FORMAT_TIME_OFFSET);
-            Date entityDate;
-            if (this.feedRequest.isFeedRequested())
-                entityDate = this.service.getFeedLastModified(this.feedRequest
-                        .getFeedId());
-            else
-                entityDate = this.service.getEntryLastModified(this.feedRequest
-                        .getEntryId(),this.feedRequest.getFeedId());
-            if(LOG.isInfoEnabled())
-                LOG.info("comparing date clientDate: "+clientDate+"; last modified: "+entityDate);
-            return (entityDate.getTime()-clientDate.getTime() > 1000);
-        } catch (java.text.ParseException e) {
-            LOG.info("Couldn't parse Last-Modified header -- "+lastModified,e);
-
-        }
-        return true;
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/DefaultInsertHandler.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/DefaultInsertHandler.java
deleted file mode 100644
index f37a0f9..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/DefaultInsertHandler.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.servlet.handler;
-
-import java.io.IOException;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
-import org.apache.lucene.gdata.server.GDataRequestException;
-import org.apache.lucene.gdata.server.GDataResponse;
-import org.apache.lucene.gdata.server.ServiceException;
-import org.apache.lucene.gdata.server.GDataRequest.GDataRequestType;
-
-import com.google.gdata.data.BaseEntry;
-
-/**
- * Default Handler implementation. This handler processes the incoming
- * {@link org.apache.lucene.gdata.server.GDataRequest} and inserts the requested
- * feed entry into the storage and the search component.
- * <p>
- * The handler sends following response to the client:
- * </p>
- * <ol>
- * <li>if the entry was added - HTTP status code <i>200 OK</i></li>
- * <li>if an error occurs - HTTP status code <i>500 INTERNAL SERVER ERROR</i></li>
- * <li>if the resource could not found - HTTP status code <i>404 NOT FOUND</i></li>
- * </ol>
- * <p>The added entry will be send back to the client if the insert request was successful.</p>
- * 
- * @author Simon Willnauer
- *
- */
-public class DefaultInsertHandler extends AbstractGdataRequestHandler {
-    private static final Log LOG = LogFactory.getLog(DefaultInsertHandler.class);
-    /**
-     * @throws ServletException 
-     * @see org.apache.lucene.gdata.servlet.handler.GDataRequestHandler#processRequest(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
-     */
-    @Override
-	public void processRequest(HttpServletRequest request,
-            HttpServletResponse response) throws IOException, ServletException {
-        try {
-            initializeRequestHandler(request,response,GDataRequestType.INSERT);            
-        } catch (GDataRequestException e) {
-            sendError();
-            return;
-        }
-        if(!authenticateAccount(this.feedRequest,AccountRole.ENTRYAMINISTRATOR)){
-            setError(GDataResponse.UNAUTHORIZED);
-            sendError();
-            return;
-        }
-       
-        try{        
-        BaseEntry entry = this.service.createEntry(this.feedRequest,this.feedResponse);
-        setFeedResponseFormat();
-        setFeedResponseStatus(GDataResponse.CREATED);        
-        this.feedResponse.sendResponse(entry, this.feedRequest.getConfigurator());
-        
-        }catch (ServiceException e) {
-           LOG.error("Could not process GetFeed request - "+e.getMessage(),e);
-           setError(e.getErrorCode());
-           sendError();
-        }finally{
-        closeService();
-        }
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/DefaultRequestHandlerFactory.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/DefaultRequestHandlerFactory.java
deleted file mode 100644
index d101338..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/DefaultRequestHandlerFactory.java
+++ /dev/null
@@ -1,150 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.servlet.handler;
-
-import org.apache.lucene.gdata.server.registry.Component;
-import org.apache.lucene.gdata.server.registry.ComponentType;
-
-/**
- * Default implementation for RequestHandlerFactory Builds the
- * {@link org.apache.lucene.gdata.servlet.handler.GDataRequestHandler}
- * instances.
- * This class should not be access directy. The class will be registered in the {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry}.
- * Use {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry#lookup(Class, ComponentType)}
- * 
- * @author Simon Willnauer
- * 
- */
-@Component(componentType=ComponentType.REQUESTHANDLERFACTORY)
-public class DefaultRequestHandlerFactory extends RequestHandlerFactory {
-
-
-    /**
-     * public constructor to enable loading via the registry
-     * @see org.apache.lucene.gdata.server.registry.Component
-     * @see org.apache.lucene.gdata.server.registry.GDataServerRegistry
-     */
-	public DefaultRequestHandlerFactory() {
-		//
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.servlet.handler.RequestHandlerFactory#getEntryUpdateHandler()
-	 */
-	@Override
-	public GDataRequestHandler getEntryUpdateHandler() {
-
-		return new DefaultUpdateHandler();
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.servlet.handler.RequestHandlerFactory#getEntryDeleteHandler()
-	 */
-	@Override
-	public GDataRequestHandler getEntryDeleteHandler() {
-
-		return new DefaultDeleteHandler();
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.servlet.handler.RequestHandlerFactory#getFeedQueryHandler()
-	 */
-	@Override
-	public GDataRequestHandler getFeedQueryHandler() {
-
-		return new DefaultGetHandler();
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.servlet.handler.RequestHandlerFactory#getEntryInsertHandler()
-	 */
-	@Override
-	public GDataRequestHandler getEntryInsertHandler() {
-
-		return new DefaultInsertHandler();
-	}
-
-    /**
-     * @see org.apache.lucene.gdata.servlet.handler.RequestHandlerFactory#getInsertAccountHandler()
-     */
-    @Override
-    public GDataRequestHandler getInsertAccountHandler() {
-        
-        return new InsertAccountStrategy();
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.servlet.handler.RequestHandlerFactory#getDeleteAccountHandler()
-     */
-    @Override
-    public GDataRequestHandler getDeleteAccountHandler() {
-        
-        return new DeleteAccountStrategy();
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.servlet.handler.RequestHandlerFactory#getUpdateAccountHandler()
-     */
-    @Override
-    public GDataRequestHandler getUpdateAccountHandler() {
-        
-        return new UpdateAccountStrategy();
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.servlet.handler.RequestHandlerFactory#getInsertFeedHandler()
-     */
-    @Override
-    public GDataRequestHandler getInsertFeedHandler() {
-        
-        return new InsertFeedHandler();
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.servlet.handler.RequestHandlerFactory#getUpdateFeedHandler()
-     */
-    @Override
-    public GDataRequestHandler getUpdateFeedHandler() {
-        
-        return new UpdateFeedHandler();
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.servlet.handler.RequestHandlerFactory#getDeleteFeedHandler()
-     */
-    @Override
-    public GDataRequestHandler getDeleteFeedHandler() {
-        
-        return new DeleteFeedHandler();
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.registry.ServerComponent#initialize()
-     */
-    public void initialize() {
-        //
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.registry.ServerComponent#destroy()
-     */
-    public void destroy() {
-        //
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/DefaultUpdateHandler.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/DefaultUpdateHandler.java
deleted file mode 100644
index e22b724..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/DefaultUpdateHandler.java
+++ /dev/null
@@ -1,92 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.servlet.handler;
-
-import java.io.IOException;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
-import org.apache.lucene.gdata.server.GDataRequestException;
-import org.apache.lucene.gdata.server.GDataResponse;
-import org.apache.lucene.gdata.server.ServiceException;
-import org.apache.lucene.gdata.server.GDataRequest.GDataRequestType;
-
-import com.google.gdata.data.BaseEntry;
-
-/**
- * Default Handler implementation. This handler processes the incoming
- * {@link org.apache.lucene.gdata.server.GDataRequest} and updates the requested
- * feed entry in the storage and the search component.
- * <p>
- * The handler sends following response to the client:
- * </p>
- * <ol>
- * <li>if the entry was successfully updated - HTTP status code <i>200 OK</i></li>
- * <li>if an error occurs - HTTP status code <i>500 INTERNAL SERVER ERROR</i></li>
- * <li>if the resource could not found - HTTP status code <i>404 NOT FOUND</i></li>
- * </ol>
- * 
- * @author Simon Willnauer
- *  
- */
-public class DefaultUpdateHandler extends AbstractGdataRequestHandler {
-	private static final Log LOG = LogFactory
-			.getLog(DefaultUpdateHandler.class);
-
-	/**
-	 * @throws ServletException 
-	 * @see org.apache.lucene.gdata.servlet.handler.AbstractGdataRequestHandler#processRequest(javax.servlet.http.HttpServletRequest,
-	 *      javax.servlet.http.HttpServletResponse)
-	 */
-	@Override
-	public void processRequest(HttpServletRequest request,
-			HttpServletResponse response) throws  IOException, ServletException {
-		try {
-			initializeRequestHandler(request, response,GDataRequestType.UPDATE);
-		} catch (GDataRequestException e) {
-            setError(GDataResponse.UNAUTHORIZED);
-			sendError();
-			return;
-		}
-        if(!authenticateAccount(request,AccountRole.ENTRYAMINISTRATOR)){
-            sendError();
-            return;
-        }
-        
-		try {
-			BaseEntry entry = this.service.updateEntry(this.feedRequest,
-					this.feedResponse);
-			setFeedResponseFormat();
-			this.feedResponse.sendResponse(entry, this.feedRequest.getConfigurator());
-		
-		}
-		catch (ServiceException e) {
-			LOG.error("Could not process UpdateFeed request - "
-					+ e.getMessage(), e);
-            setError(e.getErrorCode());
-			sendError();
-		}finally{
-        closeService();
-        }
-	}
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/DeleteAccountStrategy.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/DeleteAccountStrategy.java
deleted file mode 100644
index b808a2a..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/DeleteAccountStrategy.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.servlet.handler;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.data.GDataAccount;
-import org.apache.lucene.gdata.server.ServiceException;
-
-/**
- * @author Simon Willnauer
- *
- */
-public class DeleteAccountStrategy extends AbstractAccountHandler {
-
-    private static final Log LOG = LogFactory.getLog(DefaultDeleteHandler.class);
-
-    
-
-    @Override
-    protected void processServiceAction(GDataAccount account) throws ServiceException {
-        try{
-        this.service.deleteAccount(account);
-        }catch (ServiceException e) {
-            LOG.error("Can't delete account -- "+e.getMessage(),e);
-            throw e;
-        }
-        
-    }
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/DeleteFeedHandler.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/DeleteFeedHandler.java
deleted file mode 100644
index 881432a..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/DeleteFeedHandler.java
+++ /dev/null
@@ -1,90 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.servlet.handler;
-
-import java.io.IOException;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.data.ServerBaseFeed;
-import org.apache.lucene.gdata.server.GDataResponse;
-import org.apache.lucene.gdata.server.ServiceException;
-import org.apache.lucene.gdata.server.ServiceFactory;
-import org.apache.lucene.gdata.server.administration.AdminService;
-import org.apache.lucene.gdata.server.registry.ComponentType;
-import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
-
-/**
- * @author Simon Willnauer
- *
- */
-public class DeleteFeedHandler extends AbstractFeedHandler{
-    private static final Log LOG = LogFactory.getLog(DeleteFeedHandler.class);
-
-    /**
-     * @throws IOException 
-     * @see org.apache.lucene.gdata.servlet.handler.GDataRequestHandler#processRequest(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
-     */
-    @Override
-    public void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
-            super.processRequest(request,response);
-            if(this.authenticated){
-                AdminService service = null;
-            try {
-                ServerBaseFeed feed = createDeleteFeed(request);
-                
-                GDataServerRegistry registry = GDataServerRegistry.getRegistry();
-                ServiceFactory serviceFactory = registry.lookup(ServiceFactory.class,ComponentType.SERVICEFACTORY);
-                if(serviceFactory == null){
-                    setError(GDataResponse.SERVER_ERROR,"required component is not available");
-                    throw new FeedHandlerException("Can't save feed - ServiceFactory is null");
-                }
-                service = serviceFactory.getAdminService();
-                service.deleteFeed(feed);
-            } catch (FeedHandlerException e) {
-                LOG.error("Can not delete feed -- "+e.getMessage(),e);
-            }catch (ServiceException e) {
-                LOG.error("Can not delete feed -- "+e.getMessage(),e);
-                setError(e.getErrorCode(),"can not create feed");
-            }finally{
-                if(service != null)
-                    service.close();
-            }
-            }
-            sendResponse(response);
-           
-        
-        
-    }
-
-    private ServerBaseFeed createDeleteFeed(final HttpServletRequest request) throws FeedHandlerException {
-        String feedId = request.getParameter("feedid");
-        if(feedId == null){
-            setError(GDataResponse.BAD_REQUEST,"No feed id specified");
-            throw new FeedHandlerException("no feed Id specified");
-        }
-        ServerBaseFeed retVal = new ServerBaseFeed();
-        retVal.setId(feedId);
-        return retVal;
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/GDataRequestHandler.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/GDataRequestHandler.java
deleted file mode 100644
index c42785c..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/GDataRequestHandler.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */ 
-package org.apache.lucene.gdata.servlet.handler; 
- 
-import java.io.IOException; 
- 
-import javax.servlet.ServletException; 
-import javax.servlet.http.HttpServletRequest; 
-import javax.servlet.http.HttpServletResponse; 
- 
-/** 
- *  
- * Based on the Command pattern [GoF], the Command and Controller Strategy 
- * suggests providing a generic interface to the handler components to which the 
- * controller may delegate responsibility, minimizing the coupling among these 
- * components. 
- *  
- * Adding to or changing the work that needs to be completed by these handlers 
- * does not require any changes to the interface between the controller and the 
- * handlers, but rather to the type and/or content of the commands. This provides 
- * a flexible and easily extensible mechanism for developers to add request 
- * handling behaviors. 
- *  
- * The controller invokes the processRequest method from the corresponding servlet <i>doXXX</i> 
- * method to delegate the request to the handler. 
- *   
- *  
- * @author Simon Willnauer 
- *  
- */ 
-public interface GDataRequestHandler { 
-    /** 
-     * Processes the GDATA Client request 
-     *  
-     * @param request - the client request to be processed 
-     * @param response - the response to the client request 
-     * @throws ServletException - if a servlet exception is thrown by the request or response   
-     * @throws IOException -  if an input/output error occurs due to accessing an IO steam 
-     */ 
-    public abstract void processRequest(HttpServletRequest request, 
-            HttpServletResponse response) throws ServletException, IOException; 
-} 
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/GDataRequestHandlerException.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/GDataRequestHandlerException.java
deleted file mode 100644
index 0c1c593..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/GDataRequestHandlerException.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */ 
- 
-package org.apache.lucene.gdata.servlet.handler; 
- 
-/** 
- * @author Simon Willnauer 
- * 
- */ 
-public class GDataRequestHandlerException extends RuntimeException { 
- 
-    /** 
-     *  
-     */ 
-    private static final long serialVersionUID = -418225239671624153L; 
-    
- 
-    /** 
-     *  
-     */ 
-    public GDataRequestHandlerException() { 
-        super(); 
-        
-    } 
- 
-    /** 
-     * @param arg0 
-     */ 
-    public GDataRequestHandlerException(String arg0) { 
-        super(arg0); 
-        
-    } 
- 
-    /** 
-     * @param arg0 
-     * @param arg1 
-     */ 
-    public GDataRequestHandlerException(String arg0, Throwable arg1) { 
-        super(arg0, arg1); 
-        
-    } 
- 
-    /** 
-     * @param arg0 
-     */ 
-    public GDataRequestHandlerException(Throwable arg0) { 
-        super(arg0); 
-        
-    } 
- 
-} 
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/InsertAccountStrategy.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/InsertAccountStrategy.java
deleted file mode 100644
index f13eaeb..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/InsertAccountStrategy.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.servlet.handler;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.data.GDataAccount;
-import org.apache.lucene.gdata.server.ServiceException;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class InsertAccountStrategy extends AbstractAccountHandler {
-    private static final Log LOG = LogFactory.getLog(InsertAccountStrategy.class);
-   
-  
-
-    @Override
-    protected void processServiceAction(GDataAccount account) throws ServiceException {
-        try{
-        this.service.createAccount(account);
-        }catch (ServiceException e) {
-            LOG.error("Can't create account -- "+e.getMessage(),e);
-            throw e;
-        }
-        
-    }
-
-
-
-    
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/InsertFeedHandler.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/InsertFeedHandler.java
deleted file mode 100644
index bda76f6..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/InsertFeedHandler.java
+++ /dev/null
@@ -1,90 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.servlet.handler;
-
-import java.io.IOException;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.data.GDataAccount;
-import org.apache.lucene.gdata.data.ServerBaseFeed;
-import org.apache.lucene.gdata.server.GDataResponse;
-import org.apache.lucene.gdata.server.ServiceException;
-import org.apache.lucene.gdata.server.ServiceFactory;
-import org.apache.lucene.gdata.server.administration.AdminService;
-import org.apache.lucene.gdata.server.registry.ComponentType;
-import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
-
-import com.google.gdata.util.ParseException;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class InsertFeedHandler extends AbstractFeedHandler {
-    private static final Log LOG = LogFactory.getLog(InsertFeedHandler.class);
-
-    /**
-     * @see org.apache.lucene.gdata.servlet.handler.GDataRequestHandler#processRequest(javax.servlet.http.HttpServletRequest,
-     *      javax.servlet.http.HttpServletResponse)
-     */
-    @SuppressWarnings("unused")
-    public void processRequest(HttpServletRequest request,
-            HttpServletResponse response) throws ServletException, IOException {
-        super.processRequest(request, response);
-        if (this.authenticated) {
-            AdminService service = null;
-            try {
-                ServerBaseFeed feed = createFeedFromRequest(request);
-                GDataAccount account = createRequestedAccount(request);
-
-                GDataServerRegistry registry = GDataServerRegistry
-                        .getRegistry();
-                ServiceFactory serviceFactory = registry.lookup(
-                        ServiceFactory.class, ComponentType.SERVICEFACTORY);
-                if (serviceFactory == null) {
-                    setError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
-                            "required component is not available");
-                    throw new FeedHandlerException(
-                            "Can't save feed - ServiceFactory is null");
-                }
-                service = serviceFactory.getAdminService();
-                service.createFeed(feed, account);
-            } catch (ServiceException e) {
-                setError(GDataResponse.SERVER_ERROR,
-                        "can not create feed");
-                LOG.error("Can not create feed -- " + e.getMessage(), e);
-            } catch (FeedHandlerException e) {
-                LOG.error("Can not create feed -- " + e.getMessage(), e);
-
-            }catch (ParseException e) {
-                LOG.error("Can not create feed -- " + e.getMessage(), e);
-            }finally{
-                if(service != null)
-                    service.close();
-            }
-
-        }
-        sendResponse(response);
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/RequestAuthenticator.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/RequestAuthenticator.java
deleted file mode 100644
index 9527987..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/RequestAuthenticator.java
+++ /dev/null
@@ -1,151 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.servlet.handler;
-
-import javax.servlet.http.Cookie;
-import javax.servlet.http.HttpServletRequest;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.data.GDataAccount;
-import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
-import org.apache.lucene.gdata.server.GDataRequest;
-import org.apache.lucene.gdata.server.ServiceException;
-import org.apache.lucene.gdata.server.ServiceFactory;
-import org.apache.lucene.gdata.server.administration.AdminService;
-import org.apache.lucene.gdata.server.authentication.AuthenticationController;
-import org.apache.lucene.gdata.server.authentication.AuthenticatorException;
-import org.apache.lucene.gdata.server.authentication.GDataHttpAuthenticator;
-import org.apache.lucene.gdata.server.registry.ComponentType;
-import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
-
-/**
- * The RequestAuthenticator provides access to the registered
- * {@link org.apache.lucene.gdata.server.authentication.AuthenticationController}
- * as a super class for all request handler requiereing authentication for
- * access. This class implements the
- * {@link org.apache.lucene.gdata.server.authentication.GDataHttpAuthenticator}
- * to get the auth token from the given request and call the needed Components
- * to authenticat the client.
- * <p>
- * For request handler handling common requests like entry insert or update the
- * authentication will be based on the account name verified as the owner of the
- * feed to alter. If the accountname in the token does not match the name of the
- * account which belongs to the feed the given role will be used for
- * autentication. Authentication using the
- * {@link RequestAuthenticator#authenticateAccount(HttpServletRequest, AccountRole)}
- * method, the account name will be ignored, authentication will be based on the
- * given <tt>AccountRole</tt>
- * </p>
- * 
- * @author Simon Willnauer
- * 
- */
-public class RequestAuthenticator implements GDataHttpAuthenticator {
-    private static final Log LOG = LogFactory
-            .getLog(RequestAuthenticator.class);
-
-    /**
-     * @see org.apache.lucene.gdata.server.authentication.GDataHttpAuthenticator#authenticateAccount(org.apache.lucene.gdata.server.GDataRequest,
-     *      org.apache.lucene.gdata.data.GDataAccount.AccountRole)
-     */
-    public boolean authenticateAccount(GDataRequest request, AccountRole role) {
-        String clientIp = request.getRemoteAddress();
-        if (LOG.isDebugEnabled())
-            LOG
-                    .debug("Authenticating Account for GDataRequest -- modifying entries -- Role: "
-                            + role + "; ClientIp: " + clientIp);
-
-        AuthenticationController controller = GDataServerRegistry.getRegistry()
-                .lookup(AuthenticationController.class,
-                        ComponentType.AUTHENTICATIONCONTROLLER);
-        ServiceFactory factory = GDataServerRegistry.getRegistry().lookup(
-                ServiceFactory.class, ComponentType.SERVICEFACTORY);
-        AdminService adminService = factory.getAdminService();
-        GDataAccount account;
-        try {
-            account = adminService.getFeedOwningAccount(request.getFeedId());
-            String token = getTokenFromRequest(request.getHttpServletRequest());
-            if (LOG.isDebugEnabled())
-                LOG.debug("Got Token: " + token + "; for requesting account: "
-                        + account);
-            if (account != null && token != null)
-                return controller.authenticateToken(token, clientIp,
-                        AccountRole.ENTRYAMINISTRATOR, account.getName());
-
-        } catch (ServiceException e) {
-            LOG.error("can get GDataAccount for feedID -- "
-                    + request.getFeedId(), e);
-            throw new AuthenticatorException(" Service exception occured", e);
-
-        }finally{
-        
-            if(adminService!=null)
-                adminService.close();
-        
-        }
-
-        return false;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.authentication.GDataHttpAuthenticator#authenticateAccount(javax.servlet.http.HttpServletRequest,
-     *      org.apache.lucene.gdata.data.GDataAccount.AccountRole)
-     */
-    public boolean authenticateAccount(HttpServletRequest request,
-            AccountRole role) {
-        String clientIp = request.getRemoteAddr();
-        if (LOG.isDebugEnabled())
-            LOG
-                    .debug("Authenticating Account for GDataRequest -- modifying entries -- Role: "
-                            + role + "; ClientIp: " + clientIp);
-        AuthenticationController controller = GDataServerRegistry.getRegistry()
-                .lookup(AuthenticationController.class,
-                        ComponentType.AUTHENTICATIONCONTROLLER);
-        String token = getTokenFromRequest(request);
-        if (LOG.isDebugEnabled())
-            LOG.debug("Got Token: " + token + ";");
-        if (token == null)
-            return false;
-        return controller.authenticateToken(token, clientIp, role, null);
-
-    }
-
-    protected String getTokenFromRequest(HttpServletRequest request) {
-        String token = request
-                .getHeader(AuthenticationController.AUTHORIZATION_HEADER);
-        if (token == null || !token.startsWith("GoogleLogin")) {
-            Cookie[] cookies = request.getCookies();
-            if (cookies == null) {
-                return null;
-            }
-            for (int i = 0; i < cookies.length; i++) {
-                if (cookies[i].getName().equals(
-                        AuthenticationController.TOKEN_KEY)) {
-                    token = cookies[i].getValue();
-                    break;
-                }
-
-            }
-        }
-        if (token != null)
-            token = token.substring(token.indexOf("=") + 1);
-        return token;
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/RequestHandlerFactory.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/RequestHandlerFactory.java
deleted file mode 100644
index b3a9cd6..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/RequestHandlerFactory.java
+++ /dev/null
@@ -1,99 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.servlet.handler;
-
-import org.apache.lucene.gdata.server.registry.ServerComponent;
-
-/**
- * Abstract Superclass for RequestHandlerFactories
- * @author Simon Willnauer
- * 
- */
-public abstract class RequestHandlerFactory implements ServerComponent {
-    
-
-
-
-    /**
-     * public constructor to enable loading via the registry
-     * @see org.apache.lucene.gdata.server.registry.Component
-     * @see org.apache.lucene.gdata.server.registry.GDataServerRegistry
-     */
-    public RequestHandlerFactory() {
-        super();
-
-    }
-
-
-    /**
-     * Creates a EntryUpdateHandler which processes a GDATA UPDATE request.
-     * @return - a RequestHandlerInstance
-     */
-    public abstract GDataRequestHandler getEntryUpdateHandler();
-
-    /**
-     * Creates a EntryDeleteHandler which processes a GDATA DELETE request.
-     * @return - a RequestHandlerInstance
-     */
-    public abstract GDataRequestHandler getEntryDeleteHandler();
-
-    /**
-     * Creates a FeedQueryHandler which processes a GDATA Query / Get request.
-     * @return - a RequestHandlerInstance
-     */
-    public abstract GDataRequestHandler getFeedQueryHandler();
-
-    /**
-     * Creates a EntryInsertHandler which processes a GDATA Insert request.
-     * @return - a RequestHandlerInstance
-     */
-    public abstract GDataRequestHandler getEntryInsertHandler();
-    /**
-     * Creates a InsertAccountHandler which processes a Account Insert request.
-     * @return - a RequestHandlerInstance
-     */
-    public abstract GDataRequestHandler getInsertAccountHandler();
-    /**
-     * Creates a DeleteAccountHandler which processes a Account Delete request.
-     * @return - a RequestHandlerInstance
-     */
-    public abstract GDataRequestHandler getDeleteAccountHandler();
-    /**
-     * Creates a UpdateAccountHandler which processes a Account Update request.
-     * @return - a RequestHandlerInstance
-     */
-    public abstract GDataRequestHandler getUpdateAccountHandler();
-    /**
-     * Creates a InsertFeedHandler which processes a Feed Insert request.
-     * @return - a RequestHandlerInstance
-     */
-    public abstract GDataRequestHandler getInsertFeedHandler();
-    /**
-     * Creates a UpdateFeedHandler which processes a Feed Insert request.
-     * @return - a RequestHandlerInstance
-     */
-    public abstract GDataRequestHandler getUpdateFeedHandler();
-    /**
-     * Creates a DeleteFeedHandler which processes a Feed Insert request.
-     * @return - a RequestHandlerInstance
-     */
-    public abstract GDataRequestHandler getDeleteFeedHandler();
-    
-
-    
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/UpdateAccountStrategy.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/UpdateAccountStrategy.java
deleted file mode 100644
index 38735f6..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/UpdateAccountStrategy.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.servlet.handler;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.data.GDataAccount;
-import org.apache.lucene.gdata.server.ServiceException;
-
-/**
- * @author Simon Willnauer
- *
- */
-public class UpdateAccountStrategy extends AbstractAccountHandler {
-
-    private static final Log LOG = LogFactory.getLog(UpdateAccountStrategy.class);
-
-    
-
-    @Override
-    protected void processServiceAction(GDataAccount account) throws ServiceException {
-        try{
-        this.service.updateAccount(account);
-        }catch (ServiceException e) {
-            LOG.error("Can't update account -- "+e.getMessage(),e);
-            throw e;
-        }
-        
-    }
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/UpdateFeedHandler.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/UpdateFeedHandler.java
deleted file mode 100644
index c6db626..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/UpdateFeedHandler.java
+++ /dev/null
@@ -1,88 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.servlet.handler;
-
-import java.io.IOException;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.data.GDataAccount;
-import org.apache.lucene.gdata.data.ServerBaseFeed;
-import org.apache.lucene.gdata.server.GDataResponse;
-import org.apache.lucene.gdata.server.ServiceException;
-import org.apache.lucene.gdata.server.ServiceFactory;
-import org.apache.lucene.gdata.server.administration.AdminService;
-import org.apache.lucene.gdata.server.registry.ComponentType;
-import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class UpdateFeedHandler extends AbstractFeedHandler {
-    private static final Log LOG = LogFactory.getLog(UpdateFeedHandler.class);
-
-    /**
-     * @see org.apache.lucene.gdata.servlet.handler.AbstractFeedHandler#processRequest(javax.servlet.http.HttpServletRequest,
-     *      javax.servlet.http.HttpServletResponse)
-     */
-    @SuppressWarnings("unused")
-    @Override
-    public void processRequest(HttpServletRequest request,
-            HttpServletResponse response) throws ServletException, IOException {
-        super.processRequest(request, response);
-        if (this.authenticated) {
-            AdminService service= null;
-            try {
-                ServerBaseFeed feed = createFeedFromRequest(request);
-                GDataAccount account = createRequestedAccount(request);
-
-                GDataServerRegistry registry = GDataServerRegistry
-                        .getRegistry();
-                ServiceFactory serviceFactory = registry.lookup(
-                        ServiceFactory.class, ComponentType.SERVICEFACTORY);
-                if (serviceFactory == null) {
-                    setError(GDataResponse.SERVER_ERROR,
-                            "required component is not available");
-                    throw new FeedHandlerException(
-                            "Can't update feed - ServiceFactory is null");
-                }
-                service = serviceFactory.getAdminService();
-                service.updateFeed(feed, account);
-            } catch (ServiceException e) {
-                setError(e.getErrorCode(),
-                        "can not update feed");
-                LOG.error("Can not update feed -- " + e.getMessage(), e);
-            } catch (Exception e) {
-
-                LOG.error("Can not update feed -- " + e.getMessage(), e);
-
-            }finally{
-                if(service != null)
-                    service.close();
-            }
-        }
-        sendResponse(response);
-        
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/package.html b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/package.html
deleted file mode 100644
index c41f397..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/handler/package.html
+++ /dev/null
@@ -1,10 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
-<html> 
-<head> 
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
-   <meta name="Author" content="Simon Willnauer"> 
-</head> 
-<body> 
-GData Request Handler. 
-</body> 
-</html> 
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/package.html b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/package.html
deleted file mode 100644
index ac6f4d4..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/servlet/package.html
+++ /dev/null
@@ -1,10 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
-<html> 
-<head> 
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
-   <meta name="Author" content="Simon Willnauer"> 
-</head> 
-<body> 
-Servlets acting as basic interfaces for gdata requests. 
-</body> 
-</html> 
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/IDGenerator.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/IDGenerator.java
deleted file mode 100644
index 35a09fd..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/IDGenerator.java
+++ /dev/null
@@ -1,180 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */ 
- 
-package org.apache.lucene.gdata.storage; 
- 
-import java.security.MessageDigest; 
-import java.security.NoSuchAlgorithmException; 
-import java.security.SecureRandom; 
-import java.util.concurrent.ArrayBlockingQueue; 
-import java.util.concurrent.BlockingQueue; 
-import java.util.concurrent.atomic.AtomicBoolean;
- 
-import org.apache.commons.logging.Log; 
-import org.apache.commons.logging.LogFactory; 
- 
-/** 
- * This is the main entry ID generator to generate unique ids for each entry. 
- * The Generator uses {@link java.security.SecureRandom} Numbers and the 
- * {@link java.lang.System#currentTimeMillis()} to create a semi-unique sting; 
- * The string will be digested by a {@link java.security.MessageDigest} which 
- * returns a byte array. The generator encodes the byte array as a hex string. 
- * <p> 
- * The generated Id's will cached in a 
- * {@link java.util.concurrent.BlockingQueue} and reproduced if an id has been 
- * removed. 
- * </p> 
- *  
- * @author Simon Willnauer 
- *  
- */ 
-public class IDGenerator { 
-    final AtomicBoolean stopped = new AtomicBoolean(false);
-    
-    private final SecureRandom secureRandom; 
- 
-    private final MessageDigest mdigest; 
- 
-    private final BlockingQueue<String> blockingQueue; 
- 
-    private Thread runner; 
- 
-    private static final int DEFAULT_CAPACITY = 10; 
- 
-    protected static final Log LOGGER = LogFactory.getLog(IDGenerator.class);
-
-    private static final String RUNNER_THREAD_NAME = "GDATA-ID Generator"; 
- 
-    /** 
-     * Constructs a new ID generator. with a fixed capacity of prebuild ids. The 
-     * default capacity is 10. Every given parameter less than 10 will be 
-     * ignored. 
-     *  
-     * @param capacity - 
-     *            capacity of the prebuild id queue 
-     * @throws NoSuchAlgorithmException - 
-     *             if the algorithm does not exist 
-     */ 
-    public IDGenerator(int capacity) throws NoSuchAlgorithmException { 
- 
-        this.secureRandom = SecureRandom.getInstance("SHA1PRNG"); 
-        this.mdigest = MessageDigest.getInstance("SHA-1"); 
-        this.blockingQueue = new ArrayBlockingQueue<String>( 
-                (capacity < DEFAULT_CAPACITY ? DEFAULT_CAPACITY : capacity), 
-                false); 
-        startIDProducer(); 
- 
-    } 
- 
-    /** 
-     * This method takes a gnerated id from the IDProducer queue and retruns it. 
-     * If no ID is available this method will wait until an ID is produced. This 
-     * implementation is thread-safe. 
-     *  
-     * @return a UID 
-     * @throws InterruptedException - 
-     *             if interrupted while waiting 
-     */ 
-    public String getUID() throws InterruptedException { 
-        return this.blockingQueue.take(); 
-    } 
- 
-    private void startIDProducer() { 
-        if (this.runner == null) { 
-            UIDProducer producer = new UIDProducer(this.blockingQueue, 
-                    this.secureRandom, this.mdigest); 
-            this.runner = new Thread(producer);
-            this.runner.setDaemon(true);
-            this.runner.setName(RUNNER_THREAD_NAME);
-            this.runner.start(); 
-        } 
-    } 
- 
-    /** 
-     * @return the current size of the queue 
-     */ 
-    public int getQueueSize() { 
-        return this.blockingQueue.size(); 
-    } 
- 
-    /** 
-     * Stops the id-producer 
-     */ 
-    public void stopIDGenerator() {
-        this.stopped.set(true);
-        this.runner.interrupt(); 
-        
-    } 
- 
-    private class UIDProducer implements Runnable { 
-        SecureRandom random; 
- 
-        BlockingQueue<String> queue; 
- 
-        MessageDigest digest; 
- 
-        UIDProducer(BlockingQueue<String> queue, SecureRandom random, 
-                MessageDigest digest) { 
-            this.queue = queue; 
-            this.random = random; 
-            this.digest = digest; 
- 
-        } 
- 
-        /** 
-         * @see java.lang.Runnable#run() 
-         */ 
-        public void run() { 
- 
-            while (!IDGenerator.this.stopped.get()) { 
-                try { 
-                    this.queue.put(produce()); 
-                } catch (InterruptedException e) {
-                    LOGGER 
-                            .warn("UIDProducer has been interrupted -- runner is going down"); 
-                    return; 
-                } 
-            } 
- 
-        } 
- 
-        private String produce() { 
-            String randomNumber = Integer.toString(this.random.nextInt()); 
-            byte[] byteResult = this.digest.digest(randomNumber.getBytes()); 
-            return hexEncode(byteResult); 
-        } 
- 
-    } 
- 
-    /** 
-     * Encodes a given byte array into a hex string. 
-     *  
-     * @param input - 
-     *            the byte array to encode 
-     * @return hex string representation of the given byte array 
-     */ 
-    static String hexEncode(byte[] input) { 
-        StringBuffer result = new StringBuffer(); 
-        char[] digits = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
-                'a', 'b', 'c', 'd', 'e', 'f' }; 
-        for (int idx = 0; idx < input.length; ++idx) { 
-            byte b = input[idx]; 
-            result.append(digits[(b & 0xf0) >> 4]); 
-            result.append(digits[b & 0x0f]); 
-        } 
-        return result.toString(); 
-    } 
-} 
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/ModificationConflictException.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/ModificationConflictException.java
deleted file mode 100755
index 08e2239..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/ModificationConflictException.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.storage;
-
-/**
- * This exception will be thrown if a Version conflict occures while updateing
- * or deleteing an entry. Or if one entry is modified concurrently.
- * 
- * @author Simon Willnauer
- * 
- */
-public class ModificationConflictException extends StorageException {
-
-    /**
-     * 
-     */
-    private static final long serialVersionUID = 1L;
-
-    /**
-     * Constructs a new ModificationConflictException
-     */
-    public ModificationConflictException() {
-        super();
-    }
-
-    /**
-     * Constructs a new ModificationConflictException
-     * 
-     * @param message -
-     *            the exception message
-     */
-    public ModificationConflictException(String message) {
-        super(message);
-
-    }
-
-    /**
-     * Constructs a new ModificationConflictException
-     * 
-     * @param message -
-     *            the exception message
-     * @param cause -
-     *            the root cause of this exception
-     */
-    public ModificationConflictException(String message, Throwable cause) {
-        super(message, cause);
-
-    }
-
-    /**
-     * Constructs a new ModificationConflictException
-     * 
-     * @param cause -
-     *            the root cause of this exception
-     */
-    public ModificationConflictException(Throwable cause) {
-        super(cause);
-
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/ResourceNotFoundException.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/ResourceNotFoundException.java
deleted file mode 100644
index f7470fa..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/ResourceNotFoundException.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.storage;
-
-/**
- * This exception will be thrown if an requested resource of a resource to modify can not be found
- * @author Simon Willnauer
- *
- */
-public class ResourceNotFoundException extends StorageException {
-
-   
-    private static final long serialVersionUID = -8549987918130998249L;
-
-    /**
-     * Constructs an empty ResourceNotFoundException
-     */
-    public ResourceNotFoundException() {
-        super();
-        // TODO Auto-generated constructor stub
-    }
-
-    /**
-     * Constructs a new ResourceNotFoundException with an exception message
-     * @param message - the exception message
-     */
-    public ResourceNotFoundException(String message) {
-        super(message);
-        // TODO Auto-generated constructor stub
-    }
-
-    /**
-     * Constructs a new ResourceNotFoundException with an exception message and a root cause 
-     * @param message - the exception message
-     * @param cause - the root cause of this exception
-     */
-    public ResourceNotFoundException(String message, Throwable cause) {
-        super(message, cause);
-        // TODO Auto-generated constructor stub
-    }
-
-    /**
-     * Constructs a new ResourceNotFoundException with  a root cause
-     * @param cause - the root cause of this exception
-     * 
-     */
-    public ResourceNotFoundException(Throwable cause) {
-        super(cause);
-        // TODO Auto-generated constructor stub
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/Storage.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/Storage.java
deleted file mode 100644
index 48375d7..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/Storage.java
+++ /dev/null
@@ -1,276 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.storage;
-
-import org.apache.lucene.gdata.data.GDataAccount;
-import org.apache.lucene.gdata.data.ServerBaseEntry;
-import org.apache.lucene.gdata.data.ServerBaseFeed;
-
-import com.google.gdata.data.BaseEntry;
-import com.google.gdata.data.BaseFeed;
-
-/**
- * A interface every storage implementation must provide to access the
- * <tt>Storage</tt>. It describes all access methodes needed to store,
- * retrieve and look up data stored in the <tt>Storage</tt> component. This
- * interface acts as a <tt>Facade</tt> to hide the storage implementation from
- * the user.
- * <p>
- * This could also act as a proxy for a remote storage. It also removes any
- * restrictions from custom storage implementations.
- * </p>
- * 
- * 
- * @author Simon Willnauer
- * 
- */
-/*
- * not final yet
- */
-public interface Storage {
-
-    /**
-     * 
-     * Stores the given entry. The ServerBaseEntry must provide a feed id and
-     * the service type. configuration for the entry.
-     * 
-     * @param entry -
-     *            the entry to store
-     * 
-     * @return - the stored Entry for the server response
-     * @throws StorageException -
-     *             if the entry can not be stored or required field are not set.
-     */
-    public abstract BaseEntry storeEntry(ServerBaseEntry entry)
-            throws StorageException;
-
-    /**
-     * Deletes the given entry. The ServerBaseEntry just hase to provide the
-     * entry id to be deleted.
-     * 
-     * @param entry -
-     *            the entry to delete from the storage
-     * @throws StorageException -
-     *             if the entry can not be deleted or the entry does not exist
-     *             or required field are not set.
-     */
-    public abstract void deleteEntry(ServerBaseEntry entry)
-            throws StorageException;
-
-    /**
-     * Updates the given entry. The ServerBaseEntry must provide a feed id,
-     * service id and the
-     * {@link org.apache.lucene.gdata.server.registry.ProvidedService}
-     * 
-     * @param entry -
-     *            the entry to update
-     * 
-     * @return - the updated entry for server response.
-     * @throws StorageException -
-     *             if the entry can not be updated or does not exist or required
-     *             field are not set.
-     */
-    public abstract BaseEntry updateEntry(ServerBaseEntry entry)
-            throws StorageException;
-
-    /**
-     * Retrieves the requested feed from the storage. The given ServerBaseFeed
-     * must provide information about the feed id, max-result count and the
-     * start index. To create feeds and entries also the service type must be
-     * provided.
-     * 
-     * @param feed -
-     *            the to retieve from the storage
-     * @return the requested feed
-     * @throws StorageException -
-     *             the feed does not exist or can not be retrieved or required
-     *             field are not set.
-     */
-    public abstract BaseFeed getFeed(ServerBaseFeed feed)
-            throws StorageException;
-
-    /**
-     * Retrieves the requested entry from the storage. The given entry must
-     * provide information about the entry id and service type.
-     * 
-     * @param entry -
-     *            the entry to retrieve
-     * @return - the requested entry
-     * @throws StorageException -
-     *             if the entry does not exist or can not be created or required
-     *             field are not set.
-     */
-    public abstract BaseEntry getEntry(ServerBaseEntry entry)
-            throws StorageException;
-
-    /**
-     * Saves a new account. Required attributes to set are <tt>password</tt>
-     * and <tt>accountname</tt>
-     * 
-     * @param account -
-     *            the account to save
-     * @throws StorageException -
-     *             if the account can not be stored or the account already
-     *             exists or required field are not set.
-     */
-    public abstract void storeAccount(final GDataAccount account)
-            throws StorageException;
-
-    /**
-     * Updates an existing account. Required attributes to set are
-     * <tt>password</tt> and <tt>accountname</tt>
-     * 
-     * @param account -
-     *            the account to update
-     * @throws StorageException -
-     *             if the account does not exist or required field are not set.
-     */
-    public abstract void updateAccount(final GDataAccount account)
-            throws StorageException;
-
-    /**
-     * Deletes the account for the given account name. All feeds and entries
-     * referencing this account will be deleted as well!
-     * 
-     * @param accountname -
-     *            the name of the account to delete
-     * @throws StorageException -
-     *             if the account does not exist
-     */
-    public abstract void deleteAccount(final String accountname)
-            throws StorageException;
-
-    /**
-     * Stores a new feed for a existing account. The Feed must provide
-     * information about the service type to store the feed for and the feed id
-     * used for accessing and retrieving the feed from the storage. Each feed is
-     * associated with a provided service. This method does check wheather a
-     * feed with the same feed id as the given feed does already exists.
-     * 
-     * @see org.apache.lucene.gdata.server.registry.ProvidedService
-     * @param feed -
-     *            the feed to create
-     * @param accountname -
-     *            the account name belongs to the feed
-     * @throws StorageException -
-     *             if the feed already exists or the feed can not be stored
-     */
-    public abstract void storeFeed(final ServerBaseFeed feed, String accountname)
-            throws StorageException;
-
-    /**
-     * Deletes the feed for the given feed id. All Entries referencing the given
-     * feed id will be deleted as well.
-     * 
-     * @param feedId -
-     *            the feed id for the feed to delete.
-     * @throws StorageException -
-     *             if the feed for the feed id does not exist or the feed can
-     *             not be deleted
-     */
-    public abstract void deleteFeed(final String feedId)
-            throws StorageException;
-
-    /**
-     * Updates a stored feed. The Feed must provide information about the
-     * service type to store the feed for and the feed id used for accessing and
-     * retrieving the feed from the storage.
-     * 
-     * @param feed -
-     *            the feed to update
-     * @param accountname -
-     *            the account name belongs to the feed
-     * @throws StorageException -
-     *             if the feed does not exist or the feed can not be updated
-     */
-    public abstract void updateFeed(final ServerBaseFeed feed,
-            String accountname) throws StorageException;
-
-    /**
-     * Retrieves the service name for a stored feed
-     * 
-     * @param feedId -
-     *            the feed id
-     * @return - the name of the service
-     * @throws StorageException -
-     *             if no feed for the provided id is stored
-     */
-    public abstract String getServiceForFeed(String feedId)
-            throws StorageException;
-
-    /**
-     * 
-     * Retrieves the {@link GDataAccount} for the given account name
-     * @param accountName -
-     *            the name of the requested account
-     * @return - a {@link GDataAccount} instance for the requested account name
-     * @throws StorageException -
-     *             if no account for the account name is stored
-     * 
-     */
-    public abstract GDataAccount getAccount(String accountName)
-            throws StorageException;
-
-    /**
-     * close this storage instance. This method will be called by clients after
-     * use.
-     */
-    public abstract void close();
-
-    /**
-     * Each feed belongs to one specific account. This method retrieves the
-     * account name for
-     * 
-     * @param feedId -
-     *            the id of the feed to retrieve the accountname
-     * @return - the name / id of the account associated with the feed for the
-     *         given feed id
-     * @throws StorageException -
-     *             if the feed is not stored or the storage can not be accessed
-     */
-    public String getAccountNameForFeedId(String feedId)
-            throws StorageException;
-
-    /**
-     * Retrieves the date of the last modification for the given id
-     * 
-     * @param entryId -
-     *            the entry Id
-     * @param feedId -
-     *            the feed which contains the entry
-     * @return - The date of the last modifiaction in milliseconds or
-     *         <code>new Long(0)</code> if the resource can not be found eg.
-     *         the time can not be accessed
-     * @throws StorageException -
-     *             if the storage can not be accessed
-     */
-    public Long getEntryLastModified(String entryId, String feedId)
-            throws StorageException;
-
-    /**
-     * Retrieves the date of the last modification for the given id
-     * 
-     * @param feedId -
-     *            the feed Id
-     * @return - The date of the last modifiaction in milliseconds or
-     *         <code>new Long(0)</code> if the resource can not be found eg.
-     *         the time can not be accessed
-     * @throws StorageException -
-     *             if the storage can not be accessed
-     */
-    public Long getFeedLastModified(String feedId) throws StorageException;
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/StorageController.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/StorageController.java
deleted file mode 100644
index b4f9710..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/StorageController.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.storage;
-
-import org.apache.lucene.gdata.server.registry.ServerComponent;
-
-/**
- * An interface to define a central storage controller acting as a
- * <tt>Stroage</tt> Factory. The <tt>StroageController</tt> manages the
- * storage logic. Subclasses of {@link StorageController} can be registered as
- * {@link org.apache.lucene.gdata.server.registry.Component} in the
- * {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry}. A
- * single instance of the contorller will be loaded and passed to clients via
- * the lookup service.
- * <p>
- * This instances, registered in the registry must be thread save as they are
- * shared between several clients
- * </p>
- * <p>
- * Each StroageController implementation must provide a super user
- * {@link org.apache.lucene.gdata.data.GDataAccount} with all
- * {@link org.apache.lucene.gdata.data.GDataAccount.AccountRole} set. This
- * account must have the defined name <i>administrator</i> and a default
- * password <i>password</i>. The password has to be updated by the server
- * administrator before production use.
- * To get the predefinded GDataAccount use {@link org.apache.lucene.gdata.data.GDataAccount#createAdminAccount()}
- * </p>
- *
- * 
- * @author Simon Willnauer
- * 
- */
-public interface StorageController extends ServerComponent {
-    /**
-     * Destroys the controller - this method is called by the registry when the
-     * context will be destroyed
-     */
-    public abstract void destroy();
-
-    /**
-     * Creates Storage instances to access the underlaying storage component
-     * 
-     * @return a storage instance
-     * @throws StorageException -
-     *             if the storage instance can not be created
-     */
-    public abstract Storage getStorage() throws StorageException;
-    
-    /**
-     * Releases a new unique ID
-     * @return - unique ID
-     */
-    public abstract String releaseId();
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/StorageException.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/StorageException.java
deleted file mode 100644
index ad715a7..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/StorageException.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */ 
-package org.apache.lucene.gdata.storage; 
- 
-/** 
- * The StorageException will be throw if any error or exception inside the 
- * storage implementation occures. This exception hides all other exceptions 
- * from inside the storage. 
- *  
- * @author Simon Willnauer 
- *  
- */ 
-public class StorageException extends RuntimeException { 
- 
-    /** 
-     *  
-     */ 
-    private static final long serialVersionUID = -4997572416934126511L; 
- 
-    /** 
-     * Constructs a new StorageException 
-     */ 
-    public StorageException() { 
-        super(); 
- 
-    } 
- 
-    /** 
-     * Constructs a new StorageException 
-     *  
-     * @param message - 
-     *            the exception message 
-     */ 
-    public StorageException(String message) { 
-        super(message); 
- 
-    } 
- 
-    /** 
-     * Constructs a new StorageException 
-     *  
-     * @param message - 
-     *            the exception message 
-     * @param cause - 
-     *            the root cause of this exception 
-     */ 
-    public StorageException(String message, Throwable cause) { 
-        super(message, cause); 
- 
-    } 
- 
-    /** 
-     * Constructs a new StorageException 
-     *  
-     * @param cause - 
-     *            the root cause of this exception 
-     */ 
-    public StorageException(Throwable cause) { 
-        super(cause); 
- 
-    } 
- 
-} 
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/StorageFactory.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/StorageFactory.java
deleted file mode 100644
index e69de29..0000000
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/db4o/DB4oController.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/db4o/DB4oController.java
deleted file mode 100755
index 20aa476..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/db4o/DB4oController.java
+++ /dev/null
@@ -1,426 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.storage.db4o;
-
-import java.lang.reflect.InvocationHandler;
-import java.lang.reflect.Proxy;
-import java.security.NoSuchAlgorithmException;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.data.GDataAccount;
-import org.apache.lucene.gdata.data.ServerBaseFeed;
-import org.apache.lucene.gdata.server.registry.Component;
-import org.apache.lucene.gdata.server.registry.ComponentType;
-import org.apache.lucene.gdata.server.registry.Scope;
-import org.apache.lucene.gdata.server.registry.ScopeVisitor;
-import org.apache.lucene.gdata.server.registry.configuration.Requiered;
-import org.apache.lucene.gdata.storage.IDGenerator;
-import org.apache.lucene.gdata.storage.Storage;
-import org.apache.lucene.gdata.storage.StorageController;
-import org.apache.lucene.gdata.storage.StorageException;
-import org.apache.lucene.gdata.storage.db4o.DB4oStorage.DB4oEntry;
-import org.apache.lucene.gdata.utils.Pool;
-import org.apache.lucene.gdata.utils.PoolObjectFactory;
-import org.apache.lucene.gdata.utils.SimpleObjectPool;
-
-import com.db4o.Db4o;
-import com.db4o.ObjectContainer;
-import com.db4o.ObjectServer;
-import com.google.gdata.data.BaseEntry;
-import com.google.gdata.data.BaseFeed;
-
-/**
- * The DB4o StorageContorller can be used as a persitence component for the
- * gdata-server. To use DB4o a third party jar needs to added to the lib
- * directory of the project. If the jar is not available in the lib directory
- * all db4o dependent class won't be included in the build.
- * <p>
- * If the jar is present in the lib directory this class can be configured as a
- * {@link org.apache.lucene.gdata.server.registry.ComponentType#STORAGECONTROLLER}
- * via the <i>gdata-config.xml</i> file. For detailed config documentation see
- * the wiki page.
- * </p>
- * <p>
- * The DB4oController can run as a client or as a server to serve other running
- * db4o clients in the network. To achive the best performance out of the db4o
- * caching layer connections to the server will be reused in a connection pool.
- * A connection will not be shared withing more than one thread. The controller
- * release one connection per request and returns the connection when the
- * request has been destroyed.
- * </p>
- * @see <a href="http://www.db4o.com">db4o website</a>
- * @see org.apache.lucene.gdata.utils.Pool
- * 
- * 
- * @author Simon Willnauer
- * 
- */
-@Component(componentType = ComponentType.STORAGECONTROLLER)
-@Scope(scope = Scope.ScopeType.REQUEST)
-public class DB4oController implements StorageController, ScopeVisitor {
-    private static final Log LOG = LogFactory.getLog(DB4oController.class);
-
-    private final ThreadLocal<Storage> threadLocalStorage = new ThreadLocal<Storage>();
-
-    private Pool<ObjectContainer> containerPool;
-
-    private ObjectServer server;
-
-    private final IDGenerator idGenerator;
-
-    private boolean weakReferences;
-
-    private boolean runAsServer;
-
-    private int port;
-
-    private String filePath;
-
-    private String user;
-
-    private String password;
-
-    private String host;
-
-    private int containerPoolSize;
-
-    /**
-     * @throws NoSuchAlgorithmException
-     * 
-     */
-    public DB4oController() throws NoSuchAlgorithmException {
-
-        this.idGenerator = new IDGenerator(15);
-
-    }
-
-    ObjectContainer releaseContainer() {
-        return this.server.openClient();
-
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.StorageController#destroy()
-     */
-    public void destroy() {
-        this.containerPool.destroy();
-        this.idGenerator.stopIDGenerator();
-        this.server.close();
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.StorageController#getStorage()
-     */
-    public Storage getStorage() throws StorageException {
-       Storage retVal = this.threadLocalStorage.get();
-        if (retVal != null)
-            return retVal;
-
-        retVal = new DB4oStorage(this.containerPool.aquire(), this);
-
-        this.threadLocalStorage.set(retVal);
-        return retVal;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.registry.ServerComponent#initialize()
-     */
-    public void initialize() {
-        if (LOG.isInfoEnabled())
-            LOG.info("Initialize " + this.toString());
-
-        Db4o.configure().objectClass(DB4oEntry.class).objectField("updated")
-                .indexed(true);
-        Db4o.configure().objectClass(BaseEntry.class).objectField("id")
-                .indexed(true);
-        Db4o.configure().objectClass(BaseFeed.class).objectField("id").indexed(
-                true);
-        Db4o.configure().objectClass(GDataAccount.class).objectField("name")
-                .indexed(true);
-        Db4o.configure().objectClass(ServerBaseFeed.class).cascadeOnDelete(
-                false);
-        Db4o.configure().objectClass(ServerBaseFeed.class)
-                .maximumActivationDepth(0);
-        Db4o.configure().objectClass(BaseFeed.class).minimumActivationDepth(1);
-        Db4o.configure().objectClass(BaseEntry.class)
-                .minimumActivationDepth(1);
-        Db4o.configure().objectClass(BaseFeed.class).cascadeOnDelete(true);
-        Db4o.configure().objectClass(DB4oEntry.class).cascadeOnDelete(true);
-        Db4o.configure().objectClass(GDataAccount.class).cascadeOnDelete(true);
-        Db4o.configure().weakReferences(this.weakReferences);
-        Db4o.configure().optimizeNativeQueries(false);
-        if (this.runAsServer) {
-            this.server = Db4o.openServer(this.filePath, this.port);
-            if(this.server == null)
-                throw new RuntimeException("Can't create server at confiugred destination -- "+this.filePath);
-            this.server.grantAccess(this.user, this.password);
-        } else {
-            InvocationHandler handler = new ObjectServerDecorator(this.user,
-                    this.password, this.host, this.port);
-            this.server = (ObjectServer) Proxy.newProxyInstance(this.getClass()
-                    .getClassLoader(), new Class[] { ObjectServer.class },
-                    handler);
-        }
-
-        PoolObjectFactory<ObjectContainer> factory = new ObjectContinerFactory(
-                this.server);
-        this.containerPool = new SimpleObjectPool<ObjectContainer>(
-                this.containerPoolSize, factory);
-        try {
-            createAdminAccount();
-        } catch (StorageException e) {
-            LOG.error("Can not create admin account -- ",e);
-        }
-    }
-
-    private void createAdminAccount() throws StorageException {
-        GDataAccount adminAccount = GDataAccount.createAdminAccount();
-        visiteInitialize();
-        Storage sto = this.getStorage();
-        try {
-            sto.getAccount(adminAccount.getName());
-        } catch (Exception e) {
-            this.getStorage().storeAccount(adminAccount);
-        } finally {
-            visiteDestroy();
-        }
-
-    }
-
-    
-    /**
-     * @see org.apache.lucene.gdata.storage.StorageController#releaseId()
-     */
-    public String releaseId(){
-        try{
-        return this.idGenerator.getUID();
-        }catch (InterruptedException e) {
-            throw new StorageException("ID producer has been interrupted",e);
-        }
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.registry.ScopeVisitor#visiteInitialize()
-     */
-    public void visiteInitialize() {
-        if (LOG.isInfoEnabled())
-            LOG.info("Opened Storage -- request initialized");
-        Storage storage = this.threadLocalStorage.get();
-        if (storage != null) {
-            LOG.warn("Storage already opened");
-            return;
-        }
-
-        storage = new DB4oStorage(this.containerPool.aquire(), this);
-
-        this.threadLocalStorage.set(storage);
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.registry.ScopeVisitor#visiteDestroy()
-     */
-    public void visiteDestroy() {
-        Storage storage = this.threadLocalStorage.get();
-        if (storage == null) {
-            LOG.warn("no Storage opened -- threadlocal returned null");
-            return;
-        }
-        this.containerPool.release(((DB4oStorage)storage).getContainer());
-        this.threadLocalStorage.remove();
-        if (LOG.isInfoEnabled())
-            LOG.info("Closed Storage -- request destroyed");
-    }
-
-    private static class ObjectContinerFactory implements
-            PoolObjectFactory<ObjectContainer> {
-        private final ObjectServer server;
-
-        ObjectContinerFactory(final ObjectServer server) {
-            this.server = server;
-        }
-
-        /**
-         * @see org.apache.lucene.gdata.utils.PoolObjectFactory#getInstance()
-         */
-        public ObjectContainer getInstance() {
-
-            return this.server.openClient();
-        }
-
-        /**
-         * @param type -
-         *            object container to destroy (close)
-         * @see org.apache.lucene.gdata.utils.PoolObjectFactory#destroyInstance(Object)
-         */
-        public void destroyInstance(ObjectContainer type) {
-            type.close();
-        }
-
-    }
-
-    /**
-     * @return Returns the filePath.
-     */
-    public String getFilePath() {
-        return this.filePath;
-    }
-
-    /**
-     * @param filePath
-     *            The filePath to set.
-     */
-    public void setFilePath(String filePath) {
-        this.filePath = filePath;
-    }
-
-    /**
-     * @return Returns the host.
-     */
-    public String getHost() {
-        return this.host;
-    }
-
-    /**
-     * @param host
-     *            The host to set.
-     */
-    @Requiered
-    public void setHost(String host) {
-        this.host = host;
-    }
-
-    /**
-     * @return Returns the password.
-     */
-    public String getPassword() {
-        return this.password;
-    }
-
-    /**
-     * @param password
-     *            The password to set.
-     */
-    @Requiered
-    public void setPassword(String password) {
-        this.password = password;
-    }
-
-    /**
-     * @return Returns the port.
-     */
-    public int getPort() {
-        return this.port;
-    }
-
-    /**
-     * @param port
-     *            The port to set.
-     */
-    @Requiered
-    public void setPort(int port) {
-        this.port = port;
-    }
-
-    /**
-     * @return Returns the runAsServer.
-     */
-    public boolean isRunAsServer() {
-        return this.runAsServer;
-    }
-
-    /**
-     * @param runAsServer
-     *            The runAsServer to set.
-     */
-    @Requiered
-    public void setRunAsServer(boolean runAsServer) {
-        this.runAsServer = runAsServer;
-    }
-
-    /**
-     * @return Returns the user.
-     */
-    public String getUser() {
-        return this.user;
-    }
-
-    /**
-     * @param user
-     *            The user to set.
-     */
-    @Requiered
-    public void setUser(String user) {
-        this.user = user;
-    }
-
-    /**
-     * @return Returns the weakReferences.
-     */
-    public boolean isUseWeakReferences() {
-        return this.weakReferences;
-    }
-
-    /**
-     * @param weakReferences
-     *            The weakReferences to set.
-     */
-    @Requiered
-    public void setUseWeakReferences(boolean weakReferences) {
-        this.weakReferences = weakReferences;
-    }
-
-    /**
-     * @return Returns the containerPoolSize.
-     */
-    public int getContainerPoolSize() {
-        return this.containerPoolSize;
-    }
-
-    /**
-     * @param containerPoolSize
-     *            The containerPoolSize to set.
-     */
-    @Requiered
-    public void setContainerPoolSize(int containerPoolSize) {
-        this.containerPoolSize = containerPoolSize < 1 ? 1 : containerPoolSize;
-    }
-
-    /**
-     * @see java.lang.Object#toString()
-     */
-    @Override
-    public String toString() {
-        StringBuilder builder = new StringBuilder(this.getClass().getName())
-                .append(" ");
-        builder.append("host: ").append(this.host).append(" ");
-        builder.append("port: ").append(this.port).append(" ");
-        builder.append("pool size: ").append(this.containerPoolSize)
-                .append(" ");
-        builder.append("runs as server: ").append(this.runAsServer).append(" ");
-        builder.append("use weak references: ").append(this.weakReferences)
-                .append(" ");
-        builder.append("user: ").append(this.user).append(" ");
-        builder.append("password length: ").append(
-                this.password == null ? "no password" : this.password.length())
-                .append(" ");
-
-        return builder.toString();
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/db4o/DB4oStorage.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/db4o/DB4oStorage.java
deleted file mode 100755
index c1eba4f..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/db4o/DB4oStorage.java
+++ /dev/null
@@ -1,810 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.storage.db4o;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.data.GDataAccount;
-import org.apache.lucene.gdata.data.ServerBaseEntry;
-import org.apache.lucene.gdata.data.ServerBaseFeed;
-import org.apache.lucene.gdata.storage.ModificationConflictException;
-import org.apache.lucene.gdata.storage.ResourceNotFoundException;
-import org.apache.lucene.gdata.storage.Storage;
-import org.apache.lucene.gdata.storage.StorageController;
-import org.apache.lucene.gdata.storage.StorageException;
-
-import com.db4o.ObjectContainer;
-import com.db4o.ObjectSet;
-import com.db4o.query.Query;
-import com.google.gdata.data.BaseEntry;
-import com.google.gdata.data.BaseFeed;
-import com.google.gdata.data.DateTime;
-
-/**
- * 
- * Storage implementation for the DB4o storage component
- * @author Simon Willnauer
- * 
- */
-public class DB4oStorage implements Storage {
-    private static final Log LOG = LogFactory.getLog(DB4oStorage.class);
-
-    private static final int RENDER_ACTIVATION_DEPTH = 100;
-
-    private final ObjectContainer container;
-
-    private final StorageController controller;
-
-    private final List<String> semaphore = new ArrayList<String>();
-
-    
-    protected DB4oStorage(final ObjectContainer container,
-            StorageController controller) {
-        this.container = container;
-        this.controller = controller;
-    }
-
-    private void createSemaphore(String key)
-            throws ModificationConflictException {
-        this.semaphore.add(key);
-        if (this.container.ext().setSemaphore(key, 0))
-            return;
-        throw new ModificationConflictException(
-                "can not create semaphore for key -- " + key);
-    }
-
-    private void releaseAllSemaphore() {
-        for (String key : this.semaphore) {
-            this.container.ext().releaseSemaphore(key);
-        }
-        this.semaphore.clear();
-    }
-
-    private void releaseSemaphore(String key) {
-        if (this.semaphore.contains(key)) {
-            this.container.ext().releaseSemaphore(key);
-            this.semaphore.remove(key);
-        }
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#storeEntry(org.apache.lucene.gdata.data.ServerBaseEntry)
-     */
-    public BaseEntry storeEntry(ServerBaseEntry entry) throws StorageException {
-        if (entry == null)
-            throw new StorageException("Can not store entry -- is null");
-
-        if (entry.getFeedId() == null)
-            throw new StorageException("can not store entry -- feed id is null");
-        if (LOG.isDebugEnabled())
-            LOG.debug("Storing entry for feed: " + entry.getFeedId());
-        BaseFeed<BaseFeed, BaseEntry> feed = getFeedOnly(entry.getFeedId(),entry.getServiceType());
-       refreshPersistentObject(feed);
-        try {
-            StringBuilder idBuilder = new StringBuilder(entry.getFeedId());
-            idBuilder.append(this.controller.releaseId());
-            entry.setId(idBuilder.toString());
-        } catch (StorageException e) {
-            LOG.error("Can not create uid for entry -- " + e.getMessage(), e);
-            throw new StorageException("Can not create uid for entry -- "
-                    + e.getMessage(), e);
-
-        }
-        setUpdated(entry, feed);
-        DB4oEntry intEntry = new DB4oEntry();
-        intEntry.setEntry(entry.getEntry());
-        intEntry.setUpdateTime(entry.getUpdated().getValue());
-        intEntry.setFeedId(feed.getId());
-        intEntry.setVersion(entry.getVersion());
-
-       
-        try {
-            this.container.set(feed);
-            this.container.set(intEntry);
-            this.container.commit();
-        } catch (Exception e) {
-            LOG
-                    .error("Error occured on persisting changes -- rollback changes");
-            this.container.rollback();
-            throw new StorageException("Can not persist changes -- "
-                    + e.getMessage(), e);
-        }
-        if (LOG.isInfoEnabled())
-            LOG.info("Stored Entry for entryID: " + entry.getId()
-                    + " -- feedID: " + entry.getFeedId());
-        return entry.getEntry();
-    }
-
-    private void setUpdated(ServerBaseEntry entry, DB4oEntry intEntry) {
-        if (entry.getUpdated().compareTo(intEntry.getEntry().getUpdated()) <= 0) {
-            if (LOG.isDebugEnabled())
-                LOG
-                        .debug("Set new UpdateTime to entry new entry time is less or equal the time of the stored entry -- old Entry: "
-                                + intEntry.getEntry().getUpdated()
-                                + "; new Entry: " + entry.getUpdated());
-            entry.setUpdated(new DateTime(System.currentTimeMillis(), entry
-                    .getUpdated().getTzShift()));
-        }
-
-    }
-
-    private void setUpdated(ServerBaseEntry entry,
-            BaseFeed<BaseFeed, BaseEntry> feed) {
-        if (entry.getUpdated() != null){
-            long timeInMilli = entry.getUpdated().getValue();
-            int tzShift = entry.getUpdated().getTzShift();
-            feed.setUpdated(new DateTime(timeInMilli, tzShift));
-        }
-        else{
-            int timezone = 0;
-            if(feed.getUpdated() != null){
-                 timezone = feed.getUpdated().getTzShift();
-            }
-            long timeInMilli = System.currentTimeMillis();
-            entry.setUpdated(new DateTime(timeInMilli,timezone));
-            feed.setUpdated(new DateTime(timeInMilli,timezone));
-        }
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#deleteEntry(org.apache.lucene.gdata.data.ServerBaseEntry)
-     */
-    public void deleteEntry(ServerBaseEntry entry) throws StorageException {
-        if (entry == null)
-            throw new StorageException("Can not delete entry -- is null");
-        if (entry.getFeedId() == null)
-            throw new StorageException(
-                    "can not delete entry -- feed id is null");
-        if (entry.getId() == null)
-            throw new StorageException("Can not delete entry -- id is null");
-        if (LOG.isDebugEnabled())
-            LOG.debug("delete entry for feed: " + entry.getFeedId()
-                    + " entry ID: " + entry.getId());
-        DB4oEntry persistentEntry = getInternalEntry(entry.getId());
-        // lock the entry to prevent concurrent access
-        createSemaphore(entry.getId());
-        refreshPersistentObject(persistentEntry);
-        if(persistentEntry.getVersion() != entry.getVersion())
-            throw new ModificationConflictException(
-                    "Current version does not match given version  -- currentVersion: "+persistentEntry.getVersion()+"; given Version: "+entry.getVersion() );
-        BaseFeed<BaseFeed, BaseEntry> feed = getFeedOnly(entry.getFeedId(),entry.getServiceType());
-        refreshPersistentObject(feed);
-        DateTime time = DateTime.now();
-        if (persistentEntry.getEntry().getUpdated() != null)
-            time.setTzShift(persistentEntry.getEntry().getUpdated().getTzShift());
-        feed.setUpdated(time);
-        try {
-            //delete the entry
-            this.container.delete(persistentEntry.getEntry());
-            this.container.delete(persistentEntry);
-            this.container.set(feed);
-            this.container.commit();
-            
-        } catch (Exception e) {
-            LOG
-                    .error("Error occured on persisting changes -- rollback changes");
-            this.container.rollback();
-            throw new StorageException("Can not persist changes -- "
-                    + e.getMessage(), e);
-        } finally {
-            releaseSemaphore(entry.getId());
-        }
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#updateEntry(org.apache.lucene.gdata.data.ServerBaseEntry)
-     */
-    public BaseEntry updateEntry(ServerBaseEntry entry) throws StorageException {
-        if (entry == null)
-            throw new StorageException("Can not update entry -- is null");
-        if (entry.getFeedId() == null)
-            throw new StorageException(
-                    "can not delete entry -- feed id is null");
-        if (entry.getId() == null)
-            throw new StorageException("Can not delete entry -- id is null");
-
-        DB4oEntry persistentEntry = getInternalEntry(entry.getId());
-        // lock the entry to prevent concurrent access
-        createSemaphore(entry.getId());
-        refreshPersistentObject(persistentEntry);
-        if(persistentEntry.getVersion() != entry.getVersion())
-            throw new ModificationConflictException(
-                    "Current version does not match given version  -- currentVersion: "+persistentEntry.getVersion()+"; given Version: "+entry.getVersion() );
-        
-        setUpdated(entry, persistentEntry);
-        BaseFeed<BaseFeed, BaseEntry> feed = getFeedOnly(entry.getFeedId(),entry.getServiceType());
-        refreshPersistentObject(feed);
-        BaseEntry retVal = entry.getEntry(); 
-        DB4oEntry newEntry = new DB4oEntry();
-        newEntry.setEntry(retVal);
-        newEntry.setUpdateTime(entry.getUpdated().getValue());
-        newEntry.setFeedId(feed.getId());
-        // increment Version
-        newEntry.setVersion((entry.getVersion())+1);
-
-        setUpdated(entry, feed);
-        try {
-            this.container.set(feed);
-            this.container.set(newEntry);
-            this.container.delete(persistentEntry.getEntry());
-            this.container.delete(persistentEntry);
-            this.container.commit();
-        } catch (Exception e) {
-            LOG
-                    .error("Error occured on persisting changes -- rollback changes");
-            this.container.rollback();
-            throw new StorageException("Can not persist changes -- "
-                    + e.getMessage(), e);
-        } finally {
-            releaseSemaphore(entry.getId());
-        }
-        return retVal;
-
-    }
-    
-
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#getFeed(org.apache.lucene.gdata.data.ServerBaseFeed)
-     */
-    @SuppressWarnings("unchecked")
-    public BaseFeed getFeed(ServerBaseFeed feed) throws StorageException {
-        if (feed.getId() == null)
-            throw new StorageException("can not get feed -- feed id is null");
-        if (feed.getStartIndex() < 1)
-            feed.setStartIndex(1);
-        if (feed.getItemsPerPage() < 0)
-            feed.setItemsPerPage(25);
-
-        if (LOG.isInfoEnabled())
-            LOG.info("Fetching feed for feedID: " + feed.getId()
-                    + "; start-index: " + feed.getStartIndex()
-                    + "; items per page: " + feed.getItemsPerPage());
-
-       BaseFeed<BaseFeed, BaseEntry> persistentFeed = getFeedOnly(feed.getId(),feed.getServiceType());
-       /*
-        * prevent previously added entries in long running storage instances
-        */
-       clearDynamicElements(persistentFeed);
-        Query query = this.container.query();
-        query.constrain(DB4oEntry.class);
-        query.descend("feedId").constrain(feed.getId()).equal();
-        query.descend("updateTime").orderDescending();
-
-        ObjectSet<DB4oEntry> set = query.execute();
-       
-        int size = set.size();
-        
-        if (size < feed.getStartIndex()) {
-            if (LOG.isDebugEnabled())
-                LOG.debug("no entries found for feed constrain -- feedID: "
-                        + feed.getId() + "; start-index: "
-                        + feed.getStartIndex() + "; items per page: "
-                        + feed.getItemsPerPage());
-            return persistentFeed;
-        }
-
-        int start = feed.getStartIndex() - 1;
-        int items = start + feed.getItemsPerPage();
-        if (items > size)
-            items = size;
-        
-        List<DB4oEntry> sublist = set.subList(start, items);
-        
-        for (DB4oEntry entry : sublist) {
-            persistentFeed.getEntries().add(clearDynamicElements(entry.getEntry()));
-        }
-        this.container.activate(persistentFeed,RENDER_ACTIVATION_DEPTH);
-        return persistentFeed;
-
-    }
-
-    @SuppressWarnings("unchecked")
-    private BaseFeed<BaseFeed, BaseEntry> getFeedOnly(final String feedId, final String serviceId)
-            throws StorageException {
-        if(!checkService(feedId,serviceId))
-            throw new StorageException();
-        Query query = this.container.query();
-        query.constrain(ServerBaseFeed.class);
-      
-        query.constrain(BaseFeed.class);
-
-        query.descend("id").constrain(feedId).equal();
-
-        ObjectSet set = query.execute();
-        if (set.size() > 1)
-            throw new StorageException("Query for feed id " + feedId
-                    + " returns more than one result");
-        if (set.hasNext())
-        return (BaseFeed<BaseFeed, BaseEntry>) set.next();
-        throw new ResourceNotFoundException("can not find feed for given feed id -- "
-                + feedId);
-
-    }
-    private boolean checkService(String feedId,String serviceId){
-        Query query = this.container.query();
-        query.constrain(ServerBaseFeed.class);
-        query.descend("feed").descend("id").constrain(feedId).equal();
-        query.descend("serviceType").constrain(serviceId).equal();
-        return query.execute().size() == 1;
-    }
-    private ObjectSet getEnriesForFeedID(String feedId) {
-        Query query = this.container.query();
-        query.constrain(DB4oEntry.class);
-        query.descend("feedId").constrain(feedId).equal();
-
-        return query.execute();
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#getEntry(org.apache.lucene.gdata.data.ServerBaseEntry)
-     */
-
-    public BaseEntry getEntry(ServerBaseEntry entry) throws StorageException {
-        if (entry == null)
-            throw new StorageException("can not retrieve entry -- is null");
-        if (entry.getId() == null)
-            throw new StorageException("can not retrieve entry -- id is null");
-        if (LOG.isInfoEnabled())
-            LOG.info("Retrieving entry for entryID: " + entry.getId());
-        DB4oEntry retval = getInternalEntry(entry.getId());
-        this.container.activate(retval.getEntry(),RENDER_ACTIVATION_DEPTH);
-        return clearDynamicElements(retval.getEntry());
-    }
-
-    @SuppressWarnings("unchecked")
-    private DB4oEntry getInternalEntry(String id) throws StorageException {
-        Query query = this.container.query();
-        query.constrain(DB4oEntry.class);
-        query.descend("entry").descend("id").constrain(id).equal();
-        ObjectSet<DB4oEntry> resultSet = query.execute();
-        if (resultSet.size() > 1)
-            throw new StorageException(
-                    "Entry query returned not a unique result");
-        if (resultSet.hasNext())
-            return resultSet.next();
-        throw new ResourceNotFoundException("no entry with entryID: " + id
-                + " stored -- query returned no result");
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#storeAccount(org.apache.lucene.gdata.data.GDataAccount)
-     */
-    public void storeAccount(GDataAccount account) throws StorageException {
-        if (account == null)
-            throw new StorageException("can not store account -- is null");
-        if (account.getName() == null)
-            throw new StorageException("can not store account -- name is null");
-        if (account.getPassword() == null)
-            throw new StorageException(
-                    "can not store account -- password is null");
-        try {
-            getAccount(account.getName());
-            throw new IllegalStateException("account with accountname: "
-                    + account.getName() + " already exists");
-        } catch (IllegalStateException e) {
-            throw new StorageException("Account already exists");
-        } catch (StorageException e) {
-            if (LOG.isDebugEnabled())
-                LOG
-                        .debug("checked account for existence -- does not exist -- store account");
-        }
-        try {
-            this.container.set(account);
-            this.container.commit();
-        } catch (Exception e) {
-            LOG
-                    .error("Error occured on persisting changes -- rollback changes");
-            this.container.rollback();
-            throw new StorageException("Can not persist changes -- "
-                    + e.getMessage(), e);
-        }
-        if (LOG.isInfoEnabled())
-            LOG.info("Stored account: " + account);
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#updateAccount(org.apache.lucene.gdata.data.GDataAccount)
-     */
-    public void updateAccount(GDataAccount account) throws StorageException {
-        if (account == null)
-            throw new StorageException("can not update account -- is null");
-        if (account.getName() == null)
-            throw new StorageException("can not update account -- name is null");
-        if (account.getPassword() == null)
-            throw new StorageException(
-                    "can not update account -- password is null");
-        GDataAccount persitentAccount = getAccount(account.getName());
-        refreshPersistentObject(persitentAccount);
-        try {
-            this.container.set(account);
-            this.container.delete(persitentAccount);
-            this.container.commit();
-        } catch (Exception e) {
-            LOG
-                    .error("Error occured on persisting changes -- rollback changes");
-            this.container.rollback();
-            throw new StorageException("Can not persist changes -- "
-                    + e.getMessage(), e);
-        }
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#deleteAccount(java.lang.String)
-     */
-    public void deleteAccount(String accountname) throws StorageException {
-        if (accountname == null)
-            throw new StorageException(
-                    "can not delete account -- account name is null");
-        GDataAccount account = this.getAccount(accountname);
-        refreshPersistentObject(account);
-        if (LOG.isInfoEnabled())
-            LOG.info("delete account -- account name: " + accountname);
-        try {
-            this.container.delete(account);
-            this.container.commit();
-        } catch (Exception e) {
-            LOG
-                    .error("Error occured on persisting changes -- rollback changes");
-            this.container.rollback();
-            throw new StorageException("Can not persist changes -- "
-                    + e.getMessage(), e);
-        }
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#storeFeed(org.apache.lucene.gdata.data.ServerBaseFeed,
-     *      java.lang.String)
-     */
-    public void storeFeed(ServerBaseFeed feed, String accountname)
-            throws StorageException {
-        if (feed == null)
-            throw new StorageException("Can not store feed -- is null");
-        if (feed.getId() == null)
-            throw new StorageException("Can not store feed -- id is null");
-        if(feed.getServiceType() == null)
-            throw new StorageException("Can not store feed -- service type is null");
-        if(accountname == null)
-            throw new StorageException("Account name is null");
-        Query query = this.container.query();
-        query.constrain(ServerBaseFeed.class);
-        query.descend("feed").descend("id").constrain(feed.getId()).equal();
-        ObjectSet set = query.execute();
-        if (set.hasNext())
-            throw new StorageException("feed with feedID " + feed.getId()
-                    + " is already stored");
-        GDataAccount account = getAccount(accountname);
-        refreshPersistentObject(account);
-        feed.setAccount(account);
-        /*
-         * service config not required in db4o storage.
-         * Entries/Feeds don't have to be build from xml
-         */
-        feed.setServiceConfig(null);
-        try {
-            this.container.set(feed);
-            this.container.commit();
-        } catch (Exception e) {
-            LOG
-                    .error("Error occured on persisting changes -- rollback changes");
-            this.container.rollback();
-            throw new StorageException("Can not persist changes -- "
-                    + e.getMessage(), e);
-        }
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#deleteFeed(java.lang.String)
-     */
-    public void deleteFeed(String feedId) throws StorageException {
-        if (feedId == null)
-            throw new StorageException("can not delete feed -- feed id is null");
-        Query query = this.container.query();
-        query.constrain(ServerBaseFeed.class);
-        query.descend("feed").descend("id").constrain(feedId).equal();
-        ObjectSet set = query.execute();
-        if (set.size() > 1)
-            throw new StorageException(
-                    "Feed query returned not a unique result");
-        if (set.size() == 0)
-            throw new StorageException("no feed with feedID: " + feedId
-                    + " stored -- query returned no result");
-
-        ServerBaseFeed feed = (ServerBaseFeed) set.next();
-        refreshPersistentObject(feed);
-        ObjectSet entrySet = getEnriesForFeedID(feed.getId());
-        try {
-            this.container.delete(feed);
-            this.container.delete(feed.getFeed());
-            for (Object object : entrySet) {
-                refreshPersistentObject(object);
-                this.container.delete(object);
-            }
-            
-            this.container.commit();
-        } catch (Exception e) {
-            LOG
-                    .error("Error occured on persisting changes -- rollback changes");
-            this.container.rollback();
-            throw new StorageException("Can not persist changes -- "
-                    + e.getMessage(), e);
-        }
-
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#updateFeed(org.apache.lucene.gdata.data.ServerBaseFeed,
-     *      java.lang.String)
-     */
-    @SuppressWarnings("unchecked")
-    public void updateFeed(ServerBaseFeed feed, String accountname)
-            throws StorageException {
-        if (feed == null)
-            throw new StorageException("Can not update feed -- is null");
-        if (feed.getId() == null)
-            throw new StorageException("Can not update feed -- id is null");
-        if(feed.getServiceType() == null)
-            throw new StorageException("Can not update feed -- service type is null");
-        if(accountname == null)
-            throw new StorageException("Account name is null");
-        GDataAccount account = getAccount(accountname);
-        Query query = this.container.query();
-        query.constrain(ServerBaseFeed.class);
-        query.descend("feed").descend("id").constrain(feed.getId());
-        ObjectSet<ServerBaseFeed> set=  query.execute();
-        if (set.size() > 1)
-            throw new StorageException("Query for feed id " + feed.getId()
-                    + " returns more than one result");
-        if (set.size() < 1)
-            throw new StorageException("can not find feed for given feed id -- "
-                + feed.getId());
-        ServerBaseFeed result = set.next();
-        refreshPersistentObject(result);
-        BaseFeed oldFeed = result.getFeed();
-        result.setAccount(account);
-        result.setFeed(feed.getFeed());
-        try {
-            this.container.delete(oldFeed);
-            this.container.set(result);
-            this.container.commit();
-        } catch (Exception e) {
-            LOG
-                    .error("Error occurred on persisting changes -- rollback changes");
-            this.container.rollback();
-            throw new StorageException("Can not persist changes -- "
-                    + e.getMessage(), e);
-        }
-        
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#getServiceForFeed(java.lang.String)
-     */
-    @SuppressWarnings("unchecked")
-    public String getServiceForFeed(final String feedId) throws StorageException {
-        if(feedId == null)
-            throw new StorageException("can not get Service for feed -- feed id is null");
-        if(LOG.isInfoEnabled())
-            LOG.info("Retrieving Service for feed -- feed id: "+feedId);
-        Query query = this.container.query();
-        query.constrain(ServerBaseFeed.class);
-        query.descend("feed").descend("id").constrain(feedId);
-        ObjectSet<ServerBaseFeed> feed =  query.execute();
-        if (feed.size() > 1)
-            throw new StorageException("Query for feed id " + feedId
-                    + " returns more than one result");
-        if (feed.size() < 1)
-            throw new StorageException("can not find feed for given feed id -- "
-                + feedId);
-        
-        ServerBaseFeed result = feed.next();
-        if(LOG.isInfoEnabled())
-            LOG.info("Retrieved Service for feed -- serviceType: "+result.getServiceType());
-        return result.getServiceType();
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#getAccount(java.lang.String)
-     */
-    public GDataAccount getAccount(String accountName) throws StorageException {
-        if (accountName == null)
-            throw new StorageException(
-                    "Can not get account -- account name is null");
-        if (LOG.isInfoEnabled())
-            LOG.info("Retrieving account for account name: " + accountName);
-        Query query = this.container.query();
-        query.constrain(GDataAccount.class);
-        query.descend("name").constrain(accountName).equal();
-        ObjectSet set = query.execute();
-        if (set.size() > 1)
-            throw new StorageException(
-                    "Account query returned not a unique result -- account name: "
-                            + accountName);
-        if (!set.hasNext())
-            throw new ResourceNotFoundException(
-                    "No such account stored -- query returned not result for account name: "
-                            + accountName);
-
-        return (GDataAccount) set.next();
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#close()
-     */
-    public void close() {
-        releaseAllSemaphore();
-        
-    }
-    
-   
-
-    
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#getAccountNameForFeedId(java.lang.String)
-     */
-    
-    public String getAccountNameForFeedId(String feedId)
-            throws StorageException {
-        if(feedId == null)
-            throw new StorageException("feed id is null");
-        GDataAccount account = getServerBaseFeed(feedId).getAccount();
-        if(account == null)
-            throw new IllegalStateException("No account stored with feed -- feedID: "+feedId);
-        
-        return account.getName();
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#getEntryLastModified(java.lang.String, java.lang.String)
-     */
-    public Long getEntryLastModified(String entryId, final String feedId)
-            throws StorageException {
-        if(entryId == null)
-            throw new StorageException("Entry ID is null");
-        return new Long(getInternalEntry(entryId).getUpdateTime());
-    }
-    
-    @SuppressWarnings("unchecked")
-    private ServerBaseFeed getServerBaseFeed(String feedId)throws StorageException{
-        Query query = this.container.query();
-        query.constrain(ServerBaseFeed.class);
-        query.descend("feed").descend("id").constrain(feedId);
-        ObjectSet<ServerBaseFeed> feed =  query.execute();
-        if (feed.size() > 1)
-            throw new StorageException("Query for feed id " + feedId
-                    + " returns more than one result");
-        if (feed.size() < 1)
-            throw new StorageException("can not find feed for given feed id -- "
-                + feedId);
-        return feed.next();
-    }
-    
-    /*
-     * !Caution! -- could instantiate a lot of objects if used with certain classes!!
-     * Refresh a persisted object with a depth of 100
-     * 
-     */
-    private void refreshPersistentObject(Object o){
-        this.container.ext().refresh(o,100);
-    }
-    
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#getFeedLastModified(java.lang.String)
-     */
-    public Long getFeedLastModified(String feedId) throws StorageException {
-        if(feedId == null)
-            throw new StorageException("can not get last modified -- id is null");
-        ServerBaseFeed feed = getServerBaseFeed(feedId);
-        return new Long(feed.getUpdated().getValue());
-     
-    }
-    
-    private BaseEntry clearDynamicElements(BaseEntry entry){
-        this.container.ext().refresh(entry.getLinks(), 2);
-        return entry;
-    }
-    private BaseFeed clearDynamicElements(BaseFeed feed){
-        this.container.ext().refresh(feed.getLinks(), 2);
-        feed.getEntries().clear();
-        return feed;
-    }
-    ObjectContainer getContainer(){
-        return this.container;
-    }
-
-    static class DB4oEntry {
-        private BaseEntry entry;
-        
-        private int version;
-
-        private String feedId;
-
-        private long updateTime;
-
-        /**
-         * @return Returns the entry.
-         */
-        protected BaseEntry getEntry() {
-            return this.entry;
-        }
-
-        /**
-         * @param entry
-         *            The entry to set.
-         */
-        protected void setEntry(BaseEntry entry) {
-            this.entry = entry;
-        }
-
-        /**
-         * @return Returns the feed.
-         */
-        protected String getFeedId() {
-            return this.feedId;
-        }
-
-        /**
-         * @param feed
-         *            The feed to set.
-         */
-        protected void setFeedId(String feed) {
-            this.feedId = feed;
-        }
-
-        /**
-         * @return Returns the updateTime.
-         */
-        protected long getUpdateTime() {
-            return this.updateTime;
-        }
-
-        /**
-         * @param updateTime
-         *            The updateTime to set.
-         */
-        protected void setUpdateTime(long updateTime) {
-            this.updateTime = updateTime;
-        }
-
-        /**
-         * @return Returns the version.
-         */
-        public int getVersion() {
-            return this.version;
-        }
-
-        /**
-         * @param version The version to set.
-         */
-        public void setVersion(int version) {
-            this.version = version;
-            if(this.entry != null)
-                this.entry.setVersionId(""+this.version);
-        }
-
-    }
-    
-    
-    
-    
-    
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/db4o/ObjectServerDecorator.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/db4o/ObjectServerDecorator.java
deleted file mode 100755
index 2430e7a..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/db4o/ObjectServerDecorator.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.storage.db4o;
-
-import java.lang.reflect.InvocationHandler;
-import java.lang.reflect.Method;
-import java.lang.reflect.Type;
-
-import com.db4o.Db4o;
-import com.db4o.ObjectServer;
-
-/**
- * @author Simon Willnauer
- *
- */
-public class ObjectServerDecorator implements InvocationHandler {
-    private final int port;
-    private final String user;
-    private final String password;
-    private final String host;
-    private Method openClient;
-    /**
-     * 
-     */
-    public ObjectServerDecorator(String user, String password, String host, int port) {
-        this.user = user;
-        this.password = password;
-        this.host = host;
-        this.port = port;
-        try {
-            this.openClient = ObjectServer.class.getMethod("openClient",new Class[]{});
-        } catch (Exception e) {
-         //ignore method is visible   
-            e.printStackTrace();
-        }
-    }
-
-    /**
-     * @see java.lang.reflect.InvocationHandler#invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
-     */
-    public Object invoke(Object arg0, Method arg1, Object[] arg2)
-            throws Throwable {
-        if(arg1.equals(this.openClient)){
-            return Db4o.openClient(this.host,this.port, this.user, this.password);
-        }
-        Class clazz = arg1.getReturnType();
-        
-        if(!clazz.isPrimitive())
-            return null;
-        if(clazz == Boolean.TYPE)
-            return false;
-        return 0;
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/db4o/package.html b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/db4o/package.html
deleted file mode 100755
index a0210c4..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/db4o/package.html
+++ /dev/null
@@ -1,10 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
-<html> 
-<head> 
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
-   <meta name="Author" content="Simon Willnauer"> 
-</head> 
-<body> 
-DB4o storage implementation  (needs third patry jar) <a href="http://www.db4o.com">DB4o Website</a>
-</body> 
-</html> 
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/ConcurrentStorageLock.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/ConcurrentStorageLock.java
deleted file mode 100755
index df89cef..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/ConcurrentStorageLock.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.storage.lucenestorage;
-
-/**
- * 
- * @author Simon Willnauer
- *
- */
-public interface ConcurrentStorageLock {
-    
-    /**
-     * @param key
-     * @return
-     */
-    public abstract boolean setLock(final String key);
-    /**
-     * @param key
-     * @return
-     */
-    public abstract boolean releaseLock(final String key);
-    /**
-     * @return
-     */
-    public abstract boolean releaseThreadLocks();
-    /**
-     * @param key
-     * @return
-     */
-    public abstract boolean isKeyLocked(final String key);
-    /**
-     * 
-     */
-    public abstract void close();
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/ModifiedEntryFilter.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/ModifiedEntryFilter.java
deleted file mode 100644
index e69de29..0000000
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/SingleHostConcurrentStorageLock.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/SingleHostConcurrentStorageLock.java
deleted file mode 100755
index 1f1f875..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/SingleHostConcurrentStorageLock.java
+++ /dev/null
@@ -1,176 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.storage.lucenestorage;
-
-import java.util.HashMap;
-import java.util.Map;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReentrantReadWriteLock;
-
-/**
- * @author Simon Willnauer
- *
- */
-public class SingleHostConcurrentStorageLock implements ConcurrentStorageLock {
-    private volatile static ConcurrentStorageLock INSTANCE = null;
-    private final Map<String,Thread> locks;
-    private final Map<Thread,String> threads;
-    private final ReentrantReadWriteLock synLock = new ReentrantReadWriteLock();
-    private final Lock readLock = this.synLock.readLock();
-    private final Lock writeLock = this.synLock.writeLock();
-    private final AtomicBoolean isClosed = new AtomicBoolean(false);
-    /**
-     * 
-     */
-    private SingleHostConcurrentStorageLock() {
-        super();
-        this.locks = new HashMap<String,Thread>(10);
-        this.threads = new HashMap<Thread,String>(10);
-    }
-    protected static synchronized ConcurrentStorageLock getConcurrentStorageLock(){
-        if(INSTANCE == null)
-            INSTANCE = new SingleHostConcurrentStorageLock();
-        return INSTANCE;
-    }
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.ConcurrentStorageLock#setLock(java.lang.String)
-     */
-    public boolean setLock(String key) {
-       this.writeLock.lock();
-       try{
-           if(this.isClosed.get())
-               throw new IllegalStateException("Lock has been closed");
-           Thread t = Thread.currentThread();
-           if(this.threads.containsKey(t))
-               throw new ConcurrencyException("one thread must not obtain more than one lock -- single thread can not modify more than one resource");
-           if(this.locks.containsKey(key)){
-               return false;
-           }
-           this.locks.put(key, t);
-           this.threads.put(t,key);
-           return true;
-           
-       }finally{
-           this.writeLock.unlock();
-       }
-        
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.ConcurrentStorageLock#releaseLock(java.lang.String)
-     */
-    public boolean releaseLock(String key) {
-        this.writeLock.lock();
-        try{
-            if(this.isClosed.get())
-                throw new IllegalStateException("Lock has been closed");
-            Thread t = Thread.currentThread();
-            if(!this.threads.containsKey(t))
-                return false;
-            
-            if(!this.locks.containsKey(key))
-                return false;
-            if(t != this.locks.get(key))
-                throw new ConcurrencyException("Illegal lock access -- current thread is not owner");
-            this.locks.remove(key);
-            this.threads.remove(t);
-            return true;
-            
-        }finally{
-            this.writeLock.unlock();
-        }
-        
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.ConcurrentStorageLock#releaseThreadLocks()
-     */
-    public boolean releaseThreadLocks() {
-        this.writeLock.lock();
-        try{
-            if(this.isClosed.get())
-                throw new IllegalStateException("Lock has been closed");
-            Thread t = Thread.currentThread();
-            if(!this.threads.containsKey(t))
-                return false;
-            String key = this.threads.get(t);
-            this.threads.remove(t);
-            if(!this.locks.containsKey(key))
-                return false;
-            this.locks.remove(key);
-            return true;
-            
-        }finally{
-            this.writeLock.unlock();
-        }
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.ConcurrentStorageLock#isKeyLocked(java.lang.String)
-     */
-    public boolean isKeyLocked(String key) {
-        this.readLock.lock();
-        try{
-            if(this.isClosed.get())
-                throw new IllegalStateException("Lock has been closed");
-           return this.locks.containsKey(key);
-        }finally{
-            this.readLock.unlock();
-        }
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.ConcurrentStorageLock#close()
-     */
-    public void close() {
-        this.writeLock.lock();
-        try{
-            if(this.isClosed.get())
-                throw new IllegalStateException("Lock has been closed");
-            this.isClosed.set(true);
-            this.locks.clear();
-            this.threads.clear();
-            INSTANCE = new SingleHostConcurrentStorageLock();
-        }finally{
-            this.writeLock.unlock();
-        }
-    }
-    
-    
-    protected void forceClear(){
-        this.writeLock.lock();
-        try{
-            if(this.isClosed.get())
-                throw new IllegalStateException("Lock has been closed");
-            this.locks.clear();
-            this.threads.clear();
-            
-        }finally{
-            this.writeLock.unlock();
-        }
-    }
-    static class ConcurrencyException extends RuntimeException{
-      
-        private static final long serialVersionUID = 6388236477729760962L;
-
-        ConcurrencyException(String message){
-            super(message);
-        }
-    }
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/StorageAccountWrapper.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/StorageAccountWrapper.java
deleted file mode 100644
index e721ccc..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/StorageAccountWrapper.java
+++ /dev/null
@@ -1,111 +0,0 @@
-package org.apache.lucene.gdata.storage.lucenestorage;
-
-import java.net.MalformedURLException;
-import java.net.URL;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.gdata.data.GDataAccount;
-
-/**
- * Wrapps a User Object.
- * The wrapper provides also a Lucene repesentation of the user;
- * User Objects will not be Buffered in the lucene storage component. Each User will be written imidialtely.
- * @author Simon Willnauer
- *
- */
-public class StorageAccountWrapper implements StorageWrapper{
-    private static final Log LOG = LogFactory.getLog(StorageAccountWrapper.class);
-    
-    /**
-     * Lucene field for the username
-     */
-    public static final String FIELD_ACCOUNTNAME = "accountName";
-    /**
-     * Lucene field for the password
-     */
-    public static final String FIELD_PASSWORD = "passwd";
-    /**
-     * Lucene field for the author name
-     */
-    public static final String FIELD_AUTHORNAME = "author";
-    /**
-     * Lucene field for the author mail address
-     */
-    public static final String FIELD_AUTHORMAIL = "authorMail";
-    /**
-     * Lucene field for the author link
-     */
-    public static final String FIELD_AUTHORHREF = "authorHref";
-    /**
-     * Lucene field fot the userroles
-     */
-    public static final String FIELD_ROLES = "userroles";
-    private final GDataAccount user;
-    /**
-     * @param user - the user to be wrapped
-     */
-    public StorageAccountWrapper(final GDataAccount user) {
-        if(user == null)
-            throw new IllegalArgumentException("user must not be null");
-        this.user = user;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageWrapper#getLuceneDocument()
-     */
-    public Document getLuceneDocument() {
-        Document doc = new Document();
-        
-        doc.add(new Field(FIELD_ACCOUNTNAME,this.user.getName(),Field.Store.YES,Field.Index.UN_TOKENIZED));
-        doc.add(new Field(FIELD_PASSWORD,this.user.getPassword()==null?"":this.user.getPassword(),Field.Store.YES,Field.Index.NO));
-        doc.add(new Field(FIELD_AUTHORNAME,this.user.getAuthorname()==null?"":this.user.getAuthorname(),Field.Store.YES,Field.Index.NO));
-        doc.add(new Field(FIELD_AUTHORMAIL,this.user.getAuthorMail()==null?"":this.user.getAuthorMail(),Field.Store.YES,Field.Index.NO));
-        doc.add(new Field(FIELD_AUTHORHREF,this.user.getAuthorLink()==null?"":this.user.getAuthorLink().toString(),Field.Store.YES,Field.Index.NO));
-        doc.add(new Field(FIELD_ROLES, Integer.toString(this.user.getRolesAsInt()),Field.Store.YES,Field.Index.NO)); 
-       
-        return doc;
-    }
-   
-   
-    
-    
-    /**
-     * @param doc - a lucene document representation of an user
-     * @return - the user to build from the document. or <code>null</code> if the document is <code>null</code>
-     */
-    public static GDataAccount buildEntity(final Document doc){
-        if(doc == null)
-            return null;
-        
-        GDataAccount user = new GDataAccount();
-        user.setName(doc.get(FIELD_ACCOUNTNAME));
-        user.setPassword(doc.get(FIELD_PASSWORD));
-        user.setAuthorname(doc.get(FIELD_AUTHORNAME));
-        user.setAuthorMail(doc.get(FIELD_AUTHORMAIL));
-        try{
-        user.setRolesAsInt(Integer.parseInt(doc.get(FIELD_ROLES)));
-        }catch (NumberFormatException e) {
-            LOG.info("Can't parse userroles: "+user.getName()+" throws NumberFormatException. -- skipping --",e);
-        }
-        try {
-            if(doc.get(FIELD_AUTHORHREF)!= null)
-                user.setAuthorLink(new URL(doc.get(FIELD_AUTHORHREF)));
-        } catch (MalformedURLException e) {
-            LOG.info("SPECIFIED URL for user: "+user.getName()+" throws MalformedURLException. -- skipping --",e);
-        }
-        return user;
-    }
-    
-   
-
-    /**
-     * @return - the wrapped user
-     */
-    public GDataAccount getUser() {
-        return this.user;
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/StorageBuffer.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/StorageBuffer.java
deleted file mode 100644
index ceaf4de..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/StorageBuffer.java
+++ /dev/null
@@ -1,359 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-
-package org.apache.lucene.gdata.storage.lucenestorage;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.Map.Entry;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReadWriteLock;
-import java.util.concurrent.locks.ReentrantReadWriteLock;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper.StorageOperation;
-import org.apache.lucene.gdata.utils.ModifiedEntryFilter;
-
-import com.google.gdata.data.BaseEntry;
-import com.google.gdata.data.ExtensionProfile;
-import com.google.gdata.data.Link;
-
-/**
- * The StorageBuffer is used to buffer incoming updates, deletes and inserts to
- * the storage. The storage uses an lucene index to store the enries. As
- * modifying the index all the time an altering request comes in is not
- * efficent. The entries will be added to the buffer to be available for
- * incoming storage queries. If the loadfactor for the
- * {@link org.apache.lucene.gdata.storage.lucenestorage.StorageModifier} is
- * reached the modifier will perform a batch update on the index. Each entry
- * will be associated with a feed id inside a associative datastructure to
- * return a requested entry efficiently.
- * <p>
- * This implementation uses {@link java.util.concurrent.locks.ReadWriteLock}.
- * The read lock may be held simultaneously by multiple reader threads, so long
- * as there are no writers. The write lock is exclusive.
- * </p>
- * <p>
- * The entry and feed ID's must not be a composite key. The entry and feed ID
- * must be unique.
- * </p>
- * 
- * @see java.util.concurrent.locks.ReentrantReadWriteLock
- * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier
- * @see org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController
- * 
- * @author Simon Willnauer
- * 
- */
-public class StorageBuffer {
-    private static final Log LOG = LogFactory.getLog(StorageBuffer.class);
-
-    private final Map<String, Map<String, StorageEntryWrapper>> bufferMap;
-
-    private final Map<String, Long> modifiyMap;
-
-    private final List<String> excludeList;
-
-    private final ReadWriteLock lock = new ReentrantReadWriteLock(true);
-
-    private final Lock readLock = this.lock.readLock();
-
-    private final Lock writeLock = this.lock.writeLock();
-
-    private final int bufferSize;
-
-    protected final static int DEFAULT_BUFFER_COUNT = 10;
-
-    /**
-     * Constructs a new StorageBuffer.
-     * <p>
-     * The expectedBufferCount sould be higher than the maximum of entries added
-     * to the buffer, resizing the buffer is very efficient. For detailed
-     * infomation {@link HashMap} as this is used inside the buffer
-     * </p>
-     * 
-     * @param expectedBufferCount -
-     *            the expected size of the buffer
-     * 
-     */
-    protected StorageBuffer(final int expectedBufferCount) {
-        this.bufferSize = expectedBufferCount < DEFAULT_BUFFER_COUNT ? DEFAULT_BUFFER_COUNT
-                : expectedBufferCount;
-        this.bufferMap = new HashMap<String, Map<String, StorageEntryWrapper>>(
-                this.bufferSize);
-        this.excludeList = new ArrayList<String>(this.bufferSize);
-        this.modifiyMap = new HashMap<String, Long>(this.bufferSize);
-    }
-
-    /**
-     * Adds a {@link StorageEntryWrapper} to the buffer. If a wrapper
-     * representing the same entry are already in the buffer the wrapper will be
-     * replaced.
-     * <p>
-     * This method does ignore already delted entries. This should before the
-     * entry is added to the buffer.
-     * </p>
-     * 
-     * @param wrapper -
-     *            the wrapper to buffer
-     */
-    public void addEntry(final StorageEntryWrapper wrapper) {
-        this.writeLock.lock();
-        try {
-            if (LOG.isInfoEnabled())
-                LOG.info(" Buffering wrapper - " + wrapper.getOperation()
-                        + " ID: " + wrapper.getEntryId() + " FeedID: "
-                        + wrapper.getFeedId());
-            if (wrapper.getOperation().equals(StorageOperation.DELETE))
-                return;
-            String feedId = wrapper.getFeedId();
-            if (this.bufferMap.containsKey(feedId))
-                this.bufferMap.get(feedId).put(wrapper.getEntryId(), wrapper);
-            else {
-                Map<String, StorageEntryWrapper> newFeedMap = new HashMap<String, StorageEntryWrapper>(
-                        20);
-                newFeedMap.put(wrapper.getEntryId(), wrapper);
-                this.bufferMap.put(feedId, newFeedMap);
-
-            }
-            addLastModified(wrapper.getFeedId(), wrapper.getTimestamp());
-            /*
-             * add to exclude from searches doc will be available via the buffer
-             * if the entry is not already in the buffer
-             */
-            if (!this.excludeList.contains(wrapper.getEntryId()))
-                this.excludeList.add(wrapper.getEntryId());
-        } finally {
-            this.writeLock.unlock();
-        }
-    }
-
-    private void addLastModified(final String feedId, Long timestamp) {
-        this.writeLock.lock();
-        try {
-            if (this.modifiyMap.containsKey(feedId))
-                this.modifiyMap.remove(feedId);
-            this.modifiyMap.put(feedId, timestamp);
-        } finally {
-            this.writeLock.unlock();
-        }
-
-    }
-
-    /**
-     * the timestamp of the last modification for the given feed id
-     * 
-     * @param feedId -
-     *            feed id
-     * @return timestamp
-     */
-    protected Long getFeedLastModified(final String feedId) {
-        this.readLock.lock();
-        try {
-            return this.modifiyMap.get(feedId);
-        } finally {
-            this.readLock.unlock();
-        }
-    }
-
-    protected Set<Entry<String, Long>> getLastModified() {
-        return this.modifiyMap.entrySet();
-    }
-
-    /**
-     * Returns all entries for the given feed id sorted by the update timestamp
-     * desc.
-     * 
-     * @param feedId -
-     *            the feed id
-     * @return a {@link List} of all {@link StorageEntryWrapper} object buffered
-     *         in this buffer or an empty list if not entry has been buffered
-     *         for the given feed
-     */
-    public List<StorageEntryWrapper> getSortedEntries(String feedId) {
-        this.readLock.lock();
-        try {
-            if (!this.bufferMap.containsKey(feedId))
-                return null;
-            Map<String, StorageEntryWrapper> tempMap = this.bufferMap
-                    .get(feedId);
-            if (tempMap == null)
-                return null;
-            Collection<StorageEntryWrapper> col = tempMap.values();
-            List<StorageEntryWrapper> returnList = new ArrayList<StorageEntryWrapper>(
-                    col);
-            Collections.sort(returnList);
-            return returnList;
-
-        } finally {
-            this.readLock.unlock();
-        }
-
-    }
-
-    /**
-     * Adds a deleted entry to the buffer.
-     * 
-     * @param entryId -
-     *            the deleted entry id
-     * @param feedId -
-     *            the feed of the entry
-     */
-    public void addDeleted(final String entryId, final String feedId) {
-        this.writeLock.lock();
-        try {
-            Map<String, StorageEntryWrapper> tempMap = this.bufferMap
-                    .get(feedId);
-            if (tempMap != null) {
-                tempMap.remove(entryId);
-                this.addLastModified(feedId, new Long(System
-                        .currentTimeMillis()));
-            }
-            /*
-             * add to exclude from searches
-             */
-            if (!this.excludeList.contains(entryId))
-                this.excludeList.add(entryId);
-        } finally {
-
-            this.writeLock.unlock();
-
-        }
-
-    }
-
-    /**
-     * Returns an entry for the given entry id in the feed context spezified by
-     * the feed id;
-     * 
-     * @param entryId -
-     *            the id of the entry to return
-     * @param feedId -
-     *            the feed containing the entry
-     * @return - the entry or <code>null</code> if the corresponding entry is
-     *         not in the buffer.
-     */
-    public StorageEntryWrapper getEntry(final String entryId,
-            final String feedId) {
-        this.readLock.lock();
-        try {
-
-            if (this.bufferMap.containsKey(feedId))
-                return this.bufferMap.get(feedId).get(entryId);
-            return null;
-
-        } finally {
-            this.readLock.unlock();
-        }
-    }
-
-    /**
-     * The buffer contains updated and delete entries. These entries are already
-     * available in the lucene index but should not be found during search.
-     * 
-     * <p>
-     * This list contains all entries should not be found by the index searcher.
-     * This method creates a copy of the current list to prevent concurrent
-     * modification exceptions while iteration over the collection.
-     * </p>
-     * 
-     * 
-     * @see ModifiedEntryFilter
-     * @return - a String array of entries to be omitted from a lucene index
-     *         search
-     */
-    public String[] getExculdList() {
-        this.readLock.lock();
-        try {
-            return this.excludeList
-                    .toArray(new String[this.excludeList.size()]);
-        } finally {
-            this.readLock.unlock();
-        }
-    }
-
-    // not synchronized --> see close()
-    private void clearBuffer() {
-
-        this.bufferMap.clear();
-        this.excludeList.clear();
-        this.modifiyMap.clear();
-
-    }
-
-    /**
-     * clears the buffer -
-     */
-    public void close() {
-        this.writeLock.lock();
-        try {
-            clearBuffer();
-        } finally {
-            this.writeLock.unlock();
-        }
-
-    }
-
-    static class BufferableEntry extends BaseEntry {
-
-        /**
-         * 
-         */
-        @SuppressWarnings("unchecked")
-        public BufferableEntry() {
-            super();
-            this.links = new LinkedList<Link>();
-        }
-
-        /**
-         * @param arg0
-         */
-        @SuppressWarnings("unchecked")
-        public BufferableEntry(BaseEntry arg0) {
-            super(arg0);
-            if (this.links.size() > 0) {
-                LinkedList list = new LinkedList<Link>();
-                list.addAll(this.links);
-                this.links = list;
-            } else
-                this.links = new LinkedList<Link>();
-        }
-
-        /**
-         * @see com.google.gdata.data.BaseEntry#declareExtensions(com.google.gdata.data.ExtensionProfile)
-         */
-        @Override
-        public void declareExtensions(ExtensionProfile arg0) {
-            //
-        }
-
-    }
-
-    /**
-     * @return Returns the bufferSize.
-     */
-    public int getBufferSize() {
-        return this.bufferSize;
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/StorageCoreController.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/StorageCoreController.java
deleted file mode 100644
index 9c10004..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/StorageCoreController.java
+++ /dev/null
@@ -1,610 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.storage.lucenestorage;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.locks.Condition;
-import java.util.concurrent.locks.ReentrantLock;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.analysis.standard.StandardAnalyzer;
-import org.apache.lucene.gdata.data.GDataAccount;
-import org.apache.lucene.gdata.server.registry.Component;
-import org.apache.lucene.gdata.server.registry.ComponentType;
-import org.apache.lucene.gdata.server.registry.configuration.Requiered;
-import org.apache.lucene.gdata.storage.IDGenerator;
-import org.apache.lucene.gdata.storage.Storage;
-import org.apache.lucene.gdata.storage.StorageController;
-import org.apache.lucene.gdata.storage.StorageException;
-import org.apache.lucene.gdata.storage.lucenestorage.recover.RecoverController;
-import org.apache.lucene.gdata.storage.lucenestorage.recover.RecoverException;
-import org.apache.lucene.gdata.utils.ReferenceCounter;
-import org.apache.lucene.index.IndexModifier;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.FSDirectory;
-
-/**
- *  
- * 
- * @author Simon Willnauer
- * 
- */
-@Component(componentType = ComponentType.STORAGECONTROLLER)
-public class StorageCoreController implements StorageController {
-    
-    protected static final Log LOG = LogFactory
-            .getLog(StorageCoreController.class);
-
-    private IndexSearcher searcher;
-
-    private Directory storageDir;
-
-    private StorageModifier modifier;
-
-    private ReferenceCounter<StorageQuery> storageQuery;
-
-    private StorageBuffer currentBuffer;
-    private final AtomicBoolean isClosed = new AtomicBoolean(false);
-    private final ReentrantLock storageControllerLock = new ReentrantLock();
-    private final Condition closeCondition;
-
-    private static final int DEFAULT_STORAGE_BUFFER_SIZE = 3;
-
-    private static final int DEFAULT_STORAGE_PERSIST_FACTOR = 3;
-    
-    private static final String RECOVERDIRECTORY = "recover";
-
-    private static final String STORAGELOG = ".lucenestorage";
-
-    private IDGenerator idGenerator;
-
-    private final ConcurrentStorageLock storageLock;
-    /*
-     *properties set by configuration file e.g. Registry
-     */
-    private int indexOptimizeInterval;
-    
-    private String storageDirectory; 
- 
-    private boolean keepRecoveredFiles; 
- 
-    private boolean recover; 
-    
-    private int storageBufferSize;
-
-    private int storagePersistFactor;
-    
-    private RecoverController recoverController;
-    /**
-     * @see org.apache.lucene.gdata.server.registry.ServerComponent#initialize()
-     */
-    public void initialize() {
-        synchronized (StorageCoreController.class) {
-         
-            try {
-                this.idGenerator = new IDGenerator(10);
-            } catch (Exception e) {
-                throw new StorageException("Can't create ID Generator", e);
-            }
-
-            boolean createNewStorage = false;
-          
-            if (this.storageDir == null) {
-
-                
-                File storeDir = new File(this.storageDirectory);
-                File storageLog = new File(storeDir.getAbsolutePath()
-                        + System.getProperty("file.separator") + STORAGELOG);
-                try {
-                    if (storeDir.isDirectory() && !storageLog.exists()) {
-
-                        if (createLuceneStorageLog(storeDir)) {
-                            this.storageDir = FSDirectory.getDirectory(
-                                    storeDir, true);
-                            createNewStorage = true;
-                        } else
-                            throw new StorageException(
-                                    "could not create storage lock file in "
-                                            + this.storageDirectory);
-
-                    } else
-                        this.storageDir = FSDirectory.getDirectory(storeDir,
-                                false);
-                } catch (IOException e) {
-                    storageLog.delete();
-                    throw new StorageException(e);
-                }
-                
-                this.storageBufferSize = this.storageBufferSize < DEFAULT_STORAGE_BUFFER_SIZE ? DEFAULT_STORAGE_BUFFER_SIZE
-                        : this.storageBufferSize;
-                this.storagePersistFactor = this.storagePersistFactor < DEFAULT_STORAGE_PERSIST_FACTOR ? DEFAULT_STORAGE_PERSIST_FACTOR
-                        : this.storagePersistFactor;
-
-            }else
-                createNewStorage = true;
-               
-
-            this.currentBuffer = new StorageBuffer(this.storageBufferSize);
-            try{
-            this.modifier = createStorageModifier(createNewStorage);
-            this.searcher = new IndexSearcher(this.storageDir);
-            }catch (Exception e) {
-               throw new StorageException("Can not create Searcher/Modifier -- "+e.getMessage(),e);
-            }
-           
-            
-            if(createNewStorage)
-                createAdminAccount();
-            if(!this.recover)
-                return;
-            try{
-            tryRecover();
-            }catch (Exception e) {
-                LOG.fatal("Recovering failed",e);
-                throw new StorageException("Recovering failed -- "+e.getMessage(),e); 
-            }
-            
-            this.recoverController = createRecoverController(false,false);
-            try{
-            this.recoverController.initialize();
-            }catch (Exception e) {
-                LOG.fatal("Can not initialize recover controller",e);
-                throw new StorageException("Can not initialize recover controller -- "+e.getMessage(),e);
-            }
-
-        }
-    }
-    /*
-     * reads the remaining recover files to store the failed entries
-     */
-    private void tryRecover() throws IOException, RecoverException{
-        if(!this.recover)
-            return;
-        LOG.info("try to recover files if there are any");
-        this.recoverController = createRecoverController(true,false);
-        this.recoverController.initialize();
-        this.recoverController.recoverEntries(this.modifier);
-        this.recoverController.destroy();
-    }
-    
-    private RecoverController createRecoverController(boolean doRecover, boolean keepfiles){
-        String recoverDirectory = null;
-        if(this.storageDirectory.endsWith("/") || this.storageDirectory.endsWith("\\"))
-            recoverDirectory = this.storageDirectory.substring(0,this.storageDirectory.length()-1)+System.getProperty("file.separator")+RECOVERDIRECTORY;
-        else
-            recoverDirectory = this.storageDirectory+System.getProperty("file.separator")+RECOVERDIRECTORY;
-        File recoverDirectoryFile = new File(recoverDirectory);
-       return new RecoverController(recoverDirectoryFile,doRecover,keepfiles);
-    }
-    /**
-     * Creates a new <tt>StoragCoreController</tt>
-     */
-    public StorageCoreController() {
-        this.closeCondition = this.storageControllerLock.newCondition();
-        this.storageLock = SingleHostConcurrentStorageLock.getConcurrentStorageLock();
-
-    }
-
-    private StorageModifier createStorageModifier(boolean create)
-            throws IOException {
-        IndexModifier indexModifier = new IndexModifier(this.storageDir,
-                new StandardAnalyzer(), create);
-        return new StorageModifier(this, indexModifier, this.currentBuffer,
-                this.storagePersistFactor, this.indexOptimizeInterval);
-    }
-
-    /**
-     * returns the current storage modifier
-     * 
-     * @return - the current storage modifier
-     */
-    protected StorageModifier getStorageModifier() {
-        return this.modifier;
-    }
-
-    /**
-     * returns a <tt>StorageQuery</tt> to query the storage index. The
-     * returned object is a reference counter to keep track of the references to
-     * the <tt>StorageQuery</tt>. The reference is already incremented before
-     * returned from this method.
-     * <p>
-     * if the reference counter has no remaining references the resource e.g.
-     * the <tt>StorageQuery</tt> will be closed. This ensures that a
-     * <tt>StorageQuery</tt> instance will be around as long as needed and
-     * the resources will be released. The reference counter should be
-     * decremented by clients after finished using the query instance.
-     * </p>
-     * 
-     * @return a {@link ReferenceCounter} instance holding the StorageQuery as a
-     *         resource.
-     * 
-     */
-    protected ReferenceCounter<StorageQuery> getStorageQuery() {
-    	if(this.isClosed.get())
-    		throw new IllegalStateException("StorageController is already closed -- server is shutting down");
-        this.storageControllerLock.lock();
-        try{
-        	if(this.isClosed.get())
-        		throw new IllegalStateException("StorageController is already closed -- server is shutting down");
-            if (this.storageQuery == null) {
-                this.storageQuery = getNewStorageQueryHolder(new StorageQuery(
-                        this.currentBuffer, this.searcher));
-                if (LOG.isInfoEnabled())
-                    LOG.info("Release new StorageQuery");
-            }
-            this.storageQuery.increamentReference();
-            return this.storageQuery;
-        }finally{
-            try{
-        	this.closeCondition.signalAll();
-            }catch (Throwable e) {/**/}
-        	this.storageControllerLock.unlock();
-        }
-    }
-
-    private ReferenceCounter<StorageQuery> getNewStorageQueryHolder(
-            final StorageQuery query) {
-        ReferenceCounter<StorageQuery> holder = new ReferenceCounter<StorageQuery>(
-                query) {
-            @Override
-			public void close() {
-                try {
-                    if (LOG.isInfoEnabled())
-                        LOG
-                                .info("close StorageQuery -- zero references remaining");
-                    this.resource.close();
-                } catch (IOException e) {
-                    LOG.warn("Error during close call on StorageQuery"
-                            + e.getMessage(), e);
-                }
-            }
-        };
-        holder.increamentReference();
-        return holder;
-    }
-
-    /**
-     * Forces the controller to register a new <tt>StorageQuery</tt> instance.
-     * This method will be called after an index has been modified to make the
-     * changes available for searching.
-     * 
-     * @throws IOException -
-     *             if an IO exception occurs
-     */
-    protected void registerNewStorageQuery() throws IOException {
-    	if(this.isClosed.get())
-    		throw new IllegalStateException("StorageController is already closed -- server is shutting down");
-        this.storageControllerLock.lock();
-        try{
-        	if(this.isClosed.get())
-        		throw new IllegalStateException("StorageController is already closed -- server is shutting down");
-	        if (LOG.isInfoEnabled())
-	            LOG.info("new StorageQuery requested -- create new storage buffer");
-        
-            if (this.storageQuery != null)
-                this.storageQuery.decrementRef();
-            this.searcher = new IndexSearcher(this.storageDir);
-            this.storageQuery = null;
-            this.currentBuffer = new StorageBuffer(this.storageBufferSize);
-
-        }finally{
-            try{
-                this.closeCondition.signalAll();
-                }catch (Throwable e) {/**/}
-        	this.storageControllerLock.unlock();
-        }
-
-    }
-
-    /**
-     * Creates a new StorageBuffer
-     * 
-     * @return the new StorageBuffer
-     */
-    protected StorageBuffer releaseNewStorageBuffer() {
-    	if(this.isClosed.get())
-    		throw new IllegalStateException("StorageController is already closed -- server is shutting down");
-        this.storageControllerLock.lock();
-        try{
-        	if(this.isClosed.get())
-        		throw new IllegalStateException("StorageController is already closed -- server is shutting down");
-            return this.currentBuffer;
-        }finally{
-            try{
-        	this.closeCondition.signalAll();
-            }catch (Throwable e) {/**/}
-        	this.storageControllerLock.unlock();
-        }
-    }
-
-    /**
-     * Creates a new IndexModifier on the storage index
-     * 
-     * @return - a new modifier
-     * @throws IOException -
-     *             if an IO exception occurs
-     */
-    protected IndexModifier createIndexModifier() throws IOException {
-    	if(this.isClosed.get())
-    		throw new IllegalStateException("StorageController is already closed -- server is shutting down");
-        this.storageControllerLock.lock();
-        try{
-        	if(this.isClosed.get())
-        		throw new IllegalStateException("StorageController is already closed -- server is shutting down");
-	        if (LOG.isInfoEnabled())
-	            LOG.info("new IndexModifier created - release to StorageModifier");
-        
-            return new IndexModifier(this.storageDir, new StandardAnalyzer(),
-                    false);
-        }finally{
-            try{
-                this.closeCondition.signalAll();
-                }catch (Throwable e) {/**/}
-        	this.storageControllerLock.unlock();
-        }
-    }
-
-    private void close() throws IOException {
-    	if(this.isClosed.get())
-    		throw new IllegalStateException("StorageController is already closed -- server is shutting down");
-    	
-        this.storageControllerLock.lock();
-        try{
-        	if(this.isClosed.get())
-        		throw new IllegalStateException("StorageController is already closed -- server is shutting down");
-        	this.isClosed.set(true);
-        	while(this.storageControllerLock.getQueueLength()>0)
-        		try{
-        		this.closeCondition.await();
-        		}catch (Exception e) {
-					//
-				}
-            if (LOG.isInfoEnabled())
-                LOG.info("StorageController has been closed -- server is shutting down -- release all resources");
-            if (this.storageQuery != null)
-                this.storageQuery.decrementRef();
-            if(this.recoverController != null)
-                this.recoverController.destroy();
-            this.storageLock.close();
-            this.modifier.close();
-            this.idGenerator.stopIDGenerator();
-		}finally{
-        	this.storageControllerLock.unlock();
-        }
-    }
-
-
-    /**
-     * Forces the StorageModifier to write all buffered changes.
-     * 
-     * @throws IOException -
-     *             if an IO exception occurs
-     * 
-     */
-    public void forceWrite() throws IOException {
-    	if(this.isClosed.get())
-    		throw new IllegalStateException("StorageController is already closed -- server is shutting down");
-        this.modifier.forceWrite();
-    }
-
-    private boolean createLuceneStorageLog(File directory)
-            throws IOException {
-        if (directory.isDirectory() && !directory.exists()) {
-            if(!directory.createNewFile())
-                throw new StorageException("Can not create directory -- "+directory);
-        }
-        File file = new File(directory.getAbsolutePath()
-                + System.getProperty("file.separator") + STORAGELOG);
-        return file.createNewFile();
-
-    }
-
-    /**
-     * Creates a unique ID to store as an id for
-     * {@link org.apache.lucene.gdata.data.ServerBaseEntry} instances
-     * 
-     * @return - a unique id
-     * @throws StorageException -
-     *             if no id can be released
-     */
-    public synchronized String releaseId() {
-        try {
-            return this.idGenerator.getUID();
-        } catch (InterruptedException e) {
-            throw new StorageException("Can't release new ID", e);
-        }
-
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.StorageController#destroy()
-     */
-    public void destroy() {
-        try {
-            close();
-        } catch (Exception e) {
-            LOG.error("Closing StorageCoreController failed -- "
-                    + e.getMessage(), e);
-        }
-    }
-
-    /**
-     * 
-     * @return - the lucene directory used as a storage
-     */
-    protected Directory getDirectory() {
-        return this.storageDir;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.StorageController#getStorage()
-     */
-    public Storage getStorage() throws StorageException {
-        try {
-            return new StorageImplementation();
-        } catch (StorageException e) {
-            StorageException ex = new StorageException(
-                    "Can't create Storage instance -- " + e.getMessage(), e);
-            ex.setStackTrace(e.getStackTrace());
-            throw ex;
-
-        }
-    }
-
-
-
-
-    
-    
-    private void createAdminAccount() throws StorageException{
-        GDataAccount adminAccount = GDataAccount.createAdminAccount();
-        StorageAccountWrapper wrapper = new StorageAccountWrapper(adminAccount);
-        this.getStorageModifier().createAccount(wrapper);
-    }
-    
-    protected ConcurrentStorageLock getLock(){
-        return this.storageLock;
-    }
-
-    
-    /**
-     * The size of the <tt>StorageBuffer</tt>.
-     * 
-     * @return - storage buffer size
-     */
-    public int getBufferSize() {
-        return this.storageBufferSize;
-    }
-
-    /**
-     * The size of the <tt>StorageBuffer</tt>. This size should be at least
-     * as big as the persist factor to prevent the <tt>StorageBuffer</tt> from
-     * resizing
-     * 
-     * @param storageBufferSize
-     */
-    @Requiered
-    public void setBufferSize(int storageBufferSize) {
-        this.storageBufferSize = storageBufferSize;
-    }
-
-    /**
-     * An integer value after how many changes to the StorageModifier the
-     * buffered changes will be persisted / written to the index
-     * 
-     * @return - the persist factor
-     */
-    public int getPersistFactor() {
-        return this.storagePersistFactor;
-    }
-
-    /**
-     * @param storagePersistFactor
-     */
-    @Requiered
-    public void setPersistFactor(int storagePersistFactor) {
-        this.storagePersistFactor = storagePersistFactor;
-    }
-
-
-    /**
-     * @return Returns the indexOptimizeInterval.
-     */
-    public int getIndexOptimizeInterval() {
-        return this.indexOptimizeInterval;
-    }
-
-
-    /**
-     * @param indexOptimizeInterval The indexOptimizeInterval to set.
-     */
-    @Requiered
-    public void setOptimizeInterval(int indexOptimizeInterval) {
-        this.indexOptimizeInterval = indexOptimizeInterval;
-    }
-
-
-    /**
-     * @return Returns the keepRecoveredFiles.
-     */
-    public boolean isKeepRecoveredFiles() {
-        return this.keepRecoveredFiles;
-    }
-
-
-    /**
-     * @param keepRecoveredFiles The keepRecoveredFiles to set.
-     */
-    @Requiered
-    public void setKeepRecoveredFiles(boolean keepRecoveredFiles) {
-        this.keepRecoveredFiles = keepRecoveredFiles;
-    }
-
-
-
-    /**
-     * @return Returns the recover.
-     */
-    public boolean isRecover() {
-        return this.recover;
-    }
-
-
-    /**
-     * @param recover The recover to set.
-     */
-    @Requiered
-    public void setRecover(boolean recover) {
-        this.recover = recover;
-    }
-
-
-    /**
-     * @param storageDir The storageDir to set.
-     */
-   
-    public void setStorageDir(Directory storageDir) {
-        this.storageDir = storageDir;
-    }
-
-
-    /**
-     * @param storageDirectory The storageDirectory to set.
-     */
-    @Requiered
-    public void setDirectory(String storageDirectory) {
-        this.storageDirectory = storageDirectory;
-    }
-    
-    protected void writeRecoverEntry(StorageEntryWrapper wrapper) throws RecoverException{
-        if(this.recoverController!= null &&!this.recoverController.isRecovering() )
-            this.recoverController.storageModified(wrapper);
-    }
-    protected void registerNewRecoverWriter() throws IOException {
-        if(this.recoverController == null || this.recoverController.isRecovering())
-            return;
-        this.recoverController.destroy();
-        this.recoverController = createRecoverController(false,false);
-        this.recoverController.initialize();
-            
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/StorageEntryWrapper.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/StorageEntryWrapper.java
deleted file mode 100644
index 31962e4..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/StorageEntryWrapper.java
+++ /dev/null
@@ -1,249 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-
-package org.apache.lucene.gdata.storage.lucenestorage;
-
-import java.io.IOException;
-import java.io.Serializable;
-import java.io.StringWriter;
-
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.gdata.data.ServerBaseEntry;
-import org.apache.lucene.gdata.server.registry.ProvidedService;
-import org.apache.lucene.gdata.server.registry.ProvidedServiceConfig;
-import org.apache.lucene.gdata.storage.lucenestorage.StorageBuffer.BufferableEntry;
-
-import com.google.gdata.data.BaseEntry;
-import com.google.gdata.util.common.xml.XmlWriter;
-
-/**
- * This immutable class wrapps <tt>ServerBaseEntry</tt> for an internal
- * Storage representation of an entry. This class also acts as a Documentfactory
- * for lucene documents to be stored inside the index.
- * 
- * @author Simon Willnauer
- * 
- */
-public class StorageEntryWrapper implements Comparable<StorageEntryWrapper>, Serializable,
-        StorageWrapper {
-
-    private static final long serialVersionUID = -4619985652059888526L;
-    /*
-     * client api uses UTF-8 to encode server requests and entries
-     */
-    private static final String INTERNAL_ENCODING = "UTF-8";
-
-    /**
-     * lucene field name Entry id
-     */
-    public final static String FIELD_ENTRY_ID = "entryId";
-
-    /**
-     * lucene field name feed id
-     */
-    public final static String FIELD_FEED_REFERENCE = "feedReference";
-
-    /**
-     * lucene field name entry content
-     */
-    public final static String FIELD_CONTENT = "content";
-
-    /**
-     * lucene field name creating timestamp
-     */
-    public final static String FIELD_TIMESTAMP = "timestamp";
-
-    /**
-     * lucene field name entry version
-     */
-    public final static String FIELD_VERSION = "entryVersion";
-    private  int version;
-
-    private  String entryId;
-
-    private  String feedId;
-
-    private  String content;
-
-    private transient ServerBaseEntry entry;
-
-    private Long timestamp;
-
-    private Document document;
-
-    private StorageOperation operation;
-
-    private transient ProvidedService config;
-
-    /**
-     * Creates a new StorageEntryWrapper.
-     * 
-     * @param entry -
-     *            the entry to wrap
-     * 
-     * @param operation -
-     *            the StorageOperation
-     * 
-     * @throws IOException -
-     *             if the entry content can not be generated
-     */
-    public StorageEntryWrapper(final ServerBaseEntry entry,
-            StorageOperation operation) throws IOException {
-        this.entry = entry;
-        this.operation = operation;
-        this.entryId = entry.getId();
-        this.feedId = entry.getFeedId();
-        this.version = entry.getVersion();
-        if (operation != StorageOperation.DELETE) {
-            this.config = entry.getServiceConfig();
-            this.content = buildContent();
-            
-         
-        }
-        this.timestamp = new Long(
-                this.entry.getUpdated() != null ? this.entry.getUpdated()
-                        .getValue() : System.currentTimeMillis());
-            
-
-    }
-   
- 
-    private String buildContent() throws IOException {
-        StringWriter writer = new StringWriter();
-        XmlWriter xmlWriter = new XmlWriter(writer, INTERNAL_ENCODING);
-        this.entry.generateAtom(xmlWriter, this.config.getExtensionProfile());
-        return writer.toString();
-
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageWrapper#getLuceneDocument()
-     */
-    public Document getLuceneDocument() {
-        if(this.operation == StorageOperation.DELETE)
-            return null;
-        if (this.document != null)
-            return this.document;
-        this.document = new Document();
-        this.document.add(new Field(FIELD_ENTRY_ID, this.entryId,
-                Field.Store.YES, Field.Index.UN_TOKENIZED));
-        this.document.add(new Field(FIELD_FEED_REFERENCE, this.feedId,
-                Field.Store.YES, Field.Index.UN_TOKENIZED));
-        this.document.add(new Field(FIELD_CONTENT,this.content,
-                Field.Store.COMPRESS, Field.Index.NO));
-        this.document.add(new Field(FIELD_TIMESTAMP, this.timestamp.toString(),
-                Field.Store.YES, Field.Index.UN_TOKENIZED));
-        this.document.add(new Field(FIELD_VERSION, Integer.toString(this.version),
-                Field.Store.YES, Field.Index.UN_TOKENIZED));
-
-        return this.document;
-
-    }
-
-    /**
-     * @return - the wrapped entry
-     */
-    public BaseEntry getEntry() {
-        /*
-         * this wrapps the entry again. BufferableEntry creates a new instance
-         * for the dynamic element like links.
-         */
-        return new BufferableEntry(this.entry.getEntry());
-    }
-
-    /**
-     * @return - the entry id
-     */
-    public String getEntryId() {
-        return this.entryId;
-    }
-
-    /**
-     * @return - the feed id
-     */
-    public String getFeedId() {
-        return this.feedId;
-    }
-
-    /**
-     * Storage operations
-     * 
-     * @author Simon Willnauer
-     * 
-     */
-    public static enum StorageOperation {
-        /**
-         * delete
-         */
-        DELETE,
-        /**
-         * update
-         */
-        UPDATE,
-        /**
-         * insert
-         */
-        INSERT
-    }
-
-    /**
-     * @return the specified storage operation
-     */
-    public StorageOperation getOperation() {
-        return this.operation;
-    }
-
-    /**
-     * This compare method compares the timestamps of the wrapper instances.
-     * 
-     * @param arg0 -
-     *            the wrapper to compare
-     * @par
-     * @return - 0 if the wrappers timestamp are the same, an integer > 0 if the
-     *         given wrapper is after this wrapper
-     * 
-     */
-    public int compareTo(StorageEntryWrapper arg0) {
-        return arg0.timestamp.equals(this.timestamp) ? 0
-                : (arg0.timestamp > this.timestamp ? 1 : -1);
-    }
-
-    /**
-     * @return - the specified {@link ProvidedServiceConfig}
-     */
-    public ProvidedService getConfigurator() {
-        return this.config;
-    }
-
-    /**
-     * @return Returns the timestamp.
-     */
-    public Long getTimestamp() {
-        return this.timestamp;
-    }
-
-    /**
-     * @return - the version of the entry
-     */
-    public int getVersion() {
-        
-        return this.version;
-    }
-
-
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/StorageFeedWrapper.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/StorageFeedWrapper.java
deleted file mode 100644
index 3567b1f..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/StorageFeedWrapper.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.storage.lucenestorage;
-
-import java.io.IOException;
-import java.io.StringWriter;
-
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.gdata.data.ServerBaseFeed;
-import org.apache.lucene.gdata.server.registry.ProvidedService;
-
-import com.google.gdata.data.BaseFeed;
-import com.google.gdata.util.common.xml.XmlWriter;
-
-/**
- * This immutable class wrapps <tt>GDataAccount</tt> instances for an internal Storage representation of 
- * an account. This class also acts as a Documentfactory for lucene documents to 
- * be stored inside the index. 
- * @author Simon Willnauer
- *
- */
-public class StorageFeedWrapper implements StorageWrapper {
-    
-    private static final String INTERNAL_ENCODING = "UTF-8";
-    /**
-     * the account who owns the feed 
-     */
-    public static final String FIELD_ACCOUNTREFERENCE = "accountReference";
-    /**
-     * the id of the feed
-     */
-    public static final String FIELD_FEED_ID = "feedId";
-    /**
-     * The xml feed representation
-     */
-    public static final String FIELD_CONTENT = "content";
-    
-    /**
-     * The creation timestamp
-     */
-    public static final String FIELD_TIMESTAMP = "timestamp";
-
-    /**
-     * The Service this feed belongs to. 
-     */
-    public static final String FIELD_SERVICE_ID = "serviceId";
-    private final ServerBaseFeed feed;
-    private final String accountName;
-    private final ProvidedService config;
-    private final String content;
-    
-    
-    /**
-     * @param feed 
-     * @param accountname 
-     * @throws IOException 
-     * 
-     */
-    public StorageFeedWrapper(final ServerBaseFeed feed, final String accountname) throws IOException {
-        this.feed = feed;
-        this.accountName = accountname;
-        this.config = feed.getServiceConfig();
-        this.content = buildContent();
-       
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageWrapper#getLuceneDocument()
-     */
-    public Document getLuceneDocument() {
-        Document doc = new Document();
-        doc.add(new Field(FIELD_ACCOUNTREFERENCE,this.accountName,Field.Store.YES,Field.Index.UN_TOKENIZED));
-        doc.add(new Field(FIELD_FEED_ID,this.feed.getId(),Field.Store.YES,Field.Index.UN_TOKENIZED));
-        doc.add(new Field(FIELD_CONTENT,this.content,Field.Store.COMPRESS,Field.Index.NO));
-        doc.add(new Field(FIELD_SERVICE_ID,this.feed.getServiceType(),Field.Store.YES,Field.Index.NO));
-        return doc;
-    }
-
-    private String buildContent() throws IOException { 
-        StringWriter writer = new StringWriter(); 
-        XmlWriter xmlWriter = new XmlWriter(writer, INTERNAL_ENCODING); 
-        this.feed.generateAtom(xmlWriter,this.config.getExtensionProfile()); 
-        return writer.toString(); 
-    }
-    /**
-     * @return - the wrapped feed
-     */
-    public BaseFeed getFeed(){
-        return this.feed.getFeed();
-    }
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/StorageImplementation.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/StorageImplementation.java
deleted file mode 100644
index fc2c49c..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/StorageImplementation.java
+++ /dev/null
@@ -1,574 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.storage.lucenestorage;
-
-import java.io.IOException;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.data.GDataAccount;
-import org.apache.lucene.gdata.data.ServerBaseEntry;
-import org.apache.lucene.gdata.data.ServerBaseFeed;
-import org.apache.lucene.gdata.server.registry.ComponentType;
-import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
-import org.apache.lucene.gdata.storage.ModificationConflictException;
-import org.apache.lucene.gdata.storage.ResourceNotFoundException;
-import org.apache.lucene.gdata.storage.Storage;
-import org.apache.lucene.gdata.storage.StorageController;
-import org.apache.lucene.gdata.storage.StorageException;
-import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper.StorageOperation;
-import org.apache.lucene.gdata.utils.ReferenceCounter;
-
-import com.google.gdata.data.BaseEntry;
-import com.google.gdata.data.BaseFeed;
-
-/**
- * This is an implementation of the
- * {@link org.apache.lucene.gdata.storage.Storage} interface. The
- * StorageImplementation provides access to the
- * {@link org.apache.lucene.gdata.storage.lucenestorage.StorageQuery} and the
- * {@link org.apache.lucene.gdata.storage.lucenestorage.StorageModifier}. This
- * class will be instantiated per client request.
- * 
- * 
- * 
- * @author Simon Willnauer
- * 
- */
-public class StorageImplementation implements Storage {
-    private final StorageCoreController controller;
-
-    private static final Log LOG = LogFactory
-            .getLog(StorageImplementation.class);
-
-    /**
-     * Creates a new StorageImplementation
-     * 
-     * @throws StorageException -
-     *             if the storage controller can not be obtained
-     * 
-     * 
-     * 
-     */
-    public StorageImplementation() throws StorageException {
-        this.controller = (StorageCoreController) GDataServerRegistry
-                .getRegistry().lookup(StorageController.class,
-                        ComponentType.STORAGECONTROLLER);
-        if (this.controller == null)
-            throw new StorageException("Can't get registered StorageController");
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#storeEntry(org.apache.lucene.gdata.data.ServerBaseEntry)
-     */
-    public BaseEntry storeEntry(final ServerBaseEntry entry)
-            throws StorageException {
-        if (entry == null)
-            throw new StorageException("entry is null");
-        if(entry.getFeedId() == null)
-            throw new StorageException("feed-id is null");
-        if(entry.getVersion() != 1)
-            throw new StorageException("entry version must be 1");
-        if(entry.getServiceConfig() == null)
-            throw new StorageException("ProvidedService must not be null");
-        StorageModifier modifier = this.controller.getStorageModifier();
-        String id = this.controller.releaseId();
-        entry.setId(entry.getFeedId() + id);
-        if (LOG.isInfoEnabled())
-            LOG.info("Store entry " + id + " -- feed: " + entry.getFeedId());
-
-        try {
-            StorageEntryWrapper wrapper = new StorageEntryWrapper(entry,
-                    StorageOperation.INSERT);
-            modifier.insertEntry(wrapper);
-        } catch (IOException e) {
-            StorageException ex = new StorageException("Can't create Entry -- "
-                    + e.getMessage(), e);
-            ex.setStackTrace(e.getStackTrace());
-            throw ex;
-
-        }
-
-        return entry.getEntry();
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#deleteEntry(org.apache.lucene.gdata.data.ServerBaseEntry)
-     */
-    public void deleteEntry(final ServerBaseEntry entry)
-            throws StorageException {
-
-        if (entry == null)
-            throw new StorageException("Entry is null");
-        if(entry.getId() == null)
-            throw new StorageException("Entry id is null");
-        if(entry.getFeedId() == null)
-            throw new StorageException("feed id is null");
-        if (LOG.isInfoEnabled())
-            LOG.info("delete entry " + entry.getId() + " -- feed: "
-                    + entry.getFeedId());
-        StorageModifier modifier = this.controller.getStorageModifier();
-        ReferenceCounter<StorageQuery> query = this.controller.getStorageQuery();
-        // try to set concurrency Lock
-        String key = entry.getId();
-        setLock(key);
-        try{
-        if(query.get().isEntryStored(entry.getId(),entry.getFeedId())){
-            if(query.get().checkEntryVersion(entry.getId(),entry.getFeedId(),entry.getVersion())){
-                modifier.deleteEntry(new StorageEntryWrapper(entry,StorageOperation.DELETE));
-            }else
-                throw new ModificationConflictException("The entry version does not match -- entry "+entry.getId()+" feed:"+entry.getFeedId()+" version: "+entry.getVersion());
-        }
-        else
-            throw new ResourceNotFoundException("Entry for entry id: "+entry.getId()+" is not stored");
-        }catch (IOException e) {
-            throw new StorageException("Can not access storage");
-        }finally{
-            if(query != null)
-                query.decrementRef();
-            // release lock for concurrency
-            releaseLock(key);
-        }
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#updateEntry(org.apache.lucene.gdata.data.ServerBaseEntry)
-     */
-    public BaseEntry updateEntry(ServerBaseEntry entry) throws StorageException {
-
-        if (entry == null)
-            throw new StorageException("entry is null");
-        if(entry.getId() == null)
-            throw new StorageException("entry id is null");
-        if(entry.getServiceConfig() == null)
-            throw new StorageException("service config is not set -- null");
-        if(entry.getFeedId() == null)
-            throw new StorageException("feed id is null");
-        if (LOG.isInfoEnabled())
-            LOG.info("update entry " + entry.getId() + " -- feed: "
-                    + entry.getFeedId());
-        StorageModifier modifier = this.controller.getStorageModifier();
-        ReferenceCounter<StorageQuery> query = this.controller.getStorageQuery();
-        // try to set concurrency Lock
-        String key = entry.getId();
-        setLock(key);
-        try {
-            
-            
-            if(query.get().isEntryStored(entry.getId(),entry.getFeedId())){
-                
-                if(query.get().checkEntryVersion(entry.getId(),entry.getFeedId(),entry.getVersion())){
-                    entry.setVersion(entry.getVersion()+1);
-                    StorageEntryWrapper wrapper = new StorageEntryWrapper(entry,
-                            StorageOperation.UPDATE);  
-                    modifier.updateEntry(wrapper);
-                }else
-                    throw new ModificationConflictException("The entry version does not match -- entry "+entry.getId()+" feed:"+entry.getFeedId()+" version: "+entry.getVersion());
-              
-            }else
-                throw new ResourceNotFoundException("Entry for entry id: "+entry.getId()+" is not stored");
-            
-        } catch (IOException e) {
-            LOG.error("Can't update entry for feedID: " + entry.getFeedId()
-                    + "; entryId: " + entry.getId() + " -- " + e.getMessage(),
-                    e);
-            StorageException ex = new StorageException("Can't update Entry -- "
-                    + e.getMessage(), e);
-            ex.setStackTrace(e.getStackTrace());
-            throw ex;
-
-        }
-
-        finally{
-            if(query != null)
-                query.decrementRef();
-            // release lock for concurrency
-            releaseLock(key);
-        }
-
-        return entry.getEntry();
-
-    }
-    private void setLock(String key) throws ModificationConflictException{
-        if(!this.controller.getLock().setLock(key))
-            throw new ModificationConflictException("Can not set lock for entry -- "+key);
-            
-    }
-    
-    private void releaseLock(String key) throws StorageException{
-        if(!this.controller.getLock().releaseLock(key))
-            throw new StorageException("Can not release lock for key: "+key);
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#getFeed(org.apache.lucene.gdata.data.ServerBaseFeed)
-     */
-    @SuppressWarnings("unchecked")
-    public BaseFeed getFeed(final ServerBaseFeed feed) throws StorageException {
-
-        if (feed == null)
-            throw new StorageException("feed is null");
-        if (LOG.isInfoEnabled())
-            LOG.info("get feed: " + feed.getId() + " start-index: "
-                    + feed.getStartIndex() + " resultCount: "
-                    + feed.getItemsPerPage());
-        ReferenceCounter<StorageQuery> query = null;
-        try {
-            query = this.controller.getStorageQuery();
-            BaseFeed retVal = query.get().getLatestFeedQuery(feed.getId(),
-                    feed.getItemsPerPage(), feed.getStartIndex(),
-                    feed.getServiceConfig());
-            return retVal;
-        } catch (Exception e) {
-            LOG.error("Can't get latest feed for feedID: " + feed.getId()
-                    + " -- " + e.getMessage(), e);
-            StorageException ex = new StorageException("Can't create Entry -- "
-                    + e.getMessage(), e);
-            ex.setStackTrace(e.getStackTrace());
-            throw ex;
-
-        } finally {
-            if (query != null)
-                query.decrementRef();
-        }
-
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#getEntry(org.apache.lucene.gdata.data.ServerBaseEntry)
-     */
-    public BaseEntry getEntry(final ServerBaseEntry entry)
-            throws StorageException {
-
-        if (entry == null)
-            throw new StorageException("No entry  specified -- is null");
-        if (LOG.isInfoEnabled())
-            LOG.info("get entry " + entry.getId() + " -- feed: "
-                    + entry.getFeedId());
-        ReferenceCounter<StorageQuery> query = null;
-        try {
-            query = this.controller.getStorageQuery();
-            BaseEntry retVal = query.get().singleEntryQuery(entry.getId(),
-                    entry.getFeedId(), entry.getServiceConfig());
-            if(retVal == null)
-                throw new ResourceNotFoundException("can not get entry for entry ID "+entry.getId());
-            return retVal;
-        } catch (Exception e) {
-            LOG.error("Can't get entry for feedID: " + entry.getFeedId()
-                    + "; entryId: " + entry.getId() + " -- " + e.getMessage(),
-                    e);
-            StorageException ex = new StorageException("Can't create Entry -- "
-                    + e.getMessage(), e);
-            ex.setStackTrace(e.getStackTrace());
-            throw ex;
-
-        } finally {
-            if (query != null)
-                query.decrementRef();
-        }
-
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#close()
-     */
-    public void close() {
-        //
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#storeAccount(org.apache.lucene.gdata.data.GDataAccount)
-     */
-    public void storeAccount(GDataAccount Account) throws StorageException {
-        if (Account == null)
-            throw new StorageException("Can not save null Account");
-        ReferenceCounter<StorageQuery> query = null;
-        try {
-            query = this.controller.getStorageQuery();
-            if (query.get().getUser(Account.getName()) != null)
-                throw new StorageException("Account already exists");
-            StorageModifier modifier = this.controller.getStorageModifier();
-            StorageAccountWrapper wrapper = new StorageAccountWrapper(Account);
-            modifier.createAccount(wrapper);
-        } catch (Exception e) {
-            LOG.error("Can't save Account -- " + e.getMessage(), e);
-            StorageException ex = new StorageException("Can't save Account -- "
-                    + e.getMessage(), e);
-            ex.setStackTrace(e.getStackTrace());
-            throw ex;
-
-        } finally {
-            if (query != null)
-                query.decrementRef();
-        }
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#updateAccount(org.apache.lucene.gdata.data.GDataAccount)
-     */
-    public void updateAccount(GDataAccount Account) throws StorageException {
-        if (Account == null)
-            throw new StorageException("Can not update null Account");
-        ReferenceCounter<StorageQuery> query = null;
-        try {
-            query = this.controller.getStorageQuery();
-            if (query.get().getUser(Account.getName()) == null)
-                throw new StorageException("Account does not exist");
-            StorageModifier modifier = this.controller.getStorageModifier();
-            StorageAccountWrapper wrapper = new StorageAccountWrapper(Account);
-            modifier.updateAccount(wrapper);
-        } catch (Exception e) {
-            LOG.error("Can't update Account -- " + e.getMessage(), e);
-            StorageException ex = new StorageException(
-                    "Can't update Account -- " + e.getMessage(), e);
-            ex.setStackTrace(e.getStackTrace());
-            throw ex;
-
-        } finally {
-            if (query != null)
-                query.decrementRef();
-        }
-
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#deleteAccount(java.lang.String)
-     */
-    public void deleteAccount(String Accountname) throws StorageException {
-        if (Accountname == null)
-            throw new StorageException("can not delete null Account");
-        ReferenceCounter<StorageQuery> query = null;
-        try {
-            query = this.controller.getStorageQuery();
-            if (query.get().getUser(Accountname) == null)
-                throw new StorageException("Account does not exist");
-            StorageModifier modifier = this.controller.getStorageModifier();
-            modifier.deleteAccount(Accountname);
-        } catch (Exception e) {
-            LOG.error("Can't update Account -- " + e.getMessage(), e);
-            StorageException ex = new StorageException(
-                    "Can't update Account -- " + e.getMessage(), e);
-            ex.setStackTrace(e.getStackTrace());
-            throw ex;
-
-        } finally {
-            if (query != null)
-                query.decrementRef();
-        }
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#storeFeed(org.apache.lucene.gdata.data.ServerBaseFeed,
-     *      java.lang.String)
-     */
-    public void storeFeed(ServerBaseFeed feed, String accountName)
-            throws StorageException {
-        if (feed == null)
-            throw new StorageException("can not insert null feed");
-        if (accountName == null)
-            throw new StorageException("accountName must not be null");
-        ReferenceCounter<StorageQuery> query = null;
-        try {
-            query = this.controller.getStorageQuery();
-            if (query.get().isFeedStored(feed.getId()))
-                throw new StorageException("feed with feedID " + feed.getId()
-                        + " is already stored");
-            StorageModifier modifier = this.controller.getStorageModifier();
-            StorageFeedWrapper wrapper = new StorageFeedWrapper(feed,
-                    accountName);
-            modifier.createFeed(wrapper);
-
-        } catch (Exception e) {
-            LOG.error("Can't create feed -- " + e.getMessage(), e);
-            StorageException ex = new StorageException("Can't create feed -- "
-                    + e.getMessage(), e);
-            ex.setStackTrace(e.getStackTrace());
-            throw ex;
-
-        } finally {
-            if (query != null)
-                query.decrementRef();
-        }
-
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#deleteFeed(java.lang.String)
-     */
-    public void deleteFeed(String feedId) throws StorageException {
-        if (feedId == null)
-            throw new StorageException("can not delete feed id is null ");
-        ReferenceCounter<StorageQuery> query = null;
-        try {
-            query = this.controller.getStorageQuery();
-            if (!query.get().isFeedStored(feedId))
-                throw new StorageException("Account does not exist");
-            StorageModifier modifier = this.controller.getStorageModifier();
-
-            modifier.deleteFeed(feedId);
-
-        } catch (Exception e) {
-            LOG.error("Can't delete feed -- " + e.getMessage(), e);
-            StorageException ex = new StorageException("Can't create feed -- "
-                    + e.getMessage(), e);
-            ex.setStackTrace(e.getStackTrace());
-            throw ex;
-
-        } finally {
-            if (query != null)
-                query.decrementRef();
-        }
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#updateFeed(org.apache.lucene.gdata.data.ServerBaseFeed,
-     *      java.lang.String)
-     */
-    public void updateFeed(ServerBaseFeed feed, String accountName)
-            throws StorageException {
-        if (feed == null)
-            throw new StorageException("can not update null feed");
-        if (accountName == null)
-            throw new StorageException("accountName must not be null");
-        ReferenceCounter<StorageQuery> query = null;
-        try {
-            query = this.controller.getStorageQuery();
-            if (!query.get().isFeedStored(feed.getId()))
-                throw new StorageException("Account does not exist");
-            StorageModifier modifier = this.controller.getStorageModifier();
-            StorageFeedWrapper wrapper = new StorageFeedWrapper(feed,
-                    accountName);
-            modifier.updateFeed(wrapper);
-
-        } catch (Exception e) {
-            LOG.error("Can't create feed -- " + e.getMessage(), e);
-            StorageException ex = new StorageException("Can't create feed -- "
-                    + e.getMessage(), e);
-            ex.setStackTrace(e.getStackTrace());
-            throw ex;
-
-        } finally {
-            if (query != null)
-                query.decrementRef();
-        }
-
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#getServiceForFeed(java.lang.String)
-     */
-    public String getServiceForFeed(String feedId) throws StorageException {
-        if (feedId == null)
-            throw new StorageException("no feed for the feedID == null");
-        ReferenceCounter<StorageQuery> query = null;
-        try {
-            query = this.controller.getStorageQuery();
-            String type = query.get().getService(feedId);
-            if (type == null)
-                throw new StorageException("no feed for the feedID == "
-                        + feedId + " found");
-            return type;
-        } catch (Exception e) {
-            throw new StorageException("Can not access storage", e);
-        } finally {
-            if (query != null)
-                query.decrementRef();
-        }
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#getAccount(java.lang.String)
-     */
-    public GDataAccount getAccount(String accountName) throws StorageException {
-        if (accountName == null)
-            throw new StorageException("account name must not be null");
-        ReferenceCounter<StorageQuery> query = null;
-        try {
-            query = this.controller.getStorageQuery();
-            return query.get().getUser(accountName);
-        } catch (Exception e) {
-            throw new StorageException("Can not access storage", e);
-        } finally {
-            if (query != null)
-                query.decrementRef();
-        }
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#getAccountNameForFeedId(java.lang.String)
-     */
-    public String getAccountNameForFeedId(String feedId)
-            throws StorageException {
-        if (feedId == null)
-            throw new StorageException("feed-id must not be null");
-        ReferenceCounter<StorageQuery> query = null;
-        try {
-            query = this.controller.getStorageQuery();
-            String accountName = query.get().getAccountNameForFeedId(feedId);
-            if (accountName == null)
-                throw new StorageException("no feed for feedId " + feedId
-                        + " found");
-            return accountName;
-        } catch (IOException e) {
-            throw new StorageException("Can not access storage - "
-                    + e.getMessage(), e);
-        } finally {
-            if (query != null)
-                query.decrementRef();
-        }
-
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#getEntryLastModified(java.lang.String, java.lang.String)
-     */
-    public Long getEntryLastModified(String entryId,String feedId) throws StorageException {
-        ReferenceCounter<StorageQuery> query = null;
-        try {
-            query = this.controller.getStorageQuery();
-            return new Long(query.get().getEntryLastModified(entryId,feedId));
-        } catch (IOException e) {
-            throw new StorageException("Can not access storage - "
-                    + e.getMessage(), e);
-        } finally {
-            if (query != null)
-                query.decrementRef();
-        }
-
-        
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#getFeedLastModified(java.lang.String)
-     */
-    public Long getFeedLastModified(String feedId) throws StorageException {
-        ReferenceCounter<StorageQuery> query = null;
-        try {
-            query = this.controller.getStorageQuery();
-            return new Long(query.get().getFeedLastModified(feedId));
-        } catch (IOException e) {
-            throw new StorageException("Can not access storage - "
-                    + e.getMessage(), e);
-        } finally {
-            if (query != null)
-                query.decrementRef();
-        }
-
-            }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/StorageModifier.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/StorageModifier.java
deleted file mode 100644
index ec5a171..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/StorageModifier.java
+++ /dev/null
@@ -1,513 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.storage.lucenestorage;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReentrantLock;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.gdata.storage.StorageException;
-import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper.StorageOperation;
-import org.apache.lucene.index.IndexModifier;
-import org.apache.lucene.index.Term;
-
-/**
- * The StorageModifier is the a Singleton component of the LuceneStorage. There
- * is one single instance of this class modifying the index used to store all
- * the gdata Entities as Entries, Feeds and Users. This class contains an
- * instance of {@link org.apache.lucene.index.IndexModifier} used to manage all
- * delete and add actions to the storage.
- * <p>
- * To prevent the storage component from opening and closing the
- * {@link org.apache.lucene.index.IndexModifier} for every modifying operation
- * the incoming entry actions (DELETE, UPDATE, INSERT) will be buffered in a
- * registered instance of
- * {@link org.apache.lucene.gdata.storage.lucenestorage.StorageBuffer}. When a
- * certain amout (specified as the persistfactor in the configuration file) of
- * modifications have been executed the StorageModifier will persist the
- * buffered entries.
- * </p>
- * <p>
- * Feed and User operations won't be buffered. These actions occure not very
- * often compared to entry actions. Every call of an user / feed modifying
- * operation forces all changes to be written to the storage index.
- * </p>
- * 
- * @author Simon Willnauer
- * 
- */
-public class StorageModifier {
-    protected static final Log LOG = LogFactory.getLog(StorageModifier.class);
-
-    private final List<Term> deletedDocumentQueue;
-
-    private final List<Term> deletedForUpdateDocumentQueue;
-
-    private final Map<String, Document> documentMap;
-
-    private final List<Document> forceWriteDocuments;
-
-    private final List<Term> forceWriteTerms;
-
-    private volatile int persistFactor;
-
-    private volatile int modifiedCounter = 0;
-
-    private static int DEFAULT_PERSIST_FACTOR = 10;
-
-    private StorageBuffer buffer;
-
-    private IndexModifier modifier;
-
-    private Lock lock = new ReentrantLock();
-    
-    private final AtomicBoolean isClosed = new AtomicBoolean(false);
-
-    private final static int DEFAULT_OPTIMIZE_INTERVAL = 10;
-
-    private final int optimizeInterval;
-
-    private volatile int optimizeCounter = 0;
-
-    private final StorageCoreController controller;
-
-    /**
-     * Creates a new StorageModifier
-     * 
-     * @param controller -
-     *            the registered StorageController
-     * @param modifier -
-     *            the IndexModifier
-     * @param buffer -
-     *            the StorageBuffer
-     * @param persitsFactor -
-     *            the factor when the changes will be persisted to the storage
-     *            index
-     * @param optimizeInterval -
-     *            after how many storage operations the index will be optimized
-     */
-    protected StorageModifier(final StorageCoreController controller,
-            final IndexModifier modifier, final StorageBuffer buffer,
-            int persitsFactor, int optimizeInterval) {
-        this.deletedDocumentQueue = new LinkedList<Term>();
-        this.deletedForUpdateDocumentQueue = new LinkedList<Term>();
-        this.documentMap = new HashMap<String, Document>(persitsFactor);
-        this.forceWriteDocuments = new ArrayList<Document>(5);
-        this.forceWriteTerms = new ArrayList<Term>(5);
-        this.buffer = buffer;
-        this.controller = controller;
-
-        this.persistFactor = persitsFactor > 0 ? persitsFactor
-                : DEFAULT_PERSIST_FACTOR;
-        this.modifier = modifier;
-        this.optimizeInterval = optimizeInterval < DEFAULT_OPTIMIZE_INTERVAL ? DEFAULT_OPTIMIZE_INTERVAL
-                : optimizeInterval;
-
-    }
-
-    /**
-     * Updates the given entry. First the alredy persisted entry will be
-     * removed, after marking as deleted the new Entry will be written.
-     * 
-     * @param wrapper -
-     *            the wrapper containing the entry
-     * @throws StorageException -
-     *             if the entry can not be stored
-     */
-    public void updateEntry(StorageEntryWrapper wrapper)
-            throws StorageException {
-        if(wrapper.getOperation() != StorageOperation.UPDATE)
-            throw new StorageException("Illegal method call -- updateEntry does not accept other storageOperations than update");
-        this.lock.lock();
-        try {
-            
-            Term tempTerm = new Term(StorageEntryWrapper.FIELD_ENTRY_ID,
-                    wrapper.getEntryId());
-            this.documentMap.put(wrapper.getEntryId(), wrapper
-                    .getLuceneDocument());
-            this.deletedForUpdateDocumentQueue.add(tempTerm);
-            storageModified();
-            /*
-             * If storage not written write entry to recoverfile
-             * and make the entry available via the buffer
-             */
-            if(this.modifiedCounter != 0)
-                try{
-                    this.controller.writeRecoverEntry(wrapper);
-                    this.buffer.addEntry(wrapper);
-                }catch (Exception e) {
-                    /*
-                     * remove from all resources
-                     */
-                    this.documentMap.remove(wrapper.getEntryId());
-                    this.deletedForUpdateDocumentQueue.remove(tempTerm);
-                    
-                }
-        } finally {
-            this.lock.unlock();
-        }
-    }
-
-    /**
-     * Inserts a new Entry to the Lucene index storage
-     * 
-     * @param wrapper -
-     *            the wrapper containing the entry
-     * @throws StorageException -
-     *             if the entry can not be stored
-     */
-    public void insertEntry(StorageEntryWrapper wrapper)
-            throws StorageException {
-        if(wrapper.getOperation() != StorageOperation.INSERT)
-            throw new StorageException("Illegal method call -- insertEntry does not accept other storage operations than insert");
-        this.lock.lock();
-        try {
-            this.documentMap.put(wrapper.getEntryId(), wrapper
-                    .getLuceneDocument());
-            storageModified();
-            /*
-             * If storage not written write entry to recoverfile
-             * and make the entry available via the buffer
-             */
-            if(this.modifiedCounter != 0)
-                try{
-                    this.controller.writeRecoverEntry(wrapper);
-                    this.buffer.addEntry(wrapper);
-                }catch (Exception e) {
-                    /*
-                     * remove from all resources
-                     */
-                    this.documentMap.remove(wrapper.getEntryId());
-                }
-        } finally {
-            this.lock.unlock();
-        }
-    }
-
-    /**
-     * Deletes the entry for the given entry id.
-     * @param wrapper - the wrapper containing the information to delete 
-     * 
-     * @throws StorageException -
-     *             if the entry can not be deleted
-     * 
-     */
-    public void deleteEntry(final StorageEntryWrapper wrapper)
-            throws StorageException {
-        if(wrapper.getOperation() != StorageOperation.DELETE)
-            throw new StorageException("Illegal method call -- insertEntry does not accept other storage operations than delete");
-        this.lock.lock();
-        try {
-            
-            Term tempTerm = new Term(StorageEntryWrapper.FIELD_ENTRY_ID,
-                    wrapper.getEntryId());
-            this.deletedDocumentQueue.add(tempTerm);
-            storageModified();
-            /*
-             * If storage not written write entry to recoverfile
-             * and make the entry available via the buffer
-             */
-            if(this.modifiedCounter != 0)
-                try{
-                    this.controller.writeRecoverEntry(wrapper);
-                    this.buffer.addDeleted(wrapper.getEntryId(), wrapper.getFeedId());
-                }catch (Exception e) {
-                    /*
-                     * remove from all resources
-                     */
-                 this.deletedDocumentQueue.remove(tempTerm);
-                    
-                }
-        } finally {
-            this.lock.unlock();
-        }
-    }
-
-    /**
-     * Adds a new Feed to the storage. Feed action will be not buffered. Call to
-     * this method forces the index to be written.
-     * 
-     * @param wrapper -
-     *            the wrapper containing the feed;
-     * @throws StorageException -
-     *             if the feed can not be written
-     */
-    public void createFeed(StorageFeedWrapper wrapper) throws StorageException {
-        this.lock.lock();
-        try {
-            this.forceWriteDocuments.add(wrapper.getLuceneDocument());
-            storageModified();
-        } finally {
-            this.lock.unlock();
-        }
-    }
-
-    /**
-     * Adds a new accountr to the storage. User action will be not buffered. Call to
-     * this method forces the index to be written.
-     * 
-     * @param account
-     *            -the wrapper containig the user to be persisted
-     * @throws StorageException -
-     *             if the user can not be persisted.
-     */
-    public void createAccount(StorageAccountWrapper account) throws StorageException {
-        this.lock.lock();
-        try {
-            this.forceWriteDocuments.add(account.getLuceneDocument());
-            storageModified();
-        } finally {
-            this.lock.unlock();
-        }
-    }
-
-    /**
-     * Deletes the user with the given username. User action will be not
-     * buffered. Call to this method forces the index to be written.
-     * 
-     * @param accountName -
-     *            the user to be deleted
-     * @throws StorageException -
-     *             If the user could not be deleted
-     */
-    public void deleteAccount(String accountName) throws StorageException {
-        this.lock.lock();
-        try {
-            //TODO delete all feeds and entries of this account
-            this.forceWriteTerms.add(new Term(
-                    StorageAccountWrapper.FIELD_ACCOUNTNAME, accountName));
-            storageModified();
-        } finally {
-            this.lock.unlock();
-        }
-    }
-
-    /**
-     * User action will be not buffered. Call to this method forces the index to
-     * be written.
-     * 
-     * @param user
-     *            -the wrapper containig the user to be persisted
-     * @throws StorageException -
-     *             if the user can not be persisted.
-     */
-    public void updateAccount(final StorageAccountWrapper user)
-            throws StorageException {
-        this.lock.lock();
-        try {
-            this.forceWriteTerms.add(new Term(
-                    StorageAccountWrapper.FIELD_ACCOUNTNAME, user.getUser()
-                            .getName()));
-            this.forceWriteDocuments.add(user.getLuceneDocument());
-            storageModified();
-        } finally {
-            this.lock.unlock();
-        }
-    }
-
-    /**
-     * Feed action will be not buffered. Call to this method forces the index to
-     * be written.
-     * 
-     * @param wrapper -
-     *            the wrapper containig the feed
-     * @throws StorageException -
-     *             if the feed can not be persisted
-     */
-    public void updateFeed(final StorageFeedWrapper wrapper)
-            throws StorageException {
-        this.lock.lock();
-        try {
-            this.forceWriteTerms.add(new Term(StorageFeedWrapper.FIELD_FEED_ID,
-                    wrapper.getFeed().getId()));
-            this.forceWriteDocuments.add(wrapper.getLuceneDocument());
-            storageModified();
-        } finally {
-            this.lock.unlock();
-        }
-    }
-
-    /**
-     * Deletes the feed with the given feed id Feed action will be not buffered.
-     * Call to this method forces the index to be written.
-     * All entries referencing the given feed id will be deleted as well!
-     * @param feedId -
-     *            the id of the feed to delete
-     * @throws StorageException -
-     *             if the feed can not be deleted
-     */
-    public void deleteFeed(final String feedId) throws StorageException {
-        this.lock.lock();
-        try {
-            this.deletedDocumentQueue.add(new Term(StorageEntryWrapper.FIELD_FEED_REFERENCE,feedId));
-            this.forceWriteTerms.add(new Term(StorageFeedWrapper.FIELD_FEED_ID,
-                    feedId));
-
-            storageModified();
-        } finally {
-            this.lock.unlock();
-        }
-    }
-
-    private void storageModified() throws StorageException {
-    	if(this.isClosed.get())
-    		throw new IllegalStateException("StorageModifier is already closed");
-       
-        try {
-        	if(this.isClosed.get())
-        		throw new IllegalStateException("StorageModifier is already closed");
-            incrementCounter();
-            if (this.persistFactor > this.modifiedCounter
-                    && this.forceWriteDocuments.size() <= 0
-                    && this.forceWriteTerms.size() <= 0)
-                return;
-
-            if (LOG.isInfoEnabled())
-                LOG.info("Storage modified for " + this.modifiedCounter
-                        + " times. Write Persistent index");
-            writePersistentIndex((this.optimizeCounter >= this.optimizeInterval));
-            requestNewIndexModifier();
-
-            this.modifiedCounter = 0;
-        } catch (IOException e) {
-
-            LOG.error("Writing persistent index failed - Recovering", e);
-            throw new StorageException("could not write to storage index -- "+e.getMessage(),e);
-        }
-       
-    }
-
-    /**
-     * Persists all changes imediately
-     * @throws IOException -- if an IO Exception  occures
-     */
-    public void forceWrite() throws IOException {
-    	if(this.isClosed.get())
-    		throw new IllegalStateException("StorageModifier is already closed");
-        this.lock.lock();
-        try {
-            if (LOG.isInfoEnabled())
-                LOG.info("ForceWrite called -- current modifiedCounter: "
-                        + this.modifiedCounter + " - persisting changes");
-            writePersistentIndex(true);
-            requestNewIndexModifier();
-            this.modifiedCounter = 0;
-        } finally {
-            this.lock.unlock();
-        }
-    }
-
-    private void requestNewIndexModifier() throws IOException {
-        this.controller.registerNewRecoverWriter();
-        this.controller.registerNewStorageQuery();
-        this.buffer = this.controller.releaseNewStorageBuffer();
-        this.modifier = this.controller.createIndexModifier();
-    }
-
-    private void writePersistentIndex(final boolean optimize)
-            throws IOException {
-        try {
-
-            /*
-             * first delete all updated documents
-             */
-            for (Term entryIdTerm : this.deletedForUpdateDocumentQueue) {
-                this.modifier.deleteDocuments(entryIdTerm);
-            }
-
-            for (Term term : this.forceWriteTerms) {
-                this.modifier.deleteDocuments(term);
-            }
-            /*
-             * add all documents
-             */
-            Collection<Document> documents = this.documentMap.values();
-            for (Document doc : documents) {
-                this.modifier.addDocument(doc);
-            }
-            /*
-             * write all users or feeds
-             */
-            for (Document docs : this.forceWriteDocuments) {
-                this.modifier.addDocument(docs);
-            }
-
-            /*
-             * delete all documents marked as deleted. As the DocumentIDs are
-             * unique the document marked as deleted must not persist after the
-             * index has been written. In the case of an update of a document
-             * and a previous delete the concurrency component will not allow an
-             * update. new inserted entries can not be deleted accidently-
-             */
-            for (Term entryIdTerm : this.deletedDocumentQueue) {
-                this.modifier.deleteDocuments(entryIdTerm);
-            }
-            this.modifier.flush();
-            if (optimize) {
-                if (LOG.isInfoEnabled())
-                    LOG.info("Optimizing index -- optimize interval "
-                            + this.optimizeInterval);
-                this.modifier.optimize();
-            }
-
-        } finally {
-            if (optimize)
-                this.optimizeCounter = 0;
-            this.modifier.close();
-            this.deletedForUpdateDocumentQueue.clear();
-            this.deletedDocumentQueue.clear();
-            this.documentMap.clear();
-            this.forceWriteDocuments.clear();
-            this.forceWriteTerms.clear();
-        }
-    }
-
-    protected void close() throws IOException {
-    	if(this.isClosed.get())
-    		throw new IllegalStateException("StorageModifier is already closed");
-        this.lock.lock();
-        try {
-        	if(this.isClosed.get())
-        		throw new IllegalStateException("StorageModifier is already closed");
-        	this.isClosed.set(true);
-            if (LOG.isInfoEnabled())
-                LOG.info("ForceWrite called -- current modifiedCounter: "
-                        + this.modifiedCounter + " - persisting changes");
-
-            writePersistentIndex(true);
-            this.modifiedCounter = 0;
-        } finally {
-            this.lock.unlock();
-        }
-    }
-
-    private void incrementCounter() {
-        this.optimizeCounter++;
-        this.modifiedCounter++;
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/StorageQuery.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/StorageQuery.java
deleted file mode 100644
index 00b327e..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/StorageQuery.java
+++ /dev/null
@@ -1,546 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-
-package org.apache.lucene.gdata.storage.lucenestorage;
-
-import java.io.IOException;
-import java.io.Reader;
-import java.io.StringReader;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.gdata.data.GDataAccount;
-import org.apache.lucene.gdata.server.GDataEntityBuilder;
-import org.apache.lucene.gdata.server.registry.ProvidedService;
-import org.apache.lucene.gdata.storage.StorageException;
-import org.apache.lucene.gdata.utils.ModifiedEntryFilter;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.BooleanClause;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.Hit;
-import org.apache.lucene.search.Hits;
-import org.apache.lucene.search.Searcher;
-import org.apache.lucene.search.Sort;
-import org.apache.lucene.search.SortField;
-import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.BooleanClause.Occur;
-
-import com.google.gdata.data.BaseEntry;
-import com.google.gdata.data.BaseFeed;
-import com.google.gdata.data.DateTime;
-import com.google.gdata.util.ParseException;
-
-/**
- * StorageQuery wraps a Lucene {@link org.apache.lucene.search.IndexSearcher}
- * and a {@link org.apache.lucene.gdata.storage.lucenestorage.StorageBuffer} to
- * perform all request on the lucene storage. The wrapped components are thread -
- * safe.
- * <p>
- * An instance of this class will serve all client requests. To obtain the
- * current instance of the {@link StorageQuery} the method
- * {@link org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController#getStorageQuery()}
- * has to be invoked. This method will release the current StorageQuery.
- * </p>
- * 
- * @see org.apache.lucene.search.IndexSearcher
- * @see org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController
- * @see org.apache.lucene.gdata.storage.lucenestorage.StorageBuffer
- * 
- * @author Simon Willnauer
- * 
- */
-public class StorageQuery {
-    private static final Log LOG = LogFactory.getLog(StorageQuery.class);
-
-    private final StorageBuffer buffer;
-
-    private final Searcher searcher;
-
-    /*
-     * Sort the result by timestamp desc
-     */
-    private final Sort timeStampSort = new Sort(new SortField(
-            StorageEntryWrapper.FIELD_TIMESTAMP, SortField.STRING, true));
-
-    /**
-     * Creates a new StorageQuery
-     * 
-     * @param buffer -
-     *            the buffer instance to get the buffered inserts, updates from.
-     * @param searcher -
-     *            the searcher instance to use to query the storage index.
-     * 
-     * 
-     */
-    protected StorageQuery(final StorageBuffer buffer, final Searcher searcher) {
-
-        this.buffer = buffer;
-        this.searcher = searcher;
-
-    }
-
-    private Hits storageQuery(List<String> entryId) throws IOException {
-        BooleanQuery query = new BooleanQuery();
-        /*
-         * query the index using a BooleanQuery
-         */
-        for (String id : entryId) {
-            TermQuery termQuery = new TermQuery(new Term(
-                    StorageEntryWrapper.FIELD_ENTRY_ID, id));
-            // use an OR query
-            query.add(new BooleanClause(termQuery, Occur.SHOULD));
-        }
-
-        return this.searcher.search(query, new ModifiedEntryFilter(this.buffer
-                .getExculdList(),StorageEntryWrapper.FIELD_ENTRY_ID));
-    }
-
-    /*
-     * query the storage index for a entire feed.
-     */
-    private Hits storageFeedQuery(final String feedId, final Sort sort)
-            throws IOException {
-        TermQuery query = new TermQuery(new Term(
-                StorageEntryWrapper.FIELD_FEED_REFERENCE, feedId));
-        return this.searcher.search(query, new ModifiedEntryFilter(this.buffer
-                .getExculdList(),StorageEntryWrapper.FIELD_ENTRY_ID), sort);
-
-    }
-
-    /*
-     * get a single entry
-     */
-    private Hits storageQuery(String entryId) throws IOException {
-        TermQuery termQuery = new TermQuery(new Term(
-                StorageEntryWrapper.FIELD_ENTRY_ID, entryId));
-        /*
-         * Filter entries inside the buffer, buffered entries might contain
-         * deleted entries. These entries must be found!!
-         */
-        return this.searcher.search(termQuery, new ModifiedEntryFilter(
-                this.buffer.getExculdList(),StorageEntryWrapper.FIELD_ENTRY_ID));
-
-    }
-
-    /**
-     * This method fetches the latest feed entries from the storage. Feed
-     * usually requested via a search query or as a simple query to the REST
-     * interface.
-     * <p>
-     * The REST interface requests all the entries from a Storage. The Storage
-     * retrieves the entries corresponding to the parameters specified. This
-     * method first requests the latest entries or updated entries from the
-     * {@link StorageBuffer}. If the buffer already contains enough entries
-     * for the the specified result count the entries will be returned. If not,
-     * the underlying lucene index will be searcher for all documents of the
-     * specified feed sorted by storing timestamp desc.
-     * </p>
-     * <p>
-     * The entries will be searched in a feed context specified by the given
-     * feed ID
-     * </p>
-     * 
-     * 
-     * @param feedId -
-     *            the requested feed, this id will be used to retrieve the
-     *            entries.
-     * @param resultCount -
-     *            how many entries are requested
-     * @param startIndex -
-     *            the offset of the entry to start from.
-     * @param config -
-     *            the FeedInstanceConfiguration containing extension profile used
-     *            to create the entry instances
-     * @return - an ordered list of {@link BaseEntry} objects, or an empty list
-     *         if no entries could be found
-     * @throws IOException -
-     *             if the index could not be queries or the entries could not be
-     *             build
-     * @throws ParseException -
-     *             if an entry could not be parsed while building it from the
-     *             Lucene Document.
-     */
-    // TODO check input parameter
-    @SuppressWarnings("unchecked")
-    public BaseFeed getLatestFeedQuery(final String feedId,
-            final int resultCount, final int startIndex,
-            final ProvidedService config) throws IOException, ParseException {
-        DateTime updated = null;
-        Hits feedHits = storageFeedQuery(feedId);
-        if (feedHits.length() == 0)
-            return null;
-        BaseFeed retVal = buildFeedFromLuceneDocument(feedHits.doc(0), config);
-
-        List<BaseEntry> returnList = new ArrayList<BaseEntry>(resultCount);
-        List<StorageEntryWrapper> bufferedWrapperList = this.buffer
-                .getSortedEntries(feedId);
-        int alreadyAdded = 0;
-        int offset = startIndex - 1;
-
-        if (bufferedWrapperList != null
-                && bufferedWrapperList.size() >= startIndex) {
-            updated = bufferedWrapperList.get(0).getEntry().getUpdated();
-            for (; alreadyAdded < resultCount; alreadyAdded++) {
-                if ((bufferedWrapperList.size() - offset) > 0) {
-                    StorageEntryWrapper wrappedEntry = bufferedWrapperList
-                            .get(offset++);
-                    returnList.add(wrappedEntry.getEntry());
-                } else
-                    break;
-            }
-            // reset offset
-            offset = startIndex - 1;
-            if (alreadyAdded == resultCount) {
-                retVal.getEntries().addAll(returnList);
-                retVal.setUpdated(updated);
-                return retVal;
-            }
-        } else {
-            /*
-             * if the buffer size is less than the start index the buffer size must
-             * be considered. Sublists would not be a repeatable read part of
-             * the whole list
-             */
-            if (bufferedWrapperList != null)
-                offset = startIndex - 1 - bufferedWrapperList.size();
-        }
-
-        Hits hits = storageFeedQuery(feedId, this.timeStampSort);
-        if (hits.length() > 0) {
-
-            for (; (offset < hits.length()) && (alreadyAdded < resultCount); offset++, alreadyAdded++) {
-                Document doc = hits.doc(offset);
-                BaseEntry entry = buildEntryFromLuceneDocument(doc, config);
-                returnList.add(entry);
-            }
-            if (updated == null) {
-                try {
-                    long updatedTimeStamp = Long.parseLong(hits.doc(0).get(
-                            StorageEntryWrapper.FIELD_TIMESTAMP));
-                    updated = new DateTime(updatedTimeStamp);
-                } catch (Exception e) {
-                    LOG.warn("could not create DateTime -- " + e.getMessage(),
-                            e);
-                    updated = buildEntryFromLuceneDocument(hits.doc(0), config)
-                            .getUpdated();
-                }
-            }
-        }
-        retVal.setUpdated(updated);
-        retVal.getEntries().addAll(returnList);
-        return retVal;
-    }
-
-    /**
-     * This method retrieves a single entry from the storage. If the
-     * {@link StorageBuffer} does not contain the requested entry the
-     * underlying storage index will be searched.
-     * <p>
-     * The Entry will be searched in a feed context specified by the given feed
-     * ID
-     * </p>
-     * 
-     * @param entryId -
-     *            the entry to fetch
-     * @param feedId -
-     *            the feed id e.g. feed context
-     * @param config -
-     *            the FeedInstanceConfiguration containing extension profile used
-     *            to create the entry instances
-     * @return - the requested {@link BaseEntry} or <code>null</code> if the
-     *         entry can not be found
-     * @throws IOException -
-     *             if the index could not be queries or the entries could not be
-     *             build
-     * @throws ParseException -
-     *             if an entry could not be parsed while building it from the
-     *             Lucene Document.
-     */
-    public BaseEntry singleEntryQuery(final String entryId,
-            final String feedId, final ProvidedService config)
-            throws IOException, ParseException {
-        StorageEntryWrapper wrapper = this.buffer.getEntry(entryId, feedId);
-
-        if (wrapper == null) {
-            Hits hits = storageQuery(entryId);
-            if (hits.length() <= 0)
-                return null;
-            Document doc = hits.doc(0);
-
-            return buildEntryFromLuceneDocument(doc, config);
-        }
-        /*
-         * ServerBaseEntry enables the dynamic element of the entry like the
-         * links to be dynamic. BufferedEntries will be reused until they are
-         * written.
-         */
-        return wrapper.getEntry();
-
-    }
-
-    /**
-     * Fetches the requested entries from the storage. The given list contains
-     * entry id's to be looked up in the storage. First the {@link StorageBuffer}
-     * will be queried for the entry id's. If not all of the entries remain in
-     * the buffer the underlying lucene index will be searched. The entries are
-     * not guaranteed to be in the same order as they are in the given id list.
-     * Entry ID's not found in the index or the buffer will be omitted.
-     * <p>
-     * The entries will be searched in a feed context specified by the given
-     * feed ID
-     * </p>
-     * 
-     * @param entryIds -
-     *            the entry id's to fetch.
-     * @param feedId -
-     *            the feed id e.g. feed context.
-     * @param config -
-     *            the FeedInstanceConfiguration containing extension profile used
-     *            to create the entry instances
-     * 
-     * @return - the list of entries corresponding to the given entry id list.
-     * @throws IOException -
-     *             if the index could not be queries or the entries could not be
-     *             build
-     * @throws ParseException -
-     *             if an entry could not be parsed while building it from the
-     *             Lucene Document.
-     */
-    public List<BaseEntry> entryQuery(List<String> entryIds,
-            final String feedId, final ProvidedService config)
-            throws IOException, ParseException {
-        List<BaseEntry> resultList = new ArrayList<BaseEntry>(entryIds.size());
-        List<String> searchList = new ArrayList<String>(entryIds.size());
-        for (String entry : entryIds) {
-
-            StorageEntryWrapper bufferedEntry = this.buffer.getEntry(entry,
-                    feedId);
-            if (bufferedEntry != null) {
-                resultList.add(bufferedEntry.getEntry());
-            } else
-                searchList.add(entry);
-        }
-        if (searchList.isEmpty())
-            return resultList;
-
-        Hits hits = storageQuery(searchList);
-        Iterator hitIterator = hits.iterator();
-        while (hitIterator.hasNext()) {
-            Hit hit = (Hit) hitIterator.next();
-            Document doc = hit.getDocument();
-            BaseEntry entry = buildEntryFromLuceneDocument(doc, config);
-            resultList.add(entry);
-
-        }
-
-        return resultList;
-
-    }
-
-    private BaseEntry buildEntryFromLuceneDocument(final Document doc,
-            final ProvidedService config) throws ParseException, IOException {
-        Reader reader = new StringReader(doc.getField(StorageEntryWrapper.FIELD_CONTENT).stringValue());
-        BaseEntry entry = GDataEntityBuilder.buildEntry(reader, config);
-        entry.setVersionId(doc.getField(StorageEntryWrapper.FIELD_VERSION).stringValue());
-        return entry;
-
-    }
-
-    private BaseFeed buildFeedFromLuceneDocument(final Document doc,
-            final ProvidedService config) throws ParseException, IOException {
-        Reader reader = new StringReader(doc.getField(StorageFeedWrapper.FIELD_CONTENT).stringValue());
-        return GDataEntityBuilder.buildFeed(reader, config);
-
-    }
-
-    /**
-     * Queries the storage for an user instance
-     * 
-     * @param username -
-     *            the username (primary key)
-     * @return - the user instance if found or <code>null</code> if not exists
-     * @throws IOException -
-     *             if the storage can not be accessed.
-     */
-    public GDataAccount getUser(final String username) throws IOException {
-        if (username == null)
-            return null;
-        TermQuery query = new TermQuery(new Term(
-                StorageAccountWrapper.FIELD_ACCOUNTNAME, username));
-        Hits h = this.searcher.search(query);
-        if (h.length() == 0)
-            return null;
-        return StorageAccountWrapper.buildEntity(h.doc(0));
-    }
-
-    /**
-     * Closes all resources used in the {@link StorageQuery}. The instance can
-     * not be reused after invoking this method.
-     * 
-     * @throws IOException -
-     *             if the resources can not be closed
-     */
-    public void close() throws IOException {
-        this.searcher.close();
-        this.buffer.close();
-    }
-
-    /**
-     * Checks whether a feed for the given feedID is stored
-     * 
-     * @param feedId -
-     *            the feed ID
-     * @return <code>true</code> if and only if a feed is stored for the
-     *         provided feed ID, <code>false</code> if no feed for the given
-     *         id is stored
-     * @throws IOException
-     */
-    public boolean isFeedStored(String feedId) throws IOException {
-        Hits h = storageFeedQuery(feedId);
-        return (h.length() > 0);
-
-    }
-
-    /**
-     * Looks up the feed type for the given feed ID
-     * 
-     * @param feedID -
-     *            the feed ID
-     * @return - the feed type
-     * @throws IOException -
-     *             if the storage can not be accessed
-     */
-    public String getService(String feedID) throws IOException {
-        Hits hits = storageFeedQuery(feedID);
-        if (hits.length() <= 0)
-            return null;
-        Document doc = hits.doc(0);
-        String feedType = doc.get(StorageFeedWrapper.FIELD_SERVICE_ID);
-        return feedType;
-    }
-
-    private Hits storageFeedQuery(String feedId) throws IOException {
-        TermQuery query = new TermQuery(new Term(
-                StorageFeedWrapper.FIELD_FEED_ID, feedId));
-        return this.searcher.search(query);
-    }
-
-    /**
-     * Looks up the account reference for the given feed id
-     * 
-     * @param feedId -
-     *            id of the feed
-     * @return - the name of the account associated with the feed for the given
-     *         feed id, or <code>null</code> if the feed is not stored
-     * @throws IOException -
-     *             if the storage can not be accessed
-     */
-    public String getAccountNameForFeedId(String feedId) throws IOException {
-        Hits h = storageFeedQuery(feedId);
-        if (h.length() == 0)
-            return null;
-        Document doc = h.doc(0);
-        return doc.get(StorageFeedWrapper.FIELD_ACCOUNTREFERENCE);
-
-    }
-
-    protected long getEntryLastModified(final String entryId,
-            final String feedId) throws IOException, StorageException {
-        StorageEntryWrapper wrapper = this.buffer.getEntry(entryId, feedId);
-        if (wrapper != null)
-            return wrapper.getTimestamp();
-
-        Hits h = storageQuery(entryId);
-        if (h.length() > 0)
-            try {
-                return Long.parseLong(h.doc(0).get(
-                        StorageEntryWrapper.FIELD_TIMESTAMP));
-            } catch (Exception e) {
-                LOG.warn("Can not parse timestamp from entry -- "
-                        + h.doc(0).get(StorageEntryWrapper.FIELD_TIMESTAMP));
-            }
-        else
-            throw new StorageException("Entry not found");
-        return 0;
-
-    }
-
-    protected long getFeedLastModified(final String feedId) throws IOException {
-        Long bufferedTime = this.buffer.getFeedLastModified(feedId);
-        if (bufferedTime != null)
-            return bufferedTime;
-        Hits entryHits = storageFeedQuery(feedId, this.timeStampSort);
-        if (entryHits.length() > 0) {
-            try {
-                return Long.parseLong(entryHits.doc(0).getField(
-                        StorageEntryWrapper.FIELD_TIMESTAMP).stringValue());
-            } catch (Exception e) {
-                LOG.warn("Can not parse timestamp from entry -- "
-                        + entryHits.doc(0).get(
-                                StorageEntryWrapper.FIELD_TIMESTAMP));
-            }
-        }
-        return 0;
-
-    }
-
-    protected boolean isEntryStored(String entryId, String feedId)
-            throws IOException {
-        if (LOG.isDebugEnabled())
-            LOG.debug("Checking isEntryStored for entryid " + entryId
-                    + " feedid: " + feedId);
-        if (this.buffer.getEntry(entryId, feedId) != null)
-            return true;
-
-        Hits h = storageQuery(entryId);
-        if (h.length() > 0)
-            return true;
-        return false;
-    }
-
-    protected boolean checkEntryVersion(String id, String feedId, int version)
-            throws IOException {
-        if (LOG.isDebugEnabled())
-            LOG.debug("Checking entry version for entryid " + id + " feedid: "
-                    + feedId + " version: " + version);
-        StorageEntryWrapper wrapper = this.buffer.getEntry(id, feedId);
-
-        if (wrapper != null)
-            return wrapper.getVersion() == version;
-
-        Hits h = storageQuery(id);
-        if (h.length() < 1)
-            return false;
-        Document doc = h.doc(0);
-        String fieldValue = null;
-        try {
-            fieldValue = doc.getField(StorageEntryWrapper.FIELD_VERSION)
-                    .stringValue();
-            int storedVersion = Integer.parseInt(fieldValue);
-        if(LOG.isDebugEnabled())
-            LOG.debug("StoredEntry has version "+storedVersion +" return compare result");
-            return storedVersion == version;
-        } catch (Exception e) {
-            LOG.error("Entry has no parable Version id or field is not set -- "
-                    + fieldValue);
-        }
-        return false;
-    }
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/StorageWrapper.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/StorageWrapper.java
deleted file mode 100644
index f3296db..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/StorageWrapper.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.storage.lucenestorage;
-
-import org.apache.lucene.document.Document;
-
-/**
- * A interface to be implemented by <tt>StorageWrapper</tt> sub classes to
- * provide a lucene document for each entity wrapped.
- * 
- * @see org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper
- * @see org.apache.lucene.gdata.storage.lucenestorage.StorageAccountWrapper
- * @see org.apache.lucene.gdata.storage.lucenestorage.StorageFeedWrapper
- * @author Simon Willnauer
- * 
- */
-public interface StorageWrapper {
-    /**
-     * Returns a Lucene document representing the Wrapped Entry
-     * 
-     * @return a Lucene Document
-     */
-    public abstract Document getLuceneDocument();
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/configuration/StorageConfigurator.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/configuration/StorageConfigurator.java
deleted file mode 100644
index 838525f..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/configuration/StorageConfigurator.java
+++ /dev/null
@@ -1,153 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */ 
- 
-package org.apache.lucene.gdata.storage.lucenestorage.configuration; 
- 
-import java.io.InputStream; 
-import java.util.Properties; 
- 
-/** 
- * This clas loads the Storage configuration file and sets all properties. If 
- * the properties can not be loaded an {@link java.lang.Error} will be thrown. 
- * The configuration file <i>lucenestorage.properties.xml</i> should be available in the classpath. 
- *  
- * @author Simon Willnauer 
- *  
- */ 
-public class StorageConfigurator { 
-    private final int storageBufferSize; 
- 
-    private final int storagepersistFactor; 
- 
-    private final String storageDirectory; 
- 
-    private final boolean keepRecoveredFiles; 
- 
-    private final boolean recover; 
-    
-    private final boolean ramDirectory;
-    private static StorageConfigurator INSTANCE = null; 
- 
-    private final int indexOptimizeInterval; 
- 
-    private StorageConfigurator() { 
-        InputStream stream = StorageConfigurator.class 
-                .getResourceAsStream("/lucenestorage.properties.xml"); 
-        Properties properties = new Properties(); 
-        try { 
-            properties.loadFromXML(stream); 
- 
-        } catch (Exception e) { 
-            throw new StorageConfigurationError("Could not load properties", e); 
-        } 
-        this.storageBufferSize = Integer.parseInt(properties 
-                .getProperty("gdata.server.storage.lucene.buffersize")); 
-        this.storagepersistFactor = Integer.parseInt(properties 
-                .getProperty("gdata.server.storage.lucene.persistFactor")); 
-        this.recover = Boolean.parseBoolean(properties 
-                .getProperty("gdata.server.storage.lucene.recover")); 
-        this.keepRecoveredFiles = Boolean.parseBoolean(properties 
-                .getProperty("gdata.server.storage.lucene.recover.keepFiles")); 
-        this.storageDirectory = properties 
-                .getProperty("gdata.server.storage.lucene.directory"); 
-        this.indexOptimizeInterval = Integer.parseInt(properties 
-                .getProperty("gdata.server.storage.lucene.optimizeInterval")); 
-        this.ramDirectory = Boolean.parseBoolean(properties 
-                .getProperty("gdata.server.storage.lucene.directory.ramDirectory"));
-    } 
- 
-    /** 
-     * @return - the storage configurator 
-     */ 
-    public static synchronized StorageConfigurator getStorageConfigurator() { 
-        if (INSTANCE == null) 
-            INSTANCE = new StorageConfigurator(); 
-        return INSTANCE; 
-    } 
- 
-    /** 
-     * Keep recovering files. -- will use a lot of disk space 
-     *  
-     * @return <code>true</code> if the storage is supposed to keep the 
-     *         recovering files. 
-     */ 
-    public boolean isKeepRecoveredFiles() { 
-        return this.keepRecoveredFiles; 
-    } 
- 
-    /** 
-     * @return <code>true</code> if the storage is supposed to use recovering. 
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier 
-     */ 
-    public boolean isRecover() { 
-        return this.recover; 
-    } 
- 
-    /** 
-     * @return - the configured storage buffer size 
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageBuffer 
-     */ 
-    public int getStorageBufferSize() { 
-        return this.storageBufferSize; 
-    } 
- 
-    /** 
-     * @return - the configured storage directory 
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier 
-     */ 
-    public String getStorageDirectory() { 
-        return this.storageDirectory; 
-    } 
- 
-    /** 
-     * @return - the persist factor 
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier 
-     */ 
-    public int getStoragepersistFactor() { 
-        return this.storagepersistFactor; 
-    } 
- 
-    protected class StorageConfigurationError extends Error { 
- 
-        /** 
-         *  
-         */ 
-        private static final long serialVersionUID = 5261674332036111464L; 
- 
-        protected StorageConfigurationError(String arg0, Throwable arg1) { 
-            super(arg0, arg1); 
- 
-        } 
- 
-    } 
- 
-    /** 
-     * @return - the optimize interval 
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier 
-     */ 
-    public int getIndexOptimizeInterval() { 
- 
-        return this.indexOptimizeInterval; 
-    }
-
-    /**
-     * @return Returns the ramDirectory.
-     */
-    public boolean isRamDirectory() {
-        return this.ramDirectory;
-    } 
- 
-} 
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/configuration/package.html b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/configuration/package.html
deleted file mode 100644
index e3c84b2..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/configuration/package.html
+++ /dev/null
@@ -1,10 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
-<html> 
-<head> 
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
-   <meta name="Author" content="Simon Willnauer"> 
-</head> 
-<body> 
-Lucene Storage utils 
-</body> 
-</html> 
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/package.html b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/package.html
deleted file mode 100644
index 0f8f375..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/package.html
+++ /dev/null
@@ -1,10 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
-<html> 
-<head> 
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
-   <meta name="Author" content="Simon Willnauer"> 
-</head> 
-<body> 
-Lucene storage implementation  
-</body> 
-</html> 
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverController.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverController.java
deleted file mode 100644
index 94f3314..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverController.java
+++ /dev/null
@@ -1,204 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.storage.lucenestorage.recover;
-
-import java.io.BufferedReader;
-import java.io.BufferedWriter;
-import java.io.File;
-import java.io.FileReader;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.io.Writer;
-import java.util.List;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReentrantLock;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.storage.StorageException;
-import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper;
-import org.apache.lucene.gdata.storage.lucenestorage.StorageModifier;
-import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper.StorageOperation;
-
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class RecoverController {
-    private static final Log LOG = LogFactory.getLog(RecoverController.class);
-    private final File recoverDirectory;
-
-    private static final String FILE_SUFFIX = ".rec";
-
-    private File currentRecoverFile;
-
-    private RecoverWriter writer;
-
-    private Writer fileWriter;
-
-    private BufferedReader fileReader;
-
-    private RecoverReader reader;
-
-    private Lock lock = new ReentrantLock();
-    
-    private final boolean recover;
-    private final boolean keepRecoverFiles;
-
-    /**
-     * @param recoverDirectory
-     * @param recover
-     * @param keepRecoverFiles
-     */
-    public RecoverController(final File recoverDirectory, boolean recover, boolean keepRecoverFiles) {
-        if (recoverDirectory == null)
-            throw new IllegalArgumentException("directory must not be null");
-        if(!recoverDirectory.exists())
-            recoverDirectory.mkdirs();
-        if (!recoverDirectory.isDirectory())
-            throw new IllegalStateException("the given File is not a directory -- "+recoverDirectory);
-        this.recover = recover;
-        this.keepRecoverFiles = keepRecoverFiles;
-        this.recoverDirectory = recoverDirectory;
-       
-    }
-
-   /**
- * @param wrapper
- * @throws RecoverException
- */
-public void storageModified(StorageEntryWrapper wrapper)
-            throws RecoverException {
-        // prevent deadlock either recovering or writing
-        if(this.recover){
-            LOG.warn("Can't write entry, Recovercontroller is initialized in recover mode");
-            return;
-        }
-        this.lock.lock();
-        try {
-
-            this.writer.writeEntry(wrapper, this.fileWriter);
-        } catch (Exception e) {
-            LOG.error("Writing entry failed -- create new recover file",e);
-            throw new RecoverException(
-                    "Writing entry failed -- create new recover file",e);
-
-        } finally {
-            this.lock.unlock();
-        }
-    }
-    
-    /**
-     * @param modifier
-     */
-    public void recoverEntries(final StorageModifier modifier){
-        // prevent deadlock either recovering or writing
-        if(!this.recover){
-            LOG.warn("Can't recover entries, Recovercontroller is initialized in write mode");
-            return;
-        }
-        this.lock.lock();
-        try{
-            this.reader = new RecoverReader();
-        File[] files = this.recoverDirectory.listFiles();
-        for (int i = 0; i < files.length; i++) {
-            if(!files[i].isDirectory()){
-                try{
-                LOG.info("Recover file -- "+files[i]);
-                this.fileReader = new BufferedReader(new FileReader(files[i]));
-                List<StorageEntryWrapper> entryList = this.reader.recoverEntries(this.fileReader);
-                if(entryList.size() == 0)
-                    continue;
-                storeEntries(entryList,modifier);
-                this.fileReader.close();
-                if(!this.keepRecoverFiles){
-                    LOG.info("Recovering file -- "+files[i]+" successful, delete file");
-                    files[i].delete();
-                }
-                }catch (StorageException e) {
-                    LOG.error("Can't store recover entries for file: "+files[i].getName()+" -- keep file "+e.getMessage(),e);
-                }catch (IOException e) {
-                    LOG.error("Can't recover entries for file: "+files[i].getName()+" -- keep file",e);
-                }
-            }
-        }
-        
-        }finally{
-            this.lock.unlock();
-        }
-    }
-    
-    protected void storeEntries(final List<StorageEntryWrapper> entries, final StorageModifier modifier) throws StorageException, IOException{
-        for (StorageEntryWrapper wrapper : entries) {
-            if(wrapper.getOperation() == StorageOperation.DELETE)
-                modifier.deleteEntry(wrapper);
-            else if(wrapper.getOperation() == StorageOperation.INSERT)
-                modifier.insertEntry(wrapper);
-            else if(wrapper.getOperation() == StorageOperation.UPDATE)
-                modifier.updateEntry(wrapper);
-            modifier.forceWrite();
-          
-        }
-    }
-
-    /**
-     * @throws IOException
-     */
-    public synchronized void initialize() throws IOException {
-        if(this.recover)
-            return;
-        String filename = System.currentTimeMillis() + FILE_SUFFIX;
-        this.currentRecoverFile = new File(this.recoverDirectory, filename);
-        this.writer = new RecoverWriter();
-        this.fileWriter = new BufferedWriter(new FileWriter(
-                this.currentRecoverFile));
-
-    }
-
-    /**
-     * @throws RecoverException
-     */
-    public synchronized void destroy() throws RecoverException {
-        if (this.fileWriter != null) {
-            this.lock.lock();
-            try {
-                
-                this.fileWriter.flush();
-                this.fileWriter.close();
-                if(!this.keepRecoverFiles && this.currentRecoverFile != null)
-                    this.currentRecoverFile.delete();
-            } catch (IOException e) {
-                throw new RecoverException("Can't close recover writer ", e);
-            } finally {
-                this.lock.unlock();
-            }
-        }
-    }
-
-    /**
-     * @return <code>true</code> if the RecoverController is initialized in recover mode, otherwise <code>false</code>
-     */
-    public boolean isRecovering() {
-        
-        return this.recover;
-    }
-    
-    
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverException.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverException.java
deleted file mode 100644
index 90acff5..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverException.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.storage.lucenestorage.recover;
-
-import org.apache.lucene.gdata.storage.StorageException;
-
-/**
- * @author Simon Willnauer
- *
- */
-public class RecoverException extends StorageException {
-
-    /**
-     * 
-     */
-    private static final long serialVersionUID = -1862309520257024464L;
-
-    /**
-     * 
-     */
-    public RecoverException() {
-        super();
-        // TODO Auto-generated constructor stub
-    }
-
-    /**
-     * @param arg0
-     */
-    public RecoverException(String arg0) {
-        super(arg0);
-        // TODO Auto-generated constructor stub
-    }
-
-    /**
-     * @param arg0
-     * @param arg1
-     */
-    public RecoverException(String arg0, Throwable arg1) {
-        super(arg0, arg1);
-        // TODO Auto-generated constructor stub
-    }
-
-    /**
-     * @param arg0
-     */
-    public RecoverException(Throwable arg0) {
-        super(arg0);
-        // TODO Auto-generated constructor stub
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverReader.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverReader.java
deleted file mode 100644
index 933fbf7..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverReader.java
+++ /dev/null
@@ -1,175 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.storage.lucenestorage.recover;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.StringReader;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.StringTokenizer;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.lucene.gdata.data.ServerBaseEntry;
-import org.apache.lucene.gdata.server.GDataEntityBuilder;
-import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
-import org.apache.lucene.gdata.server.registry.ProvidedService;
-import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper;
-import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper.StorageOperation;
-
-import com.google.gdata.data.BaseEntry;
-import com.google.gdata.util.ParseException;
-
-/**
- * Recovers the written object from the harddisc
- * @author Simon Willnauer
- *
- */
-public class RecoverReader {
-    
-    private static final Log LOG = LogFactory.getLog(RecoverReader.class);
-    private RecoverStrategy strategy; 
-    protected RecoverReader(){
-        this.strategy = new RecoverStrategy();
-    }
-    /**
-     * @param reader
-     * @return
-     * @throws IOException
-     */
-    public List<StorageEntryWrapper> recoverEntries(final BufferedReader reader) throws IOException{
-        List<StorageEntryWrapper> actionList = new ArrayList<StorageEntryWrapper>();
-        this.strategy = new RecoverStrategy();
-        String input = null;
-        String metaData = null;
-        String entryData = null;
-        while((input=reader.readLine())!= null){
-            if(metaData == null){
-                metaData = input;
-                continue;
-            }
-            if(input.equals(RecoverWriter.STORAGE_OPERATION_SEPARATOR)){
-                try{
-                actionList.add(this.strategy.recover(metaData,entryData));
-                }catch (RecoverException e) {
-                  LOG.error("Skipping recover entry for metadata: "+metaData,e);
-                }
-                this.strategy = new RecoverStrategy();
-                metaData = null;
-                entryData = null;
-             continue;   
-            }
-            if(entryData == null){
-                entryData = input;
-            }
-            
-        }
-        
-        
-        
-        return actionList;
-        
-    }
-    
-    
-    
-    
-    
-  
-    
-    
-    private static  class RecoverStrategy{
-        private StorageOperation operation;
-        private ProvidedService config;
-        private String feedId;
-        private String entryId;
-        private long timestamp;
-        /**
-         * @param metaData
-         * @param entry
-         * @return
-         * @throws RecoverException
-         */
-        public StorageEntryWrapper recover(String metaData, String entry) throws RecoverException{
-                fillMetaData(metaData);
-                ServerBaseEntry retVal = null;
-                if(entry != null && this.operation == StorageOperation.DELETE)
-                    throw new RecoverException("Can not recover -- Delete operation has entry part");
-                if(entry != null)
-                    try {
-                        retVal = new ServerBaseEntry(buildEntry(entry,this.config));
-                    } catch (Exception e) {
-                        throw new RecoverException("Exception occured while building entry -- "+e.getMessage(),e);
-                    }
-                else
-                    retVal = new ServerBaseEntry();
-                retVal.setId(this.entryId);
-                retVal.setFeedId(this.feedId);
-                retVal.setServiceConfig(this.config);
-                
-           try{
-            return new StorageEntryWrapper(retVal,this.operation);
-           }catch (IOException e) {
-               throw new RecoverException("Can't create StorageWrapper -- "+e.getMessage(),e);
-        }
-        }
-        private void fillMetaData(String recoverString) throws RecoverException{
-            StringTokenizer tokenizer = new StringTokenizer(recoverString,RecoverWriter.META_DATA_SEPARATOR);
-            String temp = tokenizer.nextToken();
-            if(temp.equals("D"))
-                this.operation = StorageOperation.DELETE;
-            else if(temp.equals("U"))
-                this.operation = StorageOperation.UPDATE;
-            else if(temp.equals("I"))
-                this.operation = StorageOperation.INSERT;
-            else
-                throw new RecoverException("Illegal metadata --- "+recoverString);
-            temp = tokenizer.nextToken();
-            if(temp == null)
-                throw new RecoverException("Can't recover feed Id -- is null");
-            this.feedId = temp;
-            temp = tokenizer.nextToken();
-            if(temp == null)
-                throw new RecoverException("Can't recover entry Id -- is null");
-             this.entryId = temp;
-            
-            temp = tokenizer.nextToken();
-            try{
-                this.timestamp = Long.parseLong(temp);
-            }catch (Exception e) {
-                throw new RecoverException("Can't recover timestamp -- is null",e);
-            }
-            
-            if(this.operation != StorageOperation.DELETE){
-                temp = tokenizer.nextToken();
-                if(temp == null)
-                    throw new RecoverException("Can't recover service -- is null");  
-                if(!GDataServerRegistry.getRegistry().isServiceRegistered(temp))
-                    throw new RecoverException("Service in recover metadata is not registered  - "+temp);
-                this.config = GDataServerRegistry.getRegistry().getProvidedService(temp);
-                
-            }
-            
-        }
-        
-        private BaseEntry buildEntry(String entry, ProvidedService serviceConfig) throws ParseException, IOException{
-           StringReader reader = new StringReader(entry);
-           return GDataEntityBuilder.buildEntry(reader,serviceConfig);
-        }
-    }
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverWriter.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverWriter.java
deleted file mode 100644
index a5c78c8..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverWriter.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.storage.lucenestorage.recover;
-
-import java.io.IOException;
-import java.io.Writer;
-
-import org.apache.lucene.gdata.server.registry.ProvidedService;
-import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper;
-import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper.StorageOperation;
-
-import com.google.gdata.data.BaseEntry;
-import com.google.gdata.util.common.xml.XmlWriter;
-
-/**
- * Writes the recover objects to the hard disc.
- * @author Simon Willnauer
- *
- */
-public class RecoverWriter {
-    protected static final String META_DATA_SEPARATOR = ";";
-    protected static final String META_DATA_ENTRY_SEPARATOR = System.getProperty("line.separator");
-    protected static final String STORAGE_OPERATION_SEPARATOR = "###########";
-    protected static final String OPERATION_DELETE = "D";
-    protected static final String OPERATION_UPDATE = "U";
-    protected static final String OPERATION_INSERT = "I";
-    protected static final String FILE_PREFIX = ".strg";
-   
-    
-    
-    /**
-     * @param wrapper 
-     * @throws IOException 
-     * 
-     * 
-     * 
-     */
-    public void writeEntry(StorageEntryWrapper wrapper,Writer writer)throws IOException{
-        
-        writeOperation(wrapper.getOperation(),writer);
-        writeFeedID(wrapper.getFeedId(),writer);
-        writeEntryID(wrapper.getEntryId(),writer);
-        writeTimeStamp(wrapper.getTimestamp().toString(),writer);
-        if(!wrapper.getOperation().equals(StorageOperation.DELETE)){
-        writeService(wrapper,writer);
-            writer.write(META_DATA_ENTRY_SEPARATOR);
-            BaseEntry entry = wrapper.getEntry();
-            XmlWriter xmlWriter = new XmlWriter(writer);
-            entry.generateAtom(xmlWriter,wrapper.getConfigurator().getExtensionProfile());
-        }
-        writer.write(META_DATA_ENTRY_SEPARATOR);
-        writer.write(STORAGE_OPERATION_SEPARATOR);
-        writer.write(META_DATA_ENTRY_SEPARATOR);
-        writer.flush();
-    }
-
-   
-
-    private void writeTimeStamp(String timestamp, Writer writer) throws IOException{
-        writer.write(timestamp);
-        writer.write(META_DATA_SEPARATOR);
-    }
-    private void writeFeedID(String feedId,Writer writer) throws IOException{
-        writer.write(feedId);
-        writer.write(META_DATA_SEPARATOR);
-    }
-    private void writeEntryID(String entryId,Writer writer) throws IOException{
-        writer.write(entryId);
-        writer.write(META_DATA_SEPARATOR);
-    }
-    
-    private void writeService(StorageEntryWrapper wrapper, Writer writer) throws IOException{
-        ProvidedService config = wrapper.getConfigurator();
-        writer.write(config.getName());
-        writer.write(META_DATA_SEPARATOR);
-    }
- 
-    private void writeOperation(StorageOperation operation, Writer writer) throws IOException{
-        if(operation.equals(StorageOperation.INSERT))
-            writer.write(OPERATION_INSERT);
-        else if (operation.equals(StorageOperation.UPDATE)) 
-            writer.write(OPERATION_UPDATE);
-        else if (operation.equals(StorageOperation.DELETE)) 
-            writer.write(OPERATION_DELETE);
-        writer.write(META_DATA_SEPARATOR);
-    }
-    
-    
-    
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/recover/package.html b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/recover/package.html
deleted file mode 100644
index 0ba6029..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/recover/package.html
+++ /dev/null
@@ -1,10 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
-<html> 
-<head> 
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
-   <meta name="Author" content="Simon Willnauer"> 
-</head> 
-<body> 
-Recovering component for the lucene storage
-</body> 
-</html> 
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/util/ReferenceCounter.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/util/ReferenceCounter.java
deleted file mode 100644
index e69de29..0000000
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/util/package.html b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/util/package.html
deleted file mode 100644
index 0ed664d..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/util/package.html
+++ /dev/null
@@ -1,10 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
-<html> 
-<head> 
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
-   <meta name="Author" content="Simon Willnauer"> 
-</head> 
-<body> 
-Storage Configuration 
-</body> 
-</html> 
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/package.html b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/package.html
deleted file mode 100644
index 547ca70..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/package.html
+++ /dev/null
@@ -1,10 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
-<html> 
-<head> 
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
-   <meta name="Author" content="Simon Willnauer"> 
-</head> 
-<body> 
-Feed / Enty storage  
-</body> 
-</html> 
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/utils/DateFormater.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/utils/DateFormater.java
deleted file mode 100644
index 3f3c3cd..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/utils/DateFormater.java
+++ /dev/null
@@ -1,138 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.utils;
-
-import java.text.ParseException;
-import java.text.SimpleDateFormat;
-import java.util.Date;
-import java.util.Locale;
-import java.util.Stack;
-
-/**
- * This class uses the {@link java.text.SimpleDateFormat} class to format dates
- * into strings according to given date pattern.
- * <p>
- * As the creation of <tt>SimpleDateFormat</tt> objects is quiet expensive and
- * formating dates is used quiet fequently the objects will be cached and reused
- * in subsequent calls.
- * </p>
- * <p>
- * This implementation is thread safe as it uses {@link java.util.Stack} as a
- * cache
- * </p>
- * 
- * @author Simon Willnauer
- * 
- */
-public class DateFormater {
-    private final Stack<SimpleDateFormat> objectStack = new Stack<SimpleDateFormat>();
-    
-    private static final DateFormater formater = new DateFormater();
-
-    /**
-     * Date format as it is used in Http Last modified header (Tue, 15 Nov 1994
-     * 12:45:26 GMT)
-     */
-    public final static String HTTP_HEADER_DATE_FORMAT = "EEE, d MMM yyyy HH:mm:ss z";
-    /**
-     *  Date format as it is used in Http Last modified header (Tue, 15 Nov 1994
-     * 12:45:26 +0000)
-     */
-    public final static String HTTP_HEADER_DATE_FORMAT_TIME_OFFSET = "EEE, d MMM yyyy HH:mm:ss Z";
-
-    protected DateFormater() {
-        super();
-    }
-
-    /**
-     * Formats the given Date into the given date pattern.
-     * 
-     * @param date -
-     *            the date to format
-     * @param format -
-     *            date pattern
-     * @return - the string representation of the given <tt>Date</tt>
-     *         according to the given pattern
-     */
-    public static String formatDate(final Date date, String format) {
-        if (date == null || format == null)
-            throw new IllegalArgumentException(
-                    "given parameters must not be null");
-        SimpleDateFormat inst = formater.getFormater();
-        inst.applyPattern(format);
-        try{
-            return inst.format(date);
-        }finally{
-            formater.returnFomater(inst);
-        }
-    }
-    /**
-     * Parses the given string into one of the specified formates
-     * @param date - the string to parse
-     * @param formates - formates
-     * @return a {@link Date} instance representing the given string
-     * @throws ParseException - if the string can not be parsed
-     */
-    public static Date parseDate(final String date, final String...formates) throws ParseException{
-        for (int i = 0; i < formates.length; i++) {
-            try {
-             return parseDate(date,formates[i]);
-            } catch (ParseException e) {
-                //
-            }
-        }
-        throw new ParseException("Unparseable date: "+date,0);
-        
-    }
-    
-    /**
-     * Parses the given string into the specified formate
-     * @param dateString - the string to parse
-     * @param pattern - the expected formate
-     * @return a {@link Date} instance representing the given string
-     * @throws ParseException - if the string can not be parsed
-     */
-    public static Date parseDate(final String dateString,String pattern) throws ParseException{
-        if(dateString == null|| pattern == null)
-            throw new IllegalArgumentException(
-            "given parameters must not be null");
-        
-        SimpleDateFormat inst = formater.getFormater();
-        try{
-        inst.applyPattern(pattern);
-        return inst.parse(dateString);
-        }finally{
-            formater.returnFomater(inst);
-        }
-        
-    }
-
-    protected SimpleDateFormat getFormater() {
-        if (this.objectStack.empty())
-            return new SimpleDateFormat(DateFormater.HTTP_HEADER_DATE_FORMAT,Locale.ENGLISH);
-        return this.objectStack.pop();
-    
-    }
-
-    protected void returnFomater(final SimpleDateFormat format) {
-        if (this.objectStack.size() <= 25)
-            this.objectStack.push(format);
-        
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/utils/ModifiedEntryFilter.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/utils/ModifiedEntryFilter.java
deleted file mode 100755
index b6b2b1a..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/utils/ModifiedEntryFilter.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */ 
- 
-package org.apache.lucene.gdata.utils; 
- 
-import java.io.IOException;
-import java.util.BitSet;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.index.TermDocs;
-import org.apache.lucene.search.Filter;
- 
-/** 
- * The {@link ModifiedEntryFilter} filters the given entryIds from the lucene 
- * {@link org.apache.lucene.search.Hits} set. This filter is used to prevent the 
- * storage from retrieving already deleted or updated entries still remaining in 
- * the {@link org.apache.lucene.gdata.storage.lucenestorage.StorageBuffer}. 
- *  
- * @see org.apache.lucene.search.Filter 
- *  
- * @author Simon Willnauer 
- *  
- */ 
-public class ModifiedEntryFilter extends Filter { 
-    /*
-     * implements Serializable 
-     */ 
-    private static final long serialVersionUID = -1551686287704213591L; 
- 
-    private final String[] entyIds; 
-    private final String searchField;
-    /** 
-     * Creates a new {@link ModifiedEntryFilter} 
-     * @param entryIds the entry id's to filter  
-     * @param field - the field, the id is stored 
-     *  
-     */ 
-    public ModifiedEntryFilter(final String[] entryIds,String field) { 
-        super(); 
-        this.searchField = field;
-        this.entyIds = entryIds; 
-    } 
- 
-    /** 
-     * @see org.apache.lucene.search.Filter#bits(org.apache.lucene.index.IndexReader) 
-     */ 
-    @Override 
-    public BitSet bits(IndexReader reader) throws IOException { 
-        BitSet bitSet = new BitSet(reader.maxDoc()); 
-        bitSet.flip(0, reader.maxDoc()); // set all documents  
-        int[] docs = new int[1]; 
-        int[] freq = new int[1]; 
-        for (String id : this.entyIds) { 
-            if (id != null) { 
-                TermDocs termDocs = reader.termDocs(new Term( 
-                        this.searchField, id)); 
-                int count = termDocs.read(docs, freq); 
-                if (count == 1) 
-                    bitSet.flip(docs[0]); 
- 
-            } 
-        } 
- 
-        return bitSet; 
-    } 
- 
-} 
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/utils/Pool.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/utils/Pool.java
deleted file mode 100755
index 17bcded..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/utils/Pool.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.utils;
-
-/**
- * Basic interface to be implemented by ObjectPool implementations. Pools should
- * provide a constructor with a
- * {@link org.apache.lucene.gdata.utils.PoolObjectFactory} as a mandatory
- * parameter to create and destory the pooled objects.
- * 
- * @see org.apache.lucene.gdata.utils.PoolObjectFactory
- * 
- * @author Simon Willnauer
- * @param <Type> -
- *            the type of the pooled objects
- * 
- */
-public interface Pool<Type> {
-    /**
-     * Return an object from the pool or create one if the pool is empty.
-     * 
-     * @return - a pooled object
-     */
-    public abstract Type aquire();
-
-    /**
-     * Adds a previously aquired object to the pool. If the pool has already
-     * been closed or if the pool has already reached his size the released
-     * object will be destroyed using
-     * {@link PoolObjectFactory#destroyInstance(Object)} method.
-     * 
-     * @param type -
-     *            the previously aquired object
-     */
-    public abstract void release(final Type type);
-
-    /**
-     * @return - the defined size of the pool
-     */
-    public abstract int getSize();
-
-    /**
-     * @return - the expire time of the objects in the pool if defined
-     */
-    public abstract long getExpireTime();
-
-    /**
-     * @return <code>true</code> if and only if the pool uses an expire
-     *         mechanismn, otherwith <code>false</code>
-     */
-    public abstract boolean expires();
-
-    /**
-     * releases all pooled objects using
-     * {@link PoolObjectFactory#destroyInstance(Object)} method. The pool can not
-     * be reused after this method has been called
-     */
-    public abstract void destroy();
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/utils/PoolObjectFactory.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/utils/PoolObjectFactory.java
deleted file mode 100755
index 1b570bc..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/utils/PoolObjectFactory.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.utils;
-
-/**
- * <p>
- * This interface enables {@link org.apache.lucene.gdata.utils.Pool} users to
- * build a custom creation and destroy mechanismn for pooled objects.
- * Implementations can use standart creation to prevent the pool from using
- * reflection to create objects of the specific type. This implementation
- * seperates the Pool implementation from the creation or the destruction of a
- * pooled type.
- * </p>
- * <p>
- * The destroy method can be used to close datasource connections or release
- * resources if the object will be removed from the pool
- * </p>
- * 
- * 
- * @see org.apache.lucene.gdata.utils.Pool
- * @author Simon Willnauer
- * @param <Type> -
- *            the type to be created
- * 
- */
-public interface PoolObjectFactory<Type> {
-
-    /**
-     * @return an instance of the specified Type
-     */
-    public abstract Type getInstance();
-
-    /**
-     * destroys the given instance
-     * @param type - the object to destroy / release all resources
-     */
-    public abstract void destroyInstance(Type type);
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/utils/ReferenceCounter.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/utils/ReferenceCounter.java
deleted file mode 100755
index 7f56b45..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/utils/ReferenceCounter.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */ 
- 
-package org.apache.lucene.gdata.utils; 
- 
-import java.util.concurrent.atomic.AtomicInteger; 
- 
-/** 
- * A reference counting utility. This is use to keep track of released objects 
- * of <code>Type</code>. 
- *  
- * @author Simon Willnauer 
- * @param <Type> - 
- *            the type of the object 
- *  
- */ 
-public abstract class ReferenceCounter<Type> { 
-    protected final Type resource; 
- 
-    private AtomicInteger refcounter = new AtomicInteger(); 
- 
-    /** 
-     * @param resource - 
-     *            the resource to track 
-     *  
-     */ 
-    public ReferenceCounter(Type resource) { 
-        this.resource = resource; 
-    } 
- 
-    /** 
-     *  
-     * Decrements the reference. If no references remain the 
-     * {@link ReferenceCounter#close()} method will be invoked; 
-     */ 
-    public final void decrementRef() { 
-        /*
-         * close if less or equals 0
-         */
-        if (this.refcounter.decrementAndGet() <= 0) 
-            close(); 
-    } 
- 
-    /** 
-     * A custom implementation. Performs an action if no reference remaining 
-     *  
-     */ 
-    protected abstract void close(); 
- 
-    /** 
-     * Increments the reference 
-     *  
-     * @return the reference object 
-     */ 
-    public final ReferenceCounter<Type> increamentReference() { 
-        this.refcounter.incrementAndGet(); 
-        return this; 
-    } 
- 
-    /** 
-     * @return - the resource to keep track of 
-     */ 
-    public final Type get() { 
-        return this.resource; 
-    } 
- 
-} 
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/utils/ReflectionUtils.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/utils/ReflectionUtils.java
deleted file mode 100755
index 0f7c5fa..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/utils/ReflectionUtils.java
+++ /dev/null
@@ -1,194 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.utils;
-
-import java.lang.reflect.Constructor;
-
-/**
- * A collection of static helper methods solve common reflection problems
- * 
- * @author Simon Willnauer
- * 
- */
-public class ReflectionUtils {
-
-    /**
-     * Check if the given type implements a given super type
-     * @param typeToCheck - type supposed to implement an interface
-     * @param superType - the interface to be implemented by the type to check
-     * @return <code>true</code> if and only if the super type is above in the type hierarchy of the given type, otherwise <code>false</code>
-     */
-    public static boolean implementsType(Class typeToCheck, Class superType) {
-        if(superType == null)
-            return false;
-        if(!superType.isInterface())
-            return  false;
-        if (typeToCheck == null)
-            return false;
-        if (typeToCheck.equals(Object.class))
-            return false;
-        if (typeToCheck.equals(superType))
-            return true;
-        Class[] interfaces = typeToCheck.getInterfaces();
-        for (int i = 0; i < interfaces.length; i++) {
-            if (implementsType(interfaces[i], superType))
-                return true;
-        }
-        return implementsType(typeToCheck.getSuperclass(),superType);
-        
-    }
-    /**
-     * Check if the given type extends a given super type
-     * @param typeToCheck - type supposed to extend an specific type
-     * @param superType - the type to be extended by the type to check
-     * @return <code>true</code> if and only if the super type is above in the type hierarchy of the given type, otherwise <code>false</code>
-     */
-    public static boolean extendsType(Class typeToCheck, Class superType) {
-        if (typeToCheck == null)
-            return false;
-        if (typeToCheck.equals(Object.class))
-            return false;
-        if (typeToCheck.equals(superType))
-            return true;
-        
-        return extendsType(typeToCheck.getSuperclass(),superType);
-    }
-    /**
-     * This method combines the extendsType and implementsType and checks interfaces and classes
-     * @param typeToCheck - type supposed to extend / implement an specific type
-     * @param superType - the type to be extended / implemented by the type to check
-     * @return <code>true</code> if and only if the super type is above in the type hierarchy of the given type, otherwise <code>false</code>
-     */
-    public static boolean isTypeOf(Class typeToCheck, Class superType){
-        return extendsType(typeToCheck,superType)||implementsType(typeToCheck,superType);
-    }
-    
-    /**
-     * @param type - the type to check
-     * @param parameter - the constructor parameter
-     * @return <code>true</code> if and only if the type has a visible constructor with the desired parameters
-     */
-    public static boolean hasDesiredConstructor(Class type, Class[] parameter){
-        try{
-        return type.getConstructor(parameter) != null;
-        
-        }catch (Exception e) {
-            return false;
-        }
-    }
-  
- 
-/**
- * @param <T> the type of the class to instantiate 
- * @param clazz - class object of the type
- * @return a new instance of T
-
- */
-@SuppressWarnings("unchecked")
-public  static <T> T getDefaultInstance(Class<T> clazz) {
-    if(clazz == null)
-        throw new ReflectionException("class must not be null");
-    
-    try{
-    Constructor constructor = clazz.getConstructor(new Class[]{});
-    return (T) constructor.newInstance(new Object[]{});
-    }catch (Exception e) {
-        throw new ReflectionException("can not instantiate type of class "+clazz.getName(),e);
-    }
-}
-
-
-/**
- * This method calls {@link Class#newInstance()} to get a new instance. Use with care!
- * @param clazz - the class to instantiate
- * @return <code>true</code> if an instance could be created, otherwise false;
- */
-public static boolean canCreateInstance(Class clazz){
-    if(clazz == null)
-        return false;
-    if(clazz.isPrimitive())
-        clazz = getPrimitiveWrapper(clazz);
-    try{
-        Object o = clazz.newInstance();
-        return o != null;
-    }catch (Throwable e) {
-        return false;
-    }
-}
-/**
- * Returns the wrapper type for the given primitive type. Wrappers can be
- * easily instantiated via reflection and will be boxed by the VM
- * @param primitive - the primitive type 
- * @return - the corresponding wrapper type
- */
-public static final Class getPrimitiveWrapper(Class primitive) {
-    if(primitive == null )
-        throw new ReflectionException("primitive must not be null");
-    if(!primitive.isPrimitive())
-        throw new ReflectionException("given class is not a primitive");
-                
-    if (primitive == Integer.TYPE)
-        return Integer.class;
-    if (primitive == Float.TYPE)
-        return Float.class;
-    if (primitive == Long.TYPE)
-        return Long.class;
-    if (primitive == Short.TYPE)
-        return Short.class;
-    if (primitive == Byte.TYPE)
-        return Byte.class;
-    if (primitive == Double.TYPE)
-        return Double.class;
-    if (primitive == Boolean.TYPE)
-        return Boolean.class;
-
-    return primitive;
-}
-
-/**
- * Exception wrapper for all thrown exception in the ReflectionUtils methods
- * @author Simon Willnauer
- *
- */
-public static class ReflectionException extends RuntimeException{
-
-    /**
-     * 
-     */
-    private static final long serialVersionUID = -4855060602565614280L;
-
-    /**
-     * @param message -  the exception message
-     * @param cause - the exception root cause
-     */
-    public ReflectionException(String message, Throwable cause) {
-        super(message, cause);
-        // TODO Auto-generated constructor stub
-    }
-
-    /**
-     * @param message - the exception message
-     */
-    public ReflectionException(String message) {
-        super(message);
-        // TODO Auto-generated constructor stub
-    }
-    
-}
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/utils/SimpleObjectPool.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/utils/SimpleObjectPool.java
deleted file mode 100755
index 8da8877..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/utils/SimpleObjectPool.java
+++ /dev/null
@@ -1,176 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.utils;
-
-import java.util.Stack;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReentrantReadWriteLock;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-
-/**
- * A Simple implementation of the {@link org.apache.lucene.gdata.utils.Pool}
- * interface using a {@link java.util.Stack} as a buffer for the pooled objects.
- * This implementation does not provide any timeout mechanismn. Objects will
- * stay inside the pool until the pool is destroyed.
- * <p>
- * If any object will be released e.g. handover to the pool and the pool has
- * already enought objects in the pool the released object will be destroyed. If
- * the pool is empty a new Object will be created.
- * </p>
- * <p>
- * This implementation does not track any references to the objects aquired by
- * any other resource. The objects must be destroyed manually if not released to
- * the pool after aquired.
- * </p>
- * 
- * @author Simon Willnauer
- * @param <Type>
- * 
- */
-public class SimpleObjectPool<Type> implements Pool<Type> {
-    private static final Log LOG = LogFactory.getLog(SimpleObjectPool.class);
-    private volatile boolean isDestroyed = false;
-
-    private final PoolObjectFactory<Type> factory;
-
-    static final int DEFAULTSIZE = 5;
-    static final int MINIMALSIZE = 1;
-
-    private final int size;
-
-    private final Stack<Type> pool;
-
-    private final ReentrantReadWriteLock masterLock = new ReentrantReadWriteLock();
-
-    private final Lock readLock = this.masterLock.readLock();
-
-    private final Lock writeLock = this.masterLock.writeLock();
-
-    /**
-     * Constructs a new {@link SimpleObjectPool} and sets the ObjectFactory and the pool size 
-     * @param size - the maximum size of the pool
-     * @param factory - factory to create and destroy pooled objects
-     * 
-     */
-    public SimpleObjectPool(int size, PoolObjectFactory<Type> factory) {
-        if (factory == null)
-            throw new IllegalArgumentException("Factory must not be null");
-        this.factory = factory;
-        this.size = size < MINIMALSIZE ? MINIMALSIZE : size;
-        this.pool = new Stack<Type>();
-        for (int i = 0; i < this.size; i++) {
-            this.pool.push(this.factory.getInstance());
-        }
-    }
-    /**
-     * @param factory
-     */
-    public SimpleObjectPool(PoolObjectFactory<Type> factory) {
-        this(DEFAULTSIZE,factory);
-        
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.utils.Pool#aquire()
-     */
-    public Type aquire() {
-        // fail if writelock is aquired
-        if (this.readLock.tryLock()) {
-            try {
-                if (this.isDestroyed)
-                    throw new IllegalStateException(
-                            "The pool has already been closed");
-                if (this.pool.isEmpty())
-                    return this.factory.getInstance();
-                return this.pool.pop();
-            } finally {
-                this.readLock.unlock();
-            }
-        }
-        throw new IllegalStateException("The pool has already been closed");
-    }
-
-    /**
-     *
-     * @param type - generic type
-     * @see org.apache.lucene.gdata.utils.Pool#release(Object)
-     */
-    public void release(Type type) {
-        // fail if writelock is aquired
-        if (this.readLock.tryLock()) {
-            try {
-                if (this.pool.size() < this.size && !this.isDestroyed)
-                    this.pool.push(type);
-                else
-                    this.factory.destroyInstance(type);
-            } finally {
-                this.readLock.unlock();
-            }
-            return;
-        }
-        // enable object need to be destoryed
-        this.factory.destroyInstance(type);
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.utils.Pool#getSize()
-     */
-    public int getSize() {
-
-        return this.size;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.utils.Pool#getExpireTime()
-     */
-    public long getExpireTime() {
-
-        return 0;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.utils.Pool#expires()
-     */
-    public boolean expires() {
-
-        return false;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.utils.Pool#destroy()
-     */
-    public void destroy() {
-        this.writeLock.lock();
-        try {
-            if (this.isDestroyed)
-                return;
-            this.isDestroyed = true;
-            LOG.info("Destroy all elements in the pool -- poolsize: "+this.pool.size());
-            for (Type type : this.pool) {
-                this.factory.destroyInstance(type);
-            }
-            this.pool.clear();
-        } finally {
-            this.writeLock.unlock();
-        }
-
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/utils/SimpleSaxErrorHandler.java b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/utils/SimpleSaxErrorHandler.java
deleted file mode 100755
index 194fa54..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/utils/SimpleSaxErrorHandler.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.utils;
-
-import org.xml.sax.ErrorHandler;
-import org.xml.sax.SAXException;
-import org.xml.sax.SAXParseException;
-
-/**
- * For use with Digester to throw exceptions on errors
- * @author Simon Willnauer
- *
- */
-public final class SimpleSaxErrorHandler implements ErrorHandler{
-
-    /**
-     * @see org.xml.sax.ErrorHandler#warning(org.xml.sax.SAXParseException)
-     */
-    public void warning(SAXParseException arg0) throws SAXException {
-        //
-    }
-
-    /**
-     * @see org.xml.sax.ErrorHandler#error(org.xml.sax.SAXParseException)
-     */
-    public void error(SAXParseException arg0) throws SAXException {
-        
-        throw new SAXException("ERROR: Can not parse XML Document -- "+arg0.getMessage(),arg0);
-    }
-
-    /**
-     * @see org.xml.sax.ErrorHandler#fatalError(org.xml.sax.SAXParseException)
-     */
-    public void fatalError(SAXParseException arg0) throws SAXException {
-        throw new SAXException("FATAL ERROR: Can not parse XML Document -- "+arg0.getMessage(),arg0);
-    }
-    
-}
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/utils/package.html b/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/utils/package.html
deleted file mode 100644
index 9e0201c..0000000
--- a/contrib/gdata-server/src/core/java/org/apache/lucene/gdata/utils/package.html
+++ /dev/null
@@ -1,10 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
-<html> 
-<head> 
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
-   <meta name="Author" content="Simon Willnauer"> 
-</head> 
-<body> 
-Utils package
-</body> 
-</html> 
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/data/GDataAccount.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/data/GDataAccount.java
new file mode 100644
index 0000000..4674fd8
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/data/GDataAccount.java
@@ -0,0 +1,340 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+
+package org.apache.lucene.gdata.data;
+
+import java.net.URL;
+import java.util.HashSet;
+import java.util.Set;
+
+import com.google.gdata.data.Person;
+
+/**
+ * The GData-Server system provides acccount to be associated with registered
+ * feed. Every feed has an owner account. The account holder is automaticaly in
+ * role to modify his feeds. One account can own <i>n</i> feeds having <i>m</i>
+ * entries.
+ * <p>
+ * Additionally an account can be in role to modify other feeds, create accounts
+ * or feeds. See {@link AccountRole} for detailed infomation about roles. One
+ * account can also have more than one role. All roles in {@link AccountRole}
+ * can be combined
+ * </p>
+ * <p>
+ * For each account values for author name, author email and author link can be
+ * set at creation time or during an update. These values will be used as the
+ * corresponding values for the feed
+ * {@link org.apache.lucene.gdata.data.ServerBaseFeed#addAuthor(Person)} if no
+ * value for the feed has be specified.
+ * </p>
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class GDataAccount {
+    private String name;
+
+    private String authorname;
+
+    private String authorMail;
+
+    private URL authorLink;
+
+    private String password;
+
+    private Set<AccountRole> roles = new HashSet<AccountRole>(4);
+
+    /**
+     * Creates a new GDataAccount. The default role {@link AccountRole#USER}
+     * will be set.
+     * 
+     */
+    public GDataAccount() {
+        this.roles.add(AccountRole.USER);
+
+    }
+
+    /**
+     * @return - the password
+     */
+    public String getPassword() {
+        return this.password;
+    }
+
+    /**
+     * @param password -
+     *            the account Password
+     */
+    public void setPassword(String password) {
+        this.password = password;
+    }
+
+    /**
+     * @return - the account name
+     */
+    public String getName() {
+        return this.name;
+    }
+
+    /**
+     * @param name
+     *            The name to set.
+     */
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    /**
+     * @return - the http link specified for the author
+     */
+    public URL getAuthorLink() {
+        return this.authorLink;
+    }
+
+    /**
+     * @param authorLink -
+     *            the http link specified for the author
+     */
+    public void setAuthorLink(URL authorLink) {
+        this.authorLink = authorLink;
+    }
+
+    /**
+     * @return - the authors mail address
+     */
+    public String getAuthorMail() {
+        return this.authorMail;
+    }
+
+    /**
+     * @param authorMail -
+     *            the authors mail address
+     */
+    public void setAuthorMail(String authorMail) {
+        this.authorMail = authorMail;
+    }
+
+    /**
+     * @return - the name specified as being the author name
+     */
+    public String getAuthorname() {
+        return this.authorname;
+    }
+
+    /**
+     * @param authorname -
+     *            the name specified as being the author name
+     */
+    public void setAuthorname(String authorname) {
+        this.authorname = authorname;
+    }
+
+    /**
+     * Adds the given role to the role list
+     * 
+     * @param role -
+     *            the role to add to the role list
+     */
+    public void setRole(AccountRole role) {
+        if (role == null)
+            return;
+        this.roles.add(role);
+    }
+
+    /**
+     * @return - the set containing all roles
+     */
+    public Set<AccountRole> getRoles() {
+        return this.roles;
+    }
+
+    /**
+     * @param role -
+     *            the role to check
+     * @return <code>true</code> if the role list contains the given role
+     */
+    public boolean isUserInRole(AccountRole role) {
+        if (role == null)
+            return false;
+        return this.roles.contains(role);
+    }
+
+    /**
+     * @see GDataAccount#setRolesAsInt(int)
+     * @return - the integer representation for the user roles
+     */
+    public int getRolesAsInt() {
+        // 1 as the Userrole is always set
+        int bits = 1;
+        for (AccountRole role : this.roles) {
+            if (role == AccountRole.ENTRYAMINISTRATOR)
+                bits ^= 2;
+            else if (role == AccountRole.FEEDAMINISTRATOR)
+                bits ^= 4;
+            else if (role == AccountRole.USERADMINISTRATOR)
+                bits ^= 8;
+
+        }
+        return bits;
+
+    }
+
+    /**
+     * Sets the roles from a int representation.
+     * <ol>
+     * <li>The fist bit set indicates a {@link AccountRole#USER} - int value 1</li>
+     * <li>The second bit set indicates a {@link AccountRole#ENTRYAMINISTRATOR} -
+     * int value 2</li>
+     * <li>The third bit set indicates a {@link AccountRole#FEEDAMINISTRATOR} -
+     * int value 4</li>
+     * <li>The forth bit set indicates a {@link AccountRole#USERADMINISTRATOR} -
+     * int value 8</li>
+     * <ol>
+     * This method will only set roles, will not remove roles! A combination of
+     * roles is also possible e.g. the int value 6 combines
+     * {@link AccountRole#ENTRYAMINISTRATOR} and
+     * {@link AccountRole#FEEDAMINISTRATOR}.
+     * 
+     * @param i -
+     *            the integer used to set the roles
+     */
+    public void setRolesAsInt(int i) {
+
+        if ((i & 2) > 0)
+            this.roles.add(AccountRole.ENTRYAMINISTRATOR);
+        if ((i & 4) > 0)
+            this.roles.add(AccountRole.FEEDAMINISTRATOR);
+        if ((i & 8) > 0)
+            this.roles.add(AccountRole.USERADMINISTRATOR);
+
+    }
+
+    /**
+     * @see java.lang.Object#equals(java.lang.Object)
+     */
+    public boolean equals(Object o) {
+        if(this.name == null)
+            return super.equals(o);
+        if(o == null)
+            return false;
+        if (this == o)
+            return true;
+        if (!(o instanceof GDataAccount))
+            return false;
+        GDataAccount toCompare = (GDataAccount) o;
+        if (this.name.equals(toCompare.name))
+            return true;
+        return false;
+
+    }
+
+    /**
+     * @see java.lang.Object#hashCode()
+     */
+    public int hashCode() {
+        if(this.name == null)
+            return super.hashCode();
+        int ret = 37;
+        ret = 9 * ret + this.name.hashCode();
+        return ret;
+    }
+
+    /**
+     * Checks the requiered values for creating an account are set. Required
+     * values are <tt>name</tt> and <tt>password</tt> the minimum length of
+     * these values is 6.
+     * 
+     * @return <code>true</code> if an only if password and name are not <code>null</code> and the length is <tt>> 5</tt>
+     */
+    public boolean requiredValuesSet() {
+        return (this.name != null && this.password != null
+                && this.name.length() > 5 && this.password.length() > 5);
+    }
+    
+    /**
+     * @see java.lang.Object#toString()
+     */
+    public String toString(){
+        StringBuilder builder = new StringBuilder("GdataAccount: ");
+        builder.append("name: ").append(this.name);
+        builder.append(" password: ").append((this.password!= null?" length: "+this.password.length():null));
+        builder.append(" author: ").append(this.authorname);
+        builder.append(" author email: ").append(this.authorMail);
+        builder.append(" author link: ").append(this.authorLink!=null?"":this.authorLink);
+        return builder.toString();
+    }
+    
+    /**
+     * checks whether the given integer matches the account role.
+     * @param intRole - integer representation of a role
+     * @param role - the account role to match
+     * @return <code>true</code> if and only if the given roles match, otherwise <code>false</code>
+     */
+    public static boolean isInRole(int intRole, AccountRole role){
+        if(role == AccountRole.USER)
+            return (intRole&1)>0;
+        if (role == AccountRole.ENTRYAMINISTRATOR)
+            return (intRole&2) >0 ;
+        else if (role == AccountRole.FEEDAMINISTRATOR)
+            return (intRole&4) >0 ;
+        else if (role == AccountRole.USERADMINISTRATOR)
+            return (intRole&8) >0 ;
+        return false;
+    }
+    
+    /**
+     * @return - a new Administrator account 
+     */
+    public static final GDataAccount createAdminAccount(){
+        GDataAccount retVal = new GDataAccount();
+        retVal.setName("administrator");
+        retVal.setPassword("password");
+        retVal.setRole(AccountRole.USERADMINISTRATOR);
+        retVal.setRole(AccountRole.FEEDAMINISTRATOR);
+        retVal.setRole(AccountRole.ENTRYAMINISTRATOR);
+        return retVal;
+    }
+    
+
+
+    /**
+     * This enum respesents all account roles an account can have.
+     * 
+     * @author Simon Willnauer
+     * 
+     */
+    public enum AccountRole {
+
+        /**
+         * Can create / alter user
+         */
+        USERADMINISTRATOR,
+
+        /**
+         * Can create / alter feeds
+         */
+        FEEDAMINISTRATOR,
+        /**
+         * Can create / alter entries
+         */
+        ENTRYAMINISTRATOR,
+        /**
+         * can create / alter his own feed entries
+         */
+        USER
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/data/ServerBaseEntry.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/data/ServerBaseEntry.java
new file mode 100644
index 0000000..1f983c2
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/data/ServerBaseEntry.java
@@ -0,0 +1,642 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.data;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.Reader;
+import java.util.List;
+import java.util.Set;
+
+import org.apache.lucene.gdata.server.registry.ProvidedService;
+
+import com.google.gdata.client.Service;
+import com.google.gdata.data.BaseEntry;
+import com.google.gdata.data.Content;
+import com.google.gdata.data.DateTime;
+import com.google.gdata.data.Entry;
+import com.google.gdata.data.Extension;
+import com.google.gdata.data.ExtensionProfile;
+import com.google.gdata.data.Link;
+import com.google.gdata.data.Source;
+import com.google.gdata.data.TextConstruct;
+import com.google.gdata.util.ParseException;
+import com.google.gdata.util.ServiceException;
+import com.google.gdata.util.XmlBlob;
+import com.google.gdata.util.common.xml.XmlWriter;
+
+/**
+ * The GData-Server uses the GDATA-Client API for an interal representation of
+ * entries. These entities have dynamic elements like Links being generated
+ * using the requested URL.<br/> Some components of the server also need
+ * additional infomation like the service type
+ * {@link org.apache.lucene.gdata.server.registry.ProvidedService} of the entry
+ * and the feedid a entry belongs to. All these information are
+ * encapsulated in the ServerBaseEntry decorating a concrete sub class of <tt>BaseEntry</tt>. The actual
+ * {@link com.google.gdata.data.BaseEntry} will be passed to the ServerBaseEntry
+ * at creation time via the constructor. To use the ServerBaseFeed for generation a provided format like
+ * RSS/ATOM the corresponding {@link com.google.gdata.data.ExtensionProfile} has
+ * to be provided to the generation method.
+ * <p> For a general overview of the generic BaseFeed class see the gdata-client API documentation</p>
+ * 
+ * @see com.google.gdata.data.ExtensionProfile
+ * @see com.google.gdata.data.BaseFeed
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class ServerBaseEntry {
+    private String feedId;
+
+    private String serviceType;
+
+    private ProvidedService serviceConfig;
+    private BaseEntry entry;
+    private static final int DEFAULTVERSION = 1;
+    private int version;
+
+    
+   
+    /**
+     * @return - the provided service for the source entry 
+     */
+    public ProvidedService getServiceConfig() {
+        return this.serviceConfig;
+    }
+
+    /**
+     * @param serviceConfig - the provided service for the source entry
+     */
+    public void setServiceConfig(ProvidedService serviceConfig) {
+        this.serviceConfig = serviceConfig;
+        if (serviceConfig != null)
+            this.serviceType = serviceConfig.getName();
+    }
+
+    /**
+     * @return - the name of the service related of the feed containing this entry
+     */
+    public String getServiceType() {
+        return this.serviceType;
+    }
+
+    /**
+     *  Constructs a new ServerBaseEntry.
+     *  To provide a concrete entry to decorate after object creation use {@link ServerBaseEntry#setEntry(BaseEntry)}  
+     *  
+     */
+    @SuppressWarnings("unchecked")
+    public ServerBaseEntry() {
+        this(new Entry());
+        
+    }
+
+    /**
+     * @param arg0 - the source entry
+     */
+    @SuppressWarnings("unchecked")
+    public ServerBaseEntry(BaseEntry arg0) {
+        this.entry = arg0;
+        this.setVersion(DEFAULTVERSION);
+    }
+
+
+    /**
+     * @param link - a link added to this entry
+     */
+    @SuppressWarnings("unchecked")
+    public void addLink(final Link link) {
+        this.entry.getLinks().add(link);
+    }
+
+    /**
+     * @return - the id of the owning feed
+     */
+    public String getFeedId() {
+        return this.feedId;
+    }
+
+    /**
+     * @param feedId - the id of the owning feed
+     */
+    public void setFeedId(String feedId) {
+        this.feedId = feedId;
+    }
+    /**
+     * @return - the decorated entry
+     */
+    public BaseEntry getEntry(){
+        return this.entry;
+    }
+    /**
+     * @param entry - the entry to decorate
+     */
+    public void setEntry(BaseEntry entry){
+        this.entry = entry;
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#addHtmlLink(java.lang.String, java.lang.String, java.lang.String)
+     */
+    public void addHtmlLink(String arg0, String arg1, String arg2) {
+        
+        this.entry.addHtmlLink(arg0, arg1, arg2);
+    }
+
+
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#generateAtom(com.google.gdata.util.common.xml.XmlWriter, com.google.gdata.data.ExtensionProfile)
+     */
+    
+    public void generateAtom(XmlWriter arg0, ExtensionProfile arg1) throws IOException {
+        
+        this.entry.generateAtom(arg0, arg1);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#generateRss(com.google.gdata.util.common.xml.XmlWriter, com.google.gdata.data.ExtensionProfile)
+     */
+    
+    public void generateRss(XmlWriter arg0, ExtensionProfile arg1) throws IOException {
+        
+        this.entry.generateRss(arg0, arg1);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getAuthors()
+     */
+    
+    public List getAuthors() {
+        
+        return this.entry.getAuthors();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getCanEdit()
+     */
+    
+    public boolean getCanEdit() {
+        
+        return this.entry.getCanEdit();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getCategories()
+     */
+    
+    public Set getCategories() {
+        
+        return this.entry.getCategories();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getContent()
+     */
+    
+    public Content getContent() {
+        
+        return this.entry.getContent();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getContributors()
+     */
+    
+    public List getContributors() {
+        
+        return this.entry.getContributors();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getEditLink()
+     */
+    
+    public Link getEditLink() {
+        
+        return this.entry.getEditLink();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getHtmlLink()
+     */
+    
+    public Link getHtmlLink() {
+        
+        return this.entry.getHtmlLink();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getId()
+     */
+    
+    public String getId() {
+        
+        return this.entry.getId();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getLink(java.lang.String, java.lang.String)
+     */
+    
+    public Link getLink(String arg0, String arg1) {
+        
+        return this.entry.getLink(arg0, arg1);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getLinks()
+     */
+    
+    public List getLinks() {
+        
+        return this.entry.getLinks();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getPublished()
+     */
+    
+    public DateTime getPublished() {
+        
+        return this.entry.getPublished();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getRights()
+     */
+    
+    public TextConstruct getRights() {
+        
+        return this.entry.getRights();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getSelf()
+     */
+    
+    public BaseEntry getSelf() throws IOException, ServiceException {
+        
+        return this.entry.getSelf();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getSelfLink()
+     */
+    
+    public Link getSelfLink() {
+        
+        return this.entry.getSelfLink();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getService()
+     */
+    
+    public Service getService() {
+        
+        return this.entry.getService();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getSource()
+     */
+    
+    public Source getSource() {
+        
+        return this.entry.getSource();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getSummary()
+     */
+    
+    public TextConstruct getSummary() {
+        
+        return this.entry.getSummary();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getTitle()
+     */
+    
+    public TextConstruct getTitle() {
+        
+        return this.entry.getTitle();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getUpdated()
+     */
+    
+    public DateTime getUpdated() {
+        
+        return this.entry.getUpdated();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#getVersionId()
+     */
+    
+    public String getVersionId() {
+        
+        return this.entry.getVersionId();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#isDraft()
+     */
+    
+    public boolean isDraft() {
+        
+        return this.entry.isDraft();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#parseAtom(com.google.gdata.data.ExtensionProfile, java.io.InputStream)
+     */
+    
+    public void parseAtom(ExtensionProfile arg0, InputStream arg1) throws IOException, ParseException {
+        
+        this.entry.parseAtom(arg0, arg1);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#parseAtom(com.google.gdata.data.ExtensionProfile, java.io.Reader)
+     */
+    
+    public void parseAtom(ExtensionProfile arg0, Reader arg1) throws IOException, ParseException {
+        
+        this.entry.parseAtom(arg0, arg1);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#setCanEdit(boolean)
+     */
+    
+    public void setCanEdit(boolean arg0) {
+        
+        this.entry.setCanEdit(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#setContent(com.google.gdata.data.Content)
+     */
+    
+    public void setContent(Content arg0) {
+        
+        this.entry.setContent(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#setContent(com.google.gdata.data.TextConstruct)
+     */
+    
+    public void setContent(TextConstruct arg0) {
+        
+        this.entry.setContent(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#setDraft(boolean)
+     */
+    
+    public void setDraft(boolean arg0) {
+        
+        this.entry.setDraft(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#setId(java.lang.String)
+     */
+    
+    public void setId(String arg0) {
+        
+        this.entry.setId(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#setPublished(com.google.gdata.data.DateTime)
+     */
+    
+    public void setPublished(DateTime arg0) {
+        
+        this.entry.setPublished(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#setRights(com.google.gdata.data.TextConstruct)
+     */
+    
+    public void setRights(TextConstruct arg0) {
+        
+        this.entry.setRights(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#setService(com.google.gdata.client.Service)
+     */
+    
+    public void setService(Service arg0) {
+        
+        this.entry.setService(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#setSource(com.google.gdata.data.Source)
+     */
+    
+    public void setSource(Source arg0) {
+        
+        this.entry.setSource(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#setSummary(com.google.gdata.data.TextConstruct)
+     */
+    
+    public void setSummary(TextConstruct arg0) {
+        
+        this.entry.setSummary(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#setTitle(com.google.gdata.data.TextConstruct)
+     */
+    
+    public void setTitle(TextConstruct arg0) {
+        
+        this.entry.setTitle(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#setUpdated(com.google.gdata.data.DateTime)
+     */
+    
+    public void setUpdated(DateTime arg0) {
+        
+        this.entry.setUpdated(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#setVersionId(java.lang.String)
+     */
+    
+    public void setVersionId(String arg0) {
+        
+        this.entry.setVersionId(arg0);
+    }
+
+ 
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#addExtension(com.google.gdata.data.Extension)
+     */
+    
+    public void addExtension(Extension arg0) {
+        
+        this.entry.addExtension(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#addRepeatingExtension(com.google.gdata.data.Extension)
+     */
+    
+    public void addRepeatingExtension(Extension arg0) {
+        
+        this.entry.addRepeatingExtension(arg0);
+    }
+
+   
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#generateCumulativeXmlBlob(com.google.gdata.data.ExtensionProfile)
+     */
+    
+    public XmlBlob generateCumulativeXmlBlob(ExtensionProfile arg0) throws IOException {
+        
+        return this.entry.generateCumulativeXmlBlob(arg0);
+    }
+
+  
+   
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#getRepeatingExtension(java.lang.Class)
+     */
+    
+    public <T extends Extension> List<T> getRepeatingExtension(Class<T> arg0) {
+        
+        return this.entry.getRepeatingExtension(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#getXmlBlob()
+     */
+    
+    public XmlBlob getXmlBlob() {
+        
+        return this.entry.getXmlBlob();
+    }
+
+  
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#parseCumulativeXmlBlob(com.google.gdata.util.XmlBlob, com.google.gdata.data.ExtensionProfile, java.lang.Class)
+     */
+    
+    public void parseCumulativeXmlBlob(XmlBlob arg0, ExtensionProfile arg1, Class arg2) throws IOException, ParseException {
+        
+        this.entry.parseCumulativeXmlBlob(arg0, arg1, arg2);
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#removeExtension(java.lang.Class)
+     */
+    
+    public void removeExtension(Class arg0) {
+        
+        this.entry.removeExtension(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#removeExtension(com.google.gdata.data.Extension)
+     */
+    
+    public void removeExtension(Extension arg0) {
+        
+        this.entry.removeExtension(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#removeRepeatingExtension(com.google.gdata.data.Extension)
+     */
+    
+    public void removeRepeatingExtension(Extension arg0) {
+        
+        this.entry.removeRepeatingExtension(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#setExtension(com.google.gdata.data.Extension)
+     */
+    
+    public void setExtension(Extension arg0) {
+        
+        this.entry.setExtension(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#setXmlBlob(com.google.gdata.util.XmlBlob)
+     */
+    
+    public void setXmlBlob(XmlBlob arg0) {
+        
+        this.entry.setXmlBlob(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseEntry#declareExtensions(com.google.gdata.data.ExtensionProfile)
+     */
+    
+    public void declareExtensions(ExtensionProfile arg0) {
+        this.entry.declareExtensions(arg0);
+    }
+
+    /**
+     * @return Returns the version.
+     */
+    public int getVersion() {
+        return this.version;
+    }
+
+    /**
+     * @param version The version to set.
+     */
+    public void setVersion(int version) {
+        if(version < this.version)
+            throw new IllegalArgumentException("Version must be greater than the current version -- current version: "+this.version);
+        this.version = version;
+        setVersionId(""+this.version);
+    }
+    
+    
+    
+    
+    
+    
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/data/ServerBaseFeed.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/data/ServerBaseFeed.java
new file mode 100644
index 0000000..5ae81a2
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/data/ServerBaseFeed.java
@@ -0,0 +1,684 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.data;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.Reader;
+import java.util.Collection;
+import java.util.List;
+import java.util.Set;
+
+import org.apache.lucene.gdata.server.registry.ProvidedService;
+
+import com.google.gdata.client.Service;
+import com.google.gdata.data.BaseEntry;
+import com.google.gdata.data.BaseFeed;
+import com.google.gdata.data.Category;
+import com.google.gdata.data.DateTime;
+import com.google.gdata.data.Extension;
+import com.google.gdata.data.ExtensionProfile;
+import com.google.gdata.data.Feed;
+import com.google.gdata.data.Generator;
+import com.google.gdata.data.Link;
+import com.google.gdata.data.Person;
+import com.google.gdata.data.TextConstruct;
+import com.google.gdata.util.ParseException;
+import com.google.gdata.util.ServiceException;
+import com.google.gdata.util.XmlBlob;
+import com.google.gdata.util.common.xml.XmlWriter;
+
+/**
+ * The GData-Server uses the GDATA-Client API for an interal representation of
+ * entries. These entities have dynamic elements like Links being generated
+ * using the requested URL.<br/> Some components of the server also need
+ * additional infomation like the service type
+ * {@link org.apache.lucene.gdata.server.registry.ProvidedService} of the feed.
+ * All these information are
+ * encapsulated in the ServerBaseFeed decoration a concrete subl class of <tt>BaseFeed</tt>. The type of the 
+ * {@link com.google.gdata.data.BaseEntry} contained it this feed will be passed to the ServerBaseFeed
+ * at creation time via the constructor. To retrieve the original entry call
+ * {@link ServerBaseFeed#getFeed()} returns a
+ * {@link com.google.gdata.data.BaseFeed} instance which can be casted into the
+ * actual type. To use the ServerBaseEntry for generation a provided format like
+ * RSS/ATOM the corresponding {@link com.google.gdata.data.ExtensionProfile} has
+ * to be provided to the generation method.
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class ServerBaseFeed  {
+
+    private String serviceType;
+
+    private ProvidedService serviceConfig;
+    
+    private GDataAccount account;
+    
+    private BaseFeed feed;
+    /**
+     * @return Returns the account.
+     */
+    public GDataAccount getAccount() {
+        return this.account;
+    }
+
+    /**
+     * @param account The account to set.
+     */
+    public void setAccount(GDataAccount account) {
+        this.account = account;
+    }
+
+    /**
+     * Creates a new ServerBaseFeed and decorates a basic instance of {@link Feed}
+     */
+    @SuppressWarnings("unchecked")
+    public ServerBaseFeed() {
+        this.feed = new Feed();
+        
+    }
+    /**
+     * @param feed - the feed to decorate
+     *            
+     */
+    @SuppressWarnings("unchecked")
+    public ServerBaseFeed(BaseFeed feed) {
+        this.feed = feed;
+        
+    }
+
+    /**
+     * @return Returns the feed.
+     */
+    public BaseFeed getFeed() {
+        return this.feed;
+    }
+
+    /**
+     * @param feed The feed to set.
+     */
+    public void setFeed(BaseFeed feed) {
+        this.feed = feed;
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#declareExtensions(com.google.gdata.data.ExtensionProfile)
+     */
+    public void declareExtensions(ExtensionProfile extProfile) {
+
+      this.feed.declareExtensions(extProfile);
+    }
+
+    /**
+     * @param link -
+     *            a link added to the link list of the feed
+     */
+    @SuppressWarnings("unchecked")
+    public void addLink(final Link link) {
+        this.feed.getLinks().add(link);
+    }
+
+    /**
+     * @param collection -
+     *            a collection of <code>Link</code> instance to be added to
+     *            the feeds link list
+     */
+    public void addLinks(final Collection<Link> collection) {
+        this.feed.getLinks().addAll(collection);
+    }
+
+    /**
+     * @return - the name of the service related of the feed represented by this
+     *         ServerBaseFeed
+     */
+    public String getServiceType() {
+        return this.serviceType;
+    }
+
+    /**
+     * @param serviceType -
+     *            the name of the service related of the feed represented by
+     *            this ServerBaseFeed
+     */
+    public void setServiceType(String serviceType) {
+        this.serviceType = serviceType;
+    }
+
+    /**
+     * @return - the provided service
+     */
+    public ProvidedService getServiceConfig() {
+        return this.serviceConfig;
+    }
+
+    /**
+     * @param serviceConfig - -
+     *            the provided service
+     */
+    public void setServiceConfig(ProvidedService serviceConfig) {
+        this.serviceConfig = serviceConfig;
+        if (serviceConfig != null)
+            this.serviceType = this.serviceConfig.getName();
+
+    }
+
+    /**
+     * @param person -
+     *            adds an author to the feed
+     */
+    public void addAuthor(final Person person) {
+        this.feed.getAuthors().add(person);
+    }
+    
+    /**
+     * @see com.google.gdata.data.BaseFeed#createEntry()
+     */
+    
+    public BaseEntry createEntry() {
+        
+        return this.feed.createEntry();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#generateAtom(com.google.gdata.util.common.xml.XmlWriter, com.google.gdata.data.ExtensionProfile)
+     */
+    
+    public void generateAtom(XmlWriter arg0, ExtensionProfile arg1) throws IOException {
+        
+        this.feed.generateAtom(arg0, arg1);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#generateAtomColl(com.google.gdata.util.common.xml.XmlWriter)
+     */
+    
+    public void generateAtomColl(XmlWriter arg0) throws IOException {
+        
+        this.feed.generateAtomColl(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#generateRss(com.google.gdata.util.common.xml.XmlWriter, com.google.gdata.data.ExtensionProfile)
+     */
+    
+    public void generateRss(XmlWriter arg0, ExtensionProfile arg1) throws IOException {
+        
+        this.feed.generateRss(arg0, arg1);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#getCanPost()
+     */
+    
+    public boolean getCanPost() {
+        
+        return this.feed.getCanPost();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#getEntries()
+     */
+    
+    public List getEntries() {
+        
+        return this.feed.getEntries();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#getEntryPostLink()
+     */
+    
+    public Link getEntryPostLink() {
+        
+        return this.feed.getEntryPostLink();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#getItemsPerPage()
+     */
+    
+    public int getItemsPerPage() {
+        
+        return this.feed.getItemsPerPage();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#getSelf()
+     */
+    
+    public BaseFeed getSelf() throws IOException, ServiceException {
+        
+        return this.feed.getSelf();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#getSelfLink()
+     */
+    
+    public Link getSelfLink() {
+        
+        return this.feed.getSelfLink();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#getService()
+     */
+    
+    public Service getService() {
+        
+        return this.feed.getService();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#getStartIndex()
+     */
+    
+    public int getStartIndex() {
+        
+        return this.feed.getStartIndex();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#getTotalResults()
+     */
+    
+    public int getTotalResults() {
+        
+        return this.feed.getTotalResults();
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#insert(E)
+     */
+    
+    public BaseEntry insert(BaseEntry arg0) throws ServiceException, IOException {
+        
+        return this.feed.insert(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#parseAtom(com.google.gdata.data.ExtensionProfile, java.io.InputStream)
+     */
+    
+    public void parseAtom(ExtensionProfile arg0, InputStream arg1) throws IOException, ParseException {
+        
+        this.feed.parseAtom(arg0, arg1);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#parseAtom(com.google.gdata.data.ExtensionProfile, java.io.Reader)
+     */
+    
+    public void parseAtom(ExtensionProfile arg0, Reader arg1) throws IOException, ParseException {
+        
+        this.feed.parseAtom(arg0, arg1);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#setCanPost(boolean)
+     */
+    
+    public void setCanPost(boolean arg0) {
+        
+        this.feed.setCanPost(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#setItemsPerPage(int)
+     */
+    
+    public void setItemsPerPage(int arg0) {
+        
+        this.feed.setItemsPerPage(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#setService(com.google.gdata.client.Service)
+     */
+    
+    public void setService(Service arg0) {
+        
+        this.feed.setService(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#setStartIndex(int)
+     */
+    
+    public void setStartIndex(int arg0) {
+        
+        this.feed.setStartIndex(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.BaseFeed#setTotalResults(int)
+     */
+    
+    public void setTotalResults(int arg0) {
+        
+        this.feed.setTotalResults(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#addHtmlLink(java.lang.String, java.lang.String, java.lang.String)
+     */
+    
+    public void addHtmlLink(String arg0, String arg1, String arg2) {
+        
+        this.feed.addHtmlLink(arg0, arg1, arg2);
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#getAuthors()
+     */
+    
+    public List<Person> getAuthors() {
+        
+        return this.feed.getAuthors();
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#getCategories()
+     */
+    
+    public Set<Category> getCategories() {
+        
+        return this.feed.getCategories();
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#getContributors()
+     */
+    
+    public List<Person> getContributors() {
+        
+        return this.feed.getContributors();
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#getGenerator()
+     */
+    
+    public Generator getGenerator() {
+        
+        return this.feed.getGenerator();
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#getHtmlLink()
+     */
+    
+    public Link getHtmlLink() {
+        
+        return this.feed.getHtmlLink();
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#getIcon()
+     */
+    
+    public String getIcon() {
+        
+        return this.feed.getIcon();
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#getId()
+     */
+    
+    public String getId() {
+        
+        return this.feed.getId();
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#getLink(java.lang.String, java.lang.String)
+     */
+    
+    public Link getLink(String arg0, String arg1) {
+        
+        return this.feed.getLink(arg0, arg1);
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#getLinks()
+     */
+    
+    public List<Link> getLinks() {
+        
+        return this.feed.getLinks();
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#getLogo()
+     */
+    
+    public String getLogo() {
+        
+        return this.feed.getLogo();
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#getRights()
+     */
+    
+    public TextConstruct getRights() {
+        
+        return this.feed.getRights();
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#getSubtitle()
+     */
+    
+    public TextConstruct getSubtitle() {
+        
+        return this.feed.getSubtitle();
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#getTitle()
+     */
+    
+    public TextConstruct getTitle() {
+        
+        return this.feed.getTitle();
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#getUpdated()
+     */
+    
+    public DateTime getUpdated() {
+        
+        return this.feed.getUpdated();
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#setGenerator(com.google.gdata.data.Generator)
+     */
+    
+    public void setGenerator(Generator arg0) {
+        
+        this.feed.setGenerator(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#setIcon(java.lang.String)
+     */
+    
+    public void setIcon(String arg0) {
+        
+        this.feed.setIcon(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#setId(java.lang.String)
+     */
+    
+    public void setId(String arg0) {
+        
+        this.feed.setId(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#setLogo(java.lang.String)
+     */
+    
+    public void setLogo(String arg0) {
+        
+        this.feed.setLogo(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#setRights(com.google.gdata.data.TextConstruct)
+     */
+    
+    public void setRights(TextConstruct arg0) {
+        
+        this.feed.setRights(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#setSubtitle(com.google.gdata.data.TextConstruct)
+     */
+    
+    public void setSubtitle(TextConstruct arg0) {
+        
+        this.feed.setSubtitle(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#setTitle(com.google.gdata.data.TextConstruct)
+     */
+    
+    public void setTitle(TextConstruct arg0) {
+        
+        this.feed.setTitle(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.Source#setUpdated(com.google.gdata.data.DateTime)
+     */
+    
+    public void setUpdated(DateTime arg0) {
+        
+        this.feed.setUpdated(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#addExtension(com.google.gdata.data.Extension)
+     */
+    
+    public void addExtension(Extension arg0) {
+        
+        this.feed.addExtension(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#addRepeatingExtension(com.google.gdata.data.Extension)
+     */
+    
+    public void addRepeatingExtension(Extension arg0) {
+        
+        this.feed.addRepeatingExtension(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#getExtension(java.lang.Class)
+     */
+    
+    public <T extends Extension> T getExtension(Class<T> arg0) {
+        
+        return this.feed.getExtension(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#getRepeatingExtension(java.lang.Class)
+     */
+    
+    public <T extends Extension> List<T> getRepeatingExtension(Class<T> arg0) {
+        
+        return this.feed.getRepeatingExtension(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#getXmlBlob()
+     */
+    
+    public XmlBlob getXmlBlob() {
+        
+        return this.feed.getXmlBlob();
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#parseCumulativeXmlBlob(com.google.gdata.util.XmlBlob, com.google.gdata.data.ExtensionProfile, java.lang.Class)
+     */
+    
+    public void parseCumulativeXmlBlob(XmlBlob arg0, ExtensionProfile arg1, Class arg2) throws IOException, ParseException {
+        
+        this.feed.parseCumulativeXmlBlob(arg0, arg1, arg2);
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#removeExtension(java.lang.Class)
+     */
+    
+    public void removeExtension(Class arg0) {
+        
+        this.feed.removeExtension(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#removeExtension(com.google.gdata.data.Extension)
+     */
+    
+    public void removeExtension(Extension arg0) {
+        
+        this.feed.removeExtension(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#removeRepeatingExtension(com.google.gdata.data.Extension)
+     */
+    
+    public void removeRepeatingExtension(Extension arg0) {
+        
+        this.feed.removeRepeatingExtension(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#setExtension(com.google.gdata.data.Extension)
+     */
+    
+    public void setExtension(Extension arg0) {
+        
+        this.feed.setExtension(arg0);
+    }
+
+    /**
+     * @see com.google.gdata.data.ExtensionPoint#setXmlBlob(com.google.gdata.util.XmlBlob)
+     */
+    
+    public void setXmlBlob(XmlBlob arg0) {
+        
+        this.feed.setXmlBlob(arg0);
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/data/package.html b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/data/package.html
new file mode 100644
index 0000000..10c3ef5
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/data/package.html
@@ -0,0 +1,10 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
+<html> 
+<head> 
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
+   <meta name="Author" content="Simon Willnauer"> 
+</head> 
+<body> 
+Contains classes for the internal representation of GData feeds and entries. 
+</body> 
+</html> 
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/package.html b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/package.html
new file mode 100644
index 0000000..0ea30d2
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/package.html
@@ -0,0 +1 @@
+<html><body>Top-level package.</body></html> 
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/GDataSearcher.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/GDataSearcher.java
new file mode 100755
index 0000000..f4bd72b
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/GDataSearcher.java
@@ -0,0 +1,45 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.search;
+
+import java.io.IOException;
+import java.util.List;
+
+import org.apache.lucene.search.Query;
+
+/**
+ * @author Simon Willnauer
+ * @param <T> 
+ *
+ */
+public interface GDataSearcher <T>{
+
+    /**
+     * executes an Query and returns a list of defined return values of type T
+     * @param query - the query to apply to the searcher
+     * @param hitcount - the amount of hits returned by this search
+     * @param offset - the hit count offset 
+     * @param feedId 
+     * @return List of T
+     * @throws IOException - if the underlying lucene searcher throws an IO Exception 
+     */
+    public List<T> search(Query query,int hitcount, int offset, String feedId)throws IOException;
+    /**
+     * Destroys this Searcher
+     */
+    public abstract void close();
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/SearchComponent.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/SearchComponent.java
new file mode 100755
index 0000000..407944b
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/SearchComponent.java
@@ -0,0 +1,39 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.search;
+
+import org.apache.lucene.gdata.server.registry.ProvidedService;
+import org.apache.lucene.gdata.server.registry.ServerComponent;
+
+/**
+ * TODO document this when Search comes into play
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public interface SearchComponent extends ServerComponent {
+    /**
+     * TODO document this when Search comes into play
+     * 
+     * @param service
+     * 
+     * @return a GDataSearcher
+     */
+    public abstract GDataSearcher<String> getServiceSearcher(ProvidedService service);
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/StandardGdataSearcher.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/StandardGdataSearcher.java
new file mode 100755
index 0000000..34db075
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/StandardGdataSearcher.java
@@ -0,0 +1,136 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.search;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.gdata.search.index.IndexDocument;
+import org.apache.lucene.gdata.utils.ReferenceCounter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.Hits;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.QueryFilter;
+import org.apache.lucene.search.TermQuery;
+
+/**
+ * Standard implementation of
+ * {@link org.apache.lucene.gdata.search.GDataSearcher}
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class StandardGdataSearcher implements GDataSearcher<String> {
+    private final AtomicBoolean isClosed = new AtomicBoolean(false);
+
+    private final ReferenceCounter<IndexSearcher> searcher;
+
+    private static final Map<String, QueryFilter> queryFilterCache = new HashMap<String, QueryFilter>();
+
+    /** constructs a new GdataSearcher
+     * @param searcher - the current lucene searcher instance
+     */
+    public StandardGdataSearcher(ReferenceCounter<IndexSearcher> searcher) {
+        if (searcher == null)
+            throw new IllegalArgumentException("searcher must not be null");
+
+        this.searcher = searcher;
+
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.search.GDataSearcher#search(org.apache.lucene.search.Query,
+     *      int, int, java.lang.String)
+     */
+    public List<String> search(Query query, int hitcount, int offset,
+            String feedId) throws IOException {
+        if (hitcount < 0 || offset < 0)
+            throw new IllegalArgumentException(
+                    "hit count and offset must not be less than 0");
+        if (this.isClosed.get())
+            throw new IllegalStateException("Searcher is closed");
+        if (query == null)
+            throw new RuntimeException("query is null can not apply search");
+        if (feedId == null)
+            throw new IllegalArgumentException("feed id must not be null");
+        QueryFilter filter = null;
+        synchronized (queryFilterCache) {
+            filter = queryFilterCache.get(feedId);
+        
+        if (filter == null)
+            filter = new QueryFilter(new TermQuery(new Term(
+                    IndexDocument.FIELD_FEED_ID, feedId)));
+            queryFilterCache.put(feedId, filter);
+        }
+        IndexSearcher indexSearcher = this.searcher.get();
+        Hits hits = indexSearcher.search(query, filter);
+        
+        return collectHits(hits, hitcount, offset);
+
+    }
+
+    protected List<String> collectHits(Hits hits, int hitcount, int offset)
+            throws IOException {
+        int hitLength = hits.length();
+        if (hitLength < offset || hitLength == 0)
+            return new ArrayList<String>(0);
+        if (offset > 0)
+            --offset;
+        /*
+         * include the offset
+         */
+        int remainingHits = hitLength - offset;
+        int returnSize = remainingHits > hitcount ? hitcount : remainingHits;
+        List<String> retVal = new ArrayList<String>(returnSize);
+        for (int i = 0; i < returnSize; i++) {
+            Document doc = hits.doc(offset++);
+            /*
+             * the entry id is sufficient to retrieve the entry from the
+             * storage. the result will be ordered by score (default)
+             */
+            Field field = doc.getField(IndexDocument.FIELD_ENTRY_ID);
+            retVal.add(i, field.stringValue());
+        }
+        return retVal;
+
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.search.GDataSearcher#close()
+     */
+    public void close() {
+        this.isClosed.set(true);
+        this.searcher.decrementRef();
+
+    }
+
+    static void flushFilterCache() {
+        synchronized (queryFilterCache) {
+            queryFilterCache.clear();
+        }
+        
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/ContentStrategy.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/ContentStrategy.java
new file mode 100755
index 0000000..8951a9c
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/ContentStrategy.java
@@ -0,0 +1,179 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.search.analysis;
+
+import org.apache.lucene.document.Field;
+import org.apache.lucene.document.Field.Index;
+import org.apache.lucene.document.Field.Store;
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.search.config.IndexSchemaField;
+import org.apache.lucene.gdata.search.config.IndexSchemaField.ContentType;
+import org.apache.lucene.gdata.search.index.GdataIndexerException;
+import org.apache.lucene.gdata.utils.ReflectionUtils;
+import org.w3c.dom.Node;
+
+/**
+ * Creating Indexable document requires processing of incoming entities as
+ * GData Entries. Entries in the GData protocol might have very different
+ * structures and content. They all have on thing in common as they are atom xml
+ * format. To retrieve the configured elements of the atom format and process the
+ * actual content might differ from element to element.
+ * <p>
+ * Each predefined ContentStrategy can be used to retrieve certain content from
+ * the defined element. Which element to process is defined using a XPath
+ * expression in the gdata-config.xml file.
+ * </p>
+ * <p>
+ * <tt>ContentStrategy</tt> implementation should not be accessed directly. To
+ * get a <tt>ContentStrategy</tt> for a specific
+ * {@link org.apache.lucene.gdata.search.config.IndexSchemaField.ContentType}
+ * use the {@link ContentStrategy#getFieldStrategy} factory method. This method
+ * expects a IndexSchemaField instance with a set <tt>ContentType</tt>. The
+ * return value is a new <tt>ContentStrategy</tt> instance for the defined
+ * <tt>ContentType</tt>.
+ * </p>
+ * 
+ * @see org.apache.lucene.gdata.search.config.IndexSchemaField.ContentType
+ * @see org.apache.lucene.gdata.search.index.IndexDocumentBuilder
+ * 
+ * @author Simon Willnauer
+ */
+public abstract class ContentStrategy {
+    protected final Store store;
+
+    protected final Index index;
+
+    protected final IndexSchemaField config;
+
+    protected String content;
+
+    protected String fieldName;
+
+    protected ContentStrategy(IndexSchemaField fieldConfiguration) {
+        this(null, null, fieldConfiguration);
+    }
+
+    protected ContentStrategy(Index index, Store store,
+            IndexSchemaField fieldConfig) {
+        if(fieldConfig == null)
+            throw new IllegalArgumentException("IndexSchemaField must not be null");
+        this.config = fieldConfig;
+        this.fieldName = fieldConfig.getName();
+        if (index != null) {
+            this.index = index;
+        } else {
+            this.index = fieldConfig.getIndex() == null ? IndexSchemaField.DEFAULT_INDEX_STRATEGY
+                    : fieldConfig.getIndex();
+        }
+        if (store != null) {
+            this.store = store;
+        } else {
+            this.store = fieldConfig.getStore() == null ? IndexSchemaField.DEFAULT_STORE_STRATEGY
+                    : fieldConfig.getStore();
+        }
+
+    }
+
+    /**
+     * @param indexable
+     * @throws NotIndexableException
+     */
+    public abstract void processIndexable(
+            Indexable<? extends Node, ? extends ServerBaseEntry> indexable)
+            throws NotIndexableException;
+
+    /**
+     * This method creates a lucene field from the retrieved content of the
+     * entity. Values for Field.Index, Field.Store, the field name and the boost
+     * factor are configured in the <tt>IndexSchemaField</tt> passed by the
+     * constructor e.g the factory method. This method might be overwritten by
+     * subclasses.
+     * 
+     * @return the Lucene {@link Field}
+     */
+    public Field[] createLuceneField() {
+        /*
+         * should I test the content for being empty?!
+         * does that make any difference if empty fields are indexed?!
+         */
+        if(this.fieldName==null|| this.content == null)
+            throw new GdataIndexerException("Required field not set fieldName: "+this.fieldName+" content: "+this.content);
+        if(this.content.length()==0){
+            return new Field[0];
+        }
+        Field retValue = new Field(this.fieldName, this.content, this.store,
+                this.index);
+        float boost = this.config.getBoost();
+        if (boost != 1.0f)
+            retValue.setBoost(boost);
+        return new Field[]{retValue};
+        
+    }
+
+    /**
+     * This factory method creates the <tt>ContentStrategy</tt> corresponding
+     * to the set <tt>ContentType</tt> value in the <tt>IndexSchemaField</tt>
+     * passed to the method as the single parameter.
+     * <p>
+     * The ContentType must not be null
+     * </p>
+     * 
+     * @param fieldConfig -
+     *            the field config to use to identify the corresponding
+     *            <tt>ContentStrategy</tt>
+     * @return - a new <tt>ContentStrategy</tt> instance
+     */
+    public static ContentStrategy getFieldStrategy(IndexSchemaField fieldConfig) {
+        if (fieldConfig == null)
+            throw new IllegalArgumentException(
+                    "field configuration must not be null");
+        ContentType type = fieldConfig.getContentType();
+        if (type == null)
+            throw new IllegalArgumentException(
+                    "ContentType in IndexSchemaField must not be null");
+        fieldConfig.getAnalyzerClass();
+
+        switch (type) {
+        case CATEGORY:
+            return new GdataCategoryStrategy(fieldConfig);
+        case HTML:
+            return new HTMLStrategy(fieldConfig);
+        case XHTML:
+            return new XHtmlStrategy(fieldConfig);
+        case GDATADATE:
+            return new GdataDateStrategy(fieldConfig);
+        case TEXT:
+            return new PlainTextStrategy(fieldConfig);
+        case KEYWORD:
+            return new KeywordStrategy(fieldConfig);
+        case CUSTOM:
+            /*
+             * check if this class can be created with default constructor is checked
+             * in IndexSchemaField#setFieldClass and throws RuntimeEx if not. So
+             * server can not start up.
+             */
+            return ReflectionUtils.getDefaultInstance(fieldConfig
+                    .getFieldClass());
+        case MIXED:
+            return new MixedContentStrategy(fieldConfig);
+        default:
+            throw new RuntimeException("No content strategy found for " + type);
+        }
+
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/DomIndexable.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/DomIndexable.java
new file mode 100755
index 0000000..477e085
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/DomIndexable.java
@@ -0,0 +1,110 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.search.analysis;
+
+import java.io.IOException;
+import java.io.StringReader;
+import java.io.StringWriter;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.xpath.XPath;
+import javax.xml.xpath.XPathConstants;
+import javax.xml.xpath.XPathExpressionException;
+import javax.xml.xpath.XPathFactory;
+
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.w3c.dom.Document;
+import org.w3c.dom.Node;
+import org.xml.sax.InputSource;
+import org.xml.sax.SAXException;
+
+import com.google.gdata.data.ExtensionProfile;
+import com.google.gdata.util.common.xml.XmlWriter;
+
+/**
+ * <tt>Indexable</tt> implementation using the W3C Dom API and JAXP XPath
+ * engine
+ * 
+ * @author Simon Willnauer
+ * @param <R> -
+ *            a subtype of {@link org.w3c.dom.Node} returned by the applyPath
+ *            method
+ * @param <I> -
+ *            a subtype of {@link org.apache.lucene.gdata.data.ServerBaseEntry}
+ */
+public class DomIndexable<R extends Node, I extends ServerBaseEntry> extends
+        Indexable<R, I> {
+    private final Document document;
+
+    private final XPath xPath;
+
+    /**
+     * @param applyAble
+     * @throws NotIndexableException
+     */
+    public DomIndexable(I applyAble) throws NotIndexableException {
+        super(applyAble);
+        if (this.applyAble.getServiceConfig() == null)
+            throw new NotIndexableException("ServiceConfig is not set");
+        try {
+            this.document = buildDomDocument();
+        } catch (ParserConfigurationException e) {
+            throw new NotIndexableException("Can not create document builder",
+                    e);
+
+        } catch (IOException e) {
+            throw new NotIndexableException(
+                    "IO Exception occurred while building indexable", e);
+
+        } catch (SAXException e) {
+            throw new NotIndexableException("Can not parse entry", e);
+
+        }
+        this.xPath = XPathFactory.newInstance().newXPath();
+
+    }
+
+    private Document buildDomDocument() throws ParserConfigurationException,
+            IOException, SAXException {
+        StringWriter stringWriter = new StringWriter();
+        ExtensionProfile profile = this.applyAble.getServiceConfig()
+                .getExtensionProfile();
+        if (profile == null)
+            throw new IllegalStateException("ExtensionProfile is not set");
+        XmlWriter writer = new XmlWriter(stringWriter);
+        this.applyAble.generateAtom(writer, profile);
+        DocumentBuilder builder = DocumentBuilderFactory.newInstance()
+                .newDocumentBuilder();
+        return builder.parse(new InputSource(new StringReader(stringWriter
+                .toString())));
+
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.search.analysis.Indexable#applyPath(java.lang.String)
+     */
+    @SuppressWarnings("unchecked")
+    @Override
+    public R applyPath(String expression) throws XPathExpressionException {
+
+        return (R) this.xPath.evaluate(expression, this.document,
+                XPathConstants.NODE);
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/GdataCategoryStrategy.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/GdataCategoryStrategy.java
new file mode 100755
index 0000000..d4e0a7c
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/GdataCategoryStrategy.java
@@ -0,0 +1,167 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.search.analysis;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import javax.xml.xpath.XPathExpressionException;
+
+import org.apache.lucene.document.Field;
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.search.config.IndexSchemaField;
+import org.apache.lucene.gdata.search.index.GdataIndexerException;
+import org.w3c.dom.NamedNodeMap;
+import org.w3c.dom.Node;
+
+/**
+ * This strategy retrieves the category term and and the scheme from a category
+ * element. The content is represented by the term which can be configured via
+ * the configuration file.
+ * <p>
+ * The category element has at least one attribute with the name "scheme" which
+ * is not mandatory. The term can be the default attribute "term" or the text
+ * content of the element, this is configured via the path of the field.
+ * </p>
+ * <p>
+ * <tt>&lt;category scheme="http://www.example.com/type" term="blog.post"/&gt;<tt>
+ * </p>
+ * TODO extend javadoc for search info
+ * @author Simon Willnauer
+ *
+ */
+public class GdataCategoryStrategy extends ContentStrategy {
+    protected String categoryScheme;
+
+    protected String categorySchemeField;
+
+    private static final String LABEL = "label";
+
+    private static final String SCHEME = "scheme";
+
+    private static final String TERM = "term";
+
+    /**
+     * the string to search a schema if no schema is specified
+     */
+    public static final String CATEGORY_SCHEMA_NULL_VALUE = "LUCISCHEMANULL";
+
+    /**
+     * Schema field suffix
+     */
+    public static final String CATEGORY_SCHEMA_FIELD_SUFFIX = "-schema";
+
+    protected GdataCategoryStrategy(IndexSchemaField fieldConfiguration) {
+        super(fieldConfiguration);
+        this.categorySchemeField = new StringBuilder(this.fieldName).append(
+                CATEGORY_SCHEMA_FIELD_SUFFIX).toString();
+
+    }
+
+    /**
+     * @throws NotIndexableException
+     * @see org.apache.lucene.gdata.search.analysis.ContentStrategy#processIndexable(org.apache.lucene.gdata.search.analysis.Indexable)
+     */
+    @Override
+    public void processIndexable(
+            Indexable<? extends Node, ? extends ServerBaseEntry> indexable)
+            throws NotIndexableException {
+        String contentPath = this.config.getPath();
+        Node node = null;
+        try {
+            node = indexable.applyPath(contentPath);
+        } catch (XPathExpressionException e) {
+
+            throw new NotIndexableException("Can not apply path");
+        }
+        if (node == null)
+            throw new NotIndexableException(
+                    "Could not retrieve content for schema field: "
+                            + this.config);
+
+        StringBuilder contentBuilder = new StringBuilder();
+        StringBuilder schemeBuilder = new StringBuilder();
+        String nodeName = node.getNodeName();
+        /*
+         * enable more than one category element -- check the node name if
+         * category strategy is used with an element not named "category"
+         */
+        while (node != null && nodeName != null
+                && nodeName.equals(node.getNodeName())) {
+            NamedNodeMap attributeMap = node.getAttributes();
+            if (attributeMap == null)
+                throw new NotIndexableException(
+                        "category term attribute not present");
+            /*
+             * the "term" is the internal string used by the software to
+             * identify the category, while the "label" is the human-readable
+             * string presented to a user in a user interface.
+             */
+            Node termNode = attributeMap.getNamedItem(TERM);
+            if (termNode == null)
+                throw new NotIndexableException(
+                        "category term attribute not present");
+            contentBuilder.append(termNode.getTextContent()).append(" ");
+
+            Node labelNode = attributeMap.getNamedItem(LABEL);
+            if (labelNode != null)
+                contentBuilder.append(labelNode.getTextContent()).append(" ");
+
+            Node schemeNode = attributeMap.getNamedItem(SCHEME);
+            if (schemeNode != null)
+                schemeBuilder.append(schemeNode.getTextContent());
+            node = node.getNextSibling();
+        }
+
+        this.content = contentBuilder.toString();
+        this.categoryScheme = schemeBuilder.toString();
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.search.analysis.ContentStrategy#createLuceneField()
+     */
+    @Override
+    public Field[] createLuceneField() {
+        List<Field> retValue = new ArrayList<Field>(2);
+        if (this.fieldName == null)
+            throw new GdataIndexerException("Required field 'name' is null -- "
+                    + this.config);
+        if (this.content == null)
+            throw new GdataIndexerException(
+                    "Required field 'content' is null -- " + this.config);
+
+        Field categoryTerm = new Field(this.fieldName, this.content,
+                this.store, this.index);
+        float boost = this.config.getBoost();
+        if (boost != 1.0f)
+            categoryTerm.setBoost(boost);
+        retValue.add(categoryTerm);
+        /*
+         * if schema is not set index null value to enable search for categories
+         * without a schema
+         */
+        if (this.categoryScheme == null || this.categoryScheme.length() == 0) {
+            this.categoryScheme = CATEGORY_SCHEMA_NULL_VALUE;
+        }
+        Field categoryURN = new Field(this.categorySchemeField,
+                this.categoryScheme, Field.Store.YES, Field.Index.UN_TOKENIZED);
+        retValue.add(categoryURN);
+        return retValue.toArray(new Field[0]);
+
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/GdataDateStrategy.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/GdataDateStrategy.java
new file mode 100755
index 0000000..775215b
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/GdataDateStrategy.java
@@ -0,0 +1,99 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.search.analysis;
+
+import javax.xml.xpath.XPathExpressionException;
+
+import org.apache.lucene.document.Field;
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.search.config.IndexSchemaField;
+import org.apache.lucene.gdata.search.index.GdataIndexerException;
+import org.w3c.dom.Node;
+
+import com.google.gdata.data.DateTime;
+
+/**
+ * This content strategy retrieves a so called GData Date from a RFC 3339
+ * timestamp format. The format will be parsed and indexed as a timestamp value.
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class GdataDateStrategy extends ContentStrategy {
+
+    protected GdataDateStrategy(IndexSchemaField fieldConfiguration) {
+        super(fieldConfiguration);
+
+    }
+
+    /**
+     * @throws NotIndexableException
+     * @see org.apache.lucene.gdata.search.analysis.ContentStrategy#processIndexable(org.apache.lucene.gdata.search.analysis.Indexable)
+     */
+    @Override
+    public void processIndexable(
+            Indexable<? extends Node, ? extends ServerBaseEntry> indexable)
+            throws NotIndexableException {
+        String path = this.config.getPath();
+        Node node;
+        try {
+            node = indexable.applyPath(path);
+        } catch (XPathExpressionException e1) {
+            throw new NotIndexableException("Can not apply path -- " + path
+                    + " FieldConfig: " + this.config);
+        }
+        if (node == null)
+            throw new NotIndexableException(
+                    "Could not retrieve content for schema field: "
+                            + this.config);
+        String textContent = node.getTextContent();
+        try {
+            this.content = getTimeStamp(textContent);
+        } catch (NumberFormatException e) {
+            throw new NotIndexableException("Can not parse GData date -- "
+                    + textContent);
+        }
+
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.search.analysis.ContentStrategy#createLuceneField()
+     */
+    @Override
+    public Field[] createLuceneField() {
+        if(this.fieldName == null)
+            throw new GdataIndexerException(
+                    "Required field 'name' is null -- " +this.config);
+        if(this.content == null)
+            throw new GdataIndexerException(
+                    "Required field 'content' is null -- " +this.config);
+        if(this.content.length()==0)
+            return new Field[0];
+            Field retValue = new Field(this.fieldName, this.content,
+                    Field.Store.YES, Field.Index.UN_TOKENIZED);
+            float boost = this.config.getBoost();
+            if (boost != 1.0f)
+                retValue.setBoost(boost);
+            return new Field[] { retValue };
+        
+    }
+
+    private static String getTimeStamp(String dateString) {
+        return Long.toString(DateTime.parseDateTimeChoice(dateString).getValue());
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/HTMLStrategy.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/HTMLStrategy.java
new file mode 100755
index 0000000..b057c5c
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/HTMLStrategy.java
@@ -0,0 +1,99 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.search.analysis;
+
+import java.io.IOException;
+import java.io.StringReader;
+import java.io.StringWriter;
+
+import javax.xml.xpath.XPathExpressionException;
+
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.search.config.IndexSchemaField;
+import org.apache.xerces.xni.XNIException;
+import org.apache.xerces.xni.parser.XMLDocumentFilter;
+import org.apache.xerces.xni.parser.XMLInputSource;
+import org.apache.xerces.xni.parser.XMLParserConfiguration;
+import org.cyberneko.html.HTMLConfiguration;
+import org.cyberneko.html.filters.ElementRemover;
+import org.cyberneko.html.filters.Writer;
+import org.w3c.dom.Node;
+
+/**
+ * This ContentStrategy applies the path to the Indexable and retrieves the
+ * plain string content from the returning node. All of the nodes text content
+ * will cleaned from any html tags.
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class HTMLStrategy extends
+        org.apache.lucene.gdata.search.analysis.ContentStrategy {
+    private static final String REMOVE_SCRIPT = "script";
+
+    private static final String CHAR_ENCODING = "UTF-8";
+
+    protected HTMLStrategy(IndexSchemaField fieldConfiguration) {
+        super(fieldConfiguration);
+
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.search.analysis.ContentStrategy#processIndexable(org.apache.lucene.gdata.search.analysis.Indexable)
+     */
+    @Override
+    public void processIndexable(Indexable<? extends Node, ? extends ServerBaseEntry> indexable)
+            throws NotIndexableException {
+        String path = this.config.getPath();
+        Node node = null;
+        try {
+            node = indexable.applyPath(path);
+        } catch (XPathExpressionException e1) {
+            throw new NotIndexableException("Can not apply path -- " + path);
+
+        }
+        if(node == null)
+            throw new NotIndexableException("Could not retrieve content for schema field: "+this.config);
+        StringReader contentReader = new StringReader(node.getTextContent());
+        /*
+         * remove all elements and script parts
+         */
+        ElementRemover remover = new ElementRemover();
+        remover.removeElement(REMOVE_SCRIPT);
+        StringWriter contentWriter = new StringWriter();
+        Writer writer = new Writer(contentWriter, CHAR_ENCODING);
+        XMLDocumentFilter[] filters = { remover, writer, };
+        XMLParserConfiguration parser = new HTMLConfiguration();
+        parser.setProperty("http://cyberneko.org/html/properties/filters",
+                filters);
+        XMLInputSource source = new XMLInputSource(null, null, null,
+                contentReader, CHAR_ENCODING);
+        try {
+            parser.parse(source);
+        } catch (XNIException e) {
+            throw new NotIndexableException("Can not parse html -- ", e);
+
+        } catch (IOException e) {
+            throw new NotIndexableException("Can not parse html -- ", e);
+
+        }
+        this.content = contentWriter.toString();
+    }
+
+    
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/Indexable.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/Indexable.java
new file mode 100755
index 0000000..ae800b36
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/Indexable.java
@@ -0,0 +1,75 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.search.analysis;
+
+import javax.xml.xpath.XPathExpressionException;
+
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.w3c.dom.Node;
+
+/**
+ * This class wraps the access to the GData entities to access them via xpath
+ * expressions. An arbitrary valid Xpath expression can be passed to the
+ * <tt>applyPath</tt> method to access an element, attribute etc. in the gdata
+ * entity.
+ * 
+ * @author Simon Willnauer
+ * @param <R> -
+ *            a subtype of {@link org.w3c.dom.Node} returned by the applyPath
+ *            method
+ * @param <I> -
+ *            a subtype of {@link org.apache.lucene.gdata.data.ServerBaseEntry}
+ */
+public abstract class Indexable<R extends Node, I extends ServerBaseEntry> {
+    protected ServerBaseEntry applyAble;
+
+    /**
+     * @param applyAble
+     */
+    Indexable(I applyAble) {
+        this.applyAble = applyAble;
+    }
+
+    /**
+     * @param xPath -
+     *            a valid xpath expression
+     * @return - the requested element <b>R</b>
+     * @throws XPathExpressionException
+     */
+    public abstract R applyPath(String xPath) throws XPathExpressionException;
+
+    /**
+     * Factory method to create new <tt>Indexable</tt> instances.
+     * 
+     * @param <R> -
+     *            a subtype of {@link org.w3c.dom.Node} returned by the
+     *            applyPath method
+     * @param <I> -
+     *            a subtype of
+     *            {@link org.apache.lucene.gdata.data.ServerBaseEntry}
+     * @param entry -
+     *            the entry to wrap in a <tt>Indexable</tt>
+     * @return - a new instance of <tt>Indexable</tt> to access the entry via
+     *         Xpath
+     * @throws NotIndexableException - if <b>I<b> can not be parsed. 
+     */
+    public static <R extends Node, I extends ServerBaseEntry> Indexable<R, I> getIndexable(
+            I entry) throws NotIndexableException {
+        return new DomIndexable<R, I>(entry);
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/KeywordStrategy.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/KeywordStrategy.java
new file mode 100755
index 0000000..273140f
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/KeywordStrategy.java
@@ -0,0 +1,58 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.search.analysis;
+
+import javax.xml.xpath.XPathExpressionException;
+
+import org.apache.lucene.document.Field;
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.search.config.IndexSchemaField;
+import org.w3c.dom.Node;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class KeywordStrategy extends ContentStrategy {
+
+    /**
+     * @param fieldConfig
+     */
+    public KeywordStrategy(IndexSchemaField fieldConfig) {
+        super(Field.Index.UN_TOKENIZED,Field.Store.YES,fieldConfig);
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.search.analysis.ContentStrategy#processIndexable(org.apache.lucene.gdata.search.analysis.Indexable)
+     */
+    @Override
+    public void processIndexable(Indexable<? extends Node, ? extends ServerBaseEntry> indexable) throws NotIndexableException {
+        String path = this.config.getPath();
+        try {
+            Node node = indexable.applyPath(path);
+            if(node == null)
+                throw new NotIndexableException("Could not retrieve content for schema field: "+this.config);
+            this.content = node.getTextContent();
+        } catch (XPathExpressionException e) {
+            throw new NotIndexableException("Can not apply Path", e);
+        }
+
+    }
+
+   
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/MixedContentStrategy.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/MixedContentStrategy.java
new file mode 100755
index 0000000..0037c5e
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/MixedContentStrategy.java
@@ -0,0 +1,97 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.search.analysis;
+
+import javax.xml.xpath.XPathExpressionException;
+
+import org.apache.lucene.document.Field;
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.search.config.IndexSchemaField;
+import org.apache.lucene.gdata.search.config.IndexSchemaField.ContentType;
+import org.w3c.dom.Node;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class MixedContentStrategy extends ContentStrategy {
+    protected ContentStrategy strategy;
+
+    protected MixedContentStrategy(IndexSchemaField fieldConfiguration) {
+        super(fieldConfiguration);
+
+    }
+
+    /**
+     * @throws NotIndexableException
+     * @see org.apache.lucene.gdata.search.analysis.ContentStrategy#processIndexable(org.apache.lucene.gdata.search.analysis.Indexable)
+     */
+    @Override
+    public void processIndexable(
+            Indexable<? extends Node, ? extends ServerBaseEntry> indexable)
+            throws NotIndexableException {
+        String path = this.config.getTypePath();
+
+        try {
+            Node node = indexable.applyPath(path);
+            if (node == null)
+                this.strategy = new PlainTextStrategy(this.config);
+            else {
+                String contentType = node.getTextContent();
+
+                this.strategy = chooseStrategy(contentType, this.config);
+            }
+            this.strategy.processIndexable(indexable);
+        } catch (XPathExpressionException e) {
+            throw new NotIndexableException("Can not apply path -- " + path);
+
+        }
+    }
+    
+    /**
+     * @see org.apache.lucene.gdata.search.analysis.ContentStrategy#createLuceneField()
+     */
+    @Override
+    public Field[] createLuceneField() {
+        
+        return this.strategy.createLuceneField();
+    }
+
+    private static ContentStrategy chooseStrategy(final String contentType,
+            final IndexSchemaField config) {
+        ContentType type = null;
+        try {
+            type = ContentType.valueOf(contentType==null?"TEXT":contentType.toUpperCase());
+        } catch (Throwable e) {
+            type = ContentType.TEXT;
+        }
+
+        switch (type) {
+        case HTML:
+            return new HTMLStrategy(config);
+
+        case XHTML:
+            return new XHtmlStrategy(config);
+
+        default:
+            return new PlainTextStrategy(config);
+
+        }
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/NotIndexableException.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/NotIndexableException.java
new file mode 100755
index 0000000..83d7d9f
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/NotIndexableException.java
@@ -0,0 +1,79 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.search.analysis;
+
+/**
+ * This exception will be thrown by ContentStrategy instances if an exception
+ * occurs while retrieving content from entries
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class NotIndexableException extends Exception {
+
+    /**
+     * 
+     */
+    private static final long serialVersionUID = 1538388864181786380L;
+
+    /**
+     * Constructs a new NotIndexableException
+     */
+    public NotIndexableException() {
+        super();
+
+    }
+
+    /**
+     * Constructs a new NotIndexableException with the specified detail message.
+     * 
+     * @param arg0 -
+     *            detail message
+     */
+    public NotIndexableException(String arg0) {
+        super(arg0);
+
+    }
+
+    /**
+     * Constructs a new NotIndexableException with the specified detail message
+     * and nested exception.
+     * 
+     * @param arg0 -
+     *            detail message
+     * @param arg1 -
+     *            nested exception
+     */
+    public NotIndexableException(String arg0, Throwable arg1) {
+        super(arg0, arg1);
+
+    }
+
+    /**
+     * Constructs a new NotIndexableException with a nested exception caused
+     * this exception.
+     * 
+     * @param arg0 -
+     *            nested exception
+     */
+    public NotIndexableException(Throwable arg0) {
+        super(arg0);
+
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/PlainTextStrategy.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/PlainTextStrategy.java
new file mode 100755
index 0000000..ef0305b
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/PlainTextStrategy.java
@@ -0,0 +1,55 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.search.analysis;
+
+import javax.xml.xpath.XPathExpressionException;
+
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.search.config.IndexSchemaField;
+import org.w3c.dom.Node;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class PlainTextStrategy extends ContentStrategy {
+
+    protected PlainTextStrategy(IndexSchemaField fieldConfiguration) {
+        super(fieldConfiguration);
+        
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.search.analysis.ContentStrategy#processIndexable(org.apache.lucene.gdata.search.analysis.Indexable)
+     */
+    @Override
+    public void processIndexable(Indexable<? extends Node, ? extends ServerBaseEntry> indexable)
+            throws NotIndexableException {
+        String path = this.config.getPath();
+        try {
+            Node node = indexable.applyPath(path);
+            if(node == null)
+                throw new NotIndexableException("Could not retrieve content for schema field: "+this.config);
+            this.content = node.getTextContent();
+            
+        } catch (XPathExpressionException e) {
+            throw new NotIndexableException("Can not apply Path", e);
+        }
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/XHtmlStrategy.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/XHtmlStrategy.java
new file mode 100755
index 0000000..39d0f5b
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/XHtmlStrategy.java
@@ -0,0 +1,37 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.search.analysis;
+
+import org.apache.lucene.gdata.search.config.IndexSchemaField;
+
+
+/**
+ * @author Simon Willnauer
+ * @see org.apache.lucene.gdata.search.analysis.TestHTMLStrategy
+ */
+public class XHtmlStrategy extends HTMLStrategy {
+
+	
+
+    /**
+     * @param fieldConfig
+     */
+    public XHtmlStrategy(IndexSchemaField fieldConfig) {
+     super(fieldConfig);
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/package.html b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/package.html
new file mode 100755
index 0000000..8851e77
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/analysis/package.html
@@ -0,0 +1,10 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
+<html> 
+<head> 
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
+   <meta name="Author" content="Simon Willnauer"> 
+</head> 
+<body> 
+Classes used for extracting content from entries and building lucene documents.
+</body> 
+</html> 
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/config/IndexSchema.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/config/IndexSchema.java
new file mode 100755
index 0000000..1535229
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/config/IndexSchema.java
@@ -0,0 +1,525 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.search.config;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Set;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.PerFieldAnalyzerWrapper;
+import org.apache.lucene.analysis.standard.StandardAnalyzer;
+import org.apache.lucene.gdata.search.index.IndexDocument;
+import org.apache.lucene.gdata.utils.ReflectionUtils;
+
+/**
+ * This class is used to configure the indexing and search component. Each
+ * service on the GData server will have an own search index. For this purpose
+ * one single index schema will be configured in the gdata-config.xml file. This
+ * file will be mapped on this class on startup.
+ * <p>
+ * This class breaks some encapsulation of general java classes to be
+ * configurable via the xml configuration file. The will be very less type and
+ * value checking of the properties inside this file. Mandatory values must be
+ * set in the configuration file. The server won't start up if these values are
+ * missing. See definition in the xml schema file. If this class is instantiated
+ * manually the value for the name of the schema should be set before this is
+ * passed to the IndexController.
+ * </p>
+ * <p>
+ * One IndexSchema consists of multiple instances of
+ * {@link org.apache.lucene.gdata.search.config.IndexSchemaField} each of this
+ * instances describes a single field in the index and all schema informations
+ * about the field.
+ * <p>
+ * 
+ * 
+ * @see org.apache.lucene.gdata.search.config.IndexSchemaField
+ * 
+ * 
+ * @author Simon Willnauer
+ */
+public class IndexSchema {
+    private final Set<String> searchableFieldNames = new HashSet<String>();
+
+    private static final Log LOG = LogFactory.getLog(IndexSchema.class);
+
+    /**
+     * a static final value for properties are not set by the configuration file
+     * this value will be set to all long and int properties by default
+     */
+    public static final int NOT_SET_VALUE = -1;
+    private static final int DEFAULT_OPTIMIZE_COUNT = 1;
+    private static final int DEFAULT_COMMIT_COUNT = 1;
+
+    private String indexLocation;
+
+    /*
+     * this should be final change it if possible --> see commons digester /
+     * RegistryBuilder
+     */
+    private String name;
+
+    private boolean useTimedIndexer;
+
+    private long indexerIdleTime = NOT_SET_VALUE;
+
+    private Analyzer serviceAnalyzer;
+
+    private String defaultSearchField;
+
+    private PerFieldAnalyzerWrapper perFieldAnalyzer;
+
+    private Collection<IndexSchemaField> schemaFields;
+
+    private int maxBufferedDocs = NOT_SET_VALUE;
+
+    private int maxMergeDocs = NOT_SET_VALUE;
+
+    private int mergeFactor = NOT_SET_VALUE;
+
+    private int maxFieldLength = NOT_SET_VALUE;
+
+    private long writeLockTimeout = NOT_SET_VALUE;
+
+    private long commitLockTimeout = NOT_SET_VALUE;
+
+    private int commitAfterDocuments = DEFAULT_COMMIT_COUNT;
+    
+    private int optimizeAfterCommit = DEFAULT_OPTIMIZE_COUNT;
+    
+    private boolean useCompoundFile = false;
+
+    /**
+     * Creates a new IndexSchema and initialize the standard service analyzer to
+     * {@link StandardAnalyzer}
+     * 
+     */
+    public IndexSchema() {
+        this.schemaFields = new ArrayList<IndexSchemaField>();
+        /*
+         * keep as standard if omitted in the configuration
+         */
+        this.serviceAnalyzer = new StandardAnalyzer();
+
+    }
+
+    /**
+     * Initialize the schema and checks all required values
+     */
+    public void initialize() {
+        for (IndexSchemaField field : this.schemaFields) {
+            if (!field.checkRequieredValues())
+                throw new RuntimeException("Required Value for field: "
+                        + field.getName() + " is missing");
+        }
+        if (this.defaultSearchField == null)
+            throw new RuntimeException("DefaulSearchField must not be null");
+        if (this.name == null)
+            throw new RuntimeException(
+                    "Schema field is not set -- must not be null");
+        if (this.indexLocation == null)
+            throw new RuntimeException("IndexLocation must not be null");
+        if(!this.searchableFieldNames.contains(this.defaultSearchField)){
+            throw new RuntimeException("the default search field: "+this.defaultSearchField+" is registered as a field");
+        }
+
+    }
+
+    /**
+     * @return Returns the useCompoundFile.
+     */
+    public boolean isUseCompoundFile() {
+        return this.useCompoundFile;
+    }
+
+    /**
+     * @param useCompoundFile
+     *            The useCompoundFile to set.
+     */
+    public void setUseCompoundFile(boolean useCompoundFile) {
+        this.useCompoundFile = useCompoundFile;
+    }
+
+    /**
+     * Adds a new {@link IndexSchemaField} to the schema. if the fields name
+     * equals {@link IndexDocument#FIELD_ENTRY_ID} or the field is
+     * <code>null</code> it will simply ignored
+     * 
+     * @param field -
+     *            the index schema field to add as a field of this schema.
+     */
+    public void addSchemaField(final IndexSchemaField field) {
+        if (field == null)
+            return;
+        /*
+         * skip fields configured in the gdata-config.xml file if their names
+         * match a primary key field id of the IndexDocument
+         */
+        if (field.getName().equals(IndexDocument.FIELD_ENTRY_ID)
+                || field.getName().equals(IndexDocument.FIELD_FEED_ID))
+            return;
+        if (field.getAnalyzerClass() != null) {
+            /*
+             * enable per field analyzer if one is set.
+             */
+            Analyzer analyzer = getAnalyzerInstance(field.getAnalyzerClass());
+            /*
+             * null values will be omitted here
+             */
+            buildPerFieldAnalyzerWrapper(analyzer, field.getName());
+        }
+        this.schemaFields.add(field);
+        this.searchableFieldNames.add(field.getName());
+    }
+
+
+    /**
+     * @return Returns the fieldConfiguration.
+     */
+    public Collection<IndexSchemaField> getFields() {
+        return this.schemaFields;
+    }
+
+    /**
+     * @return - the analyzer instance to be used for this schema
+     */
+    public Analyzer getSchemaAnalyzer() {
+        if (this.perFieldAnalyzer == null)
+            return this.serviceAnalyzer;
+        return this.perFieldAnalyzer;
+    }
+
+    /**
+     * @return Returns the serviceAnalyzer.
+     */
+    public Analyzer getServiceAnalyzer() {
+        return this.serviceAnalyzer;
+    }
+
+    /**
+     * @param serviceAnalyzer
+     *            The serviceAnalyzer to set.
+     */
+    public void setServiceAnalyzer(Analyzer serviceAnalyzer) {
+        if (serviceAnalyzer == null)
+            return;
+        this.serviceAnalyzer = serviceAnalyzer;
+
+    }
+
+    /**
+     * @return Returns the commitLockTimout.
+     */
+    public long getCommitLockTimeout() {
+        return this.commitLockTimeout;
+    }
+
+    /**
+     * 
+     * @param commitLockTimeout
+     *            The commitLockTimeout to set.
+     */
+    public void setCommitLockTimeout(long commitLockTimeout) {
+        // TODO enable this in config
+        this.commitLockTimeout = commitLockTimeout;
+    }
+
+    /**
+     * @return Returns the maxBufferedDocs.
+     */
+    public int getMaxBufferedDocs() {
+
+        return this.maxBufferedDocs;
+    }
+
+    /**
+     * @param maxBufferedDocs
+     *            The maxBufferedDocs to set.
+     */
+    public void setMaxBufferedDocs(int maxBufferedDocs) {
+        this.maxBufferedDocs = maxBufferedDocs;
+    }
+
+    /**
+     * @return Returns the maxFieldLength.
+     */
+    public int getMaxFieldLength() {
+        return this.maxFieldLength;
+    }
+
+    /**
+     * @param maxFieldLength
+     *            The maxFieldLength to set.
+     */
+    public void setMaxFieldLength(int maxFieldLength) {
+        this.maxFieldLength = maxFieldLength;
+    }
+
+    /**
+     * @return Returns the maxMergeDocs.
+     */
+    public int getMaxMergeDocs() {
+        return this.maxMergeDocs;
+    }
+
+    /**
+     * @param maxMergeDocs
+     *            The maxMergeDocs to set.
+     */
+    public void setMaxMergeDocs(int maxMergeDocs) {
+        this.maxMergeDocs = maxMergeDocs;
+    }
+
+    /**
+     * @return Returns the mergeFactor.
+     */
+    public int getMergeFactor() {
+        return this.mergeFactor;
+    }
+
+    /**
+     * @param mergeFactor
+     *            The mergeFactor to set.
+     */
+    public void setMergeFactor(int mergeFactor) {
+        this.mergeFactor = mergeFactor;
+    }
+
+    /**
+     * @return Returns the writeLockTimeout.
+     */
+    public long getWriteLockTimeout() {
+        return this.writeLockTimeout;
+    }
+
+    /**
+     * @param writeLockTimeout
+     *            The writeLockTimeout to set.
+     */
+    public void setWriteLockTimeout(long writeLockTimeout) {
+        this.writeLockTimeout = writeLockTimeout;
+    }
+
+    /**
+     * @param fields
+     *            The fieldConfiguration to set.
+     */
+    public void setSchemaFields(Collection<IndexSchemaField> fields) {
+        this.schemaFields = fields;
+    }
+
+    /**
+     * @return Returns the name.
+     */
+    public String getName() {
+        return this.name;
+    }
+
+    /**
+     * @see java.lang.Object#equals(java.lang.Object)
+     */
+    @Override
+    public boolean equals(Object object) {
+        if (this == object)
+            return true;
+        if (object == null)
+            return false;
+        if (object instanceof IndexSchema) {
+           if(this.name ==null)
+               return super.equals(object);
+            return this.name.equals(((IndexSchema) object).getName());
+        }
+        return false;
+    }
+
+    /**
+     * @see java.lang.Object#hashCode()
+     */
+    @Override
+    public int hashCode() {
+        if (this.name == null)
+            return super.hashCode();
+        return this.name.hashCode();
+    }
+
+    private void buildPerFieldAnalyzerWrapper(Analyzer anazlyer, String field) {
+        if (anazlyer == null || field == null || field.length() == 0)
+            return;
+        if (this.perFieldAnalyzer == null)
+            this.perFieldAnalyzer = new PerFieldAnalyzerWrapper(
+                    this.serviceAnalyzer);
+        this.perFieldAnalyzer.addAnalyzer(field, anazlyer);
+    }
+
+    private static Analyzer getAnalyzerInstance(Class<? extends Analyzer> clazz) {
+        if (!ReflectionUtils.extendsType(clazz, Analyzer.class)) {
+            LOG.warn("Can not create analyzer for class " + clazz.getName());
+            return null;
+        }
+        try {
+            return clazz.newInstance();
+        } catch (Exception e) {
+            LOG.warn("Can not create analyzer for class " + clazz.getName());
+        }
+        return null;
+    }
+
+    /**
+     * @param name
+     *            The name to set.
+     */
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    /**
+     * @return Returns the indexLocation.
+     */
+    public String getIndexLocation() {
+        return this.indexLocation;
+    }
+
+    /**
+     * @param indexLocation
+     *            The indexLocation to set.
+     */
+    public void setIndexLocation(String indexLocation) {
+        this.indexLocation = indexLocation;
+    }
+
+    /**
+     * @return Returns the defaultField.
+     */
+    public String getDefaultSearchField() {
+        return this.defaultSearchField;
+    }
+
+    /**
+     * @param defaultField
+     *            The defaultField to set.
+     */
+    public void setDefaultSearchField(String defaultField) {
+        this.defaultSearchField = defaultField;
+    }
+
+    /**
+     * @return Returns the indexerIdleTime.
+     */
+    public long getIndexerIdleTime() {
+        return this.indexerIdleTime;
+    }
+
+    /**
+     * @param indexerIdleTime
+     *            The indexerIdleTime to set.
+     */
+    public void setIndexerIdleTime(long indexerIdleTime) {
+        this.indexerIdleTime = indexerIdleTime;
+    }
+
+    /**
+     * @return Returns the useTimedIndexer.
+     */
+    public boolean isUseTimedIndexer() {
+        return this.useTimedIndexer;
+    }
+
+    /**
+     * @param useTimedIndexer
+     *            The useTimedIndexer to set.
+     */
+    public void setUseTimedIndexer(boolean useTimedIndexer) {
+        this.useTimedIndexer = useTimedIndexer;
+    }
+
+    /**
+     * @see java.lang.Object#toString()
+     */
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder(this.getClass().getName())
+                .append(" ");
+        builder.append("Name: ").append(this.name).append(" ");
+        builder.append("MaxBufferedDocs: ").append(this.maxBufferedDocs)
+                .append(" ");
+        builder.append("MaxFieldLength: ").append(this.maxFieldLength).append(
+                " ");
+        builder.append("MaxMergeDocs: ").append(this.maxMergeDocs).append(" ");
+        builder.append("MergeFactor: ").append(this.mergeFactor).append(" ");
+        builder.append("CommitLockTimeout: ").append(this.commitLockTimeout)
+                .append(" ");
+        builder.append("WriteLockTimeout: ").append(this.writeLockTimeout)
+                .append(" ");
+        builder.append("indexerIdleTime: ").append(this.indexerIdleTime)
+                .append(" ");
+        builder.append("useCompoundFile: ").append(this.useCompoundFile)
+                .append(" ");
+        builder.append("Added SchemaField instances: ").append(
+                this.schemaFields.size()).append(" ");
+
+        builder.append("IndexLocation: ").append(this.indexLocation)
+                .append(" ");
+        return builder.toString();
+
+    }
+
+    /**
+     * @return Returns the searchableFieldNames.
+     */
+    public Set<String> getSearchableFieldNames() {
+        return this.searchableFieldNames;
+    }
+
+    /**
+     * Defines after how many added,removed or updated document the indexer should commit.
+     * @return Returns the commitAfterDocuments.
+     */
+    public int getCommitAfterDocuments() {
+        return this.commitAfterDocuments;
+    }
+
+    /**
+     * @param commitAfterDocuments The commitAfterDocuments to set.
+     */
+    public void setCommitAfterDocuments(int commitAfterDocuments) {
+        if(commitAfterDocuments < DEFAULT_COMMIT_COUNT)
+            return;
+        this.commitAfterDocuments = commitAfterDocuments;
+    }
+
+    /**
+     * Defines after how many commits the indexer should optimize the index
+     * @return Returns the optimizeAfterCommit.
+     */
+    public int getOptimizeAfterCommit() {
+        
+        return this.optimizeAfterCommit;
+    }
+
+    /**
+     * @param optimizeAfterCommit The optimizeAfterCommit to set.
+     */
+    public void setOptimizeAfterCommit(int optimizeAfterCommit) {
+        if(optimizeAfterCommit < DEFAULT_OPTIMIZE_COUNT )
+            return;
+        this.optimizeAfterCommit = optimizeAfterCommit;
+    }
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/config/IndexSchemaField.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/config/IndexSchemaField.java
new file mode 100755
index 0000000..c499fdf
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/config/IndexSchemaField.java
@@ -0,0 +1,380 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.search.config;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.document.Field.Index;
+import org.apache.lucene.document.Field.Store;
+import org.apache.lucene.gdata.search.analysis.ContentStrategy;
+import org.apache.lucene.gdata.search.analysis.GdataCategoryStrategy;
+import org.apache.lucene.gdata.search.analysis.GdataDateStrategy;
+import org.apache.lucene.gdata.search.analysis.HTMLStrategy;
+import org.apache.lucene.gdata.search.analysis.KeywordStrategy;
+import org.apache.lucene.gdata.search.analysis.MixedContentStrategy;
+import org.apache.lucene.gdata.search.analysis.PlainTextStrategy;
+import org.apache.lucene.gdata.search.analysis.XHtmlStrategy;
+import org.apache.lucene.gdata.utils.ReflectionUtils;
+
+/**
+ * Each field in the search index is defined by a instance of
+ * {@link IndexSchemaField}. The schema definition will be loaded at startup
+ * and the defined values will be set to instances of this class. Each
+ * constructed field will be passed to an instance of
+ * {@link org.apache.lucene.gdata.search.config.IndexSchema}.
+ * <p>
+ * IndexSchemaField contains all informations about how the content from
+ * incoming entries has to be extracted and how the actual content has to be
+ * index into the lucene index.
+ * </p>
+ * <p>
+ * Each field will have a defined
+ * {@link org.apache.lucene.gdata.search.analysis.ContentStrategy} which does
+ * process the extraction of the field content from an incoming entry.
+ * </p>
+ * @see org.apache.lucene.gdata.search.analysis.ContentStrategy
+ * @see org.apache.lucene.gdata.search.config.IndexSchema
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class IndexSchemaField {
+    /**
+     * Default value for Field.Store 
+     * @see org.apache.lucene.document.Field
+     */
+    public static final Store DEFAULT_STORE_STRATEGY = Field.Store.NO;
+    /**
+     * Default value for Field.Index
+     * @see org.apache.lucene.document.Field
+     */
+    public static final Index DEFAULT_INDEX_STRATEGY = Field.Index.TOKENIZED;
+    private static final float DEFAULT_BOOST = 1.0f;
+    private static final float MINIMAL_BOOST = 0.1f;
+    private float boost = DEFAULT_BOOST;
+
+    private String name;
+
+    private ContentType contentType;
+
+    private Index index = DEFAULT_INDEX_STRATEGY;
+
+    private Store store = DEFAULT_STORE_STRATEGY;
+
+    private String path;
+
+    private String typePath;
+
+    private Class<? extends Analyzer> analyzerClass;
+
+    private Class<? extends ContentStrategy> fieldClass;
+
+    /**
+     * Constructs a new SchemaField <br>
+     * Default values:
+     * <ol>
+     * <li>boost: <i>1.0</i></li>
+     * <li>index: <i>TOKENIZED</i></li>
+     * <li>store: <i>NO</i></li>
+     * </ol>
+     */
+    public IndexSchemaField() {
+        super();
+    }
+    boolean checkRequieredValues(){
+        /*
+         * This class will be inst. by the reg builder.
+         * Check all values to be set. otherwise return false.
+         * false will cause a runtime exception in IndexSchema
+         */
+        boolean returnValue = (this.name != null&&this.path!=null&&this.contentType!=null&&this.index!=null&&this.store!=null&&this.boost>=MINIMAL_BOOST);
+        if(this.contentType == ContentType.CUSTOM)
+            returnValue &=this.fieldClass!=null;
+        else if(this.contentType == ContentType.MIXED)
+            returnValue &=this.typePath!=null;
+        
+        return returnValue;
+    }
+    /**
+     * @return Returns the alanyzerClass.
+     */
+    public Class<? extends Analyzer> getAnalyzerClass() {
+        return this.analyzerClass;
+    }
+
+    /**
+     * @param alanyzerClass
+     *            The alanyzerClass to set.
+     */
+    public void setAnalyzerClass(Class<? extends Analyzer> alanyzerClass) {
+        this.analyzerClass = alanyzerClass;
+    }
+
+    /**
+     * @return Returns the fieldClass.
+     */
+    public Class<? extends ContentStrategy> getFieldClass() {
+        return this.fieldClass;
+    }
+
+    /**
+     * Sets the class or strategy is used to extract this field Attention: this
+     * method set the contentTyp to {@link ContentType#CUSTOM}
+     * 
+     * @param fieldClass
+     *            The fieldClass to set.
+     */
+    public void setFieldClass(Class<? extends ContentStrategy> fieldClass) {
+        if(fieldClass == null)
+            throw new IllegalArgumentException("ContentStrategy must not be null");
+        if(!ReflectionUtils.extendsType(fieldClass,ContentStrategy.class))
+            throw new RuntimeException("The configured ContentStrategy does not extend ContentStrategy, can not use as a custom strategy -- "+fieldClass.getName());
+        if(!ReflectionUtils.hasDesiredConstructor(fieldClass,new Class[]{IndexSchemaField.class}))
+            throw new RuntimeException("Can not create instance of "+fieldClass.getName());
+        this.fieldClass = fieldClass;
+        /*
+         * set custom - field class is only needed by custom
+         */
+        this.contentType = ContentType.CUSTOM;
+    }
+
+    /**
+     * @return Returns the index.
+     */
+    public Index getIndex() {
+        return this.index;
+    }
+
+    /**
+     * @param index
+     *            The index to set.
+     */
+    public void setIndex(Index index) {
+        this.index = index;
+    }
+
+    /**
+     * @return Returns the name.
+     */
+    public String getName() {
+        return this.name;
+    }
+
+    /**
+     * @param name
+     *            The name to set.
+     */
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    /**
+     * @return Returns the path.
+     */
+    public String getPath() {
+        return this.path;
+    }
+
+    /**
+     * @param path
+     *            The path to set.
+     */
+    public void setPath(String path) {
+        this.path = path;
+    }
+
+    /**
+     * @return Returns the store.
+     */
+    public Store getStore() {
+        return this.store;
+    }
+
+    /**
+     * @param store
+     *            The store to set.
+     */
+    public void setStore(Store store) {
+        this.store = store;
+    }
+
+    /**
+     * @return Returns the type.
+     */
+    public ContentType getContentType() {
+        return this.contentType;
+    }
+
+    /**
+     * @param type
+     *            The type to set.
+     */
+    public void setContentType(ContentType type) {
+        this.contentType = type;
+
+    }
+
+    /**
+     * Sets the content type of this field by the name of the enum type. This
+     * method is not case sensitive.
+     * 
+     * @param type -
+     *            type name as string
+     */
+    public void setType(String type) {
+        ContentType[] types = ContentType.class.getEnumConstants();
+        for (int i = 0; i < types.length; i++) {
+            if (types[i].name().toLowerCase().equals(type)) {
+                this.contentType = types[i];
+                break;
+            }
+
+        }
+    }
+
+    /**
+     * Defines the {@link ContentStrategy} to use for a
+     * <tt>IndexSchemaField</tt> to extract the content from the entry
+     * 
+     * @author Simon Willnauer
+     * 
+     */
+    public enum ContentType {
+       
+        /**
+         * HTML content strategy {@link HTMLStrategy }
+         */
+        HTML,
+        /**
+         * XHTML content strategy {@link XHtmlStrategy }
+         */
+        XHTML,
+        /**
+         * Text content strategy {@link PlainTextStrategy }
+         */
+        TEXT,
+        /**
+         * GDataDate content strategy {@link GdataDateStrategy }
+         */
+        GDATADATE,
+        /**
+         * KEYWORD content strategy {@link KeywordStrategy }
+         */
+        KEYWORD,
+        /**
+         * Category content strategy {@link GdataCategoryStrategy }
+         */
+        CATEGORY,
+        /**
+         * Custom content strategy (user defined)
+         */
+        CUSTOM,
+        /**
+         * Mixed content strategy {@link MixedContentStrategy }
+         */
+        MIXED
+
+    }
+
+    /**
+     * @return Returns the boost.
+     */
+    public float getBoost() {
+        return this.boost;
+    }
+
+    /**
+     * @param boost
+     *            The boost to set.
+     */
+    public void setBoost(float boost) {
+        if (boost <= 0)
+            return;
+        this.boost = boost;
+    }
+
+    /**
+     * @see java.lang.Object#toString()
+     */
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder(this.getClass()
+                .getSimpleName()).append(" ");
+        builder.append("field name: ").append(this.name).append(" ");
+        builder.append("path: ").append(this.path).append(" ");
+        builder.append("content type ").append(this.contentType).append(" ");
+        builder.append("field class: ").append(this.fieldClass).append(" ");
+        builder.append("analyzer: ").append(this.analyzerClass).append(" ");
+        builder.append("boost: ").append(this.boost).append(" ");
+        builder.append("INDEX: ").append(this.index).append(" ");
+        builder.append("STORE: ").append(this.store);
+        return builder.toString();
+    }
+
+    /**
+     * Sets the Store class by simple name
+     * 
+     * @param name -
+     *            one of yes, no, compress
+     */
+    public void setStoreByName(String name) {
+        if (name.toLowerCase().equals("yes"))
+            this.store = Field.Store.YES;
+        else if (name.toLowerCase().equals("no"))
+            this.store = Field.Store.NO;
+        else if (name.toLowerCase().equals("compress"))
+            this.store = Field.Store.COMPRESS;
+    }
+
+    /**
+     * Sets the Index class by simple name
+     * 
+     * @param name -
+     *            un_tokenized, tokenized, no, no_norms
+     */
+    public void setIndexByName(String name) {
+        if (name.toLowerCase().equals("un_tokenized"))
+            this.index = Field.Index.UN_TOKENIZED;
+        else if (name.toLowerCase().equals("tokenized"))
+            this.index = Field.Index.TOKENIZED;
+        else if (name.toLowerCase().equals("no_norms"))
+            this.index = Field.Index.NO_NORMS;
+        else if (name.toLowerCase().equals("no"))
+            this.index = Field.Index.NO;
+    }
+
+    /**
+     * @return Returns the typePath.
+     */
+    public String getTypePath() {
+        return this.typePath;
+    }
+
+    /**
+     * @param typePath
+     *            The typePath to set.
+     */
+    public void setTypePath(String typePath) {
+        this.typePath = typePath;
+        /*
+         * set Mixed - this property is only needed by mixed type
+         */
+        setContentType(ContentType.MIXED);
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/config/package.html b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/config/package.html
new file mode 100755
index 0000000..2bb6076
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/config/package.html
@@ -0,0 +1,10 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
+<html> 
+<head> 
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
+   <meta name="Author" content="Simon Willnauer"> 
+</head> 
+<body> 
+All classes used for index and search configuration
+</body> 
+</html> 
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/GDataIndexDocument.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/GDataIndexDocument.java
new file mode 100755
index 0000000..1e2054c
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/GDataIndexDocument.java
@@ -0,0 +1,167 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.search.index;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.gdata.search.analysis.ContentStrategy;
+import org.apache.lucene.index.Term;
+
+/**
+ * Simple implementation
+ * 
+ * @author Simon Willnauer
+ * @see org.apache.lucene.gdata.search.index.IndexDocument
+ */
+class GDataIndexDocument implements IndexDocument {
+    private final IndexAction action;
+
+    private final boolean commitAfter;
+
+    private final boolean optimizeAfter;
+
+    private String id;
+
+    protected Collection<ContentStrategy> fields;
+
+    private final String feedId;
+
+    GDataIndexDocument(final IndexAction action, final String entryId,final String feedId,final boolean commitAfter,final boolean optimizeAfter) {
+        this.action = action;
+        this.id = entryId;
+        this.feedId = feedId;
+        this.fields = new ArrayList<ContentStrategy>(10);
+        this.commitAfter = commitAfter;
+        this.optimizeAfter = optimizeAfter;
+    }
+
+    /**
+     * Adds a new field e.g. <tt>ContentStrategy</tt> to the IndexDocument
+     * 
+     * @param field -
+     *            the strategy to add
+     */
+    public void addField(ContentStrategy field) {
+        if (field == null)
+            return;
+        this.fields.add(field);
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.search.index.IndexDocument#getWriteable()
+     */
+    public Document getWriteable() {
+        Document retVal = new Document();
+        retVal.add(new Field(FIELD_ENTRY_ID, this.id, Field.Store.YES,
+                Field.Index.UN_TOKENIZED));
+        retVal.add(new Field(FIELD_FEED_ID, this.feedId, Field.Store.YES,
+                Field.Index.UN_TOKENIZED));
+        for (ContentStrategy strategy : this.fields) {
+            Field[] fieldArray = strategy.createLuceneField();
+            for (int i = 0; i < fieldArray.length; i++) {
+                retVal.add(fieldArray[i]);
+            }
+            
+        }
+        return retVal;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.search.index.IndexDocument#getDeletealbe()
+     */
+    public Term getDeletealbe() {
+
+        return new Term(IndexDocument.FIELD_ENTRY_ID, this.id);
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.search.index.IndexDocument#isUpdate()
+     */
+    public boolean isUpdate() {
+
+        return isAction(IndexAction.UPDATE);
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.search.index.IndexDocument#isDelete()
+     */
+    public boolean isDelete() {
+
+        return isAction(IndexAction.DELETE);
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.search.index.IndexDocument#isInsert()
+     */
+    public boolean isInsert() {
+
+        return isAction(IndexAction.INSERT);
+    }
+
+    private boolean isAction(IndexAction indexAction) {
+        return this.action == indexAction;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.search.index.IndexDocument#commitAfter()
+     */
+    public boolean commitAfter() {
+
+        return this.commitAfter;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.search.index.IndexDocument#optimizeAfter()
+     */
+    public boolean optimizeAfter() {
+
+        return this.optimizeAfter;
+    }
+
+    /**
+     * @see java.lang.Object#equals(java.lang.Object)
+     */
+    @Override
+    public final boolean equals(Object obj) {
+        if(obj == null)
+            return false;
+        if(this == obj)
+            return true;
+        if(obj instanceof GDataIndexDocument){
+            GDataIndexDocument other = (GDataIndexDocument)obj; 
+            if(this.id == null)
+                return false;
+            return this.id.equals(other.id);
+        }
+        return false; 
+    }
+
+    /**
+     * @see java.lang.Object#hashCode()
+     */
+    @Override
+    public final int hashCode() {
+        if(this.id == null)
+            return super.hashCode();
+        return this.id.hashCode();
+    }
+    
+    
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/GDataIndexWriter.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/GDataIndexWriter.java
new file mode 100755
index 0000000..cffe493
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/GDataIndexWriter.java
@@ -0,0 +1,104 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.search.index;
+
+import java.io.IOException;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.analysis.standard.StandardAnalyzer;
+import org.apache.lucene.gdata.search.config.IndexSchema;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.store.Directory;
+
+/**
+ * Configurable decorator for a lucene {@link IndexWriter}
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class GDataIndexWriter extends IndexWriter {
+    private static final Log LOG = LogFactory.getLog(GDataIndexWriter.class);
+
+    private String serviceName;
+
+    private void initialize(IndexSchema config) {
+        this.serviceName = config.getName();
+        setUseCompoundFile(config.isUseCompoundFile());
+        if (config.getMaxBufferedDocs() != IndexSchema.NOT_SET_VALUE)
+            setMaxBufferedDocs(config.getMaxBufferedDocs());
+        if (config.getMaxMergeDocs() != IndexSchema.NOT_SET_VALUE)
+            setMaxMergeDocs(config.getMaxMergeDocs());
+        if (config.getMergeFactor() != IndexSchema.NOT_SET_VALUE)
+            setMergeFactor(config.getMergeFactor());
+        if (config.getMaxFieldLength() != IndexSchema.NOT_SET_VALUE)
+            setMaxFieldLength(config.getMaxFieldLength());
+        if (config.getWriteLockTimeout() != IndexSchema.NOT_SET_VALUE)
+            setWriteLockTimeout(config.getWriteLockTimeout());
+        //no commit lock anymore
+        //TODO fix this
+//        if (config.getCommitLockTimeout() != IndexSchema.NOT_SET_VALUE)
+//            setCommitLockTimeout(config.getCommitLockTimeout());
+    }
+
+    /**
+     * Creates and configures a new GdataIndexWriter
+     * 
+     * @param arg0 -
+     *            the index directory
+     * @param arg1 -
+     *            create index
+     * @param arg2 -
+     *            the index schema configuration including all parameter to set
+     *            up the index writer
+     * @throws IOException
+     *             -if the directory cannot be read/written to, or if it does
+     *             not exist, and <code>create</code> is <code>false</code>
+     */
+    protected GDataIndexWriter(Directory arg0, boolean arg1, IndexSchema arg2)
+            throws IOException {
+        /*
+         * Use Schema Analyzer rather than service analyzer. 
+         * Schema analyzer returns either the service analyzer or a per field analyzer if configured.
+         */
+        super(arg0, (arg2 == null ? new StandardAnalyzer() : arg2.getSchemaAnalyzer()), arg1);
+        if (arg2 == null) {
+            /*
+             * if no schema throw exception - schema is mandatory for the index writer.
+             */
+            try {
+                this.close();
+            } catch (IOException e) {
+                //
+            }
+            throw new IllegalArgumentException("configuration must not be null");
+
+        }
+        this.initialize(arg2);
+    }
+
+    /**
+     * @see org.apache.lucene.index.IndexWriter#close()
+     */
+    @Override
+    public void close() throws IOException {
+        super.close();
+        LOG.info("Closing GdataIndexWriter for service " + this.serviceName);
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/GDataIndexer.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/GDataIndexer.java
new file mode 100755
index 0000000..7cb8885
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/GDataIndexer.java
@@ -0,0 +1,510 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.search.index;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.search.config.IndexSchema;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.TermDocs;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.store.Directory;
+
+/**
+ * A GDataIndexer encapsulates every writing access to the search index.
+ * <p>
+ * Insert, updates and deletes to the index happens inside this class. All
+ * modification will be base on an instance of
+ * {@link org.apache.lucene.gdata.search.index.IndexDocument} which contains all
+ * informations and command for the indexer.<br>
+ * Although this class provides methods to add, remove and update document in
+ * the index all <tt>IndexDocument</tt> instances should be added to the task
+ * queue via the {@link GDataIndexer#addIndexableDocumentTask(Future)} method.
+ * Inside this class runs an instance of
+ * {@link org.apache.lucene.gdata.search.index.IndexTask} listening on this
+ * queue. The analysis of the actual documents happens inside the
+ * {@link com.sun.corba.se.impl.orbutil.closure.Future} object added to the
+ * queue. This enables the indexer to do his actual work. Documents will be
+ * build / analyzed concurrently while already finished tasks can be added to
+ * the index.
+ * </p>
+ * 
+ * 
+ * 
+ * @author Simon Willnauer
+ */
+public class GDataIndexer {
+    private static final Log LOG = LogFactory.getLog(GDataIndexer.class);
+
+    protected IndexWriter writer;
+
+    protected IndexSearcher searcher;
+
+    protected AtomicInteger committed = new AtomicInteger(0);
+
+    protected AtomicInteger optimized = new AtomicInteger(0);
+
+    private AtomicBoolean isDestroyed = new AtomicBoolean(false);
+
+    protected AtomicInteger docsAdded = new AtomicInteger();
+
+    protected AtomicInteger docsUpdated = new AtomicInteger();
+
+    protected AtomicInteger docsDeleted = new AtomicInteger();
+
+    private final Directory dir;
+
+    private final List<IndexEventListener> listeners = new ArrayList<IndexEventListener>();
+
+    protected final BlockingQueue<Future<IndexDocument>> futurQueue = new LinkedBlockingQueue<Future<IndexDocument>>(
+            100);
+
+    private final IndexSchema serviceConfiguration;
+
+    private final ExecutorService indexTaskExecutor;
+
+    protected IndexTask indexTask;
+
+    private static final Integer ZERO = new Integer(0);
+
+    private static final Integer ONE = new Integer(1);
+
+    private final Map<IndexDocument, Integer> action;
+
+    protected GDataIndexer(final IndexSchema schema, Directory dir,
+            boolean create) throws IOException {
+        if (schema == null)
+            throw new IllegalArgumentException(
+                    "IndexServiceConfiguration must not be null");
+        if (dir == null)
+            throw new IllegalArgumentException(
+                    "IndexDirectory must not be null");
+
+        this.serviceConfiguration = schema;
+        this.dir = dir;
+        openWriter(create);
+        this.indexTaskExecutor = Executors.newSingleThreadExecutor();
+        this.action = new HashMap<IndexDocument, Integer>(128);
+
+    }
+
+    protected void setIndexTask(final IndexTask task) {
+        if (task != null && this.indexTask == null)
+            this.indexTask = task;
+    }
+
+    protected void init() {
+        if (this.indexTask == null)
+            this.indexTask = new IndexTask(this, this.futurQueue);
+        this.indexTaskExecutor.execute(this.indexTask);
+
+    }
+
+    /**
+     * Adds the given future task to the queue, and waits if the queue is full.
+     * The queue size is set to 100 by default.
+     * 
+     * @param task -
+     *            the task to be scheduled
+     * @throws InterruptedException -
+     *             if the queue is interrupted
+     */
+    public void addIndexableDocumentTask(final Future<IndexDocument> task)
+            throws InterruptedException {
+        if (this.isDestroyed.get())
+            throw new IllegalStateException(
+                    "Indexer has already been destroyed");
+        this.futurQueue.put(task);
+    }
+
+    /*
+     * a added doc should not be in the index, be sure and delete possible
+     * duplicates
+     */
+    protected synchronized void addDocument(IndexDocument indexable)
+            throws IOException {
+        if (!indexable.isInsert())
+            throw new GdataIndexerException(
+                    "Index action must be set to insert");
+        setAction(indexable);
+        doWrite(indexable);
+        this.docsAdded.incrementAndGet();
+
+    }
+
+    private void setAction(IndexDocument doc) {
+        Integer docCountToKeep = this.action.get(doc);
+        if (!doc.isDelete() && (docCountToKeep == null || docCountToKeep == 0)) {
+            /*
+             * add a ONE for ONE documents to keep for this IndexDocument when
+             * doDelete. doDelete will keep the latest added document and
+             * deletes all other documents for this IndexDocument e.g. all
+             * duplicates
+             */
+            this.action.put(doc, ONE);
+        } else if (doc.isDelete()
+                && (docCountToKeep == null || docCountToKeep > 0)) {
+            /*
+             * add a zero for zero documents to keep for this IndexDocument when
+             * doDelete
+             */
+            this.action.put(doc, ZERO);
+        }
+    }
+
+    protected synchronized void updateDocument(IndexDocument indexable)
+            throws IOException {
+        if (!indexable.isUpdate())
+            throw new GdataIndexerException(
+                    "Index action must be set to update");
+        setAction(indexable);
+        doWrite(indexable);
+        this.docsUpdated.incrementAndGet();
+    }
+
+    protected synchronized void deleteDocument(IndexDocument indexable) {
+        if (!indexable.isDelete())
+            throw new GdataIndexerException(
+                    "Index action must be set to delete");
+
+        setAction(indexable);
+        this.docsDeleted.incrementAndGet();
+    }
+
+    /**
+     * This method commits all changes to the index and closes all open
+     * resources (e.g. IndexWriter and IndexReader). This method notifies all
+     * registered Commit listeners if invoked.
+     * 
+     * @param optimize -
+     *            <code>true</code> if the index should be optimized on this
+     *            commit
+     * @throws IOException -
+     *             if an IOException occurs
+     */
+    protected synchronized void commit(boolean optimize) throws IOException {
+        if (LOG.isInfoEnabled())
+            LOG.info("Commit called with optimize = " + optimize);
+
+        int changes = this.docsAdded.intValue() + this.docsDeleted.intValue()
+                + this.docsUpdated.intValue();
+        /*
+         * don't call listeners to prevent unnecessary close / open of searchers
+         */
+        if (changes == 0)
+            return;
+        this.committed.incrementAndGet();
+        if(optimize)
+            this.optimized.incrementAndGet();
+        doDeltete();
+        if (optimize) {
+            closeSearcher();
+            openWriter();
+            this.writer.optimize();
+        }
+        closeSearcher();
+        closeWriter();
+        this.docsAdded.set(0);
+        this.docsDeleted.set(0);
+        this.docsUpdated.set(0);
+        notifyCommitListeners(this.serviceConfiguration.getName());
+
+    }
+
+    /**
+     * Registers a new IndexEventListener. All registered listeners will be
+     * notified if the index has been committed.
+     * 
+     * @param listener -
+     *            the listener to register
+     * 
+     */
+    public void registerIndexEventListener(IndexEventListener listener) {
+        if (listener == null || this.listeners.contains(listener))
+            return;
+        this.listeners.add(listener);
+    }
+
+    /**
+     * Removes a registered IndexEventListener
+     * 
+     * @param listener -
+     *            the listener to remove
+     */
+    public void removeIndexEventListener(IndexEventListener listener) {
+
+        if (listener == null || !this.listeners.contains(listener))
+            return;
+        this.listeners.remove(listener);
+    }
+
+    protected void notifyCommitListeners(String serviceId) {
+        if (LOG.isInfoEnabled())
+            LOG.info("notify commit event listeners for service id: "
+                    + serviceId + " --  current size of registered listeners: "
+                    + this.listeners.size());
+        for (IndexEventListener listener : this.listeners) {
+            listener.commitCallBack(serviceId);
+        }
+    }
+
+    protected void closeWriter() throws IOException {
+        try {
+            if (this.writer != null)
+                this.writer.close();
+        } finally {
+            this.writer = null;
+        }
+    }
+
+    protected void closeSearcher() throws IOException {
+        try {
+            if (this.searcher != null)
+                this.searcher.close();
+        } finally {
+            this.searcher = null;
+        }
+    }
+
+    protected void openSearcher() throws IOException {
+        if (this.searcher == null)
+            this.searcher = new IndexSearcher(this.dir);
+    }
+
+    protected void openWriter() throws IOException {
+        openWriter(false);
+    }
+
+    private void openWriter(boolean create) throws IOException {
+        if (this.writer == null)
+            this.writer = new GDataIndexWriter(this.dir, create,
+                    this.serviceConfiguration);
+    }
+
+    /*
+     * This should only be called in a synchronized block
+     */
+    protected void doWrite(IndexDocument document) throws IOException {
+        closeSearcher();
+        openWriter();
+        this.writer.addDocument(document.getWriteable());
+
+    }
+
+    // only access synchronized
+    int[] documentNumber;
+
+    /*
+     * This should only be called in a synchronized block
+     */
+    protected void doDeltete() throws IOException {
+        if (this.action.size() == 0)
+            return;
+        if (LOG.isInfoEnabled())
+            LOG
+                    .info("Deleting documents and duplicates from index, size of IndexDocuments "
+                            + this.action.size());
+        closeWriter();
+        openSearcher();
+
+        IndexReader reader = this.searcher.getIndexReader();
+        TermDocs termDocs = reader.termDocs();
+        for (Map.Entry<IndexDocument, Integer> entry : this.action.entrySet()) {
+            IndexDocument indexDocument = entry.getKey();
+            Integer docToKeep = entry.getValue();
+            // extend the array if needed
+            if (this.documentNumber == null
+                    || docToKeep > this.documentNumber.length)
+                this.documentNumber = new int[docToKeep];
+
+            for (int i = 0; i < this.documentNumber.length; i++) {
+
+                this.documentNumber[i] = -1;
+            }
+            /*
+             * get the term to find the document from the document itself
+             */
+            termDocs.seek(indexDocument.getDeletealbe());
+
+            int pos = 0;
+
+            while (termDocs.next()) {
+                /*
+                 * if this is a pure delete just delete it an continue
+                 */
+                if (docToKeep == 0) {
+                    reader.deleteDocument(termDocs.doc());
+                    continue;
+                }
+
+                int prev = this.documentNumber[pos];
+                this.documentNumber[pos] = termDocs.doc();
+                if (prev != -1) {
+                    reader.deleteDocument(prev);
+                }
+
+                if (++pos >= docToKeep)
+                    pos = 0;
+
+            }
+        }
+        /*
+         * clear the map after all documents are processed
+         */
+        this.action.clear();
+        closeSearcher();
+    }
+
+    protected synchronized void destroy() throws IOException {
+        this.isDestroyed.set(true);
+        if (!this.indexTask.isStopped())
+            this.indexTask.stop();
+        this.futurQueue.add(new FinishingFuture());
+        this.indexTaskExecutor.shutdown();
+        closeWriter();
+        closeSearcher();
+        if (LOG.isInfoEnabled())
+            LOG.info("Destroying GdataIndexer for service -- "
+                    + this.serviceConfiguration.getName());
+
+    }
+
+    /**
+     * This factory method creates a new GDataIndexer using a instance of
+     * {@link IndexTask}
+     * 
+     * @param config -
+     *            the config to be used to configure the indexer
+     * @param dir -
+     *            the directory to index to
+     * @param create -
+     *            <code>true</code> to create a new index, <code>false</code>
+     *            to use the existing one.
+     * @return - a new GDataIndexer instance
+     * @throws IOException -
+     *             if an IOException occurs while initializing the indexer
+     */
+    public static synchronized GDataIndexer createGdataIndexer(
+            final IndexSchema config, Directory dir, boolean create)
+            throws IOException {
+        GDataIndexer retVal = new GDataIndexer(config, dir, create);
+        retVal.setIndexTask(new IndexTask(retVal, retVal.futurQueue));
+        retVal.init();
+        return retVal;
+    }
+
+    /**
+     * This factory method creates a new GDataIndexer using a instance of
+     * {@link TimedIndexTask}. This indexer will automatically commit the index
+     * if no modification to the index occur for the given time. The used time
+     * unit is {@link TimeUnit#SECONDS}. Values less than the default value
+     * will be ignored. For the default value see {@link TimedIndexTask}.
+     * 
+     * @param config -
+     *            the config to be used to configure the indexer
+     * @param dir -
+     *            the directory to index to
+     * @param create -
+     *            <code>true</code> to create a new index, <code>false</code>
+     *            to use the existing one.
+     * @param commitTimeout -
+     *            the amount of seconds to wait until a commit should be
+     *            scheduled
+     * @return - a new GDataIndexer instance
+     * @throws IOException -
+     *             if an IOException occurs while initializing the indexer
+     */
+    public static synchronized GDataIndexer createTimedGdataIndexer(
+            final IndexSchema config, Directory dir, boolean create,
+            long commitTimeout) throws IOException {
+
+        GDataIndexer retVal = new GDataIndexer(config, dir, create);
+        retVal.setIndexTask(new TimedIndexTask(retVal, retVal.futurQueue,
+                commitTimeout));
+        retVal.init();
+        return retVal;
+    }
+
+    @SuppressWarnings("unused")
+    static final class FinishingFuture implements Future<IndexDocument> {
+
+        /**
+         * @see java.util.concurrent.Future#cancel(boolean)
+         */
+        public boolean cancel(boolean arg0) {
+
+            return false;
+        }
+
+        /**
+         * @see java.util.concurrent.Future#isCancelled()
+         */
+        public boolean isCancelled() {
+
+            return false;
+        }
+
+        /**
+         * @see java.util.concurrent.Future#isDone()
+         */
+        public boolean isDone() {
+
+            return true;
+        }
+
+        /**
+         * @see java.util.concurrent.Future#get()
+         */
+        @SuppressWarnings("unused")
+        public IndexDocument get() throws InterruptedException,
+                ExecutionException {
+
+            return null;
+        }
+
+        /**
+         * @see java.util.concurrent.Future#get(long,
+         *      java.util.concurrent.TimeUnit)
+         */
+        @SuppressWarnings("unused")
+        public IndexDocument get(long arg0, TimeUnit arg1)
+                throws InterruptedException, ExecutionException,
+                TimeoutException {
+
+            return null;
+        }
+
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/GdataIndexerException.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/GdataIndexerException.java
new file mode 100755
index 0000000..037b8f8
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/GdataIndexerException.java
@@ -0,0 +1,75 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.search.index;
+
+/**
+ * This exception will be thrown if an exception in the indexing component
+ * occurs
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class GdataIndexerException extends RuntimeException {
+
+    private static final long serialVersionUID = -8245420079471690182L;
+
+    /**
+     * Creates a new GdataIndexerException
+     */
+    public GdataIndexerException() {
+        super();
+
+    }
+
+    /**
+     * Creates a new GdataIndexerException with a new exception message
+     * 
+     * @param arg0 -
+     *            exception message
+     */
+    public GdataIndexerException(String arg0) {
+        super(arg0);
+
+    }
+
+    /**
+     * Creates a new GdataIndexerException with a new exception message and a
+     * root cause
+     * 
+     * @param arg0 -
+     *            exception message
+     * @param arg1 -
+     *            the root cause
+     */
+    public GdataIndexerException(String arg0, Throwable arg1) {
+        super(arg0, arg1);
+
+    }
+
+    /**
+     * Creates a new GdataIndexerException with a root cause
+     * 
+     * @param arg0 -
+     *            the root cause
+     */
+    public GdataIndexerException(Throwable arg0) {
+        super(arg0);
+
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/IndexAction.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/IndexAction.java
new file mode 100755
index 0000000..55c17ed
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/IndexAction.java
@@ -0,0 +1,38 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.search.index;
+
+/**
+ * This enum defines all possible actions on a GData index.
+ * 
+ * @see org.apache.lucene.gdata.search.index.IndexDocument
+ * @see org.apache.lucene.gdata.search.index.IndexDocumentBuilderTask
+ * @author Simon Willnauer
+ * 
+ */
+public enum IndexAction {
+    /**
+     * update action
+     */
+    UPDATE, /**
+             * delete action
+             */
+    DELETE, /**
+             * insert / add action
+             */
+    INSERT
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/IndexController.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/IndexController.java
new file mode 100755
index 0000000..5fad024
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/IndexController.java
@@ -0,0 +1,547 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.search.index;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Collection;
+import java.util.Map;
+import java.util.Set;
+import java.util.Map.Entry;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.data.ServerBaseFeed;
+import org.apache.lucene.gdata.search.GDataSearcher;
+import org.apache.lucene.gdata.search.SearchComponent;
+import org.apache.lucene.gdata.search.StandardGdataSearcher;
+import org.apache.lucene.gdata.search.config.IndexSchema;
+import org.apache.lucene.gdata.server.registry.Component;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+import org.apache.lucene.gdata.server.registry.EntryEventListener;
+import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
+import org.apache.lucene.gdata.server.registry.ProvidedService;
+import org.apache.lucene.gdata.utils.ReferenceCounter;
+import org.apache.lucene.index.IndexFileNameFilter;
+import org.apache.lucene.search.Filter;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.FSDirectory;
+
+/**
+ * Default implementation of the {@link SearchComponent} interface. All actions
+ * on the index will be controlled from this class. Only this class grants read
+ * or write actions access to the index.
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+@Component(componentType = ComponentType.SEARCHCONTROLLER)
+public class IndexController implements SearchComponent, IndexEventListener,
+        EntryEventListener {
+    static final Log LOG = LogFactory.getLog(IndexController.class);
+
+    private final AtomicBoolean isInitialized = new AtomicBoolean(false);
+
+    private final AtomicBoolean destroyed = new AtomicBoolean(false);
+
+    protected Map<String, ServiceIndex> indexerMap;
+
+    private final ExecutorService taskExecutor;
+
+    /**
+     * Creates a new IndexController -- call
+     * {@link IndexController#initialize()} to set up the controller.
+     */
+    public IndexController() {
+        this.taskExecutor = Executors.newCachedThreadPool();
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.search.SearchComponent#initialize()
+     */
+    public synchronized void initialize() {
+        if (this.isInitialized.get())
+            throw new IllegalStateException(
+                    "IndexController is already initialized");
+        this.destroyed.set(false);
+        /*
+         * if this fails the server must not startup --> throw runtime exception
+         */
+        GDataServerRegistry.getRegistry().registerEntryEventListener(this);
+
+        GDataServerRegistry.getRegistry().registerEntryEventListener(this);
+        Collection<ProvidedService> services = GDataServerRegistry
+                .getRegistry().getServices();
+        this.indexerMap = new ConcurrentHashMap<String, ServiceIndex>(services
+                .size());
+       
+        for (ProvidedService service : services) {
+            IndexSchema schema = service.getIndexSchema();
+            /*
+             * initialize will fail if mandatory values are not set. This is
+             * just a
+             */
+            schema.initialize();
+            addIndexSchema(schema);
+        }
+        this.isInitialized.set(true);
+        
+
+    }
+
+    /*
+     * add a schema to the index controller and create the indexer. create
+     * directories and check out existing indexes
+     */
+    protected void addIndexSchema(final IndexSchema schema) {
+        checkDestroyed();
+        if (schema.getName() == null)
+            throw new IllegalStateException(
+                    "schema has no name -- is not associated with any service");
+        if (this.indexerMap.containsKey(schema.getName()))
+            throw new IllegalStateException("schema for service "
+                    + schema.getName() + " is already registered");
+        if (LOG.isInfoEnabled())
+            LOG.info("add new IndexSchema for service " + schema.getName()
+                    + " -- " + schema);
+        try {
+            ServiceIndex bean = createIndexer(schema);
+            ReferenceCounter<IndexSearcher> searcher = getNewServiceSearcher(bean.getDirectory());
+            bean.setSearcher(searcher);
+            this.indexerMap.put(schema.getName(), bean);
+        } catch (IOException e) {
+            LOG.error("Can not create indexer for service " + schema.getName(),
+                    e);
+            throw new GdataIndexerException(
+                    "Can not create indexer for service " + schema.getName(), e);
+        }
+
+    }
+
+    protected ServiceIndex createIndexer(final IndexSchema schema) throws IOException {
+        GDataIndexer indexer;
+        File indexLocation = createIndexLocation(schema.getIndexLocation(),
+                schema.getName());
+        boolean create = createIndexDirectory(indexLocation);
+        Directory dir = FSDirectory.getDirectory(indexLocation, create);
+        if (LOG.isInfoEnabled())
+            LOG.info("Create new Indexer for IndexSchema: " + schema);
+        /*
+         * timed or committed indexer?! keep the possibility to let users decide
+         * to use scheduled commits
+         */
+        if (schema.isUseTimedIndexer())
+            indexer = GDataIndexer.createTimedGdataIndexer(schema, dir, create,
+                    schema.getIndexerIdleTime());
+        else
+            indexer = GDataIndexer.createGdataIndexer(schema, dir, create);
+        indexer.registerIndexEventListener(this);
+        return new ServiceIndex(schema, indexer, dir);
+    }
+
+    /*
+     * if this fails the server must not startup!!
+     */
+    protected File createIndexLocation(final String path,final  String name) {
+        if (path == null || name == null)
+            throw new GdataIndexerException(
+                    "Path or Name of the index location is not set Path: "
+                            + path + " name: " + name);
+        /*
+         * check if parent e.g. the configured path is a directory
+         */
+        File parent = new File(path);
+        if (!parent.isDirectory())
+            throw new IllegalArgumentException(
+                    "the given path is not a directory -- " + path);
+        /*
+         * try to create and throw ex if fail
+         */
+        if (!parent.exists())
+            if (!parent.mkdir())
+                throw new RuntimeException("Can not create directory -- "
+                        + path);
+        /*
+         * try to create and throw ex if fail
+         */
+        File file = new File(parent, name);
+        if (file.isFile())
+            throw new IllegalArgumentException(
+                    "A file with the name"
+                            + name
+                            + " already exists in "
+                            + path
+                            + " -- a file of the name of the service must not exist in the index location");
+
+        if (!file.exists()) {
+            if (!file.mkdir())
+                throw new RuntimeException("Can not create directory -- "
+                        + file.getAbsolutePath());
+        }
+        return file;
+    }
+
+    protected boolean createIndexDirectory(final File file) {
+        /*
+         * use a lucene filename filter to figure out if there is an existing
+         * index in the defined directory
+         */
+        String[] luceneFiles = file.list(new IndexFileNameFilter());
+        return !(luceneFiles.length > 0);
+
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.search.index.IndexEventListener#commitCallBack(java.lang.String)
+     */
+    public synchronized void commitCallBack(final String service) {
+        checkDestroyed();
+        if(LOG.isInfoEnabled())
+            LOG.info("CommitCallback triggered - register new searcher for service: "+service);
+        /*
+         * get the old searcher and replace it if possible.
+         */
+        ServiceIndex index = this.indexerMap.get(service);
+        ReferenceCounter<IndexSearcher> searcher = index.getSearcher();
+
+        try {
+            index.setSearcher(getNewServiceSearcher(index.getDirectory()));
+        } catch (IOException e) {
+            LOG.fatal("Can not create new Searcher -- keep the old one ", e);
+            return;
+        }
+        /*
+         * if new searcher if registered decrement old one to get it destroyed if unused
+         */
+        searcher.decrementRef();
+    }
+    /*
+     * create a new ReferenceCounter for the indexSearcher.
+     * The reference is already incremented before returned
+     */
+    private ReferenceCounter<IndexSearcher> getNewServiceSearcher(final Directory dir)
+            throws IOException {
+        if(LOG.isInfoEnabled())
+            LOG.info("Create new ServiceSearcher");
+        IndexSearcher searcher = new IndexSearcher(dir);
+        ReferenceCounter<IndexSearcher> holder = new ReferenceCounter<IndexSearcher>(
+                searcher) {
+
+            @Override
+            protected void close() {
+                try {
+                    LOG
+                            .info("Close IndexSearcher -- Zero references remaining");
+                    this.resource.close();
+                } catch (IOException e) {
+                    LOG.warn("Can not close IndexSearcher -- ", e);
+                }
+            }
+
+        };
+        holder.increamentReference();
+        return holder;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.registry.EntryEventListener#fireUpdateEvent(org.apache.lucene.gdata.data.ServerBaseEntry)
+     */
+    public void fireUpdateEvent(final ServerBaseEntry entry) {
+        createNewIndexerTask(entry, IndexAction.UPDATE);
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.registry.EntryEventListener#fireInsertEvent(org.apache.lucene.gdata.data.ServerBaseEntry)
+     */
+    public void fireInsertEvent(final ServerBaseEntry entry) {
+        createNewIndexerTask(entry, IndexAction.INSERT);
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.registry.EntryEventListener#fireDeleteEvent(org.apache.lucene.gdata.data.ServerBaseEntry)
+     */
+    public void fireDeleteEvent(final ServerBaseEntry entry) {
+        createNewIndexerTask(entry, IndexAction.DELETE);
+
+    }
+    
+    /**
+     * @see org.apache.lucene.gdata.server.registry.EntryEventListener#fireDeleteAllEntries(org.apache.lucene.gdata.data.ServerBaseFeed)
+     */
+    public void fireDeleteAllEntries(final ServerBaseFeed feed) {
+        createNewDeleteAllEntriesTask(feed);
+    }
+    
+    private void createNewDeleteAllEntriesTask(final ServerBaseFeed feed){
+        checkDestroyed();
+        checkInitialized();
+        if(LOG.isInfoEnabled())
+            LOG.info("Deleting all entries for feed dispatch new IndexDocumentBuilder -- "+feed.getId());
+        String serviceName = feed.getServiceConfig().getName();
+        ServiceIndex bean = this.indexerMap.get(serviceName);
+        if (bean == null)
+            throw new RuntimeException("no indexer for service " + serviceName
+                    + " registered");
+        Lock lock = bean.getLock();
+        lock.lock();
+        try{
+            IndexDocumentBuilder<IndexDocument> callable = new IndexFeedDeleteTask(feed.getId());
+            sumbitTask(callable,bean.getIndexer());
+        }finally{
+            lock.unlock();
+        }
+            
+        
+    }
+
+    // TODO add test for this method!!
+    private void createNewIndexerTask(final ServerBaseEntry entry, final IndexAction action) {
+        checkDestroyed();
+        checkInitialized();
+        String serviceName = entry.getServiceConfig().getName();
+        if (LOG.isInfoEnabled())
+            LOG.info("New Indexer Task submitted - Action: " + action
+                    + " for service: " + serviceName);
+        ServiceIndex bean = this.indexerMap.get(serviceName);
+        if (bean == null)
+            throw new RuntimeException("no indexer for service " + serviceName
+                    + " registered");
+        /*
+         * lock on service to synchronize the event order. This lock has
+         * fairness parameter set to true. Grant access to the longest waiting
+         * thread. Using fairness is slower but is acceptable in this context
+         */
+        Lock lock = bean.getLock();
+        lock.lock();
+        try {
+            IndexSchema schema = bean.getSchema();
+            boolean commitAfter = bean.incrementActionAndReset(schema.getCommitAfterDocuments());
+            IndexDocumentBuilder<IndexDocument> callable = new IndexDocumentBuilderTask<IndexDocument>(
+                    entry, bean.getSchema(), action, commitAfter,bean.getOptimize(schema.getOptimizeAfterCommit()));
+            sumbitTask(callable,bean.getIndexer());
+        } finally {
+            /*
+             * make sure to unlock
+             */
+            lock.unlock();
+        }
+
+    }
+
+    private void sumbitTask(final Callable<IndexDocument> callable, final GDataIndexer indexer){
+        Future<IndexDocument> task = this.taskExecutor.submit(callable);
+        try {
+            indexer.addIndexableDocumentTask(task);
+        } catch (InterruptedException e) {
+            throw new GdataIndexerException(
+                    "Can not accept any index tasks -- interrupted. ", e);
+
+        }
+    }    
+
+    /**
+     * @see org.apache.lucene.gdata.search.SearchComponent#getServiceSearcher(org.apache.lucene.gdata.server.registry.ProvidedService)
+     */
+    public GDataSearcher<String> getServiceSearcher(final ProvidedService service) {
+        checkDestroyed();
+        checkInitialized();
+
+        /*
+         * get and increment. searcher will be decremented if GdataSearcher is
+         * closed
+         */
+        ReferenceCounter<IndexSearcher> searcher;
+        synchronized (this) {
+            ServiceIndex serviceIndex = this.indexerMap.get(service.getName());
+            if(serviceIndex == null)
+                throw new RuntimeException("no index for service "+service.getName());
+            searcher = serviceIndex.getSearcher();
+            searcher.increamentReference();
+        }
+
+        return new StandardGdataSearcher(searcher);
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.search.SearchComponent#destroy()
+     */
+    public synchronized void destroy() {
+        checkDestroyed();
+        if(!this.isInitialized.get())
+            return;
+        this.destroyed.set(true);
+        this.isInitialized.set(false);
+        LOG.info("Shutting down IndexController -- destroy has been called");
+        Set<Entry<String, ServiceIndex>> entrySet = this.indexerMap.entrySet();
+        for (Entry<String, ServiceIndex> entry : entrySet) {
+            ServiceIndex bean = entry.getValue();
+            bean.getSearcher().decrementRef();
+            GDataIndexer indexer = bean.getIndexer();
+            try {
+                indexer.destroy();
+            } catch (IOException e) {
+                LOG.warn("Can not destroy indexer for service: "
+                        + bean.getSchema().getName(), e);
+            }
+        }
+        this.taskExecutor.shutdown();
+        this.indexerMap.clear();
+    }
+
+    private void checkDestroyed(){
+        if (this.destroyed.get())
+            throw new IllegalStateException(
+                    "IndexController has been destroyed");   
+    }
+    private void checkInitialized(){
+        if(!this.isInitialized.get())
+            throw new IllegalStateException(
+            "IndexController has not been initialized");
+    }   
+    
+    
+    final static class ServiceIndex {
+        private AtomicInteger actionCount = new AtomicInteger(0);
+        
+        private AtomicInteger commitCount = new AtomicInteger(0);
+        
+        private final Lock lock;
+
+        private final IndexSchema schema;
+
+        private final GDataIndexer indexer;
+
+        private final Directory directory;
+        
+        private Filter addedDocumentFilter;
+        
+        private ReferenceCounter<IndexSearcher> searcher;
+
+        // private final Map<String,IndexAction> actionMap;
+
+       
+
+        ServiceIndex(final IndexSchema schema, GDataIndexer indexer,
+                Directory directory) {
+            this.schema = schema;
+            this.indexer = indexer;
+            this.lock = new ReentrantLock(true);
+            this.directory = directory;
+            // this.actionMap = new HashMap<String,IndexAction>(128);
+        }
+
+        Lock getLock() {
+            return this.lock;
+        }
+
+        /**
+         * @return Returns the indexer.
+         */
+        GDataIndexer getIndexer() {
+            return this.indexer;
+        }
+
+        /**
+         * @return Returns the schema.
+         */
+        IndexSchema getSchema() {
+            return this.schema;
+        }
+
+        // public void addAction(IndexAction action,ServerBaseEntry entry){
+        //            
+        // }
+        /**
+         * Counts how many actions have been executed on this index
+         * 
+         * @param reset - count mod reset value equals 0 causes a commit
+         *            
+         * @return <code>true</code> if the count mod reset value equals 0, otherwise
+         *         false;
+         */
+        boolean incrementActionAndReset(int reset) {
+            if (this.actionCount.incrementAndGet()%reset == 0) {
+                return true;
+            }
+            return false;
+        }
+
+        /**
+         * @return Returns the directory.
+         */
+        public Directory getDirectory() {
+            return this.directory;
+        }
+        /**
+         * @return Returns the addedDocumentFilter.
+         */
+        public Filter getAddedDocumentFilter() {
+            return this.addedDocumentFilter;
+        }
+
+        /**
+         * @param addedDocumentFilter The addedDocumentFilter to set.
+         */
+        public void setAddedDocumentFilter(Filter addedDocumentFilter) {
+            this.addedDocumentFilter = addedDocumentFilter;
+        }
+
+        /**
+         * @return Returns the searcher.
+         */
+        public ReferenceCounter<IndexSearcher> getSearcher() {
+            return this.searcher;
+        }
+
+        /**
+         * @param searcher The searcher to set.
+         */
+        public void setSearcher(ReferenceCounter<IndexSearcher> searcher) {
+            this.searcher = searcher;
+        }
+
+        /**
+         * @return Returns the commitCount.
+         */
+        public int commitCountIncrement() {
+            return this.commitCount.incrementAndGet();
+        }
+        /**
+         * @param reset - the number after how many commits the index should be optimized
+         * @return <code>true</code> if and only if the commit count mod reset equals 0, otherwise <code>false</code>.
+         */
+        public boolean getOptimize(int reset){
+            if(this.commitCount.get()%reset == 0){
+                return true;
+            }
+            return false;
+        }
+    }
+
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/IndexDocument.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/IndexDocument.java
new file mode 100755
index 0000000..feee6c5
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/IndexDocument.java
@@ -0,0 +1,100 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.search.index;
+
+import org.apache.lucene.document.Document;
+import org.apache.lucene.index.Term;
+
+/**
+ * IndexDocument encapsulates the acual entity to store, update or delete. All
+ * infomation to process the action on this document are provided via this
+ * interface.
+ * <p>
+ * This enables the GDataIndexer to index every kind of document. All the
+ * processing of the original document happens somewhere behind this facade.
+ * {@link org.apache.lucene.gdata.search.index.IndexDocumentBuilderTask} passed
+ * to the {@link org.apache.lucene.gdata.search.index.GDataIndexer} task queue
+ * produce instances of this interface concurrently.
+ * </p>
+ * 
+ * @author Simon Willnauer
+ * 
+ * 
+ */
+public interface IndexDocument {
+    /**
+     * the index field to identify a document in the index. This acts as a
+     * primary key to fetch the entire entry from the storage
+     */
+    public static final String FIELD_ENTRY_ID = "enryId";
+    /**
+     * the index field to associate a document with a specific feed 
+     */
+    public static final String FIELD_FEED_ID = "feedId";
+    public static final String GDATA_MANDATORY_FIELD_UPDATED = "updated";
+    public static final String GDATA_MANDATORY_FIELD_CATEGORY = "category";
+
+    /**
+     * @return <code>true</code> if and only if this document is an update,
+     *         otherwise <code>false</code>
+     */
+    public abstract boolean isUpdate();
+
+    /**
+     * @return <code>true</code> if and only if this document is a delete,
+     *         otherwise <code>false</code>
+     */
+    public abstract boolean isDelete();
+
+    /**
+     * @return <code>true</code> if and only if this document is an insert,
+     *         otherwise <code>false</code>
+     */
+    public abstract boolean isInsert();
+
+    /**
+     * 
+     * @return - the lucene document to write to the index if the action is
+     *         insert or updated, otherwise it will return <code>null</code>;
+     */
+    public abstract Document getWriteable();
+
+    /**
+     * @return - a term that identifies this document in the index to delete
+     *         this document on a update or delete
+     */
+    public abstract Term getDeletealbe();
+
+    /**
+     * Indicates that the index should be commited after this document has been
+     * processed
+     * 
+     * @return <code>true</code> if the index should be commited after this
+     *         document, otherwise <code>false</code>
+     */
+    public abstract boolean commitAfter();
+
+    /**
+     * Indicates that the index should be optimized after this document has been
+     * processed
+     * 
+     * 
+     * @return <code>true</code> if the index should be optimized after this
+     *         document, otherwise <code>false</code>
+     */
+    public abstract boolean optimizeAfter();
+    
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/IndexDocumentBuilder.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/IndexDocumentBuilder.java
new file mode 100755
index 0000000..77df6ae
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/IndexDocumentBuilder.java
@@ -0,0 +1,33 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.search.index;
+
+import java.util.concurrent.Callable;
+
+/**
+ * Interface for DocumentBuilders
+ * @author Simon Willnauer
+ * @param <T> IndexDocument implementation
+ *
+ */
+public interface IndexDocumentBuilder<T extends IndexDocument> extends Callable<T>{
+    /**
+     * @see java.util.concurrent.Callable#call()
+     */
+    public T call() throws GdataIndexerException; 
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/IndexDocumentBuilderTask.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/IndexDocumentBuilderTask.java
new file mode 100755
index 0000000..75e0690
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/IndexDocumentBuilderTask.java
@@ -0,0 +1,105 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.search.index;
+
+import java.util.Collection;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.search.analysis.ContentStrategy;
+import org.apache.lucene.gdata.search.analysis.Indexable;
+import org.apache.lucene.gdata.search.analysis.NotIndexableException;
+import org.apache.lucene.gdata.search.config.IndexSchema;
+import org.apache.lucene.gdata.search.config.IndexSchemaField;
+
+/**
+ * This callable does all of the entiti processing concurrently while added to
+ * the {@link org.apache.lucene.gdata.search.index.GDataIndexer} task queue;
+ * 
+ * @see org.apache.lucene.gdata.search.analysis.Indexable
+ * @see org.apache.lucene.gdata.search.analysis.ContentStrategy
+ * @author Simon Willnauer
+ * 
+ */
+class IndexDocumentBuilderTask<T extends IndexDocument> implements IndexDocumentBuilder<T> {
+    private static final Log LOG = LogFactory
+            .getLog(IndexDocumentBuilderTask.class);
+
+    private final ServerBaseEntry entry;
+
+    private final IndexSchema schema;
+
+    private final IndexAction action;
+
+    private final boolean commitAfter;
+    private final boolean optimizeAfter;
+    protected IndexDocumentBuilderTask(final ServerBaseEntry entry,
+            final IndexSchema schema, IndexAction action, boolean commitAfter, boolean optimizeAfter) {
+        /*
+         * omit check for null parameter this happens in the controller.
+         */
+        this.schema = schema;
+        this.entry = entry;
+        this.action = action;
+        this.commitAfter = commitAfter;
+        this.optimizeAfter = optimizeAfter;
+    }
+
+    /**
+     * @see java.util.concurrent.Callable#call()
+     */
+    @SuppressWarnings("unchecked")
+    public T call() throws GdataIndexerException {
+        
+        Collection<IndexSchemaField> fields = this.schema.getFields();
+        GDataIndexDocument document = new GDataIndexDocument(this.action,
+                this.entry.getId(),this.entry.getFeedId(), this.commitAfter,this.optimizeAfter);
+        if(this.action != IndexAction.DELETE){
+        int addedFields = 0;
+        for (IndexSchemaField field : fields) {
+            /*
+             * get the strategy to process the field
+             */
+            ContentStrategy strategy = ContentStrategy.getFieldStrategy(field);
+            if (LOG.isInfoEnabled())
+                LOG.info("Process indexable for " + field);
+            try {
+                /*
+                 * get the indexable via the factory method to enable new /
+                 * different implementation of the interface (this could be a
+                 * faster dom impl e.g. dom4j)
+                 */
+                strategy.processIndexable(Indexable.getIndexable(this.entry));
+                addedFields++;
+            } catch (NotIndexableException e) {
+                LOG.warn("Can not create field for " + field+" field will be skipped -- reason: ", e);
+                continue;
+            }
+         
+            document.addField(strategy);
+
+        }
+        if(addedFields == 0)
+            throw new GdataIndexerException("No field added to document for Schema: "+this.schema); 
+        }
+        return (T)document;
+    }
+
+    
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/IndexEventListener.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/IndexEventListener.java
new file mode 100755
index 0000000..249ecaf
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/IndexEventListener.java
@@ -0,0 +1,36 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.search.index;
+
+/**
+ * This interface should be implemented by classes need to be notified when an
+ * index is commited
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public interface IndexEventListener {
+
+    /**
+     * This method will be invoked by an instance of {@link GDataIndexer} if the
+     * index is commited
+     * 
+     * @param service -
+     *            the name of the service the invoking indexer runs for
+     */
+    public abstract void commitCallBack(String service);
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/IndexFeedDeleteTask.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/IndexFeedDeleteTask.java
new file mode 100755
index 0000000..5e8fec2
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/IndexFeedDeleteTask.java
@@ -0,0 +1,140 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.search.index;
+
+import org.apache.lucene.document.Document;
+import org.apache.lucene.index.Term;
+
+/**
+ * This IndexDocumentBuilder deletes a entire feed form the index the builder is
+ * passed to if the feed has any entries in the search index. Each created and
+ * passed IndexFeedDeleteTask forces a commit.
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class IndexFeedDeleteTask implements IndexDocumentBuilder<IndexDocument> {
+    private final String feedId;
+
+    IndexFeedDeleteTask(String feedId) {
+        if (feedId == null)
+            throw new IllegalArgumentException("feedId must not be null");
+        this.feedId = feedId;
+
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.search.index.IndexDocumentBuilder#call()
+     */
+    public IndexDocument call() throws GdataIndexerException {
+        return new FeedDeleteDocument(this.feedId);
+        
+    }
+
+    private static class FeedDeleteDocument implements IndexDocument {
+        private final Term deleteTerm;
+
+        FeedDeleteDocument(String feedId) {
+            this.deleteTerm = new Term(FIELD_FEED_ID, feedId);
+        }
+
+        /**
+         * @see org.apache.lucene.gdata.search.index.IndexDocument#isUpdate()
+         */
+        public boolean isUpdate() {
+
+            return false;
+        }
+
+        /**
+         * @see org.apache.lucene.gdata.search.index.IndexDocument#isDelete()
+         */
+        public boolean isDelete() {
+
+            return true;
+        }
+
+        /**
+         * @see org.apache.lucene.gdata.search.index.IndexDocument#isInsert()
+         */
+        public boolean isInsert() {
+
+            return false;
+        }
+
+        /**
+         * @see org.apache.lucene.gdata.search.index.IndexDocument#getWriteable()
+         */
+        public Document getWriteable() {
+
+            return null;
+        }
+
+        /**
+         * @see org.apache.lucene.gdata.search.index.IndexDocument#getDeletealbe()
+         */
+        public Term getDeletealbe() {
+
+            return this.deleteTerm;
+        }
+
+        /**
+         * @see org.apache.lucene.gdata.search.index.IndexDocument#commitAfter()
+         */
+        public boolean commitAfter() {
+            /*
+             * force commit after delete a entire feed and its entries
+             */
+            return true;
+        }
+
+        /**
+         * @see org.apache.lucene.gdata.search.index.IndexDocument#optimizeAfter()
+         */
+        public boolean optimizeAfter() {
+
+            return false;
+        }
+
+    }
+
+    /**
+     * @see java.lang.Object#equals(java.lang.Object)
+     */
+    @Override
+    public boolean equals(Object obj) {
+        if(obj == null)
+            return false;
+        if (obj instanceof IndexFeedDeleteTask) {
+            IndexFeedDeleteTask other = (IndexFeedDeleteTask) obj;
+            return this.feedId.equals(other.feedId);
+            
+        }
+        return false;
+    }
+
+    /**
+     * @see java.lang.Object#hashCode()
+     */
+    @Override
+    public int hashCode() {
+        
+        return this.feedId.hashCode();
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/IndexLogReader.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/IndexLogReader.java
new file mode 100755
index 0000000..1dfa608
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/IndexLogReader.java
@@ -0,0 +1,169 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.search.index;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+
+import org.xml.sax.Attributes;
+import org.xml.sax.ContentHandler;
+import org.xml.sax.InputSource;
+import org.xml.sax.Locator;
+import org.xml.sax.SAXException;
+import org.xml.sax.XMLReader;
+import org.xml.sax.helpers.XMLReaderFactory;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+class IndexLogReader {
+
+     static Map<String,IndexAction> readIndexLog(File indexLogFile, Map<String,IndexAction> contentMap) throws SAXException,IOException{
+        XMLReader reader = XMLReaderFactory.createXMLReader();
+        
+        Map<String, IndexAction> logContent = contentMap;
+        if(logContent == null)
+            logContent = new HashMap<String,IndexAction>(64);
+        
+        reader.setContentHandler(new IndexLogContentHandler(logContent));
+        InputSource source = new InputSource(new FileInputStream(indexLogFile));
+        try{
+        reader.parse(source);
+        }catch (SAXException e) {
+            /*
+             * try to append the Root element end
+             * this happens if the server crashes.
+             * If it dies while writing an entry the log file has to be fixed manually
+             */
+            IndexLogWriter.tryCloseRoot(indexLogFile);
+            source = new InputSource(new FileInputStream(indexLogFile));
+            reader.parse(source);
+        }
+        return logContent;
+    }
+    
+
+    private static class IndexLogContentHandler implements ContentHandler {
+        private final Map<String, IndexAction> logContent;
+        private String currentID;
+        private String currentAction;
+        private boolean isId;
+        private boolean isAction;
+        IndexLogContentHandler(final Map<String, IndexAction> content) {
+            this.logContent = content;
+        }
+
+        /**
+         * @see org.xml.sax.ContentHandler#setDocumentLocator(org.xml.sax.Locator)
+         */
+        public void setDocumentLocator(Locator locator) {
+        }
+
+        /**
+         * @see org.xml.sax.ContentHandler#startDocument()
+         */
+        public void startDocument() throws SAXException {
+        }
+
+        /**
+         * @see org.xml.sax.ContentHandler#endDocument()
+         */
+        public void endDocument() throws SAXException {
+        }
+
+        /**
+         * @see org.xml.sax.ContentHandler#startPrefixMapping(java.lang.String, java.lang.String)
+         */
+        public void startPrefixMapping(String prefix, String uri)
+                throws SAXException {
+        }
+
+        /**
+         * @see org.xml.sax.ContentHandler#endPrefixMapping(java.lang.String)
+         */
+        public void endPrefixMapping(String prefix) throws SAXException {
+        }
+
+        /**
+         * @see org.xml.sax.ContentHandler#startElement(java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes)
+         */
+        public void startElement(String uri, String localName, String qName,
+                Attributes atts) throws SAXException {
+            if(localName.equals("entryid")){
+                this.isId = true;
+            }else if(localName.equals("action")){
+                this.isAction = true;
+            }
+        }
+
+        /**
+         * @see org.xml.sax.ContentHandler#endElement(java.lang.String, java.lang.String, java.lang.String)
+         */
+        public void endElement(String uri, String localName, String qName)
+                throws SAXException {
+            if(localName.equals("entryid")){
+                this.isId = false;
+            }else if(localName.equals("action")){
+                this.isAction = false;
+            }else if(localName.equals("indexentry")){
+                this.logContent.put(this.currentID,IndexAction.valueOf(this.currentAction));
+            }
+        }
+
+        /**
+         * @see org.xml.sax.ContentHandler#characters(char[], int, int)
+         */
+        public void characters(char[] ch, int start, int length)
+                throws SAXException {
+            if(this.isId)
+                this.currentID = new String(ch,start,length);
+            if(this.isAction)
+                this.currentAction = new String(ch,start,length);
+            
+        }
+
+        /**
+         * @see org.xml.sax.ContentHandler#ignorableWhitespace(char[], int, int)
+         */
+        public void ignorableWhitespace(char[] ch, int start, int length)
+                throws SAXException {
+        }
+
+        /**
+         * @see org.xml.sax.ContentHandler#processingInstruction(java.lang.String, java.lang.String)
+         */
+        public void processingInstruction(String target, String data)
+                throws SAXException {
+        }
+
+        /**
+         * @see org.xml.sax.ContentHandler#skippedEntity(java.lang.String)
+         */
+        public void skippedEntity(String name) throws SAXException {
+        }
+        
+        
+
+    }
+    
+   
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/IndexLogWriter.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/IndexLogWriter.java
new file mode 100755
index 0000000..54e53c4
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/IndexLogWriter.java
@@ -0,0 +1,113 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.search.index;
+
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStreamWriter;
+import java.io.RandomAccessFile;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+class IndexLogWriter {
+    private static final String LINE_BREAK = System
+            .getProperty("line.separator");
+
+    private static final String XMLHEADER = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
+            + LINE_BREAK;
+    private static final String CHARSET = "UTF-8";
+    private static final String ROOT_BEGIN = "<indexlog>" + LINE_BREAK;
+
+    private static final String ROOT_END = "</indexlog>";
+
+    
+
+    private final BufferedWriter writer;
+
+    private final AtomicBoolean isClosed;
+
+    /**
+     * @param file
+     * @throws IOException
+     * 
+     */
+    public IndexLogWriter(File file) throws IOException {
+
+        this.writer = new BufferedWriter(new OutputStreamWriter(
+                new FileOutputStream(file), CHARSET));
+        this.writer.write(XMLHEADER);
+        this.writer.write(ROOT_BEGIN);
+        this.writer.flush();
+        this.isClosed = new AtomicBoolean(false);
+
+    }
+
+    synchronized void writeAction(String id, IndexAction action)
+            throws IOException {
+        if (this.isClosed.get())
+            throw new IllegalStateException("Writer is already closed");
+        this.writer.write(buildElement(id, action.name()));
+        this.writer.flush();
+    }
+
+    static synchronized void tryCloseRoot(File file) throws IOException {
+        /*
+         * try to append the Root element end
+         * this happens if the server crashes.
+         * If it dies while writing an entry the log file has to be fixed manually
+         */
+        RandomAccessFile raFile = new RandomAccessFile(file, "rw");
+        raFile.seek(raFile.length());
+        raFile.write(IndexLogWriter.ROOT_END.getBytes(CHARSET));
+        raFile.close();
+        
+
+    }
+
+    private static String buildElement(String id, String action) {
+        StringBuilder builder = new StringBuilder("\t<indexentry>")
+                .append(LINE_BREAK);
+        builder.append("\t\t<entryid>");
+        builder.append(id);
+        builder.append("</entryid>").append(LINE_BREAK);
+        builder.append("\t\t<action>");
+        builder.append(action);
+        builder.append("</action>").append(LINE_BREAK);
+        builder.append("\t</indexentry>").append(LINE_BREAK);
+        return builder.toString();
+
+    }
+
+    synchronized void close() throws IOException {
+        if (!this.isClosed.compareAndSet(false,true))
+            throw new IllegalStateException("Writer is already closed");
+        try {
+            this.writer.write(ROOT_END);
+            this.writer.flush();
+        } finally {
+            this.writer.close();
+        }
+
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/IndexTask.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/IndexTask.java
new file mode 100755
index 0000000..92bebaa
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/IndexTask.java
@@ -0,0 +1,175 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.search.index;
+
+import java.io.IOException;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+/**
+ * 
+ * Class to be used inside a
+ * {@link org.apache.lucene.gdata.search.index.GDataIndexer} to process the task
+ * queue. This class calls the commit method of the indexer if commit is
+ * scheduled.
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+class IndexTask implements Runnable {
+    private static final Log INNERLOG = LogFactory.getLog(IndexTask.class);
+
+    private AtomicBoolean stopped = new AtomicBoolean(false);
+
+    private final GDataIndexer indexer;
+
+    protected AtomicBoolean commit = new AtomicBoolean(false);
+    
+    protected AtomicBoolean optimize = new AtomicBoolean(false);
+
+    /*
+     * keep protected for subclassing
+     */
+    protected final BlockingQueue<Future<IndexDocument>> taskQueue;
+
+    IndexTask(final GDataIndexer indexer,
+            final BlockingQueue<Future<IndexDocument>> taskQueue) {
+        this.indexer = indexer;
+        this.taskQueue = taskQueue;
+    }
+
+    /**
+     * @see java.lang.Runnable#run()
+     */
+    public void run() {
+
+        while (!this.stopped.get() || this.taskQueue.size() != 0) {
+
+            try {
+                /*
+                 * get the future from the queue and wait until processing has
+                 * been done
+                 */
+                Future<IndexDocument> future = getTask();
+                if (future != null) {
+                    IndexDocument document = future.get();
+                    setOptimize(document);
+                    processDocument(document); 
+                    /*
+                     * the document contains the info for commit or optimize -->
+                     * this comes from the controller
+                     */
+                    if (document == null || document.commitAfter())
+                        this.indexer.commit(document == null ? false : this.optimize.getAndSet(false));
+                }
+                if (this.commit.getAndSet(false))
+                    this.indexer.commit(this.optimize.getAndSet(false));
+
+            } catch (InterruptedException e) {
+                INNERLOG.warn("Queue is interrupted exiting IndexTask -- ", e);
+
+            } catch (GdataIndexerException e) {
+                /*
+                 * 
+                 * TODO fire callback here as well
+                 */
+                INNERLOG.error("can not retrieve Field from IndexDocument  ", e);
+            } catch (ExecutionException e) {
+                /*
+                 * TODO callback for fail this exception is caused by an
+                 * exception while processing the document. call back for failed
+                 * docs should be placed here
+                 */
+                INNERLOG.error("Future throws execution exception ", e);
+
+            } catch (IOException e) {
+                INNERLOG.error("IOException thrown while processing document ",
+                        e);
+
+            } catch (Throwable e) {
+                /*
+                 * catch all to prevent the thread from dieing
+                 */
+                INNERLOG.error(
+                        "Unexpected exception while processing document -- "
+                                + e.getMessage(), e);
+            }
+        }
+        try {
+            this.indexer.commit(this.optimize.getAndSet(false));
+        } catch (IOException e) {
+            INNERLOG.warn("commit on going down failed - "+e.getMessage(),e);
+            
+        }
+        this.stop();
+    }
+    protected void setOptimize(IndexDocument document){
+        if(document == null)
+            return;
+        this.optimize.set(document.optimizeAfter());
+    }
+
+    /*
+     * keep this protected for subclassing see TimedIndexTask!
+     */
+    protected Future<IndexDocument> getTask() throws InterruptedException {
+        return this.taskQueue.take();
+    }
+
+    private void processDocument(IndexDocument document) throws IOException {
+        /*
+         * a null document is used for waking up the task if the indexer has
+         * been destroyed to finish up and commit. should I change this?! -->
+         * see TimedIndexTask#getTask() also!!
+         */
+        if (document == null) {
+            INNERLOG.warn("Can not process document -- is null -- run commit");
+            return;
+        }
+        if (document.isDelete()) {
+            this.indexer.deleteDocument(document);
+            return;
+        } else if (document.isInsert()) {
+            this.indexer.addDocument(document);
+            return;
+        } else if (document.isUpdate()) {
+            this.indexer.updateDocument(document);
+            return;
+        }
+        /*
+         * that should not happen -- anyway skip the document and write it to
+         * the log
+         */
+        INNERLOG.warn("IndexDocument has no Action " + document);
+
+    }
+
+    protected boolean isStopped() {
+        return this.stopped.get();
+    }
+
+    protected void stop() {
+        this.stopped.set(true);
+    }
+
+}
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/TimedIndexTask.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/TimedIndexTask.java
new file mode 100755
index 0000000..f191c62
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/TimedIndexTask.java
@@ -0,0 +1,68 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.search.index;
+
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * This {@link IndexTask} will idle the given time if no task is on the queue.
+ * If the idle time exceeds the task will force a commit on the index. The timer
+ * will be reset if a task is on the queue.
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+class TimedIndexTask extends IndexTask {
+    protected final static TimeUnit TIME_UNIT = TimeUnit.SECONDS;
+
+    protected final static long DEFAULT_IDLE_TIME = 30;
+
+    private final long idleTime;
+
+    TimedIndexTask(final GDataIndexer indexer,
+            final BlockingQueue<Future<IndexDocument>> taskQueue,
+            final long idleTime) {
+        super(indexer, taskQueue);
+        this.idleTime = idleTime < DEFAULT_IDLE_TIME ? DEFAULT_IDLE_TIME
+                : idleTime;
+
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.search.index.IndexTask#getTask()
+     */
+    @Override
+    protected Future<IndexDocument> getTask() throws InterruptedException {
+        /*
+         * wait for a certain time and return null if no task is on the queue.
+         * If return null --> commit will be called
+         */
+        Future<IndexDocument> retVal = this.taskQueue.poll(this.idleTime, TIME_UNIT);
+        if(retVal== null)
+            this.commit.set(true);
+        return retVal;
+        
+    }
+    
+    protected long getIdleTime(){
+        return this.idleTime;
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/package.html b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/package.html
new file mode 100755
index 0000000..7257463
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/index/package.html
@@ -0,0 +1,10 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
+<html> 
+<head> 
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
+   <meta name="Author" content="Simon Willnauer"> 
+</head> 
+<body> 
+Contains classes processing of documents and accessing the search index of the server
+</body> 
+</html> 
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/package.html b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/package.html
new file mode 100755
index 0000000..4480952
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/package.html
@@ -0,0 +1,10 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
+<html> 
+<head> 
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
+   <meta name="Author" content="Simon Willnauer"> 
+</head> 
+<body> 
+Classes used for query the lucene index for a specific feed instance
+</body> 
+</html> 
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/query/GDataQueryParser.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/query/GDataQueryParser.java
new file mode 100755
index 0000000..ee63c4d
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/query/GDataQueryParser.java
@@ -0,0 +1,58 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.search.query;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.gdata.search.config.IndexSchema;
+import org.apache.lucene.queryParser.QueryParser;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class GDataQueryParser extends QueryParser {
+
+    /**
+     * Creates a new QueryParser instance and sets the default operator to
+     * {@link Operator#AND}
+     * 
+     * @param field -
+     *            the parser field
+     * @param analyzer -
+     *            the parser analyzer
+     */
+    public GDataQueryParser(String field, Analyzer analyzer) {
+        super(field, analyzer);
+        this.setDefaultOperator(Operator.AND);
+    }
+
+    /**
+     * Creates a new QueryParser instance and sets the default operator to
+     * {@link Operator#AND}. The parser will use
+     * {@link IndexSchema#getDefaultSearchField} as the field and
+     * {@link IndexSchema#getSchemaAnalyzer()} as the analyzer.
+     * 
+     * @param schema -
+     *            the schema to set the default fields
+     */
+    public GDataQueryParser(IndexSchema schema) {
+        this(schema.getDefaultSearchField(), schema.getSchemaAnalyzer());
+
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/query/QueryTranslator.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/query/QueryTranslator.java
new file mode 100755
index 0000000..174a8f9
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/search/query/QueryTranslator.java
@@ -0,0 +1,135 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.search.query;
+
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+import org.apache.lucene.gdata.search.config.IndexSchema;
+
+import com.google.gdata.data.DateTime;
+
+/**
+ * Simple static methods to translate the http query to a lucene query string.
+ * @author Simon Willnauer
+ * 
+ */
+public class QueryTranslator {
+    private static final Set<String> STANDARD_REQUEST_PARAMETER = new HashSet<String>(3);
+    private static final String GDATA_DEFAULT_SEARCH_PARAMETER = "q";
+    private static final String UPDATED_MIN = Long.toString(0);
+    private static final String UPDATED_MAX = Long.toString(Long.MAX_VALUE);
+//    private static final String GDATA_CATEGORY_FIEL = 
+
+    
+    
+    static{
+        STANDARD_REQUEST_PARAMETER.add("max-results");
+        STANDARD_REQUEST_PARAMETER.add("start-index");
+        STANDARD_REQUEST_PARAMETER.add("alt");
+    }
+    /**
+     * This method does a little preprocessing of the query. Basically it will map the given request parameters to a lucene syntax. Each
+     * parameter matching a index field in the given schema will be translated into a grouped query string according to the lucene query syntax. 
+     * <p>
+     * <ol>
+     * <li>title=foo bar AND "FooBar" will be title:(foo bar AND "FooBar)</i>
+     * <li>updated-min=2005-08-09T10:57:00-08:00 will be translated to updated:[1123613820000 TO 9223372036854775807] according to the gdata protocol</i>
+     * </ol>
+     * </p>
+     * @param schema the index schema for the queried service
+     * @param parameterMap - the http parameter map returning String[] instances as values
+     * @param categoryQuery - the parsed category query from the request
+     * @return - a lucene syntax query string
+     */
+    public static String translateHttpSearchRequest(IndexSchema schema,
+            Map<String, String[]> parameterMap, String categoryQuery) {
+        Set<String> searchableFieldNames = schema.getSearchableFieldNames();
+        Set<String> parameterSet = parameterMap.keySet();
+        StringBuilder translatedQuery = new StringBuilder();
+        if(categoryQuery != null){
+           translatedQuery.append(translateCategory(translatedQuery,categoryQuery));
+        }
+        String updateMin = null;
+        String updateMax = null;
+        for (String parameterName : parameterSet) {
+            if (STANDARD_REQUEST_PARAMETER.contains(parameterName))
+                continue;
+            if (searchableFieldNames.contains(parameterName)) {
+                translatedQuery.append(parameterName).append(":(");
+                translatedQuery.append(parameterMap.get(parameterName)[0]);
+                translatedQuery.append(") ");
+                continue;
+            }
+            if(parameterName.equals(GDATA_DEFAULT_SEARCH_PARAMETER)){
+                translatedQuery.append(schema.getDefaultSearchField());
+                translatedQuery.append(":(");
+                translatedQuery.append(parameterMap.get(parameterName)[0]);
+                translatedQuery.append(") ");
+                continue;
+                
+            }
+            if(parameterName.endsWith("updated-min")){
+                updateMin = parameterMap.get(parameterName)[0];
+                continue;
+            }
+            if(parameterName.endsWith("updated-max")){
+                updateMax = parameterMap.get(parameterName)[0];
+                continue;
+            }
+            throw new RuntimeException("Can not apply parameter -- invalid -- "
+                    + parameterName);
+        }
+        if(updateMax!=null || updateMin!= null)
+            translatedQuery.append(translateUpdate(updateMin,updateMax));
+            
+        return translatedQuery.length() == 0?null:translatedQuery.toString();
+    }
+    
+    
+     static String translateUpdate(String updateMin, String updateMax){
+        StringBuilder builder = new StringBuilder("updated:[");
+        if(updateMin != null)
+            builder.append(Long.toString(DateTime.parseDateTime(updateMin).getValue()));
+        else
+            builder.append(UPDATED_MIN);
+        builder.append(" TO ");
+        if(updateMax != null)
+            builder.append(Long.toString(DateTime.parseDateTime(updateMax).getValue()-1));
+        else
+            builder.append(UPDATED_MAX);
+        builder.append("]");
+        return builder.toString();
+        
+        
+    }
+     
+     static String translateCategory(StringBuilder builder, String categoryQuery){
+         return categoryQuery;
+         //TODO Implement this
+//         GDataCategoryQueryParser parser = new GDataCategoryQueryParser()
+         
+        
+     }
+     
+     
+     
+    
+    
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/FeedNotFoundException.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/FeedNotFoundException.java
new file mode 100644
index 0000000..5ebe60d
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/FeedNotFoundException.java
@@ -0,0 +1,57 @@
+package org.apache.lucene.gdata.server; 
+ 
+ 
+/** 
+ * Will be thrown if a requested feed could not be found or is not 
+ * registerd. 
+ *  
+ * @author Simon Willnauer 
+ *  
+ */ 
+public class FeedNotFoundException extends ServiceException { 
+ 
+    private static final long serialVersionUID = 1L; 
+ 
+    /**
+     * Constructs a new FeedNotFoundException
+     * @param errorCode - gdata request errorcode
+     */
+    public FeedNotFoundException(int errorCode) {
+        super(errorCode);
+        
+
+    }
+
+    /**
+     * Constructs a new FeedNotFoundException
+     * @param arg0 - the exception message
+     * @param errorCode - gdata request errorcode
+     */
+    public FeedNotFoundException(String arg0,int errorCode) {
+        super(arg0, errorCode);
+        
+    }
+
+    /**
+     * Constructs a new FeedNotFoundException
+     * @param arg0 - the exceptin message
+     * @param arg1 - the exception cause
+     * @param errorCode - gdata request errorcode
+     */
+    public FeedNotFoundException(String arg0, Throwable arg1,int errorCode) {
+        super(arg0, arg1, errorCode);
+        
+        
+    }
+
+    /**
+     * Constructs a new FeedNotFoundException
+     * @param arg0 - the exception cause
+     * @param errorCode - gdata request errorcode
+     */
+    public FeedNotFoundException(Throwable arg0,int errorCode) {
+        super(arg0, errorCode);
+        
+    }
+ 
+} 
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/GDataEntityBuilder.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/GDataEntityBuilder.java
new file mode 100644
index 0000000..62e8584
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/GDataEntityBuilder.java
@@ -0,0 +1,171 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.server;
+
+import java.io.IOException;
+import java.io.Reader;
+
+import org.apache.lucene.gdata.server.registry.ProvidedService;
+
+import com.google.gdata.data.BaseEntry;
+import com.google.gdata.data.BaseFeed;
+import com.google.gdata.util.ParseException;
+
+/**
+ * {@link com.google.gdata.data.BaseFeed},
+ * {@link com.google.gdata.data.BaseEntry} instances have to be build from a
+ * {@link java.io.Reader} instance as they come in from a client request or out
+ * of a storage.
+ * <p>
+ * To provide a generic builder class the {@link GDataEntityBuilder} requests
+ * the type of the feed / entry and the corresponding
+ * {@link com.google.gdata.data.ExtensionProfile} form the global
+ * {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry} and
+ * builds the instances from the provided reader.
+ * </p>
+ * <p>
+ * This build will not returne the abstract base classes.
+ * </p>
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class GDataEntityBuilder {
+
+    /**
+     * Builds a {@link BaseFeed} instance from the {@link Reader} provided by
+     * the {@link GDataRequest}
+     * 
+     * @param request -
+     *            the request to build the instance from
+     * @return - a BaseFeed instance
+     * 
+     * @throws IOException -
+     *             if an I/O Exception occures on the provided reader
+     * @throws ParseException -
+     *             if the feed could not be parsed
+     */
+    public static BaseFeed buildFeed(final GDataRequest request)
+            throws IOException, ParseException {
+        if (request == null)
+            throw new IllegalArgumentException("request must not be null");
+        ProvidedService config = request.getConfigurator();
+        return buildFeed(request.getReader(), config);
+    }
+
+    /**
+     * Builds a {@link BaseFeed} from the provided {@link Reader}
+     * 
+     * 
+     * @param reader -
+     *            the reader to build the feed from
+     * @param config -
+     *            the feed instance config containing the extension profile to
+     *            parse the resource
+     * @return - a BaseFeed instance
+     * 
+     * @throws IOException -
+     *             if an I/O Exception occures on the provided reader
+     * @throws ParseException -
+     *             if the feed could not be parsed
+     */
+    public static BaseFeed buildFeed(final Reader reader,
+            final ProvidedService config) throws ParseException, IOException {
+
+        BaseFeed retVal = null;
+        retVal = createEntityInstance(config);
+        retVal.parseAtom(config.getExtensionProfile(), reader);
+      
+        return retVal;
+    }
+
+    /**
+     * Builds a {@link BaseEntry} instance from the {@link Reader} provided by
+     * the {@link GDataRequest}
+     * 
+     * @param request -
+     *            the request to build the instance from
+     * @return - a BaseEntry instance
+     * 
+     * @throws IOException -
+     *             if an I/O Exception occures on the provided reader
+     * @throws ParseException -
+     *             if the entry could not be parsed
+     */
+    public static BaseEntry buildEntry(final GDataRequest request)
+            throws IOException, ParseException {
+        if (request == null)
+            throw new IllegalArgumentException("request must not be null");
+        ProvidedService config = request.getConfigurator();
+        return buildEntry(request.getReader(), config);
+    }
+
+    /**
+     * Builds a {@link BaseFeed} instance from the {@link Reader} provided by
+     * the {@link GDataRequest}
+     * 
+     * @param reader -
+     *            the reader to build the feed from
+     * @param config -
+     *            the instance config containing the extension profile to parse
+     *            the resource
+     * @return - a BaseFeed instance
+     * 
+     * @throws IOException -
+     *             if an I/O Exception occures on the provided reader
+     * @throws ParseException -
+     *             if the entry could not be parsed
+     */
+    public static BaseEntry buildEntry(final Reader reader,
+            final ProvidedService config) throws ParseException, IOException {
+       
+        BaseEntry e = createEntityInstance(config).createEntry();
+        e.parseAtom(config.getExtensionProfile(), reader);
+        return e;
+    }
+
+    private static BaseFeed createEntityInstance(
+            final ProvidedService config) {
+        if(config.getFeedType() == null)
+            throw new IllegalArgumentException("feedtype is null in ProvidedService");
+        
+        BaseFeed retVal = null;
+        try {
+            retVal = (BaseFeed) config.getFeedType().newInstance();
+        } catch (Exception e) {
+            throw new EntityBuilderException("Can't instanciate Feed for feedType "+config.getFeedType().getName(),e);
+        }
+        return retVal;
+    }
+    static class EntityBuilderException extends RuntimeException{
+
+        /**
+         * 
+         */
+        private static final long serialVersionUID = 7224011324202237951L;
+
+        EntityBuilderException(String arg0) {
+            super(arg0);
+           
+        }
+
+        EntityBuilderException(String arg0, Throwable arg1) {
+            super(arg0, arg1);
+           
+        }
+        
+    }
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/GDataRequest.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/GDataRequest.java
new file mode 100644
index 0000000..addd86e
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/GDataRequest.java
@@ -0,0 +1,598 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+
+package org.apache.lucene.gdata.server;
+
+import java.io.IOException;
+import java.io.Reader;
+import java.util.Enumeration;
+import java.util.Map;
+import java.util.StringTokenizer;
+
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServletRequest;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.search.config.IndexSchema;
+import org.apache.lucene.gdata.search.query.QueryTranslator;
+import org.apache.lucene.gdata.server.authentication.AuthenticationController;
+import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
+import org.apache.lucene.gdata.server.registry.ProvidedService;
+
+/**
+ * The GDataRequest Class wraps the incoming HttpServletRequest. Needed
+ * information coming with the HttpServletRequest can be accessed directly. It
+ * represents an abstraction on the plain HttpServletRequest. Every GData
+ * specific data coming from the client will be available and can be accessed
+ * via the GDataRequest.
+ * <p>
+ * GDataRequest instances will be passed to any action requested by the client.
+ * This class also holds the logic to retrieve important information like
+ * response format, the requested feed instance and query parameters.
+ * 
+ * </p>
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+/* this class might be extracted as an interface in later development */
+public class GDataRequest {
+    
+    
+    private static final Log LOG = LogFactory.getLog(GDataRequest.class);
+
+    private static final String RESPONSE_FORMAT_PARAMETER = "alt";
+
+    private static final String RESPONSE_FORMAT_PARAMETER_RSS = "rss";
+    private static final String RESPONSE_FORMAT_PARAMETER_HTML = "html";
+
+    private static final int DEFAULT_ITEMS_PER_PAGE = 25;
+
+    private static final int DEFAULT_START_INDEX = 1;
+
+    private static final String START_INDEX_NEXT_PAGE_PARAMETER = "start-index";
+
+    private static final String ITEMS_PER_PAGE_PARAMETER = "max-results";
+
+    private String contextPath;
+
+    @SuppressWarnings("unused")
+    private static final String RESPONSE_FORMAT_PARAMETER_ATOM = "atom";
+
+    private static final String HTTP_HEADER_IF_MODIFIED_SINCE = "If-Modified-Since";
+
+    private static final String HTTP_HEADER_AUTH = "Authorization";
+
+    private static final Object CATEGORY_QUERY_INDICATOR = "-";
+
+    // Atom is the default response format
+    private OutputFormat responseFormat = OutputFormat.ATOM;
+
+    private final HttpServletRequest request;
+
+    private String feedId = null;
+
+    private String entryId = null;
+
+    private String service = null;
+
+    private ProvidedService configurator = null;
+
+    private boolean isSearchRequest = false;
+
+    private String entryVersion = null;
+
+    private GDataRequestType type;
+
+    private String categoryQuery;
+    
+    private String translatedSearchQuery;
+
+    private boolean isFeedRequest = false;
+
+    /**
+     * Creates a new FeedRequest
+     * 
+     * @param requst -
+     *            the incoming HttpServletReqeust
+     * @param type -
+     *            the request type
+     * 
+     */
+    public GDataRequest(final HttpServletRequest requst,
+            final GDataRequestType type) {
+        if (requst == null)
+            throw new IllegalArgumentException("request must not be null ");
+        if (type == null)
+            throw new IllegalArgumentException("request type must not be null ");
+        this.request = requst;
+        this.type = type;
+
+    }
+
+    /**
+     * Initialize the GDataRequest. This will initialize all needed values /
+     * attributes in this request.
+     * 
+     * @throws GDataRequestException
+     */
+    public void initializeRequest() throws GDataRequestException {
+        generateIdentificationProperties();
+        setOutputFormat();
+        
+        try {
+            /*
+             * ExtensionProfile and the type is used for building the Entry /
+             * Feed Instances from an input stream or reader
+             * 
+             */
+            this.configurator = GDataServerRegistry.getRegistry()
+                    .getProvidedService(this.service);
+            
+            if (this.configurator == null)
+                throw new GDataRequestException(
+                        "no Provided Service found for service id: "+this.service,GDataResponse.NOT_FOUND);
+            applyRequestParameter();
+            if(this.translatedSearchQuery != null)
+                this.isSearchRequest = true;
+        } catch(GDataRequestException ex){
+            throw ex;
+        } catch (Exception e) {
+            throw new GDataRequestException(
+                    "failed to initialize GDataRequest -- "
+                            + e.getMessage(), e,GDataResponse.SERVER_ERROR);
+        }
+        
+    }
+    
+    @SuppressWarnings("unchecked")
+    private void applyRequestParameter() throws GDataRequestException{
+        IndexSchema schema = this.configurator.getIndexSchema();
+        try{
+        this.translatedSearchQuery = QueryTranslator.translateHttpSearchRequest(schema,this.request.getParameterMap(),this.categoryQuery);
+        }catch (Exception e) {
+            throw new GDataRequestException("Can not translate user query to search query",e,GDataResponse.BAD_REQUEST);
+        }
+    }
+
+    /**
+     * @return - the id of the requested feed
+     */
+    public String getFeedId() {
+
+        return this.feedId;
+    }
+
+    /**
+     * @return - the entry id of the requested Entry if specified, otherwise
+     *         <code>null</code>
+     */
+    public String getEntryId() {
+
+        return this.entryId;
+    }
+
+    /**
+     * @return the version Id of the requested Entry if specified, otherwise
+     *         <code>null</code>
+     */
+    public String getEntryVersion() {
+        return this.entryVersion;
+    }
+
+    /**
+     * A Reader instance to read form the client input stream
+     * 
+     * @return - the HttpServletRequest {@link Reader}
+     * @throws IOException -
+     *             if an I/O Exception occurs
+     */
+    public Reader getReader() throws IOException {
+        return this.request.getReader();
+    }
+
+    /**
+     * Returns the {@link HttpServletRequest} parameter map containing all
+     * <i>GET</i> request parameters.
+     * 
+     * @return the parameter map
+     */
+    @SuppressWarnings("unchecked")
+    public Map<String, String[]> getQueryParameter() {
+        return this.request.getParameterMap();
+    }
+
+    /**
+     * The {@link HttpServletRequest} request parameter names
+     * 
+     * @return parameter names enumeration
+     */
+    @SuppressWarnings("unchecked")
+    public Enumeration<String> getQueryParameterNames() {
+        return this.request.getParameterNames();
+    }
+
+    /**
+     * Either <i>Atom</i> or <i>RSS</i>
+     * 
+     * @return - The output format requested by the client
+     */
+    public OutputFormat getRequestedResponseFormat() {
+
+        return this.responseFormat;
+    }
+
+    private void generateIdentificationProperties()
+            throws GDataRequestException {
+        /* generate all needed data to identify the requested feed/entry */
+        String pathInfo = this.request.getPathInfo();
+              if (pathInfo.length() <= 1)
+            throw new GDataRequestException(
+                    "No feed or entry specified for this request",GDataResponse.BAD_REQUEST);
+        StringTokenizer tokenizer = new StringTokenizer(pathInfo, "/");
+        this.service = tokenizer.nextToken();
+        if (!tokenizer.hasMoreTokens())
+            throw new GDataRequestException(
+                    "Can not find feed id in requested path " + pathInfo,GDataResponse.BAD_REQUEST);
+        this.feedId = tokenizer.nextToken();
+
+        String appendix = tokenizer.hasMoreTokens() ? tokenizer.nextToken()
+                : null;
+        if (appendix == null){
+            this.isFeedRequest = true;
+            return;
+        }
+        if (appendix.equals(CATEGORY_QUERY_INDICATOR)) {
+            StringBuilder builder = new StringBuilder();
+            while (tokenizer.hasMoreTokens())
+                builder.append("/").append(tokenizer.nextToken());
+            this.categoryQuery = builder.toString();
+        } else {
+            this.entryId = appendix;
+            this.entryVersion = tokenizer.hasMoreTokens() ? tokenizer
+                    .nextToken() : "";
+        }
+        this.isFeedRequest = (this.type == GDataRequestType.GET && (this.entryId == null
+                || this.entryId.length() == 0 || (this.entryId.equals('/'))));
+    }
+
+    private void setOutputFormat() {
+        String formatParameter = this.request
+                .getParameter(RESPONSE_FORMAT_PARAMETER);
+        if (formatParameter == null)
+            return;
+        if (formatParameter.equalsIgnoreCase(RESPONSE_FORMAT_PARAMETER_RSS))
+            this.responseFormat = OutputFormat.RSS;
+        if (formatParameter.equalsIgnoreCase(RESPONSE_FORMAT_PARAMETER_HTML))
+            this.responseFormat = OutputFormat.HTML;
+
+    }
+
+    /**
+     * @return - the number of returned items per page
+     */
+    public int getItemsPerPage() {
+
+        if (this.request.getParameter(ITEMS_PER_PAGE_PARAMETER) == null)
+            return DEFAULT_ITEMS_PER_PAGE;
+        int retval = -1;
+        try {
+            retval = new Integer(this.request
+                    .getParameter(ITEMS_PER_PAGE_PARAMETER)).intValue();
+        } catch (Exception e) {
+            LOG.warn("Items per page could not be parsed - " + e.getMessage(),
+                    e);
+        }
+
+        return retval < 0 ? DEFAULT_ITEMS_PER_PAGE : retval;
+    }
+
+    /**
+     * Start index represents the number of the first entry of the query -
+     * result. The order depends on the query. Is the query a search query the
+     * this value will be assigned to the score in a common feed query the value
+     * will be assigned to the update time of the entries.
+     * 
+     * @return - the requested start index
+     */
+    public int getStartIndex() {
+        String startIndex = this.request.getParameter(START_INDEX_NEXT_PAGE_PARAMETER);
+        if (startIndex == null)
+            return DEFAULT_START_INDEX;
+        int retval = -1;
+        try {
+            retval = new Integer(startIndex).intValue();
+        } catch (Exception e) {
+            LOG.warn("Start-index could not be parsed - not an integer - " + e.getMessage());
+        }
+        return retval < 0 ? DEFAULT_START_INDEX : retval;
+    }
+
+    /**
+     * The self id is the feeds <i>href</i> pointing to the requested resource
+     * 
+     * @return - the self id
+     */
+    public String getSelfId() {
+        StringBuilder builder = new StringBuilder();
+        builder.append(buildRequestIDString(false));
+        builder.append("?");
+        builder.append(getQueryString());
+
+        return builder.toString();
+    }
+    
+    /**
+       * The previous id is the feeds <i>href</i> pointing to the previous result of the requested resource
+     * 
+     * @return - the self id
+     */
+    public String getPreviousId(){
+        
+        int startIndex = getStartIndex();
+        if(startIndex == DEFAULT_START_INDEX )
+            return null;
+        StringBuilder builder = new StringBuilder();
+        builder.append(buildRequestIDString(false));
+        startIndex = startIndex-getItemsPerPage();
+        builder.append(getPreparedQueryString(startIndex<1?DEFAULT_START_INDEX:startIndex));
+        return builder.toString();
+    }
+  
+
+    
+    private String getPreparedQueryString(int startIndex){
+        String queryString = this.request.getQueryString();
+        String startIndexValue = this.request.getParameter(START_INDEX_NEXT_PAGE_PARAMETER);
+        String maxResultsValue = this.request.getParameter(ITEMS_PER_PAGE_PARAMETER);
+        
+        StringBuilder builder = new StringBuilder("?");
+        if(maxResultsValue == null){
+            builder.append(ITEMS_PER_PAGE_PARAMETER).append("=").append(DEFAULT_ITEMS_PER_PAGE);
+            builder.append("&");
+        }
+        if(startIndexValue== null){
+            builder.append(START_INDEX_NEXT_PAGE_PARAMETER).append("=");
+            builder.append(Integer.toString(startIndex));
+            if(queryString!=null){
+                builder.append("&");
+                builder.append(queryString);
+            }
+        }else{
+            builder.append(queryString.replaceAll("start-index=[\\d]*",START_INDEX_NEXT_PAGE_PARAMETER+"="+Integer.toString(startIndex)));
+        }
+        return builder.toString();
+    }
+    /**
+     * The <i>href</i> id of the next page of the requested resource.
+     * 
+     * @return the id of the next page
+     */
+    public String getNextId() {
+        int startIndex = getStartIndex();
+        StringBuilder builder = new StringBuilder();
+        builder.append(buildRequestIDString(false));
+        startIndex = startIndex+getItemsPerPage();
+        builder.append(getPreparedQueryString(startIndex));
+        return builder.toString();
+
+    }
+
+    private String buildRequestIDString(boolean endingSlash) {
+        StringBuilder builder = new StringBuilder("http://");
+        builder.append(this.request.getHeader("Host"));
+        builder.append(this.request.getRequestURI());
+        if (!endingSlash && builder.charAt(builder.length() - 1) == '/')
+            builder.setLength(builder.length() - 1);
+        if (endingSlash && builder.charAt(builder.length() - 1) != '/')
+            builder.append("/");
+
+        return builder.toString();
+    }
+
+    /**
+     * This will return the current query string including all parameters.
+     * Additionally the <code>max-resul</code> parameter will be added if not
+     * specified.
+     * <p>
+     * <code>max-resul</code> indicates the number of results returned to the
+     * client. The default value is 25.
+     * </p>
+     * 
+     * @return - the query string including all parameters
+     */
+    public String getQueryString() {
+        String retVal = this.request.getQueryString();
+
+        if (this.request.getParameter(ITEMS_PER_PAGE_PARAMETER) != null)
+            return retVal;
+        String tempString = (retVal == null ? ITEMS_PER_PAGE_PARAMETER + "="
+                + DEFAULT_ITEMS_PER_PAGE : "&" + ITEMS_PER_PAGE_PARAMETER + "="
+                + DEFAULT_ITEMS_PER_PAGE);
+
+        return retVal == null ? tempString : retVal + tempString;
+
+    }
+
+    /**
+     * This enum represents the OutputFormat of the GDATA Server
+     * 
+     * @author Simon Willnauer
+     * 
+     */
+    public static enum OutputFormat {
+        /**
+         * Output format ATOM. ATOM is the default response format.
+         */
+        ATOM,
+        /**
+         * Output format RSS
+         */
+        RSS,
+        /**
+         * Output format html if user defined xsl style sheet is present 
+         */
+        HTML
+    }
+
+    /**
+     * Returns the requested path including the domain name and the requested
+     * resource <i>http://www.apache.org/path/resource/</i>
+     * 
+     * @return the context path
+     */
+    public String getContextPath() {
+        if (this.contextPath == null)
+            this.contextPath = buildRequestIDString(true);
+        return this.contextPath;
+    }
+
+    /**
+     * Indicates the request type
+     * 
+     * @author Simon Willnauer
+     * 
+     */
+    public enum GDataRequestType {
+        /**
+         * Type FeedRequest
+         */
+        GET,
+        /**
+         * Type UpdateRequest
+         */
+        UPDATE,
+        /**
+         * Type DeleteRequest
+         */
+        DELETE,
+        /**
+         * Type InsertRequest
+         */
+        INSERT
+    }
+
+    /**
+     * {@link GDataRequestType}
+     * 
+     * @return the current request type
+     */
+    public GDataRequestType getType() {
+        return this.type;
+    }
+
+    /**
+     * If the request is a {@link GDataRequestType#GET} request and there is no
+     * entry id specified, the requested resource is a feed.
+     * 
+     * @return - <code>true</code> if an only if the requested resource is a
+     *         feed
+     */
+    public boolean isFeedRequested() {
+
+        return this.isFeedRequest ;
+    }
+
+    /**
+     * * If the request is a {@link GDataRequestType#GET} request and there is
+     * an entry id specified, the requested resource is an entry.
+     * 
+     * @return - <code>true</code> if an only if the requested resource is an
+     *         entry
+     */
+    public boolean isEntryRequested() {
+        return !this.isFeedRequested();
+    }
+    /**
+     * @return - <code>true</code> if an only if the user request is a search request, otherwise <code>false</code>
+     */
+    public boolean isSearchRequested(){
+        return this.isSearchRequest;
+    }
+
+    /**
+     * @return the configuration for this request
+     */
+    public ProvidedService getConfigurator() {
+        return this.configurator;
+    }
+
+    /**
+     * @return - Returns the Internet Protocol (IP) address of the client or
+     *         last proxy that sent the request.
+     */
+    public String getRemoteAddress() {
+        return this.request.getRemoteAddr();
+    }
+
+    /**
+     * @return - the value for the send auth token. The auth token will be send
+     *         as a request <tt>Authentication</tt> header.
+     */
+    public String getAuthToken() {
+        String token = this.request.getHeader(HTTP_HEADER_AUTH);
+        if (token == null)
+            return null;
+        token = token.substring(token.indexOf("=") + 1);
+        return token;
+    }
+
+    /**
+     * @return - Returns an array containing all of the Cookie objects the
+     *         client sent with underlying HttpServletRequest.
+     */
+    public Cookie[] getCookies() {
+        return this.request.getCookies();
+    }
+
+    /**
+     * @return - the cookie set instead of the authentication token or
+     *         <code>null</code> if no auth cookie is set
+     */
+    public Cookie getAuthCookie() {
+        Cookie[] cookies = this.request.getCookies();
+        if (cookies == null)
+            return null;
+        for (int i = 0; i < cookies.length; i++) {
+            if (cookies[i].getName().equals(AuthenticationController.TOKEN_KEY))
+                return cookies[i];
+        }
+        return null;
+    }
+
+    /**
+     * @return - the date string of the <tt>If-Modified-Since</tt> HTTP
+     *         request header, or null if header is not set
+     */
+    public String getModifiedSince() {
+        return this.request.getHeader(HTTP_HEADER_IF_MODIFIED_SINCE);
+    }
+
+    /**
+     * @return - the underlying HttpServletRequest
+     */
+    public HttpServletRequest getHttpServletRequest() {
+
+        return this.request;
+    }
+    
+    protected String getTranslatedQuery(){
+        return this.translatedSearchQuery;
+    }
+
+ 
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/GDataRequestException.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/GDataRequestException.java
new file mode 100644
index 0000000..8f783f3
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/GDataRequestException.java
@@ -0,0 +1,80 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */ 
+ 
+package org.apache.lucene.gdata.server; 
+ 
+/** 
+ * This exception wraps all exceptions occur inside the {@link org.apache.lucene.gdata.server.GDataRequest} 
+ * @author Simon Willnauer 
+ * 
+ */ 
+public class GDataRequestException extends Exception { 
+    private final int errorCode;
+    /** 
+     * Serial version ID. -> Implements Serializable 
+     */ 
+    private static final long serialVersionUID = -4440777051466950723L; 
+ 
+    /** 
+       /**
+     * Constructs a new GDataRequestException
+     * @param errorCode - gdata request error code
+     */
+    public GDataRequestException(int errorCode) {
+        super();
+        this.errorCode = errorCode;
+
+    }
+
+    /**
+     * Constructs a new GDataRequestException
+     * @param arg0 - the exception message
+     * @param errorCode - gdata request error code
+     */
+    public GDataRequestException(String arg0,int errorCode) {
+        super(arg0);
+        this.errorCode = errorCode;
+    }
+
+    /**
+     * Constructs a new GDataRequestException
+     * @param arg0 - the exception message
+     * @param arg1 - the exception cause
+     * @param errorCode - gdata request error code
+     */
+    public GDataRequestException(String arg0, Throwable arg1,int errorCode) {
+        super(arg0, arg1);
+        this.errorCode = errorCode;
+        
+    }
+
+    /**
+     * Constructs a new GDataRequestException
+     * @param arg0 - the exception cause
+     * @param errorCode - gdata request error code
+     */
+    public GDataRequestException(Throwable arg0,int errorCode) {
+        super(arg0);
+        this.errorCode = errorCode;
+    }
+
+    /**
+     * @return Returns the errorCode.
+     */
+    public int getErrorCode() {
+        return this.errorCode;
+    }
+} 
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/GDataResponse.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/GDataResponse.java
new file mode 100644
index 0000000..384f1be
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/GDataResponse.java
@@ -0,0 +1,449 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+
+package org.apache.lucene.gdata.server;
+
+import java.io.IOException;
+import java.io.StringReader;
+import java.io.StringWriter;
+import java.io.Writer;
+import java.util.Date;
+
+import javax.servlet.http.HttpServletResponse;
+import javax.xml.transform.Source;
+import javax.xml.transform.Templates;
+import javax.xml.transform.Transformer;
+import javax.xml.transform.TransformerException;
+import javax.xml.transform.stream.StreamResult;
+import javax.xml.transform.stream.StreamSource;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.server.GDataRequest.OutputFormat;
+import org.apache.lucene.gdata.server.registry.ProvidedService;
+import org.apache.lucene.gdata.utils.DateFormater;
+
+import com.google.gdata.data.BaseEntry;
+import com.google.gdata.data.BaseFeed;
+import com.google.gdata.data.DateTime;
+import com.google.gdata.data.ExtensionProfile;
+import com.google.gdata.util.common.xml.XmlWriter;
+import com.google.gdata.util.common.xml.XmlWriter.Namespace;
+
+/**
+ * The FeedRequest Class wraps the current HttpServletResponse. Any action on the
+ * HttpServletRequest will be executed via this class. This represents an
+ * abstraction on the plain {@link HttpServletResponse}. Any action which has
+ * to be performed on the underlying {@link HttpServletResponse} will be
+ * executed within this class.
+ * <p>
+ * The GData basically writes two different kinds of response to the output
+ * stream.
+ * <ol>
+ * <li>update, delete or insert requests will respond with a status code and if
+ * successful the feed entry modified or created</li>
+ * <li>get requests will respond with a status code and if successful the
+ * requested feed</li>
+ * </ol>
+ * 
+ * For this purpose the {@link GDataResponse} class provides the overloaded
+ * method
+ * {@link org.apache.lucene.gdata.server.GDataResponse#sendResponse(BaseEntry, ExtensionProfile)}
+ * which sends the entry e.g feed to the output stream.
+ * </p>
+ * <p>
+ * This class will set the HTTP <tt>Last-Modified</tt> Header to enable
+ * clients to send <tt>If-Modified-Since</tt> request header to avoid
+ * retrieving the content again if it hasn't changed. If the content hasn't
+ * changed since the If-Modified-Since time, then the GData service returns a
+ * 304 (Not Modified) HTTP response.
+ * </p>
+ * 
+ * 
+ * 
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class GDataResponse {
+    /**
+     * Response code bad request
+     */
+    public static final int BAD_REQUEST = HttpServletResponse.SC_BAD_REQUEST;
+    /**
+     * Response code version conflict
+     */
+    public static final int CONFLICT = HttpServletResponse.SC_CONFLICT;
+    /**
+     * Response code forbidden access
+     */
+    public static final int FORBIDDEN = HttpServletResponse.SC_FORBIDDEN;
+    /**
+     * Response code internal server error
+     */
+    public static final int SERVER_ERROR = HttpServletResponse.SC_INTERNAL_SERVER_ERROR;
+    /**
+     * Response code not found
+     */
+    public static final int NOT_FOUND = HttpServletResponse.SC_NOT_FOUND;
+    /**
+     * Response code not modified since
+     */
+    public static final int NOT_MODIFIED = HttpServletResponse.SC_NOT_MODIFIED;
+    /**
+     * Response code created
+     */
+    public static final int CREATED = HttpServletResponse.SC_CREATED;
+    /**
+     * Response code unauthorized access
+     */
+    public static final int UNAUTHORIZED = HttpServletResponse.SC_UNAUTHORIZED;
+    
+    
+    static final Log LOG = LogFactory.getLog(GDataResponse.class);
+    private int error;
+
+    private boolean isError = false;
+
+    private String encoding;
+
+    private OutputFormat outputFormat;
+
+    private final HttpServletResponse response;
+
+    protected static final String XMLMIME_ATOM = "text/xml";
+
+    protected static final String XMLMIME_RSS = "text/xml";
+
+    private static final String HEADER_LASTMODIFIED = "Last-Modified";
+
+    /**
+     * Creates a new GDataResponse
+     * 
+     * @param response -
+     *            The underlying {@link HttpServletResponse}
+     */
+    public GDataResponse(HttpServletResponse response) {
+        if (response == null)
+            throw new IllegalArgumentException("response must not be null");
+        this.response = response;
+
+    }
+
+    /**
+     * Sets an error code to this FeedResponse.
+     * 
+     * @param errorCode -
+     *            {@link HttpServletResponse} error code
+     */
+    public void setError(int errorCode) {
+        this.isError = true;
+        this.error = errorCode;
+    }
+
+    /**
+     * Sets the status of the underlying response
+     * 
+     * @see HttpServletResponse
+     * @param responseCode -
+     *            the status of the response
+     */
+    public void setResponseCode(int responseCode) {
+        this.response.setStatus(responseCode);
+    }
+
+    /**
+     * This method sends the specified error to the user if set
+     * 
+     * @throws IOException -
+     *             if an I/O Exception occurs
+     */
+    public void sendError() throws IOException {
+        if (this.isError)
+            this.response.sendError(this.error);
+        
+    }
+
+    /**
+     * @return - the {@link HttpServletResponse} writer
+     * @throws IOException -
+     *             If an I/O exception occurs
+     */
+    public Writer getWriter() throws IOException {
+        return this.response.getWriter();
+    }
+
+    /**
+     * Sends a response for a get e.g. query request. This method must not
+     * invoked in a case of an error performing the requested action.
+     * 
+     * @param feed -
+     *            the feed to respond to the client
+     * @param service - the service to render the feed
+     * 
+     * @throws IOException -
+     *             if an I/O exception occurs, often caused by an already
+     *             closed Writer or OutputStream
+     * 
+     */
+    public void sendResponse(final BaseFeed feed, final ProvidedService service)
+            throws IOException {
+        if (feed == null)
+            throw new IllegalArgumentException("feed must not be null");
+        if (service == null)
+            throw new IllegalArgumentException(
+                    "provided service must not be null");
+        DateTime time = feed.getUpdated();
+        if (time != null)
+            setLastModifiedHeader(time.getValue());
+        FormatWriter writer = FormatWriter.getFormatWriter(this,service);
+        writer.generateOutputFormat(feed,this.response);
+
+    }
+
+    /**
+     * 
+     * Sends a response for an update, insert or delete request. This method
+     * must not invoked in a case of an error performing the requested action. If
+     * the specified response format is ATOM the default namespace will be set
+     * to ATOM.
+     * 
+     * @param entry -
+     *            the modified / created entry to send
+     * @param service - the service to render the feed
+     * @throws IOException -
+     *             if an I/O exception occurs, often caused by an already
+     *             closed Writer or OutputStream
+     */
+    public void sendResponse(BaseEntry entry, ProvidedService service)
+            throws IOException {
+        if (entry == null)
+            throw new IllegalArgumentException("entry must not be null");
+        if (service == null)
+            throw new IllegalArgumentException(
+                    "service must not be null");
+        DateTime time = entry.getUpdated();
+        if (time != null)
+            setLastModifiedHeader(time.getValue());
+        FormatWriter writer = FormatWriter.getFormatWriter(this,service);
+        writer.generateOutputFormat(entry,this.response);
+
+        
+    }
+
+
+    /**
+     * This encoding will be used to encode the xml representation of feed or
+     * entry written to the {@link HttpServletResponse} output stream.
+     * 
+     * @return - the entry / feed encoding
+     */
+    public String getEncoding() {
+        return this.encoding;
+    }
+
+    /**
+     * This encoding will be used to encode the xml representation of feed or
+     * entry written to the {@link HttpServletResponse} output stream. <i>UTF-8</i>
+     * <i>ISO-8859-1</i>
+     * 
+     * @param encoding -
+     *            string represents the encoding
+     */
+    public void setEncoding(String encoding) {
+        this.encoding = encoding;
+    }
+
+    /**
+     * @return - the response
+     *         {@link org.apache.lucene.gdata.server.GDataRequest.OutputFormat}
+     */
+    public OutputFormat getOutputFormat() {
+        return this.outputFormat;
+    }
+
+    /**
+     * @param outputFormat -
+     *            the response
+     *            {@link org.apache.lucene.gdata.server.GDataRequest.OutputFormat}
+     */
+    public void setOutputFormat(OutputFormat outputFormat) {
+        this.outputFormat = outputFormat;
+    }
+
+    /**
+     * @see Object#toString()
+     */
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder(" GDataResponse: ");
+        builder.append("Error: ").append(this.error);
+        builder.append(" outputFormat: ").append(getOutputFormat());
+        builder.append(" encoding: ").append(this.encoding);
+
+        return builder.toString();
+
+    }
+
+    protected void setLastModifiedHeader(long lastModified) {
+        String lastMod = DateFormater.formatDate(new Date(lastModified),
+                DateFormater.HTTP_HEADER_DATE_FORMAT);
+        this.response.setHeader(HEADER_LASTMODIFIED, lastMod);
+    }
+    
+    /**
+     * @see HttpServletResponse#setStatus(int)
+     * @param status - the request status code
+     */
+    public void setStatus(int status){
+        this.response.setStatus(status);
+    }
+
+    private static abstract class FormatWriter{
+        
+        static FormatWriter getFormatWriter(final GDataResponse response, final ProvidedService service ){
+            OutputFormat format = response.getOutputFormat();
+            if(format == OutputFormat.HTML){
+                return new HTMLFormatWriter(service);
+            }
+            return new SyndicateFormatWriter(service,format,response.getEncoding());
+        }
+        
+        abstract void generateOutputFormat(final BaseFeed feed, final HttpServletResponse response) throws IOException;
+        abstract void generateOutputFormat(final BaseEntry entry, final HttpServletResponse response) throws IOException;
+        
+        private static class HTMLFormatWriter extends FormatWriter{
+            private static final String CONTENT_TYPE = "text/html";
+            private final ProvidedService service;
+            
+            HTMLFormatWriter(final ProvidedService service){
+                this.service = service;
+            }
+            @Override
+            void generateOutputFormat(BaseFeed feed, final HttpServletResponse response) throws IOException {
+                Templates template = this.service.getTransformTemplate();
+                response.setContentType(CONTENT_TYPE);
+                if(template == null){
+                    sendNotAvailable(response);
+                    return;
+                }
+                StringWriter writer = new StringWriter();
+                XmlWriter xmlWriter = new XmlWriter(writer);
+                feed.generateAtom(xmlWriter,this.service.getExtensionProfile());
+                try {
+                    writeHtml(template,response.getWriter(),writer);
+                } catch (TransformerException e) {
+                 LOG.error("Can not transform feed for service "+this.service.getName(),e);
+                 sendNotAvailable(response);
+                    
+                }
+            }
+
+            @Override
+            void generateOutputFormat(BaseEntry entry, final HttpServletResponse response)  throws IOException{
+                Templates template = this.service.getTransformTemplate();
+                response.setContentType(CONTENT_TYPE);
+                if(template == null){
+                    sendNotAvailable(response);
+                    return;
+                }
+                StringWriter writer = new StringWriter();
+                XmlWriter xmlWriter = new XmlWriter(writer);
+                entry.generateAtom(xmlWriter,this.service.getExtensionProfile());
+                try {
+                    writeHtml(template,response.getWriter(),writer);
+                } catch (TransformerException e) {
+                 LOG.error("Can not transform feed for service "+this.service.getName(),e);
+                 sendNotAvailable(response);
+                    
+                }
+
+            }
+            
+            private void writeHtml(final Templates template, final Writer writer, final StringWriter source ) throws TransformerException{
+                Transformer transformer = template.newTransformer();
+                Source tranformSource = new StreamSource(new StringReader(source.toString())); 
+                transformer.transform(tranformSource,new StreamResult(writer));
+            }
+            
+            private void sendNotAvailable(final HttpServletResponse response) throws IOException{
+                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE, "No transformation stylesheet available");
+            }
+            
+        }
+        private static class SyndicateFormatWriter extends FormatWriter{
+            private static final String DEFAUL_NAMESPACE_URI = "http://www.w3.org/2005/Atom";
+
+            private static final Namespace DEFAULT_NAMESPACE = new Namespace("",
+                    DEFAUL_NAMESPACE_URI);
+            private final ProvidedService service;
+            private final String encoding;
+            private final OutputFormat format;
+            
+            SyndicateFormatWriter(final ProvidedService service,final OutputFormat format, String encoding){
+                this.service = service;
+                this.format = format;
+                this.encoding = encoding;
+                
+            }
+            @Override
+            void generateOutputFormat(final BaseFeed feed, final HttpServletResponse response) throws IOException {
+                XmlWriter writer = null;
+                try{
+                 writer = createWriter(response.getWriter());
+                if (this.format == OutputFormat.ATOM) {
+                    response.setContentType(XMLMIME_ATOM);
+                    feed.generateAtom(writer, this.service.getExtensionProfile());
+                } else {
+                    response.setContentType(XMLMIME_RSS);
+                    feed.generateRss(writer, this.service.getExtensionProfile());
+                }
+                }finally{
+                    if(writer != null)
+                        writer.close();
+                }
+            }
+
+            @Override
+            void generateOutputFormat(final BaseEntry entry, final HttpServletResponse response) throws IOException {
+                XmlWriter writer = null;
+                try{
+                 writer = createWriter(response.getWriter());
+                if (this.format == OutputFormat.ATOM) {
+                    response.setContentType(XMLMIME_ATOM);
+                    entry.generateAtom(writer, this.service.getExtensionProfile());
+                } else {
+                    response.setContentType(XMLMIME_RSS);
+                    entry.generateRss(writer, this.service.getExtensionProfile());
+                }
+                }finally{
+                    if(writer != null)
+                        writer.close();
+                }
+            }
+            private XmlWriter createWriter(final Writer target) throws IOException {
+                XmlWriter writer = new XmlWriter(target, this.encoding);
+                // set the default namespace to Atom if Atom is the response format
+                if (this.format == OutputFormat.ATOM)
+                    writer.setDefaultNamespace(DEFAULT_NAMESPACE);
+                return writer;
+            }
+        }
+    }
+    
+    
+    
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/GDataSearchService.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/GDataSearchService.java
new file mode 100755
index 0000000..fd28f4d
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/GDataSearchService.java
@@ -0,0 +1,114 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.server;
+
+import java.io.IOException;
+import java.util.List;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.data.ServerBaseFeed;
+import org.apache.lucene.gdata.search.GDataSearcher;
+import org.apache.lucene.gdata.search.SearchComponent;
+import org.apache.lucene.gdata.search.query.GDataQueryParser;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
+import org.apache.lucene.gdata.server.registry.ProvidedService;
+import org.apache.lucene.gdata.storage.StorageException;
+import org.apache.lucene.queryParser.ParseException;
+import org.apache.lucene.queryParser.QueryParser;
+import org.apache.lucene.search.Query;
+
+import com.google.gdata.data.BaseEntry;
+import com.google.gdata.data.BaseFeed;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class GDataSearchService extends GDataService {
+    private static final Log LOG = LogFactory.getLog(GDataSearchService.class);
+    private static SearchComponent SEARCHCOMPONENT;
+    private GDataSearcher<String> searcher;
+    protected GDataSearchService() throws ServiceException {
+        if(SEARCHCOMPONENT == null)
+            SEARCHCOMPONENT = GDataServerRegistry.getRegistry().lookup(SearchComponent.class,ComponentType.SEARCHCONTROLLER);
+        
+       
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.GDataService#getFeed(org.apache.lucene.gdata.server.GDataRequest, org.apache.lucene.gdata.server.GDataResponse)
+     */
+    @SuppressWarnings("unchecked")
+    @Override
+    public BaseFeed getFeed(GDataRequest request, GDataResponse response) throws ServiceException {
+        String translatedQuery = request.getTranslatedQuery();
+        ProvidedService service = request.getConfigurator();
+        
+        QueryParser parser = new GDataQueryParser(service.getIndexSchema());
+        Query query;
+        try {
+            query = parser.parse(translatedQuery);
+           
+        } catch (ParseException e1) {
+            throw new ServiceException("Search Failed -- Can not parse query",e1,GDataResponse.BAD_REQUEST);
+        }
+        if(LOG.isInfoEnabled())
+            LOG.info("Fire search for user query  query: "+query.toString());
+        this.searcher = SEARCHCOMPONENT.getServiceSearcher(service);
+        List<String> result;
+        try {
+            result = this.searcher.search(query,request.getItemsPerPage(),request.getStartIndex(),request.getFeedId());
+        } catch (IOException e) {
+           throw new ServiceException("Search Failed -- Searcher throws IOException",e,GDataResponse.SERVER_ERROR); 
+           
+        }
+        if(LOG.isInfoEnabled())
+            LOG.info("Fetching results for user query result size: "+result.size());
+        ServerBaseFeed requestFeed = new ServerBaseFeed();
+        requestFeed.setServiceConfig(service);
+        requestFeed.setStartIndex(0);
+        requestFeed.setItemsPerPage(0);
+        requestFeed.setId(request.getFeedId());
+        BaseFeed feed = null;
+        try{
+         feed = this.storage.getFeed(requestFeed);
+        }catch (StorageException e) {
+            throw new ServiceException("Search Failed -- can not get feed, feed not stored ",e,GDataResponse.NOT_FOUND);
+        }
+        for (String entryId : result) {
+            ServerBaseEntry requestEntry = new ServerBaseEntry();
+            requestEntry.setId(entryId);
+            requestEntry.setServiceConfig(service);
+            try{
+            BaseEntry entry = this.storage.getEntry(requestEntry);
+            feed.getEntries().add(entry);
+            }catch (StorageException e) {
+                
+                LOG.error("StorageException caught while fetching query results -- skip entry -- "+e.getMessage(),e);
+            }
+        }
+        dynamicElementFeedStragey(feed,request);
+        return feed;
+    }
+
+    
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/GDataService.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/GDataService.java
new file mode 100644
index 0000000..0151394
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/GDataService.java
@@ -0,0 +1,450 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.server;
+
+import java.io.IOException;
+import java.util.Date;
+import java.util.List;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.data.ServerBaseFeed;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+import org.apache.lucene.gdata.server.registry.EntryEventMediator;
+import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
+import org.apache.lucene.gdata.storage.ModificationConflictException;
+import org.apache.lucene.gdata.storage.ResourceNotFoundException;
+import org.apache.lucene.gdata.storage.Storage;
+import org.apache.lucene.gdata.storage.StorageController;
+import org.apache.lucene.gdata.storage.StorageException;
+
+import com.google.gdata.data.BaseEntry;
+import com.google.gdata.data.BaseFeed;
+import com.google.gdata.data.DateTime;
+import com.google.gdata.data.Generator;
+import com.google.gdata.data.Link;
+import com.google.gdata.util.ParseException;
+
+/**
+ * default implementation of the {@link org.apache.lucene.gdata.server.Service}
+ * interface.
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class GDataService implements Service {
+    private static final Log LOG = LogFactory.getLog(GDataService.class);
+
+    protected Storage storage;
+
+    protected GDataServerRegistry registry = GDataServerRegistry.getRegistry();
+
+    private static final Generator generator;
+
+    private static final String generatorName = "Lucene GData-Server";
+
+    private static final String generatorURI = "http://lucene.apache.org";
+
+    private static final String XMLMIME = "application/atom+xml";
+    
+    protected final EntryEventMediator entryEventMediator;
+    static {
+        generator = new Generator();
+        generator.setName(generatorName);
+        generator.setUri(generatorURI);
+        generator.setVersion("0.1");
+    }
+
+    protected GDataService() throws ServiceException {
+        try {
+            StorageController controller = GDataServerRegistry.getRegistry()
+                    .lookup(StorageController.class,
+                            ComponentType.STORAGECONTROLLER);
+            if (controller == null)
+                throw new StorageException(
+                        "StorageController is not registered");
+            this.storage = controller.getStorage();
+            this.entryEventMediator = GDataServerRegistry.getRegistry().getEntryEventMediator();
+        } catch (StorageException e) {
+            LOG
+                    .fatal(
+                            "Can't get Storage Instance -- can't serve any requests",
+                            e);
+            ServiceException ex = new ServiceException(
+                    "Can't get Storage instance" + e.getMessage(), e,GDataResponse.SERVER_ERROR);
+            ex.setStackTrace(e.getStackTrace());
+            throw ex;
+        }
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.Service#createEntry(org.apache.lucene.gdata.server.GDataRequest,
+     *      org.apache.lucene.gdata.server.GDataResponse)
+     */
+
+    public BaseEntry createEntry(GDataRequest request, GDataResponse response)
+            throws ServiceException {
+
+        if (LOG.isInfoEnabled())
+            LOG.info("create Entry for feedId: " + request.getFeedId());
+
+        ServerBaseEntry entry = buildEntry(request, response);
+        entry.setFeedId(request.getFeedId());
+        entry.setServiceConfig(request.getConfigurator());
+        BaseEntry tempEntry = entry.getEntry();
+        tempEntry.setPublished(getCurrentDateTime());
+        tempEntry.setUpdated(getCurrentDateTime());
+        BaseEntry retVal = null;
+        removeDynamicElements(entry.getEntry());
+        try {
+            retVal = this.storage.storeEntry(entry);
+        } catch (Exception e) {
+            
+            ServiceException ex = new ServiceException("Could not store entry",
+                    e,GDataResponse.SERVER_ERROR);
+            ex.setStackTrace(e.getStackTrace());
+            throw ex;
+        }
+        this.entryEventMediator.entryAdded(entry);
+        return retVal;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.Service#deleteEntry(org.apache.lucene.gdata.server.GDataRequest,
+     *      org.apache.lucene.gdata.server.GDataResponse)
+     */
+
+    public BaseEntry deleteEntry(GDataRequest request, GDataResponse response)
+            throws ServiceException {
+
+        ServerBaseEntry entry = new ServerBaseEntry();
+        entry.setServiceConfig(request.getConfigurator());
+        entry.setFeedId(request.getFeedId());
+        entry.setId(request.getEntryId());
+        setVersionId(entry,request,response);
+        if (entry.getId() == null)
+            throw new ServiceException(
+                    "entry id is null -- can not delete null entry",GDataResponse.SERVER_ERROR);
+        try {
+            this.storage.deleteEntry(entry);
+            
+        } catch (ResourceNotFoundException e) {
+            
+            ServiceException ex = new ServiceException(
+                    "Could not delete entry", e,GDataResponse.BAD_REQUEST);
+            ex.setStackTrace(e.getStackTrace());
+            throw ex;
+        }catch (ModificationConflictException e) {
+            
+            ServiceException ex = new ServiceException(
+                    "Could not delete entry - version conflict",e, GDataResponse.CONFLICT);
+            ex.setStackTrace(e.getStackTrace());
+            throw ex;  
+        }catch (StorageException e) {
+            
+            ServiceException ex = new ServiceException(
+                    "Could not delete entry", e,GDataResponse.SERVER_ERROR);
+            ex.setStackTrace(e.getStackTrace());
+            throw ex;
+        }
+        this.entryEventMediator.entryDeleted(entry);
+        //TODO change ret value
+        return null;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.Service#updateEntry(org.apache.lucene.gdata.server.GDataRequest,
+     *      org.apache.lucene.gdata.server.GDataResponse)
+     */
+
+    public BaseEntry updateEntry(GDataRequest request, GDataResponse response)
+            throws ServiceException {
+
+        ServerBaseEntry entry = buildEntry(request, response);
+        entry.setFeedId(request.getFeedId());
+        setVersionId(entry,request,response);
+        entry.setServiceConfig(request.getConfigurator());
+        if (LOG.isInfoEnabled())
+            LOG.info("update Entry" + entry.getId() + " for feedId: "
+                    + request.getFeedId());
+        if (entry.getId() == null) {
+            throw new ServiceException("Entry id is null can not update entry",GDataResponse.BAD_REQUEST);
+        }
+        if (!entry.getId().equals(request.getEntryId())) {
+            if (LOG.isInfoEnabled())
+                LOG
+                        .info("Entry id in the entry xml does not match the requested resource -- XML-ID:"
+                                + entry.getId()
+                                + "; Requested resource: "
+                                + request.getEntryId());
+
+            throw new ServiceException(
+                    "Entry id in the entry xml does not match the requested resource",GDataResponse.BAD_REQUEST);
+        }
+        BaseEntry tempEntry = entry.getEntry();
+        tempEntry.setUpdated(getCurrentDateTime());
+        removeDynamicElements(entry.getEntry());
+        
+        BaseEntry retVal = null;
+     
+        try {
+            retVal = this.storage.updateEntry(entry);
+        } catch (ResourceNotFoundException e) {
+            
+            ServiceException ex = new ServiceException(
+                    "Could not update entry", e,GDataResponse.BAD_REQUEST);
+            ex.setStackTrace(e.getStackTrace());
+            throw ex;
+        }catch (ModificationConflictException e) {
+            ServiceException ex = new ServiceException(
+                    "Could not update entry - version conflict", e,GDataResponse.CONFLICT);
+            ex.setStackTrace(e.getStackTrace());
+            throw ex;
+        }catch (StorageException e) {
+
+            ServiceException ex = new ServiceException(
+                    "Could not update entry", e,GDataResponse.SERVER_ERROR);
+            ex.setStackTrace(e.getStackTrace());
+            throw ex;
+        }
+        this.entryEventMediator.entryUpdated(entry);
+        return retVal;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.Service#getFeed(org.apache.lucene.gdata.server.GDataRequest,
+     *      org.apache.lucene.gdata.server.GDataResponse)
+     */
+    @SuppressWarnings("unchecked")
+    public BaseFeed getFeed(GDataRequest request, GDataResponse response)
+            throws ServiceException {
+
+        ServerBaseFeed feed = new ServerBaseFeed();
+        feed.setId(request.getFeedId());
+        feed.setStartIndex(request.getStartIndex());
+        feed.setItemsPerPage(request.getItemsPerPage());
+        feed.setServiceConfig(request.getConfigurator());
+        try {
+            /*
+             * the strategy executes either a search or a direct access.
+             */
+            BaseFeed retVal = this.storage.getFeed(feed);
+            dynamicElementFeedStragey(retVal, request);
+
+            return retVal;
+            /*
+             * Resource not found will be detected in Gdata request.
+             * the request queries the storage for the feed to get the service for the feed
+             */
+        } catch (StorageException e) {
+            ServiceException ex = new ServiceException("Could not get feed", e,GDataResponse.NOT_FOUND);
+            ex.setStackTrace(e.getStackTrace());
+            throw ex;
+        }
+
+    }
+
+    private Link buildLink(String rel, String type, String href) {
+        Link retVal = new Link();
+        retVal.setHref(href);
+        retVal.setRel(rel);
+        retVal.setType(type);
+        return retVal;
+    }
+
+    private ServerBaseEntry buildEntry(final GDataRequest request,
+            final GDataResponse response) throws ServiceException {
+        try {
+            ServerBaseEntry entry = new ServerBaseEntry(GDataEntityBuilder
+                    .buildEntry(request));
+            return entry;
+
+        } catch (ParseException e) {
+            ServiceException ex = new ServiceException(
+                    "Could not parse entry from incoming request", e, GDataResponse.BAD_REQUEST);
+            ex.setStackTrace(e.getStackTrace());
+            throw ex;
+        } catch (IOException e) {
+            ServiceException ex = new ServiceException(
+                    "Could not read or open input stream", e, GDataResponse.BAD_REQUEST);
+            ex.setStackTrace(e.getStackTrace());
+            throw ex;
+        }
+    }
+
+
+    /**
+     * @see org.apache.lucene.gdata.server.Service#getSingleEntry(org.apache.lucene.gdata.server.GDataRequest,
+     *      org.apache.lucene.gdata.server.GDataResponse)
+     */
+
+    public BaseEntry getSingleEntry(GDataRequest request, GDataResponse response)
+            throws ServiceException {
+
+        try {
+            ServerBaseEntry entry = new ServerBaseEntry();
+            entry.setServiceConfig(request.getConfigurator());
+            entry.setFeedId(request.getFeedId());
+            entry.setId(request.getEntryId());
+
+            
+            if(entry.getId() == null){
+                throw new ServiceException("entry is null can't get entry", GDataResponse.BAD_REQUEST);
+            }
+                
+            BaseEntry retVal = null;
+            retVal = this.storage.getEntry(entry);
+            dynamicElementEntryStragey(retVal, request);
+            return retVal;
+        } catch (ResourceNotFoundException e) {
+            ServiceException ex = new ServiceException(
+                    "Could not get entry", e, GDataResponse.BAD_REQUEST);
+            ex.setStackTrace(e.getStackTrace());
+            throw ex;
+        } catch (StorageException e) {
+            ServiceException ex = new ServiceException("Could not get entry", e, GDataResponse.SERVER_ERROR);
+            ex.setStackTrace(e.getStackTrace());
+            throw ex;
+        }
+    }
+
+    /*
+     * adds all dynamic element to the entry
+     */
+    private void dynamicElementEntryStragey(final BaseEntry entry,
+            final GDataRequest request) {
+        setSelfLink(entry, request.getContextPath());
+    }
+
+    /*
+     * adds all dynamic element to the feed entries
+     */
+    @SuppressWarnings("unchecked")
+    protected void dynamicElementFeedStragey(final BaseFeed feed,
+            final GDataRequest request) {
+         buildDynamicFeedElements(request, feed);
+        List<BaseEntry> entryList = feed.getEntries();
+        for (BaseEntry entry : entryList) {
+            String id = new StringBuilder(request.getContextPath()).append(entry.getId()).append("/").toString();
+            setSelfLink(entry, id);
+        }
+
+    }
+
+    /*
+     * The selfLink is build from a prefix and the entry id. The prefix is the
+     * context path of the requested feed. This will be used to request the
+     * entry directly
+     */@SuppressWarnings("unchecked")
+    private BaseEntry setSelfLink(final BaseEntry entry, String id) {
+        Link self = buildLink(Link.Rel.SELF, XMLMIME, id);
+        StringBuilder builder = new StringBuilder(id);
+        builder.append(entry.getVersionId());
+        Link edit = buildLink(Link.Rel.ENTRY_EDIT,XMLMIME,builder.toString());
+        List<Link> list = entry.getLinks();
+        list.add(edit);
+        list.add(self);
+        return entry;
+    }
+
+    /*
+     * build the dynamic elements like self link and next link
+     */
+    private void buildDynamicFeedElements(final GDataRequest request,
+            final BaseFeed feed) {
+        feed.setGenerator(generator);
+        feed.setItemsPerPage(request.getItemsPerPage());
+        feed.setStartIndex(request.getStartIndex());
+        feed.setId(request.getContextPath());
+        List<Link> links = feed.getLinks();
+        links.add(
+                buildLink(Link.Rel.SELF, Link.Type.ATOM, request.getSelfId()));
+        links.add(
+                buildLink(Link.Rel.NEXT, XMLMIME, request.getNextId()));
+        String prevLink = request.getPreviousId();
+        if(prevLink != null)
+            links.add(buildLink(Link.Rel.PREVIOUS,XMLMIME,prevLink));
+        
+
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.Service#close()
+     */
+    public void close() {
+        this.storage.close();
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.Service#getFeedLastModified(java.lang.String)
+     */
+    public Date getFeedLastModified(final String feedId) throws ServiceException {
+        try {
+            return new Date(this.storage.getFeedLastModified(feedId));
+           
+        } catch (StorageException e) {
+            ServiceException ex = new ServiceException(
+                    "Could not get Last update for feed -- "+feedId, e, GDataResponse.SERVER_ERROR);
+            ex.setStackTrace(e.getStackTrace());
+            throw ex;
+        }
+
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.Service#getEntryLastModified(java.lang.String, java.lang.String)
+     */
+    public Date getEntryLastModified(final String entryId,final String feedId) throws ServiceException {
+            try {
+                return new Date(this.storage.getEntryLastModified(entryId, feedId));
+            } catch (StorageException e) {
+                ServiceException ex = new ServiceException(
+                        "Could not get Last update for entry  -- "+entryId, e, GDataResponse.SERVER_ERROR);
+                ex.setStackTrace(e.getStackTrace());
+                throw ex;
+            }
+        
+    }
+    private ServerBaseEntry setVersionId(final ServerBaseEntry entry, final GDataRequest request, final GDataResponse response)throws ServiceException{
+        try{
+            entry.setVersion(Integer.parseInt(request.getEntryVersion()));
+            return entry;
+        }catch (Exception e) {
+            LOG.error("Can not parse entry version -- version is not an integer -- versionid: "+request.getEntryVersion(),e);
+            throw new ServiceException("Can not parse entry version -- version is not an integer -- versionid: "+request.getEntryVersion(),e, GDataResponse.BAD_REQUEST);
+           
+        }
+    }
+    /*
+     * provide current time to set as published / updated values
+     * always use servertime to prevent client / server time lag
+     * Timezoneshift is 0
+     */
+    protected DateTime getCurrentDateTime(){
+        return new DateTime(System.currentTimeMillis(),0);
+    }
+    
+    private void removeDynamicElements(BaseEntry entry){
+        Link selfLink = entry.getSelfLink();
+        if(selfLink != null)
+            entry.getLinks().remove(selfLink);
+        Link editLink = entry.getEditLink();
+        if(editLink != null)
+            entry.getLinks().remove(editLink);
+    }
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/Service.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/Service.java
new file mode 100644
index 0000000..a3d7d8d
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/Service.java
@@ -0,0 +1,162 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */ 
+ 
+package org.apache.lucene.gdata.server; 
+ 
+import java.util.Date;
+
+import com.google.gdata.data.BaseEntry; 
+import com.google.gdata.data.BaseFeed; 
+ 
+ 
+/** 
+ * The Service class represents an interface to access the GData service 
+ * componentes of the GData-Server. It encapsulates all interactions with the 
+ * GData client. 
+ * <p> 
+ * This class provides the base level common functionality required to access 
+ * the GData components. It is also designed to act as a base class that can be 
+ * extended for specific types of underlaying server components as different 
+ * indexing or storage components. 
+ * </p> 
+ * <p> 
+ * It could also encapsulate caching mechanismn build on top of the storage to 
+ * reduce load on the storage component 
+ * </p> 
+ *  
+ * @author Simon Willnauer 
+ *  
+ *  
+ */ 
+public interface Service { 
+ 
+    /** 
+     * Service method to create an entry in an already created and existing 
+     * feed. This method will create the entry and passes the entry to the 
+     * indexing component to make the new entry accessable via <i>get-queries</i>. 
+     * The response and the corresponding http status code will be added to the 
+     * given <code>FeedResponse</code>. 
+     *  
+     * @param request - 
+     *            the current FeedRequest 
+     * @param response - 
+     *            the current FeedResponse 
+     * @return - the entry which has been created  
+     * @throws ServiceException - 
+     *             if the corresponding feed does not exist or the storage can 
+     *             not be accessed 
+     */ 
+    public abstract BaseEntry createEntry(final GDataRequest request, 
+            final GDataResponse response) throws ServiceException; 
+ 
+    /** 
+     * Service Method to delete an entry specified in the given FeedRequest. 
+     * This method will remove the entry permanently. There will be no 
+     * possiblity to restore the entry. The response and the corresponding http 
+     * status code will be added to the given <code>FeedResponse</code>. 
+     *  
+     * @param request - 
+     *            the current FeedRequest 
+     * @param response - 
+     *            the current FeedResponse 
+     * @return - the entry wich has been deleted 
+     * @throws ServiceException - 
+     *             if the entry does not exist or the storage can not be 
+     *             accessed 
+     */ 
+    public abstract BaseEntry deleteEntry(GDataRequest request, final GDataResponse response) 
+            throws ServiceException; 
+ 
+    /** 
+     * Service method to update an existing entry in a existing feed context. 
+     * The entry version will be checked and a <code>ServiceException</code> 
+     * will be thrown if the version to update is outdated. The new entry will 
+     * be passed to the indexing component to make the version accessable via 
+     * <i>get-queries</i>. 
+     *  
+     * @param request - 
+     *            the current FeedRequest 
+     * @param response - 
+     *            the current FeedResponse 
+     * @return - the entry wich has been updated 
+     * @throws ServiceException - 
+     *             if the corresponding feed does not exist, the storage can not 
+     *             be accessed or the version to update is out of date. 
+     */ 
+    public abstract BaseEntry  updateEntry(final GDataRequest request, 
+            final GDataResponse response) throws ServiceException; 
+ 
+    /** 
+     * Service method to retrieve a requested Feed. The feed will also be added to 
+     * the given <code>FeedResponse</code> instance and can also be accessed 
+     * via the <code>FeedResponse</code> object. 
+     *  
+     * @param request - 
+     *            the current FeedRequest 
+     * @param response - 
+     *            the current FeedResponse 
+     * @return - the requested feed 
+     *  
+     * @throws ServiceException - 
+     *             If the storage can not be accessed or the requested feed does 
+     *             not exist. 
+     */ 
+    public abstract BaseFeed getFeed(final GDataRequest request, final GDataResponse response) 
+            throws ServiceException; 
+ 
+    /** 
+     * Service method to retrieve a requested entry. The entry will also be added to 
+     * the given <code>FeedResponse</code> instance and can also be accessed 
+     * via the <code>FeedResponse</code> object. 
+     *  
+     * @param request - 
+     *            the current FeedRequest 
+     * @param response - 
+     *            the current FeedResponse 
+     * @return - the requested entry 
+     *  
+     * @throws ServiceException - 
+     *             If the storage can not be accessed or the requested entry does 
+     *             not exist. 
+     */ 
+    public abstract BaseEntry getSingleEntry(final GDataRequest request, final GDataResponse response) 
+            throws ServiceException; 
+     
+    /**
+     * will close the Service - service should not be used after this method has been called
+     */
+    public void close();
+
+    /**
+     * Retruns the date of the last modification for the given feed id
+     * @param feedId - the id of the feed 
+     * @return - the last modified date or the current date if the date can not be retrieved
+     * @throws ServiceException - if the storage can not be accessed
+     */
+    public abstract Date getFeedLastModified(String feedId)throws ServiceException;
+
+    /**
+     * Retruns the date of the last modification for the given entry id
+     * @param entryId - the id of the entry
+     * @param feedId  - the feed id this entry belongs to
+     * @return - the last modified date or the current date if the date can not be retrieved
+     * @throws ServiceException - if the storage can not be accessed 
+     */
+    public abstract Date getEntryLastModified(String entryId, String feedId)throws ServiceException;
+     
+ 
+ 
+} 
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/ServiceException.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/ServiceException.java
new file mode 100644
index 0000000..9643e2b
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/ServiceException.java
@@ -0,0 +1,85 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+
+package org.apache.lucene.gdata.server;
+
+
+/**
+ * The ServiceException is used to encapsulate all {@link java.lang.Exception}
+ * throw by underlying layers of the
+ * {@link org.apache.lucene.gdata.server.Service} layer.
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class ServiceException extends Exception {
+    
+    private int errorCode;
+    /**
+     * 
+     */
+    private static final long serialVersionUID = -7099825107871876584L;
+
+    /**
+     * Constructs a new ServiceException
+     * @param errorCode - gdata request error code
+     */
+    public ServiceException(int errorCode) {
+        super();
+        this.errorCode = errorCode;
+
+    }
+
+    /**
+     * Constructs a new ServiceException
+     * @param arg0 - the exception message
+     * @param errorCode - gdata request error code
+     */
+    public ServiceException(String arg0,int errorCode) {
+        super(arg0);
+        this.errorCode = errorCode;
+    }
+
+    /**
+     * Constructs a new ServiceException
+     * @param arg0 - the exception message
+     * @param arg1 - the exception cause
+     * @param errorCode - gdata request error code
+     */
+    public ServiceException(String arg0, Throwable arg1,int errorCode) {
+        super(arg0, arg1);
+        this.errorCode = errorCode;
+        
+    }
+
+    /**
+     * Constructs a new ServiceException
+     * @param arg0 - the exception cause
+     * @param errorCode - gdata request error code
+     */
+    public ServiceException(Throwable arg0,int errorCode) {
+        super(arg0);
+        this.errorCode = errorCode;
+    }
+
+    /**
+     * @return Returns the errorCode.
+     */
+    public int getErrorCode() {
+        return this.errorCode;
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/ServiceFactory.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/ServiceFactory.java
new file mode 100644
index 0000000..9476695
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/ServiceFactory.java
@@ -0,0 +1,96 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.server;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.server.administration.AdminService;
+import org.apache.lucene.gdata.server.administration.GDataAdminService;
+import org.apache.lucene.gdata.server.registry.Component;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+import org.apache.lucene.gdata.server.registry.ServerComponent;
+
+
+/**
+ * The {@link ServiceFactory} creates {@link Service} implementations to access
+ * the GData - Server components.
+ * This class should not be access directy. The class will be registered in the {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry}.
+ * Use {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry#lookup(Class, ComponentType)}
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+@Component(componentType=ComponentType.SERVICEFACTORY)
+public class ServiceFactory implements ServerComponent {
+
+    private static final Log LOG = LogFactory.getLog(ServiceFactory.class);
+
+	
+
+	/**
+	 * public constructor to enable loading via the registry
+     * @see org.apache.lucene.gdata.server.registry.Component
+     * @see org.apache.lucene.gdata.server.registry.GDataServerRegistry
+	 */
+	public ServiceFactory() {
+		//
+	}
+
+	/**
+	 * Creates a {@link Service} instance.
+	 * @param request - the request for this service
+	 * 
+	 * @return a Service instance
+	 */
+	public Service getService(GDataRequest request) {
+		try{
+            if(request.isSearchRequested())
+                return new GDataSearchService();
+		return new GDataService();
+        }catch (Exception e) {
+            //
+        }
+        return null;
+	}
+    
+    /**
+     * Creates a {@link AdminService} instance
+     * @return a AdminService instance
+     */
+    public AdminService getAdminService(){
+        try {
+            return new GDataAdminService();
+        } catch (ServiceException e) {
+           LOG.warn("Factory method can not create GDataAdminService returning null-- "+e.getMessage(),e);
+        }
+        return null;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.registry.ServerComponent#initialize()
+     */
+    public void initialize() {
+        //
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.registry.ServerComponent#destroy()
+     */
+    public void destroy() {
+        //
+    }
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/administration/AccountBuilder.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/administration/AccountBuilder.java
new file mode 100644
index 0000000..af823f2
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/administration/AccountBuilder.java
@@ -0,0 +1,84 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.server.administration;
+
+import java.io.IOException;
+import java.io.Reader;
+import java.net.URL;
+
+
+
+import org.apache.commons.digester.Digester;
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.utils.SimpleSaxErrorHandler;
+import org.apache.xerces.parsers.SAXParser;
+import org.xml.sax.SAXException;
+
+/**
+ * Helper class to create {@link org.apache.lucene.gdata.data.GDataAccount}
+ * instances from a xml stream provided via a {@link Reader} instance.
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class AccountBuilder {
+
+    /**
+     * Reads the xml from the provided reader and binds the values to the 
+     * @param reader - the reader to read the xml from
+     * @return - the GDataAccount 
+     * @throws IOException - if an IOException occurs
+     * @throws SAXException - if the xml can not be parsed by the sax reader
+     */
+    public static GDataAccount buildAccount(final Reader reader) throws IOException,
+            SAXException {
+        if (reader == null)
+            throw new IllegalArgumentException("Reader must not be null");
+        URL resource = AccountBuilder.class.getResource("/gdata-account.xsd");
+        if(resource == null)
+            throw new RuntimeException("can not find xml schema file 'gdata-account.xsd' -- file must be present on the classpath");
+        String schemaFile = resource.getFile();
+        GDataAccount account = null;
+        /*
+         * Force using apache xerces parser for digester
+         */
+        SAXParser parser = new SAXParser();
+        parser.setFeature("http://apache.org/xml/features/validation/schema-full-checking",true);
+        parser.setFeature("http://apache.org/xml/features/validation/schema",true);
+        parser.setFeature("http://xml.org/sax/features/validation",true); 
+        parser.setProperty("http://apache.org/xml/properties/schema/external-noNamespaceSchemaLocation",schemaFile);
+        Digester digester = new Digester(parser);
+        digester.setValidating(true);
+        digester.setErrorHandler(new SimpleSaxErrorHandler());
+        digester.setSchema(schemaFile);
+        digester.addObjectCreate("account", GDataAccount.class);
+        digester.addBeanPropertySetter("account/account-name", "name");
+        digester.addBeanPropertySetter("account/password", "password");
+        digester.addBeanPropertySetter("account/account-role", "rolesAsInt");
+        digester.addBeanPropertySetter("account/account-owner/name",
+                "authorname");
+        digester.addBeanPropertySetter("account/account-owner/email-address",
+                "authorMail");
+        digester.addBeanPropertySetter("account/account-owner/url",
+                "authorLink");
+
+        account = (GDataAccount) digester.parse(reader);
+        return account;
+    }
+    
+    
+  
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/administration/AdminService.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/administration/AdminService.java
new file mode 100644
index 0000000..b6e81b2
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/administration/AdminService.java
@@ -0,0 +1,123 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.server.administration;
+
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.data.ServerBaseFeed;
+import org.apache.lucene.gdata.server.Service;
+import org.apache.lucene.gdata.server.ServiceException;
+
+/**
+ * The AdminService interface extends the Service interface to serve common
+ * administrator requests. Common users can not create feed or user instances.
+ * This interface provides all actions for create, delete or update Users and
+ * Feeds. Each Feed has an associated Feed - Name which acts as an ID. Feed will
+ * be identified by the feed name e.g. {@link com.google.gdata.data.Source#getId()}
+ * <p>User accounts are supposed to have a unique username attribute as the username acts as a primary key for the storage</p>
+ *  
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public interface AdminService extends Service {
+
+    /**
+     * Creates a new feed instance.
+     * 
+     * @param feed -
+     *            the feed to create
+     * @param account - the account who own this feed
+     * @throws ServiceException -
+     *             if the feed can not be created
+     */
+    public abstract void createFeed(final ServerBaseFeed feed,
+            final GDataAccount account) throws ServiceException;
+
+    /**
+     * Updates the given feed
+     * 
+     * @param feed -
+     *            the feed to update
+     * @param account - the account who own this feed
+     * 
+     * @throws ServiceException -
+     *             if the feed can not be updated or does not exist.
+     */
+    public abstract void updateFeed(final ServerBaseFeed feed,
+            final GDataAccount account) throws ServiceException;
+
+    /**
+     * Deletes the given feed and all containing entries from the storage. The feed will not be accessable
+     * anymore.
+     * 
+     * @param feed -
+     *            the feed to deltete
+     * 
+     * @throws ServiceException -
+     *             if the feed can not be deleted or does not exist
+     */
+    public abstract void deleteFeed(final ServerBaseFeed feed) throws ServiceException;
+
+    /**
+     * Creates a new account accout.
+     * 
+     * @param account -
+     *            the account to create
+     * @throws ServiceException -
+     *             if the account can not be created or the account does already
+     *             exist.
+     */
+    public abstract void createAccount(final GDataAccount account)
+            throws ServiceException;
+
+    /**
+     * Deletes the given account from the storage. it will also delete all
+     * accociated feeds.
+     * 
+     * @param account
+     *            the account to delete
+     * @throws ServiceException -
+     *             if the account does not exist or the account can not be deleted
+     */
+    public abstract void deleteAccount(final GDataAccount account)
+            throws ServiceException;
+
+    /**
+     * Updates the given account if the account already exists.
+     * 
+     * @param account - the account to update 
+     * @throws ServiceException - if the account can not be updated or the account does not exist
+     */
+    public abstract void updateAccount(final GDataAccount account)
+            throws ServiceException;
+
+    /**
+     * Returns the account for the given account name or <code>null</code> if the account does not exist 
+     * 
+     * @param account - account name
+     * @return - the account for the given account name or <code>null</code> if the account does not exist
+     * @throws ServiceException - if the account can not be accessed
+     */
+    public abstract GDataAccount getAccount(String account) throws ServiceException;
+    
+    /**
+     * Returns the account associated with the feed for the given feed id
+     * @param feedId - the feed id
+     * @return - the GdataAccount assoziated with the feed for the given feed Id or <code>null</code> if there is no feed for the given feed Id
+     * @throws ServiceException - if the storage can not be accessed
+     */
+    public abstract GDataAccount getFeedOwningAccount(String feedId) throws ServiceException;
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/administration/GDataAdminService.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/administration/GDataAdminService.java
new file mode 100644
index 0000000..a4df68e
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/administration/GDataAdminService.java
@@ -0,0 +1,231 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.server.administration;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.data.ServerBaseFeed;
+import org.apache.lucene.gdata.server.GDataResponse;
+import org.apache.lucene.gdata.server.GDataService;
+import org.apache.lucene.gdata.server.ServiceException;
+import org.apache.lucene.gdata.server.registry.ProvidedService;
+import org.apache.lucene.gdata.storage.StorageException;
+
+/**
+ * default implementation of the
+ * {@link org.apache.lucene.gdata.server.administration.AdminService} interface.
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class GDataAdminService extends GDataService implements AdminService {
+    private static final Log LOG = LogFactory.getLog(GDataAdminService.class);
+
+    /**
+     * @throws ServiceException
+     */
+    public GDataAdminService() throws ServiceException {
+        super();
+
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.administration.AdminService#createFeed(org.apache.lucene.gdata.data.ServerBaseFeed,
+     *      org.apache.lucene.gdata.data.GDataAccount)
+     */
+    public void createFeed(final ServerBaseFeed feed, final GDataAccount account)
+            throws ServiceException {
+        if (feed == null)
+            throw new ServiceException("Can not create feed -- feed is null",
+                    GDataResponse.BAD_REQUEST);
+        if (account == null)
+            throw new ServiceException(
+                    "Can not create feed -- account is null",
+                    GDataResponse.UNAUTHORIZED);
+        if (feed.getId() == null)
+            throw new ServiceException("Feed ID is null can not create feed",
+                    GDataResponse.BAD_REQUEST);
+        if (account.getName() == null)
+            throw new ServiceException(
+                    "Account name is null -- can't create feed",
+                    GDataResponse.UNAUTHORIZED);
+        try {
+            feed.setUpdated(getCurrentDateTime());
+            feed.setAccount(account);
+            this.storage.storeFeed(feed, account.getName());
+        } catch (StorageException e) {
+            if (LOG.isInfoEnabled())
+                LOG.info("Can not save feed -- " + e.getMessage(), e);
+            throw new ServiceException("Can not save feed", e,
+                    GDataResponse.BAD_REQUEST);
+        }
+
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.administration.AdminService#updateFeed(org.apache.lucene.gdata.data.ServerBaseFeed,
+     *      org.apache.lucene.gdata.data.GDataAccount)
+     */
+    public void updateFeed(ServerBaseFeed feed, GDataAccount account)
+            throws ServiceException {
+        if (feed == null)
+            throw new ServiceException("Can not update null feed",
+                    GDataResponse.BAD_REQUEST);
+        if (account == null)
+            throw new ServiceException(
+                    "Can not update feed -- account is null",
+                    GDataResponse.UNAUTHORIZED);
+        if (feed.getId() == null)
+            throw new ServiceException("Feed ID is null can not update feed",
+                    GDataResponse.BAD_REQUEST);
+        if (account.getName() == null)
+            throw new ServiceException(
+                    "Account name is null -- can't update feed",
+                    GDataResponse.UNAUTHORIZED);
+        try {
+            feed.setAccount(account);
+            feed.setUpdated(getCurrentDateTime());
+            this.storage.updateFeed(feed, account.getName());
+        } catch (StorageException e) {
+            if (LOG.isInfoEnabled())
+                LOG.info("Can not update feed -- " + e.getMessage(), e);
+            throw new ServiceException("Can not update feed", e,
+                    GDataResponse.BAD_REQUEST);
+        }
+
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.administration.AdminService#deleteFeed(org.apache.lucene.gdata.data.ServerBaseFeed)
+     */
+    public void deleteFeed(ServerBaseFeed feed) throws ServiceException {
+        if (feed == null)
+            throw new ServiceException("Can not delete null feed",
+                    GDataResponse.BAD_REQUEST);
+        if (feed.getId() == null)
+            throw new ServiceException("Feed ID is null can not delete feed",
+                    GDataResponse.BAD_REQUEST);
+        String serviceid = null;
+        try {
+            serviceid = this.storage.getServiceForFeed(feed.getId());
+            this.storage.deleteFeed(feed.getId());
+        } catch (StorageException e) {
+            if (LOG.isInfoEnabled())
+                LOG.info("Can not delete feed -- " + e.getMessage(), e);
+            throw new ServiceException("Can not delete feed", e,
+                    GDataResponse.BAD_REQUEST);
+        }
+        ProvidedService service = this.registry.getProvidedService(serviceid);
+        feed.setServiceConfig(service);
+        this.entryEventMediator.allEntriesDeleted(feed);
+
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.administration.AdminService#createAccount(org.apache.lucene.gdata.data.GDataAccount)
+     */
+    public void createAccount(GDataAccount account) throws ServiceException {
+        if (account == null)
+            throw new ServiceException("Can not save null account",
+                    GDataResponse.BAD_REQUEST);
+        try {
+            this.storage.storeAccount(account);
+        } catch (StorageException e) {
+            if (LOG.isInfoEnabled())
+                LOG.info("Can not save account -- " + e.getMessage(), e);
+            throw new ServiceException("Can not save account", e,
+                    GDataResponse.BAD_REQUEST);
+        }
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.administration.AdminService#deleteAccount(org.apache.lucene.gdata.data.GDataAccount)
+     */
+    public void deleteAccount(GDataAccount account) throws ServiceException {
+        if (account == null)
+            throw new ServiceException("Can not delete null account",
+                    GDataResponse.BAD_REQUEST);
+        try {
+            this.storage.deleteAccount(account.getName());
+        } catch (StorageException e) {
+            if (LOG.isInfoEnabled())
+                LOG.info("Can not save account -- " + e.getMessage(), e);
+            throw new ServiceException("Can not save account", e,
+                    GDataResponse.BAD_REQUEST);
+        }
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.administration.AdminService#updateAccount(org.apache.lucene.gdata.data.GDataAccount)
+     */
+    public void updateAccount(GDataAccount account) throws ServiceException {
+        if (account == null)
+            throw new ServiceException("Can not update null account",
+                    GDataResponse.BAD_REQUEST);
+        try {
+            this.storage.updateAccount(account);
+        } catch (StorageException e) {
+            if (LOG.isInfoEnabled())
+                LOG.info("Can not save account -- " + e.getMessage(), e);
+            throw new ServiceException("Can not save account", e,
+                    GDataResponse.BAD_REQUEST);
+        }
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.administration.AdminService#getAccount(java.lang.String)
+     */
+    public GDataAccount getAccount(String accountName) throws ServiceException {
+        if (accountName == null)
+            throw new ServiceException("Can not get null account",
+                    GDataResponse.BAD_REQUEST);
+        try {
+            return this.storage.getAccount(accountName);
+        } catch (StorageException e) {
+            if (LOG.isInfoEnabled())
+                LOG.info("Can not get account -- " + e.getMessage(), e);
+            throw new ServiceException("Can not get account", e,
+                    GDataResponse.BAD_REQUEST);
+        }
+
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.administration.AdminService#getFeedOwningAccount(java.lang.String)
+     */
+    public GDataAccount getFeedOwningAccount(String feedId)
+            throws ServiceException {
+        if (feedId == null)
+            throw new ServiceException(
+                    "Can not get account - feed id must not be null",
+                    GDataResponse.BAD_REQUEST);
+        try {
+            String accountName = this.storage.getAccountNameForFeedId(feedId);
+            return this.storage.getAccount(accountName);
+
+        } catch (StorageException e) {
+            if (LOG.isInfoEnabled())
+                LOG.info(
+                        "Can not get account for feed Id -- " + e.getMessage(),
+                        e);
+            throw new ServiceException(
+                    "Can not get account for the given feed id", e,
+                    GDataResponse.BAD_REQUEST);
+        }
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/administration/package.html b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/administration/package.html
new file mode 100644
index 0000000..3ea9939
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/administration/package.html
@@ -0,0 +1,10 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
+<html> 
+<head> 
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
+   <meta name="Author" content="Simon Willnauer"> 
+</head> 
+<body> 
+Classes and Services used for user and feed configuration
+</body> 
+</html> 
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/authentication/AuthenticationController.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/authentication/AuthenticationController.java
new file mode 100644
index 0000000..6102735
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/authentication/AuthenticationController.java
@@ -0,0 +1,123 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.server.authentication;
+
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
+import org.apache.lucene.gdata.server.registry.ServerComponent;
+
+/**
+ * Implementations of the AuthenticationController interface contain all the
+ * logic for processing token based authentification. A token is an encoded
+ * unique <tt>String</tt> value passed back to the client if successfully
+ * authenticated. Clients provide account name, password, the requested service
+ * and the name of the application used for accessing the the gdata service.
+ * <p>
+ * The algorithmn to create and reauthenticate the token can be choosen by the
+ * implementor. <br/> This interface extends
+ * {@link org.apache.lucene.gdata.server.registry.ServerComponent} e.g.
+ * implementing classes can be registered as a
+ * {@link org.apache.lucene.gdata.server.registry.Component} in the
+ * {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry} to be
+ * accessed via the provided lookup service
+ * </p>
+ * 
+ * @see org.apache.lucene.gdata.server.authentication.BlowfishAuthenticationController
+ * @author Simon Willnauer
+ * 
+ */
+public interface AuthenticationController extends ServerComponent {
+
+    /**
+     * The header name containing the authentication token provided by the
+     * client
+     */
+    public static final String AUTHORIZATION_HEADER = "Authorization";
+
+    /**
+     * Authentication parameter for the account name. Provided by the client to
+     * recieve the auth token.
+     */
+    public static final String ACCOUNT_PARAMETER = "Email";
+
+    /**
+     * Authentication parameter for the account password. Provided by the client
+     * to recieve the auth token.
+     */
+    public static final String PASSWORD_PARAMETER = "Passwd";
+
+    /**
+     * Authentication parameter for the requested service. Provided by the
+     * client to recieve the auth token.
+     */
+    public static final String SERVICE_PARAMETER = "service";
+
+    /**
+     * Authentication parameter for the application name of the clients
+     * application. This is just used for loggin purposes
+     */
+    public static final String APPLICATION_PARAMETER = "source";
+
+    /**
+     * The key used for respond the auth token to the client. Either as a cookie
+     * (key as cookie name) or as plain response (TOKEN_KEY=TOKEN)
+     */
+    public final static String TOKEN_KEY = "Auth";
+
+    /**
+     * Creates a authentication token for the given account. The token will be
+     * calculated based on a part of the clients ip address, the account role
+     * and the account name and the time in millisecond at the point of
+     * creation.
+     * 
+     * @param account -
+     *            the account to create the token for
+     * @param requestIp -
+     *            the clients request ip address
+     * @return - a BASE64 encoded authentification token
+     */
+    public abstract String authenticatAccount(GDataAccount account,
+            String requestIp);
+
+    /**
+     * Authenticates the given auth token and checks the given parameter for
+     * matching the information contained inside the token.
+     * <p>
+     * if the given account name is <code>null</code> the authentication will
+     * ignore the account name and the decision whether the token is valid or
+     * not will be based on the given role compared to the role inside the token
+     * </p>
+     * 
+     * @param token -
+     *            the token to authenticate
+     * @param requestIp -
+     *            the client request IP address
+     * @param role -
+     *            the required role
+     * @param accountName -
+     *            the name of the account
+     * @return <code>true</code> if the given values match the values inside
+     *         the token and if the timestamp plus the configured timeout is
+     *         greater than the current time, if one of the values does not
+     *         match or the token has timed out it will return
+     *         <code>false</code>
+     */
+    public abstract boolean authenticateToken(final String token,
+            final String requestIp, AccountRole role, String accountName);
+
+}
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/authentication/AuthenticationException.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/authentication/AuthenticationException.java
new file mode 100644
index 0000000..40fa489
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/authentication/AuthenticationException.java
@@ -0,0 +1,71 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.server.authentication;
+
+/**
+ * 
+ * @author Simon Willnauer
+ *
+ */
+public class AuthenticationException extends Exception {
+
+    /**
+     * 
+     */
+    private static final long serialVersionUID = 5467768078178612671L;
+
+    /**
+     * Constructs a new Authentication Exception
+     */
+    public AuthenticationException() {
+        super();
+       
+    }
+
+    /**
+     * Constructs a new Authentication Exception with the specified detail message 
+     * @param arg0 - detail message
+     */
+    public AuthenticationException(String arg0) {
+        super(arg0);
+       
+    }
+
+    /**
+     * Constructs a new Authentication Exception with the specified detail message and
+     * nested exception caused this exception.
+      * @param arg0 -
+     *            detail message
+     * @param arg1 -
+     *            nested exception
+     */
+    public AuthenticationException(String arg0, Throwable arg1) {
+        super(arg0, arg1);
+       
+    }
+
+    /**
+     * Constructs a new Authentication Exception with a nested exception caused this exception
+     * @param arg0 - nested exception
+     */
+    public AuthenticationException(Throwable arg0) {
+        super(arg0);
+       
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/authentication/AuthenticatorException.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/authentication/AuthenticatorException.java
new file mode 100644
index 0000000..ca972bc
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/authentication/AuthenticatorException.java
@@ -0,0 +1,72 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.server.authentication;
+
+/**
+ * This exception will be thrown by
+ * {@link org.apache.lucene.gdata.server.authentication.AuthenticationController}
+ * implementations if an error while de/encrypting the token occures.
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class AuthenticatorException extends RuntimeException {
+
+    private static final long serialVersionUID = -5690495392712564651L;
+
+    /**
+     * Constructs a new Authenticator Exception
+     */ 
+    public AuthenticatorException() {
+        super();
+        
+    }
+
+    /**
+     * Constructs a new Authenticator Exception with the specified detail message.
+     * @param arg0 - detail message
+     */
+    public AuthenticatorException(String arg0) {
+        super(arg0);
+        
+    }
+
+    /**
+     * Constructs a new Authenticator Exception with the specified detail message and
+     * nested exception.
+     * 
+     * @param arg0 -
+     *            detail message
+     * @param arg1 -
+     *            nested exception
+     */
+    public AuthenticatorException(String arg0, Throwable arg1) {
+        super(arg0, arg1);
+        
+    }
+
+    /**
+     * Constructs a new Authenticator Exception with a nested exception caused this exception.
+     * @param arg0 - nested exception
+     */
+    public AuthenticatorException(Throwable arg0) {
+        super(arg0);
+        
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/authentication/BlowfishAuthenticationController.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/authentication/BlowfishAuthenticationController.java
new file mode 100644
index 0000000..8c04ec6
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/authentication/BlowfishAuthenticationController.java
@@ -0,0 +1,277 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.server.authentication;
+
+import java.io.IOException;
+import java.io.UnsupportedEncodingException;
+import java.security.Provider;
+import java.security.Security;
+import java.util.StringTokenizer;
+import java.util.concurrent.locks.ReentrantLock;
+
+import javax.crypto.BadPaddingException;
+import javax.crypto.Cipher;
+import javax.crypto.IllegalBlockSizeException;
+import javax.crypto.KeyGenerator;
+import javax.crypto.spec.SecretKeySpec;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
+import org.apache.lucene.gdata.server.registry.Component;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+import org.apache.lucene.gdata.server.registry.configuration.Requiered;
+
+import sun.misc.BASE64Decoder;
+import sun.misc.BASE64Encoder;
+
+/**
+ * A
+ * {@link org.apache.lucene.gdata.server.authentication.AuthenticationController}
+ * implmentation using a <i>Blowfish</i> algorithmn to en/decrpyt the
+ * authentification token. The <i>Blowfish</i> algorithmn enables a stateless
+ * authetication of the client. The token contains all information to
+ * authenticate the client on possible other hosts.
+ * <p>
+ * The token contains the first 32 bit of the client ip (e.g. 192.168.0),
+ * account name, {@link org.apache.lucene.gdata.data.GDataAccount.AccountRole}
+ * and the cration time as a timestamp. The timestamp will be checked on every
+ * subsequent request. If the timestamp plus the configured timeout is less
+ * than the current time the client has to reauthenticate again.
+ * </p>
+ * <p>
+ * The auth token returned by the
+ * {@link BlowfishAuthenticationController#authenticatAccount(GDataAccount, String)}
+ * method is a BASE64 encoded string.
+ * </p>
+ * 
+ * @see javax.crypto.Cipher
+ * @see sun.misc.BASE64Encoder
+ * @see sun.misc.BASE64Decoder
+ * @author Simon Willnauer
+ * 
+ */
+@Component(componentType = ComponentType.AUTHENTICATIONCONTROLLER)
+public class BlowfishAuthenticationController implements
+        AuthenticationController {
+    private static final Log LOG = LogFactory
+            .getLog(BlowfishAuthenticationController.class);
+
+    private static final String ALG = "Blowfish";
+
+    private static final String TOKEN_LIMITER = "#";
+
+    private static final String ENCODING = "UTF-8";
+
+    private Cipher deCrypt;
+
+    private Cipher enCrypt;
+
+    private int minuteOffset = 30;
+
+    private long milisecondOffset;
+
+    private BASE64Encoder encoder = new BASE64Encoder();
+
+    private BASE64Decoder decoder = new BASE64Decoder();
+
+    private ReentrantLock lock = new ReentrantLock();
+
+    
+    private  String key;
+
+    /**
+     * @see org.apache.lucene.gdata.server.authentication.AuthenticationController#initialize()
+     */
+    public void initialize() {
+        if (this.key == null)
+            throw new IllegalArgumentException("Auth key must not be null");
+        if (this.key.length() < 5 || this.key.length() > 16)
+            throw new IllegalArgumentException(
+                    "Auth key length must be greater than 4 and less than 17");
+
+        try {
+            Provider sunJce = new com.sun.crypto.provider.SunJCE();
+            Security.addProvider(sunJce);
+            KeyGenerator kgen = KeyGenerator.getInstance(ALG);
+            kgen.init(448); // 448 Bit^M
+            byte[] raw = this.key.getBytes();
+            SecretKeySpec skeySpec = new SecretKeySpec(raw, ALG);
+            this.deCrypt = Cipher.getInstance(ALG);
+            this.enCrypt = Cipher.getInstance(ALG);
+            this.deCrypt.init(Cipher.DECRYPT_MODE, skeySpec);
+            this.enCrypt.init(Cipher.ENCRYPT_MODE, skeySpec);
+        } catch (Exception e) {
+            throw new AuthenticatorException(
+                    "Can't initialize BlowfishAuthenticationController -- "
+                            + e.getMessage(), e);
+
+        }
+        calculateTimeOffset();
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.authentication.AuthenticationController#authenticatAccount(org.apache.lucene.gdata.data.GDataAccount,
+     *      java.lang.String)
+     */
+    public String authenticatAccount(GDataAccount account, String requestIp) {
+        try {
+            String passIp = requestIp.substring(0, requestIp.lastIndexOf('.'));
+            String role = Integer.toString(account.getRolesAsInt());
+
+            return calculateAuthToken(passIp, role, account.getName());
+        } catch (Exception e) {
+            throw new AuthenticatorException("Can not authenticat account -- "
+                    + e.getMessage(), e);
+
+        }
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.authentication.AuthenticationController#authenticateToken(java.lang.String,
+     *      java.lang.String,
+     *      org.apache.lucene.gdata.data.GDataAccount.AccountRole,
+     *      java.lang.String)
+     */
+    public boolean authenticateToken(final String token,
+            final String requestIp, AccountRole role, String accountName) {
+        if (LOG.isInfoEnabled())
+            LOG.info("authenticate Token " + token + " for requestIp: "
+                    + requestIp);
+        if (token == null || requestIp == null)
+            return false;
+        String passIp = requestIp.substring(0, requestIp.lastIndexOf('.'));
+        String authString = null;
+        try {
+            authString = deCryptAuthToken(token);
+        } catch (Exception e) {
+            throw new AuthenticatorException("Can not decrypt token -- "
+                    + e.getMessage(), e);
+        }
+        if (authString == null)
+            return false;
+        try {
+            StringTokenizer tokenizer = new StringTokenizer(authString,
+                    TOKEN_LIMITER);
+            if (!tokenizer.nextToken().equals(passIp))
+                return false;
+            String tempAccountName = tokenizer.nextToken();
+            int intRole = Integer.parseInt(tokenizer.nextToken());
+            /*
+             * Authentication goes either for a account role or a account. For
+             * entry manipulation the account name will be retrieved by the
+             * feedId otherwise it will be null If it is null the authentication
+             * goes against the account role
+             */
+            if (tempAccountName == null
+                    || (!tempAccountName.equals(accountName) && !GDataAccount
+                            .isInRole(intRole, role)))
+                return false;
+            long timeout = Long.parseLong(tokenizer.nextToken());
+
+            return (timeout + this.milisecondOffset) > System
+                    .currentTimeMillis();
+        } catch (Exception e) {
+            LOG.error("Error occured while encrypting token " + e.getMessage(),
+                    e);
+            return false;
+        }
+
+    }
+
+    private void calculateTimeOffset() {
+        this.milisecondOffset = this.minuteOffset * 60 * 1000;
+    }
+
+    protected String calculateAuthToken(final String ipAddress,
+            final String role, String accountName)
+            throws IllegalBlockSizeException, BadPaddingException,
+            UnsupportedEncodingException {
+        StringBuilder builder = new StringBuilder();
+        builder.append(ipAddress).append(TOKEN_LIMITER);
+        builder.append(accountName).append(TOKEN_LIMITER);
+        builder.append(role).append(TOKEN_LIMITER);
+        builder.append(System.currentTimeMillis());
+
+        this.lock.lock();
+        try {
+            byte[] toencode = builder.toString().getBytes(ENCODING);
+            byte[] result = this.enCrypt.doFinal(toencode);
+            return this.encoder.encode(result);
+        } finally {
+            this.lock.unlock();
+
+        }
+
+    }
+
+    protected String deCryptAuthToken(final String authToken)
+            throws IOException, IllegalBlockSizeException, BadPaddingException {
+        this.lock.lock();
+        try {
+            byte[] input = this.decoder.decodeBuffer(authToken);
+            byte[] result = this.deCrypt.doFinal(input);
+            return new String(result, ENCODING);
+        } finally {
+            this.lock.unlock();
+        }
+
+    }
+
+    /**
+     * @return Returns the minuteOffset.
+     */
+    @Requiered
+    public int getLoginTimeout() {
+        return this.minuteOffset;
+    }
+
+    /**
+     * @param minuteOffset
+     *            The minuteOffset to set.
+     */
+    @Requiered
+    public void setLoginTimeout(int minuteOffset) {
+        this.minuteOffset = minuteOffset;
+        calculateTimeOffset();
+    }
+
+    /**
+     * @return Returns the key.
+     */
+    public String getKey() {
+        return this.key;
+    }
+
+    /**
+     * @param key
+     *            The key to set.
+     */
+    public void setKey(String key) {
+        this.key = key;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.registry.ServerComponent#destroy()
+     */
+    public void destroy() {
+        //
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/authentication/GDataHttpAuthenticator.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/authentication/GDataHttpAuthenticator.java
new file mode 100644
index 0000000..5062e75
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/authentication/GDataHttpAuthenticator.java
@@ -0,0 +1,60 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.server.authentication;
+
+import javax.servlet.http.HttpServletRequest;
+
+import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
+import org.apache.lucene.gdata.server.GDataRequest;
+
+/**
+ * The GData protocol is based on the widly know REST approach and therefor
+ * client authentication will mostly be provided via a REST interface.
+ * <p>
+ * This interface describes internally used authentication methods to be
+ * implemented by http based authenticator implementations. The GData Server
+ * basically has 2 different REST interfaces need authentication. One is for
+ * altering feed entries and the other for administration actions.
+ * </p>
+ * <p>The interface altering entries work with {@link com.google.gdata.client.Service.GDataRequest} object created by the handler and passed to the {@link org.apache.lucene.gdata.server.Service} instance.
+ * Administration interfaces use the plain {@link javax.servlet.http.HttpServletRequest} inside the handler.
+ * For each type of interface a authentication type a method has to be provided by implementing classes.</p> 
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public interface GDataHttpAuthenticator {
+
+    /**
+     * Authenticates the client request based on the given GdataRequst and required account role
+     * @param request - the gdata request
+     * @param role - the required role for passing the authentication
+     * 
+     * @return <code>true</code> if the request successfully authenticates, otherwise <code>false</code>
+     */
+    public boolean authenticateAccount(final GDataRequest request,
+            AccountRole role);
+
+    /**
+     * Authenticates the client request based on the given requst and required account role
+     * @param request - the client request
+     * @param role - the required role for passing the authentication
+     * @return <code>true</code> if the request successfully authenticates, otherwise <code>false</code>
+     */
+    public boolean authenticateAccount(final HttpServletRequest request,
+            AccountRole role);
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/authentication/package.html b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/authentication/package.html
new file mode 100644
index 0000000..2b5672b
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/authentication/package.html
@@ -0,0 +1,10 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
+<html> 
+<head> 
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
+   <meta name="Author" content="Simon Willnauer"> 
+</head> 
+<body> 
+Classes and Exceptions used for client authentification.
+</body> 
+</html> 
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/package.html b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/package.html
new file mode 100644
index 0000000..6363daf
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/package.html
@@ -0,0 +1,10 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
+<html> 
+<head> 
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
+   <meta name="Author" content="Simon Willnauer"> 
+</head> 
+<body> 
+GData-Server classes encapsulation all protocol-level interactions and underlaying GData components. 
+</body> 
+</html> 
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/Component.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/Component.java
new file mode 100644
index 0000000..4733cdd
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/Component.java
@@ -0,0 +1,75 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.server.registry;
+
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+/**
+ * The {@link Component} annotation is used to annotate a class as a
+ * server-component of the GDATA-Server. Annotated class can be configured via
+ * the gdata-config.xml file to be looked up by aribaty classes at runtime via
+ * the
+ * {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry#lookup(Class, ComponentType)}
+ * method.
+ * <p>
+ * Classes annotated with the Component annotation need to provide a default
+ * constructor to be instanciated via reflection. Components of the GData-Server
+ * are definded in the
+ * {@link org.apache.lucene.gdata.server.registry.ComponentType} enumeration.
+ * Each of the enum types are annotated with a
+ * {@link org.apache.lucene.gdata.server.registry.SuperType} annotation. This
+ * annotation specifies the super class or interface of the component. A class
+ * annotated with the Component annotation must implement or extends this
+ * defined super-type. This enables developers to use custom implemetations of
+ * the component like a custom {@link org.apache.lucene.gdata.storage.Storage}.
+ * </p>
+ * <p>
+ * Each ComponentType can only registerd once as the
+ * {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry} does not
+ * provide multipe instances of a ComponentType.
+ * </p>
+ * <p>
+ * This annotation can only annotate types and can be accessed at runtime.
+ * {@link java.lang.annotation.Target} ==
+ * {@link java.lang.annotation.ElementType#TYPE} and
+ * {@link java.lang.annotation.Retention} ==
+ * {@link java.lang.annotation.RetentionPolicy#RUNTIME}.
+ * 
+ * @see org.apache.lucene.gdata.server.registry.GDataServerRegistry
+ * @see org.apache.lucene.gdata.server.registry.ComponentType
+ * @see org.apache.lucene.gdata.server.registry.SuperType
+ * 
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+@Target( { TYPE })
+@Retention(value = RUNTIME)
+public @interface Component {
+
+    /**
+     * @see ComponentType
+     * @return - the component type
+     */
+    ComponentType componentType();
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/ComponentType.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/ComponentType.java
new file mode 100644
index 0000000..29d3698
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/ComponentType.java
@@ -0,0 +1,53 @@
+package org.apache.lucene.gdata.server.registry;
+
+import org.apache.lucene.gdata.search.SearchComponent;
+import org.apache.lucene.gdata.server.ServiceFactory;
+import org.apache.lucene.gdata.server.authentication.AuthenticationController;
+import org.apache.lucene.gdata.servlet.handler.RequestHandlerFactory;
+import org.apache.lucene.gdata.storage.StorageController;
+
+/**
+ * The enumeration {@link ComponentType} defines the GDATA-Server Components 
+ * available via {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry#lookup(Class, ComponentType)} 
+ * method.
+ * @see org.apache.lucene.gdata.server.registry.Component
+ * @see org.apache.lucene.gdata.server.registry.GDataServerRegistry 
+ * @author Simon Willnauer
+ *
+ */
+public enum ComponentType {
+    /**
+     * StorageController Type
+     * 
+     * @see StorageController
+     */
+    @SuperType(superType = StorageController.class)
+    STORAGECONTROLLER,
+    /**
+     * RequestHandlerFactory Type
+     * 
+     * @see RequestHandlerFactory
+     */
+    @SuperType(superType = RequestHandlerFactory.class)
+    REQUESTHANDLERFACTORY,
+    /**
+     * SearchComponent Type
+     * @see SearchComponent
+     */
+    @SuperType(superType = SearchComponent.class)
+    SEARCHCONTROLLER,
+    /**
+     * ServiceFactory Type
+     * 
+     * @see ServiceFactory
+     */
+    @SuperType(superType = ServiceFactory.class)
+    SERVICEFACTORY,
+    /**
+     * Super type for AuthenticationController implementations
+     * @see AuthenticationController
+     */
+    @SuperType(superType = AuthenticationController.class)
+    AUTHENTICATIONCONTROLLER
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/DataBuilderException.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/DataBuilderException.java
new file mode 100644
index 0000000..e69de29
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/EntryEventListener.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/EntryEventListener.java
new file mode 100755
index 0000000..36e283e
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/EntryEventListener.java
@@ -0,0 +1,56 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.server.registry;
+
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.data.ServerBaseFeed;
+
+/**
+ * The EntryEventListener interface should be implemented by any class needs to be informed about any changes on entries.
+ * To register a class as a EntryEventListener use:
+ * <p>
+ * <tt>
+ * GdataServerRegistry.registerEntryEventListener(EntryEventListener);
+ * <tt>
+ * </p>
+ * @author Simon Willnauer
+ *
+ */
+public interface EntryEventListener {
+    /**
+     * will be invoked on every successful update on every entry
+     * @param entry the updated entry
+     */
+    public abstract void fireUpdateEvent(ServerBaseEntry entry);
+    /**
+     * will be invoked on every successful entry insert
+     * @param entry
+     */
+    public abstract void fireInsertEvent(ServerBaseEntry entry);
+    /**
+     * will be invoked on every successful entry delete
+     * @param entry
+     */
+    public abstract void fireDeleteEvent(ServerBaseEntry entry);
+    
+    /**
+     * will be invoked on every successful feed delete
+     * @param feed - the feed containing the feed id to delete all entries for
+     */
+    public abstract void fireDeleteAllEntries(ServerBaseFeed feed);
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/EntryEventMediator.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/EntryEventMediator.java
new file mode 100755
index 0000000..27d7d76
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/EntryEventMediator.java
@@ -0,0 +1,105 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.server.registry;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.data.ServerBaseFeed;
+
+/**
+ * This class will be informed about every successful entry event and
+ * distributes all event to all registered
+ * {@link org.apache.lucene.gdata.server.registry.EntryEventListener}
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public abstract class EntryEventMediator {
+
+    private final List<EntryEventListener> entryEventListener = new ArrayList<EntryEventListener>(
+            5);
+
+    /**
+     * @return - a entry event mediator instance
+     */
+    public abstract EntryEventMediator getEntryEventMediator();
+
+    /**
+     * Registers a {@link EntryEventListener}. This listener will be fired if an
+     * entry update, insert or delete occurs
+     * 
+     * @param listener -
+     *            listener to register
+     */
+    public void registerEntryEventListener(final EntryEventListener listener) {
+        if (listener == null || this.entryEventListener.contains(listener))
+            return;
+        this.entryEventListener.add(listener);
+    }
+
+    /**
+     * @param entry -
+     *            the updated entry
+     */
+    public void entryUpdated(final ServerBaseEntry entry) {
+        for (EntryEventListener listener : this.entryEventListener) {
+            listener.fireUpdateEvent(entry);
+        }
+    }
+
+    /**
+     * @param entry -
+     *            the added entry
+     */
+    public void entryAdded(final ServerBaseEntry entry) {
+        for (EntryEventListener listener : this.entryEventListener) {
+            listener.fireInsertEvent(entry);
+        }
+    }
+    
+    /**
+     * @param feed - the feed to delete all entries for
+     */
+    public void allEntriesDeleted(final ServerBaseFeed feed){
+        for (EntryEventListener listener : this.entryEventListener) {
+            listener.fireDeleteAllEntries(feed);
+        }
+    }
+
+    /**
+     * @param entry -
+     *            the deleted entry
+     */
+    public void entryDeleted(final ServerBaseEntry entry) {
+        for (EntryEventListener listener : this.entryEventListener) {
+            listener.fireDeleteEvent(entry);
+        }
+    }
+    
+    /**
+     * checks if the listener is already registered.
+     * @param listner - the listener to check
+     * @return <code>true</code> if and only if the given listener is already registered, otherwise <code>false</code>.
+     */
+    public boolean isListenerRegistered(final EntryEventListener listner){
+        return listner!=null&&this.entryEventListener.contains(listner);
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/FeedInstanceConfigurator.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/FeedInstanceConfigurator.java
new file mode 100644
index 0000000..e69de29
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/GDataRequestListener.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/GDataRequestListener.java
new file mode 100755
index 0000000..661b7b9
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/GDataRequestListener.java
@@ -0,0 +1,92 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.server.registry;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import javax.servlet.ServletRequestEvent;
+import javax.servlet.ServletRequestListener;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.server.registry.Scope.ScopeType;
+
+/**
+ * This <tt>ServletRequestListener</tt> is used by the registry to notify
+ * registered {@link org.apache.lucene.gdata.server.registry.ScopeVisitor}
+ * implementations when a request is initialized e.g destroyed.
+ * 
+ * 
+ * @see org.apache.lucene.gdata.server.registry.ScopeVisitable
+ * @see javax.servlet.ServletRequestListener
+ * @author Simon Willnauer
+ * 
+ */
+@Scope(scope = ScopeType.REQUEST)
+public class GDataRequestListener implements ServletRequestListener,
+        ScopeVisitable {
+    private final GDataServerRegistry registry;
+
+    private final List<ScopeVisitor> visitors = new ArrayList<ScopeVisitor>(5);
+
+    private static final Log LOG = LogFactory
+            .getLog(GDataRequestListener.class);
+
+    /**
+     * @throws RegistryException
+     * 
+     */
+    public GDataRequestListener() throws RegistryException {
+        this.registry = GDataServerRegistry.getRegistry();
+        this.registry.registerScopeVisitable(this);
+
+    }
+
+    /**
+     * @see javax.servlet.ServletRequestListener#requestDestroyed(javax.servlet.ServletRequestEvent)
+     */
+    public void requestDestroyed(ServletRequestEvent arg0) {
+        for (ScopeVisitor visitor : this.visitors) {
+            visitor.visiteDestroy();
+        }
+
+    }
+
+    /**
+     * @see javax.servlet.ServletRequestListener#requestInitialized(javax.servlet.ServletRequestEvent)
+     */
+    public void requestInitialized(ServletRequestEvent arg0) {
+        for (ScopeVisitor visitor : this.visitors) {
+            visitor.visiteInitialize();
+        }
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.registry.ScopeVisitable#accept(org.apache.lucene.gdata.server.registry.ScopeVisitor)
+     */
+    public void accept(ScopeVisitor visitor) {
+
+        if (!this.visitors.contains(visitor) && visitor != null) {
+            this.visitors.add(visitor);
+            if(LOG.isDebugEnabled())
+                LOG.debug("visitor added -- " + visitor.getClass());
+        }
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/GDataServerRegistry.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/GDataServerRegistry.java
new file mode 100644
index 0000000..0059347
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/GDataServerRegistry.java
@@ -0,0 +1,378 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.server.registry;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.server.registry.configuration.ComponentConfiguration;
+import org.apache.lucene.gdata.server.registry.configuration.PropertyInjector;
+import org.apache.lucene.gdata.utils.ReflectionUtils;
+
+/**
+ * 
+ * The GDataServerRegistry represents the registry component of the GData
+ * Server. All provided services and server components will be registered here.
+ * The GData Server serves RSS / ATOM feeds for defined services. Each service
+ * provides <i>n</i> feeds of a defined subclass of
+ * {@link com.google.gdata.data.BaseFeed}. Each feed contains <i>m</i> entries
+ * of a defined subclass of {@link com.google.gdata.data.BaseEntry}. To
+ * generate RSS / ATOM formates a class of the type
+ * {@link com.google.gdata.data.ExtensionProfile} is also defined for a service.
+ * <p>
+ * The entry,feed and the ExtensionProfile classes are defined in the
+ * gdata-config.xml and will be loaded when the server starts up.
+ * </p>
+ * <p>
+ * The components defined in the gdata-config.xml will also be loaded and
+ * instantiated at startup. If a component can not be loaded or an Exception
+ * occurs the server will not start up. To cause of the exception or error will
+ * be logged to the standard server output.
+ * </p>
+ * <p>
+ * The GDataServerRegistry is a Singleton
+ * </p>
+ * 
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class GDataServerRegistry extends EntryEventMediator{
+    private static GDataServerRegistry INSTANCE;
+
+    private static final Log LOG = LogFactory
+            .getLog(GDataServerRegistry.class);
+
+    private ScopeVisitable requestVisitable;
+
+    private ScopeVisitable sessionVisitable;
+
+    // not available yet
+    private ScopeVisitable contextVisitable;
+
+    private List<ScopeVisitor> visitorBuffer = new ArrayList<ScopeVisitor>(5);
+
+    private final Map<String, ProvidedService> serviceTypeMap = new HashMap<String, ProvidedService>();
+
+    private final Map<ComponentType, ComponentBean> componentMap = new HashMap<ComponentType, ComponentBean>(
+            ComponentType.values().length);
+
+    private GDataServerRegistry() {
+        // private - singleton
+    }
+
+    /**
+     * @return a Singleton registry instance
+     */
+    public static synchronized GDataServerRegistry getRegistry() {
+        if (INSTANCE == null)
+            INSTANCE = new GDataServerRegistry();
+        return INSTANCE;
+    }
+
+    /**
+     * Registers a {@link ProvidedService}
+     * 
+     * @param configurator -
+     *            the configurator to register in the registry
+     */
+    public void registerService(ProvidedService configurator) {
+        if (configurator == null) {
+            LOG.warn("Feed configurator is null -- skip registration");
+            return;
+        }
+        this.serviceTypeMap.put(configurator.getName(), configurator);
+    }
+
+    /**
+     * @param visitor -
+     *            the visitor to register
+     * @throws RegistryException
+     */
+    public synchronized void registerScopeVisitor(final ScopeVisitor visitor)
+            throws RegistryException {
+        if (visitor == null)
+            throw new IllegalArgumentException("visitor must not be null");
+        Scope scope = visitor.getClass().getAnnotation(Scope.class);
+        if (scope == null)
+            throw new RegistryException("Visitor has not Scope");
+        if (LOG.isInfoEnabled())
+            LOG.info("Register scope visitor -- " + visitor.getClass());
+        if (scope.scope().equals(Scope.ScopeType.REQUEST)
+                && this.requestVisitable != null)
+            this.requestVisitable.accept(visitor);
+        else if (scope.scope() == Scope.ScopeType.SESSION
+                && this.sessionVisitable != null)
+            this.sessionVisitable.accept(visitor);
+        else if (scope.scope() == Scope.ScopeType.CONTEXT
+                && this.contextVisitable != null)
+            this.sessionVisitable.accept(visitor);
+        else if (!this.visitorBuffer.contains(visitor))
+            this.visitorBuffer.add(visitor);
+    }
+
+    /**
+     * @param visitable -
+     *            the instance to register
+     * @throws RegistryException
+     * @see ScopeVisitable
+     */
+    public synchronized void registerScopeVisitable(
+            final ScopeVisitable visitable) throws RegistryException {
+        if (visitable == null)
+            throw new IllegalArgumentException("visitable must not be null");
+
+        Scope scope = visitable.getClass().getAnnotation(Scope.class);
+        if (scope == null)
+            throw new RegistryException("Visitable has not Scope");
+        if (LOG.isInfoEnabled())
+            LOG.info("Register scope visitable -- " + visitable.getClass());
+        if (scope.scope() == Scope.ScopeType.REQUEST
+                && this.requestVisitable == null)
+            this.requestVisitable = visitable;
+        else if (scope.scope() == Scope.ScopeType.SESSION
+                && this.sessionVisitable == null)
+            this.sessionVisitable = visitable;
+        else if (scope.scope() == Scope.ScopeType.CONTEXT
+                && this.contextVisitable == null)
+            this.sessionVisitable = visitable;
+
+        if (!this.visitorBuffer.isEmpty()) {
+
+            List<ScopeVisitor> tempList = this.visitorBuffer;
+            this.visitorBuffer = new ArrayList<ScopeVisitor>(5);
+            for (ScopeVisitor visitor : tempList) {
+                registerScopeVisitor(visitor);
+            }
+            tempList.clear();
+
+        }
+
+    }
+
+    /**
+     * Looks up the {@link ProvidedServiceConfig} by the given service name.
+     * 
+     * @param service
+     * @return - the {@link ProvidedServiceConfig} or <code>null</code> if the
+     *         no configuration for this service has been registered
+     */
+    public ProvidedService getProvidedService(String service) {
+        if (service == null)
+            throw new IllegalArgumentException(
+                    "Service is null - must not be null to get registered feed type");
+        return this.serviceTypeMap.get(service);
+    }
+
+    protected void flushRegistry() {
+        Collection<ProvidedService> services = this.serviceTypeMap.values();
+        for (ProvidedService service : services) {
+            service.destroy();
+        }
+        this.serviceTypeMap.clear();
+        this.componentMap.clear();
+    }
+
+    /**
+     * @param service -
+     *            the name of the service
+     * @return - <code>true</code> if and only if the service is registered,
+     *         otherwise <code>false</code>.
+     */
+    public boolean isServiceRegistered(String service) {
+        return this.serviceTypeMap.containsKey(service);
+
+    }
+
+    /**
+     * Destroys the registry and release all resources
+     */
+    public void destroy() {
+        for (ComponentBean component : this.componentMap.values()) {
+            component.getObject().destroy();
+        }
+
+        flushRegistry();
+
+    }
+
+    /**
+     * This method is the main interface to the Component Lookup Service of the
+     * registry. Every GDATA - Server component like STORAGE or the INDEXER
+     * component will be accessible via this method. To get a Component from the
+     * lookup service specify the expected Class as an argument and the
+     * component type of the component to return. For a lookup of the
+     * STORAGECONTORLER the code looks like:
+     * <p>
+     * <code> registryInstance.lookup(StorageController.class,ComponentType.STORAGECONTROLLER);</code>
+     * </p>
+     * 
+     * @param <R>
+     *            the type of the expected return value
+     * @param clazz -
+     *            Class object of the expected return value
+     * @param compType -
+     *            The component type
+     * @return the registered component or <code>null</code> if the component
+     *         can not looked up.
+     */
+    @SuppressWarnings("unchecked")
+    public <R> R lookup(Class<R> clazz, ComponentType compType) {
+        ComponentBean bean = this.componentMap.get(compType);
+        if (bean == null)
+            return null;
+        if (bean.getSuperType().equals(clazz))
+            return (R) bean.getObject();
+        return null;
+    }
+
+    /**
+     * All registered {@link ServerComponent} registered via this method are
+     * available via the
+     * {@link GDataServerRegistry#lookup(Class, ComponentType)} method. For each
+     * {@link ComponentType} there will be one single instance registered in the
+     * registry.
+     * <p>
+     * Eventually this method invokes the initialize method of the
+     * ServerComponent interface to prepare the component to be available via
+     * the lookup service
+     * </p>
+     * 
+     * @param <E> -
+     *            The interface of the component to register
+     * @param componentClass -
+     *            a implementation of a ServerComponent interface to register in
+     *            the registry
+     * @param configuration -
+     *            the component configuration {@link ComponentConfiguration}
+     * @throws RegistryException -
+     *             if the provided class does not implement the
+     *             {@link ServerComponent} interface, if the mandatory
+     *             annotations not visible at runtime or not set, if the super
+     *             type provided by the {@link ComponentType} for the class to
+     *             register is not a super type of the class or if the
+     *             invocation of the {@link ServerComponent#initialize()} method
+     *             throws an exception.
+     */
+    @SuppressWarnings("unchecked")
+    public <E extends ServerComponent> void registerComponent(
+            final Class<E> componentClass,
+            final ComponentConfiguration configuration)
+            throws RegistryException {
+
+        if (componentClass == null)
+            throw new IllegalArgumentException(
+                    "component class must not be null");
+
+        if (!ReflectionUtils.implementsType(componentClass,
+                ServerComponent.class))
+            throw new RegistryException(
+                    "can not register component. the given class does not implement ServerComponent interface -- "
+                            + componentClass.getName());
+        try {
+
+            Component annotation = componentClass
+                    .getAnnotation(Component.class);
+            if (annotation == null)
+                throw new RegistryException(
+                        "can not register component. the given class is not a component -- "
+                                + componentClass.getName());
+            ComponentType type = annotation.componentType();
+            if (this.componentMap.containsKey(type))
+                throw new RegistryException("component already registered -- "
+                        + type.name());
+            Class superType = type.getClass().getField(type.name())
+                    .getAnnotation(SuperType.class).superType();
+            if (!ReflectionUtils.isTypeOf(componentClass, superType))
+                throw new RegistryException("Considered super type <"
+                        + superType.getName() + "> is not a super type of <"
+                        + componentClass + ">");
+            ServerComponent comp = componentClass.newInstance();
+            if (configuration == null) {
+                if (LOG.isInfoEnabled())
+                    LOG.info("no configuration for ComponentType: "
+                            + type.name());
+            } else
+                configureComponent(comp, type, configuration);
+            comp.initialize();
+            ComponentBean bean = new ComponentBean(comp, superType);
+
+            this.componentMap.put(type, bean);
+            if (ReflectionUtils.implementsType(componentClass,
+                    ScopeVisitor.class))
+                this.registerScopeVisitor((ScopeVisitor) comp);
+        } catch (Exception e) {
+            throw new RegistryException("Can not register component -- "
+                    + e.getMessage(), e);
+        }
+
+    }
+
+    /*
+     * Injects the configured properties located in the configuration into the
+     * given server component
+     */
+    private void configureComponent(final ServerComponent component,
+            final ComponentType type, final ComponentConfiguration configuration) {
+        PropertyInjector injector = new PropertyInjector();
+        injector.setTargetObject(component);
+        injector.injectProperties(configuration);
+    }
+
+    private static class ComponentBean {
+        private final Class superType;
+
+        private final ServerComponent object;
+
+        ComponentBean(final ServerComponent object, final Class superType) {
+            this.superType = superType;
+            this.object = object;
+        }
+
+        ServerComponent getObject() {
+            return this.object;
+        }
+
+        Class getSuperType() {
+            return this.superType;
+        }
+
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.registry.EntryEventMediator#getEntryEventMediator()
+     */
+    @Override
+    public EntryEventMediator getEntryEventMediator() {
+        
+        return this;
+    }
+
+    /**
+     * @return - all registered services
+     */
+    public Collection<ProvidedService> getServices() {
+        
+        return this.serviceTypeMap.values();
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/ProvidedService.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/ProvidedService.java
new file mode 100644
index 0000000..2d51f67
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/ProvidedService.java
@@ -0,0 +1,65 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */ 
+package org.apache.lucene.gdata.server.registry;
+
+import javax.xml.transform.Templates;
+
+import org.apache.lucene.gdata.search.config.IndexSchema;
+
+import com.google.gdata.data.ExtensionProfile;
+
+/**
+ * This interface describes a service provided by the GData-Server.
+ * @see org.apache.lucene.gdata.server.registry.GDataServerRegistry 
+ * @author Simon Willnauer
+ *
+ */
+public interface ProvidedService {
+
+    /** 
+     * @return Returns the feedType. 
+     */
+    public abstract Class getFeedType();
+
+    /** 
+     * @return - the extension profile for this feed 
+     */
+    public abstract ExtensionProfile getExtensionProfile();
+
+    /**
+     * @return the entry Type configured for this Service
+     */
+    public abstract Class getEntryType();
+
+    /**
+     * @return - the service name
+     */
+    public abstract String getName();
+
+    /**
+     * releases all dependencies and resources
+     */
+    public abstract void destroy();
+    /**
+     * @return the index schema configuration for this service
+     */
+    public abstract IndexSchema getIndexSchema();
+    /**
+     * @return the compiled xslt stylesheet to transform the feed / entry for preview
+     */
+    public abstract Templates getTransformTemplate();
+    
+}
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/ProvidedServiceConfig.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/ProvidedServiceConfig.java
new file mode 100644
index 0000000..95f3f29
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/ProvidedServiceConfig.java
@@ -0,0 +1,364 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.server.registry;
+
+import java.lang.reflect.Constructor;
+
+import javax.xml.transform.Templates;
+import javax.xml.transform.TransformerConfigurationException;
+import javax.xml.transform.TransformerFactory;
+import javax.xml.transform.stream.StreamSource;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.search.config.IndexSchema;
+import org.apache.lucene.gdata.utils.Pool;
+import org.apache.lucene.gdata.utils.PoolObjectFactory;
+import org.apache.lucene.gdata.utils.SimpleObjectPool;
+
+import com.google.gdata.data.BaseEntry;
+import com.google.gdata.data.BaseFeed;
+import com.google.gdata.data.ExtensionProfile;
+
+/**
+ * Standard implementation of
+ * {@link org.apache.lucene.gdata.server.registry.ProvidedService} to be used
+ * inside the
+ * {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry}
+ * <p>
+ * ExtensionProfiles are used to generate and parse xml by the gdata api. For
+ * that case all methods are synchronized. This will slow down the application
+ * when performing lots of xml generation concurrently. For that case the
+ * extensionProfile for a specific service will be pooled and reused.
+ * </p>
+ * 
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+@Scope(scope = Scope.ScopeType.REQUEST)
+public class ProvidedServiceConfig implements ProvidedService, ScopeVisitor {
+    private final static Log LOG = LogFactory
+            .getLog(ProvidedServiceConfig.class);
+
+    private static final int DEFAULT_POOL_SIZE = 5;
+    private IndexSchema indexSchema;
+    /*
+     * To ensure a extension profile instance will not be shared within multiple
+     * threads each thread requesting a config will have one instance for the
+     * entire request.
+     */
+    protected final ThreadLocal<ExtensionProfile> extProfThreadLocal = new ThreadLocal<ExtensionProfile>();
+
+    /*
+     * ExtensionProfiles are used to generate and parse xml by the gdata api.
+     * For that case all methodes are synchronized. This will slow down the
+     * application when performing lots of xml generation concurrently. for that
+     * case the extensionProfile for a specific service will be pooled and
+     * reused.
+     */
+    private Pool<ExtensionProfile> profilPool;
+
+    private String serviceName;
+
+    private Class<? extends BaseEntry> entryType;
+
+    private Class<? extends BaseFeed> feedType;
+
+    private ExtensionProfile extensionProfile;
+
+    private int poolSize = DEFAULT_POOL_SIZE;
+    
+    private Templates transformerTemplate;
+    
+
+    /**
+     * @return Returns the poolSize.
+     */
+    public int getPoolSize() {
+        return this.poolSize;
+    }
+
+    /**
+     * @param poolSize
+     *            The poolSize to set.
+     */
+    public void setPoolSize(int poolSize) {
+        
+        this.poolSize = poolSize >= DEFAULT_POOL_SIZE ? poolSize
+                : DEFAULT_POOL_SIZE;
+    }
+
+    /**
+     * Default constructor to instantiate via reflection
+     */
+    public ProvidedServiceConfig() {
+        try {
+            GDataServerRegistry.getRegistry().registerScopeVisitor(this);
+        } catch (RegistryException e) {
+            throw new RuntimeException("Can not register ScopeVisitor -- "
+                    + e.getMessage(), e);
+        }
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.registry.ProvidedService#getFeedType()
+     */
+    public Class getFeedType() {
+        return this.feedType;
+    }
+
+    /**
+     * @param feedType
+     *            The feedType to set.
+     */
+    public void setFeedType(Class feedType) {
+        this.feedType = feedType;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.registry.ProvidedService#getExtensionProfile()
+     */
+    public ExtensionProfile getExtensionProfile() {
+        ExtensionProfile ext = this.extProfThreadLocal.get();
+        if (ext != null) {
+            return ext;
+        }
+        if(this.extensionProfile == null)
+            return null;
+        if (this.profilPool == null)
+            createProfilePool();
+        ext = this.profilPool.aquire();
+        this.extProfThreadLocal.set(ext);
+        return ext;
+    }
+
+    /**
+     * @param extensionProfil -
+     *            the extension profile for this feed configuration
+     */
+    @SuppressWarnings("unchecked")
+    public void setExtensionProfile(ExtensionProfile extensionProfil) {
+        if (extensionProfil == null)
+            throw new IllegalArgumentException(
+                    "ExtensionProfile  must not be null");
+        if (this.extensionProfile != null)
+            return;
+        this.extensionProfile = extensionProfil;
+
+    }
+
+    private void createProfilePool() {
+        if (LOG.isInfoEnabled())
+            LOG.info("Create ExtensionProfile pool with pool size:"
+                    + this.poolSize + " for service " + this.serviceName);
+        this.profilPool = new SimpleObjectPool<ExtensionProfile>(this.poolSize,
+                new ExtensionProfileFactory<ExtensionProfile>(
+                        this.extensionProfile.getClass(),this.entryType,this.feedType));
+    }
+
+    /**
+     * TODO add comment
+     * 
+     * @param <E>
+     * @param extensionProfileClass
+     * @throws InstantiationException
+     * @throws IllegalAccessException
+     */
+    public <E extends ExtensionProfile> void setExtensionProfileClass(
+            Class<E> extensionProfileClass) throws InstantiationException,
+            IllegalAccessException {
+        if (extensionProfileClass == null)
+            throw new IllegalArgumentException(
+                    "ExtensionProfile class must not be null");
+
+        setExtensionProfile(extensionProfileClass.newInstance());
+
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.registry.ProvidedService#getEntryType()
+     */
+    public Class getEntryType() {
+        return this.entryType;
+    }
+
+    /**
+     * @param entryType
+     */
+    public void setEntryType(Class entryType) {
+        this.entryType = entryType;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.registry.ProvidedService#getName()
+     */
+    public String getName() {
+        return this.serviceName;
+    }
+
+    /**
+     * @param serviceName
+     */
+    public void setName(String serviceName) {
+        this.serviceName = serviceName;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.registry.ProvidedService#destroy()
+     */
+    public void destroy() {
+        if (this.profilPool != null)
+            this.profilPool.destroy();
+        if (LOG.isInfoEnabled())
+            LOG.info("Destroy Service " + this.serviceName
+                    + " -- release all resources");
+        this.feedType = null;
+        this.entryType = null;
+        this.extensionProfile = null;
+    }
+
+    private static class ExtensionProfileFactory<Type extends ExtensionProfile>
+            implements PoolObjectFactory<Type> {
+        private final Class<? extends ExtensionProfile> clazz;
+
+        private final Constructor<? extends ExtensionProfile> constructor;
+
+        private static final Object[] constArray = new Object[0];
+        
+        private BaseEntry entry;
+        private BaseFeed feed;
+
+        ExtensionProfileFactory(Class<? extends ExtensionProfile> clazz, Class<? extends BaseEntry> entryClass, Class<? extends BaseFeed> feedClass) {
+            this.clazz = clazz;
+            try {
+                this.constructor = clazz.getConstructor(new Class[0]);
+                this.entry = entryClass.newInstance();
+                this.feed = feedClass.newInstance();
+            } catch (Exception e) {
+                throw new IllegalArgumentException(
+                        "The given class has no default constructor -- can not use as a ExtensionProfile -- "
+                                + this.clazz.getName(), e);
+            }
+        }
+
+        /**
+         * @see org.apache.lucene.gdata.utils.PoolObjectFactory#getInstance()
+         */
+        @SuppressWarnings("unchecked")
+        public Type getInstance() {
+
+            try {
+                Type retValue = (Type) this.constructor.newInstance(constArray);
+                this.entry.declareExtensions(retValue);
+                this.feed.declareExtensions(retValue);
+                return retValue; 
+            } catch (Exception e) {
+                throw new RuntimeException(
+                        "Can not instantiate new ExtensionProfile -- ", e);
+
+            }
+        }
+
+        /**
+         * @param type -
+         *            the ExtensionProfile to destroy
+         * @see org.apache.lucene.gdata.utils.PoolObjectFactory#destroyInstance(Object)
+         */
+        public void destroyInstance(Type type) {
+            //
+        }
+
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.registry.ScopeVisitor#visiteInitialize()
+     */
+    public void visiteInitialize() {
+        if(this.profilPool == null)
+            createProfilePool();
+        /*
+         * don't set a extension profile for each thread. The current thread
+         * might use another service and does not need the extension profile of
+         * this service
+         */
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.registry.ScopeVisitor#visiteDestroy()
+     */
+    public void visiteDestroy() {
+        /*
+         * Check every thread after request destroyed to release all profiles to
+         * the pool
+         */
+        ExtensionProfile ext = this.extProfThreadLocal.get();
+        if (ext == null) {
+            if(LOG.isDebugEnabled())
+            LOG.debug("ThreadLocal owns no ExtensionProfile in requestDestroy for service "
+                            + this.serviceName);
+            return;
+        }
+        this.extProfThreadLocal.set(null);
+        this.profilPool.release(ext);
+    }
+
+    /**
+     * @return Returns the indexSchema.
+     */
+    public IndexSchema getIndexSchema() {
+        return this.indexSchema;
+    }
+
+    /**
+     * @param indexSchema The indexSchema to set.
+     */
+    public void setIndexSchema(IndexSchema indexSchema) {
+        this.indexSchema = indexSchema;
+        if(this.indexSchema != null)
+            this.indexSchema.setName(this.serviceName);
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.registry.ProvidedService#getTransformTemplate()
+     */
+    public Templates getTransformTemplate() {
+        
+        return this.transformerTemplate;
+    }
+    
+    /**
+     * Sets and creates the preview transformer xslt template to provide a html formate for feeds and entries.
+     * The given file name must be available in the classpath. 
+     * @param filename - the name of the file in the classpath
+     */
+    public void setXsltStylesheet(String filename){
+        if(filename == null || filename.length() == 0){
+            LOG.info("No preview stylesheet configured for service "+this.serviceName);
+            return;
+        }
+        
+        TransformerFactory factory = TransformerFactory.newInstance();
+        
+        try {
+            this.transformerTemplate = factory.newTemplates(new StreamSource(ProvidedServiceConfig.class.getResourceAsStream(filename.startsWith("/")?filename:"/"+filename)));
+        } catch (TransformerConfigurationException e) {
+            throw new RuntimeException("Can not compile xslt stylesheet path: "+filename,e);
+        }
+        
+    }
+    
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/RegistryBuilder.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/RegistryBuilder.java
new file mode 100644
index 0000000..146131c
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/RegistryBuilder.java
@@ -0,0 +1,154 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.server.registry;
+
+import java.io.IOException;
+
+import org.apache.commons.digester.Digester;
+import org.apache.lucene.gdata.search.config.IndexSchema;
+import org.apache.lucene.gdata.search.config.IndexSchemaField;
+import org.apache.lucene.gdata.server.registry.configuration.ComponentConfiguration;
+import org.apache.lucene.gdata.utils.SimpleSaxErrorHandler;
+import org.apache.xerces.parsers.SAXParser;
+import org.xml.sax.SAXException;
+
+/**
+ * Reads the configuration file and creates the
+ * {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry} singleton
+ * instance. All services and components will be instantiated and registered in
+ * the registry.
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+class RegistryBuilder {
+
+    /**
+     * builds the {@link GDataServerRegistry} accessible via the
+     * {@link GDataServerRegistry#getRegistry()} method
+     * 
+     * @throws IOException -
+     *             if an IOException occurs while reading the config file
+     * @throws SAXException -
+     *             if the config file can not be parsed
+     */
+    static void buildRegistry() throws IOException, SAXException {
+        String schemaFile = RegistryBuilder.class.getResource("/gdata-config.xsd").getFile();
+        /*
+         * Force using apache xerces parser for digester
+         */
+        SAXParser parser = new SAXParser();
+        parser.setFeature("http://apache.org/xml/features/validation/schema-full-checking",true);
+        parser.setFeature("http://apache.org/xml/features/validation/schema",true);
+        parser.setFeature("http://xml.org/sax/features/validation",true); 
+        parser.setProperty("http://apache.org/xml/properties/schema/external-noNamespaceSchemaLocation",schemaFile);
+        Digester digester = new Digester(parser);
+        buildFromConfiguration(digester, GDataServerRegistry
+                .getRegistry(),schemaFile);
+
+    }
+
+    private static void buildFromConfiguration(Digester digester,
+            GDataServerRegistry registry, String schemaURL) throws IOException, SAXException {
+        digester.setValidating(true);
+        digester.setSchema(schemaURL);
+        digester.setErrorHandler(new SimpleSaxErrorHandler());
+        digester.push(registry);
+        /*
+         * register services
+         */
+        digester.addObjectCreate("gdata/service", ProvidedServiceConfig.class);
+        digester.addSetProperties("gdata/service");
+        digester.addSetNext("gdata/service", "registerService");
+        digester.addBeanPropertySetter("gdata/service/feed-class", "feedType");
+        digester.addBeanPropertySetter("gdata/service/entry-class", "entryType");
+        digester.addBeanPropertySetter("gdata/service/extension-profile",
+                "extensionProfileClass");
+        digester.addBeanPropertySetter("gdata/service/previewStyleSheet","xsltStylesheet");
+        addIndexRule(digester);
+        /*
+         * load components and configurations
+         */
+        digester.addCallMethod("gdata/server-components/component",
+                "registerComponent", 2, new Class[] { Class.class , ComponentConfiguration.class});
+        digester.addCallParam("gdata/server-components/component/class",0);
+            digester.addObjectCreate("gdata/server-components/component/configuration",ComponentConfiguration.class);
+            digester.addCallMethod("gdata/server-components/component/configuration/property","set",2,new Class[]{String.class,String.class});
+            digester.addCallParam("gdata/server-components/component/configuration/property",0,"name");
+            digester.addCallParam("gdata/server-components/component/configuration/property",1);
+        //second parameter on registerComponent -- top of the stack (Component configuration)
+        digester.addCallParam("gdata/server-components/component/configuration",1,0);    
+        digester.parse(RegistryBuilder.class
+                .getResourceAsStream("/gdata-config.xml"));
+        
+    }
+    
+    
+    private static void addIndexRule(Digester digester){
+        digester.addObjectCreate("gdata/service/index-schema", IndexSchema.class);
+        digester.addSetNext("gdata/service/index-schema", "setIndexSchema");
+        digester.addSetProperties("gdata/service/index-schema");
+        digester.addSetProperties("gdata/service/index-schema/index");
+        digester.addBeanPropertySetter("gdata/service/index-schema/index/maxMergeDocs");
+        digester.addBeanPropertySetter("gdata/service/index-schema/index/maxBufferedDocs");
+        digester.addBeanPropertySetter("gdata/service/index-schema/index/maxFieldLength");
+        digester.addBeanPropertySetter("gdata/service/index-schema/index/mergeFactor");
+        digester.addBeanPropertySetter("gdata/service/index-schema/index/indexLocation");
+        digester.addBeanPropertySetter("gdata/service/index-schema/index/useCompoundFile");
+        digester.addCallMethod("gdata/service/index-schema/index/defaultAnalyzer", "serviceAnalyzer",1,new Class[]{Class.class});
+        
+        //call method on top of the stack addSchemaField
+        digester.addCallMethod("gdata/service/index-schema/field","addSchemaField",1,new Class[]{IndexSchemaField.class});
+        digester.addObjectCreate("gdata/service/index-schema/field",IndexSchemaField.class);
+        //set parameter for method call -- parameter is IndexSchemaField
+        digester.addCallParam("gdata/service/index-schema/field",0,0);
+        digester.addSetProperties("gdata/service/index-schema/field");
+        digester.addBeanPropertySetter("gdata/service/index-schema/field/path");
+        digester.addBeanPropertySetter("gdata/service/index-schema/field/store","storeByName");
+        digester.addBeanPropertySetter("gdata/service/index-schema/field/index","indexByName");
+        digester.addBeanPropertySetter("gdata/service/index-schema/field/analyzer","analyzerClass");
+        
+//      call method on top of the stack addSchemaField
+        digester.addCallMethod("gdata/service/index-schema/custom","addSchemaField",1,new Class[]{IndexSchemaField.class});
+        digester.addObjectCreate("gdata/service/index-schema/custom",IndexSchemaField.class);
+        //set parameter for method call -- parameter is IndexSchemaField
+        digester.addCallParam("gdata/service/index-schema/custom",0,0);
+        digester.addSetProperties("gdata/service/index-schema/custom");
+        digester.addBeanPropertySetter("gdata/service/index-schema/custom/path");
+        digester.addBeanPropertySetter("gdata/service/index-schema/custom/store","storeByName");
+        digester.addBeanPropertySetter("gdata/service/index-schema/custom/index","indexByName");
+        digester.addBeanPropertySetter("gdata/service/index-schema/custom/analyzer","analyzerClass");
+        digester.addBeanPropertySetter("gdata/service/index-schema/custom/field-class","fieldClass");
+//        digester.addCallMethod("gdata/service/index-schema/custom/field-class","fieldClass",1,new Class[]{Class.class});
+     
+     
+//      call method on top of the stack addSchemaField
+        digester.addCallMethod("gdata/service/index-schema/mixed","addSchemaField",1,new Class[]{IndexSchemaField.class});
+        digester.addObjectCreate("gdata/service/index-schema/mixed",IndexSchemaField.class);
+        //set parameter for method call -- parameter is IndexSchemaField
+        digester.addCallParam("gdata/service/index-schema/mixed",0,0);
+        digester.addSetProperties("gdata/service/index-schema/mixed");
+        digester.addBeanPropertySetter("gdata/service/index-schema/mixed","type");
+        digester.addBeanPropertySetter("gdata/service/index-schema/mixed/path");
+        digester.addBeanPropertySetter("gdata/service/index-schema/mixed/store","storeByName");
+        digester.addBeanPropertySetter("gdata/service/index-schema/mixed/index","indexByName");
+        digester.addBeanPropertySetter("gdata/service/index-schema/mixed/contenttype","typePath");
+        digester.addBeanPropertySetter("gdata/service/index-schema/mixed/analyzer","analyzerClass");
+        
+    }
+
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/RegistryContextListener.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/RegistryContextListener.java
new file mode 100644
index 0000000..40016e2
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/RegistryContextListener.java
@@ -0,0 +1,90 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.server.registry;
+
+import javax.servlet.ServletContextEvent;
+import javax.servlet.ServletContextListener;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+/**
+ * This Listener creates the
+ * {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry} when the
+ * context is loaded. The registry will be loaded before the
+ * {@link org.apache.lucene.gdata.servlet.RequestControllerServlet} is loaded.
+ * The Registry will be loaded and set up before the REST interface is available.
+ * <p>
+ * This ContextListener has to be configured in the <code>web.xml</code>
+ * deployment descriptor.
+ * </p>
+ * <p>
+ * When the
+ * {@link javax.servlet.ServletContextListener#contextDestroyed(javax.servlet.ServletContextEvent)}
+ * method is called the registry will be destroyed using
+ * {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry#destroy()}
+ * method.
+ * 
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class RegistryContextListener implements ServletContextListener {
+    private GDataServerRegistry serverRegistry;
+
+    private static final Log LOG = LogFactory
+            .getLog(RegistryContextListener.class);
+
+    /**
+     * @see javax.servlet.ServletContextListener#contextInitialized(javax.servlet.ServletContextEvent)
+     */
+    public void contextInitialized(ServletContextEvent arg0) {
+        LOG.info("RegistryContextListener has been loaded");
+
+        try {
+            RegistryBuilder.buildRegistry();
+            this.serverRegistry = GDataServerRegistry.getRegistry();
+            /*
+             * catch all exceptions and destroy the registry to release all resources.
+             * some components start lots of threads, the will remain running if the registry is not destroyed
+             */
+        } catch (Throwable e) {
+            GDataServerRegistry.getRegistry().destroy();
+            LOG.error("can not register required components", e);
+            throw new RuntimeException("Can not register required components",
+                    e);
+        }
+     
+
+    }
+
+    /**
+     * @see javax.servlet.ServletContextListener#contextDestroyed(javax.servlet.ServletContextEvent)
+     */
+    public void contextDestroyed(ServletContextEvent arg0) {
+        LOG.info("Destroying context");
+        /*
+         * this might be null if startup fails
+         * --> prevent null pointer exception
+         */
+        if(this.serverRegistry != null)
+            this.serverRegistry.destroy();
+
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/RegistryException.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/RegistryException.java
new file mode 100644
index 0000000..81a5db1
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/RegistryException.java
@@ -0,0 +1,51 @@
+package org.apache.lucene.gdata.server.registry;
+
+/**
+ * This exception is thrown by the
+ * {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry} if
+ * registering a service or a component fails.
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class RegistryException extends Exception {
+
+ 
+    private static final long serialVersionUID = -3563720639871194466L;
+
+    /**
+     * Constructs a new Registry Exception.
+     */
+    public RegistryException() {
+        super();
+        
+    }
+
+    /**
+     * Constructs a new Registry Exception with the specified detail message.
+     * @param arg0 - detail message
+     */
+    public RegistryException(String arg0) {
+        super(arg0);
+        
+    }
+
+    /**
+     * Constructs a new Registry Exception with the specified detail message and nested exception.
+     * @param arg0 - detail message
+     * @param arg1 - nested exception
+     */
+    public RegistryException(String arg0, Throwable arg1) {
+        super(arg0, arg1);
+        
+    }
+
+    /** Constructs a new Registry Exception with a nested exception.
+     * @param arg0 - nested exception
+     */
+    public RegistryException(Throwable arg0) {
+        super(arg0);
+        
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/Scope.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/Scope.java
new file mode 100755
index 0000000..ed5ec03
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/Scope.java
@@ -0,0 +1,64 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.server.registry;
+
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+/**
+ * The Scope annotation is used in
+ * {@link org.apache.lucene.gdata.server.registry.ScopeVisitable} and
+ * {@link org.apache.lucene.gdata.server.registry.ScopeVisitor} implementations
+ * to indicate which scope should be visited.
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+@Target( { TYPE })
+@Retention(value = RUNTIME)
+public @interface Scope {
+    /**
+     * @return - the scope type the class was annotated with
+     */
+    ScopeType scope();
+
+    /**
+     * Defines a Scope for {@link Scope} annotations
+     * 
+     * @author Simon Willnauer
+     * 
+     */
+    public static enum ScopeType {
+        /**
+         * Request scope
+         */
+        REQUEST,
+        /**
+         * Session scope
+         */
+        SESSION,
+        /**
+         * Context scope
+         */
+        CONTEXT
+
+    }
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/ScopeVisitable.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/ScopeVisitable.java
new file mode 100755
index 0000000..6f406ac
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/ScopeVisitable.java
@@ -0,0 +1,34 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.server.registry;
+
+/**
+ * Implementation of this interface accept
+ * {@link org.apache.lucene.gdata.server.registry.ScopeVisitor} objects and call
+ * their methods on the desired action.
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public interface ScopeVisitable {
+    /**
+     * @param visitor -
+     *            the visitor to accept
+     */
+    public abstract void accept(ScopeVisitor visitor);
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/ScopeVisitor.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/ScopeVisitor.java
new file mode 100755
index 0000000..b2fc87e
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/ScopeVisitor.java
@@ -0,0 +1,56 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.server.registry;
+
+/**
+ * <p>
+ * <code>ScopeVisitor</code> is used to implement the <code>Visitor</code>
+ * pattern in GDATAServer. An object of this interface can be passed to a
+ * <code>ScopeVistable</code> which will then call its methods. <br/>
+ * {@link org.apache.lucene.gdata.server.registry.Component} Classes registered
+ * in the {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry}
+ * will be added to the Visitableimplementation automatically. Please refer to
+ * the <i>Gang of Four </i> book of Design Patterns for more details on the
+ * <code>Visitor</code> pattern.
+ * </p>
+ * <p>
+ * A scope can be Session, Request or Context if one of the ScopeVisitors for
+ * the desired scope is available by the registry.
+ * </p>
+ * <p>
+ * This <a href="http://www.patterndepot.com/put/8/JavaPatterns.htm">site </a>
+ * has further discussion on design patterns and links to the GOF book. This <a
+ * href="http://www.patterndepot.com/put/8/visitor.pdf">link </a> describes the
+ * Visitor pattern in detail.
+ * </p>
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public interface ScopeVisitor {
+    /**
+     * Visites the initialization of the scope
+     */
+    public abstract void visiteInitialize();
+
+    /**
+     * Visites the destory of the scope
+     * 
+     */
+    public abstract void visiteDestroy();
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/ServerComponent.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/ServerComponent.java
new file mode 100644
index 0000000..2d1e20b
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/ServerComponent.java
@@ -0,0 +1,44 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.server.registry;
+
+/**
+ * To Register a class as a component in the
+ * {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry} the class
+ * or a super class must implements this interface.
+ * <p>
+ * <tt>ServerComponent</tt> defines a method <tt>initialize</tt> and
+ * <tt>destroy</tt>. <tt>initialize</tt> will be called when the component
+ * is registered and <tt>destroy</tt> when the registry is destroyed (usually
+ * at server shut down).</p>
+ * @see org.apache.lucene.gdata.server.registry.GDataServerRegistry
+ * @author Simon Willnauer
+ * 
+ */
+public interface ServerComponent {
+    /**
+     * will be call when the component is registered.
+     * if this fails the server must not startup.
+     */
+    public abstract void initialize();
+
+    /**
+     * will be called when the registry is going down e.g. when the  {@link GDataServerRegistry#destroy()} method is called.
+     */
+    public abstract void destroy();
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/SuperType.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/SuperType.java
new file mode 100644
index 0000000..9c6eb05
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/SuperType.java
@@ -0,0 +1,45 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.server.registry;
+
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+/**
+ * This Annotation is use to annotate
+ * {@link org.apache.lucene.gdata.server.registry.ComponentType} elements to
+ * specify an interface e.g. super type of a defined component.
+ * <p>This annotation will be visible at runtime</p>
+ * @see org.apache.lucene.gdata.server.registry.Component
+ * @see org.apache.lucene.gdata.server.registry.GDataServerRegistry
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+@Target( { FIELD })
+@Retention(value = RUNTIME)
+public @interface SuperType {
+    /**
+     * 
+     * @return the specified super type
+     */
+    Class superType();
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/configuration/ComponentConfiguration.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/configuration/ComponentConfiguration.java
new file mode 100755
index 0000000..2898bf9
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/configuration/ComponentConfiguration.java
@@ -0,0 +1,80 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.server.registry.configuration;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Simple configuration class storing properties as key with defined property
+ * values as values in a <code>Map<String,String></code>. As a map cannot
+ * contain duplicate keys the first use of a key can not be replaced. If a key
+ * is used twice a {@link java.lang.IllegalArgumentException} will be thrown.
+ * @see Map
+ * @author Simon Willnauer
+ * 
+ */
+public class ComponentConfiguration {
+    private final Map<String, String> configMap;
+
+    /**
+     * Creates a new ComponentConfiguration object and initializes the internal
+     * map.
+     */
+    public ComponentConfiguration() {
+        super();
+        this.configMap = new HashMap<String, String>();
+    }
+
+    /**
+     * Stores a key / value pair as a property. If a key is used twice the first
+     * call will set the key / value pair. Any subsequent calls with a already
+     * set key will throw a IllegalArgumentException.
+     * 
+     * @param key -
+     *            the property as a key
+     * @param value -
+     *            the value for the key
+     *@see Map#put(Object, Object)
+     */
+    public void set(final String key, final String value) {
+        if (this.configMap.containsKey(key))
+            throw new IllegalArgumentException("key has already been used");
+        this.configMap.put(key, value);
+    }
+
+    /**
+     * Returns the value of the key or <code>null</code> if the key is not set.
+     * @param key - the key
+     * @return - the value for the key or <code>null</code> if the key is not set.
+     * @see Map#get(java.lang.Object) 
+     */
+    public String get(final String key) {
+        return this.configMap.get(key);
+    }
+
+    /**
+     * @param key - a string key
+     * @return - <code>true</code> if the key is set, otherwise <code>false</code>
+     * @see Map#containsKey(java.lang.Object)
+     */
+    public boolean contains(String key) {
+        return this.configMap.containsKey(key);
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/configuration/InjectionException.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/configuration/InjectionException.java
new file mode 100755
index 0000000..b6c96dd
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/configuration/InjectionException.java
@@ -0,0 +1,78 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.server.registry.configuration;
+
+/**
+ * Will be throw if an exception occures while injecting properties, a type or
+ * cast exception occures or a
+ * {@link org.apache.lucene.gdata.server.registry.configuration.Requiered}
+ * property is not available.
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class InjectionException extends RuntimeException {
+
+    /**
+     * 
+     */
+    private static final long serialVersionUID = 3559845601111510210L;
+
+    /**
+     * Constructs a new InjectionException
+     */
+    public InjectionException() {
+        super();
+    }
+
+    /**
+     * Constructs a new InjectionException
+     * 
+     * @param message -
+     *            the exception message
+     */
+    public InjectionException(String message) {
+        super(message);
+
+    }
+
+    /**
+     * Constructs a new InjectionException
+     * 
+     * @param message -
+     *            the exception message
+     * @param cause -
+     *            the root cause of this exception
+     */
+    public InjectionException(String message, Throwable cause) {
+        super(message, cause);
+
+    }
+
+    /**
+     * Constructs a new InjectionException
+     * 
+     * @param cause -
+     *            the root cause of this exception
+     */
+    public InjectionException(Throwable cause) {
+        super(cause);
+
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/configuration/PropertyInjector.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/configuration/PropertyInjector.java
new file mode 100755
index 0000000..7837ad5
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/configuration/PropertyInjector.java
@@ -0,0 +1,262 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.server.registry.configuration;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+import java.util.Map.Entry;
+
+import org.apache.lucene.gdata.utils.ReflectionUtils;
+
+/**
+ * PropertyInjector is used to set member variables / properties of classes via
+ * <i>setter</i> methods using the
+ * {@link org.apache.lucene.gdata.server.registry.configuration.ComponentConfiguration}
+ * class.
+ * <p>
+ * To populate a object with properties from a ComponentConfiguration instance
+ * the class or a superclass of the object to populate has to provide at least
+ * one setter method with a single parameter. The object to populate is set via
+ * the {@link PropertyInjector#setTargetObject} method. The class of the object
+ * will be analyzed for setter methods having a "set" prefix in their method
+ * name. If one of the found setter methods is annotated with
+ * {@link org.apache.lucene.gdata.server.registry.configuration.Requiered} this
+ * property is interpreted as a mandatory property. Mandatory properties must be
+ * available in the provided ComponentConfiguration, if not the injection will
+ * fail.<br>
+ * The
+ * {@link org.apache.lucene.gdata.server.registry.configuration.ComponentConfiguration}
+ * contains key / value pairs where the key must match the signature of the
+ * setter method without the 'set' prefix and must begin with a lower case
+ * character. <span>Key<code>bufferSize</code> does match a method signature
+ * of <code>setBufferSize</code></span> The type of the parameter will be
+ * reflected via the Reflection API and instantiated with the given value if
+ * possible.
+ * </p>
+ * <p>
+ * Setter methods without a <code>Required</code> annotation will be set if
+ * the property is present in the ComponentConfiguration
+ * </p>
+ * <p>This class does not support overloaded setter methods.</p>
+ * @author Simon Willnauer
+ * @see org.apache.lucene.gdata.server.registry.configuration.Requiered
+ * @see org.apache.lucene.gdata.server.registry.configuration.ComponentConfiguration
+ */
+public class PropertyInjector {
+    private static final String SETTER_PREFIX = "set";
+
+    private Class targetClass;
+
+    private Object target;
+
+    private Map<String, Method> requieredProperties = new HashMap<String, Method>();
+
+    private Map<String, Method> optionalProperties = new HashMap<String, Method>();
+
+    /**
+     * Sets the object to be populated with the properties provided in the ComponentConfiguration.
+     * @param o - the object to populate
+     */
+    public void setTargetObject(final Object o) {
+        if (o == null)
+            throw new IllegalArgumentException("TargetObject must not be null");
+        this.target = o;
+        this.targetClass = o.getClass();
+        try {
+            registerProperties(this.targetClass);
+        } catch (Exception e) {
+            throw new InjectionException("can access field -- "
+                    + e.getMessage(), e);
+
+        }
+        if (this.requieredProperties.isEmpty()
+                && this.optionalProperties.isEmpty())
+            throw new InjectionException(
+                    "Given type has no public setter methods -- "
+                            + o.getClass().getName());
+
+    }
+
+    protected int getRequiredSize() {
+        return this.requieredProperties.size();
+    }
+
+    protected int getOptionalSize() {
+        return this.optionalProperties.size();
+    }
+
+    private void registerProperties(final Class clazz)
+            throws SecurityException, NoSuchFieldException {
+        if (clazz == null)
+            return;
+        Method[] methodes = clazz.getMethods();
+        for (int i = 0; i < methodes.length; i++) {
+            if (methodes[i].getName()
+                    .startsWith(PropertyInjector.SETTER_PREFIX)) {
+                String methodName = methodes[i].getName();
+                String fieldName = getFieldName(methodName);
+                if (methodes[i].getAnnotation(Requiered.class) != null)
+                    this.requieredProperties.put(fieldName, methodes[i]);
+                else
+                    this.optionalProperties.put(fieldName, methodes[i]);
+
+            }
+
+        }
+        registerProperties(clazz.getSuperclass());
+    }
+
+    private String getFieldName(final String setterMethodName) {
+        // remove 'set' prefix --> first char as lowerCase
+        String retVal = setterMethodName.substring(3);
+        String firstLetter = retVal.substring(0, 1);
+        retVal = retVal.replaceFirst(firstLetter, firstLetter.toLowerCase());
+        return retVal;
+    }
+
+    /**
+     * Injects the properties stored in the <code>ComponentConfiguration</code>
+     * to the corresponding methods of the target object
+     * @param bean - configuration bean containing all properties to set.
+     * 
+     */
+    public void injectProperties(final ComponentConfiguration bean) {
+        if (bean == null)
+            throw new IllegalArgumentException("bean must not be null");
+        if (this.target == null)
+            throw new IllegalStateException("target is not set -- null");
+        Set<Entry<String, Method>> requiered = this.requieredProperties
+                .entrySet();
+        // set required properties
+        for (Entry<String, Method> entry : requiered) {
+            if (!bean.contains(entry.getKey()))
+                throw new InjectionException(
+                        "Required property can not be set -- value not in configuration bean; Property: "
+                                + entry.getKey()
+                                + "for class "
+                                + this.targetClass.getName());
+            populate(bean, entry);
+
+        }
+        Set<Entry<String, Method>> optinal = this.optionalProperties.entrySet();
+        // set optional properties
+        for (Entry<String, Method> entry : optinal) {
+            if (bean.contains(entry.getKey()))
+                populate(bean, entry);
+        }
+
+    }
+
+    private void populate(ComponentConfiguration bean,
+            Entry<String, Method> entry) {
+        String value = bean.get(entry.getKey());
+        Method m = entry.getValue();
+        Class<?>[] parameterTypes = m.getParameterTypes();
+        if (parameterTypes.length > 1)
+            throw new InjectionException("Setter has more than one parameter "
+                    + m.getName() + " -- can not invoke method -- ");
+        Object parameter = null;
+        try {
+
+            parameter = createObject(value, parameterTypes[0]);
+        } catch (InjectionException e) {
+            throw new InjectionException(
+                    "parameter object creation failed for method "
+                            + m.getName() + " in class: "
+                            + this.targetClass.getName(), e);
+        }
+        // only setters with one parameter are supported
+        Object[] parameters = { parameter };
+        try {
+            m.invoke(this.target, parameters);
+        } catch (Exception e) {
+            throw new InjectionException("Can not set value of type "
+                    + value.getClass().getName()
+                    + " -- can not invoke method -- " + e.getMessage(), e);
+
+        }
+    }
+
+    private Object createObject(String s, Class<?> clazz) {
+
+        try {
+            // if class is requested use s as fully qualified class name
+            if (clazz == Class.class)
+                return Class.forName(s);
+            // check for primitive type
+            if (clazz.isPrimitive())
+                clazz = ReflectionUtils.getPrimitiveWrapper(clazz);
+            boolean defaultConst = false;
+            boolean stringConst = false;
+            Constructor[] constructors = clazz.getConstructors();
+            if (constructors.length == 0)
+                defaultConst = true;
+            for (int i = 0; i < constructors.length; i++) {
+                if (constructors[i].getParameterTypes().length == 0) {
+                    defaultConst = true;
+                    continue;
+                }
+                if (constructors[i].getParameterTypes().length == 1
+                        && constructors[i].getParameterTypes()[0]
+                                .equals(String.class))
+                    stringConst = true;
+            }
+            /*
+             * if there is a string constructor use the string as a parameter
+             */
+            if (stringConst) {
+                Constructor constructor = clazz
+                        .getConstructor(new Class[] { String.class });
+                return constructor.newInstance(new Object[] { s });
+            }
+            /*
+             * if no string const. but a default const. -- use the string as a
+             * class name
+             */
+            if (defaultConst)
+                return Class.forName(s).newInstance();
+            throw new InjectionException(
+                    "Parameter can not be created -- no default or String constructor found for class "
+                            + clazz.getName());
+
+        } catch (Exception e) {
+
+            throw new InjectionException("can not create object for setter", e);
+        }
+
+    }
+
+    /**
+     * Sets all members to their default values and clears the internal used
+     * {@link Map} instances
+     * 
+     * @see Map#clear()
+     */
+    public void clear() {
+        this.target = null;
+        this.targetClass = null;
+        this.optionalProperties.clear();
+        this.requieredProperties.clear();
+    }
+
+    
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/configuration/Requiered.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/configuration/Requiered.java
new file mode 100755
index 0000000..366a72f
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/configuration/Requiered.java
@@ -0,0 +1,38 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.server.registry.configuration;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+/**
+ * This annotation is used to define mandatory properties via their setter
+ * methodes. It will be present at runtime.
+ * 
+ * @see org.apache.lucene.gdata.server.registry.configuration.PropertyInjector
+ * @see org.apache.lucene.gdata.server.registry.configuration.ComponentConfiguration
+ * @author Simon Willnauer
+ * 
+ */
+@Target( { METHOD })
+@Retention(value = RUNTIME)
+public @interface Requiered {
+//
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/package.html b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/package.html
new file mode 100644
index 0000000..dc9b7a6
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/package.html
@@ -0,0 +1,10 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
+<html> 
+<head> 
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
+   <meta name="Author" content="Simon Willnauer"> 
+</head> 
+<body> 
+Internal registry - registering services and server components
+</body> 
+</html> 
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/AbstractGdataServlet.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/AbstractGdataServlet.java
new file mode 100644
index 0000000..dfda9df
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/AbstractGdataServlet.java
@@ -0,0 +1,115 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */ 
+ 
+package org.apache.lucene.gdata.servlet; 
+ 
+import java.io.IOException; 
+ 
+import javax.servlet.ServletConfig;
+import javax.servlet.ServletException; 
+import javax.servlet.http.HttpServlet; 
+import javax.servlet.http.HttpServletRequest; 
+import javax.servlet.http.HttpServletResponse; 
+
+import org.apache.lucene.gdata.server.registry.ComponentType;
+import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
+import org.apache.lucene.gdata.servlet.handler.RequestHandlerFactory;
+ 
+/** 
+ *  
+ * Provides an abstract class to be subclassed to create an GDATA servlet 
+ * suitable for a GDATA serverside implementation. 
+ *  
+ * @see javax.servlet.http.HttpServlet 
+ *  
+ * @author Simon Willnauer 
+ *  
+ */ 
+public abstract class AbstractGdataServlet extends HttpServlet { 
+    private static final String METHOD_HEADER_NAME = "x-http-method-override"; 
+ 
+    private static final String METHOD_DELETE = "DELETE"; 
+ 
+    private static final String METHOD_GET = "GET"; 
+ 
+    private static final String METHOD_POST = "POST"; 
+ 
+    private static final String METHOD_PUT = "PUT";
+
+    protected static RequestHandlerFactory HANDLER_FACTORY = null; 
+ 
+    /** 
+     * This overwrites the protected <code>service</code> method to dispatch 
+     * the request to the correponding <code>do</code> method. There is 
+     * ususaly no need for overwriting this method. The GData protool and the 
+     * Google GData API uses the <code>x-http-method-override</code> header to 
+     * get through firewalls. The http method will be overritten by the 
+     * <code>x-http-method-override</code> and dispatched to the 
+     * <code>do</code><i>Xxx</i> methods defined in this class. This method 
+     * is an GDATA-specific version of the {@link javax.servlet.Servlet#service} 
+     * method. 
+     *  
+     * @see HttpServlet#service(javax.servlet.http.HttpServletRequest, 
+     *      javax.servlet.http.HttpServletResponse) 
+     */ 
+    @Override 
+    protected void service(HttpServletRequest arg0, HttpServletResponse arg1) 
+            throws ServletException, IOException { 
+        if (arg0.getHeader(METHOD_HEADER_NAME) == null) { 
+            super.service(arg0, arg1); 
+            return; 
+        } 
+        overrideMethod(arg0, arg1); 
+ 
+    } 
+ 
+    private void overrideMethod(HttpServletRequest arg0, 
+            HttpServletResponse arg1) throws ServletException, IOException { 
+        final String method = arg0.getMethod(); 
+        final String overrideHeaderMethod = arg0.getHeader(METHOD_HEADER_NAME); 
+        if (overrideHeaderMethod.equals(method)) { 
+            super.service(arg0, arg1); 
+            return; 
+        } 
+        // These methodes are use by GDATA Client APIs 
+        if (overrideHeaderMethod.equals(METHOD_DELETE)) { 
+            doDelete(arg0, arg1); 
+        } else if (overrideHeaderMethod.equals(METHOD_GET)) { 
+            doGet(arg0, arg1); 
+        } else if (overrideHeaderMethod.equals(METHOD_POST)) { 
+            doPost(arg0, arg1); 
+        } else if (overrideHeaderMethod.equals(METHOD_PUT)) { 
+            doPut(arg0, arg1); 
+        } else { 
+            // if another method has been overwritten follow the HttpServlet 
+            // implementation 
+            super.service(arg0, arg1); 
+        } 
+ 
+    }
+
+    /**
+     * 
+     * @see javax.servlet.GenericServlet#init(javax.servlet.ServletConfig)
+     */
+    public void init(ServletConfig arg0) throws ServletException {
+        HANDLER_FACTORY = GDataServerRegistry.getRegistry().lookup(RequestHandlerFactory.class,ComponentType.REQUESTHANDLERFACTORY);
+        if(HANDLER_FACTORY == null)
+            throw new ServletException("service not available");
+        
+    } 
+ 
+} 
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/AccountAdministrationServlet.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/AccountAdministrationServlet.java
new file mode 100644
index 0000000..9e1d5cb
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/AccountAdministrationServlet.java
@@ -0,0 +1,74 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.servlet;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.servlet.handler.GDataRequestHandler;
+
+/**
+ * This Servlet provides an REST interface to create / update and delete user instances.
+ * @author Simon Willnauer
+ *
+ */
+public class AccountAdministrationServlet extends AbstractGdataServlet {
+   
+    private static final Log LOGGER = LogFactory.getLog(AccountAdministrationServlet.class);
+
+    /**
+     * 
+     */
+    private static final long serialVersionUID = 8215863212137543185L;
+
+    @Override
+    protected void doDelete(HttpServletRequest arg0, HttpServletResponse arg1) throws ServletException, IOException {
+        GDataRequestHandler handler = HANDLER_FACTORY.getDeleteAccountHandler();
+        if(LOGGER.isInfoEnabled())
+            LOGGER.info("Process delete Account request");
+        handler.processRequest(arg0,arg1);
+       
+    }
+
+    @Override
+    protected void doPost(HttpServletRequest arg0, HttpServletResponse arg1) throws ServletException, IOException {
+        GDataRequestHandler handler = HANDLER_FACTORY.getInsertAccountHandler();
+        if(LOGGER.isInfoEnabled())
+            LOGGER.info("Process insert Account request");
+        handler.processRequest(arg0,arg1);        
+       
+    }
+
+    @Override
+    protected void doPut(HttpServletRequest arg0, HttpServletResponse arg1) throws ServletException, IOException {
+        
+        GDataRequestHandler handler = HANDLER_FACTORY.getUpdateAccountHandler();
+        if(LOGGER.isInfoEnabled())
+            LOGGER.info("Process update Account request");
+        handler.processRequest(arg0,arg1);  
+    }
+    
+   
+   
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/AuthenticationServlet.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/AuthenticationServlet.java
new file mode 100644
index 0000000..eb68a1e
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/AuthenticationServlet.java
@@ -0,0 +1,51 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.servlet;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.lucene.gdata.servlet.handler.AuthenticationHandler;
+
+/**
+ * REST interface for handling authentification requests from clients to get a
+ * auth token either as a cookie or as a plain auth token. This Servlet uses a
+ * single {@link org.apache.lucene.gdata.servlet.handler.AuthenticationHandler}
+ * instance to handle the incoming requests.
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class AuthenticationServlet extends HttpServlet {
+
+    private final AuthenticationHandler handler = new AuthenticationHandler();
+
+    private static final long serialVersionUID = 7132478125868917848L;
+
+    @SuppressWarnings("unused")
+    @Override
+    protected void doPost(HttpServletRequest request,
+            HttpServletResponse response) throws ServletException, IOException {
+        this.handler.processRequest(request, response);
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/FeedAdministrationServlet.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/FeedAdministrationServlet.java
new file mode 100644
index 0000000..0ada64e
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/FeedAdministrationServlet.java
@@ -0,0 +1,72 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.servlet;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.servlet.handler.GDataRequestHandler;
+
+/**
+ * This Servlet provides an REST interface to create / update and delete Feed instances.
+ *  
+ * @author Simon Willnauer
+ *
+ */
+public class FeedAdministrationServlet extends AbstractGdataServlet {
+    private static final Log LOGGER = LogFactory.getLog(FeedAdministrationServlet.class);
+    /**
+     * 
+     */
+    private static final long serialVersionUID = -905586350743277032L;
+
+    @Override
+    protected void doDelete(HttpServletRequest arg0, HttpServletResponse arg1) throws ServletException, IOException {
+        GDataRequestHandler handler = HANDLER_FACTORY.getDeleteFeedHandler();
+        if(LOGGER.isInfoEnabled())
+            LOGGER.info("Process delete feed request");
+        handler.processRequest(arg0,arg1);
+     
+    }
+
+    @Override
+    protected void doPost(HttpServletRequest arg0, HttpServletResponse arg1) throws ServletException, IOException {
+        GDataRequestHandler handler = HANDLER_FACTORY.getInsertFeedHandler();
+        if(LOGGER.isInfoEnabled())
+            LOGGER.info("Process insert feed request");
+        handler.processRequest(arg0,arg1);
+     
+    }
+
+    @Override
+    protected void doPut(HttpServletRequest arg0, HttpServletResponse arg1) throws ServletException, IOException {
+        GDataRequestHandler handler = HANDLER_FACTORY.getUpdateFeedHandler();
+        if(LOGGER.isInfoEnabled())
+            LOGGER.info("Process update feed request");
+        handler.processRequest(arg0,arg1);
+     
+    }
+
+  
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/RequestControllerServlet.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/RequestControllerServlet.java
new file mode 100644
index 0000000..58c4553
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/RequestControllerServlet.java
@@ -0,0 +1,103 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.servlet;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.servlet.handler.GDataRequestHandler;
+
+/**
+ * Provides a clean basic interface for GDATA Client API and requests to the
+ * GDATA Server. This Servlet dispatches the incoming requests to defined GDATA
+ * request handlers. Each of the handler processes the incoming request and
+ * responds according to the requested action.
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class RequestControllerServlet extends AbstractGdataServlet {
+    private static final Log LOGGER = LogFactory.getLog(RequestControllerServlet.class);
+
+    /**
+     * Version ID since this class implements
+     * 
+     * @see java.io.Serializable
+     */
+    private static final long serialVersionUID = 7540810742476175576L;
+
+    /**
+     * @see javax.servlet.http.HttpServlet#doDelete(javax.servlet.http.HttpServletRequest,
+     *      javax.servlet.http.HttpServletResponse)
+     */
+    @Override
+	protected void doDelete(HttpServletRequest arg0, HttpServletResponse arg1)
+            throws ServletException, IOException {
+        GDataRequestHandler hanlder = HANDLER_FACTORY.getEntryDeleteHandler();
+        if(LOGGER.isInfoEnabled())
+            LOGGER.info("Process DELETE request");
+        
+        hanlder.processRequest(arg0, arg1);
+    }
+
+    /**
+     * @see javax.servlet.http.HttpServlet#doGet(javax.servlet.http.HttpServletRequest,
+     *      javax.servlet.http.HttpServletResponse)
+     */
+    @Override
+	protected void doGet(HttpServletRequest arg0, HttpServletResponse arg1)
+            throws ServletException, IOException {
+        GDataRequestHandler hanlder = HANDLER_FACTORY.getFeedQueryHandler();
+        if(LOGGER.isInfoEnabled())
+            LOGGER.info("Process GET request");
+        hanlder.processRequest(arg0, arg1);
+    }
+
+    /**
+     * @see javax.servlet.http.HttpServlet#doPost(javax.servlet.http.HttpServletRequest,
+     *      javax.servlet.http.HttpServletResponse)
+     */
+    @Override
+	protected void doPost(HttpServletRequest arg0, HttpServletResponse arg1)
+            throws ServletException, IOException {
+        GDataRequestHandler hanlder = HANDLER_FACTORY.getEntryInsertHandler();
+        if(LOGGER.isInfoEnabled())
+            LOGGER.info("Process POST request");
+        hanlder.processRequest(arg0, arg1);
+    }
+
+    /**
+     * @see javax.servlet.http.HttpServlet#doPut(javax.servlet.http.HttpServletRequest,
+     *      javax.servlet.http.HttpServletResponse)
+     */
+    @Override
+	protected void doPut(HttpServletRequest arg0, HttpServletResponse arg1)
+            throws ServletException, IOException {
+        GDataRequestHandler hanlder = HANDLER_FACTORY.getEntryUpdateHandler();
+        if(LOGGER.isInfoEnabled())
+            LOGGER.info("Process PUT request");
+        hanlder.processRequest(arg0, arg1);
+    }
+    
+  
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/AbstractAccountHandler.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/AbstractAccountHandler.java
new file mode 100644
index 0000000..7f857ac
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/AbstractAccountHandler.java
@@ -0,0 +1,193 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.servlet.handler;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
+import org.apache.lucene.gdata.server.GDataResponse;
+import org.apache.lucene.gdata.server.ServiceException;
+import org.apache.lucene.gdata.server.ServiceFactory;
+import org.apache.lucene.gdata.server.administration.AccountBuilder;
+import org.apache.lucene.gdata.server.administration.AdminService;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
+import org.xml.sax.SAXException;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public abstract class AbstractAccountHandler extends RequestAuthenticator
+        implements GDataRequestHandler {
+    private static final Log LOG = LogFactory
+            .getLog(AbstractAccountHandler.class);
+
+    private boolean authenticated = false;
+
+    private int error;
+
+    private String errorMessage = "";
+
+    private boolean isError = false;
+
+    protected AdminService service;
+
+    /**
+     * @see org.apache.lucene.gdata.servlet.handler.GDataRequestHandler#processRequest(javax.servlet.http.HttpServletRequest,
+     *      javax.servlet.http.HttpServletResponse)
+     */
+    @SuppressWarnings("unused")
+    public void processRequest(HttpServletRequest request,
+            HttpServletResponse response) throws ServletException, IOException {
+      try{  
+            this.authenticated = authenticateAccount(request,
+                AccountRole.USERADMINISTRATOR);
+        
+        if (this.authenticated) {
+            GDataServerRegistry registry = GDataServerRegistry.getRegistry();
+            ServiceFactory factory = registry.lookup(ServiceFactory.class,
+                    ComponentType.SERVICEFACTORY);
+            try {
+
+                GDataAccount account = getAccountFromRequest(request);
+                if (!account.requiredValuesSet()) {
+                    setError(GDataResponse.SERVER_ERROR,
+                            "Required server component not available");
+                    throw new AccountHandlerException(
+                            "Required values are not set -- account can not be saved -- "
+                                    + account);
+                }
+                this.service = factory.getAdminService();
+                processServiceAction(account);
+            } catch (ServiceException e) {
+                LOG.error("Can't process account action -- " + e.getMessage(),
+                        e);
+                setError(e.getErrorCode(), "");
+            } 
+            catch (AccountHandlerException e) {
+                LOG.error("Can't process account action -- " + e.getMessage(),
+                        e);
+            }
+        }else{
+            setError(GDataResponse.UNAUTHORIZED,"Authorization failed");
+        }
+        sendResponse(response);
+      }finally{
+          if(this.service!=null)
+              this.service.close();
+      }
+
+    }
+    
+    
+    
+
+    protected GDataAccount getAccountFromRequest(
+            final HttpServletRequest request) throws AccountHandlerException {
+        try {
+            GDataAccount account = AccountBuilder.buildAccount(request
+                    .getReader());
+            if (account == null) {
+                setError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "");
+                throw new AccountHandlerException(
+                        "unexpected value -- parsed account is null");
+            }
+            return account;
+        } catch (IOException e) {
+            setError(HttpServletResponse.SC_BAD_REQUEST, "can not read input");
+            throw new AccountHandlerException("Can't read from request reader",
+                    e);
+        } catch (SAXException e) {
+            setError(HttpServletResponse.SC_BAD_REQUEST,
+                    "can not parse gdata account");
+            throw new AccountHandlerException(
+                    "Can not parse incoming gdata account", e);
+        }
+    }
+
+    protected void sendResponse(HttpServletResponse response) {
+
+        if (!this.isError)
+            return;
+        try {
+            response.sendError(this.error, this.errorMessage);
+        } catch (IOException e) {
+            LOG.warn("can send error in RequestHandler ", e);
+        }
+    }
+
+    protected void setError(int error, String message) {
+        this.error = error;
+        this.errorMessage = message;
+        this.isError = true;
+    }
+
+    protected int getErrorCode() {
+        return this.error;
+    }
+
+    protected String getErrorMessage() {
+        return this.errorMessage;
+    }
+
+    protected abstract void processServiceAction(final GDataAccount account)
+            throws ServiceException;
+
+    static class AccountHandlerException extends Exception {
+
+        /**
+         * 
+         */
+        private static final long serialVersionUID = 3140463271122190694L;
+
+        /**
+         * Constructs a new <tt>AccountHandlerException</tt> with an exception
+         * message and the exception caused this exception.
+         * 
+         * @param arg0 -
+         *            the exception message
+         * @param arg1 -
+         *            the exception cause
+         */
+        public AccountHandlerException(String arg0, Throwable arg1) {
+            super(arg0, arg1);
+
+        }
+
+        /**
+         * Constructs a new <tt>AccountHandlerException</tt> with an exception
+         * message.
+         * 
+         * @param arg0 -
+         *            the exception message
+         */
+        public AccountHandlerException(String arg0) {
+            super(arg0);
+
+        }
+
+    }
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/AbstractFeedHandler.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/AbstractFeedHandler.java
new file mode 100644
index 0000000..10ce873
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/AbstractFeedHandler.java
@@ -0,0 +1,175 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.servlet.handler;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.data.ServerBaseFeed;
+import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
+import org.apache.lucene.gdata.server.GDataEntityBuilder;
+import org.apache.lucene.gdata.server.GDataResponse;
+import org.apache.lucene.gdata.server.ServiceException;
+import org.apache.lucene.gdata.server.ServiceFactory;
+import org.apache.lucene.gdata.server.administration.AdminService;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
+import org.apache.lucene.gdata.server.registry.ProvidedService;
+
+import com.google.gdata.util.ParseException;
+
+/**
+ * 
+ * @author Simon Willnauer
+ *
+ */
+public abstract class AbstractFeedHandler extends RequestAuthenticator implements GDataRequestHandler {
+    private static final Log LOG = LogFactory.getLog(AbstractFeedHandler.class);
+
+    protected static final String PARAMETER_ACCOUNT = "account";
+
+    protected static final String PARAMETER_SERVICE = "service";
+    private int error;
+    protected boolean authenticated = false;
+    
+      private String errorMessage = "";
+      private boolean isError = false;
+      
+    /**
+     * @see org.apache.lucene.gdata.servlet.handler.GDataRequestHandler#processRequest(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
+     */
+    @SuppressWarnings("unused")
+    public void processRequest(HttpServletRequest request,
+            HttpServletResponse response) throws ServletException, IOException {
+            this.authenticated = authenticateAccount(request,AccountRole.FEEDAMINISTRATOR);
+            if(!this.authenticated)
+                setError(GDataResponse.UNAUTHORIZED,"Authorization failed");
+        
+    }
+    
+    protected ServerBaseFeed createFeedFromRequest(HttpServletRequest request) throws ParseException, IOException, FeedHandlerException{
+        GDataServerRegistry registry = GDataServerRegistry.getRegistry();
+        String providedService = request.getParameter(PARAMETER_SERVICE);
+        if(!registry.isServiceRegistered(providedService)){
+            setError(GDataResponse.NOT_FOUND,"no such service");
+            throw new FeedHandlerException("ProvicdedService is not registered -- Name: "+providedService);
+         }
+        ProvidedService provServiceInstance = registry.getProvidedService(providedService);  
+        if(providedService == null){
+            setError(GDataResponse.BAD_REQUEST,"no such service");
+            throw new FeedHandlerException("no such service registered -- "+providedService);
+        }
+        try{
+            ServerBaseFeed retVal = new ServerBaseFeed(GDataEntityBuilder.buildFeed(request.getReader(),provServiceInstance));
+            retVal.setServiceConfig(provServiceInstance);
+        return retVal;
+        }catch (IOException e) {
+            if(LOG.isInfoEnabled())
+                LOG.info("Can not read from input stream - ",e);
+            setError(GDataResponse.BAD_REQUEST,"Can not read from input stream");
+            throw e;
+        }catch (ParseException e) {
+            if(LOG.isInfoEnabled())
+                LOG.info("feed can not be parsed - ",e);
+            setError(GDataResponse.BAD_REQUEST,"incoming feed can not be parsed");
+            throw e;
+        }
+        
+    }
+    
+    
+    protected GDataAccount createRequestedAccount(HttpServletRequest request) throws FeedHandlerException{
+        GDataServerRegistry registry = GDataServerRegistry.getRegistry();
+           ServiceFactory serviceFactory = registry.lookup(ServiceFactory.class,ComponentType.SERVICEFACTORY);
+        
+        if(serviceFactory == null){
+            setError(GDataResponse.SERVER_ERROR, "Required server component not available");
+            throw new FeedHandlerException("Required server component not available -- "+ServiceFactory.class.getName());
+        }
+        AdminService service = serviceFactory.getAdminService();
+        String account = request.getParameter(PARAMETER_ACCOUNT);
+        try{
+        return service.getAccount(account);
+        }catch (ServiceException e) {
+            if(LOG.isInfoEnabled())
+                LOG.info("no account for requested account - "+account,e);
+            setError(HttpServletResponse.SC_BAD_REQUEST,"no such account");
+            throw new FeedHandlerException(e.getMessage(),e);
+        }
+    }
+    
+    protected void sendResponse(HttpServletResponse response){
+        
+        if(!this.isError)
+            return;
+        try{
+        response.sendError(this.error,this.errorMessage);
+        }catch (IOException e) {
+            LOG.warn("can send error in RequestHandler ",e);
+        }
+    }
+    
+    protected void setError(int error, String message){
+        this.error = error;
+        this.errorMessage = message;
+        this.isError = true;
+    }
+    protected int getErrorCode(){
+        return this.error;
+    }
+    
+    protected String getErrorMessage(){
+        return this.errorMessage;
+    }
+    
+    static class FeedHandlerException extends Exception{
+
+        /**
+         * 
+         */
+        private static final long serialVersionUID = 1L;
+
+        /**
+         * Creates a new FeedHandlerException with a exception message and the exception cause this ex.
+         * @param arg0 - the message
+         * @param arg1 - the cause
+         */
+        public FeedHandlerException(String arg0, Throwable arg1) {
+            super(arg0, arg1);
+       
+        }
+
+        /**
+         * Creates a new FeedHandlerException with a exception message.
+         * @param arg0 - message
+         */
+        public FeedHandlerException(String arg0) {
+            super(arg0 );
+            
+        }
+        
+    }
+    
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/AbstractGdataRequestHandler.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/AbstractGdataRequestHandler.java
new file mode 100644
index 0000000..d914014
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/AbstractGdataRequestHandler.java
@@ -0,0 +1,110 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.servlet.handler;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.server.GDataRequest;
+import org.apache.lucene.gdata.server.GDataRequestException;
+import org.apache.lucene.gdata.server.GDataResponse;
+import org.apache.lucene.gdata.server.Service;
+import org.apache.lucene.gdata.server.ServiceFactory;
+import org.apache.lucene.gdata.server.GDataRequest.GDataRequestType;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public abstract class AbstractGdataRequestHandler extends RequestAuthenticator implements
+        GDataRequestHandler {
+    private final static Log LOG = LogFactory
+            .getLog(AbstractGdataRequestHandler.class);
+    /*
+     * UTF-8 is the encoding used in the client API to send the entries to the server
+     */
+    private final static String ENCODING = "UTF-8";
+    protected Service service;
+    protected GDataRequest feedRequest;
+    protected GDataResponse feedResponse;
+
+    /**
+     * @see org.apache.lucene.gdata.servlet.handler.GDataRequestHandler#processRequest(javax.servlet.http.HttpServletRequest,
+     *      javax.servlet.http.HttpServletResponse)
+     */
+    public abstract void processRequest(HttpServletRequest request,
+            HttpServletResponse response) throws ServletException, IOException;
+
+    protected void initializeRequestHandler(final HttpServletRequest request, final HttpServletResponse response, final GDataRequestType type)
+            throws GDataRequestException, ServletException {
+        this.feedRequest = new GDataRequest(request, type);
+        this.feedResponse = new GDataResponse(response);
+        this.feedResponse.setEncoding(ENCODING);
+        
+        try {       
+            this.feedRequest.initializeRequest();
+        } catch (GDataRequestException e) {
+            setError(e.getErrorCode());
+            LOG.warn("Couldn't initialize FeedRequest - " + e.getMessage(), e);
+            throw e;
+        }
+        getService(this.feedRequest);
+    }
+
+    
+
+    protected void sendError() throws IOException {
+        this.feedResponse.sendError();
+        
+    }
+
+	protected void setFeedResponseFormat() {
+		this.feedResponse.setOutputFormat(this.feedRequest.getRequestedResponseFormat());
+	}
+
+	protected void setFeedResponseStatus(int status) {
+		this.feedResponse.setResponseCode(status);
+	}
+
+	protected void setError(int error) {
+		this.feedResponse.setError(error);
+	}
+
+    private void getService(GDataRequest request) throws ServletException {
+        GDataServerRegistry registry = GDataServerRegistry.getRegistry();
+        ServiceFactory serviceFactory = registry.lookup(ServiceFactory.class,ComponentType.SERVICEFACTORY);
+        this.service = serviceFactory.getService(request);
+        if(this.service == null)
+            throw new ServletException("Service not available"); 
+        
+    }
+    
+    protected void closeService(){
+        this.service.close();
+    }
+
+
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/AuthenticationHandler.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/AuthenticationHandler.java
new file mode 100644
index 0000000..6161fbe
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/AuthenticationHandler.java
@@ -0,0 +1,132 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.servlet.handler;
+
+import java.io.IOException;
+import java.io.Writer;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.server.GDataResponse;
+import org.apache.lucene.gdata.server.ServiceException;
+import org.apache.lucene.gdata.server.ServiceFactory;
+import org.apache.lucene.gdata.server.administration.AdminService;
+import org.apache.lucene.gdata.server.authentication.AuthenticationController;
+import org.apache.lucene.gdata.server.authentication.AuthenticationException;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
+
+
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class AuthenticationHandler implements GDataRequestHandler {
+    private static final Log LOG = LogFactory.getLog(AuthenticationHandler.class);
+    private final AuthenticationController controller;
+    private final static String errorKey = "Error";
+    private final static char seperatory = '=';
+    private final ServiceFactory serviceFactory;
+    private final GDataServerRegistry registry;
+    /**
+     * 
+     */
+    public AuthenticationHandler() {
+        this.registry = GDataServerRegistry.getRegistry();
+        this.controller = this.registry.lookup(AuthenticationController.class, ComponentType.AUTHENTICATIONCONTROLLER);
+        this.serviceFactory = this.registry.lookup(ServiceFactory.class, ComponentType.SERVICEFACTORY);
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.servlet.handler.GDataRequestHandler#processRequest(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
+     */
+    @SuppressWarnings("unused")
+    public void processRequest(HttpServletRequest request,
+            HttpServletResponse response) throws ServletException, IOException {
+        
+        try {
+        String serviceName = request.getParameter(AuthenticationController.SERVICE_PARAMETER);
+        if(LOG.isInfoEnabled()){
+            String application = request.getParameter(AuthenticationController.APPLICATION_PARAMETER);
+            LOG.info("Authentication request for service: "+serviceName+"; Application name: "+application);
+        }
+        
+        if(!this.registry.isServiceRegistered(serviceName))
+            throw new AuthenticationException("requested Service "+serviceName+"is not registered");
+        String password = request.getParameter(AuthenticationController.PASSWORD_PARAMETER);
+        String accountName = request.getParameter(AuthenticationController.ACCOUNT_PARAMETER);
+        String clientIp = request.getRemoteHost();
+        
+       
+        
+        GDataAccount  account = getAccount(accountName);
+        if(account == null || !account.getPassword().equals(password))
+            throw new AuthenticationException("Account is null or password does not match");
+        
+        String token = this.controller.authenticatAccount(account,clientIp);
+        sendToken(response,token);
+        if(LOG.isInfoEnabled()){
+            
+            LOG.info("Account authenticated -- "+account);
+        }
+        } catch (AuthenticationException e){
+            LOG.error("BadAuthentication -- "+e.getMessage(),e);
+            sendError(response, GDataResponse.FORBIDDEN,"BadAuthentication");
+        }catch (Exception e) {
+            LOG.error("Unexpected Exception -- SERVERERROR -- "+e.getMessage(),e);
+            sendError(response,GDataResponse.SERVER_ERROR, "Service not available");
+        }
+    }
+    
+    
+   private GDataAccount getAccount(String accountName) throws ServiceException{
+       
+       AdminService service = this.serviceFactory.getAdminService();
+       try{
+       return service.getAccount(accountName);
+       }finally{
+            service.close();
+       }
+            
+        
+    }
+   private void sendError(HttpServletResponse response, int code, String message)throws IOException{
+       Writer writer = response.getWriter();
+       writer.write(errorKey);
+       writer.write(seperatory);
+       writer.write(message);
+       response.sendError(code);
+   }
+   
+   private void sendToken(HttpServletResponse response, String token) throws IOException{
+       Writer responseWriter = response.getWriter();
+       Cookie cookie = new Cookie(AuthenticationController.TOKEN_KEY,token);
+       response.addCookie(cookie);
+       responseWriter.write(AuthenticationController.TOKEN_KEY);
+       responseWriter.write(seperatory);
+       responseWriter.write(token);
+       responseWriter.close();
+   }
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/DefaultDeleteHandler.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/DefaultDeleteHandler.java
new file mode 100644
index 0000000..7d33bdb
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/DefaultDeleteHandler.java
@@ -0,0 +1,86 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.servlet.handler;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
+import org.apache.lucene.gdata.server.GDataRequestException;
+import org.apache.lucene.gdata.server.GDataResponse;
+import org.apache.lucene.gdata.server.ServiceException;
+import org.apache.lucene.gdata.server.GDataRequest.GDataRequestType;
+
+/**
+ * Default Handler implementation. This handler processes the incoming
+ * {@link org.apache.lucene.gdata.server.GDataRequest} and deletes the requested
+ * feed entry from the storage and the search component.
+ * <p>
+ * The handler sends following response to the client:
+ * </p>
+ * <ol>
+ * <li>if the entry could be deleted - HTTP status code <i>200 OK</i></li>
+ * <li>if an error occurs - HTTP status code <i>500 INTERNAL SERVER ERROR</i></li>
+ * <li>if the resource could not found - HTTP status code <i>404 NOT FOUND</i></li>
+ * </ol>
+ *  
+ * @author Simon Willnauer
+ * 
+ */
+public class DefaultDeleteHandler extends AbstractGdataRequestHandler {
+	private static final Log LOG = LogFactory
+			.getLog(DefaultDeleteHandler.class);
+
+	/**
+	 * @throws ServletException 
+	 * @see org.apache.lucene.gdata.servlet.handler.AbstractGdataRequestHandler#processRequest(javax.servlet.http.HttpServletRequest,
+	 *      javax.servlet.http.HttpServletResponse)
+	 */
+	@Override
+	public void processRequest(HttpServletRequest request,
+			HttpServletResponse response) throws IOException, ServletException {
+		try {
+			initializeRequestHandler(request, response,GDataRequestType.DELETE);
+		} catch (GDataRequestException e) {
+			sendError();
+			return;
+		}
+        if(!authenticateAccount(request,AccountRole.ENTRYAMINISTRATOR)){
+            setError(GDataResponse.UNAUTHORIZED);
+            sendError();
+            return;
+        }
+		
+		try {
+			this.service.deleteEntry(this.feedRequest, this.feedResponse);
+		
+		} catch (ServiceException e) {
+			LOG.error("Could not process DeleteFeed request - "
+					+ e.getMessage(), e);
+            setError(e.getErrorCode());
+			sendError();
+		}finally{
+        closeService();
+        }
+	}
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/DefaultGetHandler.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/DefaultGetHandler.java
new file mode 100644
index 0000000..d1fed95
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/DefaultGetHandler.java
@@ -0,0 +1,140 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.servlet.handler;
+
+import java.io.IOException;
+import java.util.Date;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.server.GDataRequestException;
+import org.apache.lucene.gdata.server.Service;
+import org.apache.lucene.gdata.server.ServiceException;
+import org.apache.lucene.gdata.server.GDataRequest.GDataRequestType;
+import org.apache.lucene.gdata.utils.DateFormater;
+
+import com.google.gdata.data.BaseEntry;
+import com.google.gdata.data.BaseFeed;
+
+/**
+ * Default Handler implementation. This handler processes the incoming
+ * {@link org.apache.lucene.gdata.server.GDataRequest} and retrieves the
+ * requested feed from the underlying storage.
+ * <p>
+ * This hander also processes search queries and retrieves the search hits from
+ * the underlying search component. The user query will be accessed via the
+ * {@link org.apache.lucene.gdata.server.GDataRequest} instance passed to the
+ * {@link Service} class.
+ * </p>
+ * <p>
+ * The DefaultGetHandler supports HTTP Conditional GET. It set the Last-Modified
+ * response header based upon the value of the <atom:updated> element in the
+ * returned feed or entry. A client can send this value back as the value of the
+ * If-Modified-Since request header to avoid retrieving the content again if it
+ * hasn't changed. If the content hasn't changed since the If-Modified-Since
+ * time, then the GData service returns a 304 (Not Modified) HTTP response.</p>
+ * 
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class DefaultGetHandler extends AbstractGdataRequestHandler {
+    private static final Log LOG = LogFactory.getLog(DefaultGetHandler.class);
+
+    /**
+     * @see org.apache.lucene.gdata.servlet.handler.AbstractGdataRequestHandler#processRequest(javax.servlet.http.HttpServletRequest,
+     *      javax.servlet.http.HttpServletResponse)
+     */
+    @Override
+    public void processRequest(HttpServletRequest request,
+            HttpServletResponse response) throws IOException, ServletException {
+        try {
+            initializeRequestHandler(request, response, GDataRequestType.GET);
+        } catch (GDataRequestException e) {
+            sendError();
+            return;
+        }
+
+        try {
+            String modifiedSince = this.feedRequest.getModifiedSince();
+            if (!checkIsModified(modifiedSince)) {
+                this.feedResponse
+                        .setStatus(HttpServletResponse.SC_NOT_MODIFIED);
+                return;
+            }
+            if (LOG.isInfoEnabled())
+                LOG.info("Requested output formate: "
+                        + this.feedRequest.getRequestedResponseFormat());
+            this.feedResponse.setOutputFormat(this.feedRequest
+                    .getRequestedResponseFormat());
+            if (this.feedRequest.isFeedRequested()) {
+                BaseFeed feed = this.service.getFeed(this.feedRequest,
+                        this.feedResponse);
+
+                this.feedResponse.sendResponse(feed, this.feedRequest
+                        .getConfigurator());
+            } else {
+                BaseEntry entry = this.service.getSingleEntry(this.feedRequest,
+                        this.feedResponse);
+                this.feedResponse.sendResponse(entry, this.feedRequest
+                        .getConfigurator());
+            }
+
+        } catch (ServiceException e) {
+            LOG.error("Could not process GetFeed request - " + e.getMessage(),
+                    e);
+            setError(e.getErrorCode());
+            sendError();
+        }finally{
+        closeService();
+        }
+    }
+
+    /**
+     * 
+     * returns true if the resource has been modified since the specified
+     * request header value
+     */
+    protected boolean checkIsModified(String lastModified)
+            throws ServiceException {
+        if (lastModified == null)
+            return true;
+        try {
+            Date clientDate = DateFormater.parseDate(lastModified,DateFormater.HTTP_HEADER_DATE_FORMAT,DateFormater.HTTP_HEADER_DATE_FORMAT_TIME_OFFSET);
+            Date entityDate;
+            if (this.feedRequest.isFeedRequested())
+                entityDate = this.service.getFeedLastModified(this.feedRequest
+                        .getFeedId());
+            else
+                entityDate = this.service.getEntryLastModified(this.feedRequest
+                        .getEntryId(),this.feedRequest.getFeedId());
+            if(LOG.isInfoEnabled())
+                LOG.info("comparing date clientDate: "+clientDate+"; last modified: "+entityDate);
+            return (entityDate.getTime()-clientDate.getTime() > 1000);
+        } catch (java.text.ParseException e) {
+            LOG.info("Couldn't parse Last-Modified header -- "+lastModified,e);
+
+        }
+        return true;
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/DefaultInsertHandler.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/DefaultInsertHandler.java
new file mode 100644
index 0000000..f37a0f9
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/DefaultInsertHandler.java
@@ -0,0 +1,89 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.servlet.handler;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
+import org.apache.lucene.gdata.server.GDataRequestException;
+import org.apache.lucene.gdata.server.GDataResponse;
+import org.apache.lucene.gdata.server.ServiceException;
+import org.apache.lucene.gdata.server.GDataRequest.GDataRequestType;
+
+import com.google.gdata.data.BaseEntry;
+
+/**
+ * Default Handler implementation. This handler processes the incoming
+ * {@link org.apache.lucene.gdata.server.GDataRequest} and inserts the requested
+ * feed entry into the storage and the search component.
+ * <p>
+ * The handler sends following response to the client:
+ * </p>
+ * <ol>
+ * <li>if the entry was added - HTTP status code <i>200 OK</i></li>
+ * <li>if an error occurs - HTTP status code <i>500 INTERNAL SERVER ERROR</i></li>
+ * <li>if the resource could not found - HTTP status code <i>404 NOT FOUND</i></li>
+ * </ol>
+ * <p>The added entry will be send back to the client if the insert request was successful.</p>
+ * 
+ * @author Simon Willnauer
+ *
+ */
+public class DefaultInsertHandler extends AbstractGdataRequestHandler {
+    private static final Log LOG = LogFactory.getLog(DefaultInsertHandler.class);
+    /**
+     * @throws ServletException 
+     * @see org.apache.lucene.gdata.servlet.handler.GDataRequestHandler#processRequest(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
+     */
+    @Override
+	public void processRequest(HttpServletRequest request,
+            HttpServletResponse response) throws IOException, ServletException {
+        try {
+            initializeRequestHandler(request,response,GDataRequestType.INSERT);            
+        } catch (GDataRequestException e) {
+            sendError();
+            return;
+        }
+        if(!authenticateAccount(this.feedRequest,AccountRole.ENTRYAMINISTRATOR)){
+            setError(GDataResponse.UNAUTHORIZED);
+            sendError();
+            return;
+        }
+       
+        try{        
+        BaseEntry entry = this.service.createEntry(this.feedRequest,this.feedResponse);
+        setFeedResponseFormat();
+        setFeedResponseStatus(GDataResponse.CREATED);        
+        this.feedResponse.sendResponse(entry, this.feedRequest.getConfigurator());
+        
+        }catch (ServiceException e) {
+           LOG.error("Could not process GetFeed request - "+e.getMessage(),e);
+           setError(e.getErrorCode());
+           sendError();
+        }finally{
+        closeService();
+        }
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/DefaultRequestHandlerFactory.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/DefaultRequestHandlerFactory.java
new file mode 100644
index 0000000..d101338
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/DefaultRequestHandlerFactory.java
@@ -0,0 +1,150 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.servlet.handler;
+
+import org.apache.lucene.gdata.server.registry.Component;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+
+/**
+ * Default implementation for RequestHandlerFactory Builds the
+ * {@link org.apache.lucene.gdata.servlet.handler.GDataRequestHandler}
+ * instances.
+ * This class should not be access directy. The class will be registered in the {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry}.
+ * Use {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry#lookup(Class, ComponentType)}
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+@Component(componentType=ComponentType.REQUESTHANDLERFACTORY)
+public class DefaultRequestHandlerFactory extends RequestHandlerFactory {
+
+
+    /**
+     * public constructor to enable loading via the registry
+     * @see org.apache.lucene.gdata.server.registry.Component
+     * @see org.apache.lucene.gdata.server.registry.GDataServerRegistry
+     */
+	public DefaultRequestHandlerFactory() {
+		//
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.servlet.handler.RequestHandlerFactory#getEntryUpdateHandler()
+	 */
+	@Override
+	public GDataRequestHandler getEntryUpdateHandler() {
+
+		return new DefaultUpdateHandler();
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.servlet.handler.RequestHandlerFactory#getEntryDeleteHandler()
+	 */
+	@Override
+	public GDataRequestHandler getEntryDeleteHandler() {
+
+		return new DefaultDeleteHandler();
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.servlet.handler.RequestHandlerFactory#getFeedQueryHandler()
+	 */
+	@Override
+	public GDataRequestHandler getFeedQueryHandler() {
+
+		return new DefaultGetHandler();
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.servlet.handler.RequestHandlerFactory#getEntryInsertHandler()
+	 */
+	@Override
+	public GDataRequestHandler getEntryInsertHandler() {
+
+		return new DefaultInsertHandler();
+	}
+
+    /**
+     * @see org.apache.lucene.gdata.servlet.handler.RequestHandlerFactory#getInsertAccountHandler()
+     */
+    @Override
+    public GDataRequestHandler getInsertAccountHandler() {
+        
+        return new InsertAccountStrategy();
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.servlet.handler.RequestHandlerFactory#getDeleteAccountHandler()
+     */
+    @Override
+    public GDataRequestHandler getDeleteAccountHandler() {
+        
+        return new DeleteAccountStrategy();
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.servlet.handler.RequestHandlerFactory#getUpdateAccountHandler()
+     */
+    @Override
+    public GDataRequestHandler getUpdateAccountHandler() {
+        
+        return new UpdateAccountStrategy();
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.servlet.handler.RequestHandlerFactory#getInsertFeedHandler()
+     */
+    @Override
+    public GDataRequestHandler getInsertFeedHandler() {
+        
+        return new InsertFeedHandler();
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.servlet.handler.RequestHandlerFactory#getUpdateFeedHandler()
+     */
+    @Override
+    public GDataRequestHandler getUpdateFeedHandler() {
+        
+        return new UpdateFeedHandler();
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.servlet.handler.RequestHandlerFactory#getDeleteFeedHandler()
+     */
+    @Override
+    public GDataRequestHandler getDeleteFeedHandler() {
+        
+        return new DeleteFeedHandler();
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.registry.ServerComponent#initialize()
+     */
+    public void initialize() {
+        //
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.registry.ServerComponent#destroy()
+     */
+    public void destroy() {
+        //
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/DefaultUpdateHandler.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/DefaultUpdateHandler.java
new file mode 100644
index 0000000..e22b724
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/DefaultUpdateHandler.java
@@ -0,0 +1,92 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.servlet.handler;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
+import org.apache.lucene.gdata.server.GDataRequestException;
+import org.apache.lucene.gdata.server.GDataResponse;
+import org.apache.lucene.gdata.server.ServiceException;
+import org.apache.lucene.gdata.server.GDataRequest.GDataRequestType;
+
+import com.google.gdata.data.BaseEntry;
+
+/**
+ * Default Handler implementation. This handler processes the incoming
+ * {@link org.apache.lucene.gdata.server.GDataRequest} and updates the requested
+ * feed entry in the storage and the search component.
+ * <p>
+ * The handler sends following response to the client:
+ * </p>
+ * <ol>
+ * <li>if the entry was successfully updated - HTTP status code <i>200 OK</i></li>
+ * <li>if an error occurs - HTTP status code <i>500 INTERNAL SERVER ERROR</i></li>
+ * <li>if the resource could not found - HTTP status code <i>404 NOT FOUND</i></li>
+ * </ol>
+ * 
+ * @author Simon Willnauer
+ *  
+ */
+public class DefaultUpdateHandler extends AbstractGdataRequestHandler {
+	private static final Log LOG = LogFactory
+			.getLog(DefaultUpdateHandler.class);
+
+	/**
+	 * @throws ServletException 
+	 * @see org.apache.lucene.gdata.servlet.handler.AbstractGdataRequestHandler#processRequest(javax.servlet.http.HttpServletRequest,
+	 *      javax.servlet.http.HttpServletResponse)
+	 */
+	@Override
+	public void processRequest(HttpServletRequest request,
+			HttpServletResponse response) throws  IOException, ServletException {
+		try {
+			initializeRequestHandler(request, response,GDataRequestType.UPDATE);
+		} catch (GDataRequestException e) {
+            setError(GDataResponse.UNAUTHORIZED);
+			sendError();
+			return;
+		}
+        if(!authenticateAccount(request,AccountRole.ENTRYAMINISTRATOR)){
+            sendError();
+            return;
+        }
+        
+		try {
+			BaseEntry entry = this.service.updateEntry(this.feedRequest,
+					this.feedResponse);
+			setFeedResponseFormat();
+			this.feedResponse.sendResponse(entry, this.feedRequest.getConfigurator());
+		
+		}
+		catch (ServiceException e) {
+			LOG.error("Could not process UpdateFeed request - "
+					+ e.getMessage(), e);
+            setError(e.getErrorCode());
+			sendError();
+		}finally{
+        closeService();
+        }
+	}
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/DeleteAccountStrategy.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/DeleteAccountStrategy.java
new file mode 100644
index 0000000..b808a2a
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/DeleteAccountStrategy.java
@@ -0,0 +1,45 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.servlet.handler;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.server.ServiceException;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class DeleteAccountStrategy extends AbstractAccountHandler {
+
+    private static final Log LOG = LogFactory.getLog(DefaultDeleteHandler.class);
+
+    
+
+    @Override
+    protected void processServiceAction(GDataAccount account) throws ServiceException {
+        try{
+        this.service.deleteAccount(account);
+        }catch (ServiceException e) {
+            LOG.error("Can't delete account -- "+e.getMessage(),e);
+            throw e;
+        }
+        
+    }
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/DeleteFeedHandler.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/DeleteFeedHandler.java
new file mode 100644
index 0000000..881432a
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/DeleteFeedHandler.java
@@ -0,0 +1,90 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.servlet.handler;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.ServerBaseFeed;
+import org.apache.lucene.gdata.server.GDataResponse;
+import org.apache.lucene.gdata.server.ServiceException;
+import org.apache.lucene.gdata.server.ServiceFactory;
+import org.apache.lucene.gdata.server.administration.AdminService;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class DeleteFeedHandler extends AbstractFeedHandler{
+    private static final Log LOG = LogFactory.getLog(DeleteFeedHandler.class);
+
+    /**
+     * @throws IOException 
+     * @see org.apache.lucene.gdata.servlet.handler.GDataRequestHandler#processRequest(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
+     */
+    @Override
+    public void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
+            super.processRequest(request,response);
+            if(this.authenticated){
+                AdminService service = null;
+            try {
+                ServerBaseFeed feed = createDeleteFeed(request);
+                
+                GDataServerRegistry registry = GDataServerRegistry.getRegistry();
+                ServiceFactory serviceFactory = registry.lookup(ServiceFactory.class,ComponentType.SERVICEFACTORY);
+                if(serviceFactory == null){
+                    setError(GDataResponse.SERVER_ERROR,"required component is not available");
+                    throw new FeedHandlerException("Can't save feed - ServiceFactory is null");
+                }
+                service = serviceFactory.getAdminService();
+                service.deleteFeed(feed);
+            } catch (FeedHandlerException e) {
+                LOG.error("Can not delete feed -- "+e.getMessage(),e);
+            }catch (ServiceException e) {
+                LOG.error("Can not delete feed -- "+e.getMessage(),e);
+                setError(e.getErrorCode(),"can not create feed");
+            }finally{
+                if(service != null)
+                    service.close();
+            }
+            }
+            sendResponse(response);
+           
+        
+        
+    }
+
+    private ServerBaseFeed createDeleteFeed(final HttpServletRequest request) throws FeedHandlerException {
+        String feedId = request.getParameter("feedid");
+        if(feedId == null){
+            setError(GDataResponse.BAD_REQUEST,"No feed id specified");
+            throw new FeedHandlerException("no feed Id specified");
+        }
+        ServerBaseFeed retVal = new ServerBaseFeed();
+        retVal.setId(feedId);
+        return retVal;
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/GDataRequestHandler.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/GDataRequestHandler.java
new file mode 100644
index 0000000..c42785c
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/GDataRequestHandler.java
@@ -0,0 +1,55 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */ 
+package org.apache.lucene.gdata.servlet.handler; 
+ 
+import java.io.IOException; 
+ 
+import javax.servlet.ServletException; 
+import javax.servlet.http.HttpServletRequest; 
+import javax.servlet.http.HttpServletResponse; 
+ 
+/** 
+ *  
+ * Based on the Command pattern [GoF], the Command and Controller Strategy 
+ * suggests providing a generic interface to the handler components to which the 
+ * controller may delegate responsibility, minimizing the coupling among these 
+ * components. 
+ *  
+ * Adding to or changing the work that needs to be completed by these handlers 
+ * does not require any changes to the interface between the controller and the 
+ * handlers, but rather to the type and/or content of the commands. This provides 
+ * a flexible and easily extensible mechanism for developers to add request 
+ * handling behaviors. 
+ *  
+ * The controller invokes the processRequest method from the corresponding servlet <i>doXXX</i> 
+ * method to delegate the request to the handler. 
+ *   
+ *  
+ * @author Simon Willnauer 
+ *  
+ */ 
+public interface GDataRequestHandler { 
+    /** 
+     * Processes the GDATA Client request 
+     *  
+     * @param request - the client request to be processed 
+     * @param response - the response to the client request 
+     * @throws ServletException - if a servlet exception is thrown by the request or response   
+     * @throws IOException -  if an input/output error occurs due to accessing an IO steam 
+     */ 
+    public abstract void processRequest(HttpServletRequest request, 
+            HttpServletResponse response) throws ServletException, IOException; 
+} 
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/GDataRequestHandlerException.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/GDataRequestHandlerException.java
new file mode 100644
index 0000000..0c1c593
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/GDataRequestHandlerException.java
@@ -0,0 +1,64 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */ 
+ 
+package org.apache.lucene.gdata.servlet.handler; 
+ 
+/** 
+ * @author Simon Willnauer 
+ * 
+ */ 
+public class GDataRequestHandlerException extends RuntimeException { 
+ 
+    /** 
+     *  
+     */ 
+    private static final long serialVersionUID = -418225239671624153L; 
+    
+ 
+    /** 
+     *  
+     */ 
+    public GDataRequestHandlerException() { 
+        super(); 
+        
+    } 
+ 
+    /** 
+     * @param arg0 
+     */ 
+    public GDataRequestHandlerException(String arg0) { 
+        super(arg0); 
+        
+    } 
+ 
+    /** 
+     * @param arg0 
+     * @param arg1 
+     */ 
+    public GDataRequestHandlerException(String arg0, Throwable arg1) { 
+        super(arg0, arg1); 
+        
+    } 
+ 
+    /** 
+     * @param arg0 
+     */ 
+    public GDataRequestHandlerException(Throwable arg0) { 
+        super(arg0); 
+        
+    } 
+ 
+} 
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/InsertAccountStrategy.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/InsertAccountStrategy.java
new file mode 100644
index 0000000..f13eaeb
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/InsertAccountStrategy.java
@@ -0,0 +1,49 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.servlet.handler;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.server.ServiceException;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class InsertAccountStrategy extends AbstractAccountHandler {
+    private static final Log LOG = LogFactory.getLog(InsertAccountStrategy.class);
+   
+  
+
+    @Override
+    protected void processServiceAction(GDataAccount account) throws ServiceException {
+        try{
+        this.service.createAccount(account);
+        }catch (ServiceException e) {
+            LOG.error("Can't create account -- "+e.getMessage(),e);
+            throw e;
+        }
+        
+    }
+
+
+
+    
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/InsertFeedHandler.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/InsertFeedHandler.java
new file mode 100644
index 0000000..bda76f6
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/InsertFeedHandler.java
@@ -0,0 +1,90 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.servlet.handler;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.data.ServerBaseFeed;
+import org.apache.lucene.gdata.server.GDataResponse;
+import org.apache.lucene.gdata.server.ServiceException;
+import org.apache.lucene.gdata.server.ServiceFactory;
+import org.apache.lucene.gdata.server.administration.AdminService;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
+
+import com.google.gdata.util.ParseException;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class InsertFeedHandler extends AbstractFeedHandler {
+    private static final Log LOG = LogFactory.getLog(InsertFeedHandler.class);
+
+    /**
+     * @see org.apache.lucene.gdata.servlet.handler.GDataRequestHandler#processRequest(javax.servlet.http.HttpServletRequest,
+     *      javax.servlet.http.HttpServletResponse)
+     */
+    @SuppressWarnings("unused")
+    public void processRequest(HttpServletRequest request,
+            HttpServletResponse response) throws ServletException, IOException {
+        super.processRequest(request, response);
+        if (this.authenticated) {
+            AdminService service = null;
+            try {
+                ServerBaseFeed feed = createFeedFromRequest(request);
+                GDataAccount account = createRequestedAccount(request);
+
+                GDataServerRegistry registry = GDataServerRegistry
+                        .getRegistry();
+                ServiceFactory serviceFactory = registry.lookup(
+                        ServiceFactory.class, ComponentType.SERVICEFACTORY);
+                if (serviceFactory == null) {
+                    setError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
+                            "required component is not available");
+                    throw new FeedHandlerException(
+                            "Can't save feed - ServiceFactory is null");
+                }
+                service = serviceFactory.getAdminService();
+                service.createFeed(feed, account);
+            } catch (ServiceException e) {
+                setError(GDataResponse.SERVER_ERROR,
+                        "can not create feed");
+                LOG.error("Can not create feed -- " + e.getMessage(), e);
+            } catch (FeedHandlerException e) {
+                LOG.error("Can not create feed -- " + e.getMessage(), e);
+
+            }catch (ParseException e) {
+                LOG.error("Can not create feed -- " + e.getMessage(), e);
+            }finally{
+                if(service != null)
+                    service.close();
+            }
+
+        }
+        sendResponse(response);
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/RequestAuthenticator.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/RequestAuthenticator.java
new file mode 100644
index 0000000..9527987
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/RequestAuthenticator.java
@@ -0,0 +1,151 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.servlet.handler;
+
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServletRequest;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
+import org.apache.lucene.gdata.server.GDataRequest;
+import org.apache.lucene.gdata.server.ServiceException;
+import org.apache.lucene.gdata.server.ServiceFactory;
+import org.apache.lucene.gdata.server.administration.AdminService;
+import org.apache.lucene.gdata.server.authentication.AuthenticationController;
+import org.apache.lucene.gdata.server.authentication.AuthenticatorException;
+import org.apache.lucene.gdata.server.authentication.GDataHttpAuthenticator;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
+
+/**
+ * The RequestAuthenticator provides access to the registered
+ * {@link org.apache.lucene.gdata.server.authentication.AuthenticationController}
+ * as a super class for all request handler requiereing authentication for
+ * access. This class implements the
+ * {@link org.apache.lucene.gdata.server.authentication.GDataHttpAuthenticator}
+ * to get the auth token from the given request and call the needed Components
+ * to authenticat the client.
+ * <p>
+ * For request handler handling common requests like entry insert or update the
+ * authentication will be based on the account name verified as the owner of the
+ * feed to alter. If the accountname in the token does not match the name of the
+ * account which belongs to the feed the given role will be used for
+ * autentication. Authentication using the
+ * {@link RequestAuthenticator#authenticateAccount(HttpServletRequest, AccountRole)}
+ * method, the account name will be ignored, authentication will be based on the
+ * given <tt>AccountRole</tt>
+ * </p>
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class RequestAuthenticator implements GDataHttpAuthenticator {
+    private static final Log LOG = LogFactory
+            .getLog(RequestAuthenticator.class);
+
+    /**
+     * @see org.apache.lucene.gdata.server.authentication.GDataHttpAuthenticator#authenticateAccount(org.apache.lucene.gdata.server.GDataRequest,
+     *      org.apache.lucene.gdata.data.GDataAccount.AccountRole)
+     */
+    public boolean authenticateAccount(GDataRequest request, AccountRole role) {
+        String clientIp = request.getRemoteAddress();
+        if (LOG.isDebugEnabled())
+            LOG
+                    .debug("Authenticating Account for GDataRequest -- modifying entries -- Role: "
+                            + role + "; ClientIp: " + clientIp);
+
+        AuthenticationController controller = GDataServerRegistry.getRegistry()
+                .lookup(AuthenticationController.class,
+                        ComponentType.AUTHENTICATIONCONTROLLER);
+        ServiceFactory factory = GDataServerRegistry.getRegistry().lookup(
+                ServiceFactory.class, ComponentType.SERVICEFACTORY);
+        AdminService adminService = factory.getAdminService();
+        GDataAccount account;
+        try {
+            account = adminService.getFeedOwningAccount(request.getFeedId());
+            String token = getTokenFromRequest(request.getHttpServletRequest());
+            if (LOG.isDebugEnabled())
+                LOG.debug("Got Token: " + token + "; for requesting account: "
+                        + account);
+            if (account != null && token != null)
+                return controller.authenticateToken(token, clientIp,
+                        AccountRole.ENTRYAMINISTRATOR, account.getName());
+
+        } catch (ServiceException e) {
+            LOG.error("can get GDataAccount for feedID -- "
+                    + request.getFeedId(), e);
+            throw new AuthenticatorException(" Service exception occured", e);
+
+        }finally{
+        
+            if(adminService!=null)
+                adminService.close();
+        
+        }
+
+        return false;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.authentication.GDataHttpAuthenticator#authenticateAccount(javax.servlet.http.HttpServletRequest,
+     *      org.apache.lucene.gdata.data.GDataAccount.AccountRole)
+     */
+    public boolean authenticateAccount(HttpServletRequest request,
+            AccountRole role) {
+        String clientIp = request.getRemoteAddr();
+        if (LOG.isDebugEnabled())
+            LOG
+                    .debug("Authenticating Account for GDataRequest -- modifying entries -- Role: "
+                            + role + "; ClientIp: " + clientIp);
+        AuthenticationController controller = GDataServerRegistry.getRegistry()
+                .lookup(AuthenticationController.class,
+                        ComponentType.AUTHENTICATIONCONTROLLER);
+        String token = getTokenFromRequest(request);
+        if (LOG.isDebugEnabled())
+            LOG.debug("Got Token: " + token + ";");
+        if (token == null)
+            return false;
+        return controller.authenticateToken(token, clientIp, role, null);
+
+    }
+
+    protected String getTokenFromRequest(HttpServletRequest request) {
+        String token = request
+                .getHeader(AuthenticationController.AUTHORIZATION_HEADER);
+        if (token == null || !token.startsWith("GoogleLogin")) {
+            Cookie[] cookies = request.getCookies();
+            if (cookies == null) {
+                return null;
+            }
+            for (int i = 0; i < cookies.length; i++) {
+                if (cookies[i].getName().equals(
+                        AuthenticationController.TOKEN_KEY)) {
+                    token = cookies[i].getValue();
+                    break;
+                }
+
+            }
+        }
+        if (token != null)
+            token = token.substring(token.indexOf("=") + 1);
+        return token;
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/RequestHandlerFactory.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/RequestHandlerFactory.java
new file mode 100644
index 0000000..b3a9cd6
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/RequestHandlerFactory.java
@@ -0,0 +1,99 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.servlet.handler;
+
+import org.apache.lucene.gdata.server.registry.ServerComponent;
+
+/**
+ * Abstract Superclass for RequestHandlerFactories
+ * @author Simon Willnauer
+ * 
+ */
+public abstract class RequestHandlerFactory implements ServerComponent {
+    
+
+
+
+    /**
+     * public constructor to enable loading via the registry
+     * @see org.apache.lucene.gdata.server.registry.Component
+     * @see org.apache.lucene.gdata.server.registry.GDataServerRegistry
+     */
+    public RequestHandlerFactory() {
+        super();
+
+    }
+
+
+    /**
+     * Creates a EntryUpdateHandler which processes a GDATA UPDATE request.
+     * @return - a RequestHandlerInstance
+     */
+    public abstract GDataRequestHandler getEntryUpdateHandler();
+
+    /**
+     * Creates a EntryDeleteHandler which processes a GDATA DELETE request.
+     * @return - a RequestHandlerInstance
+     */
+    public abstract GDataRequestHandler getEntryDeleteHandler();
+
+    /**
+     * Creates a FeedQueryHandler which processes a GDATA Query / Get request.
+     * @return - a RequestHandlerInstance
+     */
+    public abstract GDataRequestHandler getFeedQueryHandler();
+
+    /**
+     * Creates a EntryInsertHandler which processes a GDATA Insert request.
+     * @return - a RequestHandlerInstance
+     */
+    public abstract GDataRequestHandler getEntryInsertHandler();
+    /**
+     * Creates a InsertAccountHandler which processes a Account Insert request.
+     * @return - a RequestHandlerInstance
+     */
+    public abstract GDataRequestHandler getInsertAccountHandler();
+    /**
+     * Creates a DeleteAccountHandler which processes a Account Delete request.
+     * @return - a RequestHandlerInstance
+     */
+    public abstract GDataRequestHandler getDeleteAccountHandler();
+    /**
+     * Creates a UpdateAccountHandler which processes a Account Update request.
+     * @return - a RequestHandlerInstance
+     */
+    public abstract GDataRequestHandler getUpdateAccountHandler();
+    /**
+     * Creates a InsertFeedHandler which processes a Feed Insert request.
+     * @return - a RequestHandlerInstance
+     */
+    public abstract GDataRequestHandler getInsertFeedHandler();
+    /**
+     * Creates a UpdateFeedHandler which processes a Feed Insert request.
+     * @return - a RequestHandlerInstance
+     */
+    public abstract GDataRequestHandler getUpdateFeedHandler();
+    /**
+     * Creates a DeleteFeedHandler which processes a Feed Insert request.
+     * @return - a RequestHandlerInstance
+     */
+    public abstract GDataRequestHandler getDeleteFeedHandler();
+    
+
+    
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/UpdateAccountStrategy.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/UpdateAccountStrategy.java
new file mode 100644
index 0000000..38735f6
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/UpdateAccountStrategy.java
@@ -0,0 +1,45 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.servlet.handler;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.server.ServiceException;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class UpdateAccountStrategy extends AbstractAccountHandler {
+
+    private static final Log LOG = LogFactory.getLog(UpdateAccountStrategy.class);
+
+    
+
+    @Override
+    protected void processServiceAction(GDataAccount account) throws ServiceException {
+        try{
+        this.service.updateAccount(account);
+        }catch (ServiceException e) {
+            LOG.error("Can't update account -- "+e.getMessage(),e);
+            throw e;
+        }
+        
+    }
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/UpdateFeedHandler.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/UpdateFeedHandler.java
new file mode 100644
index 0000000..c6db626
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/UpdateFeedHandler.java
@@ -0,0 +1,88 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.servlet.handler;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.data.ServerBaseFeed;
+import org.apache.lucene.gdata.server.GDataResponse;
+import org.apache.lucene.gdata.server.ServiceException;
+import org.apache.lucene.gdata.server.ServiceFactory;
+import org.apache.lucene.gdata.server.administration.AdminService;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class UpdateFeedHandler extends AbstractFeedHandler {
+    private static final Log LOG = LogFactory.getLog(UpdateFeedHandler.class);
+
+    /**
+     * @see org.apache.lucene.gdata.servlet.handler.AbstractFeedHandler#processRequest(javax.servlet.http.HttpServletRequest,
+     *      javax.servlet.http.HttpServletResponse)
+     */
+    @SuppressWarnings("unused")
+    @Override
+    public void processRequest(HttpServletRequest request,
+            HttpServletResponse response) throws ServletException, IOException {
+        super.processRequest(request, response);
+        if (this.authenticated) {
+            AdminService service= null;
+            try {
+                ServerBaseFeed feed = createFeedFromRequest(request);
+                GDataAccount account = createRequestedAccount(request);
+
+                GDataServerRegistry registry = GDataServerRegistry
+                        .getRegistry();
+                ServiceFactory serviceFactory = registry.lookup(
+                        ServiceFactory.class, ComponentType.SERVICEFACTORY);
+                if (serviceFactory == null) {
+                    setError(GDataResponse.SERVER_ERROR,
+                            "required component is not available");
+                    throw new FeedHandlerException(
+                            "Can't update feed - ServiceFactory is null");
+                }
+                service = serviceFactory.getAdminService();
+                service.updateFeed(feed, account);
+            } catch (ServiceException e) {
+                setError(e.getErrorCode(),
+                        "can not update feed");
+                LOG.error("Can not update feed -- " + e.getMessage(), e);
+            } catch (Exception e) {
+
+                LOG.error("Can not update feed -- " + e.getMessage(), e);
+
+            }finally{
+                if(service != null)
+                    service.close();
+            }
+        }
+        sendResponse(response);
+        
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/package.html b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/package.html
new file mode 100644
index 0000000..c41f397
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/handler/package.html
@@ -0,0 +1,10 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
+<html> 
+<head> 
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
+   <meta name="Author" content="Simon Willnauer"> 
+</head> 
+<body> 
+GData Request Handler. 
+</body> 
+</html> 
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/package.html b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/package.html
new file mode 100644
index 0000000..ac6f4d4
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/servlet/package.html
@@ -0,0 +1,10 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
+<html> 
+<head> 
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
+   <meta name="Author" content="Simon Willnauer"> 
+</head> 
+<body> 
+Servlets acting as basic interfaces for gdata requests. 
+</body> 
+</html> 
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/IDGenerator.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/IDGenerator.java
new file mode 100644
index 0000000..35a09fd
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/IDGenerator.java
@@ -0,0 +1,180 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */ 
+ 
+package org.apache.lucene.gdata.storage; 
+ 
+import java.security.MessageDigest; 
+import java.security.NoSuchAlgorithmException; 
+import java.security.SecureRandom; 
+import java.util.concurrent.ArrayBlockingQueue; 
+import java.util.concurrent.BlockingQueue; 
+import java.util.concurrent.atomic.AtomicBoolean;
+ 
+import org.apache.commons.logging.Log; 
+import org.apache.commons.logging.LogFactory; 
+ 
+/** 
+ * This is the main entry ID generator to generate unique ids for each entry. 
+ * The Generator uses {@link java.security.SecureRandom} Numbers and the 
+ * {@link java.lang.System#currentTimeMillis()} to create a semi-unique sting; 
+ * The string will be digested by a {@link java.security.MessageDigest} which 
+ * returns a byte array. The generator encodes the byte array as a hex string. 
+ * <p> 
+ * The generated Id's will cached in a 
+ * {@link java.util.concurrent.BlockingQueue} and reproduced if an id has been 
+ * removed. 
+ * </p> 
+ *  
+ * @author Simon Willnauer 
+ *  
+ */ 
+public class IDGenerator { 
+    final AtomicBoolean stopped = new AtomicBoolean(false);
+    
+    private final SecureRandom secureRandom; 
+ 
+    private final MessageDigest mdigest; 
+ 
+    private final BlockingQueue<String> blockingQueue; 
+ 
+    private Thread runner; 
+ 
+    private static final int DEFAULT_CAPACITY = 10; 
+ 
+    protected static final Log LOGGER = LogFactory.getLog(IDGenerator.class);
+
+    private static final String RUNNER_THREAD_NAME = "GDATA-ID Generator"; 
+ 
+    /** 
+     * Constructs a new ID generator. with a fixed capacity of prebuild ids. The 
+     * default capacity is 10. Every given parameter less than 10 will be 
+     * ignored. 
+     *  
+     * @param capacity - 
+     *            capacity of the prebuild id queue 
+     * @throws NoSuchAlgorithmException - 
+     *             if the algorithm does not exist 
+     */ 
+    public IDGenerator(int capacity) throws NoSuchAlgorithmException { 
+ 
+        this.secureRandom = SecureRandom.getInstance("SHA1PRNG"); 
+        this.mdigest = MessageDigest.getInstance("SHA-1"); 
+        this.blockingQueue = new ArrayBlockingQueue<String>( 
+                (capacity < DEFAULT_CAPACITY ? DEFAULT_CAPACITY : capacity), 
+                false); 
+        startIDProducer(); 
+ 
+    } 
+ 
+    /** 
+     * This method takes a gnerated id from the IDProducer queue and retruns it. 
+     * If no ID is available this method will wait until an ID is produced. This 
+     * implementation is thread-safe. 
+     *  
+     * @return a UID 
+     * @throws InterruptedException - 
+     *             if interrupted while waiting 
+     */ 
+    public String getUID() throws InterruptedException { 
+        return this.blockingQueue.take(); 
+    } 
+ 
+    private void startIDProducer() { 
+        if (this.runner == null) { 
+            UIDProducer producer = new UIDProducer(this.blockingQueue, 
+                    this.secureRandom, this.mdigest); 
+            this.runner = new Thread(producer);
+            this.runner.setDaemon(true);
+            this.runner.setName(RUNNER_THREAD_NAME);
+            this.runner.start(); 
+        } 
+    } 
+ 
+    /** 
+     * @return the current size of the queue 
+     */ 
+    public int getQueueSize() { 
+        return this.blockingQueue.size(); 
+    } 
+ 
+    /** 
+     * Stops the id-producer 
+     */ 
+    public void stopIDGenerator() {
+        this.stopped.set(true);
+        this.runner.interrupt(); 
+        
+    } 
+ 
+    private class UIDProducer implements Runnable { 
+        SecureRandom random; 
+ 
+        BlockingQueue<String> queue; 
+ 
+        MessageDigest digest; 
+ 
+        UIDProducer(BlockingQueue<String> queue, SecureRandom random, 
+                MessageDigest digest) { 
+            this.queue = queue; 
+            this.random = random; 
+            this.digest = digest; 
+ 
+        } 
+ 
+        /** 
+         * @see java.lang.Runnable#run() 
+         */ 
+        public void run() { 
+ 
+            while (!IDGenerator.this.stopped.get()) { 
+                try { 
+                    this.queue.put(produce()); 
+                } catch (InterruptedException e) {
+                    LOGGER 
+                            .warn("UIDProducer has been interrupted -- runner is going down"); 
+                    return; 
+                } 
+            } 
+ 
+        } 
+ 
+        private String produce() { 
+            String randomNumber = Integer.toString(this.random.nextInt()); 
+            byte[] byteResult = this.digest.digest(randomNumber.getBytes()); 
+            return hexEncode(byteResult); 
+        } 
+ 
+    } 
+ 
+    /** 
+     * Encodes a given byte array into a hex string. 
+     *  
+     * @param input - 
+     *            the byte array to encode 
+     * @return hex string representation of the given byte array 
+     */ 
+    static String hexEncode(byte[] input) { 
+        StringBuffer result = new StringBuffer(); 
+        char[] digits = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
+                'a', 'b', 'c', 'd', 'e', 'f' }; 
+        for (int idx = 0; idx < input.length; ++idx) { 
+            byte b = input[idx]; 
+            result.append(digits[(b & 0xf0) >> 4]); 
+            result.append(digits[b & 0x0f]); 
+        } 
+        return result.toString(); 
+    } 
+} 
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/ModificationConflictException.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/ModificationConflictException.java
new file mode 100755
index 0000000..08e2239
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/ModificationConflictException.java
@@ -0,0 +1,76 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.storage;
+
+/**
+ * This exception will be thrown if a Version conflict occures while updateing
+ * or deleteing an entry. Or if one entry is modified concurrently.
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class ModificationConflictException extends StorageException {
+
+    /**
+     * 
+     */
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * Constructs a new ModificationConflictException
+     */
+    public ModificationConflictException() {
+        super();
+    }
+
+    /**
+     * Constructs a new ModificationConflictException
+     * 
+     * @param message -
+     *            the exception message
+     */
+    public ModificationConflictException(String message) {
+        super(message);
+
+    }
+
+    /**
+     * Constructs a new ModificationConflictException
+     * 
+     * @param message -
+     *            the exception message
+     * @param cause -
+     *            the root cause of this exception
+     */
+    public ModificationConflictException(String message, Throwable cause) {
+        super(message, cause);
+
+    }
+
+    /**
+     * Constructs a new ModificationConflictException
+     * 
+     * @param cause -
+     *            the root cause of this exception
+     */
+    public ModificationConflictException(Throwable cause) {
+        super(cause);
+
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/ResourceNotFoundException.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/ResourceNotFoundException.java
new file mode 100644
index 0000000..f7470fa
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/ResourceNotFoundException.java
@@ -0,0 +1,67 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.storage;
+
+/**
+ * This exception will be thrown if an requested resource of a resource to modify can not be found
+ * @author Simon Willnauer
+ *
+ */
+public class ResourceNotFoundException extends StorageException {
+
+   
+    private static final long serialVersionUID = -8549987918130998249L;
+
+    /**
+     * Constructs an empty ResourceNotFoundException
+     */
+    public ResourceNotFoundException() {
+        super();
+        // TODO Auto-generated constructor stub
+    }
+
+    /**
+     * Constructs a new ResourceNotFoundException with an exception message
+     * @param message - the exception message
+     */
+    public ResourceNotFoundException(String message) {
+        super(message);
+        // TODO Auto-generated constructor stub
+    }
+
+    /**
+     * Constructs a new ResourceNotFoundException with an exception message and a root cause 
+     * @param message - the exception message
+     * @param cause - the root cause of this exception
+     */
+    public ResourceNotFoundException(String message, Throwable cause) {
+        super(message, cause);
+        // TODO Auto-generated constructor stub
+    }
+
+    /**
+     * Constructs a new ResourceNotFoundException with  a root cause
+     * @param cause - the root cause of this exception
+     * 
+     */
+    public ResourceNotFoundException(Throwable cause) {
+        super(cause);
+        // TODO Auto-generated constructor stub
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/Storage.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/Storage.java
new file mode 100644
index 0000000..48375d7
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/Storage.java
@@ -0,0 +1,276 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.storage;
+
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.data.ServerBaseFeed;
+
+import com.google.gdata.data.BaseEntry;
+import com.google.gdata.data.BaseFeed;
+
+/**
+ * A interface every storage implementation must provide to access the
+ * <tt>Storage</tt>. It describes all access methodes needed to store,
+ * retrieve and look up data stored in the <tt>Storage</tt> component. This
+ * interface acts as a <tt>Facade</tt> to hide the storage implementation from
+ * the user.
+ * <p>
+ * This could also act as a proxy for a remote storage. It also removes any
+ * restrictions from custom storage implementations.
+ * </p>
+ * 
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+/*
+ * not final yet
+ */
+public interface Storage {
+
+    /**
+     * 
+     * Stores the given entry. The ServerBaseEntry must provide a feed id and
+     * the service type. configuration for the entry.
+     * 
+     * @param entry -
+     *            the entry to store
+     * 
+     * @return - the stored Entry for the server response
+     * @throws StorageException -
+     *             if the entry can not be stored or required field are not set.
+     */
+    public abstract BaseEntry storeEntry(ServerBaseEntry entry)
+            throws StorageException;
+
+    /**
+     * Deletes the given entry. The ServerBaseEntry just hase to provide the
+     * entry id to be deleted.
+     * 
+     * @param entry -
+     *            the entry to delete from the storage
+     * @throws StorageException -
+     *             if the entry can not be deleted or the entry does not exist
+     *             or required field are not set.
+     */
+    public abstract void deleteEntry(ServerBaseEntry entry)
+            throws StorageException;
+
+    /**
+     * Updates the given entry. The ServerBaseEntry must provide a feed id,
+     * service id and the
+     * {@link org.apache.lucene.gdata.server.registry.ProvidedService}
+     * 
+     * @param entry -
+     *            the entry to update
+     * 
+     * @return - the updated entry for server response.
+     * @throws StorageException -
+     *             if the entry can not be updated or does not exist or required
+     *             field are not set.
+     */
+    public abstract BaseEntry updateEntry(ServerBaseEntry entry)
+            throws StorageException;
+
+    /**
+     * Retrieves the requested feed from the storage. The given ServerBaseFeed
+     * must provide information about the feed id, max-result count and the
+     * start index. To create feeds and entries also the service type must be
+     * provided.
+     * 
+     * @param feed -
+     *            the to retieve from the storage
+     * @return the requested feed
+     * @throws StorageException -
+     *             the feed does not exist or can not be retrieved or required
+     *             field are not set.
+     */
+    public abstract BaseFeed getFeed(ServerBaseFeed feed)
+            throws StorageException;
+
+    /**
+     * Retrieves the requested entry from the storage. The given entry must
+     * provide information about the entry id and service type.
+     * 
+     * @param entry -
+     *            the entry to retrieve
+     * @return - the requested entry
+     * @throws StorageException -
+     *             if the entry does not exist or can not be created or required
+     *             field are not set.
+     */
+    public abstract BaseEntry getEntry(ServerBaseEntry entry)
+            throws StorageException;
+
+    /**
+     * Saves a new account. Required attributes to set are <tt>password</tt>
+     * and <tt>accountname</tt>
+     * 
+     * @param account -
+     *            the account to save
+     * @throws StorageException -
+     *             if the account can not be stored or the account already
+     *             exists or required field are not set.
+     */
+    public abstract void storeAccount(final GDataAccount account)
+            throws StorageException;
+
+    /**
+     * Updates an existing account. Required attributes to set are
+     * <tt>password</tt> and <tt>accountname</tt>
+     * 
+     * @param account -
+     *            the account to update
+     * @throws StorageException -
+     *             if the account does not exist or required field are not set.
+     */
+    public abstract void updateAccount(final GDataAccount account)
+            throws StorageException;
+
+    /**
+     * Deletes the account for the given account name. All feeds and entries
+     * referencing this account will be deleted as well!
+     * 
+     * @param accountname -
+     *            the name of the account to delete
+     * @throws StorageException -
+     *             if the account does not exist
+     */
+    public abstract void deleteAccount(final String accountname)
+            throws StorageException;
+
+    /**
+     * Stores a new feed for a existing account. The Feed must provide
+     * information about the service type to store the feed for and the feed id
+     * used for accessing and retrieving the feed from the storage. Each feed is
+     * associated with a provided service. This method does check wheather a
+     * feed with the same feed id as the given feed does already exists.
+     * 
+     * @see org.apache.lucene.gdata.server.registry.ProvidedService
+     * @param feed -
+     *            the feed to create
+     * @param accountname -
+     *            the account name belongs to the feed
+     * @throws StorageException -
+     *             if the feed already exists or the feed can not be stored
+     */
+    public abstract void storeFeed(final ServerBaseFeed feed, String accountname)
+            throws StorageException;
+
+    /**
+     * Deletes the feed for the given feed id. All Entries referencing the given
+     * feed id will be deleted as well.
+     * 
+     * @param feedId -
+     *            the feed id for the feed to delete.
+     * @throws StorageException -
+     *             if the feed for the feed id does not exist or the feed can
+     *             not be deleted
+     */
+    public abstract void deleteFeed(final String feedId)
+            throws StorageException;
+
+    /**
+     * Updates a stored feed. The Feed must provide information about the
+     * service type to store the feed for and the feed id used for accessing and
+     * retrieving the feed from the storage.
+     * 
+     * @param feed -
+     *            the feed to update
+     * @param accountname -
+     *            the account name belongs to the feed
+     * @throws StorageException -
+     *             if the feed does not exist or the feed can not be updated
+     */
+    public abstract void updateFeed(final ServerBaseFeed feed,
+            String accountname) throws StorageException;
+
+    /**
+     * Retrieves the service name for a stored feed
+     * 
+     * @param feedId -
+     *            the feed id
+     * @return - the name of the service
+     * @throws StorageException -
+     *             if no feed for the provided id is stored
+     */
+    public abstract String getServiceForFeed(String feedId)
+            throws StorageException;
+
+    /**
+     * 
+     * Retrieves the {@link GDataAccount} for the given account name
+     * @param accountName -
+     *            the name of the requested account
+     * @return - a {@link GDataAccount} instance for the requested account name
+     * @throws StorageException -
+     *             if no account for the account name is stored
+     * 
+     */
+    public abstract GDataAccount getAccount(String accountName)
+            throws StorageException;
+
+    /**
+     * close this storage instance. This method will be called by clients after
+     * use.
+     */
+    public abstract void close();
+
+    /**
+     * Each feed belongs to one specific account. This method retrieves the
+     * account name for
+     * 
+     * @param feedId -
+     *            the id of the feed to retrieve the accountname
+     * @return - the name / id of the account associated with the feed for the
+     *         given feed id
+     * @throws StorageException -
+     *             if the feed is not stored or the storage can not be accessed
+     */
+    public String getAccountNameForFeedId(String feedId)
+            throws StorageException;
+
+    /**
+     * Retrieves the date of the last modification for the given id
+     * 
+     * @param entryId -
+     *            the entry Id
+     * @param feedId -
+     *            the feed which contains the entry
+     * @return - The date of the last modifiaction in milliseconds or
+     *         <code>new Long(0)</code> if the resource can not be found eg.
+     *         the time can not be accessed
+     * @throws StorageException -
+     *             if the storage can not be accessed
+     */
+    public Long getEntryLastModified(String entryId, String feedId)
+            throws StorageException;
+
+    /**
+     * Retrieves the date of the last modification for the given id
+     * 
+     * @param feedId -
+     *            the feed Id
+     * @return - The date of the last modifiaction in milliseconds or
+     *         <code>new Long(0)</code> if the resource can not be found eg.
+     *         the time can not be accessed
+     * @throws StorageException -
+     *             if the storage can not be accessed
+     */
+    public Long getFeedLastModified(String feedId) throws StorageException;
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/StorageController.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/StorageController.java
new file mode 100644
index 0000000..b4f9710
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/StorageController.java
@@ -0,0 +1,68 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.storage;
+
+import org.apache.lucene.gdata.server.registry.ServerComponent;
+
+/**
+ * An interface to define a central storage controller acting as a
+ * <tt>Stroage</tt> Factory. The <tt>StroageController</tt> manages the
+ * storage logic. Subclasses of {@link StorageController} can be registered as
+ * {@link org.apache.lucene.gdata.server.registry.Component} in the
+ * {@link org.apache.lucene.gdata.server.registry.GDataServerRegistry}. A
+ * single instance of the contorller will be loaded and passed to clients via
+ * the lookup service.
+ * <p>
+ * This instances, registered in the registry must be thread save as they are
+ * shared between several clients
+ * </p>
+ * <p>
+ * Each StroageController implementation must provide a super user
+ * {@link org.apache.lucene.gdata.data.GDataAccount} with all
+ * {@link org.apache.lucene.gdata.data.GDataAccount.AccountRole} set. This
+ * account must have the defined name <i>administrator</i> and a default
+ * password <i>password</i>. The password has to be updated by the server
+ * administrator before production use.
+ * To get the predefinded GDataAccount use {@link org.apache.lucene.gdata.data.GDataAccount#createAdminAccount()}
+ * </p>
+ *
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public interface StorageController extends ServerComponent {
+    /**
+     * Destroys the controller - this method is called by the registry when the
+     * context will be destroyed
+     */
+    public abstract void destroy();
+
+    /**
+     * Creates Storage instances to access the underlaying storage component
+     * 
+     * @return a storage instance
+     * @throws StorageException -
+     *             if the storage instance can not be created
+     */
+    public abstract Storage getStorage() throws StorageException;
+    
+    /**
+     * Releases a new unique ID
+     * @return - unique ID
+     */
+    public abstract String releaseId();
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/StorageException.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/StorageException.java
new file mode 100644
index 0000000..ad715a7
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/StorageException.java
@@ -0,0 +1,76 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */ 
+package org.apache.lucene.gdata.storage; 
+ 
+/** 
+ * The StorageException will be throw if any error or exception inside the 
+ * storage implementation occures. This exception hides all other exceptions 
+ * from inside the storage. 
+ *  
+ * @author Simon Willnauer 
+ *  
+ */ 
+public class StorageException extends RuntimeException { 
+ 
+    /** 
+     *  
+     */ 
+    private static final long serialVersionUID = -4997572416934126511L; 
+ 
+    /** 
+     * Constructs a new StorageException 
+     */ 
+    public StorageException() { 
+        super(); 
+ 
+    } 
+ 
+    /** 
+     * Constructs a new StorageException 
+     *  
+     * @param message - 
+     *            the exception message 
+     */ 
+    public StorageException(String message) { 
+        super(message); 
+ 
+    } 
+ 
+    /** 
+     * Constructs a new StorageException 
+     *  
+     * @param message - 
+     *            the exception message 
+     * @param cause - 
+     *            the root cause of this exception 
+     */ 
+    public StorageException(String message, Throwable cause) { 
+        super(message, cause); 
+ 
+    } 
+ 
+    /** 
+     * Constructs a new StorageException 
+     *  
+     * @param cause - 
+     *            the root cause of this exception 
+     */ 
+    public StorageException(Throwable cause) { 
+        super(cause); 
+ 
+    } 
+ 
+} 
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/StorageFactory.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/StorageFactory.java
new file mode 100644
index 0000000..e69de29
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/db4o/DB4oController.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/db4o/DB4oController.java
new file mode 100755
index 0000000..20aa476
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/db4o/DB4oController.java
@@ -0,0 +1,426 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.storage.db4o;
+
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.Proxy;
+import java.security.NoSuchAlgorithmException;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.data.ServerBaseFeed;
+import org.apache.lucene.gdata.server.registry.Component;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+import org.apache.lucene.gdata.server.registry.Scope;
+import org.apache.lucene.gdata.server.registry.ScopeVisitor;
+import org.apache.lucene.gdata.server.registry.configuration.Requiered;
+import org.apache.lucene.gdata.storage.IDGenerator;
+import org.apache.lucene.gdata.storage.Storage;
+import org.apache.lucene.gdata.storage.StorageController;
+import org.apache.lucene.gdata.storage.StorageException;
+import org.apache.lucene.gdata.storage.db4o.DB4oStorage.DB4oEntry;
+import org.apache.lucene.gdata.utils.Pool;
+import org.apache.lucene.gdata.utils.PoolObjectFactory;
+import org.apache.lucene.gdata.utils.SimpleObjectPool;
+
+import com.db4o.Db4o;
+import com.db4o.ObjectContainer;
+import com.db4o.ObjectServer;
+import com.google.gdata.data.BaseEntry;
+import com.google.gdata.data.BaseFeed;
+
+/**
+ * The DB4o StorageContorller can be used as a persitence component for the
+ * gdata-server. To use DB4o a third party jar needs to added to the lib
+ * directory of the project. If the jar is not available in the lib directory
+ * all db4o dependent class won't be included in the build.
+ * <p>
+ * If the jar is present in the lib directory this class can be configured as a
+ * {@link org.apache.lucene.gdata.server.registry.ComponentType#STORAGECONTROLLER}
+ * via the <i>gdata-config.xml</i> file. For detailed config documentation see
+ * the wiki page.
+ * </p>
+ * <p>
+ * The DB4oController can run as a client or as a server to serve other running
+ * db4o clients in the network. To achive the best performance out of the db4o
+ * caching layer connections to the server will be reused in a connection pool.
+ * A connection will not be shared withing more than one thread. The controller
+ * release one connection per request and returns the connection when the
+ * request has been destroyed.
+ * </p>
+ * @see <a href="http://www.db4o.com">db4o website</a>
+ * @see org.apache.lucene.gdata.utils.Pool
+ * 
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+@Component(componentType = ComponentType.STORAGECONTROLLER)
+@Scope(scope = Scope.ScopeType.REQUEST)
+public class DB4oController implements StorageController, ScopeVisitor {
+    private static final Log LOG = LogFactory.getLog(DB4oController.class);
+
+    private final ThreadLocal<Storage> threadLocalStorage = new ThreadLocal<Storage>();
+
+    private Pool<ObjectContainer> containerPool;
+
+    private ObjectServer server;
+
+    private final IDGenerator idGenerator;
+
+    private boolean weakReferences;
+
+    private boolean runAsServer;
+
+    private int port;
+
+    private String filePath;
+
+    private String user;
+
+    private String password;
+
+    private String host;
+
+    private int containerPoolSize;
+
+    /**
+     * @throws NoSuchAlgorithmException
+     * 
+     */
+    public DB4oController() throws NoSuchAlgorithmException {
+
+        this.idGenerator = new IDGenerator(15);
+
+    }
+
+    ObjectContainer releaseContainer() {
+        return this.server.openClient();
+
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.StorageController#destroy()
+     */
+    public void destroy() {
+        this.containerPool.destroy();
+        this.idGenerator.stopIDGenerator();
+        this.server.close();
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.StorageController#getStorage()
+     */
+    public Storage getStorage() throws StorageException {
+       Storage retVal = this.threadLocalStorage.get();
+        if (retVal != null)
+            return retVal;
+
+        retVal = new DB4oStorage(this.containerPool.aquire(), this);
+
+        this.threadLocalStorage.set(retVal);
+        return retVal;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.registry.ServerComponent#initialize()
+     */
+    public void initialize() {
+        if (LOG.isInfoEnabled())
+            LOG.info("Initialize " + this.toString());
+
+        Db4o.configure().objectClass(DB4oEntry.class).objectField("updated")
+                .indexed(true);
+        Db4o.configure().objectClass(BaseEntry.class).objectField("id")
+                .indexed(true);
+        Db4o.configure().objectClass(BaseFeed.class).objectField("id").indexed(
+                true);
+        Db4o.configure().objectClass(GDataAccount.class).objectField("name")
+                .indexed(true);
+        Db4o.configure().objectClass(ServerBaseFeed.class).cascadeOnDelete(
+                false);
+        Db4o.configure().objectClass(ServerBaseFeed.class)
+                .maximumActivationDepth(0);
+        Db4o.configure().objectClass(BaseFeed.class).minimumActivationDepth(1);
+        Db4o.configure().objectClass(BaseEntry.class)
+                .minimumActivationDepth(1);
+        Db4o.configure().objectClass(BaseFeed.class).cascadeOnDelete(true);
+        Db4o.configure().objectClass(DB4oEntry.class).cascadeOnDelete(true);
+        Db4o.configure().objectClass(GDataAccount.class).cascadeOnDelete(true);
+        Db4o.configure().weakReferences(this.weakReferences);
+        Db4o.configure().optimizeNativeQueries(false);
+        if (this.runAsServer) {
+            this.server = Db4o.openServer(this.filePath, this.port);
+            if(this.server == null)
+                throw new RuntimeException("Can't create server at confiugred destination -- "+this.filePath);
+            this.server.grantAccess(this.user, this.password);
+        } else {
+            InvocationHandler handler = new ObjectServerDecorator(this.user,
+                    this.password, this.host, this.port);
+            this.server = (ObjectServer) Proxy.newProxyInstance(this.getClass()
+                    .getClassLoader(), new Class[] { ObjectServer.class },
+                    handler);
+        }
+
+        PoolObjectFactory<ObjectContainer> factory = new ObjectContinerFactory(
+                this.server);
+        this.containerPool = new SimpleObjectPool<ObjectContainer>(
+                this.containerPoolSize, factory);
+        try {
+            createAdminAccount();
+        } catch (StorageException e) {
+            LOG.error("Can not create admin account -- ",e);
+        }
+    }
+
+    private void createAdminAccount() throws StorageException {
+        GDataAccount adminAccount = GDataAccount.createAdminAccount();
+        visiteInitialize();
+        Storage sto = this.getStorage();
+        try {
+            sto.getAccount(adminAccount.getName());
+        } catch (Exception e) {
+            this.getStorage().storeAccount(adminAccount);
+        } finally {
+            visiteDestroy();
+        }
+
+    }
+
+    
+    /**
+     * @see org.apache.lucene.gdata.storage.StorageController#releaseId()
+     */
+    public String releaseId(){
+        try{
+        return this.idGenerator.getUID();
+        }catch (InterruptedException e) {
+            throw new StorageException("ID producer has been interrupted",e);
+        }
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.registry.ScopeVisitor#visiteInitialize()
+     */
+    public void visiteInitialize() {
+        if (LOG.isInfoEnabled())
+            LOG.info("Opened Storage -- request initialized");
+        Storage storage = this.threadLocalStorage.get();
+        if (storage != null) {
+            LOG.warn("Storage already opened");
+            return;
+        }
+
+        storage = new DB4oStorage(this.containerPool.aquire(), this);
+
+        this.threadLocalStorage.set(storage);
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.registry.ScopeVisitor#visiteDestroy()
+     */
+    public void visiteDestroy() {
+        Storage storage = this.threadLocalStorage.get();
+        if (storage == null) {
+            LOG.warn("no Storage opened -- threadlocal returned null");
+            return;
+        }
+        this.containerPool.release(((DB4oStorage)storage).getContainer());
+        this.threadLocalStorage.remove();
+        if (LOG.isInfoEnabled())
+            LOG.info("Closed Storage -- request destroyed");
+    }
+
+    private static class ObjectContinerFactory implements
+            PoolObjectFactory<ObjectContainer> {
+        private final ObjectServer server;
+
+        ObjectContinerFactory(final ObjectServer server) {
+            this.server = server;
+        }
+
+        /**
+         * @see org.apache.lucene.gdata.utils.PoolObjectFactory#getInstance()
+         */
+        public ObjectContainer getInstance() {
+
+            return this.server.openClient();
+        }
+
+        /**
+         * @param type -
+         *            object container to destroy (close)
+         * @see org.apache.lucene.gdata.utils.PoolObjectFactory#destroyInstance(Object)
+         */
+        public void destroyInstance(ObjectContainer type) {
+            type.close();
+        }
+
+    }
+
+    /**
+     * @return Returns the filePath.
+     */
+    public String getFilePath() {
+        return this.filePath;
+    }
+
+    /**
+     * @param filePath
+     *            The filePath to set.
+     */
+    public void setFilePath(String filePath) {
+        this.filePath = filePath;
+    }
+
+    /**
+     * @return Returns the host.
+     */
+    public String getHost() {
+        return this.host;
+    }
+
+    /**
+     * @param host
+     *            The host to set.
+     */
+    @Requiered
+    public void setHost(String host) {
+        this.host = host;
+    }
+
+    /**
+     * @return Returns the password.
+     */
+    public String getPassword() {
+        return this.password;
+    }
+
+    /**
+     * @param password
+     *            The password to set.
+     */
+    @Requiered
+    public void setPassword(String password) {
+        this.password = password;
+    }
+
+    /**
+     * @return Returns the port.
+     */
+    public int getPort() {
+        return this.port;
+    }
+
+    /**
+     * @param port
+     *            The port to set.
+     */
+    @Requiered
+    public void setPort(int port) {
+        this.port = port;
+    }
+
+    /**
+     * @return Returns the runAsServer.
+     */
+    public boolean isRunAsServer() {
+        return this.runAsServer;
+    }
+
+    /**
+     * @param runAsServer
+     *            The runAsServer to set.
+     */
+    @Requiered
+    public void setRunAsServer(boolean runAsServer) {
+        this.runAsServer = runAsServer;
+    }
+
+    /**
+     * @return Returns the user.
+     */
+    public String getUser() {
+        return this.user;
+    }
+
+    /**
+     * @param user
+     *            The user to set.
+     */
+    @Requiered
+    public void setUser(String user) {
+        this.user = user;
+    }
+
+    /**
+     * @return Returns the weakReferences.
+     */
+    public boolean isUseWeakReferences() {
+        return this.weakReferences;
+    }
+
+    /**
+     * @param weakReferences
+     *            The weakReferences to set.
+     */
+    @Requiered
+    public void setUseWeakReferences(boolean weakReferences) {
+        this.weakReferences = weakReferences;
+    }
+
+    /**
+     * @return Returns the containerPoolSize.
+     */
+    public int getContainerPoolSize() {
+        return this.containerPoolSize;
+    }
+
+    /**
+     * @param containerPoolSize
+     *            The containerPoolSize to set.
+     */
+    @Requiered
+    public void setContainerPoolSize(int containerPoolSize) {
+        this.containerPoolSize = containerPoolSize < 1 ? 1 : containerPoolSize;
+    }
+
+    /**
+     * @see java.lang.Object#toString()
+     */
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder(this.getClass().getName())
+                .append(" ");
+        builder.append("host: ").append(this.host).append(" ");
+        builder.append("port: ").append(this.port).append(" ");
+        builder.append("pool size: ").append(this.containerPoolSize)
+                .append(" ");
+        builder.append("runs as server: ").append(this.runAsServer).append(" ");
+        builder.append("use weak references: ").append(this.weakReferences)
+                .append(" ");
+        builder.append("user: ").append(this.user).append(" ");
+        builder.append("password length: ").append(
+                this.password == null ? "no password" : this.password.length())
+                .append(" ");
+
+        return builder.toString();
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/db4o/DB4oStorage.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/db4o/DB4oStorage.java
new file mode 100755
index 0000000..c1eba4f
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/db4o/DB4oStorage.java
@@ -0,0 +1,810 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.storage.db4o;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.data.ServerBaseFeed;
+import org.apache.lucene.gdata.storage.ModificationConflictException;
+import org.apache.lucene.gdata.storage.ResourceNotFoundException;
+import org.apache.lucene.gdata.storage.Storage;
+import org.apache.lucene.gdata.storage.StorageController;
+import org.apache.lucene.gdata.storage.StorageException;
+
+import com.db4o.ObjectContainer;
+import com.db4o.ObjectSet;
+import com.db4o.query.Query;
+import com.google.gdata.data.BaseEntry;
+import com.google.gdata.data.BaseFeed;
+import com.google.gdata.data.DateTime;
+
+/**
+ * 
+ * Storage implementation for the DB4o storage component
+ * @author Simon Willnauer
+ * 
+ */
+public class DB4oStorage implements Storage {
+    private static final Log LOG = LogFactory.getLog(DB4oStorage.class);
+
+    private static final int RENDER_ACTIVATION_DEPTH = 100;
+
+    private final ObjectContainer container;
+
+    private final StorageController controller;
+
+    private final List<String> semaphore = new ArrayList<String>();
+
+    
+    protected DB4oStorage(final ObjectContainer container,
+            StorageController controller) {
+        this.container = container;
+        this.controller = controller;
+    }
+
+    private void createSemaphore(String key)
+            throws ModificationConflictException {
+        this.semaphore.add(key);
+        if (this.container.ext().setSemaphore(key, 0))
+            return;
+        throw new ModificationConflictException(
+                "can not create semaphore for key -- " + key);
+    }
+
+    private void releaseAllSemaphore() {
+        for (String key : this.semaphore) {
+            this.container.ext().releaseSemaphore(key);
+        }
+        this.semaphore.clear();
+    }
+
+    private void releaseSemaphore(String key) {
+        if (this.semaphore.contains(key)) {
+            this.container.ext().releaseSemaphore(key);
+            this.semaphore.remove(key);
+        }
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#storeEntry(org.apache.lucene.gdata.data.ServerBaseEntry)
+     */
+    public BaseEntry storeEntry(ServerBaseEntry entry) throws StorageException {
+        if (entry == null)
+            throw new StorageException("Can not store entry -- is null");
+
+        if (entry.getFeedId() == null)
+            throw new StorageException("can not store entry -- feed id is null");
+        if (LOG.isDebugEnabled())
+            LOG.debug("Storing entry for feed: " + entry.getFeedId());
+        BaseFeed<BaseFeed, BaseEntry> feed = getFeedOnly(entry.getFeedId(),entry.getServiceType());
+       refreshPersistentObject(feed);
+        try {
+            StringBuilder idBuilder = new StringBuilder(entry.getFeedId());
+            idBuilder.append(this.controller.releaseId());
+            entry.setId(idBuilder.toString());
+        } catch (StorageException e) {
+            LOG.error("Can not create uid for entry -- " + e.getMessage(), e);
+            throw new StorageException("Can not create uid for entry -- "
+                    + e.getMessage(), e);
+
+        }
+        setUpdated(entry, feed);
+        DB4oEntry intEntry = new DB4oEntry();
+        intEntry.setEntry(entry.getEntry());
+        intEntry.setUpdateTime(entry.getUpdated().getValue());
+        intEntry.setFeedId(feed.getId());
+        intEntry.setVersion(entry.getVersion());
+
+       
+        try {
+            this.container.set(feed);
+            this.container.set(intEntry);
+            this.container.commit();
+        } catch (Exception e) {
+            LOG
+                    .error("Error occured on persisting changes -- rollback changes");
+            this.container.rollback();
+            throw new StorageException("Can not persist changes -- "
+                    + e.getMessage(), e);
+        }
+        if (LOG.isInfoEnabled())
+            LOG.info("Stored Entry for entryID: " + entry.getId()
+                    + " -- feedID: " + entry.getFeedId());
+        return entry.getEntry();
+    }
+
+    private void setUpdated(ServerBaseEntry entry, DB4oEntry intEntry) {
+        if (entry.getUpdated().compareTo(intEntry.getEntry().getUpdated()) <= 0) {
+            if (LOG.isDebugEnabled())
+                LOG
+                        .debug("Set new UpdateTime to entry new entry time is less or equal the time of the stored entry -- old Entry: "
+                                + intEntry.getEntry().getUpdated()
+                                + "; new Entry: " + entry.getUpdated());
+            entry.setUpdated(new DateTime(System.currentTimeMillis(), entry
+                    .getUpdated().getTzShift()));
+        }
+
+    }
+
+    private void setUpdated(ServerBaseEntry entry,
+            BaseFeed<BaseFeed, BaseEntry> feed) {
+        if (entry.getUpdated() != null){
+            long timeInMilli = entry.getUpdated().getValue();
+            int tzShift = entry.getUpdated().getTzShift();
+            feed.setUpdated(new DateTime(timeInMilli, tzShift));
+        }
+        else{
+            int timezone = 0;
+            if(feed.getUpdated() != null){
+                 timezone = feed.getUpdated().getTzShift();
+            }
+            long timeInMilli = System.currentTimeMillis();
+            entry.setUpdated(new DateTime(timeInMilli,timezone));
+            feed.setUpdated(new DateTime(timeInMilli,timezone));
+        }
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#deleteEntry(org.apache.lucene.gdata.data.ServerBaseEntry)
+     */
+    public void deleteEntry(ServerBaseEntry entry) throws StorageException {
+        if (entry == null)
+            throw new StorageException("Can not delete entry -- is null");
+        if (entry.getFeedId() == null)
+            throw new StorageException(
+                    "can not delete entry -- feed id is null");
+        if (entry.getId() == null)
+            throw new StorageException("Can not delete entry -- id is null");
+        if (LOG.isDebugEnabled())
+            LOG.debug("delete entry for feed: " + entry.getFeedId()
+                    + " entry ID: " + entry.getId());
+        DB4oEntry persistentEntry = getInternalEntry(entry.getId());
+        // lock the entry to prevent concurrent access
+        createSemaphore(entry.getId());
+        refreshPersistentObject(persistentEntry);
+        if(persistentEntry.getVersion() != entry.getVersion())
+            throw new ModificationConflictException(
+                    "Current version does not match given version  -- currentVersion: "+persistentEntry.getVersion()+"; given Version: "+entry.getVersion() );
+        BaseFeed<BaseFeed, BaseEntry> feed = getFeedOnly(entry.getFeedId(),entry.getServiceType());
+        refreshPersistentObject(feed);
+        DateTime time = DateTime.now();
+        if (persistentEntry.getEntry().getUpdated() != null)
+            time.setTzShift(persistentEntry.getEntry().getUpdated().getTzShift());
+        feed.setUpdated(time);
+        try {
+            //delete the entry
+            this.container.delete(persistentEntry.getEntry());
+            this.container.delete(persistentEntry);
+            this.container.set(feed);
+            this.container.commit();
+            
+        } catch (Exception e) {
+            LOG
+                    .error("Error occured on persisting changes -- rollback changes");
+            this.container.rollback();
+            throw new StorageException("Can not persist changes -- "
+                    + e.getMessage(), e);
+        } finally {
+            releaseSemaphore(entry.getId());
+        }
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#updateEntry(org.apache.lucene.gdata.data.ServerBaseEntry)
+     */
+    public BaseEntry updateEntry(ServerBaseEntry entry) throws StorageException {
+        if (entry == null)
+            throw new StorageException("Can not update entry -- is null");
+        if (entry.getFeedId() == null)
+            throw new StorageException(
+                    "can not delete entry -- feed id is null");
+        if (entry.getId() == null)
+            throw new StorageException("Can not delete entry -- id is null");
+
+        DB4oEntry persistentEntry = getInternalEntry(entry.getId());
+        // lock the entry to prevent concurrent access
+        createSemaphore(entry.getId());
+        refreshPersistentObject(persistentEntry);
+        if(persistentEntry.getVersion() != entry.getVersion())
+            throw new ModificationConflictException(
+                    "Current version does not match given version  -- currentVersion: "+persistentEntry.getVersion()+"; given Version: "+entry.getVersion() );
+        
+        setUpdated(entry, persistentEntry);
+        BaseFeed<BaseFeed, BaseEntry> feed = getFeedOnly(entry.getFeedId(),entry.getServiceType());
+        refreshPersistentObject(feed);
+        BaseEntry retVal = entry.getEntry(); 
+        DB4oEntry newEntry = new DB4oEntry();
+        newEntry.setEntry(retVal);
+        newEntry.setUpdateTime(entry.getUpdated().getValue());
+        newEntry.setFeedId(feed.getId());
+        // increment Version
+        newEntry.setVersion((entry.getVersion())+1);
+
+        setUpdated(entry, feed);
+        try {
+            this.container.set(feed);
+            this.container.set(newEntry);
+            this.container.delete(persistentEntry.getEntry());
+            this.container.delete(persistentEntry);
+            this.container.commit();
+        } catch (Exception e) {
+            LOG
+                    .error("Error occured on persisting changes -- rollback changes");
+            this.container.rollback();
+            throw new StorageException("Can not persist changes -- "
+                    + e.getMessage(), e);
+        } finally {
+            releaseSemaphore(entry.getId());
+        }
+        return retVal;
+
+    }
+    
+
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#getFeed(org.apache.lucene.gdata.data.ServerBaseFeed)
+     */
+    @SuppressWarnings("unchecked")
+    public BaseFeed getFeed(ServerBaseFeed feed) throws StorageException {
+        if (feed.getId() == null)
+            throw new StorageException("can not get feed -- feed id is null");
+        if (feed.getStartIndex() < 1)
+            feed.setStartIndex(1);
+        if (feed.getItemsPerPage() < 0)
+            feed.setItemsPerPage(25);
+
+        if (LOG.isInfoEnabled())
+            LOG.info("Fetching feed for feedID: " + feed.getId()
+                    + "; start-index: " + feed.getStartIndex()
+                    + "; items per page: " + feed.getItemsPerPage());
+
+       BaseFeed<BaseFeed, BaseEntry> persistentFeed = getFeedOnly(feed.getId(),feed.getServiceType());
+       /*
+        * prevent previously added entries in long running storage instances
+        */
+       clearDynamicElements(persistentFeed);
+        Query query = this.container.query();
+        query.constrain(DB4oEntry.class);
+        query.descend("feedId").constrain(feed.getId()).equal();
+        query.descend("updateTime").orderDescending();
+
+        ObjectSet<DB4oEntry> set = query.execute();
+       
+        int size = set.size();
+        
+        if (size < feed.getStartIndex()) {
+            if (LOG.isDebugEnabled())
+                LOG.debug("no entries found for feed constrain -- feedID: "
+                        + feed.getId() + "; start-index: "
+                        + feed.getStartIndex() + "; items per page: "
+                        + feed.getItemsPerPage());
+            return persistentFeed;
+        }
+
+        int start = feed.getStartIndex() - 1;
+        int items = start + feed.getItemsPerPage();
+        if (items > size)
+            items = size;
+        
+        List<DB4oEntry> sublist = set.subList(start, items);
+        
+        for (DB4oEntry entry : sublist) {
+            persistentFeed.getEntries().add(clearDynamicElements(entry.getEntry()));
+        }
+        this.container.activate(persistentFeed,RENDER_ACTIVATION_DEPTH);
+        return persistentFeed;
+
+    }
+
+    @SuppressWarnings("unchecked")
+    private BaseFeed<BaseFeed, BaseEntry> getFeedOnly(final String feedId, final String serviceId)
+            throws StorageException {
+        if(!checkService(feedId,serviceId))
+            throw new StorageException();
+        Query query = this.container.query();
+        query.constrain(ServerBaseFeed.class);
+      
+        query.constrain(BaseFeed.class);
+
+        query.descend("id").constrain(feedId).equal();
+
+        ObjectSet set = query.execute();
+        if (set.size() > 1)
+            throw new StorageException("Query for feed id " + feedId
+                    + " returns more than one result");
+        if (set.hasNext())
+        return (BaseFeed<BaseFeed, BaseEntry>) set.next();
+        throw new ResourceNotFoundException("can not find feed for given feed id -- "
+                + feedId);
+
+    }
+    private boolean checkService(String feedId,String serviceId){
+        Query query = this.container.query();
+        query.constrain(ServerBaseFeed.class);
+        query.descend("feed").descend("id").constrain(feedId).equal();
+        query.descend("serviceType").constrain(serviceId).equal();
+        return query.execute().size() == 1;
+    }
+    private ObjectSet getEnriesForFeedID(String feedId) {
+        Query query = this.container.query();
+        query.constrain(DB4oEntry.class);
+        query.descend("feedId").constrain(feedId).equal();
+
+        return query.execute();
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#getEntry(org.apache.lucene.gdata.data.ServerBaseEntry)
+     */
+
+    public BaseEntry getEntry(ServerBaseEntry entry) throws StorageException {
+        if (entry == null)
+            throw new StorageException("can not retrieve entry -- is null");
+        if (entry.getId() == null)
+            throw new StorageException("can not retrieve entry -- id is null");
+        if (LOG.isInfoEnabled())
+            LOG.info("Retrieving entry for entryID: " + entry.getId());
+        DB4oEntry retval = getInternalEntry(entry.getId());
+        this.container.activate(retval.getEntry(),RENDER_ACTIVATION_DEPTH);
+        return clearDynamicElements(retval.getEntry());
+    }
+
+    @SuppressWarnings("unchecked")
+    private DB4oEntry getInternalEntry(String id) throws StorageException {
+        Query query = this.container.query();
+        query.constrain(DB4oEntry.class);
+        query.descend("entry").descend("id").constrain(id).equal();
+        ObjectSet<DB4oEntry> resultSet = query.execute();
+        if (resultSet.size() > 1)
+            throw new StorageException(
+                    "Entry query returned not a unique result");
+        if (resultSet.hasNext())
+            return resultSet.next();
+        throw new ResourceNotFoundException("no entry with entryID: " + id
+                + " stored -- query returned no result");
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#storeAccount(org.apache.lucene.gdata.data.GDataAccount)
+     */
+    public void storeAccount(GDataAccount account) throws StorageException {
+        if (account == null)
+            throw new StorageException("can not store account -- is null");
+        if (account.getName() == null)
+            throw new StorageException("can not store account -- name is null");
+        if (account.getPassword() == null)
+            throw new StorageException(
+                    "can not store account -- password is null");
+        try {
+            getAccount(account.getName());
+            throw new IllegalStateException("account with accountname: "
+                    + account.getName() + " already exists");
+        } catch (IllegalStateException e) {
+            throw new StorageException("Account already exists");
+        } catch (StorageException e) {
+            if (LOG.isDebugEnabled())
+                LOG
+                        .debug("checked account for existence -- does not exist -- store account");
+        }
+        try {
+            this.container.set(account);
+            this.container.commit();
+        } catch (Exception e) {
+            LOG
+                    .error("Error occured on persisting changes -- rollback changes");
+            this.container.rollback();
+            throw new StorageException("Can not persist changes -- "
+                    + e.getMessage(), e);
+        }
+        if (LOG.isInfoEnabled())
+            LOG.info("Stored account: " + account);
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#updateAccount(org.apache.lucene.gdata.data.GDataAccount)
+     */
+    public void updateAccount(GDataAccount account) throws StorageException {
+        if (account == null)
+            throw new StorageException("can not update account -- is null");
+        if (account.getName() == null)
+            throw new StorageException("can not update account -- name is null");
+        if (account.getPassword() == null)
+            throw new StorageException(
+                    "can not update account -- password is null");
+        GDataAccount persitentAccount = getAccount(account.getName());
+        refreshPersistentObject(persitentAccount);
+        try {
+            this.container.set(account);
+            this.container.delete(persitentAccount);
+            this.container.commit();
+        } catch (Exception e) {
+            LOG
+                    .error("Error occured on persisting changes -- rollback changes");
+            this.container.rollback();
+            throw new StorageException("Can not persist changes -- "
+                    + e.getMessage(), e);
+        }
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#deleteAccount(java.lang.String)
+     */
+    public void deleteAccount(String accountname) throws StorageException {
+        if (accountname == null)
+            throw new StorageException(
+                    "can not delete account -- account name is null");
+        GDataAccount account = this.getAccount(accountname);
+        refreshPersistentObject(account);
+        if (LOG.isInfoEnabled())
+            LOG.info("delete account -- account name: " + accountname);
+        try {
+            this.container.delete(account);
+            this.container.commit();
+        } catch (Exception e) {
+            LOG
+                    .error("Error occured on persisting changes -- rollback changes");
+            this.container.rollback();
+            throw new StorageException("Can not persist changes -- "
+                    + e.getMessage(), e);
+        }
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#storeFeed(org.apache.lucene.gdata.data.ServerBaseFeed,
+     *      java.lang.String)
+     */
+    public void storeFeed(ServerBaseFeed feed, String accountname)
+            throws StorageException {
+        if (feed == null)
+            throw new StorageException("Can not store feed -- is null");
+        if (feed.getId() == null)
+            throw new StorageException("Can not store feed -- id is null");
+        if(feed.getServiceType() == null)
+            throw new StorageException("Can not store feed -- service type is null");
+        if(accountname == null)
+            throw new StorageException("Account name is null");
+        Query query = this.container.query();
+        query.constrain(ServerBaseFeed.class);
+        query.descend("feed").descend("id").constrain(feed.getId()).equal();
+        ObjectSet set = query.execute();
+        if (set.hasNext())
+            throw new StorageException("feed with feedID " + feed.getId()
+                    + " is already stored");
+        GDataAccount account = getAccount(accountname);
+        refreshPersistentObject(account);
+        feed.setAccount(account);
+        /*
+         * service config not required in db4o storage.
+         * Entries/Feeds don't have to be build from xml
+         */
+        feed.setServiceConfig(null);
+        try {
+            this.container.set(feed);
+            this.container.commit();
+        } catch (Exception e) {
+            LOG
+                    .error("Error occured on persisting changes -- rollback changes");
+            this.container.rollback();
+            throw new StorageException("Can not persist changes -- "
+                    + e.getMessage(), e);
+        }
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#deleteFeed(java.lang.String)
+     */
+    public void deleteFeed(String feedId) throws StorageException {
+        if (feedId == null)
+            throw new StorageException("can not delete feed -- feed id is null");
+        Query query = this.container.query();
+        query.constrain(ServerBaseFeed.class);
+        query.descend("feed").descend("id").constrain(feedId).equal();
+        ObjectSet set = query.execute();
+        if (set.size() > 1)
+            throw new StorageException(
+                    "Feed query returned not a unique result");
+        if (set.size() == 0)
+            throw new StorageException("no feed with feedID: " + feedId
+                    + " stored -- query returned no result");
+
+        ServerBaseFeed feed = (ServerBaseFeed) set.next();
+        refreshPersistentObject(feed);
+        ObjectSet entrySet = getEnriesForFeedID(feed.getId());
+        try {
+            this.container.delete(feed);
+            this.container.delete(feed.getFeed());
+            for (Object object : entrySet) {
+                refreshPersistentObject(object);
+                this.container.delete(object);
+            }
+            
+            this.container.commit();
+        } catch (Exception e) {
+            LOG
+                    .error("Error occured on persisting changes -- rollback changes");
+            this.container.rollback();
+            throw new StorageException("Can not persist changes -- "
+                    + e.getMessage(), e);
+        }
+
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#updateFeed(org.apache.lucene.gdata.data.ServerBaseFeed,
+     *      java.lang.String)
+     */
+    @SuppressWarnings("unchecked")
+    public void updateFeed(ServerBaseFeed feed, String accountname)
+            throws StorageException {
+        if (feed == null)
+            throw new StorageException("Can not update feed -- is null");
+        if (feed.getId() == null)
+            throw new StorageException("Can not update feed -- id is null");
+        if(feed.getServiceType() == null)
+            throw new StorageException("Can not update feed -- service type is null");
+        if(accountname == null)
+            throw new StorageException("Account name is null");
+        GDataAccount account = getAccount(accountname);
+        Query query = this.container.query();
+        query.constrain(ServerBaseFeed.class);
+        query.descend("feed").descend("id").constrain(feed.getId());
+        ObjectSet<ServerBaseFeed> set=  query.execute();
+        if (set.size() > 1)
+            throw new StorageException("Query for feed id " + feed.getId()
+                    + " returns more than one result");
+        if (set.size() < 1)
+            throw new StorageException("can not find feed for given feed id -- "
+                + feed.getId());
+        ServerBaseFeed result = set.next();
+        refreshPersistentObject(result);
+        BaseFeed oldFeed = result.getFeed();
+        result.setAccount(account);
+        result.setFeed(feed.getFeed());
+        try {
+            this.container.delete(oldFeed);
+            this.container.set(result);
+            this.container.commit();
+        } catch (Exception e) {
+            LOG
+                    .error("Error occurred on persisting changes -- rollback changes");
+            this.container.rollback();
+            throw new StorageException("Can not persist changes -- "
+                    + e.getMessage(), e);
+        }
+        
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#getServiceForFeed(java.lang.String)
+     */
+    @SuppressWarnings("unchecked")
+    public String getServiceForFeed(final String feedId) throws StorageException {
+        if(feedId == null)
+            throw new StorageException("can not get Service for feed -- feed id is null");
+        if(LOG.isInfoEnabled())
+            LOG.info("Retrieving Service for feed -- feed id: "+feedId);
+        Query query = this.container.query();
+        query.constrain(ServerBaseFeed.class);
+        query.descend("feed").descend("id").constrain(feedId);
+        ObjectSet<ServerBaseFeed> feed =  query.execute();
+        if (feed.size() > 1)
+            throw new StorageException("Query for feed id " + feedId
+                    + " returns more than one result");
+        if (feed.size() < 1)
+            throw new StorageException("can not find feed for given feed id -- "
+                + feedId);
+        
+        ServerBaseFeed result = feed.next();
+        if(LOG.isInfoEnabled())
+            LOG.info("Retrieved Service for feed -- serviceType: "+result.getServiceType());
+        return result.getServiceType();
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#getAccount(java.lang.String)
+     */
+    public GDataAccount getAccount(String accountName) throws StorageException {
+        if (accountName == null)
+            throw new StorageException(
+                    "Can not get account -- account name is null");
+        if (LOG.isInfoEnabled())
+            LOG.info("Retrieving account for account name: " + accountName);
+        Query query = this.container.query();
+        query.constrain(GDataAccount.class);
+        query.descend("name").constrain(accountName).equal();
+        ObjectSet set = query.execute();
+        if (set.size() > 1)
+            throw new StorageException(
+                    "Account query returned not a unique result -- account name: "
+                            + accountName);
+        if (!set.hasNext())
+            throw new ResourceNotFoundException(
+                    "No such account stored -- query returned not result for account name: "
+                            + accountName);
+
+        return (GDataAccount) set.next();
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#close()
+     */
+    public void close() {
+        releaseAllSemaphore();
+        
+    }
+    
+   
+
+    
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#getAccountNameForFeedId(java.lang.String)
+     */
+    
+    public String getAccountNameForFeedId(String feedId)
+            throws StorageException {
+        if(feedId == null)
+            throw new StorageException("feed id is null");
+        GDataAccount account = getServerBaseFeed(feedId).getAccount();
+        if(account == null)
+            throw new IllegalStateException("No account stored with feed -- feedID: "+feedId);
+        
+        return account.getName();
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#getEntryLastModified(java.lang.String, java.lang.String)
+     */
+    public Long getEntryLastModified(String entryId, final String feedId)
+            throws StorageException {
+        if(entryId == null)
+            throw new StorageException("Entry ID is null");
+        return new Long(getInternalEntry(entryId).getUpdateTime());
+    }
+    
+    @SuppressWarnings("unchecked")
+    private ServerBaseFeed getServerBaseFeed(String feedId)throws StorageException{
+        Query query = this.container.query();
+        query.constrain(ServerBaseFeed.class);
+        query.descend("feed").descend("id").constrain(feedId);
+        ObjectSet<ServerBaseFeed> feed =  query.execute();
+        if (feed.size() > 1)
+            throw new StorageException("Query for feed id " + feedId
+                    + " returns more than one result");
+        if (feed.size() < 1)
+            throw new StorageException("can not find feed for given feed id -- "
+                + feedId);
+        return feed.next();
+    }
+    
+    /*
+     * !Caution! -- could instantiate a lot of objects if used with certain classes!!
+     * Refresh a persisted object with a depth of 100
+     * 
+     */
+    private void refreshPersistentObject(Object o){
+        this.container.ext().refresh(o,100);
+    }
+    
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#getFeedLastModified(java.lang.String)
+     */
+    public Long getFeedLastModified(String feedId) throws StorageException {
+        if(feedId == null)
+            throw new StorageException("can not get last modified -- id is null");
+        ServerBaseFeed feed = getServerBaseFeed(feedId);
+        return new Long(feed.getUpdated().getValue());
+     
+    }
+    
+    private BaseEntry clearDynamicElements(BaseEntry entry){
+        this.container.ext().refresh(entry.getLinks(), 2);
+        return entry;
+    }
+    private BaseFeed clearDynamicElements(BaseFeed feed){
+        this.container.ext().refresh(feed.getLinks(), 2);
+        feed.getEntries().clear();
+        return feed;
+    }
+    ObjectContainer getContainer(){
+        return this.container;
+    }
+
+    static class DB4oEntry {
+        private BaseEntry entry;
+        
+        private int version;
+
+        private String feedId;
+
+        private long updateTime;
+
+        /**
+         * @return Returns the entry.
+         */
+        protected BaseEntry getEntry() {
+            return this.entry;
+        }
+
+        /**
+         * @param entry
+         *            The entry to set.
+         */
+        protected void setEntry(BaseEntry entry) {
+            this.entry = entry;
+        }
+
+        /**
+         * @return Returns the feed.
+         */
+        protected String getFeedId() {
+            return this.feedId;
+        }
+
+        /**
+         * @param feed
+         *            The feed to set.
+         */
+        protected void setFeedId(String feed) {
+            this.feedId = feed;
+        }
+
+        /**
+         * @return Returns the updateTime.
+         */
+        protected long getUpdateTime() {
+            return this.updateTime;
+        }
+
+        /**
+         * @param updateTime
+         *            The updateTime to set.
+         */
+        protected void setUpdateTime(long updateTime) {
+            this.updateTime = updateTime;
+        }
+
+        /**
+         * @return Returns the version.
+         */
+        public int getVersion() {
+            return this.version;
+        }
+
+        /**
+         * @param version The version to set.
+         */
+        public void setVersion(int version) {
+            this.version = version;
+            if(this.entry != null)
+                this.entry.setVersionId(""+this.version);
+        }
+
+    }
+    
+    
+    
+    
+    
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/db4o/ObjectServerDecorator.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/db4o/ObjectServerDecorator.java
new file mode 100755
index 0000000..2430e7a
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/db4o/ObjectServerDecorator.java
@@ -0,0 +1,70 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.storage.db4o;
+
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.Method;
+import java.lang.reflect.Type;
+
+import com.db4o.Db4o;
+import com.db4o.ObjectServer;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class ObjectServerDecorator implements InvocationHandler {
+    private final int port;
+    private final String user;
+    private final String password;
+    private final String host;
+    private Method openClient;
+    /**
+     * 
+     */
+    public ObjectServerDecorator(String user, String password, String host, int port) {
+        this.user = user;
+        this.password = password;
+        this.host = host;
+        this.port = port;
+        try {
+            this.openClient = ObjectServer.class.getMethod("openClient",new Class[]{});
+        } catch (Exception e) {
+         //ignore method is visible   
+            e.printStackTrace();
+        }
+    }
+
+    /**
+     * @see java.lang.reflect.InvocationHandler#invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
+     */
+    public Object invoke(Object arg0, Method arg1, Object[] arg2)
+            throws Throwable {
+        if(arg1.equals(this.openClient)){
+            return Db4o.openClient(this.host,this.port, this.user, this.password);
+        }
+        Class clazz = arg1.getReturnType();
+        
+        if(!clazz.isPrimitive())
+            return null;
+        if(clazz == Boolean.TYPE)
+            return false;
+        return 0;
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/db4o/package.html b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/db4o/package.html
new file mode 100755
index 0000000..a0210c4
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/db4o/package.html
@@ -0,0 +1,10 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
+<html> 
+<head> 
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
+   <meta name="Author" content="Simon Willnauer"> 
+</head> 
+<body> 
+DB4o storage implementation  (needs third patry jar) <a href="http://www.db4o.com">DB4o Website</a>
+</body> 
+</html> 
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/ConcurrentStorageLock.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/ConcurrentStorageLock.java
new file mode 100755
index 0000000..df89cef
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/ConcurrentStorageLock.java
@@ -0,0 +1,51 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.storage.lucenestorage;
+
+/**
+ * 
+ * @author Simon Willnauer
+ *
+ */
+public interface ConcurrentStorageLock {
+    
+    /**
+     * @param key
+     * @return
+     */
+    public abstract boolean setLock(final String key);
+    /**
+     * @param key
+     * @return
+     */
+    public abstract boolean releaseLock(final String key);
+    /**
+     * @return
+     */
+    public abstract boolean releaseThreadLocks();
+    /**
+     * @param key
+     * @return
+     */
+    public abstract boolean isKeyLocked(final String key);
+    /**
+     * 
+     */
+    public abstract void close();
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/ModifiedEntryFilter.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/ModifiedEntryFilter.java
new file mode 100644
index 0000000..e69de29
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/SingleHostConcurrentStorageLock.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/SingleHostConcurrentStorageLock.java
new file mode 100755
index 0000000..1f1f875
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/SingleHostConcurrentStorageLock.java
@@ -0,0 +1,176 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.storage.lucenestorage;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class SingleHostConcurrentStorageLock implements ConcurrentStorageLock {
+    private volatile static ConcurrentStorageLock INSTANCE = null;
+    private final Map<String,Thread> locks;
+    private final Map<Thread,String> threads;
+    private final ReentrantReadWriteLock synLock = new ReentrantReadWriteLock();
+    private final Lock readLock = this.synLock.readLock();
+    private final Lock writeLock = this.synLock.writeLock();
+    private final AtomicBoolean isClosed = new AtomicBoolean(false);
+    /**
+     * 
+     */
+    private SingleHostConcurrentStorageLock() {
+        super();
+        this.locks = new HashMap<String,Thread>(10);
+        this.threads = new HashMap<Thread,String>(10);
+    }
+    protected static synchronized ConcurrentStorageLock getConcurrentStorageLock(){
+        if(INSTANCE == null)
+            INSTANCE = new SingleHostConcurrentStorageLock();
+        return INSTANCE;
+    }
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.ConcurrentStorageLock#setLock(java.lang.String)
+     */
+    public boolean setLock(String key) {
+       this.writeLock.lock();
+       try{
+           if(this.isClosed.get())
+               throw new IllegalStateException("Lock has been closed");
+           Thread t = Thread.currentThread();
+           if(this.threads.containsKey(t))
+               throw new ConcurrencyException("one thread must not obtain more than one lock -- single thread can not modify more than one resource");
+           if(this.locks.containsKey(key)){
+               return false;
+           }
+           this.locks.put(key, t);
+           this.threads.put(t,key);
+           return true;
+           
+       }finally{
+           this.writeLock.unlock();
+       }
+        
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.ConcurrentStorageLock#releaseLock(java.lang.String)
+     */
+    public boolean releaseLock(String key) {
+        this.writeLock.lock();
+        try{
+            if(this.isClosed.get())
+                throw new IllegalStateException("Lock has been closed");
+            Thread t = Thread.currentThread();
+            if(!this.threads.containsKey(t))
+                return false;
+            
+            if(!this.locks.containsKey(key))
+                return false;
+            if(t != this.locks.get(key))
+                throw new ConcurrencyException("Illegal lock access -- current thread is not owner");
+            this.locks.remove(key);
+            this.threads.remove(t);
+            return true;
+            
+        }finally{
+            this.writeLock.unlock();
+        }
+        
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.ConcurrentStorageLock#releaseThreadLocks()
+     */
+    public boolean releaseThreadLocks() {
+        this.writeLock.lock();
+        try{
+            if(this.isClosed.get())
+                throw new IllegalStateException("Lock has been closed");
+            Thread t = Thread.currentThread();
+            if(!this.threads.containsKey(t))
+                return false;
+            String key = this.threads.get(t);
+            this.threads.remove(t);
+            if(!this.locks.containsKey(key))
+                return false;
+            this.locks.remove(key);
+            return true;
+            
+        }finally{
+            this.writeLock.unlock();
+        }
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.ConcurrentStorageLock#isKeyLocked(java.lang.String)
+     */
+    public boolean isKeyLocked(String key) {
+        this.readLock.lock();
+        try{
+            if(this.isClosed.get())
+                throw new IllegalStateException("Lock has been closed");
+           return this.locks.containsKey(key);
+        }finally{
+            this.readLock.unlock();
+        }
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.ConcurrentStorageLock#close()
+     */
+    public void close() {
+        this.writeLock.lock();
+        try{
+            if(this.isClosed.get())
+                throw new IllegalStateException("Lock has been closed");
+            this.isClosed.set(true);
+            this.locks.clear();
+            this.threads.clear();
+            INSTANCE = new SingleHostConcurrentStorageLock();
+        }finally{
+            this.writeLock.unlock();
+        }
+    }
+    
+    
+    protected void forceClear(){
+        this.writeLock.lock();
+        try{
+            if(this.isClosed.get())
+                throw new IllegalStateException("Lock has been closed");
+            this.locks.clear();
+            this.threads.clear();
+            
+        }finally{
+            this.writeLock.unlock();
+        }
+    }
+    static class ConcurrencyException extends RuntimeException{
+      
+        private static final long serialVersionUID = 6388236477729760962L;
+
+        ConcurrencyException(String message){
+            super(message);
+        }
+    }
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageAccountWrapper.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageAccountWrapper.java
new file mode 100644
index 0000000..e721ccc
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageAccountWrapper.java
@@ -0,0 +1,111 @@
+package org.apache.lucene.gdata.storage.lucenestorage;
+
+import java.net.MalformedURLException;
+import java.net.URL;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.gdata.data.GDataAccount;
+
+/**
+ * Wrapps a User Object.
+ * The wrapper provides also a Lucene repesentation of the user;
+ * User Objects will not be Buffered in the lucene storage component. Each User will be written imidialtely.
+ * @author Simon Willnauer
+ *
+ */
+public class StorageAccountWrapper implements StorageWrapper{
+    private static final Log LOG = LogFactory.getLog(StorageAccountWrapper.class);
+    
+    /**
+     * Lucene field for the username
+     */
+    public static final String FIELD_ACCOUNTNAME = "accountName";
+    /**
+     * Lucene field for the password
+     */
+    public static final String FIELD_PASSWORD = "passwd";
+    /**
+     * Lucene field for the author name
+     */
+    public static final String FIELD_AUTHORNAME = "author";
+    /**
+     * Lucene field for the author mail address
+     */
+    public static final String FIELD_AUTHORMAIL = "authorMail";
+    /**
+     * Lucene field for the author link
+     */
+    public static final String FIELD_AUTHORHREF = "authorHref";
+    /**
+     * Lucene field fot the userroles
+     */
+    public static final String FIELD_ROLES = "userroles";
+    private final GDataAccount user;
+    /**
+     * @param user - the user to be wrapped
+     */
+    public StorageAccountWrapper(final GDataAccount user) {
+        if(user == null)
+            throw new IllegalArgumentException("user must not be null");
+        this.user = user;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageWrapper#getLuceneDocument()
+     */
+    public Document getLuceneDocument() {
+        Document doc = new Document();
+        
+        doc.add(new Field(FIELD_ACCOUNTNAME,this.user.getName(),Field.Store.YES,Field.Index.UN_TOKENIZED));
+        doc.add(new Field(FIELD_PASSWORD,this.user.getPassword()==null?"":this.user.getPassword(),Field.Store.YES,Field.Index.NO));
+        doc.add(new Field(FIELD_AUTHORNAME,this.user.getAuthorname()==null?"":this.user.getAuthorname(),Field.Store.YES,Field.Index.NO));
+        doc.add(new Field(FIELD_AUTHORMAIL,this.user.getAuthorMail()==null?"":this.user.getAuthorMail(),Field.Store.YES,Field.Index.NO));
+        doc.add(new Field(FIELD_AUTHORHREF,this.user.getAuthorLink()==null?"":this.user.getAuthorLink().toString(),Field.Store.YES,Field.Index.NO));
+        doc.add(new Field(FIELD_ROLES, Integer.toString(this.user.getRolesAsInt()),Field.Store.YES,Field.Index.NO)); 
+       
+        return doc;
+    }
+   
+   
+    
+    
+    /**
+     * @param doc - a lucene document representation of an user
+     * @return - the user to build from the document. or <code>null</code> if the document is <code>null</code>
+     */
+    public static GDataAccount buildEntity(final Document doc){
+        if(doc == null)
+            return null;
+        
+        GDataAccount user = new GDataAccount();
+        user.setName(doc.get(FIELD_ACCOUNTNAME));
+        user.setPassword(doc.get(FIELD_PASSWORD));
+        user.setAuthorname(doc.get(FIELD_AUTHORNAME));
+        user.setAuthorMail(doc.get(FIELD_AUTHORMAIL));
+        try{
+        user.setRolesAsInt(Integer.parseInt(doc.get(FIELD_ROLES)));
+        }catch (NumberFormatException e) {
+            LOG.info("Can't parse userroles: "+user.getName()+" throws NumberFormatException. -- skipping --",e);
+        }
+        try {
+            if(doc.get(FIELD_AUTHORHREF)!= null)
+                user.setAuthorLink(new URL(doc.get(FIELD_AUTHORHREF)));
+        } catch (MalformedURLException e) {
+            LOG.info("SPECIFIED URL for user: "+user.getName()+" throws MalformedURLException. -- skipping --",e);
+        }
+        return user;
+    }
+    
+   
+
+    /**
+     * @return - the wrapped user
+     */
+    public GDataAccount getUser() {
+        return this.user;
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageBuffer.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageBuffer.java
new file mode 100644
index 0000000..ceaf4de
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageBuffer.java
@@ -0,0 +1,359 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+
+package org.apache.lucene.gdata.storage.lucenestorage;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.Map.Entry;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper.StorageOperation;
+import org.apache.lucene.gdata.utils.ModifiedEntryFilter;
+
+import com.google.gdata.data.BaseEntry;
+import com.google.gdata.data.ExtensionProfile;
+import com.google.gdata.data.Link;
+
+/**
+ * The StorageBuffer is used to buffer incoming updates, deletes and inserts to
+ * the storage. The storage uses an lucene index to store the enries. As
+ * modifying the index all the time an altering request comes in is not
+ * efficent. The entries will be added to the buffer to be available for
+ * incoming storage queries. If the loadfactor for the
+ * {@link org.apache.lucene.gdata.storage.lucenestorage.StorageModifier} is
+ * reached the modifier will perform a batch update on the index. Each entry
+ * will be associated with a feed id inside a associative datastructure to
+ * return a requested entry efficiently.
+ * <p>
+ * This implementation uses {@link java.util.concurrent.locks.ReadWriteLock}.
+ * The read lock may be held simultaneously by multiple reader threads, so long
+ * as there are no writers. The write lock is exclusive.
+ * </p>
+ * <p>
+ * The entry and feed ID's must not be a composite key. The entry and feed ID
+ * must be unique.
+ * </p>
+ * 
+ * @see java.util.concurrent.locks.ReentrantReadWriteLock
+ * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier
+ * @see org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class StorageBuffer {
+    private static final Log LOG = LogFactory.getLog(StorageBuffer.class);
+
+    private final Map<String, Map<String, StorageEntryWrapper>> bufferMap;
+
+    private final Map<String, Long> modifiyMap;
+
+    private final List<String> excludeList;
+
+    private final ReadWriteLock lock = new ReentrantReadWriteLock(true);
+
+    private final Lock readLock = this.lock.readLock();
+
+    private final Lock writeLock = this.lock.writeLock();
+
+    private final int bufferSize;
+
+    protected final static int DEFAULT_BUFFER_COUNT = 10;
+
+    /**
+     * Constructs a new StorageBuffer.
+     * <p>
+     * The expectedBufferCount sould be higher than the maximum of entries added
+     * to the buffer, resizing the buffer is very efficient. For detailed
+     * infomation {@link HashMap} as this is used inside the buffer
+     * </p>
+     * 
+     * @param expectedBufferCount -
+     *            the expected size of the buffer
+     * 
+     */
+    protected StorageBuffer(final int expectedBufferCount) {
+        this.bufferSize = expectedBufferCount < DEFAULT_BUFFER_COUNT ? DEFAULT_BUFFER_COUNT
+                : expectedBufferCount;
+        this.bufferMap = new HashMap<String, Map<String, StorageEntryWrapper>>(
+                this.bufferSize);
+        this.excludeList = new ArrayList<String>(this.bufferSize);
+        this.modifiyMap = new HashMap<String, Long>(this.bufferSize);
+    }
+
+    /**
+     * Adds a {@link StorageEntryWrapper} to the buffer. If a wrapper
+     * representing the same entry are already in the buffer the wrapper will be
+     * replaced.
+     * <p>
+     * This method does ignore already delted entries. This should before the
+     * entry is added to the buffer.
+     * </p>
+     * 
+     * @param wrapper -
+     *            the wrapper to buffer
+     */
+    public void addEntry(final StorageEntryWrapper wrapper) {
+        this.writeLock.lock();
+        try {
+            if (LOG.isInfoEnabled())
+                LOG.info(" Buffering wrapper - " + wrapper.getOperation()
+                        + " ID: " + wrapper.getEntryId() + " FeedID: "
+                        + wrapper.getFeedId());
+            if (wrapper.getOperation().equals(StorageOperation.DELETE))
+                return;
+            String feedId = wrapper.getFeedId();
+            if (this.bufferMap.containsKey(feedId))
+                this.bufferMap.get(feedId).put(wrapper.getEntryId(), wrapper);
+            else {
+                Map<String, StorageEntryWrapper> newFeedMap = new HashMap<String, StorageEntryWrapper>(
+                        20);
+                newFeedMap.put(wrapper.getEntryId(), wrapper);
+                this.bufferMap.put(feedId, newFeedMap);
+
+            }
+            addLastModified(wrapper.getFeedId(), wrapper.getTimestamp());
+            /*
+             * add to exclude from searches doc will be available via the buffer
+             * if the entry is not already in the buffer
+             */
+            if (!this.excludeList.contains(wrapper.getEntryId()))
+                this.excludeList.add(wrapper.getEntryId());
+        } finally {
+            this.writeLock.unlock();
+        }
+    }
+
+    private void addLastModified(final String feedId, Long timestamp) {
+        this.writeLock.lock();
+        try {
+            if (this.modifiyMap.containsKey(feedId))
+                this.modifiyMap.remove(feedId);
+            this.modifiyMap.put(feedId, timestamp);
+        } finally {
+            this.writeLock.unlock();
+        }
+
+    }
+
+    /**
+     * the timestamp of the last modification for the given feed id
+     * 
+     * @param feedId -
+     *            feed id
+     * @return timestamp
+     */
+    protected Long getFeedLastModified(final String feedId) {
+        this.readLock.lock();
+        try {
+            return this.modifiyMap.get(feedId);
+        } finally {
+            this.readLock.unlock();
+        }
+    }
+
+    protected Set<Entry<String, Long>> getLastModified() {
+        return this.modifiyMap.entrySet();
+    }
+
+    /**
+     * Returns all entries for the given feed id sorted by the update timestamp
+     * desc.
+     * 
+     * @param feedId -
+     *            the feed id
+     * @return a {@link List} of all {@link StorageEntryWrapper} object buffered
+     *         in this buffer or an empty list if not entry has been buffered
+     *         for the given feed
+     */
+    public List<StorageEntryWrapper> getSortedEntries(String feedId) {
+        this.readLock.lock();
+        try {
+            if (!this.bufferMap.containsKey(feedId))
+                return null;
+            Map<String, StorageEntryWrapper> tempMap = this.bufferMap
+                    .get(feedId);
+            if (tempMap == null)
+                return null;
+            Collection<StorageEntryWrapper> col = tempMap.values();
+            List<StorageEntryWrapper> returnList = new ArrayList<StorageEntryWrapper>(
+                    col);
+            Collections.sort(returnList);
+            return returnList;
+
+        } finally {
+            this.readLock.unlock();
+        }
+
+    }
+
+    /**
+     * Adds a deleted entry to the buffer.
+     * 
+     * @param entryId -
+     *            the deleted entry id
+     * @param feedId -
+     *            the feed of the entry
+     */
+    public void addDeleted(final String entryId, final String feedId) {
+        this.writeLock.lock();
+        try {
+            Map<String, StorageEntryWrapper> tempMap = this.bufferMap
+                    .get(feedId);
+            if (tempMap != null) {
+                tempMap.remove(entryId);
+                this.addLastModified(feedId, new Long(System
+                        .currentTimeMillis()));
+            }
+            /*
+             * add to exclude from searches
+             */
+            if (!this.excludeList.contains(entryId))
+                this.excludeList.add(entryId);
+        } finally {
+
+            this.writeLock.unlock();
+
+        }
+
+    }
+
+    /**
+     * Returns an entry for the given entry id in the feed context spezified by
+     * the feed id;
+     * 
+     * @param entryId -
+     *            the id of the entry to return
+     * @param feedId -
+     *            the feed containing the entry
+     * @return - the entry or <code>null</code> if the corresponding entry is
+     *         not in the buffer.
+     */
+    public StorageEntryWrapper getEntry(final String entryId,
+            final String feedId) {
+        this.readLock.lock();
+        try {
+
+            if (this.bufferMap.containsKey(feedId))
+                return this.bufferMap.get(feedId).get(entryId);
+            return null;
+
+        } finally {
+            this.readLock.unlock();
+        }
+    }
+
+    /**
+     * The buffer contains updated and delete entries. These entries are already
+     * available in the lucene index but should not be found during search.
+     * 
+     * <p>
+     * This list contains all entries should not be found by the index searcher.
+     * This method creates a copy of the current list to prevent concurrent
+     * modification exceptions while iteration over the collection.
+     * </p>
+     * 
+     * 
+     * @see ModifiedEntryFilter
+     * @return - a String array of entries to be omitted from a lucene index
+     *         search
+     */
+    public String[] getExculdList() {
+        this.readLock.lock();
+        try {
+            return this.excludeList
+                    .toArray(new String[this.excludeList.size()]);
+        } finally {
+            this.readLock.unlock();
+        }
+    }
+
+    // not synchronized --> see close()
+    private void clearBuffer() {
+
+        this.bufferMap.clear();
+        this.excludeList.clear();
+        this.modifiyMap.clear();
+
+    }
+
+    /**
+     * clears the buffer -
+     */
+    public void close() {
+        this.writeLock.lock();
+        try {
+            clearBuffer();
+        } finally {
+            this.writeLock.unlock();
+        }
+
+    }
+
+    static class BufferableEntry extends BaseEntry {
+
+        /**
+         * 
+         */
+        @SuppressWarnings("unchecked")
+        public BufferableEntry() {
+            super();
+            this.links = new LinkedList<Link>();
+        }
+
+        /**
+         * @param arg0
+         */
+        @SuppressWarnings("unchecked")
+        public BufferableEntry(BaseEntry arg0) {
+            super(arg0);
+            if (this.links.size() > 0) {
+                LinkedList list = new LinkedList<Link>();
+                list.addAll(this.links);
+                this.links = list;
+            } else
+                this.links = new LinkedList<Link>();
+        }
+
+        /**
+         * @see com.google.gdata.data.BaseEntry#declareExtensions(com.google.gdata.data.ExtensionProfile)
+         */
+        @Override
+        public void declareExtensions(ExtensionProfile arg0) {
+            //
+        }
+
+    }
+
+    /**
+     * @return Returns the bufferSize.
+     */
+    public int getBufferSize() {
+        return this.bufferSize;
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageCoreController.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageCoreController.java
new file mode 100644
index 0000000..9c10004
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageCoreController.java
@@ -0,0 +1,610 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.storage.lucenestorage;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.locks.Condition;
+import java.util.concurrent.locks.ReentrantLock;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.analysis.standard.StandardAnalyzer;
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.server.registry.Component;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+import org.apache.lucene.gdata.server.registry.configuration.Requiered;
+import org.apache.lucene.gdata.storage.IDGenerator;
+import org.apache.lucene.gdata.storage.Storage;
+import org.apache.lucene.gdata.storage.StorageController;
+import org.apache.lucene.gdata.storage.StorageException;
+import org.apache.lucene.gdata.storage.lucenestorage.recover.RecoverController;
+import org.apache.lucene.gdata.storage.lucenestorage.recover.RecoverException;
+import org.apache.lucene.gdata.utils.ReferenceCounter;
+import org.apache.lucene.index.IndexModifier;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.FSDirectory;
+
+/**
+ *  
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+@Component(componentType = ComponentType.STORAGECONTROLLER)
+public class StorageCoreController implements StorageController {
+    
+    protected static final Log LOG = LogFactory
+            .getLog(StorageCoreController.class);
+
+    private IndexSearcher searcher;
+
+    private Directory storageDir;
+
+    private StorageModifier modifier;
+
+    private ReferenceCounter<StorageQuery> storageQuery;
+
+    private StorageBuffer currentBuffer;
+    private final AtomicBoolean isClosed = new AtomicBoolean(false);
+    private final ReentrantLock storageControllerLock = new ReentrantLock();
+    private final Condition closeCondition;
+
+    private static final int DEFAULT_STORAGE_BUFFER_SIZE = 3;
+
+    private static final int DEFAULT_STORAGE_PERSIST_FACTOR = 3;
+    
+    private static final String RECOVERDIRECTORY = "recover";
+
+    private static final String STORAGELOG = ".lucenestorage";
+
+    private IDGenerator idGenerator;
+
+    private final ConcurrentStorageLock storageLock;
+    /*
+     *properties set by configuration file e.g. Registry
+     */
+    private int indexOptimizeInterval;
+    
+    private String storageDirectory; 
+ 
+    private boolean keepRecoveredFiles; 
+ 
+    private boolean recover; 
+    
+    private int storageBufferSize;
+
+    private int storagePersistFactor;
+    
+    private RecoverController recoverController;
+    /**
+     * @see org.apache.lucene.gdata.server.registry.ServerComponent#initialize()
+     */
+    public void initialize() {
+        synchronized (StorageCoreController.class) {
+         
+            try {
+                this.idGenerator = new IDGenerator(10);
+            } catch (Exception e) {
+                throw new StorageException("Can't create ID Generator", e);
+            }
+
+            boolean createNewStorage = false;
+          
+            if (this.storageDir == null) {
+
+                
+                File storeDir = new File(this.storageDirectory);
+                File storageLog = new File(storeDir.getAbsolutePath()
+                        + System.getProperty("file.separator") + STORAGELOG);
+                try {
+                    if (storeDir.isDirectory() && !storageLog.exists()) {
+
+                        if (createLuceneStorageLog(storeDir)) {
+                            this.storageDir = FSDirectory.getDirectory(
+                                    storeDir, true);
+                            createNewStorage = true;
+                        } else
+                            throw new StorageException(
+                                    "could not create storage lock file in "
+                                            + this.storageDirectory);
+
+                    } else
+                        this.storageDir = FSDirectory.getDirectory(storeDir,
+                                false);
+                } catch (IOException e) {
+                    storageLog.delete();
+                    throw new StorageException(e);
+                }
+                
+                this.storageBufferSize = this.storageBufferSize < DEFAULT_STORAGE_BUFFER_SIZE ? DEFAULT_STORAGE_BUFFER_SIZE
+                        : this.storageBufferSize;
+                this.storagePersistFactor = this.storagePersistFactor < DEFAULT_STORAGE_PERSIST_FACTOR ? DEFAULT_STORAGE_PERSIST_FACTOR
+                        : this.storagePersistFactor;
+
+            }else
+                createNewStorage = true;
+               
+
+            this.currentBuffer = new StorageBuffer(this.storageBufferSize);
+            try{
+            this.modifier = createStorageModifier(createNewStorage);
+            this.searcher = new IndexSearcher(this.storageDir);
+            }catch (Exception e) {
+               throw new StorageException("Can not create Searcher/Modifier -- "+e.getMessage(),e);
+            }
+           
+            
+            if(createNewStorage)
+                createAdminAccount();
+            if(!this.recover)
+                return;
+            try{
+            tryRecover();
+            }catch (Exception e) {
+                LOG.fatal("Recovering failed",e);
+                throw new StorageException("Recovering failed -- "+e.getMessage(),e); 
+            }
+            
+            this.recoverController = createRecoverController(false,false);
+            try{
+            this.recoverController.initialize();
+            }catch (Exception e) {
+                LOG.fatal("Can not initialize recover controller",e);
+                throw new StorageException("Can not initialize recover controller -- "+e.getMessage(),e);
+            }
+
+        }
+    }
+    /*
+     * reads the remaining recover files to store the failed entries
+     */
+    private void tryRecover() throws IOException, RecoverException{
+        if(!this.recover)
+            return;
+        LOG.info("try to recover files if there are any");
+        this.recoverController = createRecoverController(true,false);
+        this.recoverController.initialize();
+        this.recoverController.recoverEntries(this.modifier);
+        this.recoverController.destroy();
+    }
+    
+    private RecoverController createRecoverController(boolean doRecover, boolean keepfiles){
+        String recoverDirectory = null;
+        if(this.storageDirectory.endsWith("/") || this.storageDirectory.endsWith("\\"))
+            recoverDirectory = this.storageDirectory.substring(0,this.storageDirectory.length()-1)+System.getProperty("file.separator")+RECOVERDIRECTORY;
+        else
+            recoverDirectory = this.storageDirectory+System.getProperty("file.separator")+RECOVERDIRECTORY;
+        File recoverDirectoryFile = new File(recoverDirectory);
+       return new RecoverController(recoverDirectoryFile,doRecover,keepfiles);
+    }
+    /**
+     * Creates a new <tt>StoragCoreController</tt>
+     */
+    public StorageCoreController() {
+        this.closeCondition = this.storageControllerLock.newCondition();
+        this.storageLock = SingleHostConcurrentStorageLock.getConcurrentStorageLock();
+
+    }
+
+    private StorageModifier createStorageModifier(boolean create)
+            throws IOException {
+        IndexModifier indexModifier = new IndexModifier(this.storageDir,
+                new StandardAnalyzer(), create);
+        return new StorageModifier(this, indexModifier, this.currentBuffer,
+                this.storagePersistFactor, this.indexOptimizeInterval);
+    }
+
+    /**
+     * returns the current storage modifier
+     * 
+     * @return - the current storage modifier
+     */
+    protected StorageModifier getStorageModifier() {
+        return this.modifier;
+    }
+
+    /**
+     * returns a <tt>StorageQuery</tt> to query the storage index. The
+     * returned object is a reference counter to keep track of the references to
+     * the <tt>StorageQuery</tt>. The reference is already incremented before
+     * returned from this method.
+     * <p>
+     * if the reference counter has no remaining references the resource e.g.
+     * the <tt>StorageQuery</tt> will be closed. This ensures that a
+     * <tt>StorageQuery</tt> instance will be around as long as needed and
+     * the resources will be released. The reference counter should be
+     * decremented by clients after finished using the query instance.
+     * </p>
+     * 
+     * @return a {@link ReferenceCounter} instance holding the StorageQuery as a
+     *         resource.
+     * 
+     */
+    protected ReferenceCounter<StorageQuery> getStorageQuery() {
+    	if(this.isClosed.get())
+    		throw new IllegalStateException("StorageController is already closed -- server is shutting down");
+        this.storageControllerLock.lock();
+        try{
+        	if(this.isClosed.get())
+        		throw new IllegalStateException("StorageController is already closed -- server is shutting down");
+            if (this.storageQuery == null) {
+                this.storageQuery = getNewStorageQueryHolder(new StorageQuery(
+                        this.currentBuffer, this.searcher));
+                if (LOG.isInfoEnabled())
+                    LOG.info("Release new StorageQuery");
+            }
+            this.storageQuery.increamentReference();
+            return this.storageQuery;
+        }finally{
+            try{
+        	this.closeCondition.signalAll();
+            }catch (Throwable e) {/**/}
+        	this.storageControllerLock.unlock();
+        }
+    }
+
+    private ReferenceCounter<StorageQuery> getNewStorageQueryHolder(
+            final StorageQuery query) {
+        ReferenceCounter<StorageQuery> holder = new ReferenceCounter<StorageQuery>(
+                query) {
+            @Override
+			public void close() {
+                try {
+                    if (LOG.isInfoEnabled())
+                        LOG
+                                .info("close StorageQuery -- zero references remaining");
+                    this.resource.close();
+                } catch (IOException e) {
+                    LOG.warn("Error during close call on StorageQuery"
+                            + e.getMessage(), e);
+                }
+            }
+        };
+        holder.increamentReference();
+        return holder;
+    }
+
+    /**
+     * Forces the controller to register a new <tt>StorageQuery</tt> instance.
+     * This method will be called after an index has been modified to make the
+     * changes available for searching.
+     * 
+     * @throws IOException -
+     *             if an IO exception occurs
+     */
+    protected void registerNewStorageQuery() throws IOException {
+    	if(this.isClosed.get())
+    		throw new IllegalStateException("StorageController is already closed -- server is shutting down");
+        this.storageControllerLock.lock();
+        try{
+        	if(this.isClosed.get())
+        		throw new IllegalStateException("StorageController is already closed -- server is shutting down");
+	        if (LOG.isInfoEnabled())
+	            LOG.info("new StorageQuery requested -- create new storage buffer");
+        
+            if (this.storageQuery != null)
+                this.storageQuery.decrementRef();
+            this.searcher = new IndexSearcher(this.storageDir);
+            this.storageQuery = null;
+            this.currentBuffer = new StorageBuffer(this.storageBufferSize);
+
+        }finally{
+            try{
+                this.closeCondition.signalAll();
+                }catch (Throwable e) {/**/}
+        	this.storageControllerLock.unlock();
+        }
+
+    }
+
+    /**
+     * Creates a new StorageBuffer
+     * 
+     * @return the new StorageBuffer
+     */
+    protected StorageBuffer releaseNewStorageBuffer() {
+    	if(this.isClosed.get())
+    		throw new IllegalStateException("StorageController is already closed -- server is shutting down");
+        this.storageControllerLock.lock();
+        try{
+        	if(this.isClosed.get())
+        		throw new IllegalStateException("StorageController is already closed -- server is shutting down");
+            return this.currentBuffer;
+        }finally{
+            try{
+        	this.closeCondition.signalAll();
+            }catch (Throwable e) {/**/}
+        	this.storageControllerLock.unlock();
+        }
+    }
+
+    /**
+     * Creates a new IndexModifier on the storage index
+     * 
+     * @return - a new modifier
+     * @throws IOException -
+     *             if an IO exception occurs
+     */
+    protected IndexModifier createIndexModifier() throws IOException {
+    	if(this.isClosed.get())
+    		throw new IllegalStateException("StorageController is already closed -- server is shutting down");
+        this.storageControllerLock.lock();
+        try{
+        	if(this.isClosed.get())
+        		throw new IllegalStateException("StorageController is already closed -- server is shutting down");
+	        if (LOG.isInfoEnabled())
+	            LOG.info("new IndexModifier created - release to StorageModifier");
+        
+            return new IndexModifier(this.storageDir, new StandardAnalyzer(),
+                    false);
+        }finally{
+            try{
+                this.closeCondition.signalAll();
+                }catch (Throwable e) {/**/}
+        	this.storageControllerLock.unlock();
+        }
+    }
+
+    private void close() throws IOException {
+    	if(this.isClosed.get())
+    		throw new IllegalStateException("StorageController is already closed -- server is shutting down");
+    	
+        this.storageControllerLock.lock();
+        try{
+        	if(this.isClosed.get())
+        		throw new IllegalStateException("StorageController is already closed -- server is shutting down");
+        	this.isClosed.set(true);
+        	while(this.storageControllerLock.getQueueLength()>0)
+        		try{
+        		this.closeCondition.await();
+        		}catch (Exception e) {
+					//
+				}
+            if (LOG.isInfoEnabled())
+                LOG.info("StorageController has been closed -- server is shutting down -- release all resources");
+            if (this.storageQuery != null)
+                this.storageQuery.decrementRef();
+            if(this.recoverController != null)
+                this.recoverController.destroy();
+            this.storageLock.close();
+            this.modifier.close();
+            this.idGenerator.stopIDGenerator();
+		}finally{
+        	this.storageControllerLock.unlock();
+        }
+    }
+
+
+    /**
+     * Forces the StorageModifier to write all buffered changes.
+     * 
+     * @throws IOException -
+     *             if an IO exception occurs
+     * 
+     */
+    public void forceWrite() throws IOException {
+    	if(this.isClosed.get())
+    		throw new IllegalStateException("StorageController is already closed -- server is shutting down");
+        this.modifier.forceWrite();
+    }
+
+    private boolean createLuceneStorageLog(File directory)
+            throws IOException {
+        if (directory.isDirectory() && !directory.exists()) {
+            if(!directory.createNewFile())
+                throw new StorageException("Can not create directory -- "+directory);
+        }
+        File file = new File(directory.getAbsolutePath()
+                + System.getProperty("file.separator") + STORAGELOG);
+        return file.createNewFile();
+
+    }
+
+    /**
+     * Creates a unique ID to store as an id for
+     * {@link org.apache.lucene.gdata.data.ServerBaseEntry} instances
+     * 
+     * @return - a unique id
+     * @throws StorageException -
+     *             if no id can be released
+     */
+    public synchronized String releaseId() {
+        try {
+            return this.idGenerator.getUID();
+        } catch (InterruptedException e) {
+            throw new StorageException("Can't release new ID", e);
+        }
+
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.StorageController#destroy()
+     */
+    public void destroy() {
+        try {
+            close();
+        } catch (Exception e) {
+            LOG.error("Closing StorageCoreController failed -- "
+                    + e.getMessage(), e);
+        }
+    }
+
+    /**
+     * 
+     * @return - the lucene directory used as a storage
+     */
+    protected Directory getDirectory() {
+        return this.storageDir;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.StorageController#getStorage()
+     */
+    public Storage getStorage() throws StorageException {
+        try {
+            return new StorageImplementation();
+        } catch (StorageException e) {
+            StorageException ex = new StorageException(
+                    "Can't create Storage instance -- " + e.getMessage(), e);
+            ex.setStackTrace(e.getStackTrace());
+            throw ex;
+
+        }
+    }
+
+
+
+
+    
+    
+    private void createAdminAccount() throws StorageException{
+        GDataAccount adminAccount = GDataAccount.createAdminAccount();
+        StorageAccountWrapper wrapper = new StorageAccountWrapper(adminAccount);
+        this.getStorageModifier().createAccount(wrapper);
+    }
+    
+    protected ConcurrentStorageLock getLock(){
+        return this.storageLock;
+    }
+
+    
+    /**
+     * The size of the <tt>StorageBuffer</tt>.
+     * 
+     * @return - storage buffer size
+     */
+    public int getBufferSize() {
+        return this.storageBufferSize;
+    }
+
+    /**
+     * The size of the <tt>StorageBuffer</tt>. This size should be at least
+     * as big as the persist factor to prevent the <tt>StorageBuffer</tt> from
+     * resizing
+     * 
+     * @param storageBufferSize
+     */
+    @Requiered
+    public void setBufferSize(int storageBufferSize) {
+        this.storageBufferSize = storageBufferSize;
+    }
+
+    /**
+     * An integer value after how many changes to the StorageModifier the
+     * buffered changes will be persisted / written to the index
+     * 
+     * @return - the persist factor
+     */
+    public int getPersistFactor() {
+        return this.storagePersistFactor;
+    }
+
+    /**
+     * @param storagePersistFactor
+     */
+    @Requiered
+    public void setPersistFactor(int storagePersistFactor) {
+        this.storagePersistFactor = storagePersistFactor;
+    }
+
+
+    /**
+     * @return Returns the indexOptimizeInterval.
+     */
+    public int getIndexOptimizeInterval() {
+        return this.indexOptimizeInterval;
+    }
+
+
+    /**
+     * @param indexOptimizeInterval The indexOptimizeInterval to set.
+     */
+    @Requiered
+    public void setOptimizeInterval(int indexOptimizeInterval) {
+        this.indexOptimizeInterval = indexOptimizeInterval;
+    }
+
+
+    /**
+     * @return Returns the keepRecoveredFiles.
+     */
+    public boolean isKeepRecoveredFiles() {
+        return this.keepRecoveredFiles;
+    }
+
+
+    /**
+     * @param keepRecoveredFiles The keepRecoveredFiles to set.
+     */
+    @Requiered
+    public void setKeepRecoveredFiles(boolean keepRecoveredFiles) {
+        this.keepRecoveredFiles = keepRecoveredFiles;
+    }
+
+
+
+    /**
+     * @return Returns the recover.
+     */
+    public boolean isRecover() {
+        return this.recover;
+    }
+
+
+    /**
+     * @param recover The recover to set.
+     */
+    @Requiered
+    public void setRecover(boolean recover) {
+        this.recover = recover;
+    }
+
+
+    /**
+     * @param storageDir The storageDir to set.
+     */
+   
+    public void setStorageDir(Directory storageDir) {
+        this.storageDir = storageDir;
+    }
+
+
+    /**
+     * @param storageDirectory The storageDirectory to set.
+     */
+    @Requiered
+    public void setDirectory(String storageDirectory) {
+        this.storageDirectory = storageDirectory;
+    }
+    
+    protected void writeRecoverEntry(StorageEntryWrapper wrapper) throws RecoverException{
+        if(this.recoverController!= null &&!this.recoverController.isRecovering() )
+            this.recoverController.storageModified(wrapper);
+    }
+    protected void registerNewRecoverWriter() throws IOException {
+        if(this.recoverController == null || this.recoverController.isRecovering())
+            return;
+        this.recoverController.destroy();
+        this.recoverController = createRecoverController(false,false);
+        this.recoverController.initialize();
+            
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageEntryWrapper.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageEntryWrapper.java
new file mode 100644
index 0000000..31962e4
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageEntryWrapper.java
@@ -0,0 +1,249 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+
+package org.apache.lucene.gdata.storage.lucenestorage;
+
+import java.io.IOException;
+import java.io.Serializable;
+import java.io.StringWriter;
+
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.server.registry.ProvidedService;
+import org.apache.lucene.gdata.server.registry.ProvidedServiceConfig;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageBuffer.BufferableEntry;
+
+import com.google.gdata.data.BaseEntry;
+import com.google.gdata.util.common.xml.XmlWriter;
+
+/**
+ * This immutable class wrapps <tt>ServerBaseEntry</tt> for an internal
+ * Storage representation of an entry. This class also acts as a Documentfactory
+ * for lucene documents to be stored inside the index.
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class StorageEntryWrapper implements Comparable<StorageEntryWrapper>, Serializable,
+        StorageWrapper {
+
+    private static final long serialVersionUID = -4619985652059888526L;
+    /*
+     * client api uses UTF-8 to encode server requests and entries
+     */
+    private static final String INTERNAL_ENCODING = "UTF-8";
+
+    /**
+     * lucene field name Entry id
+     */
+    public final static String FIELD_ENTRY_ID = "entryId";
+
+    /**
+     * lucene field name feed id
+     */
+    public final static String FIELD_FEED_REFERENCE = "feedReference";
+
+    /**
+     * lucene field name entry content
+     */
+    public final static String FIELD_CONTENT = "content";
+
+    /**
+     * lucene field name creating timestamp
+     */
+    public final static String FIELD_TIMESTAMP = "timestamp";
+
+    /**
+     * lucene field name entry version
+     */
+    public final static String FIELD_VERSION = "entryVersion";
+    private  int version;
+
+    private  String entryId;
+
+    private  String feedId;
+
+    private  String content;
+
+    private transient ServerBaseEntry entry;
+
+    private Long timestamp;
+
+    private Document document;
+
+    private StorageOperation operation;
+
+    private transient ProvidedService config;
+
+    /**
+     * Creates a new StorageEntryWrapper.
+     * 
+     * @param entry -
+     *            the entry to wrap
+     * 
+     * @param operation -
+     *            the StorageOperation
+     * 
+     * @throws IOException -
+     *             if the entry content can not be generated
+     */
+    public StorageEntryWrapper(final ServerBaseEntry entry,
+            StorageOperation operation) throws IOException {
+        this.entry = entry;
+        this.operation = operation;
+        this.entryId = entry.getId();
+        this.feedId = entry.getFeedId();
+        this.version = entry.getVersion();
+        if (operation != StorageOperation.DELETE) {
+            this.config = entry.getServiceConfig();
+            this.content = buildContent();
+            
+         
+        }
+        this.timestamp = new Long(
+                this.entry.getUpdated() != null ? this.entry.getUpdated()
+                        .getValue() : System.currentTimeMillis());
+            
+
+    }
+   
+ 
+    private String buildContent() throws IOException {
+        StringWriter writer = new StringWriter();
+        XmlWriter xmlWriter = new XmlWriter(writer, INTERNAL_ENCODING);
+        this.entry.generateAtom(xmlWriter, this.config.getExtensionProfile());
+        return writer.toString();
+
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageWrapper#getLuceneDocument()
+     */
+    public Document getLuceneDocument() {
+        if(this.operation == StorageOperation.DELETE)
+            return null;
+        if (this.document != null)
+            return this.document;
+        this.document = new Document();
+        this.document.add(new Field(FIELD_ENTRY_ID, this.entryId,
+                Field.Store.YES, Field.Index.UN_TOKENIZED));
+        this.document.add(new Field(FIELD_FEED_REFERENCE, this.feedId,
+                Field.Store.YES, Field.Index.UN_TOKENIZED));
+        this.document.add(new Field(FIELD_CONTENT,this.content,
+                Field.Store.COMPRESS, Field.Index.NO));
+        this.document.add(new Field(FIELD_TIMESTAMP, this.timestamp.toString(),
+                Field.Store.YES, Field.Index.UN_TOKENIZED));
+        this.document.add(new Field(FIELD_VERSION, Integer.toString(this.version),
+                Field.Store.YES, Field.Index.UN_TOKENIZED));
+
+        return this.document;
+
+    }
+
+    /**
+     * @return - the wrapped entry
+     */
+    public BaseEntry getEntry() {
+        /*
+         * this wrapps the entry again. BufferableEntry creates a new instance
+         * for the dynamic element like links.
+         */
+        return new BufferableEntry(this.entry.getEntry());
+    }
+
+    /**
+     * @return - the entry id
+     */
+    public String getEntryId() {
+        return this.entryId;
+    }
+
+    /**
+     * @return - the feed id
+     */
+    public String getFeedId() {
+        return this.feedId;
+    }
+
+    /**
+     * Storage operations
+     * 
+     * @author Simon Willnauer
+     * 
+     */
+    public static enum StorageOperation {
+        /**
+         * delete
+         */
+        DELETE,
+        /**
+         * update
+         */
+        UPDATE,
+        /**
+         * insert
+         */
+        INSERT
+    }
+
+    /**
+     * @return the specified storage operation
+     */
+    public StorageOperation getOperation() {
+        return this.operation;
+    }
+
+    /**
+     * This compare method compares the timestamps of the wrapper instances.
+     * 
+     * @param arg0 -
+     *            the wrapper to compare
+     * @par
+     * @return - 0 if the wrappers timestamp are the same, an integer > 0 if the
+     *         given wrapper is after this wrapper
+     * 
+     */
+    public int compareTo(StorageEntryWrapper arg0) {
+        return arg0.timestamp.equals(this.timestamp) ? 0
+                : (arg0.timestamp > this.timestamp ? 1 : -1);
+    }
+
+    /**
+     * @return - the specified {@link ProvidedServiceConfig}
+     */
+    public ProvidedService getConfigurator() {
+        return this.config;
+    }
+
+    /**
+     * @return Returns the timestamp.
+     */
+    public Long getTimestamp() {
+        return this.timestamp;
+    }
+
+    /**
+     * @return - the version of the entry
+     */
+    public int getVersion() {
+        
+        return this.version;
+    }
+
+
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageFeedWrapper.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageFeedWrapper.java
new file mode 100644
index 0000000..3567b1f
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageFeedWrapper.java
@@ -0,0 +1,107 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.storage.lucenestorage;
+
+import java.io.IOException;
+import java.io.StringWriter;
+
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.gdata.data.ServerBaseFeed;
+import org.apache.lucene.gdata.server.registry.ProvidedService;
+
+import com.google.gdata.data.BaseFeed;
+import com.google.gdata.util.common.xml.XmlWriter;
+
+/**
+ * This immutable class wrapps <tt>GDataAccount</tt> instances for an internal Storage representation of 
+ * an account. This class also acts as a Documentfactory for lucene documents to 
+ * be stored inside the index. 
+ * @author Simon Willnauer
+ *
+ */
+public class StorageFeedWrapper implements StorageWrapper {
+    
+    private static final String INTERNAL_ENCODING = "UTF-8";
+    /**
+     * the account who owns the feed 
+     */
+    public static final String FIELD_ACCOUNTREFERENCE = "accountReference";
+    /**
+     * the id of the feed
+     */
+    public static final String FIELD_FEED_ID = "feedId";
+    /**
+     * The xml feed representation
+     */
+    public static final String FIELD_CONTENT = "content";
+    
+    /**
+     * The creation timestamp
+     */
+    public static final String FIELD_TIMESTAMP = "timestamp";
+
+    /**
+     * The Service this feed belongs to. 
+     */
+    public static final String FIELD_SERVICE_ID = "serviceId";
+    private final ServerBaseFeed feed;
+    private final String accountName;
+    private final ProvidedService config;
+    private final String content;
+    
+    
+    /**
+     * @param feed 
+     * @param accountname 
+     * @throws IOException 
+     * 
+     */
+    public StorageFeedWrapper(final ServerBaseFeed feed, final String accountname) throws IOException {
+        this.feed = feed;
+        this.accountName = accountname;
+        this.config = feed.getServiceConfig();
+        this.content = buildContent();
+       
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageWrapper#getLuceneDocument()
+     */
+    public Document getLuceneDocument() {
+        Document doc = new Document();
+        doc.add(new Field(FIELD_ACCOUNTREFERENCE,this.accountName,Field.Store.YES,Field.Index.UN_TOKENIZED));
+        doc.add(new Field(FIELD_FEED_ID,this.feed.getId(),Field.Store.YES,Field.Index.UN_TOKENIZED));
+        doc.add(new Field(FIELD_CONTENT,this.content,Field.Store.COMPRESS,Field.Index.NO));
+        doc.add(new Field(FIELD_SERVICE_ID,this.feed.getServiceType(),Field.Store.YES,Field.Index.NO));
+        return doc;
+    }
+
+    private String buildContent() throws IOException { 
+        StringWriter writer = new StringWriter(); 
+        XmlWriter xmlWriter = new XmlWriter(writer, INTERNAL_ENCODING); 
+        this.feed.generateAtom(xmlWriter,this.config.getExtensionProfile()); 
+        return writer.toString(); 
+    }
+    /**
+     * @return - the wrapped feed
+     */
+    public BaseFeed getFeed(){
+        return this.feed.getFeed();
+    }
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageImplementation.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageImplementation.java
new file mode 100644
index 0000000..fc2c49c
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageImplementation.java
@@ -0,0 +1,574 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.storage.lucenestorage;
+
+import java.io.IOException;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.data.ServerBaseFeed;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
+import org.apache.lucene.gdata.storage.ModificationConflictException;
+import org.apache.lucene.gdata.storage.ResourceNotFoundException;
+import org.apache.lucene.gdata.storage.Storage;
+import org.apache.lucene.gdata.storage.StorageController;
+import org.apache.lucene.gdata.storage.StorageException;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper.StorageOperation;
+import org.apache.lucene.gdata.utils.ReferenceCounter;
+
+import com.google.gdata.data.BaseEntry;
+import com.google.gdata.data.BaseFeed;
+
+/**
+ * This is an implementation of the
+ * {@link org.apache.lucene.gdata.storage.Storage} interface. The
+ * StorageImplementation provides access to the
+ * {@link org.apache.lucene.gdata.storage.lucenestorage.StorageQuery} and the
+ * {@link org.apache.lucene.gdata.storage.lucenestorage.StorageModifier}. This
+ * class will be instantiated per client request.
+ * 
+ * 
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class StorageImplementation implements Storage {
+    private final StorageCoreController controller;
+
+    private static final Log LOG = LogFactory
+            .getLog(StorageImplementation.class);
+
+    /**
+     * Creates a new StorageImplementation
+     * 
+     * @throws StorageException -
+     *             if the storage controller can not be obtained
+     * 
+     * 
+     * 
+     */
+    public StorageImplementation() throws StorageException {
+        this.controller = (StorageCoreController) GDataServerRegistry
+                .getRegistry().lookup(StorageController.class,
+                        ComponentType.STORAGECONTROLLER);
+        if (this.controller == null)
+            throw new StorageException("Can't get registered StorageController");
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#storeEntry(org.apache.lucene.gdata.data.ServerBaseEntry)
+     */
+    public BaseEntry storeEntry(final ServerBaseEntry entry)
+            throws StorageException {
+        if (entry == null)
+            throw new StorageException("entry is null");
+        if(entry.getFeedId() == null)
+            throw new StorageException("feed-id is null");
+        if(entry.getVersion() != 1)
+            throw new StorageException("entry version must be 1");
+        if(entry.getServiceConfig() == null)
+            throw new StorageException("ProvidedService must not be null");
+        StorageModifier modifier = this.controller.getStorageModifier();
+        String id = this.controller.releaseId();
+        entry.setId(entry.getFeedId() + id);
+        if (LOG.isInfoEnabled())
+            LOG.info("Store entry " + id + " -- feed: " + entry.getFeedId());
+
+        try {
+            StorageEntryWrapper wrapper = new StorageEntryWrapper(entry,
+                    StorageOperation.INSERT);
+            modifier.insertEntry(wrapper);
+        } catch (IOException e) {
+            StorageException ex = new StorageException("Can't create Entry -- "
+                    + e.getMessage(), e);
+            ex.setStackTrace(e.getStackTrace());
+            throw ex;
+
+        }
+
+        return entry.getEntry();
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#deleteEntry(org.apache.lucene.gdata.data.ServerBaseEntry)
+     */
+    public void deleteEntry(final ServerBaseEntry entry)
+            throws StorageException {
+
+        if (entry == null)
+            throw new StorageException("Entry is null");
+        if(entry.getId() == null)
+            throw new StorageException("Entry id is null");
+        if(entry.getFeedId() == null)
+            throw new StorageException("feed id is null");
+        if (LOG.isInfoEnabled())
+            LOG.info("delete entry " + entry.getId() + " -- feed: "
+                    + entry.getFeedId());
+        StorageModifier modifier = this.controller.getStorageModifier();
+        ReferenceCounter<StorageQuery> query = this.controller.getStorageQuery();
+        // try to set concurrency Lock
+        String key = entry.getId();
+        setLock(key);
+        try{
+        if(query.get().isEntryStored(entry.getId(),entry.getFeedId())){
+            if(query.get().checkEntryVersion(entry.getId(),entry.getFeedId(),entry.getVersion())){
+                modifier.deleteEntry(new StorageEntryWrapper(entry,StorageOperation.DELETE));
+            }else
+                throw new ModificationConflictException("The entry version does not match -- entry "+entry.getId()+" feed:"+entry.getFeedId()+" version: "+entry.getVersion());
+        }
+        else
+            throw new ResourceNotFoundException("Entry for entry id: "+entry.getId()+" is not stored");
+        }catch (IOException e) {
+            throw new StorageException("Can not access storage");
+        }finally{
+            if(query != null)
+                query.decrementRef();
+            // release lock for concurrency
+            releaseLock(key);
+        }
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#updateEntry(org.apache.lucene.gdata.data.ServerBaseEntry)
+     */
+    public BaseEntry updateEntry(ServerBaseEntry entry) throws StorageException {
+
+        if (entry == null)
+            throw new StorageException("entry is null");
+        if(entry.getId() == null)
+            throw new StorageException("entry id is null");
+        if(entry.getServiceConfig() == null)
+            throw new StorageException("service config is not set -- null");
+        if(entry.getFeedId() == null)
+            throw new StorageException("feed id is null");
+        if (LOG.isInfoEnabled())
+            LOG.info("update entry " + entry.getId() + " -- feed: "
+                    + entry.getFeedId());
+        StorageModifier modifier = this.controller.getStorageModifier();
+        ReferenceCounter<StorageQuery> query = this.controller.getStorageQuery();
+        // try to set concurrency Lock
+        String key = entry.getId();
+        setLock(key);
+        try {
+            
+            
+            if(query.get().isEntryStored(entry.getId(),entry.getFeedId())){
+                
+                if(query.get().checkEntryVersion(entry.getId(),entry.getFeedId(),entry.getVersion())){
+                    entry.setVersion(entry.getVersion()+1);
+                    StorageEntryWrapper wrapper = new StorageEntryWrapper(entry,
+                            StorageOperation.UPDATE);  
+                    modifier.updateEntry(wrapper);
+                }else
+                    throw new ModificationConflictException("The entry version does not match -- entry "+entry.getId()+" feed:"+entry.getFeedId()+" version: "+entry.getVersion());
+              
+            }else
+                throw new ResourceNotFoundException("Entry for entry id: "+entry.getId()+" is not stored");
+            
+        } catch (IOException e) {
+            LOG.error("Can't update entry for feedID: " + entry.getFeedId()
+                    + "; entryId: " + entry.getId() + " -- " + e.getMessage(),
+                    e);
+            StorageException ex = new StorageException("Can't update Entry -- "
+                    + e.getMessage(), e);
+            ex.setStackTrace(e.getStackTrace());
+            throw ex;
+
+        }
+
+        finally{
+            if(query != null)
+                query.decrementRef();
+            // release lock for concurrency
+            releaseLock(key);
+        }
+
+        return entry.getEntry();
+
+    }
+    private void setLock(String key) throws ModificationConflictException{
+        if(!this.controller.getLock().setLock(key))
+            throw new ModificationConflictException("Can not set lock for entry -- "+key);
+            
+    }
+    
+    private void releaseLock(String key) throws StorageException{
+        if(!this.controller.getLock().releaseLock(key))
+            throw new StorageException("Can not release lock for key: "+key);
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#getFeed(org.apache.lucene.gdata.data.ServerBaseFeed)
+     */
+    @SuppressWarnings("unchecked")
+    public BaseFeed getFeed(final ServerBaseFeed feed) throws StorageException {
+
+        if (feed == null)
+            throw new StorageException("feed is null");
+        if (LOG.isInfoEnabled())
+            LOG.info("get feed: " + feed.getId() + " start-index: "
+                    + feed.getStartIndex() + " resultCount: "
+                    + feed.getItemsPerPage());
+        ReferenceCounter<StorageQuery> query = null;
+        try {
+            query = this.controller.getStorageQuery();
+            BaseFeed retVal = query.get().getLatestFeedQuery(feed.getId(),
+                    feed.getItemsPerPage(), feed.getStartIndex(),
+                    feed.getServiceConfig());
+            return retVal;
+        } catch (Exception e) {
+            LOG.error("Can't get latest feed for feedID: " + feed.getId()
+                    + " -- " + e.getMessage(), e);
+            StorageException ex = new StorageException("Can't create Entry -- "
+                    + e.getMessage(), e);
+            ex.setStackTrace(e.getStackTrace());
+            throw ex;
+
+        } finally {
+            if (query != null)
+                query.decrementRef();
+        }
+
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#getEntry(org.apache.lucene.gdata.data.ServerBaseEntry)
+     */
+    public BaseEntry getEntry(final ServerBaseEntry entry)
+            throws StorageException {
+
+        if (entry == null)
+            throw new StorageException("No entry  specified -- is null");
+        if (LOG.isInfoEnabled())
+            LOG.info("get entry " + entry.getId() + " -- feed: "
+                    + entry.getFeedId());
+        ReferenceCounter<StorageQuery> query = null;
+        try {
+            query = this.controller.getStorageQuery();
+            BaseEntry retVal = query.get().singleEntryQuery(entry.getId(),
+                    entry.getFeedId(), entry.getServiceConfig());
+            if(retVal == null)
+                throw new ResourceNotFoundException("can not get entry for entry ID "+entry.getId());
+            return retVal;
+        } catch (Exception e) {
+            LOG.error("Can't get entry for feedID: " + entry.getFeedId()
+                    + "; entryId: " + entry.getId() + " -- " + e.getMessage(),
+                    e);
+            StorageException ex = new StorageException("Can't create Entry -- "
+                    + e.getMessage(), e);
+            ex.setStackTrace(e.getStackTrace());
+            throw ex;
+
+        } finally {
+            if (query != null)
+                query.decrementRef();
+        }
+
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#close()
+     */
+    public void close() {
+        //
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#storeAccount(org.apache.lucene.gdata.data.GDataAccount)
+     */
+    public void storeAccount(GDataAccount Account) throws StorageException {
+        if (Account == null)
+            throw new StorageException("Can not save null Account");
+        ReferenceCounter<StorageQuery> query = null;
+        try {
+            query = this.controller.getStorageQuery();
+            if (query.get().getUser(Account.getName()) != null)
+                throw new StorageException("Account already exists");
+            StorageModifier modifier = this.controller.getStorageModifier();
+            StorageAccountWrapper wrapper = new StorageAccountWrapper(Account);
+            modifier.createAccount(wrapper);
+        } catch (Exception e) {
+            LOG.error("Can't save Account -- " + e.getMessage(), e);
+            StorageException ex = new StorageException("Can't save Account -- "
+                    + e.getMessage(), e);
+            ex.setStackTrace(e.getStackTrace());
+            throw ex;
+
+        } finally {
+            if (query != null)
+                query.decrementRef();
+        }
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#updateAccount(org.apache.lucene.gdata.data.GDataAccount)
+     */
+    public void updateAccount(GDataAccount Account) throws StorageException {
+        if (Account == null)
+            throw new StorageException("Can not update null Account");
+        ReferenceCounter<StorageQuery> query = null;
+        try {
+            query = this.controller.getStorageQuery();
+            if (query.get().getUser(Account.getName()) == null)
+                throw new StorageException("Account does not exist");
+            StorageModifier modifier = this.controller.getStorageModifier();
+            StorageAccountWrapper wrapper = new StorageAccountWrapper(Account);
+            modifier.updateAccount(wrapper);
+        } catch (Exception e) {
+            LOG.error("Can't update Account -- " + e.getMessage(), e);
+            StorageException ex = new StorageException(
+                    "Can't update Account -- " + e.getMessage(), e);
+            ex.setStackTrace(e.getStackTrace());
+            throw ex;
+
+        } finally {
+            if (query != null)
+                query.decrementRef();
+        }
+
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#deleteAccount(java.lang.String)
+     */
+    public void deleteAccount(String Accountname) throws StorageException {
+        if (Accountname == null)
+            throw new StorageException("can not delete null Account");
+        ReferenceCounter<StorageQuery> query = null;
+        try {
+            query = this.controller.getStorageQuery();
+            if (query.get().getUser(Accountname) == null)
+                throw new StorageException("Account does not exist");
+            StorageModifier modifier = this.controller.getStorageModifier();
+            modifier.deleteAccount(Accountname);
+        } catch (Exception e) {
+            LOG.error("Can't update Account -- " + e.getMessage(), e);
+            StorageException ex = new StorageException(
+                    "Can't update Account -- " + e.getMessage(), e);
+            ex.setStackTrace(e.getStackTrace());
+            throw ex;
+
+        } finally {
+            if (query != null)
+                query.decrementRef();
+        }
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#storeFeed(org.apache.lucene.gdata.data.ServerBaseFeed,
+     *      java.lang.String)
+     */
+    public void storeFeed(ServerBaseFeed feed, String accountName)
+            throws StorageException {
+        if (feed == null)
+            throw new StorageException("can not insert null feed");
+        if (accountName == null)
+            throw new StorageException("accountName must not be null");
+        ReferenceCounter<StorageQuery> query = null;
+        try {
+            query = this.controller.getStorageQuery();
+            if (query.get().isFeedStored(feed.getId()))
+                throw new StorageException("feed with feedID " + feed.getId()
+                        + " is already stored");
+            StorageModifier modifier = this.controller.getStorageModifier();
+            StorageFeedWrapper wrapper = new StorageFeedWrapper(feed,
+                    accountName);
+            modifier.createFeed(wrapper);
+
+        } catch (Exception e) {
+            LOG.error("Can't create feed -- " + e.getMessage(), e);
+            StorageException ex = new StorageException("Can't create feed -- "
+                    + e.getMessage(), e);
+            ex.setStackTrace(e.getStackTrace());
+            throw ex;
+
+        } finally {
+            if (query != null)
+                query.decrementRef();
+        }
+
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#deleteFeed(java.lang.String)
+     */
+    public void deleteFeed(String feedId) throws StorageException {
+        if (feedId == null)
+            throw new StorageException("can not delete feed id is null ");
+        ReferenceCounter<StorageQuery> query = null;
+        try {
+            query = this.controller.getStorageQuery();
+            if (!query.get().isFeedStored(feedId))
+                throw new StorageException("Account does not exist");
+            StorageModifier modifier = this.controller.getStorageModifier();
+
+            modifier.deleteFeed(feedId);
+
+        } catch (Exception e) {
+            LOG.error("Can't delete feed -- " + e.getMessage(), e);
+            StorageException ex = new StorageException("Can't create feed -- "
+                    + e.getMessage(), e);
+            ex.setStackTrace(e.getStackTrace());
+            throw ex;
+
+        } finally {
+            if (query != null)
+                query.decrementRef();
+        }
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#updateFeed(org.apache.lucene.gdata.data.ServerBaseFeed,
+     *      java.lang.String)
+     */
+    public void updateFeed(ServerBaseFeed feed, String accountName)
+            throws StorageException {
+        if (feed == null)
+            throw new StorageException("can not update null feed");
+        if (accountName == null)
+            throw new StorageException("accountName must not be null");
+        ReferenceCounter<StorageQuery> query = null;
+        try {
+            query = this.controller.getStorageQuery();
+            if (!query.get().isFeedStored(feed.getId()))
+                throw new StorageException("Account does not exist");
+            StorageModifier modifier = this.controller.getStorageModifier();
+            StorageFeedWrapper wrapper = new StorageFeedWrapper(feed,
+                    accountName);
+            modifier.updateFeed(wrapper);
+
+        } catch (Exception e) {
+            LOG.error("Can't create feed -- " + e.getMessage(), e);
+            StorageException ex = new StorageException("Can't create feed -- "
+                    + e.getMessage(), e);
+            ex.setStackTrace(e.getStackTrace());
+            throw ex;
+
+        } finally {
+            if (query != null)
+                query.decrementRef();
+        }
+
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#getServiceForFeed(java.lang.String)
+     */
+    public String getServiceForFeed(String feedId) throws StorageException {
+        if (feedId == null)
+            throw new StorageException("no feed for the feedID == null");
+        ReferenceCounter<StorageQuery> query = null;
+        try {
+            query = this.controller.getStorageQuery();
+            String type = query.get().getService(feedId);
+            if (type == null)
+                throw new StorageException("no feed for the feedID == "
+                        + feedId + " found");
+            return type;
+        } catch (Exception e) {
+            throw new StorageException("Can not access storage", e);
+        } finally {
+            if (query != null)
+                query.decrementRef();
+        }
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#getAccount(java.lang.String)
+     */
+    public GDataAccount getAccount(String accountName) throws StorageException {
+        if (accountName == null)
+            throw new StorageException("account name must not be null");
+        ReferenceCounter<StorageQuery> query = null;
+        try {
+            query = this.controller.getStorageQuery();
+            return query.get().getUser(accountName);
+        } catch (Exception e) {
+            throw new StorageException("Can not access storage", e);
+        } finally {
+            if (query != null)
+                query.decrementRef();
+        }
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#getAccountNameForFeedId(java.lang.String)
+     */
+    public String getAccountNameForFeedId(String feedId)
+            throws StorageException {
+        if (feedId == null)
+            throw new StorageException("feed-id must not be null");
+        ReferenceCounter<StorageQuery> query = null;
+        try {
+            query = this.controller.getStorageQuery();
+            String accountName = query.get().getAccountNameForFeedId(feedId);
+            if (accountName == null)
+                throw new StorageException("no feed for feedId " + feedId
+                        + " found");
+            return accountName;
+        } catch (IOException e) {
+            throw new StorageException("Can not access storage - "
+                    + e.getMessage(), e);
+        } finally {
+            if (query != null)
+                query.decrementRef();
+        }
+
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#getEntryLastModified(java.lang.String, java.lang.String)
+     */
+    public Long getEntryLastModified(String entryId,String feedId) throws StorageException {
+        ReferenceCounter<StorageQuery> query = null;
+        try {
+            query = this.controller.getStorageQuery();
+            return new Long(query.get().getEntryLastModified(entryId,feedId));
+        } catch (IOException e) {
+            throw new StorageException("Can not access storage - "
+                    + e.getMessage(), e);
+        } finally {
+            if (query != null)
+                query.decrementRef();
+        }
+
+        
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#getFeedLastModified(java.lang.String)
+     */
+    public Long getFeedLastModified(String feedId) throws StorageException {
+        ReferenceCounter<StorageQuery> query = null;
+        try {
+            query = this.controller.getStorageQuery();
+            return new Long(query.get().getFeedLastModified(feedId));
+        } catch (IOException e) {
+            throw new StorageException("Can not access storage - "
+                    + e.getMessage(), e);
+        } finally {
+            if (query != null)
+                query.decrementRef();
+        }
+
+            }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageModifier.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageModifier.java
new file mode 100644
index 0000000..ec5a171
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageModifier.java
@@ -0,0 +1,513 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.storage.lucenestorage;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.gdata.storage.StorageException;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper.StorageOperation;
+import org.apache.lucene.index.IndexModifier;
+import org.apache.lucene.index.Term;
+
+/**
+ * The StorageModifier is the a Singleton component of the LuceneStorage. There
+ * is one single instance of this class modifying the index used to store all
+ * the gdata Entities as Entries, Feeds and Users. This class contains an
+ * instance of {@link org.apache.lucene.index.IndexModifier} used to manage all
+ * delete and add actions to the storage.
+ * <p>
+ * To prevent the storage component from opening and closing the
+ * {@link org.apache.lucene.index.IndexModifier} for every modifying operation
+ * the incoming entry actions (DELETE, UPDATE, INSERT) will be buffered in a
+ * registered instance of
+ * {@link org.apache.lucene.gdata.storage.lucenestorage.StorageBuffer}. When a
+ * certain amout (specified as the persistfactor in the configuration file) of
+ * modifications have been executed the StorageModifier will persist the
+ * buffered entries.
+ * </p>
+ * <p>
+ * Feed and User operations won't be buffered. These actions occure not very
+ * often compared to entry actions. Every call of an user / feed modifying
+ * operation forces all changes to be written to the storage index.
+ * </p>
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class StorageModifier {
+    protected static final Log LOG = LogFactory.getLog(StorageModifier.class);
+
+    private final List<Term> deletedDocumentQueue;
+
+    private final List<Term> deletedForUpdateDocumentQueue;
+
+    private final Map<String, Document> documentMap;
+
+    private final List<Document> forceWriteDocuments;
+
+    private final List<Term> forceWriteTerms;
+
+    private volatile int persistFactor;
+
+    private volatile int modifiedCounter = 0;
+
+    private static int DEFAULT_PERSIST_FACTOR = 10;
+
+    private StorageBuffer buffer;
+
+    private IndexModifier modifier;
+
+    private Lock lock = new ReentrantLock();
+    
+    private final AtomicBoolean isClosed = new AtomicBoolean(false);
+
+    private final static int DEFAULT_OPTIMIZE_INTERVAL = 10;
+
+    private final int optimizeInterval;
+
+    private volatile int optimizeCounter = 0;
+
+    private final StorageCoreController controller;
+
+    /**
+     * Creates a new StorageModifier
+     * 
+     * @param controller -
+     *            the registered StorageController
+     * @param modifier -
+     *            the IndexModifier
+     * @param buffer -
+     *            the StorageBuffer
+     * @param persitsFactor -
+     *            the factor when the changes will be persisted to the storage
+     *            index
+     * @param optimizeInterval -
+     *            after how many storage operations the index will be optimized
+     */
+    protected StorageModifier(final StorageCoreController controller,
+            final IndexModifier modifier, final StorageBuffer buffer,
+            int persitsFactor, int optimizeInterval) {
+        this.deletedDocumentQueue = new LinkedList<Term>();
+        this.deletedForUpdateDocumentQueue = new LinkedList<Term>();
+        this.documentMap = new HashMap<String, Document>(persitsFactor);
+        this.forceWriteDocuments = new ArrayList<Document>(5);
+        this.forceWriteTerms = new ArrayList<Term>(5);
+        this.buffer = buffer;
+        this.controller = controller;
+
+        this.persistFactor = persitsFactor > 0 ? persitsFactor
+                : DEFAULT_PERSIST_FACTOR;
+        this.modifier = modifier;
+        this.optimizeInterval = optimizeInterval < DEFAULT_OPTIMIZE_INTERVAL ? DEFAULT_OPTIMIZE_INTERVAL
+                : optimizeInterval;
+
+    }
+
+    /**
+     * Updates the given entry. First the alredy persisted entry will be
+     * removed, after marking as deleted the new Entry will be written.
+     * 
+     * @param wrapper -
+     *            the wrapper containing the entry
+     * @throws StorageException -
+     *             if the entry can not be stored
+     */
+    public void updateEntry(StorageEntryWrapper wrapper)
+            throws StorageException {
+        if(wrapper.getOperation() != StorageOperation.UPDATE)
+            throw new StorageException("Illegal method call -- updateEntry does not accept other storageOperations than update");
+        this.lock.lock();
+        try {
+            
+            Term tempTerm = new Term(StorageEntryWrapper.FIELD_ENTRY_ID,
+                    wrapper.getEntryId());
+            this.documentMap.put(wrapper.getEntryId(), wrapper
+                    .getLuceneDocument());
+            this.deletedForUpdateDocumentQueue.add(tempTerm);
+            storageModified();
+            /*
+             * If storage not written write entry to recoverfile
+             * and make the entry available via the buffer
+             */
+            if(this.modifiedCounter != 0)
+                try{
+                    this.controller.writeRecoverEntry(wrapper);
+                    this.buffer.addEntry(wrapper);
+                }catch (Exception e) {
+                    /*
+                     * remove from all resources
+                     */
+                    this.documentMap.remove(wrapper.getEntryId());
+                    this.deletedForUpdateDocumentQueue.remove(tempTerm);
+                    
+                }
+        } finally {
+            this.lock.unlock();
+        }
+    }
+
+    /**
+     * Inserts a new Entry to the Lucene index storage
+     * 
+     * @param wrapper -
+     *            the wrapper containing the entry
+     * @throws StorageException -
+     *             if the entry can not be stored
+     */
+    public void insertEntry(StorageEntryWrapper wrapper)
+            throws StorageException {
+        if(wrapper.getOperation() != StorageOperation.INSERT)
+            throw new StorageException("Illegal method call -- insertEntry does not accept other storage operations than insert");
+        this.lock.lock();
+        try {
+            this.documentMap.put(wrapper.getEntryId(), wrapper
+                    .getLuceneDocument());
+            storageModified();
+            /*
+             * If storage not written write entry to recoverfile
+             * and make the entry available via the buffer
+             */
+            if(this.modifiedCounter != 0)
+                try{
+                    this.controller.writeRecoverEntry(wrapper);
+                    this.buffer.addEntry(wrapper);
+                }catch (Exception e) {
+                    /*
+                     * remove from all resources
+                     */
+                    this.documentMap.remove(wrapper.getEntryId());
+                }
+        } finally {
+            this.lock.unlock();
+        }
+    }
+
+    /**
+     * Deletes the entry for the given entry id.
+     * @param wrapper - the wrapper containing the information to delete 
+     * 
+     * @throws StorageException -
+     *             if the entry can not be deleted
+     * 
+     */
+    public void deleteEntry(final StorageEntryWrapper wrapper)
+            throws StorageException {
+        if(wrapper.getOperation() != StorageOperation.DELETE)
+            throw new StorageException("Illegal method call -- insertEntry does not accept other storage operations than delete");
+        this.lock.lock();
+        try {
+            
+            Term tempTerm = new Term(StorageEntryWrapper.FIELD_ENTRY_ID,
+                    wrapper.getEntryId());
+            this.deletedDocumentQueue.add(tempTerm);
+            storageModified();
+            /*
+             * If storage not written write entry to recoverfile
+             * and make the entry available via the buffer
+             */
+            if(this.modifiedCounter != 0)
+                try{
+                    this.controller.writeRecoverEntry(wrapper);
+                    this.buffer.addDeleted(wrapper.getEntryId(), wrapper.getFeedId());
+                }catch (Exception e) {
+                    /*
+                     * remove from all resources
+                     */
+                 this.deletedDocumentQueue.remove(tempTerm);
+                    
+                }
+        } finally {
+            this.lock.unlock();
+        }
+    }
+
+    /**
+     * Adds a new Feed to the storage. Feed action will be not buffered. Call to
+     * this method forces the index to be written.
+     * 
+     * @param wrapper -
+     *            the wrapper containing the feed;
+     * @throws StorageException -
+     *             if the feed can not be written
+     */
+    public void createFeed(StorageFeedWrapper wrapper) throws StorageException {
+        this.lock.lock();
+        try {
+            this.forceWriteDocuments.add(wrapper.getLuceneDocument());
+            storageModified();
+        } finally {
+            this.lock.unlock();
+        }
+    }
+
+    /**
+     * Adds a new accountr to the storage. User action will be not buffered. Call to
+     * this method forces the index to be written.
+     * 
+     * @param account
+     *            -the wrapper containig the user to be persisted
+     * @throws StorageException -
+     *             if the user can not be persisted.
+     */
+    public void createAccount(StorageAccountWrapper account) throws StorageException {
+        this.lock.lock();
+        try {
+            this.forceWriteDocuments.add(account.getLuceneDocument());
+            storageModified();
+        } finally {
+            this.lock.unlock();
+        }
+    }
+
+    /**
+     * Deletes the user with the given username. User action will be not
+     * buffered. Call to this method forces the index to be written.
+     * 
+     * @param accountName -
+     *            the user to be deleted
+     * @throws StorageException -
+     *             If the user could not be deleted
+     */
+    public void deleteAccount(String accountName) throws StorageException {
+        this.lock.lock();
+        try {
+            //TODO delete all feeds and entries of this account
+            this.forceWriteTerms.add(new Term(
+                    StorageAccountWrapper.FIELD_ACCOUNTNAME, accountName));
+            storageModified();
+        } finally {
+            this.lock.unlock();
+        }
+    }
+
+    /**
+     * User action will be not buffered. Call to this method forces the index to
+     * be written.
+     * 
+     * @param user
+     *            -the wrapper containig the user to be persisted
+     * @throws StorageException -
+     *             if the user can not be persisted.
+     */
+    public void updateAccount(final StorageAccountWrapper user)
+            throws StorageException {
+        this.lock.lock();
+        try {
+            this.forceWriteTerms.add(new Term(
+                    StorageAccountWrapper.FIELD_ACCOUNTNAME, user.getUser()
+                            .getName()));
+            this.forceWriteDocuments.add(user.getLuceneDocument());
+            storageModified();
+        } finally {
+            this.lock.unlock();
+        }
+    }
+
+    /**
+     * Feed action will be not buffered. Call to this method forces the index to
+     * be written.
+     * 
+     * @param wrapper -
+     *            the wrapper containig the feed
+     * @throws StorageException -
+     *             if the feed can not be persisted
+     */
+    public void updateFeed(final StorageFeedWrapper wrapper)
+            throws StorageException {
+        this.lock.lock();
+        try {
+            this.forceWriteTerms.add(new Term(StorageFeedWrapper.FIELD_FEED_ID,
+                    wrapper.getFeed().getId()));
+            this.forceWriteDocuments.add(wrapper.getLuceneDocument());
+            storageModified();
+        } finally {
+            this.lock.unlock();
+        }
+    }
+
+    /**
+     * Deletes the feed with the given feed id Feed action will be not buffered.
+     * Call to this method forces the index to be written.
+     * All entries referencing the given feed id will be deleted as well!
+     * @param feedId -
+     *            the id of the feed to delete
+     * @throws StorageException -
+     *             if the feed can not be deleted
+     */
+    public void deleteFeed(final String feedId) throws StorageException {
+        this.lock.lock();
+        try {
+            this.deletedDocumentQueue.add(new Term(StorageEntryWrapper.FIELD_FEED_REFERENCE,feedId));
+            this.forceWriteTerms.add(new Term(StorageFeedWrapper.FIELD_FEED_ID,
+                    feedId));
+
+            storageModified();
+        } finally {
+            this.lock.unlock();
+        }
+    }
+
+    private void storageModified() throws StorageException {
+    	if(this.isClosed.get())
+    		throw new IllegalStateException("StorageModifier is already closed");
+       
+        try {
+        	if(this.isClosed.get())
+        		throw new IllegalStateException("StorageModifier is already closed");
+            incrementCounter();
+            if (this.persistFactor > this.modifiedCounter
+                    && this.forceWriteDocuments.size() <= 0
+                    && this.forceWriteTerms.size() <= 0)
+                return;
+
+            if (LOG.isInfoEnabled())
+                LOG.info("Storage modified for " + this.modifiedCounter
+                        + " times. Write Persistent index");
+            writePersistentIndex((this.optimizeCounter >= this.optimizeInterval));
+            requestNewIndexModifier();
+
+            this.modifiedCounter = 0;
+        } catch (IOException e) {
+
+            LOG.error("Writing persistent index failed - Recovering", e);
+            throw new StorageException("could not write to storage index -- "+e.getMessage(),e);
+        }
+       
+    }
+
+    /**
+     * Persists all changes imediately
+     * @throws IOException -- if an IO Exception  occures
+     */
+    public void forceWrite() throws IOException {
+    	if(this.isClosed.get())
+    		throw new IllegalStateException("StorageModifier is already closed");
+        this.lock.lock();
+        try {
+            if (LOG.isInfoEnabled())
+                LOG.info("ForceWrite called -- current modifiedCounter: "
+                        + this.modifiedCounter + " - persisting changes");
+            writePersistentIndex(true);
+            requestNewIndexModifier();
+            this.modifiedCounter = 0;
+        } finally {
+            this.lock.unlock();
+        }
+    }
+
+    private void requestNewIndexModifier() throws IOException {
+        this.controller.registerNewRecoverWriter();
+        this.controller.registerNewStorageQuery();
+        this.buffer = this.controller.releaseNewStorageBuffer();
+        this.modifier = this.controller.createIndexModifier();
+    }
+
+    private void writePersistentIndex(final boolean optimize)
+            throws IOException {
+        try {
+
+            /*
+             * first delete all updated documents
+             */
+            for (Term entryIdTerm : this.deletedForUpdateDocumentQueue) {
+                this.modifier.deleteDocuments(entryIdTerm);
+            }
+
+            for (Term term : this.forceWriteTerms) {
+                this.modifier.deleteDocuments(term);
+            }
+            /*
+             * add all documents
+             */
+            Collection<Document> documents = this.documentMap.values();
+            for (Document doc : documents) {
+                this.modifier.addDocument(doc);
+            }
+            /*
+             * write all users or feeds
+             */
+            for (Document docs : this.forceWriteDocuments) {
+                this.modifier.addDocument(docs);
+            }
+
+            /*
+             * delete all documents marked as deleted. As the DocumentIDs are
+             * unique the document marked as deleted must not persist after the
+             * index has been written. In the case of an update of a document
+             * and a previous delete the concurrency component will not allow an
+             * update. new inserted entries can not be deleted accidently-
+             */
+            for (Term entryIdTerm : this.deletedDocumentQueue) {
+                this.modifier.deleteDocuments(entryIdTerm);
+            }
+            this.modifier.flush();
+            if (optimize) {
+                if (LOG.isInfoEnabled())
+                    LOG.info("Optimizing index -- optimize interval "
+                            + this.optimizeInterval);
+                this.modifier.optimize();
+            }
+
+        } finally {
+            if (optimize)
+                this.optimizeCounter = 0;
+            this.modifier.close();
+            this.deletedForUpdateDocumentQueue.clear();
+            this.deletedDocumentQueue.clear();
+            this.documentMap.clear();
+            this.forceWriteDocuments.clear();
+            this.forceWriteTerms.clear();
+        }
+    }
+
+    protected void close() throws IOException {
+    	if(this.isClosed.get())
+    		throw new IllegalStateException("StorageModifier is already closed");
+        this.lock.lock();
+        try {
+        	if(this.isClosed.get())
+        		throw new IllegalStateException("StorageModifier is already closed");
+        	this.isClosed.set(true);
+            if (LOG.isInfoEnabled())
+                LOG.info("ForceWrite called -- current modifiedCounter: "
+                        + this.modifiedCounter + " - persisting changes");
+
+            writePersistentIndex(true);
+            this.modifiedCounter = 0;
+        } finally {
+            this.lock.unlock();
+        }
+    }
+
+    private void incrementCounter() {
+        this.optimizeCounter++;
+        this.modifiedCounter++;
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageQuery.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageQuery.java
new file mode 100644
index 0000000..00b327e
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageQuery.java
@@ -0,0 +1,546 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+
+package org.apache.lucene.gdata.storage.lucenestorage;
+
+import java.io.IOException;
+import java.io.Reader;
+import java.io.StringReader;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.server.GDataEntityBuilder;
+import org.apache.lucene.gdata.server.registry.ProvidedService;
+import org.apache.lucene.gdata.storage.StorageException;
+import org.apache.lucene.gdata.utils.ModifiedEntryFilter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.Hit;
+import org.apache.lucene.search.Hits;
+import org.apache.lucene.search.Searcher;
+import org.apache.lucene.search.Sort;
+import org.apache.lucene.search.SortField;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.BooleanClause.Occur;
+
+import com.google.gdata.data.BaseEntry;
+import com.google.gdata.data.BaseFeed;
+import com.google.gdata.data.DateTime;
+import com.google.gdata.util.ParseException;
+
+/**
+ * StorageQuery wraps a Lucene {@link org.apache.lucene.search.IndexSearcher}
+ * and a {@link org.apache.lucene.gdata.storage.lucenestorage.StorageBuffer} to
+ * perform all request on the lucene storage. The wrapped components are thread -
+ * safe.
+ * <p>
+ * An instance of this class will serve all client requests. To obtain the
+ * current instance of the {@link StorageQuery} the method
+ * {@link org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController#getStorageQuery()}
+ * has to be invoked. This method will release the current StorageQuery.
+ * </p>
+ * 
+ * @see org.apache.lucene.search.IndexSearcher
+ * @see org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController
+ * @see org.apache.lucene.gdata.storage.lucenestorage.StorageBuffer
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class StorageQuery {
+    private static final Log LOG = LogFactory.getLog(StorageQuery.class);
+
+    private final StorageBuffer buffer;
+
+    private final Searcher searcher;
+
+    /*
+     * Sort the result by timestamp desc
+     */
+    private final Sort timeStampSort = new Sort(new SortField(
+            StorageEntryWrapper.FIELD_TIMESTAMP, SortField.STRING, true));
+
+    /**
+     * Creates a new StorageQuery
+     * 
+     * @param buffer -
+     *            the buffer instance to get the buffered inserts, updates from.
+     * @param searcher -
+     *            the searcher instance to use to query the storage index.
+     * 
+     * 
+     */
+    protected StorageQuery(final StorageBuffer buffer, final Searcher searcher) {
+
+        this.buffer = buffer;
+        this.searcher = searcher;
+
+    }
+
+    private Hits storageQuery(List<String> entryId) throws IOException {
+        BooleanQuery query = new BooleanQuery();
+        /*
+         * query the index using a BooleanQuery
+         */
+        for (String id : entryId) {
+            TermQuery termQuery = new TermQuery(new Term(
+                    StorageEntryWrapper.FIELD_ENTRY_ID, id));
+            // use an OR query
+            query.add(new BooleanClause(termQuery, Occur.SHOULD));
+        }
+
+        return this.searcher.search(query, new ModifiedEntryFilter(this.buffer
+                .getExculdList(),StorageEntryWrapper.FIELD_ENTRY_ID));
+    }
+
+    /*
+     * query the storage index for a entire feed.
+     */
+    private Hits storageFeedQuery(final String feedId, final Sort sort)
+            throws IOException {
+        TermQuery query = new TermQuery(new Term(
+                StorageEntryWrapper.FIELD_FEED_REFERENCE, feedId));
+        return this.searcher.search(query, new ModifiedEntryFilter(this.buffer
+                .getExculdList(),StorageEntryWrapper.FIELD_ENTRY_ID), sort);
+
+    }
+
+    /*
+     * get a single entry
+     */
+    private Hits storageQuery(String entryId) throws IOException {
+        TermQuery termQuery = new TermQuery(new Term(
+                StorageEntryWrapper.FIELD_ENTRY_ID, entryId));
+        /*
+         * Filter entries inside the buffer, buffered entries might contain
+         * deleted entries. These entries must be found!!
+         */
+        return this.searcher.search(termQuery, new ModifiedEntryFilter(
+                this.buffer.getExculdList(),StorageEntryWrapper.FIELD_ENTRY_ID));
+
+    }
+
+    /**
+     * This method fetches the latest feed entries from the storage. Feed
+     * usually requested via a search query or as a simple query to the REST
+     * interface.
+     * <p>
+     * The REST interface requests all the entries from a Storage. The Storage
+     * retrieves the entries corresponding to the parameters specified. This
+     * method first requests the latest entries or updated entries from the
+     * {@link StorageBuffer}. If the buffer already contains enough entries
+     * for the the specified result count the entries will be returned. If not,
+     * the underlying lucene index will be searcher for all documents of the
+     * specified feed sorted by storing timestamp desc.
+     * </p>
+     * <p>
+     * The entries will be searched in a feed context specified by the given
+     * feed ID
+     * </p>
+     * 
+     * 
+     * @param feedId -
+     *            the requested feed, this id will be used to retrieve the
+     *            entries.
+     * @param resultCount -
+     *            how many entries are requested
+     * @param startIndex -
+     *            the offset of the entry to start from.
+     * @param config -
+     *            the FeedInstanceConfiguration containing extension profile used
+     *            to create the entry instances
+     * @return - an ordered list of {@link BaseEntry} objects, or an empty list
+     *         if no entries could be found
+     * @throws IOException -
+     *             if the index could not be queries or the entries could not be
+     *             build
+     * @throws ParseException -
+     *             if an entry could not be parsed while building it from the
+     *             Lucene Document.
+     */
+    // TODO check input parameter
+    @SuppressWarnings("unchecked")
+    public BaseFeed getLatestFeedQuery(final String feedId,
+            final int resultCount, final int startIndex,
+            final ProvidedService config) throws IOException, ParseException {
+        DateTime updated = null;
+        Hits feedHits = storageFeedQuery(feedId);
+        if (feedHits.length() == 0)
+            return null;
+        BaseFeed retVal = buildFeedFromLuceneDocument(feedHits.doc(0), config);
+
+        List<BaseEntry> returnList = new ArrayList<BaseEntry>(resultCount);
+        List<StorageEntryWrapper> bufferedWrapperList = this.buffer
+                .getSortedEntries(feedId);
+        int alreadyAdded = 0;
+        int offset = startIndex - 1;
+
+        if (bufferedWrapperList != null
+                && bufferedWrapperList.size() >= startIndex) {
+            updated = bufferedWrapperList.get(0).getEntry().getUpdated();
+            for (; alreadyAdded < resultCount; alreadyAdded++) {
+                if ((bufferedWrapperList.size() - offset) > 0) {
+                    StorageEntryWrapper wrappedEntry = bufferedWrapperList
+                            .get(offset++);
+                    returnList.add(wrappedEntry.getEntry());
+                } else
+                    break;
+            }
+            // reset offset
+            offset = startIndex - 1;
+            if (alreadyAdded == resultCount) {
+                retVal.getEntries().addAll(returnList);
+                retVal.setUpdated(updated);
+                return retVal;
+            }
+        } else {
+            /*
+             * if the buffer size is less than the start index the buffer size must
+             * be considered. Sublists would not be a repeatable read part of
+             * the whole list
+             */
+            if (bufferedWrapperList != null)
+                offset = startIndex - 1 - bufferedWrapperList.size();
+        }
+
+        Hits hits = storageFeedQuery(feedId, this.timeStampSort);
+        if (hits.length() > 0) {
+
+            for (; (offset < hits.length()) && (alreadyAdded < resultCount); offset++, alreadyAdded++) {
+                Document doc = hits.doc(offset);
+                BaseEntry entry = buildEntryFromLuceneDocument(doc, config);
+                returnList.add(entry);
+            }
+            if (updated == null) {
+                try {
+                    long updatedTimeStamp = Long.parseLong(hits.doc(0).get(
+                            StorageEntryWrapper.FIELD_TIMESTAMP));
+                    updated = new DateTime(updatedTimeStamp);
+                } catch (Exception e) {
+                    LOG.warn("could not create DateTime -- " + e.getMessage(),
+                            e);
+                    updated = buildEntryFromLuceneDocument(hits.doc(0), config)
+                            .getUpdated();
+                }
+            }
+        }
+        retVal.setUpdated(updated);
+        retVal.getEntries().addAll(returnList);
+        return retVal;
+    }
+
+    /**
+     * This method retrieves a single entry from the storage. If the
+     * {@link StorageBuffer} does not contain the requested entry the
+     * underlying storage index will be searched.
+     * <p>
+     * The Entry will be searched in a feed context specified by the given feed
+     * ID
+     * </p>
+     * 
+     * @param entryId -
+     *            the entry to fetch
+     * @param feedId -
+     *            the feed id e.g. feed context
+     * @param config -
+     *            the FeedInstanceConfiguration containing extension profile used
+     *            to create the entry instances
+     * @return - the requested {@link BaseEntry} or <code>null</code> if the
+     *         entry can not be found
+     * @throws IOException -
+     *             if the index could not be queries or the entries could not be
+     *             build
+     * @throws ParseException -
+     *             if an entry could not be parsed while building it from the
+     *             Lucene Document.
+     */
+    public BaseEntry singleEntryQuery(final String entryId,
+            final String feedId, final ProvidedService config)
+            throws IOException, ParseException {
+        StorageEntryWrapper wrapper = this.buffer.getEntry(entryId, feedId);
+
+        if (wrapper == null) {
+            Hits hits = storageQuery(entryId);
+            if (hits.length() <= 0)
+                return null;
+            Document doc = hits.doc(0);
+
+            return buildEntryFromLuceneDocument(doc, config);
+        }
+        /*
+         * ServerBaseEntry enables the dynamic element of the entry like the
+         * links to be dynamic. BufferedEntries will be reused until they are
+         * written.
+         */
+        return wrapper.getEntry();
+
+    }
+
+    /**
+     * Fetches the requested entries from the storage. The given list contains
+     * entry id's to be looked up in the storage. First the {@link StorageBuffer}
+     * will be queried for the entry id's. If not all of the entries remain in
+     * the buffer the underlying lucene index will be searched. The entries are
+     * not guaranteed to be in the same order as they are in the given id list.
+     * Entry ID's not found in the index or the buffer will be omitted.
+     * <p>
+     * The entries will be searched in a feed context specified by the given
+     * feed ID
+     * </p>
+     * 
+     * @param entryIds -
+     *            the entry id's to fetch.
+     * @param feedId -
+     *            the feed id e.g. feed context.
+     * @param config -
+     *            the FeedInstanceConfiguration containing extension profile used
+     *            to create the entry instances
+     * 
+     * @return - the list of entries corresponding to the given entry id list.
+     * @throws IOException -
+     *             if the index could not be queries or the entries could not be
+     *             build
+     * @throws ParseException -
+     *             if an entry could not be parsed while building it from the
+     *             Lucene Document.
+     */
+    public List<BaseEntry> entryQuery(List<String> entryIds,
+            final String feedId, final ProvidedService config)
+            throws IOException, ParseException {
+        List<BaseEntry> resultList = new ArrayList<BaseEntry>(entryIds.size());
+        List<String> searchList = new ArrayList<String>(entryIds.size());
+        for (String entry : entryIds) {
+
+            StorageEntryWrapper bufferedEntry = this.buffer.getEntry(entry,
+                    feedId);
+            if (bufferedEntry != null) {
+                resultList.add(bufferedEntry.getEntry());
+            } else
+                searchList.add(entry);
+        }
+        if (searchList.isEmpty())
+            return resultList;
+
+        Hits hits = storageQuery(searchList);
+        Iterator hitIterator = hits.iterator();
+        while (hitIterator.hasNext()) {
+            Hit hit = (Hit) hitIterator.next();
+            Document doc = hit.getDocument();
+            BaseEntry entry = buildEntryFromLuceneDocument(doc, config);
+            resultList.add(entry);
+
+        }
+
+        return resultList;
+
+    }
+
+    private BaseEntry buildEntryFromLuceneDocument(final Document doc,
+            final ProvidedService config) throws ParseException, IOException {
+        Reader reader = new StringReader(doc.getField(StorageEntryWrapper.FIELD_CONTENT).stringValue());
+        BaseEntry entry = GDataEntityBuilder.buildEntry(reader, config);
+        entry.setVersionId(doc.getField(StorageEntryWrapper.FIELD_VERSION).stringValue());
+        return entry;
+
+    }
+
+    private BaseFeed buildFeedFromLuceneDocument(final Document doc,
+            final ProvidedService config) throws ParseException, IOException {
+        Reader reader = new StringReader(doc.getField(StorageFeedWrapper.FIELD_CONTENT).stringValue());
+        return GDataEntityBuilder.buildFeed(reader, config);
+
+    }
+
+    /**
+     * Queries the storage for an user instance
+     * 
+     * @param username -
+     *            the username (primary key)
+     * @return - the user instance if found or <code>null</code> if not exists
+     * @throws IOException -
+     *             if the storage can not be accessed.
+     */
+    public GDataAccount getUser(final String username) throws IOException {
+        if (username == null)
+            return null;
+        TermQuery query = new TermQuery(new Term(
+                StorageAccountWrapper.FIELD_ACCOUNTNAME, username));
+        Hits h = this.searcher.search(query);
+        if (h.length() == 0)
+            return null;
+        return StorageAccountWrapper.buildEntity(h.doc(0));
+    }
+
+    /**
+     * Closes all resources used in the {@link StorageQuery}. The instance can
+     * not be reused after invoking this method.
+     * 
+     * @throws IOException -
+     *             if the resources can not be closed
+     */
+    public void close() throws IOException {
+        this.searcher.close();
+        this.buffer.close();
+    }
+
+    /**
+     * Checks whether a feed for the given feedID is stored
+     * 
+     * @param feedId -
+     *            the feed ID
+     * @return <code>true</code> if and only if a feed is stored for the
+     *         provided feed ID, <code>false</code> if no feed for the given
+     *         id is stored
+     * @throws IOException
+     */
+    public boolean isFeedStored(String feedId) throws IOException {
+        Hits h = storageFeedQuery(feedId);
+        return (h.length() > 0);
+
+    }
+
+    /**
+     * Looks up the feed type for the given feed ID
+     * 
+     * @param feedID -
+     *            the feed ID
+     * @return - the feed type
+     * @throws IOException -
+     *             if the storage can not be accessed
+     */
+    public String getService(String feedID) throws IOException {
+        Hits hits = storageFeedQuery(feedID);
+        if (hits.length() <= 0)
+            return null;
+        Document doc = hits.doc(0);
+        String feedType = doc.get(StorageFeedWrapper.FIELD_SERVICE_ID);
+        return feedType;
+    }
+
+    private Hits storageFeedQuery(String feedId) throws IOException {
+        TermQuery query = new TermQuery(new Term(
+                StorageFeedWrapper.FIELD_FEED_ID, feedId));
+        return this.searcher.search(query);
+    }
+
+    /**
+     * Looks up the account reference for the given feed id
+     * 
+     * @param feedId -
+     *            id of the feed
+     * @return - the name of the account associated with the feed for the given
+     *         feed id, or <code>null</code> if the feed is not stored
+     * @throws IOException -
+     *             if the storage can not be accessed
+     */
+    public String getAccountNameForFeedId(String feedId) throws IOException {
+        Hits h = storageFeedQuery(feedId);
+        if (h.length() == 0)
+            return null;
+        Document doc = h.doc(0);
+        return doc.get(StorageFeedWrapper.FIELD_ACCOUNTREFERENCE);
+
+    }
+
+    protected long getEntryLastModified(final String entryId,
+            final String feedId) throws IOException, StorageException {
+        StorageEntryWrapper wrapper = this.buffer.getEntry(entryId, feedId);
+        if (wrapper != null)
+            return wrapper.getTimestamp();
+
+        Hits h = storageQuery(entryId);
+        if (h.length() > 0)
+            try {
+                return Long.parseLong(h.doc(0).get(
+                        StorageEntryWrapper.FIELD_TIMESTAMP));
+            } catch (Exception e) {
+                LOG.warn("Can not parse timestamp from entry -- "
+                        + h.doc(0).get(StorageEntryWrapper.FIELD_TIMESTAMP));
+            }
+        else
+            throw new StorageException("Entry not found");
+        return 0;
+
+    }
+
+    protected long getFeedLastModified(final String feedId) throws IOException {
+        Long bufferedTime = this.buffer.getFeedLastModified(feedId);
+        if (bufferedTime != null)
+            return bufferedTime;
+        Hits entryHits = storageFeedQuery(feedId, this.timeStampSort);
+        if (entryHits.length() > 0) {
+            try {
+                return Long.parseLong(entryHits.doc(0).getField(
+                        StorageEntryWrapper.FIELD_TIMESTAMP).stringValue());
+            } catch (Exception e) {
+                LOG.warn("Can not parse timestamp from entry -- "
+                        + entryHits.doc(0).get(
+                                StorageEntryWrapper.FIELD_TIMESTAMP));
+            }
+        }
+        return 0;
+
+    }
+
+    protected boolean isEntryStored(String entryId, String feedId)
+            throws IOException {
+        if (LOG.isDebugEnabled())
+            LOG.debug("Checking isEntryStored for entryid " + entryId
+                    + " feedid: " + feedId);
+        if (this.buffer.getEntry(entryId, feedId) != null)
+            return true;
+
+        Hits h = storageQuery(entryId);
+        if (h.length() > 0)
+            return true;
+        return false;
+    }
+
+    protected boolean checkEntryVersion(String id, String feedId, int version)
+            throws IOException {
+        if (LOG.isDebugEnabled())
+            LOG.debug("Checking entry version for entryid " + id + " feedid: "
+                    + feedId + " version: " + version);
+        StorageEntryWrapper wrapper = this.buffer.getEntry(id, feedId);
+
+        if (wrapper != null)
+            return wrapper.getVersion() == version;
+
+        Hits h = storageQuery(id);
+        if (h.length() < 1)
+            return false;
+        Document doc = h.doc(0);
+        String fieldValue = null;
+        try {
+            fieldValue = doc.getField(StorageEntryWrapper.FIELD_VERSION)
+                    .stringValue();
+            int storedVersion = Integer.parseInt(fieldValue);
+        if(LOG.isDebugEnabled())
+            LOG.debug("StoredEntry has version "+storedVersion +" return compare result");
+            return storedVersion == version;
+        } catch (Exception e) {
+            LOG.error("Entry has no parable Version id or field is not set -- "
+                    + fieldValue);
+        }
+        return false;
+    }
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageWrapper.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageWrapper.java
new file mode 100644
index 0000000..f3296db
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageWrapper.java
@@ -0,0 +1,39 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.storage.lucenestorage;
+
+import org.apache.lucene.document.Document;
+
+/**
+ * A interface to be implemented by <tt>StorageWrapper</tt> sub classes to
+ * provide a lucene document for each entity wrapped.
+ * 
+ * @see org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper
+ * @see org.apache.lucene.gdata.storage.lucenestorage.StorageAccountWrapper
+ * @see org.apache.lucene.gdata.storage.lucenestorage.StorageFeedWrapper
+ * @author Simon Willnauer
+ * 
+ */
+public interface StorageWrapper {
+    /**
+     * Returns a Lucene document representing the Wrapped Entry
+     * 
+     * @return a Lucene Document
+     */
+    public abstract Document getLuceneDocument();
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/configuration/StorageConfigurator.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/configuration/StorageConfigurator.java
new file mode 100644
index 0000000..838525f
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/configuration/StorageConfigurator.java
@@ -0,0 +1,153 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */ 
+ 
+package org.apache.lucene.gdata.storage.lucenestorage.configuration; 
+ 
+import java.io.InputStream; 
+import java.util.Properties; 
+ 
+/** 
+ * This clas loads the Storage configuration file and sets all properties. If 
+ * the properties can not be loaded an {@link java.lang.Error} will be thrown. 
+ * The configuration file <i>lucenestorage.properties.xml</i> should be available in the classpath. 
+ *  
+ * @author Simon Willnauer 
+ *  
+ */ 
+public class StorageConfigurator { 
+    private final int storageBufferSize; 
+ 
+    private final int storagepersistFactor; 
+ 
+    private final String storageDirectory; 
+ 
+    private final boolean keepRecoveredFiles; 
+ 
+    private final boolean recover; 
+    
+    private final boolean ramDirectory;
+    private static StorageConfigurator INSTANCE = null; 
+ 
+    private final int indexOptimizeInterval; 
+ 
+    private StorageConfigurator() { 
+        InputStream stream = StorageConfigurator.class 
+                .getResourceAsStream("/lucenestorage.properties.xml"); 
+        Properties properties = new Properties(); 
+        try { 
+            properties.loadFromXML(stream); 
+ 
+        } catch (Exception e) { 
+            throw new StorageConfigurationError("Could not load properties", e); 
+        } 
+        this.storageBufferSize = Integer.parseInt(properties 
+                .getProperty("gdata.server.storage.lucene.buffersize")); 
+        this.storagepersistFactor = Integer.parseInt(properties 
+                .getProperty("gdata.server.storage.lucene.persistFactor")); 
+        this.recover = Boolean.parseBoolean(properties 
+                .getProperty("gdata.server.storage.lucene.recover")); 
+        this.keepRecoveredFiles = Boolean.parseBoolean(properties 
+                .getProperty("gdata.server.storage.lucene.recover.keepFiles")); 
+        this.storageDirectory = properties 
+                .getProperty("gdata.server.storage.lucene.directory"); 
+        this.indexOptimizeInterval = Integer.parseInt(properties 
+                .getProperty("gdata.server.storage.lucene.optimizeInterval")); 
+        this.ramDirectory = Boolean.parseBoolean(properties 
+                .getProperty("gdata.server.storage.lucene.directory.ramDirectory"));
+    } 
+ 
+    /** 
+     * @return - the storage configurator 
+     */ 
+    public static synchronized StorageConfigurator getStorageConfigurator() { 
+        if (INSTANCE == null) 
+            INSTANCE = new StorageConfigurator(); 
+        return INSTANCE; 
+    } 
+ 
+    /** 
+     * Keep recovering files. -- will use a lot of disk space 
+     *  
+     * @return <code>true</code> if the storage is supposed to keep the 
+     *         recovering files. 
+     */ 
+    public boolean isKeepRecoveredFiles() { 
+        return this.keepRecoveredFiles; 
+    } 
+ 
+    /** 
+     * @return <code>true</code> if the storage is supposed to use recovering. 
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier 
+     */ 
+    public boolean isRecover() { 
+        return this.recover; 
+    } 
+ 
+    /** 
+     * @return - the configured storage buffer size 
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageBuffer 
+     */ 
+    public int getStorageBufferSize() { 
+        return this.storageBufferSize; 
+    } 
+ 
+    /** 
+     * @return - the configured storage directory 
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier 
+     */ 
+    public String getStorageDirectory() { 
+        return this.storageDirectory; 
+    } 
+ 
+    /** 
+     * @return - the persist factor 
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier 
+     */ 
+    public int getStoragepersistFactor() { 
+        return this.storagepersistFactor; 
+    } 
+ 
+    protected class StorageConfigurationError extends Error { 
+ 
+        /** 
+         *  
+         */ 
+        private static final long serialVersionUID = 5261674332036111464L; 
+ 
+        protected StorageConfigurationError(String arg0, Throwable arg1) { 
+            super(arg0, arg1); 
+ 
+        } 
+ 
+    } 
+ 
+    /** 
+     * @return - the optimize interval 
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier 
+     */ 
+    public int getIndexOptimizeInterval() { 
+ 
+        return this.indexOptimizeInterval; 
+    }
+
+    /**
+     * @return Returns the ramDirectory.
+     */
+    public boolean isRamDirectory() {
+        return this.ramDirectory;
+    } 
+ 
+} 
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/configuration/package.html b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/configuration/package.html
new file mode 100644
index 0000000..e3c84b2
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/configuration/package.html
@@ -0,0 +1,10 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
+<html> 
+<head> 
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
+   <meta name="Author" content="Simon Willnauer"> 
+</head> 
+<body> 
+Lucene Storage utils 
+</body> 
+</html> 
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/package.html b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/package.html
new file mode 100644
index 0000000..0f8f375
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/package.html
@@ -0,0 +1,10 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
+<html> 
+<head> 
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
+   <meta name="Author" content="Simon Willnauer"> 
+</head> 
+<body> 
+Lucene storage implementation  
+</body> 
+</html> 
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverController.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverController.java
new file mode 100644
index 0000000..94f3314
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverController.java
@@ -0,0 +1,204 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.storage.lucenestorage.recover;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.FileReader;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.Writer;
+import java.util.List;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.storage.StorageException;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageModifier;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper.StorageOperation;
+
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class RecoverController {
+    private static final Log LOG = LogFactory.getLog(RecoverController.class);
+    private final File recoverDirectory;
+
+    private static final String FILE_SUFFIX = ".rec";
+
+    private File currentRecoverFile;
+
+    private RecoverWriter writer;
+
+    private Writer fileWriter;
+
+    private BufferedReader fileReader;
+
+    private RecoverReader reader;
+
+    private Lock lock = new ReentrantLock();
+    
+    private final boolean recover;
+    private final boolean keepRecoverFiles;
+
+    /**
+     * @param recoverDirectory
+     * @param recover
+     * @param keepRecoverFiles
+     */
+    public RecoverController(final File recoverDirectory, boolean recover, boolean keepRecoverFiles) {
+        if (recoverDirectory == null)
+            throw new IllegalArgumentException("directory must not be null");
+        if(!recoverDirectory.exists())
+            recoverDirectory.mkdirs();
+        if (!recoverDirectory.isDirectory())
+            throw new IllegalStateException("the given File is not a directory -- "+recoverDirectory);
+        this.recover = recover;
+        this.keepRecoverFiles = keepRecoverFiles;
+        this.recoverDirectory = recoverDirectory;
+       
+    }
+
+   /**
+ * @param wrapper
+ * @throws RecoverException
+ */
+public void storageModified(StorageEntryWrapper wrapper)
+            throws RecoverException {
+        // prevent deadlock either recovering or writing
+        if(this.recover){
+            LOG.warn("Can't write entry, Recovercontroller is initialized in recover mode");
+            return;
+        }
+        this.lock.lock();
+        try {
+
+            this.writer.writeEntry(wrapper, this.fileWriter);
+        } catch (Exception e) {
+            LOG.error("Writing entry failed -- create new recover file",e);
+            throw new RecoverException(
+                    "Writing entry failed -- create new recover file",e);
+
+        } finally {
+            this.lock.unlock();
+        }
+    }
+    
+    /**
+     * @param modifier
+     */
+    public void recoverEntries(final StorageModifier modifier){
+        // prevent deadlock either recovering or writing
+        if(!this.recover){
+            LOG.warn("Can't recover entries, Recovercontroller is initialized in write mode");
+            return;
+        }
+        this.lock.lock();
+        try{
+            this.reader = new RecoverReader();
+        File[] files = this.recoverDirectory.listFiles();
+        for (int i = 0; i < files.length; i++) {
+            if(!files[i].isDirectory()){
+                try{
+                LOG.info("Recover file -- "+files[i]);
+                this.fileReader = new BufferedReader(new FileReader(files[i]));
+                List<StorageEntryWrapper> entryList = this.reader.recoverEntries(this.fileReader);
+                if(entryList.size() == 0)
+                    continue;
+                storeEntries(entryList,modifier);
+                this.fileReader.close();
+                if(!this.keepRecoverFiles){
+                    LOG.info("Recovering file -- "+files[i]+" successful, delete file");
+                    files[i].delete();
+                }
+                }catch (StorageException e) {
+                    LOG.error("Can't store recover entries for file: "+files[i].getName()+" -- keep file "+e.getMessage(),e);
+                }catch (IOException e) {
+                    LOG.error("Can't recover entries for file: "+files[i].getName()+" -- keep file",e);
+                }
+            }
+        }
+        
+        }finally{
+            this.lock.unlock();
+        }
+    }
+    
+    protected void storeEntries(final List<StorageEntryWrapper> entries, final StorageModifier modifier) throws StorageException, IOException{
+        for (StorageEntryWrapper wrapper : entries) {
+            if(wrapper.getOperation() == StorageOperation.DELETE)
+                modifier.deleteEntry(wrapper);
+            else if(wrapper.getOperation() == StorageOperation.INSERT)
+                modifier.insertEntry(wrapper);
+            else if(wrapper.getOperation() == StorageOperation.UPDATE)
+                modifier.updateEntry(wrapper);
+            modifier.forceWrite();
+          
+        }
+    }
+
+    /**
+     * @throws IOException
+     */
+    public synchronized void initialize() throws IOException {
+        if(this.recover)
+            return;
+        String filename = System.currentTimeMillis() + FILE_SUFFIX;
+        this.currentRecoverFile = new File(this.recoverDirectory, filename);
+        this.writer = new RecoverWriter();
+        this.fileWriter = new BufferedWriter(new FileWriter(
+                this.currentRecoverFile));
+
+    }
+
+    /**
+     * @throws RecoverException
+     */
+    public synchronized void destroy() throws RecoverException {
+        if (this.fileWriter != null) {
+            this.lock.lock();
+            try {
+                
+                this.fileWriter.flush();
+                this.fileWriter.close();
+                if(!this.keepRecoverFiles && this.currentRecoverFile != null)
+                    this.currentRecoverFile.delete();
+            } catch (IOException e) {
+                throw new RecoverException("Can't close recover writer ", e);
+            } finally {
+                this.lock.unlock();
+            }
+        }
+    }
+
+    /**
+     * @return <code>true</code> if the RecoverController is initialized in recover mode, otherwise <code>false</code>
+     */
+    public boolean isRecovering() {
+        
+        return this.recover;
+    }
+    
+    
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverException.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverException.java
new file mode 100644
index 0000000..90acff5
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverException.java
@@ -0,0 +1,66 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.storage.lucenestorage.recover;
+
+import org.apache.lucene.gdata.storage.StorageException;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class RecoverException extends StorageException {
+
+    /**
+     * 
+     */
+    private static final long serialVersionUID = -1862309520257024464L;
+
+    /**
+     * 
+     */
+    public RecoverException() {
+        super();
+        // TODO Auto-generated constructor stub
+    }
+
+    /**
+     * @param arg0
+     */
+    public RecoverException(String arg0) {
+        super(arg0);
+        // TODO Auto-generated constructor stub
+    }
+
+    /**
+     * @param arg0
+     * @param arg1
+     */
+    public RecoverException(String arg0, Throwable arg1) {
+        super(arg0, arg1);
+        // TODO Auto-generated constructor stub
+    }
+
+    /**
+     * @param arg0
+     */
+    public RecoverException(Throwable arg0) {
+        super(arg0);
+        // TODO Auto-generated constructor stub
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverReader.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverReader.java
new file mode 100644
index 0000000..933fbf7
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverReader.java
@@ -0,0 +1,175 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.storage.lucenestorage.recover;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.StringReader;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.StringTokenizer;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.server.GDataEntityBuilder;
+import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
+import org.apache.lucene.gdata.server.registry.ProvidedService;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper.StorageOperation;
+
+import com.google.gdata.data.BaseEntry;
+import com.google.gdata.util.ParseException;
+
+/**
+ * Recovers the written object from the harddisc
+ * @author Simon Willnauer
+ *
+ */
+public class RecoverReader {
+    
+    private static final Log LOG = LogFactory.getLog(RecoverReader.class);
+    private RecoverStrategy strategy; 
+    protected RecoverReader(){
+        this.strategy = new RecoverStrategy();
+    }
+    /**
+     * @param reader
+     * @return
+     * @throws IOException
+     */
+    public List<StorageEntryWrapper> recoverEntries(final BufferedReader reader) throws IOException{
+        List<StorageEntryWrapper> actionList = new ArrayList<StorageEntryWrapper>();
+        this.strategy = new RecoverStrategy();
+        String input = null;
+        String metaData = null;
+        String entryData = null;
+        while((input=reader.readLine())!= null){
+            if(metaData == null){
+                metaData = input;
+                continue;
+            }
+            if(input.equals(RecoverWriter.STORAGE_OPERATION_SEPARATOR)){
+                try{
+                actionList.add(this.strategy.recover(metaData,entryData));
+                }catch (RecoverException e) {
+                  LOG.error("Skipping recover entry for metadata: "+metaData,e);
+                }
+                this.strategy = new RecoverStrategy();
+                metaData = null;
+                entryData = null;
+             continue;   
+            }
+            if(entryData == null){
+                entryData = input;
+            }
+            
+        }
+        
+        
+        
+        return actionList;
+        
+    }
+    
+    
+    
+    
+    
+  
+    
+    
+    private static  class RecoverStrategy{
+        private StorageOperation operation;
+        private ProvidedService config;
+        private String feedId;
+        private String entryId;
+        private long timestamp;
+        /**
+         * @param metaData
+         * @param entry
+         * @return
+         * @throws RecoverException
+         */
+        public StorageEntryWrapper recover(String metaData, String entry) throws RecoverException{
+                fillMetaData(metaData);
+                ServerBaseEntry retVal = null;
+                if(entry != null && this.operation == StorageOperation.DELETE)
+                    throw new RecoverException("Can not recover -- Delete operation has entry part");
+                if(entry != null)
+                    try {
+                        retVal = new ServerBaseEntry(buildEntry(entry,this.config));
+                    } catch (Exception e) {
+                        throw new RecoverException("Exception occured while building entry -- "+e.getMessage(),e);
+                    }
+                else
+                    retVal = new ServerBaseEntry();
+                retVal.setId(this.entryId);
+                retVal.setFeedId(this.feedId);
+                retVal.setServiceConfig(this.config);
+                
+           try{
+            return new StorageEntryWrapper(retVal,this.operation);
+           }catch (IOException e) {
+               throw new RecoverException("Can't create StorageWrapper -- "+e.getMessage(),e);
+        }
+        }
+        private void fillMetaData(String recoverString) throws RecoverException{
+            StringTokenizer tokenizer = new StringTokenizer(recoverString,RecoverWriter.META_DATA_SEPARATOR);
+            String temp = tokenizer.nextToken();
+            if(temp.equals("D"))
+                this.operation = StorageOperation.DELETE;
+            else if(temp.equals("U"))
+                this.operation = StorageOperation.UPDATE;
+            else if(temp.equals("I"))
+                this.operation = StorageOperation.INSERT;
+            else
+                throw new RecoverException("Illegal metadata --- "+recoverString);
+            temp = tokenizer.nextToken();
+            if(temp == null)
+                throw new RecoverException("Can't recover feed Id -- is null");
+            this.feedId = temp;
+            temp = tokenizer.nextToken();
+            if(temp == null)
+                throw new RecoverException("Can't recover entry Id -- is null");
+             this.entryId = temp;
+            
+            temp = tokenizer.nextToken();
+            try{
+                this.timestamp = Long.parseLong(temp);
+            }catch (Exception e) {
+                throw new RecoverException("Can't recover timestamp -- is null",e);
+            }
+            
+            if(this.operation != StorageOperation.DELETE){
+                temp = tokenizer.nextToken();
+                if(temp == null)
+                    throw new RecoverException("Can't recover service -- is null");  
+                if(!GDataServerRegistry.getRegistry().isServiceRegistered(temp))
+                    throw new RecoverException("Service in recover metadata is not registered  - "+temp);
+                this.config = GDataServerRegistry.getRegistry().getProvidedService(temp);
+                
+            }
+            
+        }
+        
+        private BaseEntry buildEntry(String entry, ProvidedService serviceConfig) throws ParseException, IOException{
+           StringReader reader = new StringReader(entry);
+           return GDataEntityBuilder.buildEntry(reader,serviceConfig);
+        }
+    }
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverWriter.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverWriter.java
new file mode 100644
index 0000000..a5c78c8
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/recover/RecoverWriter.java
@@ -0,0 +1,106 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.storage.lucenestorage.recover;
+
+import java.io.IOException;
+import java.io.Writer;
+
+import org.apache.lucene.gdata.server.registry.ProvidedService;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper.StorageOperation;
+
+import com.google.gdata.data.BaseEntry;
+import com.google.gdata.util.common.xml.XmlWriter;
+
+/**
+ * Writes the recover objects to the hard disc.
+ * @author Simon Willnauer
+ *
+ */
+public class RecoverWriter {
+    protected static final String META_DATA_SEPARATOR = ";";
+    protected static final String META_DATA_ENTRY_SEPARATOR = System.getProperty("line.separator");
+    protected static final String STORAGE_OPERATION_SEPARATOR = "###########";
+    protected static final String OPERATION_DELETE = "D";
+    protected static final String OPERATION_UPDATE = "U";
+    protected static final String OPERATION_INSERT = "I";
+    protected static final String FILE_PREFIX = ".strg";
+   
+    
+    
+    /**
+     * @param wrapper 
+     * @throws IOException 
+     * 
+     * 
+     * 
+     */
+    public void writeEntry(StorageEntryWrapper wrapper,Writer writer)throws IOException{
+        
+        writeOperation(wrapper.getOperation(),writer);
+        writeFeedID(wrapper.getFeedId(),writer);
+        writeEntryID(wrapper.getEntryId(),writer);
+        writeTimeStamp(wrapper.getTimestamp().toString(),writer);
+        if(!wrapper.getOperation().equals(StorageOperation.DELETE)){
+        writeService(wrapper,writer);
+            writer.write(META_DATA_ENTRY_SEPARATOR);
+            BaseEntry entry = wrapper.getEntry();
+            XmlWriter xmlWriter = new XmlWriter(writer);
+            entry.generateAtom(xmlWriter,wrapper.getConfigurator().getExtensionProfile());
+        }
+        writer.write(META_DATA_ENTRY_SEPARATOR);
+        writer.write(STORAGE_OPERATION_SEPARATOR);
+        writer.write(META_DATA_ENTRY_SEPARATOR);
+        writer.flush();
+    }
+
+   
+
+    private void writeTimeStamp(String timestamp, Writer writer) throws IOException{
+        writer.write(timestamp);
+        writer.write(META_DATA_SEPARATOR);
+    }
+    private void writeFeedID(String feedId,Writer writer) throws IOException{
+        writer.write(feedId);
+        writer.write(META_DATA_SEPARATOR);
+    }
+    private void writeEntryID(String entryId,Writer writer) throws IOException{
+        writer.write(entryId);
+        writer.write(META_DATA_SEPARATOR);
+    }
+    
+    private void writeService(StorageEntryWrapper wrapper, Writer writer) throws IOException{
+        ProvidedService config = wrapper.getConfigurator();
+        writer.write(config.getName());
+        writer.write(META_DATA_SEPARATOR);
+    }
+ 
+    private void writeOperation(StorageOperation operation, Writer writer) throws IOException{
+        if(operation.equals(StorageOperation.INSERT))
+            writer.write(OPERATION_INSERT);
+        else if (operation.equals(StorageOperation.UPDATE)) 
+            writer.write(OPERATION_UPDATE);
+        else if (operation.equals(StorageOperation.DELETE)) 
+            writer.write(OPERATION_DELETE);
+        writer.write(META_DATA_SEPARATOR);
+    }
+    
+    
+    
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/recover/package.html b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/recover/package.html
new file mode 100644
index 0000000..0ba6029
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/recover/package.html
@@ -0,0 +1,10 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
+<html> 
+<head> 
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
+   <meta name="Author" content="Simon Willnauer"> 
+</head> 
+<body> 
+Recovering component for the lucene storage
+</body> 
+</html> 
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/util/ReferenceCounter.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/util/ReferenceCounter.java
new file mode 100644
index 0000000..e69de29
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/util/package.html b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/util/package.html
new file mode 100644
index 0000000..0ed664d
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/lucenestorage/util/package.html
@@ -0,0 +1,10 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
+<html> 
+<head> 
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
+   <meta name="Author" content="Simon Willnauer"> 
+</head> 
+<body> 
+Storage Configuration 
+</body> 
+</html> 
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/package.html b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/package.html
new file mode 100644
index 0000000..547ca70
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/storage/package.html
@@ -0,0 +1,10 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
+<html> 
+<head> 
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
+   <meta name="Author" content="Simon Willnauer"> 
+</head> 
+<body> 
+Feed / Enty storage  
+</body> 
+</html> 
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/utils/DateFormater.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/utils/DateFormater.java
new file mode 100644
index 0000000..3f3c3cd
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/utils/DateFormater.java
@@ -0,0 +1,138 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.utils;
+
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Locale;
+import java.util.Stack;
+
+/**
+ * This class uses the {@link java.text.SimpleDateFormat} class to format dates
+ * into strings according to given date pattern.
+ * <p>
+ * As the creation of <tt>SimpleDateFormat</tt> objects is quiet expensive and
+ * formating dates is used quiet fequently the objects will be cached and reused
+ * in subsequent calls.
+ * </p>
+ * <p>
+ * This implementation is thread safe as it uses {@link java.util.Stack} as a
+ * cache
+ * </p>
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class DateFormater {
+    private final Stack<SimpleDateFormat> objectStack = new Stack<SimpleDateFormat>();
+    
+    private static final DateFormater formater = new DateFormater();
+
+    /**
+     * Date format as it is used in Http Last modified header (Tue, 15 Nov 1994
+     * 12:45:26 GMT)
+     */
+    public final static String HTTP_HEADER_DATE_FORMAT = "EEE, d MMM yyyy HH:mm:ss z";
+    /**
+     *  Date format as it is used in Http Last modified header (Tue, 15 Nov 1994
+     * 12:45:26 +0000)
+     */
+    public final static String HTTP_HEADER_DATE_FORMAT_TIME_OFFSET = "EEE, d MMM yyyy HH:mm:ss Z";
+
+    protected DateFormater() {
+        super();
+    }
+
+    /**
+     * Formats the given Date into the given date pattern.
+     * 
+     * @param date -
+     *            the date to format
+     * @param format -
+     *            date pattern
+     * @return - the string representation of the given <tt>Date</tt>
+     *         according to the given pattern
+     */
+    public static String formatDate(final Date date, String format) {
+        if (date == null || format == null)
+            throw new IllegalArgumentException(
+                    "given parameters must not be null");
+        SimpleDateFormat inst = formater.getFormater();
+        inst.applyPattern(format);
+        try{
+            return inst.format(date);
+        }finally{
+            formater.returnFomater(inst);
+        }
+    }
+    /**
+     * Parses the given string into one of the specified formates
+     * @param date - the string to parse
+     * @param formates - formates
+     * @return a {@link Date} instance representing the given string
+     * @throws ParseException - if the string can not be parsed
+     */
+    public static Date parseDate(final String date, final String...formates) throws ParseException{
+        for (int i = 0; i < formates.length; i++) {
+            try {
+             return parseDate(date,formates[i]);
+            } catch (ParseException e) {
+                //
+            }
+        }
+        throw new ParseException("Unparseable date: "+date,0);
+        
+    }
+    
+    /**
+     * Parses the given string into the specified formate
+     * @param dateString - the string to parse
+     * @param pattern - the expected formate
+     * @return a {@link Date} instance representing the given string
+     * @throws ParseException - if the string can not be parsed
+     */
+    public static Date parseDate(final String dateString,String pattern) throws ParseException{
+        if(dateString == null|| pattern == null)
+            throw new IllegalArgumentException(
+            "given parameters must not be null");
+        
+        SimpleDateFormat inst = formater.getFormater();
+        try{
+        inst.applyPattern(pattern);
+        return inst.parse(dateString);
+        }finally{
+            formater.returnFomater(inst);
+        }
+        
+    }
+
+    protected SimpleDateFormat getFormater() {
+        if (this.objectStack.empty())
+            return new SimpleDateFormat(DateFormater.HTTP_HEADER_DATE_FORMAT,Locale.ENGLISH);
+        return this.objectStack.pop();
+    
+    }
+
+    protected void returnFomater(final SimpleDateFormat format) {
+        if (this.objectStack.size() <= 25)
+            this.objectStack.push(format);
+        
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/utils/ModifiedEntryFilter.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/utils/ModifiedEntryFilter.java
new file mode 100755
index 0000000..b6b2b1a
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/utils/ModifiedEntryFilter.java
@@ -0,0 +1,81 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */ 
+ 
+package org.apache.lucene.gdata.utils; 
+ 
+import java.io.IOException;
+import java.util.BitSet;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermDocs;
+import org.apache.lucene.search.Filter;
+ 
+/** 
+ * The {@link ModifiedEntryFilter} filters the given entryIds from the lucene 
+ * {@link org.apache.lucene.search.Hits} set. This filter is used to prevent the 
+ * storage from retrieving already deleted or updated entries still remaining in 
+ * the {@link org.apache.lucene.gdata.storage.lucenestorage.StorageBuffer}. 
+ *  
+ * @see org.apache.lucene.search.Filter 
+ *  
+ * @author Simon Willnauer 
+ *  
+ */ 
+public class ModifiedEntryFilter extends Filter { 
+    /*
+     * implements Serializable 
+     */ 
+    private static final long serialVersionUID = -1551686287704213591L; 
+ 
+    private final String[] entyIds; 
+    private final String searchField;
+    /** 
+     * Creates a new {@link ModifiedEntryFilter} 
+     * @param entryIds the entry id's to filter  
+     * @param field - the field, the id is stored 
+     *  
+     */ 
+    public ModifiedEntryFilter(final String[] entryIds,String field) { 
+        super(); 
+        this.searchField = field;
+        this.entyIds = entryIds; 
+    } 
+ 
+    /** 
+     * @see org.apache.lucene.search.Filter#bits(org.apache.lucene.index.IndexReader) 
+     */ 
+    @Override 
+    public BitSet bits(IndexReader reader) throws IOException { 
+        BitSet bitSet = new BitSet(reader.maxDoc()); 
+        bitSet.flip(0, reader.maxDoc()); // set all documents  
+        int[] docs = new int[1]; 
+        int[] freq = new int[1]; 
+        for (String id : this.entyIds) { 
+            if (id != null) { 
+                TermDocs termDocs = reader.termDocs(new Term( 
+                        this.searchField, id)); 
+                int count = termDocs.read(docs, freq); 
+                if (count == 1) 
+                    bitSet.flip(docs[0]); 
+ 
+            } 
+        } 
+ 
+        return bitSet; 
+    } 
+ 
+} 
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/utils/Pool.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/utils/Pool.java
new file mode 100755
index 0000000..17bcded
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/utils/Pool.java
@@ -0,0 +1,75 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.utils;
+
+/**
+ * Basic interface to be implemented by ObjectPool implementations. Pools should
+ * provide a constructor with a
+ * {@link org.apache.lucene.gdata.utils.PoolObjectFactory} as a mandatory
+ * parameter to create and destory the pooled objects.
+ * 
+ * @see org.apache.lucene.gdata.utils.PoolObjectFactory
+ * 
+ * @author Simon Willnauer
+ * @param <Type> -
+ *            the type of the pooled objects
+ * 
+ */
+public interface Pool<Type> {
+    /**
+     * Return an object from the pool or create one if the pool is empty.
+     * 
+     * @return - a pooled object
+     */
+    public abstract Type aquire();
+
+    /**
+     * Adds a previously aquired object to the pool. If the pool has already
+     * been closed or if the pool has already reached his size the released
+     * object will be destroyed using
+     * {@link PoolObjectFactory#destroyInstance(Object)} method.
+     * 
+     * @param type -
+     *            the previously aquired object
+     */
+    public abstract void release(final Type type);
+
+    /**
+     * @return - the defined size of the pool
+     */
+    public abstract int getSize();
+
+    /**
+     * @return - the expire time of the objects in the pool if defined
+     */
+    public abstract long getExpireTime();
+
+    /**
+     * @return <code>true</code> if and only if the pool uses an expire
+     *         mechanismn, otherwith <code>false</code>
+     */
+    public abstract boolean expires();
+
+    /**
+     * releases all pooled objects using
+     * {@link PoolObjectFactory#destroyInstance(Object)} method. The pool can not
+     * be reused after this method has been called
+     */
+    public abstract void destroy();
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/utils/PoolObjectFactory.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/utils/PoolObjectFactory.java
new file mode 100755
index 0000000..1b570bc
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/utils/PoolObjectFactory.java
@@ -0,0 +1,54 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.utils;
+
+/**
+ * <p>
+ * This interface enables {@link org.apache.lucene.gdata.utils.Pool} users to
+ * build a custom creation and destroy mechanismn for pooled objects.
+ * Implementations can use standart creation to prevent the pool from using
+ * reflection to create objects of the specific type. This implementation
+ * seperates the Pool implementation from the creation or the destruction of a
+ * pooled type.
+ * </p>
+ * <p>
+ * The destroy method can be used to close datasource connections or release
+ * resources if the object will be removed from the pool
+ * </p>
+ * 
+ * 
+ * @see org.apache.lucene.gdata.utils.Pool
+ * @author Simon Willnauer
+ * @param <Type> -
+ *            the type to be created
+ * 
+ */
+public interface PoolObjectFactory<Type> {
+
+    /**
+     * @return an instance of the specified Type
+     */
+    public abstract Type getInstance();
+
+    /**
+     * destroys the given instance
+     * @param type - the object to destroy / release all resources
+     */
+    public abstract void destroyInstance(Type type);
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/utils/ReferenceCounter.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/utils/ReferenceCounter.java
new file mode 100755
index 0000000..7f56b45
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/utils/ReferenceCounter.java
@@ -0,0 +1,80 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */ 
+ 
+package org.apache.lucene.gdata.utils; 
+ 
+import java.util.concurrent.atomic.AtomicInteger; 
+ 
+/** 
+ * A reference counting utility. This is use to keep track of released objects 
+ * of <code>Type</code>. 
+ *  
+ * @author Simon Willnauer 
+ * @param <Type> - 
+ *            the type of the object 
+ *  
+ */ 
+public abstract class ReferenceCounter<Type> { 
+    protected final Type resource; 
+ 
+    private AtomicInteger refcounter = new AtomicInteger(); 
+ 
+    /** 
+     * @param resource - 
+     *            the resource to track 
+     *  
+     */ 
+    public ReferenceCounter(Type resource) { 
+        this.resource = resource; 
+    } 
+ 
+    /** 
+     *  
+     * Decrements the reference. If no references remain the 
+     * {@link ReferenceCounter#close()} method will be invoked; 
+     */ 
+    public final void decrementRef() { 
+        /*
+         * close if less or equals 0
+         */
+        if (this.refcounter.decrementAndGet() <= 0) 
+            close(); 
+    } 
+ 
+    /** 
+     * A custom implementation. Performs an action if no reference remaining 
+     *  
+     */ 
+    protected abstract void close(); 
+ 
+    /** 
+     * Increments the reference 
+     *  
+     * @return the reference object 
+     */ 
+    public final ReferenceCounter<Type> increamentReference() { 
+        this.refcounter.incrementAndGet(); 
+        return this; 
+    } 
+ 
+    /** 
+     * @return - the resource to keep track of 
+     */ 
+    public final Type get() { 
+        return this.resource; 
+    } 
+ 
+} 
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/utils/ReflectionUtils.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/utils/ReflectionUtils.java
new file mode 100755
index 0000000..0f7c5fa
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/utils/ReflectionUtils.java
@@ -0,0 +1,194 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.utils;
+
+import java.lang.reflect.Constructor;
+
+/**
+ * A collection of static helper methods solve common reflection problems
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class ReflectionUtils {
+
+    /**
+     * Check if the given type implements a given super type
+     * @param typeToCheck - type supposed to implement an interface
+     * @param superType - the interface to be implemented by the type to check
+     * @return <code>true</code> if and only if the super type is above in the type hierarchy of the given type, otherwise <code>false</code>
+     */
+    public static boolean implementsType(Class typeToCheck, Class superType) {
+        if(superType == null)
+            return false;
+        if(!superType.isInterface())
+            return  false;
+        if (typeToCheck == null)
+            return false;
+        if (typeToCheck.equals(Object.class))
+            return false;
+        if (typeToCheck.equals(superType))
+            return true;
+        Class[] interfaces = typeToCheck.getInterfaces();
+        for (int i = 0; i < interfaces.length; i++) {
+            if (implementsType(interfaces[i], superType))
+                return true;
+        }
+        return implementsType(typeToCheck.getSuperclass(),superType);
+        
+    }
+    /**
+     * Check if the given type extends a given super type
+     * @param typeToCheck - type supposed to extend an specific type
+     * @param superType - the type to be extended by the type to check
+     * @return <code>true</code> if and only if the super type is above in the type hierarchy of the given type, otherwise <code>false</code>
+     */
+    public static boolean extendsType(Class typeToCheck, Class superType) {
+        if (typeToCheck == null)
+            return false;
+        if (typeToCheck.equals(Object.class))
+            return false;
+        if (typeToCheck.equals(superType))
+            return true;
+        
+        return extendsType(typeToCheck.getSuperclass(),superType);
+    }
+    /**
+     * This method combines the extendsType and implementsType and checks interfaces and classes
+     * @param typeToCheck - type supposed to extend / implement an specific type
+     * @param superType - the type to be extended / implemented by the type to check
+     * @return <code>true</code> if and only if the super type is above in the type hierarchy of the given type, otherwise <code>false</code>
+     */
+    public static boolean isTypeOf(Class typeToCheck, Class superType){
+        return extendsType(typeToCheck,superType)||implementsType(typeToCheck,superType);
+    }
+    
+    /**
+     * @param type - the type to check
+     * @param parameter - the constructor parameter
+     * @return <code>true</code> if and only if the type has a visible constructor with the desired parameters
+     */
+    public static boolean hasDesiredConstructor(Class type, Class[] parameter){
+        try{
+        return type.getConstructor(parameter) != null;
+        
+        }catch (Exception e) {
+            return false;
+        }
+    }
+  
+ 
+/**
+ * @param <T> the type of the class to instantiate 
+ * @param clazz - class object of the type
+ * @return a new instance of T
+
+ */
+@SuppressWarnings("unchecked")
+public  static <T> T getDefaultInstance(Class<T> clazz) {
+    if(clazz == null)
+        throw new ReflectionException("class must not be null");
+    
+    try{
+    Constructor constructor = clazz.getConstructor(new Class[]{});
+    return (T) constructor.newInstance(new Object[]{});
+    }catch (Exception e) {
+        throw new ReflectionException("can not instantiate type of class "+clazz.getName(),e);
+    }
+}
+
+
+/**
+ * This method calls {@link Class#newInstance()} to get a new instance. Use with care!
+ * @param clazz - the class to instantiate
+ * @return <code>true</code> if an instance could be created, otherwise false;
+ */
+public static boolean canCreateInstance(Class clazz){
+    if(clazz == null)
+        return false;
+    if(clazz.isPrimitive())
+        clazz = getPrimitiveWrapper(clazz);
+    try{
+        Object o = clazz.newInstance();
+        return o != null;
+    }catch (Throwable e) {
+        return false;
+    }
+}
+/**
+ * Returns the wrapper type for the given primitive type. Wrappers can be
+ * easily instantiated via reflection and will be boxed by the VM
+ * @param primitive - the primitive type 
+ * @return - the corresponding wrapper type
+ */
+public static final Class getPrimitiveWrapper(Class primitive) {
+    if(primitive == null )
+        throw new ReflectionException("primitive must not be null");
+    if(!primitive.isPrimitive())
+        throw new ReflectionException("given class is not a primitive");
+                
+    if (primitive == Integer.TYPE)
+        return Integer.class;
+    if (primitive == Float.TYPE)
+        return Float.class;
+    if (primitive == Long.TYPE)
+        return Long.class;
+    if (primitive == Short.TYPE)
+        return Short.class;
+    if (primitive == Byte.TYPE)
+        return Byte.class;
+    if (primitive == Double.TYPE)
+        return Double.class;
+    if (primitive == Boolean.TYPE)
+        return Boolean.class;
+
+    return primitive;
+}
+
+/**
+ * Exception wrapper for all thrown exception in the ReflectionUtils methods
+ * @author Simon Willnauer
+ *
+ */
+public static class ReflectionException extends RuntimeException{
+
+    /**
+     * 
+     */
+    private static final long serialVersionUID = -4855060602565614280L;
+
+    /**
+     * @param message -  the exception message
+     * @param cause - the exception root cause
+     */
+    public ReflectionException(String message, Throwable cause) {
+        super(message, cause);
+        // TODO Auto-generated constructor stub
+    }
+
+    /**
+     * @param message - the exception message
+     */
+    public ReflectionException(String message) {
+        super(message);
+        // TODO Auto-generated constructor stub
+    }
+    
+}
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/utils/SimpleObjectPool.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/utils/SimpleObjectPool.java
new file mode 100755
index 0000000..8da8877
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/utils/SimpleObjectPool.java
@@ -0,0 +1,176 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.utils;
+
+import java.util.Stack;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+/**
+ * A Simple implementation of the {@link org.apache.lucene.gdata.utils.Pool}
+ * interface using a {@link java.util.Stack} as a buffer for the pooled objects.
+ * This implementation does not provide any timeout mechanismn. Objects will
+ * stay inside the pool until the pool is destroyed.
+ * <p>
+ * If any object will be released e.g. handover to the pool and the pool has
+ * already enought objects in the pool the released object will be destroyed. If
+ * the pool is empty a new Object will be created.
+ * </p>
+ * <p>
+ * This implementation does not track any references to the objects aquired by
+ * any other resource. The objects must be destroyed manually if not released to
+ * the pool after aquired.
+ * </p>
+ * 
+ * @author Simon Willnauer
+ * @param <Type>
+ * 
+ */
+public class SimpleObjectPool<Type> implements Pool<Type> {
+    private static final Log LOG = LogFactory.getLog(SimpleObjectPool.class);
+    private volatile boolean isDestroyed = false;
+
+    private final PoolObjectFactory<Type> factory;
+
+    static final int DEFAULTSIZE = 5;
+    static final int MINIMALSIZE = 1;
+
+    private final int size;
+
+    private final Stack<Type> pool;
+
+    private final ReentrantReadWriteLock masterLock = new ReentrantReadWriteLock();
+
+    private final Lock readLock = this.masterLock.readLock();
+
+    private final Lock writeLock = this.masterLock.writeLock();
+
+    /**
+     * Constructs a new {@link SimpleObjectPool} and sets the ObjectFactory and the pool size 
+     * @param size - the maximum size of the pool
+     * @param factory - factory to create and destroy pooled objects
+     * 
+     */
+    public SimpleObjectPool(int size, PoolObjectFactory<Type> factory) {
+        if (factory == null)
+            throw new IllegalArgumentException("Factory must not be null");
+        this.factory = factory;
+        this.size = size < MINIMALSIZE ? MINIMALSIZE : size;
+        this.pool = new Stack<Type>();
+        for (int i = 0; i < this.size; i++) {
+            this.pool.push(this.factory.getInstance());
+        }
+    }
+    /**
+     * @param factory
+     */
+    public SimpleObjectPool(PoolObjectFactory<Type> factory) {
+        this(DEFAULTSIZE,factory);
+        
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.utils.Pool#aquire()
+     */
+    public Type aquire() {
+        // fail if writelock is aquired
+        if (this.readLock.tryLock()) {
+            try {
+                if (this.isDestroyed)
+                    throw new IllegalStateException(
+                            "The pool has already been closed");
+                if (this.pool.isEmpty())
+                    return this.factory.getInstance();
+                return this.pool.pop();
+            } finally {
+                this.readLock.unlock();
+            }
+        }
+        throw new IllegalStateException("The pool has already been closed");
+    }
+
+    /**
+     *
+     * @param type - generic type
+     * @see org.apache.lucene.gdata.utils.Pool#release(Object)
+     */
+    public void release(Type type) {
+        // fail if writelock is aquired
+        if (this.readLock.tryLock()) {
+            try {
+                if (this.pool.size() < this.size && !this.isDestroyed)
+                    this.pool.push(type);
+                else
+                    this.factory.destroyInstance(type);
+            } finally {
+                this.readLock.unlock();
+            }
+            return;
+        }
+        // enable object need to be destoryed
+        this.factory.destroyInstance(type);
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.utils.Pool#getSize()
+     */
+    public int getSize() {
+
+        return this.size;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.utils.Pool#getExpireTime()
+     */
+    public long getExpireTime() {
+
+        return 0;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.utils.Pool#expires()
+     */
+    public boolean expires() {
+
+        return false;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.utils.Pool#destroy()
+     */
+    public void destroy() {
+        this.writeLock.lock();
+        try {
+            if (this.isDestroyed)
+                return;
+            this.isDestroyed = true;
+            LOG.info("Destroy all elements in the pool -- poolsize: "+this.pool.size());
+            for (Type type : this.pool) {
+                this.factory.destroyInstance(type);
+            }
+            this.pool.clear();
+        } finally {
+            this.writeLock.unlock();
+        }
+
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/utils/SimpleSaxErrorHandler.java b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/utils/SimpleSaxErrorHandler.java
new file mode 100755
index 0000000..194fa54
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/utils/SimpleSaxErrorHandler.java
@@ -0,0 +1,53 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.utils;
+
+import org.xml.sax.ErrorHandler;
+import org.xml.sax.SAXException;
+import org.xml.sax.SAXParseException;
+
+/**
+ * For use with Digester to throw exceptions on errors
+ * @author Simon Willnauer
+ *
+ */
+public final class SimpleSaxErrorHandler implements ErrorHandler{
+
+    /**
+     * @see org.xml.sax.ErrorHandler#warning(org.xml.sax.SAXParseException)
+     */
+    public void warning(SAXParseException arg0) throws SAXException {
+        //
+    }
+
+    /**
+     * @see org.xml.sax.ErrorHandler#error(org.xml.sax.SAXParseException)
+     */
+    public void error(SAXParseException arg0) throws SAXException {
+        
+        throw new SAXException("ERROR: Can not parse XML Document -- "+arg0.getMessage(),arg0);
+    }
+
+    /**
+     * @see org.xml.sax.ErrorHandler#fatalError(org.xml.sax.SAXParseException)
+     */
+    public void fatalError(SAXParseException arg0) throws SAXException {
+        throw new SAXException("FATAL ERROR: Can not parse XML Document -- "+arg0.getMessage(),arg0);
+    }
+    
+}
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/utils/package.html b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/utils/package.html
new file mode 100644
index 0000000..9e0201c
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/utils/package.html
@@ -0,0 +1,10 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> 
+<html> 
+<head> 
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
+   <meta name="Author" content="Simon Willnauer"> 
+</head> 
+<body> 
+Utils package
+</body> 
+</html> 
diff --git a/contrib/gdata-server/src/core/src/test/gdata-account.xsd b/contrib/gdata-server/src/core/src/test/gdata-account.xsd
new file mode 100755
index 0000000..bc0b0e0
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/gdata-account.xsd
@@ -0,0 +1,50 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
+	<xs:element name="password">
+		<xs:simpleType>
+			<xs:restriction base="xs:string">
+				<xs:minLength value="5" />
+			</xs:restriction>
+		</xs:simpleType>
+	</xs:element> 
+	<xs:element name="account-name">
+		<xs:simpleType>
+			<xs:restriction base="xs:string">
+				<xs:whiteSpace value="collapse" />
+			</xs:restriction>
+		</xs:simpleType>
+	</xs:element>
+
+	<xs:element name="email-address" type="xs:string" />
+	<xs:element name="url" type="xs:anyURI" />
+	<xs:element name="name" type="xs:string" />
+	<xs:element name="account-role">
+		<xs:simpleType>
+			<xs:restriction base="xs:positiveInteger">
+				<xs:fractionDigits value="2" />
+			</xs:restriction>
+		</xs:simpleType>
+	</xs:element>
+
+
+	<xs:element name="account-owner">
+		<xs:complexType>
+			<xs:sequence>
+				<xs:element ref="name" />
+				<xs:element ref="email-address" />
+				<xs:element ref="url" />
+			</xs:sequence>
+		</xs:complexType>
+	</xs:element>
+
+	<xs:element name="account">
+		<xs:complexType>
+			<xs:sequence>
+				<xs:element ref="account-name" />
+				<xs:element ref="password" />
+				<xs:element ref="account-role" />
+				<xs:element ref="account-owner" minOccurs="0" />
+			</xs:sequence>
+		</xs:complexType>
+	</xs:element>
+</xs:schema>
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/src/test/gdata-config.xml b/contrib/gdata-server/src/core/src/test/gdata-config.xml
new file mode 100644
index 0000000..e69de29
diff --git a/contrib/gdata-server/src/core/src/test/lucenestorage.properties.xml b/contrib/gdata-server/src/core/src/test/lucenestorage.properties.xml
new file mode 100644
index 0000000..e69de29
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/data/TestGDataUser.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/data/TestGDataUser.java
new file mode 100644
index 0000000..ec2a877
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/data/TestGDataUser.java
@@ -0,0 +1,132 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.data;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class TestGDataUser extends TestCase {
+    private GDataAccount user;
+    @Override
+    protected void setUp() throws Exception {
+        this.user = new GDataAccount();
+        this.user.setName("simonW");
+        super.setUp();
+    }
+
+    @Override
+    protected void tearDown() throws Exception {
+        
+        super.tearDown();
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.data.GDataUser.isUserInRole(UserRole)'
+     */
+    public void testIsUserInRole() {
+        assertFalse(this.user.isUserInRole(null));
+        assertTrue(this.user.isUserInRole(AccountRole.USER));
+        assertFalse(this.user.isUserInRole(AccountRole.ENTRYAMINISTRATOR));
+        this.user.setRole(AccountRole.ENTRYAMINISTRATOR);
+        assertTrue(this.user.isUserInRole(AccountRole.ENTRYAMINISTRATOR));
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.data.GDataUser.getRolesAsInt()'
+     */
+    public void testGetRolesAsInt() {
+        assertEquals(1,this.user.getRolesAsInt());
+        this.user.setRole(AccountRole.ENTRYAMINISTRATOR);
+        assertEquals(3,this.user.getRolesAsInt());
+        this.user.setRole(AccountRole.FEEDAMINISTRATOR);
+        assertEquals(7,this.user.getRolesAsInt());
+        this.user.setRole(AccountRole.USERADMINISTRATOR);
+        assertEquals(15,this.user.getRolesAsInt());
+        
+        
+        
+    }
+    
+    public void testIsUserInRoleInt(){
+        assertFalse(GDataAccount.isInRole(1,AccountRole.ENTRYAMINISTRATOR));
+        assertFalse(GDataAccount.isInRole(1,AccountRole.FEEDAMINISTRATOR));
+        assertTrue(GDataAccount.isInRole(3,AccountRole.ENTRYAMINISTRATOR));
+        assertTrue(GDataAccount.isInRole(15,AccountRole.ENTRYAMINISTRATOR));
+        assertTrue(GDataAccount.isInRole(3,AccountRole.USER));
+        assertTrue(GDataAccount.isInRole(15,AccountRole.USERADMINISTRATOR));
+        assertFalse(GDataAccount.isInRole(7,AccountRole.USERADMINISTRATOR));
+        assertFalse(GDataAccount.isInRole(7,null));
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.data.GDataUser.setRolesAsInt(int)'
+     */
+    public void testSetRolesAsInt() {
+        this.user.setRolesAsInt(2);
+        this.user.setRolesAsInt(4);
+        this.user.setRolesAsInt(8);
+        assertEquals(4,this.user.getRoles().size()); 
+        this.user.setRolesAsInt(15);
+        assertEquals(4,this.user.getRoles().size());
+        this.user = new GDataAccount();
+        this.user.setName("simon");
+        this.user.setRolesAsInt(15);
+        assertEquals(4,this.user.getRoles().size());
+        
+    }
+    
+    public void testEquals(){
+        assertTrue(this.user.equals(this.user));
+        GDataAccount a = new GDataAccount();
+        a.setName(this.user.getName());
+        assertTrue(this.user.equals(a));
+        a.setName("someOtheraccount");
+        assertFalse(this.user.equals(a));
+        assertFalse(this.user.equals(null));
+        assertFalse(this.user.equals(new String()));
+        assertFalse(new GDataAccount().equals(new GDataAccount()));
+    }
+    public void testHashCode(){
+        assertEquals(this.user.hashCode(),this.user.hashCode());
+        assertFalse(this.user.hashCode()== this.user.getName().hashCode());
+        GDataAccount a = new GDataAccount();
+        a.setName(this.user.getName());
+        assertEquals(this.user.hashCode(),a.hashCode());
+        a.setName(null);
+        assertFalse(a.hashCode()== this.user.hashCode());
+    }
+    
+    public void testReqValuesSet(){
+        assertFalse(this.user.requiredValuesSet());
+        this.user.setPassword("hello");
+        assertFalse(this.user.requiredValuesSet());
+        this.user.setPassword("helloworld");
+        assertTrue(this.user.requiredValuesSet());
+        assertFalse(new GDataAccount().requiredValuesSet());
+    }
+    
+    public void testToStringPrevNulPEx(){
+        assertNotNull(this.user.toString());
+    }
+    
+    
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/TestStandardGdataSearcher.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/TestStandardGdataSearcher.java
new file mode 100755
index 0000000..26ee9df
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/TestStandardGdataSearcher.java
@@ -0,0 +1,222 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.search;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.analysis.standard.StandardAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.gdata.search.StandardGdataSearcher;
+import org.apache.lucene.gdata.search.index.IndexDocument;
+import org.apache.lucene.gdata.utils.ReferenceCounter;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.Hits;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.RAMDirectory;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class TestStandardGdataSearcher extends TestCase {
+    private Directory dir;
+
+    private int amountDocuments = 30;
+
+    private static final String FIELDNAME = "fname";
+
+    private static final String FIELDVALUE = "foobar";
+
+    private ReferenceCounter<IndexSearcher> searcher;
+
+    private StandardGdataSearcher gdataSearcher;
+
+    private List<String> idlist;
+    
+    private String feedId = "myFeed";
+
+    protected void setUp() throws Exception {
+        this.dir = new RAMDirectory();
+        IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(), true);
+        this.idlist = new ArrayList<String>();
+        for (int i = 0; i < this.amountDocuments; i++) {
+            Document doc = new Document();
+            doc.add(new Field(IndexDocument.FIELD_FEED_ID, this.feedId,
+                    Field.Store.YES, Field.Index.UN_TOKENIZED));
+            doc.add(new Field(IndexDocument.FIELD_ENTRY_ID, "" + i,
+                    Field.Store.YES, Field.Index.UN_TOKENIZED));
+            doc.add(new Field(FIELDNAME, FIELDVALUE, Field.Store.YES,
+                    Field.Index.UN_TOKENIZED));
+            writer.addDocument(doc);
+            this.idlist.add("" + i);
+        }
+        writer.close();
+        this.searcher = new TestRefcounter(new IndexSearcher(this.dir));
+        this.searcher.increamentReference();
+        this.gdataSearcher = new StandardGdataSearcher(this.searcher);
+    }
+
+    protected void tearDown() throws Exception {
+        this.searcher.decrementRef();
+        StandardGdataSearcher.flushFilterCache();
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.search.StandardGdataSearcher.StandardGdataSearcher(ReferenceCounter<IndexSearcher>)'
+     */
+    public void testStandardGdataSearcher() {
+        try {
+            new StandardGdataSearcher(null);
+            fail("searcher ref is null");
+        } catch (IllegalArgumentException e) {
+
+        }
+        new StandardGdataSearcher(this.searcher);
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.search.StandardGdataSearcher.search(Query, int,
+     * int)'
+     */
+    public void testSearch() throws IOException {
+        Query q = new TermQuery(new Term(FIELDNAME, FIELDVALUE));
+        Hits hits = this.searcher.get().search(q);
+        assertEquals(amountDocuments, hits.length());
+        List<String> returnValue = this.gdataSearcher.search(q,
+                this.amountDocuments, 0,this.feedId);
+        assertEquals(amountDocuments, returnValue.size());
+        assertTrue(returnValue.containsAll(this.idlist));
+        try {
+            this.gdataSearcher.search(null, 1, 0,this.feedId);
+            fail("searcher is null");
+        } catch (RuntimeException e) {
+        }
+
+        try {
+            this.gdataSearcher.search(q, -1, 5,this.feedId);
+            fail("hitcount is less than 0");
+        } catch (IllegalArgumentException e) {}
+        try {
+            this.gdataSearcher.search(q, 4, -1,this.feedId);
+            fail("offset is less than 0");
+        } catch (IllegalArgumentException e) {}
+        try {
+            this.gdataSearcher.search(q, 4, 5,null);
+            fail("feed id is null");
+        } catch (IllegalArgumentException e) {}
+      
+        returnValue = this.gdataSearcher.search(q,this.amountDocuments, 0,"SomeOtherFeed");
+        assertEquals(0,returnValue.size());
+        
+
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.search.StandardGdataSearcher.collectHits(Hits,
+     * int, int)'
+     */
+    public void testCollectHits() throws IOException {
+        Query q = new TermQuery(new Term(FIELDNAME, FIELDVALUE));
+        Hits hits = this.searcher.get().search(q);
+        assertEquals(amountDocuments, hits.length());
+        List<String> returnValue = this.gdataSearcher.collectHits(hits, 1, 0);
+        assertEquals(hits.doc(0).getField(IndexDocument.FIELD_ENTRY_ID)
+                .stringValue(), returnValue.get(0));
+
+        returnValue = this.gdataSearcher.collectHits(hits, 1, 1);
+        assertEquals(hits.doc(0).getField(IndexDocument.FIELD_ENTRY_ID)
+                .stringValue(), returnValue.get(0));
+
+        returnValue = this.gdataSearcher.collectHits(hits, 1,
+                this.amountDocuments);
+        assertEquals(1, returnValue.size());
+        assertEquals(hits.doc(this.amountDocuments - 1).getField(
+                IndexDocument.FIELD_ENTRY_ID).stringValue(), returnValue.get(0));
+
+        returnValue = this.gdataSearcher.collectHits(hits, 10,
+                this.amountDocuments);
+        assertEquals(1, returnValue.size());
+        assertEquals(hits.doc(this.amountDocuments - 1).getField(
+                IndexDocument.FIELD_ENTRY_ID).stringValue(), returnValue.get(0));
+
+        returnValue = this.gdataSearcher.collectHits(hits, 50, 0);
+        assertEquals(this.amountDocuments, returnValue.size());
+        assertTrue(returnValue.containsAll(this.idlist));
+
+        returnValue = this.gdataSearcher.collectHits(hits, 1, 5);
+        assertEquals(1, returnValue.size());
+        assertEquals(hits.doc(4).getField(IndexDocument.FIELD_ENTRY_ID)
+                .stringValue(), returnValue.get(0));
+
+        returnValue = this.gdataSearcher.collectHits(hits, 50,
+                this.amountDocuments);
+        assertEquals(1, returnValue.size());
+        assertEquals(hits.doc(this.amountDocuments - 1).getField(
+                IndexDocument.FIELD_ENTRY_ID).stringValue(), returnValue.get(0));
+
+        returnValue = this.gdataSearcher.collectHits(hits, 1,
+                this.amountDocuments + 1);
+        assertEquals(0, returnValue.size());
+
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.search.StandardGdataSearcher.close()'
+     */
+    public void testClose() throws IOException {
+        StandardGdataSearcher s = new StandardGdataSearcher(new TestRefcounter(
+                new IndexSearcher(this.dir)));
+        s.close();
+        try {
+            s.search(null, 0, 0,this.feedId);
+            fail("searcher is closed");
+        } catch (IllegalStateException e) {
+        }
+
+    }
+
+    private static class TestRefcounter extends ReferenceCounter<IndexSearcher> {
+
+        public TestRefcounter(IndexSearcher resource) {
+            super(resource);
+            // TODO Auto-generated constructor stub
+        }
+
+        @Override
+        protected void close() {
+            try {
+                this.resource.close();
+            } catch (Exception e) {
+                // TODO: handle exception
+            }
+        }
+
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/analysis/IndexableStub.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/analysis/IndexableStub.java
new file mode 100755
index 0000000..f16c213
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/analysis/IndexableStub.java
@@ -0,0 +1,89 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.search.analysis;
+
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.Method;
+import java.lang.reflect.Proxy;
+
+import javax.xml.xpath.XPathExpressionException;
+
+import org.w3c.dom.NamedNodeMap;
+import org.w3c.dom.Node;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class IndexableStub extends Indexable {
+
+    private String content;
+    private boolean retNull;
+    int times = 1;
+    int count = 0;
+    IndexableStub() {
+        super(null);
+
+    }
+    public void returnProxyTimes(int times){
+        this.times = times;
+    }
+    public void setReturnNull(boolean returnNull){
+        this.retNull = returnNull;
+    }
+    public void setReturnValueTextContent(String content){
+        this.content = content;
+    }
+    @Override
+    public Node applyPath(String xPath) throws XPathExpressionException {
+        if(xPath == null)
+            throw new XPathExpressionException("path is null");
+        if(this.retNull)
+            return null;
+        if(times == count)
+            return null;
+        times++;
+        return (Node)Proxy.newProxyInstance(this.getClass().getClassLoader(),new Class[] {Node.class,NamedNodeMap.class},new Handler(this.content));
+        
+    }
+
+    private static class Handler implements InvocationHandler{
+        String returnValue;
+        public Handler(String toReturn){
+            this.returnValue = toReturn;
+        }
+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+            if(method.getName().equals("getNextSibling")){
+                return null;
+            }
+            if(method.getReturnType() == String.class)
+                return this.returnValue;
+            if(method.getReturnType() == Node.class)
+                
+            return (Node)Proxy.newProxyInstance(this.getClass().getClassLoader(),new Class[] {Node.class,NamedNodeMap.class},new Handler(this.returnValue));
+            if(method.getReturnType() == NamedNodeMap.class)
+                return  (NamedNodeMap)Proxy.newProxyInstance(this.getClass().getClassLoader(),new Class[] {Node.class,NamedNodeMap.class},new Handler(this.returnValue));
+            return null;
+            
+        }
+        
+    }
+    
+
+
+}
+
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/analysis/TestContentStrategy.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/analysis/TestContentStrategy.java
new file mode 100755
index 0000000..2ae2fa5
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/analysis/TestContentStrategy.java
@@ -0,0 +1,131 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.search.analysis;
+
+import org.apache.lucene.document.Field;
+import org.apache.lucene.document.Field.Index;
+import org.apache.lucene.document.Field.Store;
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.search.config.IndexSchemaField;
+import org.apache.lucene.gdata.search.index.GdataIndexerException;
+import org.w3c.dom.Node;
+
+import junit.framework.TestCase;
+
+public class TestContentStrategy extends TestCase {
+    private static final String FIELD = "foo";
+    private static final float BOOST = 2.0f;
+    ContentStrategy strategy;
+    
+    protected void setUp() throws Exception {
+        IndexSchemaField field = new IndexSchemaField();
+        field.setName(FIELD);
+        field.setStore(Field.Store.YES);
+        field.setIndex(Field.Index.UN_TOKENIZED);
+        field.setBoost(BOOST);
+        this.strategy = new TestStrategy(field);
+    }
+
+    protected void tearDown() throws Exception {
+        super.tearDown();
+    }
+    public void testContentStrategyIndexStoreField() throws NotIndexableException{
+        IndexSchemaField field = new IndexSchemaField();
+        field.setName(FIELD);
+        
+        
+        this.strategy = new TestStrategy(Field.Index.UN_TOKENIZED,Field.Store.YES,field);
+        this.strategy.processIndexable(null);
+        Field f = this.strategy.createLuceneField()[0];
+        assertEquals(FIELD,f.name());
+        assertEquals(TestStrategy.CONTENT,f.stringValue());
+        assertEquals(1.0f,f.getBoost());
+        assertTrue(f.isIndexed());
+        assertTrue(f.isStored());
+        assertFalse(f.isTokenized());
+        assertFalse(f.isCompressed());
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.search.analysis.ContentStrategy.ContentStrategy(Index, Store, IndexSchemaField)'
+     */
+    public void testContentStrategyIndexSchemaField() throws NotIndexableException {
+        IndexSchemaField field = new IndexSchemaField();
+        field.setName(FIELD);
+        
+        
+        this.strategy = new TestStrategy(field);
+        this.strategy.processIndexable(null);
+        Field f = this.strategy.createLuceneField()[0];
+        
+        assertEquals(FIELD,f.name());
+        assertEquals(TestStrategy.CONTENT,f.stringValue());
+        assertEquals(1.0f,f.getBoost());
+        assertTrue(f.isIndexed());
+        assertFalse(f.isStored());
+        assertTrue(f.isTokenized());
+        assertFalse(f.isCompressed());
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.search.analysis.ContentStrategy.createLuceneField()'
+     */
+    public void testCreateLuceneField() throws NotIndexableException {
+        try{
+        this.strategy.createLuceneField();
+        fail("processIndexable is not called");
+        }catch (GdataIndexerException e) {
+          //
+        }
+        this.strategy.processIndexable(null);
+        Field f = this.strategy.createLuceneField()[0];
+        
+        assertEquals(FIELD,f.name());
+        assertEquals(TestStrategy.CONTENT,f.stringValue());
+        assertEquals(BOOST,f.getBoost());
+        assertTrue(f.isIndexed());
+        assertTrue(f.isStored());
+        assertFalse(f.isTokenized());
+        assertFalse(f.isCompressed());
+       
+        
+        
+    }
+    
+    private static class TestStrategy extends ContentStrategy{
+
+        private static final String CONTENT = "someString";
+
+      
+        protected TestStrategy(Index index, Store store, IndexSchemaField fieldConfig) {
+            super(index, store, fieldConfig);
+      
+        }
+
+        protected TestStrategy(IndexSchemaField fieldConfiguration) {
+            super(fieldConfiguration);
+            
+        }
+
+        @Override
+        public void processIndexable(Indexable<? extends Node, ? extends ServerBaseEntry> indexable) throws NotIndexableException {
+            this.content = CONTENT;
+        }
+        
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/analysis/TestDomIndexable.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/analysis/TestDomIndexable.java
new file mode 100755
index 0000000..2555673
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/analysis/TestDomIndexable.java
@@ -0,0 +1,85 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.search.analysis;
+
+import javax.xml.xpath.XPathExpressionException;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.server.registry.ProvidedServiceConfig;
+import org.apache.lucene.gdata.utils.ProvidedServiceStub;
+import org.w3c.dom.Attr;
+import org.w3c.dom.Node;
+
+import com.google.gdata.data.Category;
+import com.google.gdata.data.ExtensionProfile;
+import com.google.gdata.data.HtmlTextConstruct;
+import com.google.gdata.data.extensions.EventEntry;
+
+public class TestDomIndexable extends TestCase {
+
+   
+    public void testConstructor(){
+        try {
+            new DomIndexable(new ServerBaseEntry());
+            fail("no service config");
+        } catch (NotIndexableException e) {
+            
+            
+        }
+        ServerBaseEntry e = new ServerBaseEntry();
+        e.setServiceConfig(new ProvidedServiceConfig());
+        try {
+            new DomIndexable(e);
+            fail("no extension profile");
+        } catch (IllegalStateException e1) {
+            
+            
+        } catch (NotIndexableException e2) {
+            
+            fail("unexp. exception");   
+        }
+        e.setServiceConfig(new ProvidedServiceStub());
+        try {
+            new DomIndexable(e);
+        } catch (NotIndexableException e1) {
+         fail("unexp. exception");   
+         
+        }
+    }
+    /*
+     * Test method for 'org.apache.lucene.gdata.search.analysis.DomIndexable.applyPath(String)'
+     */
+    public void testApplyPath() throws NotIndexableException, XPathExpressionException {
+        String content = "fooo bar<br>";
+        ServerBaseEntry entry = new ServerBaseEntry();
+        entry.setContent(new HtmlTextConstruct(content));
+        entry.setServiceConfig(new ProvidedServiceStub());
+        
+            Indexable ind = new DomIndexable(entry);
+            Node n = ind.applyPath("/entry/content");
+            assertNotNull(n);
+            assertEquals(content,n.getTextContent());
+            Node attr = ind.applyPath("/entry/content/@type");
+            assertNotNull(attr);
+            assertEquals("html",attr.getTextContent());
+            assertTrue(attr instanceof Attr);
+            
+    }
+    
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/analysis/TestGdataCategoryStrategy.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/analysis/TestGdataCategoryStrategy.java
new file mode 100755
index 0000000..4d06e2a
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/analysis/TestGdataCategoryStrategy.java
@@ -0,0 +1,106 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.search.analysis;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.document.Field;
+import org.apache.lucene.gdata.search.config.IndexSchemaField;
+import org.apache.lucene.gdata.search.index.GdataIndexerException;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class TestGdataCategoryStrategy extends TestCase {
+    private static final String FIELD = "foo";
+
+    private static final float BOOST = 2.0f;
+
+    GdataCategoryStrategy strategy;
+
+    private IndexSchemaField field;
+
+    protected void setUp() throws Exception {
+        this.field = new IndexSchemaField();
+        field.setName(FIELD);
+        //store and index will be ignored
+        field.setStore(Field.Store.NO);
+        field.setIndex(Field.Index.TOKENIZED);
+        field.setBoost(BOOST);
+        field.setPath("/path");
+        this.strategy = new GdataCategoryStrategy(field);
+    }
+
+    protected void tearDown() throws Exception {
+        super.tearDown();
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.search.analysis.PlainTextStrategy.processIndexable(Indexable<?
+     * extends Node, ? extends ServerBaseEntry>)'
+     */
+    public void testProcessIndexable() throws NotIndexableException {
+        IndexableStub stub = new IndexableStub();
+        stub.setReturnNull(true);
+        try {
+            this.strategy.processIndexable(stub);
+            fail("retun value is null must fail");
+        } catch (NotIndexableException e) {
+        }
+        assertNull(this.strategy.content);
+        try {
+            this.strategy.createLuceneField();
+            fail("content is not set");
+        } catch (GdataIndexerException e) {
+        }
+
+        String content = "fooBar";
+        stub.setReturnNull(false);
+        stub.setReturnValueTextContent(content);
+        this.strategy.processIndexable(stub);
+        assertNotNull(this.strategy.content);
+        assertNotNull(this.strategy.categoryScheme);
+        assertEquals(content+" "+content, this.strategy.content.trim());
+        assertEquals(content, this.strategy.categoryScheme);
+
+        Field[] fields = this.strategy.createLuceneField();
+        assertEquals(2, fields.length);
+        assertEquals(this.field.getName(), fields[0].name());
+        assertEquals(content+" "+content, fields[0].stringValue().trim());
+        assertEquals(this.strategy.categorySchemeField, fields[1].name());
+        assertEquals(content, fields[1].stringValue());
+        // this is also stored an untok.
+        assertFalse(fields[0].isStored());
+        assertTrue(fields[0].isTokenized());
+        // test for xpath exc.
+        this.field.setPath(null);
+        this.strategy = new GdataCategoryStrategy(field);
+        try {
+            this.strategy.processIndexable(stub);
+            fail("path is null must fail");
+        } catch (NotIndexableException e) {
+        }
+        try {
+            this.strategy.createLuceneField();
+            fail("content is not set");
+        } catch (GdataIndexerException e) {
+        }
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/analysis/TestGdataDateStrategy.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/analysis/TestGdataDateStrategy.java
new file mode 100755
index 0000000..13c4600
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/analysis/TestGdataDateStrategy.java
@@ -0,0 +1,116 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.search.analysis;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.document.Field;
+import org.apache.lucene.gdata.search.config.IndexSchemaField;
+import org.apache.lucene.gdata.search.index.GdataIndexerException;
+
+import com.google.gdata.data.DateTime;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class TestGdataDateStrategy extends TestCase {
+    private static final String FIELD = "foo";
+
+    private static final float BOOST = 2.0f;
+
+    ContentStrategy strategy;
+
+    private IndexSchemaField field;
+
+    protected void setUp() throws Exception {
+        this.field = new IndexSchemaField();
+        field.setName(FIELD);
+        field.setStore(Field.Store.NO);
+        field.setIndex(Field.Index.TOKENIZED);
+        field.setBoost(BOOST);
+        field.setPath("/path");
+        this.strategy = new GdataDateStrategy(field);
+    }
+
+    protected void tearDown() throws Exception {
+        super.tearDown();
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.search.analysis.PlainTextStrategy.processIndexable(Indexable<?
+     * extends Node, ? extends ServerBaseEntry>)'
+     */
+    public void testProcessIndexable() throws NotIndexableException {
+        IndexableStub stub = new IndexableStub();
+        stub.setReturnNull(true);
+        try {
+            this.strategy.processIndexable(stub);
+            fail("retun value is null must fail");
+        } catch (NotIndexableException e) {
+        }
+        assertNull(this.strategy.content);
+        try {
+            this.strategy.createLuceneField();
+            fail("content is not set");
+        } catch (GdataIndexerException e) {
+        }
+        // test with proper date 
+        String content = "2005-01-09T08:00:00Z";
+        String parsedConent = Long.toString(DateTime.parseDateTime(content)
+                .getValue());
+        stub.setReturnNull(false);
+        stub.setReturnValueTextContent(content);
+        this.strategy.processIndexable(stub);
+        assertNotNull(this.strategy.content);
+        assertEquals(parsedConent, this.strategy.content);
+
+        Field[] fields = this.strategy.createLuceneField();
+        assertEquals(1, fields.length);
+        assertEquals(this.field.getName(), fields[0].name());
+        assertEquals(parsedConent, fields[0].stringValue());
+        // timestamp is stored and untok.
+        assertTrue(fields[0].isStored());
+        assertFalse(fields[0].isTokenized());
+        
+        this.strategy = new GdataDateStrategy(this.field);
+        content = "2005-01-09T##08:00:00Z";
+        stub.setReturnValueTextContent(content);
+        try {
+            this.strategy.processIndexable(stub);
+            fail("unparsable date must fail");
+        } catch (NotIndexableException e) {
+        }
+        
+        
+        // test for xpath exc.
+        this.field.setPath(null);
+        this.strategy = new GdataDateStrategy(this.field);
+        try {
+            this.strategy.processIndexable(stub);
+            fail("path is null must fail");
+        } catch (NotIndexableException e) {
+        }
+        try {
+            this.strategy.createLuceneField();
+            fail("content is not set");
+        } catch (GdataIndexerException e) {
+        }
+
+    }
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/analysis/TestHTMLStrategy.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/analysis/TestHTMLStrategy.java
new file mode 100755
index 0000000..9b20936
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/analysis/TestHTMLStrategy.java
@@ -0,0 +1,76 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.search.analysis;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.document.Field;
+import org.apache.lucene.gdata.search.config.IndexSchemaField;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class TestHTMLStrategy extends TestCase {
+    private static final String FIELD = "foo";
+    private static final float BOOST = 2.0f;
+    ContentStrategy strategy;
+    private IndexSchemaField field;
+    protected void setUp() throws Exception {
+        this.field = new IndexSchemaField();
+        field.setName(FIELD);
+        field.setStore(Field.Store.YES);
+        field.setIndex(Field.Index.UN_TOKENIZED);
+        field.setBoost(BOOST);
+        field.setPath("/path");
+        this.strategy = new HTMLStrategy(field);
+    }
+
+    protected void tearDown() throws Exception {
+        super.tearDown();
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.search.analysis.PlainTextStrategy.processIndexable(Indexable<? extends Node, ? extends ServerBaseEntry>)'
+     */
+    public void testProcessIndexable() throws NotIndexableException {
+        IndexableStub stub = new IndexableStub();
+        stub.setReturnNull(true);
+        try{
+        this.strategy.processIndexable(stub);
+        fail("retun value is null must fail");
+        }catch (NotIndexableException e) {}
+        assertNull(this.strategy.content);
+        String content = "fooBar";
+        //just to make sure the filter is applied.
+        String htmlContent = "<b>"+content+"</b>";
+        stub.setReturnNull(false);
+        stub.setReturnValueTextContent(htmlContent);
+        this.strategy.processIndexable(stub);
+        assertNotNull(this.strategy.content);
+        assertEquals(content,this.strategy.content);
+        
+        
+        // test for xpath exc.
+        this.field.setPath(null);
+        try{
+            this.strategy.processIndexable(stub);
+            fail("path is null must fail");
+            }catch (NotIndexableException e) {}
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/analysis/TestKeywordStrategy.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/analysis/TestKeywordStrategy.java
new file mode 100755
index 0000000..bd9cc9a
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/analysis/TestKeywordStrategy.java
@@ -0,0 +1,105 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.search.analysis;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.document.Field;
+import org.apache.lucene.gdata.search.config.IndexSchemaField;
+import org.apache.lucene.gdata.search.index.GdataIndexerException;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class TestKeywordStrategy extends TestCase {
+    private static final String FIELD = "foo";
+
+    private static final float BOOST = 2.0f;
+
+    ContentStrategy strategy;
+
+    private IndexSchemaField field;
+
+    protected void setUp() throws Exception {
+        this.field = new IndexSchemaField();
+        field.setName(FIELD);
+        field.setStore(Field.Store.NO);
+        field.setIndex(Field.Index.TOKENIZED);
+        field.setBoost(BOOST);
+        field.setPath("/path");
+        
+        this.strategy = new KeywordStrategy(field);
+    }
+
+    protected void tearDown() throws Exception {
+        super.tearDown();
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.search.analysis.PlainTextStrategy.processIndexable(Indexable<?
+     * extends Node, ? extends ServerBaseEntry>)'
+     */
+    public void testProcessIndexable() throws NotIndexableException {
+        IndexableStub stub = new IndexableStub();
+        stub.setReturnNull(true);
+        try {
+            this.strategy.processIndexable(stub);
+            fail("retun value is null must fail");
+        } catch (NotIndexableException e) {
+        }
+        assertNull(this.strategy.content);
+        try {
+            this.strategy.createLuceneField();
+            fail("content is not set");
+        } catch (GdataIndexerException e) {
+        }
+
+        String content = "fooBar";
+        stub.setReturnNull(false);
+        stub.setReturnValueTextContent(content);
+        this.strategy.processIndexable(stub);
+        assertNotNull(this.strategy.content);
+        assertEquals(content, this.strategy.content);
+
+        Field[] fields = this.strategy.createLuceneField();
+        assertEquals(1, fields.length);
+        assertEquals(this.field.getName(), fields[0].name());
+        assertEquals(content, fields[0].stringValue());
+        // this is also stored an untok.
+        assertTrue(fields[0].isStored());
+        assertFalse(fields[0].isTokenized());
+        
+        
+        // test for xpath exc.
+        this.field.setPath(null);
+        this.strategy = new KeywordStrategy(field);
+        try {
+            this.strategy.processIndexable(stub);
+            fail("path is null must fail");
+        } catch (NotIndexableException e) {
+        }
+        try {
+            this.strategy.createLuceneField();
+            fail("content is not set");
+        } catch (GdataIndexerException e) {
+        }
+
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/analysis/TestMixedStrategy.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/analysis/TestMixedStrategy.java
new file mode 100755
index 0000000..edb9b62
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/analysis/TestMixedStrategy.java
@@ -0,0 +1,103 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.search.analysis;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.document.Field;
+import org.apache.lucene.gdata.search.config.IndexSchemaField;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class TestMixedStrategy extends TestCase {
+    private static final String FIELD = "foo";
+
+    private static final float BOOST = 2.0f;
+
+    MixedContentStrategy strategy;
+
+    private IndexSchemaField field;
+
+    protected void setUp() throws Exception {
+        this.field = new IndexSchemaField();
+        field.setName(FIELD);
+
+        field.setStore(Field.Store.YES);
+        field.setIndex(Field.Index.UN_TOKENIZED);
+        field.setBoost(BOOST);
+        field.setPath("/path");
+        field.setTypePath("/path");
+        this.strategy = new MixedContentStrategy(field);
+    }
+
+    protected void tearDown() throws Exception {
+        super.tearDown();
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.search.analysis.PlainTextStrategy.processIndexable(Indexable<?
+     * extends Node, ? extends ServerBaseEntry>)'
+     */
+    public void testProcessIndexable() throws NotIndexableException {
+        IndexableStub stub = new IndexableStub();
+        stub.setReturnNull(true);
+        try {
+            this.strategy.processIndexable(stub);
+            fail("retun value is null must fail");
+        } catch (NotIndexableException e) {
+        }
+        assertNull(this.strategy.content);
+        String content = "fooBar";
+        stub.setReturnNull(false);
+        stub.setReturnValueTextContent(content);
+        this.strategy.processIndexable(stub);
+        assertNotNull(this.strategy.strategy.content);
+        assertEquals(content, this.strategy.strategy.content);
+        assertEquals(this.strategy.strategy.getClass(), PlainTextStrategy.class);
+
+       
+
+        content = "html";
+        stub.setReturnNull(false);
+        stub.setReturnValueTextContent(content);
+        this.strategy.processIndexable(stub);
+        assertNotNull(this.strategy.strategy.content);
+        assertEquals(content, this.strategy.strategy.content);
+        assertEquals(this.strategy.strategy.getClass(), HTMLStrategy.class);
+
+        content = "xhtml";
+        stub.setReturnNull(false);
+        stub.setReturnValueTextContent(content);
+        this.strategy.processIndexable(stub);
+        assertNotNull(this.strategy.strategy.content);
+        assertEquals(content, this.strategy.strategy.content);
+        assertEquals(this.strategy.strategy.getClass(), XHtmlStrategy.class);
+
+        
+        // test for xpath exc.
+        this.field.setPath(null);
+        try {
+            this.strategy.processIndexable(stub);
+            fail("path is null must fail");
+        } catch (NotIndexableException e) {
+        }
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/analysis/TestPlainTextStrategy.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/analysis/TestPlainTextStrategy.java
new file mode 100755
index 0000000..08a497b
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/analysis/TestPlainTextStrategy.java
@@ -0,0 +1,74 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.search.analysis;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.document.Field;
+import org.apache.lucene.gdata.search.config.IndexSchemaField;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class TestPlainTextStrategy extends TestCase {
+    private static final String FIELD = "foo";
+    private static final float BOOST = 2.0f;
+    ContentStrategy strategy;
+    private IndexSchemaField field;
+    protected void setUp() throws Exception {
+        this.field = new IndexSchemaField();
+        field.setName(FIELD);
+        field.setStore(Field.Store.YES);
+        field.setIndex(Field.Index.UN_TOKENIZED);
+        field.setBoost(BOOST);
+        field.setPath("/path");
+        this.strategy = new PlainTextStrategy(field);
+    }
+
+    protected void tearDown() throws Exception {
+        super.tearDown();
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.search.analysis.PlainTextStrategy.processIndexable(Indexable<? extends Node, ? extends ServerBaseEntry>)'
+     */
+    public void testProcessIndexable() throws NotIndexableException {
+        IndexableStub stub = new IndexableStub();
+        stub.setReturnNull(true);
+        try{
+        this.strategy.processIndexable(stub);
+        fail("retun value is null must fail");
+        }catch (NotIndexableException e) {}
+        assertNull(this.strategy.content);
+        String content = "fooBar";
+        stub.setReturnNull(false);
+        stub.setReturnValueTextContent(content);
+        this.strategy.processIndexable(stub);
+        assertNotNull(this.strategy.content);
+        assertEquals(content,this.strategy.content);
+        
+        
+        // test for xpath exc.
+        this.field.setPath(null);
+        try{
+            this.strategy.processIndexable(stub);
+            fail("path is null must fail");
+            }catch (NotIndexableException e) {}
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/config/TestIndexSchema.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/config/TestIndexSchema.java
new file mode 100755
index 0000000..45113a9
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/config/TestIndexSchema.java
@@ -0,0 +1,159 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.search.config;
+
+import org.apache.lucene.analysis.PerFieldAnalyzerWrapper;
+import org.apache.lucene.analysis.StopAnalyzer;
+import org.apache.lucene.analysis.standard.StandardAnalyzer;
+import org.apache.lucene.gdata.search.config.IndexSchemaField.ContentType;
+import org.apache.lucene.gdata.search.index.IndexDocument;
+
+import junit.framework.TestCase;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class TestIndexSchema extends TestCase {
+    IndexSchema schema;
+
+    protected void setUp() throws Exception {
+        schema = new IndexSchema();
+    }
+
+    protected void tearDown() throws Exception {
+        super.tearDown();
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.search.config.IndexSchema.initialize()'
+     */
+    public void testInitialize() {
+        try {
+            schema.initialize();
+            fail("def search field is null");
+        } catch (RuntimeException e) {
+            // TODO: handle exception
+        }
+        schema.setDefaultSearchField("someField");
+        try {
+            schema.initialize();
+            fail("name is null");
+        } catch (RuntimeException e) {
+            // TODO: handle exception
+        }
+        schema.setName("someName");
+        try {
+            schema.initialize();
+            fail("indexLocation  is null");
+        } catch (RuntimeException e) {
+            // TODO: handle exception
+        }
+        schema.setIndexLocation("/loc/loc");
+        try {
+            schema.initialize();
+            fail("default search field is not set as a field");
+        } catch (RuntimeException e) {
+            // TODO: handle exception
+        }
+        IndexSchemaField f = new IndexSchemaField();
+        f.setName(schema.getDefaultSearchField());
+        f.setContentType(ContentType.TEXT);
+        schema.addSchemaField(f);
+        try {
+            schema.initialize();
+            fail("field check failed");
+        } catch (RuntimeException e) {
+            // TODO: handle exception
+        }
+        f.setPath("path");
+        schema.initialize();
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.search.config.IndexSchema.addSchemaField(IndexSchemaField)'
+     */
+    public void testAddSchemaField() {
+        schema.addSchemaField(null);
+        assertEquals(0, schema.getFields().size());
+
+        IndexSchemaField f = new IndexSchemaField();
+        f.setName(IndexDocument.FIELD_ENTRY_ID);
+        schema.addSchemaField(f);
+        assertEquals(0, schema.getFields().size());
+
+        f.setName(IndexDocument.FIELD_FEED_ID);
+        schema.addSchemaField(f);
+        assertEquals(0, schema.getFields().size());
+
+        f.setName("some");
+        schema.addSchemaField(f);
+        assertEquals(1, schema.getFields().size());
+        assertEquals(StandardAnalyzer.class, schema.getServiceAnalyzer()
+                .getClass());
+        assertEquals(StandardAnalyzer.class, schema.getSchemaAnalyzer()
+                .getClass());
+        f.setName("someOther");
+        f.setAnalyzerClass(StopAnalyzer.class);
+        schema.addSchemaField(f);
+        assertEquals(2, schema.getFields().size());
+        assertEquals(PerFieldAnalyzerWrapper.class, schema.getSchemaAnalyzer()
+                .getClass());
+        schema.addSchemaField(f);
+        assertEquals(3, schema.getFields().size());
+
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.search.config.IndexSchema.getSearchableFieldNames()'
+     */
+    public void testGetSearchableFieldNames() {
+        IndexSchemaField f = new IndexSchemaField();
+        f.setName("some");
+        schema.addSchemaField(f);
+        assertEquals(1, schema.getSearchableFieldNames().size());
+        assertTrue(schema.getSearchableFieldNames().contains("some"));
+    }
+
+    public void testEquals() {
+        assertFalse(schema.equals(null));
+        assertFalse(schema.equals(new String()));
+        assertTrue(schema.equals(schema));
+        assertFalse(schema.equals(new IndexSchema()));
+        IndexSchema s1 = new IndexSchema();
+        s1.setName("someName");
+        assertFalse(schema.equals(s1));
+        schema.setName(s1.getName());
+        assertTrue(schema.equals(s1));
+    }
+
+    public void testHashCode() {
+        assertEquals(schema.hashCode(), schema.hashCode());
+        assertNotNull(schema.hashCode());
+        IndexSchema s1 = new IndexSchema();
+        s1.setName("someName");
+        assertTrue(schema.hashCode() != s1.hashCode());
+        schema.setName(s1.getName());
+        assertTrue(schema.hashCode() == s1.hashCode());
+    }
+
+    public void testToSTringNoNullPEx() {
+        assertNotNull(schema.toString());
+    }
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/config/TestIndexSchemaField.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/config/TestIndexSchemaField.java
new file mode 100755
index 0000000..c4f4c5e
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/config/TestIndexSchemaField.java
@@ -0,0 +1,154 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.search.config;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.document.Field;
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.search.analysis.ContentStrategy;
+import org.apache.lucene.gdata.search.analysis.Indexable;
+import org.apache.lucene.gdata.search.analysis.NotIndexableException;
+import org.apache.lucene.gdata.search.analysis.PlainTextStrategy;
+import org.apache.lucene.gdata.search.config.IndexSchemaField.ContentType;
+import org.w3c.dom.Node;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class TestIndexSchemaField extends TestCase {
+
+    protected void setUp() throws Exception {
+        super.setUp();
+    }
+
+    protected void tearDown() throws Exception {
+        super.tearDown();
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.search.config.IndexSchemaField.checkRequieredValues()'
+     */
+    public void testCheckRequieredValues() {
+        IndexSchemaField f = new IndexSchemaField();
+        assertFalse(f.checkRequieredValues());
+        f.setName("someName");
+        assertFalse(f.checkRequieredValues());
+        f.setPath("somePath");
+        assertFalse(f.checkRequieredValues());
+        f.setType("text");
+        assertTrue(f.checkRequieredValues());
+        f.setType("mixed");
+        assertFalse(f.checkRequieredValues());
+        f.setTypePath("sometypepath");
+        assertTrue(f.checkRequieredValues());
+        
+        f.setType("custom");
+        assertFalse(f.checkRequieredValues());
+        f.setFieldClass(TestContentStragtegy.class);
+        assertTrue(f.checkRequieredValues());
+    }
+    public void testSetFieldType(){
+        IndexSchemaField f = new IndexSchemaField();
+        f.setFieldClass(TestContentStragtegy.class);
+        try{
+            f.setFieldClass(PlainTextStrategy.class);
+            fail("no pub const.");
+        }catch (RuntimeException e) {
+            
+        }
+        try{
+            f.setFieldClass(null);
+            fail("is null");
+        }catch (RuntimeException e) {
+            
+        }
+        
+    }
+    /*
+     * Test method for 'org.apache.lucene.gdata.search.config.IndexSchemaField.setAnalyzerClass(Class<? extends Analyzer>)'
+     */
+    public void testSetType() {
+        IndexSchemaField f = new IndexSchemaField();
+        f.setType("notatype");
+        assertNull(f.getContentType());
+        f.setType("custom");
+        assertEquals(ContentType.CUSTOM,f.getContentType());
+        f.setType("text");
+        assertEquals(ContentType.TEXT,f.getContentType());
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.search.config.IndexSchemaField.setStoreByName(String)'
+     */
+    public void testSetStoreByName() {
+        IndexSchemaField f = new IndexSchemaField();
+        f.setStoreByName("someother");
+        assertEquals(Field.Store.NO,f.getStore());
+        f.setStoreByName("COMPRESS");
+        assertEquals(Field.Store.COMPRESS,f.getStore());
+        f.setStoreByName("YeS");
+        assertEquals(Field.Store.YES,f.getStore());
+        f.setStoreByName("No");
+        assertEquals(Field.Store.NO,f.getStore());
+        
+        
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.search.config.IndexSchemaField.setIndexByName(String)'
+     */
+    public void testSetIndexByName() {
+        IndexSchemaField f = new IndexSchemaField();
+        f.setIndexByName("UN_done");
+        assertEquals(Field.Index.TOKENIZED,f.getIndex());
+        f.setIndexByName("UN_tokenized");
+        assertEquals(Field.Index.UN_TOKENIZED,f.getIndex());
+        f.setIndexByName("tokenized");
+        assertEquals(Field.Index.TOKENIZED,f.getIndex());
+        f.setIndexByName("no");
+        assertEquals(Field.Index.NO,f.getIndex());
+        f.setIndexByName("no_norms");
+        assertEquals(Field.Index.NO_NORMS,f.getIndex());
+        
+        
+    }
+    
+    public void testSetboost(){
+        IndexSchemaField f = new IndexSchemaField();
+        f.setBoost(-0.1f);
+        assertEquals(1.0f,f.getBoost());
+        f.setBoost(2.50f);
+        assertEquals(2.50f,f.getBoost());
+    }
+    
+    public void testToSTringNoNullPEx(){
+        assertNotNull(new IndexSchemaField().toString());
+    }
+    static class TestContentStragtegy extends ContentStrategy{
+        
+        public TestContentStragtegy(IndexSchemaField fieldConfiguration) {
+            super(fieldConfiguration);
+            // TODO Auto-generated constructor stub
+        }
+
+        @Override
+        public void processIndexable(Indexable<? extends Node, ? extends ServerBaseEntry> indexable) throws NotIndexableException {
+        }
+        
+    }
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/index/FutureStub.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/index/FutureStub.java
new file mode 100755
index 0000000..cf8fecd
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/index/FutureStub.java
@@ -0,0 +1,104 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.search.index;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class FutureStub<T> implements Future<T>{
+    T object;
+    CountDownLatch latch;
+    boolean wait;
+    
+    /**
+     * 
+     */
+    public FutureStub(T returnObject, CountDownLatch latch) {
+        this(returnObject,latch,false);
+    }
+    /**
+     * 
+     */
+    public FutureStub(T returnObject, CountDownLatch latch, boolean wait) {
+        super();
+        this.object = returnObject;
+        this.latch =latch;
+        this.wait =wait;
+    }
+    public FutureStub(T returnObject) {
+        this(returnObject,null);
+    }
+
+    /**
+     * @see java.util.concurrent.Future#cancel(boolean)
+     */
+    public boolean cancel(boolean arg0) {
+
+        return false;
+    }
+
+    /**
+     * @see java.util.concurrent.Future#isCancelled()
+     */
+    public boolean isCancelled() {
+
+        return false;
+    }
+
+    /**
+     * @see java.util.concurrent.Future#isDone()
+     */
+    public boolean isDone() {
+
+        return true;
+    }
+
+    /**
+     * @see java.util.concurrent.Future#get()
+     */
+    public T get() throws InterruptedException, ExecutionException {
+        doLatch(); 
+        return this.object;
+    }
+
+    /**
+     * @see java.util.concurrent.Future#get(long, java.util.concurrent.TimeUnit)
+     */
+    public T get(long arg0, TimeUnit arg1) throws InterruptedException,
+            ExecutionException, TimeoutException {
+       doLatch();
+        return this.object;
+    }
+    
+    private void doLatch() throws InterruptedException{
+        if(latch != null){
+            if(!wait)
+            this.latch.countDown();
+            else
+                this.latch.await(5000,TimeUnit.MILLISECONDS);
+        }
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/index/IndexDocumentStub.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/index/IndexDocumentStub.java
new file mode 100755
index 0000000..c93dd56
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/index/IndexDocumentStub.java
@@ -0,0 +1,136 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.search.index;
+
+import java.util.concurrent.CountDownLatch;
+
+import org.apache.lucene.document.Document;
+import org.apache.lucene.index.Term;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class IndexDocumentStub implements IndexDocument {
+    Document document;
+    Term deleteTerm;
+    IndexAction action;
+    CountDownLatch latch;
+    boolean commitAfter;
+    boolean optimizeAfter;
+    /**
+     * 
+     */
+    public IndexDocumentStub(Document doc, Term deleteTerm, IndexAction action, CountDownLatch latch) {
+        this.document = doc;
+        this.deleteTerm = deleteTerm;
+        this.action = action;
+        this.latch = latch;
+    }
+    public IndexDocumentStub(Document doc, Term deleteTerm, IndexAction action) {
+        this(doc,deleteTerm,action,null);
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.search.index.IndexDocument#isUpdate()
+     */
+    public boolean isUpdate() {
+
+        return isAction(IndexAction.UPDATE);
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.search.index.IndexDocument#isDelete()
+     */
+    public boolean isDelete() {
+
+        return isAction(IndexAction.DELETE);
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.search.index.IndexDocument#isInsert()
+     */
+    public boolean isInsert() {
+
+     return isAction(IndexAction.INSERT);
+    }
+    private boolean isAction(IndexAction currentAction){
+        return this.action == currentAction;
+    }
+    /**
+     * @see org.apache.lucene.gdata.search.index.IndexDocument#getWriteable()
+     */
+    public Document getWriteable() {
+        if(latch != null)
+        latch.countDown();        
+        return this.document;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.search.index.IndexDocument#getDeletealbe()
+     */
+    public Term getDeletealbe() {
+        if(latch != null)
+            latch.countDown();
+        return this.deleteTerm;
+    }
+    public boolean commitAfter() {
+        
+        return this.commitAfter;
+    }
+    public boolean optimizeAfter() {
+        
+        return this.optimizeAfter;
+    }
+    /**
+     * @param commitAfter The commitAfter to set.
+     */
+    public void setCommitAfter(boolean commitAfter) {
+        this.commitAfter = commitAfter;
+    }
+    /**
+     * @param optimizeAfter The optimizeAfter to set.
+     */
+    public void setOptimizeAfter(boolean optimizeAfter) {
+        this.optimizeAfter = optimizeAfter;
+    }
+    
+    /**
+     * @see java.lang.Object#equals(java.lang.Object)
+     */
+    @Override
+    public final boolean equals(Object obj) {
+        if(obj == null)
+            return false;
+        if(obj instanceof IndexDocumentStub){
+            IndexDocumentStub other = (IndexDocumentStub)obj;
+            return this.document.getField(IndexDocument.FIELD_ENTRY_ID).stringValue().equals(other.document.getField(IndexDocument.FIELD_ENTRY_ID).stringValue());
+              
+        }
+        return false; 
+    }
+
+    /**
+     * @see java.lang.Object#hashCode()
+     */
+    @Override
+    public final int hashCode() {
+        return this.document.getField(IndexDocument.FIELD_ENTRY_ID).stringValue().hashCode();
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/index/IndexEventListenerStub.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/index/IndexEventListenerStub.java
new file mode 100755
index 0000000..5b16bfe
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/index/IndexEventListenerStub.java
@@ -0,0 +1,47 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.search.index;
+
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class IndexEventListenerStub implements IndexEventListener {
+    AtomicInteger count;
+    /**
+     * 
+     */
+    public IndexEventListenerStub() {
+        super();
+       this.count = new AtomicInteger(0);
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.search.index.IndexEventListener#commitCallBack(java.lang.String)
+     */
+    public void commitCallBack(String service) {
+        this.count.incrementAndGet();
+    }
+    
+    public int getCalledCount(){
+        return this.count.get();
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/index/TestGdataIndexDocument.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/index/TestGdataIndexDocument.java
new file mode 100755
index 0000000..6182a50
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/index/TestGdataIndexDocument.java
@@ -0,0 +1,123 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.search.index;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.document.Document;
+import org.apache.lucene.gdata.search.analysis.ContentStrategy;
+import org.apache.lucene.gdata.search.config.IndexSchemaField;
+import org.apache.lucene.gdata.search.config.IndexSchemaField.ContentType;
+import org.apache.lucene.index.Term;
+
+public class TestGdataIndexDocument extends TestCase {
+    static String ENTRYID = "someEId";
+    static String FEEDID = "someFId";
+    GDataIndexDocument delDocument;
+    GDataIndexDocument updDocument;
+    GDataIndexDocument insDocument;
+    protected void setUp() throws Exception {
+        this.delDocument = new GDataIndexDocument(IndexAction.DELETE,ENTRYID,FEEDID,false,true);
+        this.insDocument = new GDataIndexDocument(IndexAction.INSERT,ENTRYID,FEEDID,true,false);
+        this.updDocument = new GDataIndexDocument(IndexAction.UPDATE,ENTRYID,FEEDID,false,true);
+    }
+
+    protected void tearDown() throws Exception {
+        super.tearDown();
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.search.index.GDataIndexDocument.addField(ContentStrategy)'
+     */
+    public void testAddField() {
+        assertEquals(0,this.delDocument.fields.size());    
+        this.delDocument.addField(null);
+        assertEquals(0,this.delDocument.fields.size());
+        IndexSchemaField ifield = new IndexSchemaField();
+        ifield.setContentType(ContentType.TEXT);
+        this.delDocument.addField(ContentStrategy.getFieldStrategy(ifield));
+        assertEquals(1,this.delDocument.fields.size());
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.search.index.GDataIndexDocument.getWriteable()'
+     */
+    public void testGetWriteable() {
+        assertNotNull(this.insDocument.getWriteable());
+        Document doc = this.insDocument.getWriteable();
+        assertEquals(2,doc.getFields().size());
+        assertEquals(ENTRYID,doc.getField(GDataIndexDocument.FIELD_ENTRY_ID).stringValue());
+        assertEquals(FEEDID,doc.getField(GDataIndexDocument.FIELD_FEED_ID).stringValue());
+        
+        
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.search.index.GDataIndexDocument.getDeletealbe()'
+     */
+    public void testGetDeletealbe() {
+        assertNotNull(this.insDocument.getDeletealbe());
+        Term t = this.insDocument.getDeletealbe();
+        assertEquals(IndexDocument.FIELD_ENTRY_ID,t.field());
+        assertEquals(ENTRYID,t.text());
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.search.index.GDataIndexDocument.isUpdate()'
+     */
+    public void testIsUpdate() {
+        assertFalse(this.insDocument.isUpdate());
+        assertTrue(this.updDocument.isUpdate());
+        assertFalse(this.delDocument.isUpdate());
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.search.index.GDataIndexDocument.isDelete()'
+     */
+    public void testIsDelete() {
+        assertFalse(this.insDocument.isDelete());
+        assertFalse(this.updDocument.isDelete());
+        assertTrue(this.delDocument.isDelete());
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.search.index.GDataIndexDocument.isInsert()'
+     */
+    public void testIsInsert() {
+        assertTrue(this.insDocument.isInsert());
+        assertFalse(this.updDocument.isInsert());
+        assertFalse(this.delDocument.isInsert());
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.search.index.GDataIndexDocument.commitAfter()'
+     */
+    public void testCommitAfter() {
+        assertTrue(this.insDocument.commitAfter());
+        assertFalse(this.updDocument.commitAfter());
+        assertFalse(this.delDocument.commitAfter());
+    }
+    
+    /*
+     * Test method for 'org.apache.lucene.gdata.search.index.GDataIndexDocument.optimizeAfter()'
+     */
+    public void testOptimizeAfter() {
+        assertFalse(this.insDocument.optimizeAfter());
+        assertTrue(this.updDocument.optimizeAfter());
+        assertTrue(this.delDocument.optimizeAfter());
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/index/TestGdataIndexWriter.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/index/TestGdataIndexWriter.java
new file mode 100755
index 0000000..25a256d
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/index/TestGdataIndexWriter.java
@@ -0,0 +1,81 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.search.index;
+
+import java.io.IOException;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.analysis.PerFieldAnalyzerWrapper;
+import org.apache.lucene.analysis.StopAnalyzer;
+import org.apache.lucene.analysis.standard.StandardAnalyzer;
+import org.apache.lucene.gdata.search.config.IndexSchema;
+import org.apache.lucene.gdata.search.config.IndexSchemaField;
+import org.apache.lucene.store.RAMDirectory;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class TestGdataIndexWriter extends TestCase {
+    IndexSchema schemaNoPerFielAnalyzer;
+    IndexSchema schemaPerFielAnalyzer;
+    long VALUE_GT_DEFAULT_LONG = 15000;
+    int VALUE_GT_DEFAULT_INT = 10000;
+    
+    protected void setUp() throws Exception {
+        this.schemaNoPerFielAnalyzer = new IndexSchema();
+        this.schemaPerFielAnalyzer = new IndexSchema();
+        IndexSchemaField field = new IndexSchemaField();
+        field.setName("someField");
+        field.setAnalyzerClass(StopAnalyzer.class);
+        this.schemaPerFielAnalyzer.addSchemaField(field);
+        this.schemaPerFielAnalyzer.setCommitLockTimeout(VALUE_GT_DEFAULT_LONG);
+        this.schemaPerFielAnalyzer.setMaxBufferedDocs(VALUE_GT_DEFAULT_INT);
+        this.schemaPerFielAnalyzer.setMaxFieldLength(VALUE_GT_DEFAULT_INT);
+        this.schemaPerFielAnalyzer.setMaxMergeDocs(VALUE_GT_DEFAULT_INT);
+        this.schemaPerFielAnalyzer.setMergeFactor(VALUE_GT_DEFAULT_INT);
+        this.schemaPerFielAnalyzer.setWriteLockTimeout(VALUE_GT_DEFAULT_LONG);
+        this.schemaPerFielAnalyzer.setUseCompoundFile(true);
+    }
+
+
+    /**
+     * Test method for 'org.apache.lucene.gdata.search.index.GDataIndexWriter.GDataIndexWriter(Directory, boolean, IndexSchema)'
+     * @throws IOException 
+     */
+    public void testGDataIndexWriter() throws IOException {
+        try{
+        new GDataIndexWriter(new RAMDirectory(),true,null);
+        fail("no index schema");
+        }catch (IllegalArgumentException e) {}
+        GDataIndexWriter writer = new GDataIndexWriter(new RAMDirectory(),true,this.schemaNoPerFielAnalyzer);
+        assertTrue(writer.getAnalyzer().getClass() == StandardAnalyzer.class);
+        
+        writer = new GDataIndexWriter(new RAMDirectory(),true,this.schemaPerFielAnalyzer);
+        assertTrue(writer.getAnalyzer().getClass() == PerFieldAnalyzerWrapper.class);
+        //TODO fix this - index writer has no commitlocktimeout setter anymore (lockless commits)
+//        assertEquals(VALUE_GT_DEFAULT_LONG,writer.getCommitLockTimeout());
+        assertEquals(VALUE_GT_DEFAULT_LONG,writer.getWriteLockTimeout());
+        assertEquals(VALUE_GT_DEFAULT_INT,writer.getMaxBufferedDocs());
+        assertEquals(VALUE_GT_DEFAULT_INT,writer.getMaxMergeDocs());
+        assertEquals(VALUE_GT_DEFAULT_INT,writer.getMaxFieldLength());
+        assertEquals(VALUE_GT_DEFAULT_INT,writer.getMergeFactor());
+        assertTrue(writer.getUseCompoundFile());
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/index/TestGdataIndexer.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/index/TestGdataIndexer.java
new file mode 100755
index 0000000..87e16b7
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/index/TestGdataIndexer.java
@@ -0,0 +1,577 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.search.index;
+
+import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.analysis.standard.StandardAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.gdata.search.config.IndexSchema;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.Hits;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.RAMDirectory;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class TestGdataIndexer extends TestCase {
+    private GDataIndexer indexer;
+
+    private Directory dir;
+
+    private static IndexSchema config;
+
+    private static String FIELD_ID = IndexDocument.FIELD_ENTRY_ID;
+
+    static {
+        config = new IndexSchema();
+        config.setName("testService");
+        config.setCommitLockTimeout(-1);
+        config.setServiceAnalyzer(new StandardAnalyzer());
+        config.setMaxBufferedDocs(-1);
+        config.setMaxFieldLength(-1);
+        config.setMaxMergeDocs(-1);
+        config.setWriteLockTimeout(-1);
+        config.setMergeFactor(-1);
+    }
+
+    /**
+     * @see junit.framework.TestCase#setUp()
+     */
+    @Override
+    protected void setUp() throws Exception {
+        this.dir = new RAMDirectory();
+        this.indexer = GDataIndexer.createGdataIndexer(config, this.dir, true);
+        super.setUp();
+    }
+
+    /**
+     * @see junit.framework.TestCase#tearDown()
+     */
+    @Override
+    protected void tearDown() throws Exception {
+        this.indexer.destroy();
+    }
+    public void testStaticFactoryMethodes() throws IOException{
+        GDataIndexer i =GDataIndexer.createGdataIndexer(config, new RAMDirectory(), true);
+        assertNotNull(i);
+        assertEquals(IndexTask.class,i.indexTask.getClass());
+        
+        i =GDataIndexer.createTimedGdataIndexer(config, new RAMDirectory(), true,60);
+        assertNotNull(i);
+        assertEquals(TimedIndexTask.class,i.indexTask.getClass());
+        assertEquals(60,((TimedIndexTask)i.indexTask).getIdleTime());
+        
+        i.destroy();
+    }
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.search.index.GDataIndexer.GDataIndexer(IndexServiceConfiguration,
+     * Directory, boolean)'
+     */
+    public void testGDataIndexer() throws InterruptedException, IOException {
+        try {
+            new GDataIndexer(null, dir, true);
+            fail("config is null");
+        } catch (IllegalArgumentException e) {
+            //
+        }
+
+        try {
+            new GDataIndexer(config, null, true);
+            fail("dir is null");
+        } catch (IllegalArgumentException e) {
+            //
+        }
+        
+        GDataIndexer in = new GDataIndexer(config,new RAMDirectory(),true);
+        in.setIndexTask(null);
+        in.init();
+        assertNotNull(in.indexTask);
+        assertEquals(IndexTask.class,in.indexTask.getClass());
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.search.index.GDataIndexer.addIndexableDocumentTask(Future<IndexDocument>)'
+     */
+    public void testAddIndexableDocumentTask() throws InterruptedException,
+            IOException {
+        String id = "myID";
+        Field f = new Field(FIELD_ID, id, Field.Store.YES,
+                Field.Index.UN_TOKENIZED);
+        Document doc = new Document();
+        doc.add(f);
+        Term delTerm = new Term(FIELD_ID, id);
+        /*
+         * Latch will be decremented in FutureStub#get() and
+         * IndexDocumentStub#getIndexable
+         */
+        CountDownLatch l = new CountDownLatch(2);
+        IndexDocument iDoc = new IndexDocumentStub(doc, delTerm,
+                IndexAction.INSERT, l);
+        Future<IndexDocument> future = new FutureStub<IndexDocument>(iDoc, l);
+
+        this.indexer.addIndexableDocumentTask(future);
+        // wait for the latch do decrement
+        l.await(5000, TimeUnit.MILLISECONDS);
+
+        this.indexer.commit(false);
+        IndexSearcher s = new IndexSearcher(this.dir);
+        Hits h = s.search(new TermQuery(delTerm));
+        assertEquals(1, h.length());
+        s.close();
+        // test for update
+        /*
+         * Latch will be decremented in FutureStub#get() and
+         * IndexDocumentStub#getIndexable
+         */
+        l = new CountDownLatch(2);
+        iDoc = new IndexDocumentStub(doc, delTerm, IndexAction.UPDATE, l);
+        future = new FutureStub<IndexDocument>(iDoc, l);
+        this.indexer.addIndexableDocumentTask(future);
+        l.await(5000, TimeUnit.MILLISECONDS);
+        this.indexer.commit(false);
+        s = new IndexSearcher(this.dir);
+        h = s.search(new TermQuery(delTerm));
+        assertEquals(1, h.length());
+        s.close();
+
+        // test for delete
+        /*
+         * Latch will be decremented in FutureStub#get()
+         */
+        l = new CountDownLatch(1);
+        iDoc = new IndexDocumentStub(doc, delTerm, IndexAction.DELETE, l);
+        future = new FutureStub<IndexDocument>(iDoc, l);
+
+        this.indexer.addIndexableDocumentTask(future);
+        /*
+         * wait for the indexer task to add the deleted
+         */
+        while (this.indexer.docsDeleted.get() == 0)
+            l.await(5000, TimeUnit.MILLISECONDS);
+
+        this.indexer.commit(false);
+        s = new IndexSearcher(this.dir);
+        h = s.search(new TermQuery(delTerm));
+        assertEquals(0, h.length());
+        s.close();
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.search.index.GDataIndexer.addDocument(IndexDocument)'
+     */
+public void testAddDocument() throws IOException {
+        String id = "myID";
+        Field f = new Field(FIELD_ID, id, Field.Store.YES,
+                Field.Index.UN_TOKENIZED);
+        Document doc = new Document();
+        doc.add(f);
+        Term delTerm =  new Term(FIELD_ID, id);
+        IndexDocument iDoc = new IndexDocumentStub(doc,delTerm,
+                IndexAction.INSERT);
+        
+        this.indexer.addDocument(iDoc);
+        assertEquals(1,this.indexer.docsAdded.get());
+        assertEquals(0,this.indexer.docsDeleted.get());
+        assertEquals(0,this.indexer.docsUpdated.get());
+        this.indexer.addDocument(iDoc);
+        this.indexer.commit(false);
+        
+        
+        IndexSearcher s = new IndexSearcher(this.dir);
+        Hits h = s.search(new TermQuery(delTerm));
+        assertEquals(1, h.length());
+        s.close();
+        
+        iDoc = new IndexDocumentStub(doc,delTerm,
+                IndexAction.UPDATE);
+        try{
+            this.indexer.addDocument(iDoc);
+            fail("document has not insert action ");
+        }catch (GdataIndexerException e) {
+            
+        }
+        
+    }
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.search.index.GDataIndexer.updateDocument(IndexDocument)'
+     */
+    public void testUpdateDocument() throws IOException {
+        
+        String id = "myID";
+        Field f = new Field(FIELD_ID, id, Field.Store.YES,
+                Field.Index.UN_TOKENIZED);
+        Document doc = new Document();
+        doc.add(f);
+        Term delTerm =  new Term(FIELD_ID, id);
+        IndexDocument iDoc = new IndexDocumentStub(doc,delTerm,
+                IndexAction.INSERT);
+        /*
+         * write doc to index
+         */
+        this.indexer.writer.addDocument(doc);
+        this.indexer.closeWriter();
+        IndexSearcher s = new IndexSearcher(this.dir);
+        Hits h = s.search(new TermQuery(delTerm));
+        assertEquals(1, h.length());
+        s.close();
+        String testFieldName = "someTestFieldupdate";
+        doc.add(new Field(testFieldName,"someText",Field.Store.YES,Field.Index.TOKENIZED));
+        iDoc = new IndexDocumentStub(doc,delTerm,
+                IndexAction.UPDATE);
+        /*
+         * updateDoc via indexer 
+         */
+        this.indexer.updateDocument(iDoc);
+        assertEquals(0,this.indexer.docsAdded.get());
+        assertEquals(0,this.indexer.docsDeleted.get());
+        assertEquals(1,this.indexer.docsUpdated.get());
+        
+        this.indexer.commit(false);
+        
+        
+        s = new IndexSearcher(this.dir);
+        h = s.search(new TermQuery(delTerm));
+        assertEquals(1, h.length());
+        assertNotNull(h.doc(0).getField(testFieldName));
+        s.close();
+        
+        iDoc = new IndexDocumentStub(doc,delTerm,
+                IndexAction.DELETE);
+        try{
+            this.indexer.updateDocument(iDoc);
+            fail("document has not update action ");
+        }catch (GdataIndexerException e) {
+            
+        }
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.search.index.GDataIndexer.deleteDocument(IndexDocument)'
+     */
+    public void testDeleteDocument() throws IOException {
+        String id = "myID";
+        Field f = new Field(FIELD_ID, id, Field.Store.YES,
+                Field.Index.UN_TOKENIZED);
+        Document doc = new Document();
+        doc.add(f);
+        Term delTerm =  new Term(FIELD_ID, id);
+        IndexDocument iDoc = new IndexDocumentStub(doc,delTerm,
+                IndexAction.INSERT);
+        /*
+         * write doc to index
+         */
+        this.indexer.writer.addDocument(doc);
+       
+        this.indexer.closeWriter();
+        IndexSearcher s = new IndexSearcher(this.dir);
+        Hits h = s.search(new TermQuery(delTerm));
+        assertEquals(1, h.length());
+        s.close();
+        
+        /*
+         * del doc via indexer
+         */
+        iDoc = new IndexDocumentStub(doc,delTerm,
+                IndexAction.DELETE);
+        this.indexer.deleteDocument(iDoc);
+        assertEquals(0,this.indexer.docsAdded.get());
+        assertEquals(1,this.indexer.docsDeleted.get());
+        assertEquals(0,this.indexer.docsUpdated.get());
+        this.indexer.commit(false);
+        s = new IndexSearcher(this.dir);
+        h = s.search(new TermQuery(delTerm));
+        assertEquals(0, h.length());
+        s.close();
+        
+        /*
+         * test insert / del without optimize
+         */ 
+        iDoc = new IndexDocumentStub(doc,delTerm,
+                 IndexAction.INSERT);
+        this.indexer.addDocument(iDoc);
+        iDoc = new IndexDocumentStub(doc,delTerm,
+                IndexAction.DELETE);
+        this.indexer.deleteDocument(iDoc);
+        this.indexer.commit(false);
+        s = new IndexSearcher(this.dir);
+        h = s.search(new TermQuery(delTerm));
+        assertEquals(0, h.length());
+        s.close();
+        
+        
+        
+        /*
+         * test insert / del / update without optimize
+         */ 
+        iDoc = new IndexDocumentStub(doc,delTerm,
+                 IndexAction.INSERT);
+        this.indexer.addDocument(iDoc);
+        iDoc = new IndexDocumentStub(doc,delTerm,
+                IndexAction.DELETE);
+        this.indexer.deleteDocument(iDoc);
+        iDoc = new IndexDocumentStub(doc,delTerm,
+                IndexAction.INSERT);
+       this.indexer.addDocument(iDoc);
+        this.indexer.commit(false);
+        s = new IndexSearcher(this.dir);
+        h = s.search(new TermQuery(delTerm));
+        assertEquals(1, h.length());
+        s.close();
+        
+        
+        
+        
+        /*
+         * test insert / update / del without optimize
+         */
+        iDoc = new IndexDocumentStub(doc,delTerm,
+                IndexAction.INSERT);
+        this.indexer.addDocument(iDoc);
+        iDoc = new IndexDocumentStub(doc,delTerm,
+                IndexAction.UPDATE);
+        this.indexer.updateDocument(iDoc);
+        iDoc = new IndexDocumentStub(doc,delTerm,
+                IndexAction.DELETE);
+        this.indexer.deleteDocument(iDoc);
+        this.indexer.commit(false);
+        s = new IndexSearcher(this.dir);
+        h = s.search(new TermQuery(delTerm));
+        assertEquals(0, h.length());
+        s.close();
+        
+        
+        
+        iDoc = new IndexDocumentStub(doc,delTerm,
+                IndexAction.UPDATE);
+        try{
+            this.indexer.deleteDocument(iDoc);
+            fail("document has not delete action ");
+        }catch (GdataIndexerException e) {
+            
+        }
+        
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.search.index.GDataIndexer.commit(boolean)'
+     */
+    public void testCommit() throws IOException {
+        String id = "myID";
+        Field f = new Field(FIELD_ID, id, Field.Store.YES,
+                Field.Index.UN_TOKENIZED);
+        Document doc = new Document();
+        doc.add(f);
+        Term delTerm =  new Term(FIELD_ID, id);
+        IndexDocument iDoc = new IndexDocumentStub(doc,delTerm,
+                IndexAction.INSERT);
+        this.indexer.addDocument(iDoc);
+         iDoc = new IndexDocumentStub(doc,delTerm,
+                IndexAction.UPDATE);
+        this.indexer.updateDocument(iDoc);
+        this.indexer.updateDocument(iDoc);
+        iDoc = new IndexDocumentStub(doc,delTerm,
+                IndexAction.DELETE);
+        this.indexer.deleteDocument(iDoc);
+        IndexEventListenerStub evListener = new IndexEventListenerStub();
+        this.indexer.registerIndexEventListener(evListener);
+        assertEquals(1,this.indexer.docsAdded.get());
+        assertEquals(1,this.indexer.docsDeleted.get());
+        assertEquals(2,this.indexer.docsUpdated.get());
+        assertEquals(0,evListener.getCalledCount());
+        this.indexer.commit(true);
+        this.indexer.commit(false);
+        assertEquals(1,evListener.getCalledCount());
+        assertEquals(0,this.indexer.docsAdded.get());
+        assertEquals(0,this.indexer.docsDeleted.get());
+        assertEquals(0,this.indexer.docsUpdated.get());
+        IndexSearcher s = new IndexSearcher(this.dir);
+        Hits h = s.search(new TermQuery(delTerm));
+        assertEquals(0, h.length());
+        s.close();
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.search.index.GDataIndexer.registerIndexEventListener(IndexEventListener)'
+     */
+    public void testRegisterIndexEventListener() {
+        IndexEventListenerStub evListener = new IndexEventListenerStub();
+        this.indexer.registerIndexEventListener(evListener);
+        this.indexer.registerIndexEventListener(evListener);
+        assertEquals(0,evListener.getCalledCount());
+        this.indexer.notifyCommitListeners("someId");
+        this.indexer.notifyCommitListeners("someId");
+        assertEquals(2,evListener.getCalledCount());
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.search.index.GDataIndexer.removeIndexEventListener(IndexEventListener)'
+     */
+    public void testRemoveIndexEventListener() {
+        IndexEventListenerStub evListener = new IndexEventListenerStub();
+        this.indexer.registerIndexEventListener(evListener);
+        assertEquals(0,evListener.getCalledCount());
+        this.indexer.notifyCommitListeners("someId");
+        assertEquals(1,evListener.getCalledCount());
+        this.indexer.removeIndexEventListener(evListener);
+        this.indexer.removeIndexEventListener(evListener);
+        this.indexer.notifyCommitListeners("someId");
+        assertEquals(1,evListener.getCalledCount());
+        
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.search.index.GDataIndexer.notifyCommitListeners(String)'
+     */
+    public void testNotifyCommitListeners() {
+        IndexEventListenerStub evListener = new IndexEventListenerStub();
+        IndexEventListenerStub evListener1 = new IndexEventListenerStub();
+        IndexEventListenerStub evListener2 = new IndexEventListenerStub();
+        this.indexer.registerIndexEventListener(evListener);
+        this.indexer.registerIndexEventListener(evListener1);
+        this.indexer.registerIndexEventListener(evListener2);
+        assertEquals(0,evListener.getCalledCount());
+        this.indexer.notifyCommitListeners("someId");
+        assertEquals(1,evListener.getCalledCount());
+        assertEquals(1,evListener1.getCalledCount());
+        assertEquals(1,evListener2.getCalledCount());
+        this.indexer.removeIndexEventListener(evListener);
+        this.indexer.notifyCommitListeners("someId");
+        assertEquals(1,evListener.getCalledCount());
+        assertEquals(2,evListener1.getCalledCount());
+        assertEquals(2,evListener2.getCalledCount());
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.search.index.GDataIndexer.closeWriter()'
+     */
+    public void testCloseWriter() throws IOException{
+        assertNotNull(this.indexer.writer);
+        this.indexer.closeWriter();
+        assertNull(this.indexer.writer);
+
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.search.index.GDataIndexer.closeSearcher()'
+     */
+    public void testCloseSearcher() throws IOException {
+        this.indexer.openSearcher();
+        assertNotNull(this.indexer.searcher);
+        this.indexer.closeSearcher();
+        assertNull(this.indexer.searcher);
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.search.index.GDataIndexer.openSearcher()'
+     */
+    public void testOpenSearcher() throws IOException {
+        this.indexer.searcher = null;
+        this.indexer.openSearcher();
+         assertNotNull(this.indexer.searcher);
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.search.index.GDataIndexer.openWriter()'
+     */
+    public void testOpenWriter() throws IOException {
+        this.indexer.closeWriter();
+        assertNull(this.indexer.writer);
+       this.indexer.openWriter();
+        assertNotNull(this.indexer.writer);
+    }
+
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.search.index.GDataIndexer.destroy()'
+     */
+    public void testDestroy() throws InterruptedException, IOException {
+        this.indexer.destroy();
+        String id = "myID";
+        Field f = new Field(FIELD_ID, id, Field.Store.YES,
+                Field.Index.UN_TOKENIZED);
+        Document doc = new Document();
+        doc.add(f);
+        Term delTerm = new Term(FIELD_ID, id);
+        IndexDocument iDoc = new IndexDocumentStub(doc, delTerm,
+                IndexAction.INSERT);
+        Future<IndexDocument> future = new FutureStub<IndexDocument>(iDoc);
+        try{
+        this.indexer.addIndexableDocumentTask(future);
+        fail("indexer already closed exc. expected");
+        }catch (IllegalStateException e) {}
+        this.indexer = GDataIndexer.createGdataIndexer(config, dir, true);
+        CountDownLatch documentLatch = new CountDownLatch(1);
+        iDoc = new IndexDocumentStub(doc, delTerm,
+                IndexAction.INSERT,documentLatch);
+        
+        CountDownLatch latch = new CountDownLatch(1);
+        future = new FutureStub<IndexDocument>(iDoc,latch,true);
+        this.indexer.addIndexableDocumentTask(future);
+        this.indexer.destroy();
+        latch.countDown();
+        documentLatch.await(5000,TimeUnit.MILLISECONDS);
+        // wait active for the commit
+        while(this.indexer.writer != null){}
+        
+        IndexSearcher s = new IndexSearcher(this.dir);
+        Hits h = s.search(new TermQuery(delTerm));
+        assertEquals(1, h.length());
+        s.close();
+        
+        
+    }
+    
+    public void testInnerClassFuture() throws InterruptedException, ExecutionException, TimeoutException{
+        Future f = new GDataIndexer.FinishingFuture();
+        assertNull(f.get());
+        assertNull(f.get(0,TimeUnit.MICROSECONDS));
+        assertTrue(f.isDone());
+        assertFalse(f.isCancelled());
+        assertFalse(f.cancel(true));
+        
+    }
+
+   
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/index/TestIndexController.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/index/TestIndexController.java
new file mode 100755
index 0000000..f8a3551
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/index/TestIndexController.java
@@ -0,0 +1,382 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.search.index;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.analysis.standard.StandardAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.search.GDataSearcher;
+import org.apache.lucene.gdata.search.config.IndexSchema;
+import org.apache.lucene.gdata.search.config.IndexSchemaField;
+import org.apache.lucene.gdata.search.config.IndexSchemaField.ContentType;
+import org.apache.lucene.gdata.search.index.IndexController.ServiceIndex;
+import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
+import org.apache.lucene.gdata.utils.ProvidedServiceStub;
+import org.apache.lucene.gdata.utils.ReferenceCounter;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.TermQuery;
+
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class TestIndexController extends TestCase {
+    IndexController controller;
+
+    IndexSchema schema;
+
+    File indexLocation;
+
+    protected void setUp() throws Exception {
+        this.controller = new IndexController();
+        GDataServerRegistry reg = GDataServerRegistry.getRegistry();
+
+        this.indexLocation = new File(System.getProperty("java.io.tmpdir"));
+        
+        
+        ProvidedServiceStub stub = new ProvidedServiceStub();
+        this.schema = new IndexSchema();
+        // must be set
+        this.schema.setDefaultSearchField("content");
+        this.schema.setName(ProvidedServiceStub.SERVICE_NAME);
+        this.schema.setIndexLocation(this.indexLocation.getAbsolutePath());
+        IndexSchemaField field = new IndexSchemaField();
+        field.setName("content");
+        field.setPath("/somePath");
+        field.setContentType(ContentType.TEXT);
+        this.schema.addSchemaField(field);
+        stub.setIndexSchema(this.schema);
+
+        reg.registerService(stub);
+    }
+
+    protected void tearDown() throws Exception {
+        super.tearDown();
+        GDataServerRegistry.getRegistry().destroy();
+        this.controller.destroy();
+        /*
+         * this file will be created by the controller
+         */
+        File toDel = new File(this.indexLocation,
+                ProvidedServiceStub.SERVICE_NAME);
+        delAllFiles(toDel);
+    }
+
+    /*
+     * del all created files
+     */
+    private void delAllFiles(File dir) {
+        if (dir == null || !dir.exists())
+            return;
+        File[] files = dir.listFiles();
+        for (int i = 0; i < files.length; i++) {
+            while (!files[i].canWrite()) {
+            }
+            ;
+            files[i].delete();
+        }
+        dir.delete();
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.search.index.IndexController.initialize()'
+     */
+    public void testInitialize() {
+        this.controller.initialize();
+        assertTrue(this.controller.indexerMap
+                .containsKey(ProvidedServiceStub.SERVICE_NAME));
+        ServiceIndex bean = this.controller.indexerMap
+                .get(ProvidedServiceStub.SERVICE_NAME);
+        assertNotNull(bean);
+        assertNotNull(bean.getIndexer());
+        assertSame(this.schema, bean.getSchema());
+        assertTrue(GDataServerRegistry.getRegistry().getEntryEventMediator()
+                .isListenerRegistered(this.controller));
+
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.search.index.IndexController.initialize()'
+     */
+    public void testInitializeValueMissing() {
+        this.schema.setIndexLocation(null);
+        try {
+
+            this.controller.initialize();
+            fail("missing index location");
+        } catch (RuntimeException e) {
+        }
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.search.index.IndexController.addIndexSchema(IndexSchema)'
+     */
+    public void testAddIndexSchema() {
+        this.controller.initialize();
+        assertEquals(1, this.controller.indexerMap.size());
+        try {
+            this.controller.addIndexSchema(this.schema);
+            fail("schema already added");
+        } catch (IllegalStateException e) {
+
+        }
+        this.schema.setName(null);
+        try {
+            this.controller.addIndexSchema(this.schema);
+            fail("schema name is null");
+        } catch (IllegalStateException e) {
+
+        }
+
+        this.schema.setName("someOthername");
+        this.controller.addIndexSchema(this.schema);
+        assertEquals(2, this.controller.indexerMap.size());
+
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.search.index.IndexController.createIndexer(IndexSchema)'
+     */
+    public void testCreateIndexDirectory() throws IOException {
+        File f = new File(System.getProperty("java.io.tmpdir"), "gdataindexdir"
+                + System.currentTimeMillis());
+        f.mkdir();
+        f.deleteOnExit();
+        IndexWriter w = new IndexWriter(f, new StandardAnalyzer(), true);
+        Document d = new Document();
+        d.add(new Field("test", "test", Field.Store.NO, Field.Index.TOKENIZED));
+        w.addDocument(d);
+        w.close();
+        assertFalse(this.controller.createIndexDirectory(f));
+        // throw away files in the directory
+        delAllFiles(f);
+        File f1 = new File(System.getProperty("java.io.tmpdir"), "newIndexDir"
+                + System.currentTimeMillis());
+        f1.mkdir();
+        f1.deleteOnExit();
+        assertTrue(this.controller.createIndexDirectory(f1));
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.search.index.IndexController.createIndexLocation(String,
+     * String)'
+     */
+    public void testCreateIndexLocation() throws IOException {
+        File f = new File(System.getProperty("java.io.tmpdir"), "gdatadir"
+                + System.currentTimeMillis());
+        f.mkdir();
+        f.deleteOnExit();
+
+        assertEquals(f.getAbsolutePath(), this.controller.createIndexLocation(
+                f.getParent(), f.getName()).getAbsolutePath());
+        ;
+        File pFile = new File(System.getProperty("java.io.tmpdir"), "gdatafile"
+                + System.currentTimeMillis());
+        pFile.deleteOnExit();
+        try{
+        this.controller.createIndexLocation(pFile.getParent(),pFile.getAbsolutePath());
+        fail("can not create dir");
+        }catch (RuntimeException e) {
+            
+        }
+        assertTrue(pFile.createNewFile());
+        try {
+            this.controller.createIndexLocation(pFile.getParent(), pFile
+                    .getName());
+            fail("file is not a directory");
+        } catch (IllegalArgumentException e) {
+
+        }
+        try {
+            this.controller.createIndexLocation(pFile.getName(), pFile
+                    .getName());
+            fail("parent is not a directory");
+        } catch (IllegalArgumentException e) {
+
+        }
+        try{
+            this.controller.createIndexLocation(null,null);
+            fail("null");
+        }catch (GdataIndexerException e) {
+
+        }
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.search.index.IndexController.getServiceSearcher(ProvidedService)'
+     */
+    public void testGetServiceSearcher() {
+
+        this.controller.initialize();
+        ReferenceCounter<IndexSearcher> refCounter = this.controller.indexerMap
+                .get(ProvidedServiceStub.SERVICE_NAME).getSearcher();
+        GDataSearcher searcher = this.controller
+                .getServiceSearcher(new ProvidedServiceStub());
+        assertNotNull(searcher);
+        GDataSearcher sameSearcher = this.controller
+                .getServiceSearcher(new ProvidedServiceStub());
+        assertSame(refCounter, this.controller.indexerMap.get(
+                ProvidedServiceStub.SERVICE_NAME).getSearcher());
+
+        this.controller.commitCallBack(ProvidedServiceStub.SERVICE_NAME);
+        GDataSearcher newSearcher = this.controller
+                .getServiceSearcher(new ProvidedServiceStub());
+        assertNotSame(refCounter, this.controller.indexerMap.get(
+                ProvidedServiceStub.SERVICE_NAME).getSearcher());
+
+        sameSearcher.close();
+        searcher.close();
+        newSearcher.close();
+
+    }
+
+    public void testDestroy() {
+        this.controller.initialize();
+        try {
+            this.controller.initialize();
+            fail("controller is initialized");
+        } catch (IllegalStateException e) {
+        }
+        this.controller.destroy();
+        try {
+            this.controller.getServiceSearcher(null);
+            fail("controller is closed");
+        } catch (IllegalStateException e) {
+        }
+        try {
+            this.controller.commitCallBack("null");
+            fail("controller is closed");
+        } catch (IllegalStateException e) {
+        }
+        
+        try {
+            this.controller.destroy();
+            fail("controller is closed");
+        } catch (IllegalStateException e) {
+        }   
+        try {
+            this.controller.addIndexSchema(null);
+            fail("controller is closed");
+        } catch (IllegalStateException e) {
+        }
+        /*
+         * init again to destroy in teardown
+         */
+        this.controller.initialize();
+    }
+    
+    
+    public void testfireInsertEvent(){
+        try{
+        this.controller.fireInsertEvent(null);
+        fail("not initialized");
+        }catch (IllegalStateException e) {
+            // TODO: handle exception
+        }
+        this.controller.initialize();
+        ServerBaseEntry e = new ServerBaseEntry();
+        e.setId("someId");
+        e.setFeedId("someId");
+        e.setServiceConfig(new ProvidedServiceStub());
+        this.controller.fireInsertEvent(e);
+    }
+    
+    public void testCreateNewIndexTask() throws InterruptedException, IOException{
+        this.schema.setCommitAfterDocuments(1);
+        this.schema.setOptimizeAfterCommit(1);
+        IndexSchemaField f = new IndexSchemaField();
+        f.setName("myField");
+        f.setContentType(ContentType.KEYWORD);
+        f.setPath("entry/id");
+        this.schema.addSchemaField(f);
+        this.controller.initialize();
+        ServerBaseEntry e = new ServerBaseEntry();
+        e.setId("someId");
+        e.setFeedId("someId");
+        e.setServiceConfig(new ProvidedServiceStub());
+        CommitListener l = new CommitListener();
+        l.createLatch(1);
+        ServiceIndex sIndex = this.controller.indexerMap.get(this.schema.getName());
+        sIndex.getIndexer().registerIndexEventListener(l);
+        this.controller.fireInsertEvent(e);
+        l.waitOnLatch();      
+       
+       assertEquals(1,sIndex.getIndexer().optimized.get());
+       assertEquals(1,sIndex.getIndexer().committed.get());
+       
+       sIndex.getIndexer().removeIndexEventListener(l);
+       
+       
+       e = new ServerBaseEntry();
+       e.setId("someId");
+       e.setFeedId("someId");
+       e.setServiceConfig(new ProvidedServiceStub());
+       l = new CommitListener();
+       l.createLatch(1);
+        sIndex = this.controller.indexerMap.get(this.schema.getName());
+       sIndex.getIndexer().registerIndexEventListener(l);
+       this.controller.fireUpdateEvent(e);
+       l.waitOnLatch();      
+      
+      assertEquals(2,sIndex.getIndexer().optimized.get());
+      assertEquals(2,sIndex.getIndexer().committed.get());
+      
+      GDataSearcher<String> searcher = this.controller.getServiceSearcher(e.getServiceConfig());
+      List<String> results = searcher.search(new TermQuery(new Term(IndexDocument.FIELD_ENTRY_ID,"someId")),10,0,"someId");
+      assertEquals(1,results.size());
+      searcher.close();
+      
+       
+        
+    }
+    
+    static class CommitListener implements IndexEventListener{
+        public CountDownLatch latch;
+        
+        public void createLatch(int count){
+            this.latch = new CountDownLatch(count);
+        }
+        public void waitOnLatch() throws InterruptedException{
+            if(latch != null)
+            latch.await();
+        }
+
+        public void commitCallBack(String service) {
+            if(this.latch != null)
+            this.latch.countDown();
+        }
+        
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/index/TestIndexLogReader.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/index/TestIndexLogReader.java
new file mode 100755
index 0000000..2de309f
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/index/TestIndexLogReader.java
@@ -0,0 +1,139 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.search.index;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+
+import org.xml.sax.SAXException;
+
+import junit.framework.TestCase;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class TestIndexLogReader extends TestCase {
+    File logFile;
+    Map<String, IndexAction> actions;
+    protected void setUp() throws Exception {
+        this.logFile = new File(System.getProperty("java.io.tmpdir"),"log");
+        this.logFile.deleteOnExit();
+        this.logFile.createNewFile();
+        this.actions = new HashMap<String,IndexAction>();
+   
+        
+    }
+    private IndexLogWriter writeLog() throws IOException{
+        this.actions = new HashMap<String,IndexAction>();
+        IndexLogWriter writer = new IndexLogWriter(this.logFile);
+        boolean totwice = true;
+        for (int i = 0; i < 10; i++) {
+            IndexAction a = null;
+            if(i%3 ==0)
+                a= IndexAction.INSERT;
+            if(i%3 ==1)
+                a= IndexAction.UPDATE;
+            if(i%3 ==2)
+                a= IndexAction.DELETE;
+            this.actions.put(""+i,a);
+            writer.writeAction(""+i,a);
+            /*
+             * double action
+             */
+            if(i == 9 && totwice){
+                i = 0;
+                totwice = false;
+            }
+        }
+        return writer;
+    }
+    protected void tearDown() throws Exception {
+        super.tearDown();
+        this.logFile.delete();
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.search.index.IndexLogReader.readIndexLog(File, Map<String, IndexAction>)'
+     */
+    public void testReadIndexLog() throws SAXException, IOException {
+        writeLog().close();
+        
+        Map<String,IndexAction> readActionMap = new HashMap<String,IndexAction>();
+        IndexLogReader.readIndexLog(this.logFile,readActionMap);
+        Set<String> keySet = this.actions.keySet();
+        assertEquals(10,keySet.size());
+        for (String string : keySet) {
+            assertTrue(readActionMap.get(string).equals(actions.get(string)));
+        }
+        
+       
+        
+    }
+    
+    /*
+     * Test method for 'org.apache.lucene.gdata.search.index.IndexLogReader.readIndexLog(File, Map<String, IndexAction>)'
+     */
+    public void testReadIndexLogNoInputMap() throws SAXException, IOException {
+        writeLog().close();
+      
+        Map<String,IndexAction> readActionMap = IndexLogReader.readIndexLog(this.logFile,null);
+        Set<String> keySet = this.actions.keySet();
+        assertEquals(10,keySet.size());
+        for (String string : keySet) {
+            assertTrue(readActionMap.get(string).equals(actions.get(string)));
+        }
+        
+    }
+    
+    /*
+     * Test method for 'org.apache.lucene.gdata.search.index.IndexLogReader.readIndexLog(File, Map<String, IndexAction>)'
+     */
+    public void testReadIndexLogFixLogFile() throws SAXException, IOException {
+        writeLog();
+          
+        Map<String,IndexAction> readActionMap = IndexLogReader.readIndexLog(this.logFile,null);
+        Set<String> keySet = this.actions.keySet();
+        assertEquals(10,keySet.size());
+        for (String string : keySet) {
+            assertTrue(readActionMap.get(string).equals(actions.get(string)));
+        }
+        
+    }
+    
+    public void testWriterClosed()throws SAXException, IOException{
+        IndexLogWriter writer = writeLog();
+        writer.close();
+        try{
+            writer.writeAction(null,null);
+            fail("writer is closed");
+        }catch (IllegalStateException e) {
+          
+        }
+        try{
+            writer.close();
+            fail("writer is closed");
+        }catch (IllegalStateException e) {
+          
+        }
+        
+        
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/index/TestindexDocumentBuilderTask.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/index/TestindexDocumentBuilderTask.java
new file mode 100755
index 0000000..0d7f130
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/index/TestindexDocumentBuilderTask.java
@@ -0,0 +1,163 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.search.index;
+
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.search.config.IndexSchema;
+import org.apache.lucene.gdata.search.config.IndexSchemaField;
+import org.apache.lucene.gdata.search.config.IndexSchemaField.ContentType;
+import org.apache.lucene.gdata.utils.ProvidedServiceStub;
+
+import com.google.gdata.data.PlainTextConstruct;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class TestindexDocumentBuilderTask extends TestCase {
+    IndexDocumentBuilder fineBuilder;
+    IndexDocumentBuilder failInStrategyBuilder;
+    IndexDocumentBuilder builder;
+    IndexDocumentBuilderTask zeroFields;
+    static String ID = "someId";
+    static String CONTENT_FIELD = "someId";
+    static String CONTENT = "foo bar";
+    protected void setUp() throws Exception {
+        ServerBaseEntry entry = new ServerBaseEntry();
+        entry.setVersionId("1");
+        entry.setFeedId("myFeed");
+        entry.setId(ID);
+        entry.setContent(new PlainTextConstruct(CONTENT));
+        entry.setServiceConfig(new ProvidedServiceStub());
+        IndexSchema schema = new IndexSchema();
+        schema.setName("mySchema");
+        IndexSchemaField field = new IndexSchemaField();
+        field.setName(CONTENT_FIELD);
+        field.setPath("/entry/content");
+        field.setContentType(ContentType.TEXT);
+        schema.addSchemaField(field);
+        this.fineBuilder = new IndexDocumentBuilderTask(entry,schema,IndexAction.INSERT,true,true);
+        
+        /*
+         * two fields, one will fail due to broken xpath.
+         * One will remain.
+         */
+        schema = new IndexSchema();
+        schema.setName("mySchema");
+        field = new IndexSchemaField();
+        field.setName("someContent");
+        //broken xpath
+        field.setPath("/entry///wrongXPath");
+        field.setContentType(ContentType.TEXT);
+        schema.addSchemaField(field);
+        field = new IndexSchemaField();
+        field.setName(CONTENT_FIELD);
+        field.setPath("/entry/content");
+        field.setContentType(ContentType.TEXT);
+        schema.addSchemaField(field);
+        this.failInStrategyBuilder = new IndexDocumentBuilderTask(entry,schema,IndexAction.INSERT,false,false);
+        //fail with no fields
+        schema = new IndexSchema();
+        schema.setName("mySchema");
+        this.zeroFields = new IndexDocumentBuilderTask(entry,schema,IndexAction.INSERT,false,false);
+        
+        
+    }
+
+    protected void tearDown() throws Exception {
+        super.tearDown();
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.search.index.IndexDocumentBuilderTask.IndexDocumentBuilderTask(ServerBaseEntry, IndexSchema, IndexAction, boolean)'
+     */
+    public void testIndexDocumentBuilderTask() {
+        IndexDocument doc = this.fineBuilder.call();
+        assertNotNull(doc.getDeletealbe());
+        assertNotNull(doc.getWriteable());
+        assertEquals(IndexDocument.FIELD_ENTRY_ID,doc.getDeletealbe().field());
+        assertEquals(ID,doc.getDeletealbe().text());
+        assertEquals(ID,doc.getWriteable().getField(IndexDocument.FIELD_ENTRY_ID).stringValue());
+        assertNotNull(doc.getWriteable().getField(CONTENT_FIELD).stringValue());
+      
+        /*
+         * the broken xpath fails but the other fields will be indexed
+         */
+        doc = this.failInStrategyBuilder.call();
+        assertNotNull(doc.getDeletealbe());
+        assertNotNull(doc.getWriteable());
+        assertEquals(IndexDocument.FIELD_ENTRY_ID,doc.getDeletealbe().field());
+        assertEquals(ID,doc.getDeletealbe().text());
+        assertEquals(ID,doc.getWriteable().getField(IndexDocument.FIELD_ENTRY_ID).stringValue());
+        assertNotNull(doc.getWriteable().getField(CONTENT_FIELD).stringValue());
+        
+        try{
+        this.zeroFields.call();
+        fail("zero fields in document");
+        }catch (GdataIndexerException e) {}
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.search.index.IndexDocumentBuilderTask.call()'
+     */
+    public void testCall() throws InterruptedException, ExecutionException {
+        ExecutorService service = Executors.newSingleThreadExecutor();
+        Future<IndexDocument> future = service.submit(this.fineBuilder);
+        IndexDocument doc = future.get();
+        assertNotNull(doc.getDeletealbe());
+        assertNotNull(doc.getWriteable());
+        assertEquals(IndexDocument.FIELD_ENTRY_ID,doc.getDeletealbe().field());
+        assertEquals(ID,doc.getDeletealbe().text());
+        assertEquals(ID,doc.getWriteable().getField(IndexDocument.FIELD_ENTRY_ID).stringValue());
+        assertNotNull(doc.getWriteable().getField(CONTENT_FIELD).stringValue());
+        assertTrue(doc.commitAfter());
+        assertTrue(doc.optimizeAfter());
+      
+        /*
+         * the broken xpath fails but the other fields will be indexed
+         */
+        future = service.submit(this.failInStrategyBuilder);
+         doc = future.get();
+        
+        assertNotNull(doc.getDeletealbe());
+        assertNotNull(doc.getWriteable());
+        assertEquals(IndexDocument.FIELD_ENTRY_ID,doc.getDeletealbe().field());
+        assertEquals(ID,doc.getDeletealbe().text());
+        assertEquals(ID,doc.getWriteable().getField(IndexDocument.FIELD_ENTRY_ID).stringValue());
+        assertNotNull(doc.getWriteable().getField(CONTENT_FIELD).stringValue());
+        future = service.submit(this.zeroFields);
+        
+        try{
+         future.get();
+        fail("zero fields in document");
+        }catch (ExecutionException e) {
+            assertTrue(e.getCause().getClass() == GdataIndexerException.class);
+            
+        }
+        service.shutdownNow();
+    }
+    
+    
+    
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/query/TestGdataQueryParser.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/query/TestGdataQueryParser.java
new file mode 100755
index 0000000..09a1927
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/query/TestGdataQueryParser.java
@@ -0,0 +1,36 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.search.query;
+
+import org.apache.lucene.analysis.standard.StandardAnalyzer;
+import org.apache.lucene.gdata.search.config.IndexSchema;
+import org.apache.lucene.queryParser.QueryParser.Operator;
+
+import junit.framework.TestCase;
+
+public class TestGdataQueryParser extends TestCase {
+
+    
+    public void testConstructor(){
+        String field = "someField";
+        IndexSchema s = new IndexSchema();
+        s.setDefaultSearchField(field);
+        GDataQueryParser p = new GDataQueryParser(s);
+        assertEquals(field,p.getField());
+        assertEquals(Operator.AND,p.getDefaultOperator());
+        assertEquals(StandardAnalyzer.class,p.getAnalyzer().getClass());
+    }
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/query/TestQueryTranslator.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/query/TestQueryTranslator.java
new file mode 100755
index 0000000..bdfe3e7
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/search/query/TestQueryTranslator.java
@@ -0,0 +1,106 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */ 
+package org.apache.lucene.gdata.search.query;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.lucene.gdata.search.config.IndexSchema;
+import org.apache.lucene.gdata.search.config.IndexSchemaField;
+import org.apache.lucene.gdata.search.config.IndexSchemaField.ContentType;
+import org.apache.lucene.gdata.utils.ProvidedServiceStub;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.RangeQuery;
+
+import junit.framework.TestCase;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class TestQueryTranslator extends TestCase {
+    private static final String CONTENT_FIELD = "content";
+    private static final String UPDATED_FIELD = "updated";
+    private IndexSchema schema;
+    Map<String,String[]> parameterMap;
+    /*
+     * @see junit.framework.TestCase#setUp()
+     */
+    @Override
+    protected void setUp() throws Exception {
+        this.schema = new IndexSchema();
+        //must be set
+        this.schema.setDefaultSearchField(CONTENT_FIELD);
+        this.schema.setIndexLocation("/tmp/");
+        this.schema.setName(ProvidedServiceStub.SERVICE_NAME);
+        IndexSchemaField field = new IndexSchemaField();
+        
+        field.setName(CONTENT_FIELD);
+        field.setContentType(ContentType.TEXT);
+        
+        IndexSchemaField field1 = new IndexSchemaField();
+        field1.setName(UPDATED_FIELD);
+        field1.setContentType(ContentType.GDATADATE);
+        this.schema.addSchemaField(field);
+        this.schema.addSchemaField(field1);
+        parameterMap = new HashMap<String,String[]>();
+        
+
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.search.query.QueryTranslator.translateHttpSearchRequest(IndexSchema, Map<String, String>, String, String)'
+     */
+    public void testTranslateHttpSearchRequest() {
+        assertNull(QueryTranslator.translateHttpSearchRequest(this.schema,this.parameterMap,null));
+        String contentQuery = "content1 -content2 \"exact Content\""; 
+        parameterMap.put("q", new String[]{contentQuery});
+        String expected = CONTENT_FIELD+":("+contentQuery+") ";
+      
+        assertEquals(expected,QueryTranslator.translateHttpSearchRequest(this.schema,this.parameterMap,null));
+        parameterMap.put("updated-min", new String[]{"2005-08-09T10:57:00-08:00"});
+        parameterMap.put("updated-max", new String[]{"2005-10-09T10:57:00-08:00"});
+        parameterMap.put("max-results", new String[]{"3"});
+        parameterMap.remove("q");
+        parameterMap.put(CONTENT_FIELD, new String[]{"apache"});
+        
+        String tranlatedQuery = QueryTranslator.translateHttpSearchRequest(this.schema,this.parameterMap,"test |{urn:google.com} {urn:apache.org}");
+        assertTrue(tranlatedQuery.contains("updated:[1123613820000 TO 1128884219999]"));
+        assertTrue(tranlatedQuery.contains(CONTENT_FIELD+":(apache)"));
+        
+        parameterMap.remove("updated-max");
+        tranlatedQuery = QueryTranslator.translateHttpSearchRequest(this.schema,this.parameterMap,"test |{urn:google.com} {urn:apache.org}");
+        assertTrue(tranlatedQuery.contains("updated:[1123613820000 TO "+Long.MAX_VALUE+"]"));
+        assertTrue(tranlatedQuery.contains(CONTENT_FIELD+":(apache)"));
+        parameterMap.put("updated-max", new String[]{"2005-10-09T10:57:00-08:00"});
+        parameterMap.remove("updated-min");
+        tranlatedQuery = QueryTranslator.translateHttpSearchRequest(this.schema,this.parameterMap,"test |{urn:google.com} {urn:apache.org}");
+        assertTrue(tranlatedQuery.contains("updated:["+0+" TO 1128884219999]"));
+        assertTrue(tranlatedQuery.contains(CONTENT_FIELD+":(apache)"));
+        
+        
+        
+        parameterMap.put("wrong-parameter", new String[]{"3"});
+        try{
+        QueryTranslator.translateHttpSearchRequest(this.schema,this.parameterMap,"test |{urn:google.com} {urn:apache.org}");
+        fail("illegal parameter");
+        }catch (RuntimeException e) {
+           
+        }
+       
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/server/TestGDataRequest.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/server/TestGDataRequest.java
new file mode 100644
index 0000000..f635a8e
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/server/TestGDataRequest.java
@@ -0,0 +1,681 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */ 
+package org.apache.lucene.gdata.server; 
+ 
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.StringTokenizer;
+
+import javax.servlet.http.HttpServletRequest;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.gdata.search.config.IndexSchema;
+import org.apache.lucene.gdata.search.config.IndexSchemaField;
+import org.apache.lucene.gdata.search.config.IndexSchemaField.ContentType;
+import org.apache.lucene.gdata.server.GDataRequest.GDataRequestType;
+import org.apache.lucene.gdata.server.GDataRequest.OutputFormat;
+import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
+import org.apache.lucene.gdata.server.registry.ProvidedService;
+import org.apache.lucene.gdata.utils.ProvidedServiceStub;
+import org.apache.lucene.gdata.utils.StorageStub;
+import org.easymock.MockControl;
+ 
+/** 
+ *  
+ * @author Simon Willnauer 
+ *  
+ */ 
+public class TestGDataRequest extends TestCase { 
+    private HttpServletRequest request; 
+ 
+    private MockControl control; 
+ 
+    private GDataRequest feedRequest; 
+    
+    private Map parametermap = new HashMap();
+    
+    @Override 
+    protected void setUp() throws Exception {
+        try{
+            GDataServerRegistry.getRegistry().registerComponent(StorageStub.class,null);
+        }catch (Exception e) {
+
+        }
+        ProvidedService configurator = new ProvidedServiceStub();
+        GDataServerRegistry.getRegistry().registerService(configurator);
+        IndexSchema schema = new IndexSchema();
+        //must be set
+        schema.setDefaultSearchField("field");
+        schema.setIndexLocation("/tmp/");
+        schema.setName(ProvidedServiceStub.SERVICE_NAME);
+        
+        ((ProvidedServiceStub)configurator).setIndexSchema(schema);
+            
+        this.control = MockControl.createControl(HttpServletRequest.class); 
+        this.request = (HttpServletRequest) this.control.getMock(); 
+        this.feedRequest = new GDataRequest(this.request,GDataRequestType.GET); 
+         
+    } 
+ 
+    protected void tearDown() throws Exception { 
+        super.tearDown(); 
+        this.control.reset(); 
+        GDataServerRegistry.getRegistry().destroy();
+    } 
+ 
+    public void testConstructor() { 
+        try { 
+            new GDataRequest(null,GDataRequestType.GET); 
+            fail("IllegalArgumentException expected"); 
+        } catch (IllegalArgumentException e) { 
+            //  
+        } 
+        try { 
+            new GDataRequest(null,null); 
+            fail("IllegalArgumentException expected"); 
+        } catch (IllegalArgumentException e) { 
+            //  
+        } 
+        try { 
+            new GDataRequest(this.request,null); 
+            fail("IllegalArgumentException expected"); 
+        } catch (IllegalArgumentException e) { 
+            //  
+        } 
+    } 
+ 
+    public void testGetFeedId() throws GDataRequestException { 
+        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
+        this.control.expectAndDefaultReturn(this.request.getPathInfo(), 
+                "/"+ProvidedServiceStub.SERVICE_NAME+"/feed/1/1"); 
+        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
+                null); 
+        this.control.replay(); 
+        this.feedRequest.initializeRequest(); 
+        assertEquals("feedID", this.feedRequest.getFeedId(), "feed"); 
+        this.control.reset(); 
+ 
+    } 
+ 
+    public void testEmptyPathInfo() { 
+        this.control.expectAndDefaultReturn(this.request.getPathInfo(), "/"); 
+        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
+                null); 
+        this.control.replay(); 
+        try { 
+            this.feedRequest.initializeRequest(); 
+ 
+            fail("FeedRequestException expected"); 
+        } catch (GDataRequestException e) { 
+            // expected 
+        } catch (Exception e) { 
+            fail("FeedRequestException expected"); 
+        } 
+ 
+    } 
+ 
+    public void testGetFeedIdWithoutEntry() throws GDataRequestException { 
+        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
+        this.control 
+                .expectAndDefaultReturn(this.request.getPathInfo(), "/"+ProvidedServiceStub.SERVICE_NAME+"/feed"); 
+        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
+                null); 
+        this.control.replay(); 
+        this.feedRequest.initializeRequest(); 
+        assertEquals("feedID", this.feedRequest.getFeedId(), "feed"); 
+    } 
+ 
+    public void testGetEntyId() throws GDataRequestException { 
+        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
+        this.control.expectAndDefaultReturn(this.request.getPathInfo(), 
+                "/"+ProvidedServiceStub.SERVICE_NAME+"/feed/1/15"); 
+        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
+                null); 
+        this.control.replay(); 
+        this.feedRequest.initializeRequest(); 
+        assertEquals("entryid", this.feedRequest.getEntryId(), "1"); 
+        assertEquals("feedId", this.feedRequest.getFeedId(), "feed"); 
+        assertEquals("entryid", this.feedRequest.getEntryVersion(), "15"); 
+        this.control.reset(); 
+ 
+    } 
+ 
+    public void testSetResponseFormatAtom() throws GDataRequestException { 
+        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
+        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
+                "atom"); 
+        this.control 
+                .expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+ "/feed"); 
+        this.control.replay(); 
+        this.feedRequest.initializeRequest(); 
+        assertEquals("ResponseFromat Atom", this.feedRequest 
+                .getRequestedResponseFormat(), OutputFormat.ATOM); 
+        this.control.reset(); 
+    } 
+ 
+    public void testSetResponseFormatRSS() throws GDataRequestException { 
+        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
+        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
+                "rss"); 
+        this.control 
+                .expectAndDefaultReturn(this.request.getPathInfo(), "/"+ProvidedServiceStub.SERVICE_NAME+"/feed"); 
+        this.control.replay(); 
+        this.feedRequest.initializeRequest(); 
+        assertEquals("ResponseFromat RSS", this.feedRequest 
+                .getRequestedResponseFormat(), OutputFormat.RSS); 
+        this.control.reset(); 
+    } 
+ 
+    public void testSetResponseFormatKeepAtom() throws GDataRequestException { 
+        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
+        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
+                "fooBar"); 
+        this.control 
+                .expectAndDefaultReturn(this.request.getPathInfo(), "/"+ProvidedServiceStub.SERVICE_NAME+"/feed"); 
+        this.control.replay(); 
+        this.feedRequest.initializeRequest(); 
+        assertEquals("ResponseFromat Atom", this.feedRequest 
+                .getRequestedResponseFormat(), OutputFormat.ATOM); 
+        this.control.reset(); 
+    } 
+ 
+    public void testSetResponseFormatNull() throws GDataRequestException { 
+        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
+        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
+                null); 
+ 
+        this.control 
+                .expectAndDefaultReturn(this.request.getPathInfo(), "/"+ProvidedServiceStub.SERVICE_NAME+"/feed"); 
+        this.control.replay(); 
+        this.feedRequest.initializeRequest(); 
+        assertEquals("ResponseFromat Atom", this.feedRequest 
+                .getRequestedResponseFormat(), OutputFormat.ATOM); 
+        this.control.reset(); 
+    } 
+ 
+    public void testGetItemsPerPage() throws GDataRequestException { 
+        this.control.expectAndReturn(this.request.getParameter("max-results"), 
+                null); 
+        this.control.replay(); 
+        assertEquals("default value 25", 25, this.feedRequest.getItemsPerPage()); 
+        this.control.verify(); 
+        this.control.reset(); 
+ 
+        this.control.expectAndReturn(this.request.getParameter("max-results"), 
+                "24", 2); 
+        this.control.replay(); 
+        assertEquals("24 results", 24, this.feedRequest.getItemsPerPage()); 
+        this.control.verify(); 
+        this.control.reset(); 
+         
+        this.control.expectAndReturn(this.request.getParameter("max-results"), 
+                "-1", 2); 
+        this.control.replay(); 
+        assertEquals("25 results", 25, this.feedRequest.getItemsPerPage()); 
+        this.control.verify(); 
+        this.control.reset(); 
+ 
+        this.control.expectAndReturn(this.request.getParameter("max-results"), 
+                "helloworld", 2); 
+        this.control.replay(); 
+        assertEquals("25 results", 25, this.feedRequest.getItemsPerPage()); 
+        this.control.verify(); 
+        this.control.reset(); 
+    } 
+     
+    public void testGetSelfId() throws GDataRequestException{ 
+        String host = "www.apache.org"; 
+        String feedAndEntryID = "/"+ProvidedServiceStub.SERVICE_NAME+"/feed/entryid"; 
+        String queryString = "max-results=25"; 
+        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
+        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
+        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/host"+"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/entryId/15/"); 
+        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/entryId/15"); 
+        this.control.expectAndReturn(this.request.getParameter("max-results"),"25",2); 
+        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
+                null); 
+        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
+                queryString); 
+        this.control.replay(); 
+        this.feedRequest.initializeRequest(); 
+        String selfID = "http://"+host+"/host"+"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/entryId/15?"+queryString; 
+        assertEquals("Self ID",selfID,this.feedRequest.getSelfId()); 
+        this.control.reset(); 
+         
+         
+        queryString = "alt=rss&max-results=25";
+        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
+        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
+        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/host"+"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/entryId/15/"); 
+        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/entryId/15"); 
+        this.control.expectAndReturn(this.request.getParameter("max-results"),"25",2); 
+        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
+                null); 
+        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
+                queryString); 
+        this.control.replay(); 
+        this.feedRequest.initializeRequest(); 
+        selfID = "http://"+host+"/host"+"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/entryId/15?"+queryString; 
+     
+        assertEquals("Self ID",selfID,this.feedRequest.getSelfId()); 
+        this.control.reset(); 
+         
+        queryString = ""; 
+        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
+        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
+        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/host"+"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/entryId/15/"); 
+        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/entryId/15"); 
+        this.control.expectAndDefaultReturn(this.request.getParameter("max-results"),null); 
+        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
+                null); 
+        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
+                null); 
+        this.control.replay(); 
+        this.feedRequest.initializeRequest(); 
+        selfID = "http://"+host+"/host"+"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/entryId/15"+"?max-results=25"; 
+     
+        assertEquals("Self ID",selfID,this.feedRequest.getSelfId()); 
+        this.control.reset(); 
+    } 
+     
+    public void testGetQueryString(){ 
+        String maxResults  = "max-results=25"; 
+        String queryString = "?"+maxResults; 
+        this.control.expectAndReturn(this.request.getParameter("max-results"),"25",2); 
+         
+        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
+                queryString); 
+        this.control.replay(); 
+         
+        assertEquals(queryString,this.feedRequest.getQueryString()); 
+        this.control.reset(); 
+        // test no result defined 
+        queryString = "?alt=rss"; 
+        this.control.expectAndDefaultReturn(this.request.getParameter("max-results"),null); 
+         
+        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
+                queryString); 
+        this.control.replay(); 
+         
+        assertEquals(queryString+"&"+maxResults,this.feedRequest.getQueryString()); 
+        this.control.reset(); 
+         
+//         test no result defined && query == null 
+        queryString = null; 
+        this.control.expectAndDefaultReturn(this.request.getParameter("max-results"),null); 
+         
+        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
+                queryString); 
+        this.control.replay(); 
+         
+        assertEquals(maxResults,this.feedRequest.getQueryString()); 
+        this.control.reset(); 
+     
+    } 
+     
+    public void testIsFeedRequest() throws GDataRequestException{ 
+        String host = "www.apache.org"; 
+        String feedAndEntryID = "/feed"; 
+        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
+        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
+        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/host"+"/"+ProvidedServiceStub.SERVICE_NAME+"/feed"); 
+        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed"); 
+         
+        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
+                null); 
+        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
+                null); 
+        this.control.replay(); 
+        this.feedRequest.initializeRequest(); 
+         
+     
+        assertTrue(this.feedRequest.isFeedRequested()); 
+        assertFalse(this.feedRequest.isEntryRequested()); 
+        this.control.reset(); 
+         
+        host = "www.apache.org"; 
+        feedAndEntryID = "/"+ProvidedServiceStub.SERVICE_NAME+"/feed/1"; 
+        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
+        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
+        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/host"+"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/1"); 
+        this.control.expectAndDefaultReturn(this.request.getPathInfo(),feedAndEntryID); 
+         
+        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
+                null); 
+        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
+                null); 
+        this.control.replay(); 
+        this.feedRequest.initializeRequest(); 
+         
+     
+        assertFalse(this.feedRequest.isFeedRequested()); 
+        assertTrue(this.feedRequest.isEntryRequested()); 
+        this.control.reset(); 
+        
+        host = "www.apache.org"; 
+        feedAndEntryID = "/"+ProvidedServiceStub.SERVICE_NAME+"/feed/1"; 
+        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
+        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
+        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/host"+"/"+"NOTREGISTERED"+"/feed/1"); 
+        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+"NOTREGISTERED"+"/feed/1"); 
+         
+        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
+                null); 
+        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
+                null); 
+        this.control.replay(); 
+        try{
+        this.feedRequest.initializeRequest();
+        fail("service not registered");
+        }catch (GDataRequestException e) {
+            //
+        }
+        this.control.reset(); 
+        
+        host = "www.apache.org"; 
+        feedAndEntryID = "/"+ProvidedServiceStub.SERVICE_NAME+"/feed/1"; 
+        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
+        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
+        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/host"+"/"+ProvidedServiceStub.SERVICE_NAME+"/"); 
+        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+"/"); 
+         
+        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
+                null); 
+        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
+                null); 
+        this.control.replay(); 
+        try{
+        this.feedRequest.initializeRequest();
+        fail("service not registered");
+        }catch (GDataRequestException e) {
+//
+        }
+        this.control.reset(); 
+         
+         
+    } 
+    public void testgetAuthToken(){ 
+        this.control.expectAndDefaultReturn(this.request.getHeader("Authentication"),"GoogleLogin auth=bla");
+        this.control.replay();
+        assertEquals("bla",this.feedRequest.getAuthToken());
+        this.control.verify();
+        this.control.reset();
+        
+        this.control.expectAndDefaultReturn(this.request.getHeader("Authentication"),null);
+        this.control.replay();
+        assertNull(this.feedRequest.getAuthToken());
+        this.control.verify();
+        this.control.reset();
+        
+    } 
+    
+    public void testGetStartIndex(){
+        this.control.expectAndDefaultReturn(this.request.getParameter("start-index"),"5");
+        this.control.replay();
+        assertEquals(5,this.feedRequest.getStartIndex());
+        this.control.verify();
+        this.control.reset();
+        this.control.expectAndDefaultReturn(this.request.getParameter("start-index"),"-5");
+        this.control.replay();
+        assertEquals(1,this.feedRequest.getStartIndex());
+        this.control.verify();
+        this.control.reset();
+        this.control.expectAndDefaultReturn(this.request.getParameter("start-index"),"unparsable");
+        this.control.replay();
+        assertEquals(1,this.feedRequest.getStartIndex());
+        this.control.verify();
+        this.control.reset();
+    }
+     
+    public void testGetNextId() throws GDataRequestException{ 
+        String host = "www.apache.org"; 
+        String feedAndEntryID = "/"+ProvidedServiceStub.SERVICE_NAME+"/feed/entryid"; 
+        String queryString = "max-results=25"; 
+        String startIndex = "start-index=26"; 
+        Enumeration enu = new StringTokenizer("max-results",",");
+        
+        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
+        this.control.expectAndDefaultReturn(this.request.getParameterNames(),enu);
+        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
+        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/"); 
+        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/"); 
+        this.control.expectAndReturn(this.request.getParameter("max-results"),"25",3); 
+        this.control.expectAndReturn(this.request.getParameter("start-index"),null); 
+        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
+                null); 
+        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
+                queryString); 
+        this.control.replay(); 
+
+        this.feedRequest.initializeRequest(); 
+        String nextID = "http://"+host+"/"+ProvidedServiceStub.SERVICE_NAME+"/feed?"+startIndex+"&"+queryString; 
+     
+        assertEquals("Next ID",nextID,this.feedRequest.getNextId());
+        this.control.verify();
+        this.control.reset(); 
+         
+        enu = new StringTokenizer("alt,max-results,start-index",",");
+        queryString = "alt=rss&max-results=25"; 
+        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
+        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
+        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/"); 
+        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/"); 
+        this.control.expectAndReturn(this.request.getParameter("max-results"),"25",4); 
+        this.control.expectAndReturn(this.request.getParameter("start-index"),"26",4); 
+        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
+                "rss"); 
+        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
+                queryString+"&"+startIndex); 
+        
+        this.control.expectAndDefaultReturn(this.request.getParameterNames(),enu);
+        
+        
+        this.control.replay(); 
+        this.feedRequest.initializeRequest(); 
+        startIndex = "&start-index=51"; 
+        nextID = "http://"+host+"/"+ProvidedServiceStub.SERVICE_NAME+"/feed?"+queryString+startIndex; 
+     
+        assertEquals("Next ID 51",nextID,this.feedRequest.getNextId()); 
+        this.control.reset(); 
+         
+        queryString = ""; 
+        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
+        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
+        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/"); 
+        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/entryId/15"); 
+        this.control.expectAndDefaultReturn(this.request.getParameter("max-results"),null); 
+        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
+                null); 
+        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
+                null); 
+        this.control.replay(); 
+        this.feedRequest.initializeRequest(); 
+        String nextId = "http://"+host+"/"+ProvidedServiceStub.SERVICE_NAME+"/feed"+"?max-results=25&start-index=26"; 
+     
+        assertEquals("next ID",nextId,this.feedRequest.getNextId()); 
+        this.control.reset();
+
+        
+        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
+        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
+        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/"); 
+        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/entryId/15"); 
+        this.control.expectAndReturn(this.request.getParameter("max-results"),null,3); 
+        this.control.expectAndReturn(this.request.getParameter("start-index"),null,3);
+        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
+                null); 
+        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
+                null); 
+        this.control.replay(); 
+        this.feedRequest.initializeRequest(); 
+        nextId = "http://"+host+"/"+ProvidedServiceStub.SERVICE_NAME+"/feed"+"?max-results=25&start-index=26"; 
+        assertEquals("nextID",nextId,this.feedRequest.getNextId());
+    } 
+    
+    public void testGetpreviousId() throws GDataRequestException{ 
+        String host = "www.apache.org"; 
+        String feedAndEntryID = "/"+ProvidedServiceStub.SERVICE_NAME+"/feed/entryid"; 
+        String queryString = "max-results=25"; 
+         
+        Enumeration enu = new StringTokenizer("max-results",",");
+        
+        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
+        this.control.expectAndDefaultReturn(this.request.getParameterNames(),enu);
+        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
+        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/"); 
+        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/"); 
+        this.control.expectAndReturn(this.request.getParameter("start-index"),null); 
+        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
+                null); 
+        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
+                queryString); 
+        this.control.replay(); 
+
+        this.feedRequest.initializeRequest(); 
+         
+     
+        assertNull(this.feedRequest.getPreviousId());
+        this.control.verify();
+        this.control.reset(); 
+        String startIndex = "start-index="; 
+        enu = new StringTokenizer("alt,max-results,start-index",",");
+        queryString = "alt=rss&max-results=25&start-index=26"; 
+        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
+        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
+        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/"); 
+        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/"); 
+        this.control.expectAndReturn(this.request.getParameter("max-results"),"25",4); 
+        this.control.expectAndReturn(this.request.getParameter("start-index"),"26",4); 
+        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
+                "rss"); 
+        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
+                queryString); 
+        
+        this.control.expectAndDefaultReturn(this.request.getParameterNames(),enu);
+        
+        
+        this.control.replay(); 
+        this.feedRequest.initializeRequest(); 
+        
+        String prevId = "http://"+host+"/"+ProvidedServiceStub.SERVICE_NAME+"/feed"+"?alt=rss&max-results=25&start-index=1"; 
+        assertEquals("prevID",prevId,this.feedRequest.getPreviousId());
+        
+        this.control.reset(); 
+         
+        queryString = ""; 
+        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
+        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
+        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/"); 
+        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/entryId/15"); 
+        this.control.expectAndDefaultReturn(this.request.getParameter("max-results"),null); 
+        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
+                null); 
+        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
+                null); 
+        this.control.replay(); 
+        this.feedRequest.initializeRequest(); 
+        assertNull(this.feedRequest.getPreviousId());
+     
+        
+        this.control.reset(); 
+        
+        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
+        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
+        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/"); 
+        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/entryId/15"); 
+        this.control.expectAndReturn(this.request.getParameter("max-results"),"35",3); 
+        this.control.expectAndReturn(this.request.getParameter("start-index"),"5",3);
+        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
+                null); 
+        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
+                "max-results=35&start-index=5"); 
+        this.control.replay(); 
+        this.feedRequest.initializeRequest(); 
+        prevId = "http://"+host+"/"+ProvidedServiceStub.SERVICE_NAME+"/feed"+"?max-results=35&start-index=1"; 
+        assertEquals("prevID",prevId,this.feedRequest.getPreviousId());
+        
+        
+        
+        
+    } 
+    
+    public void testGetContextPath(){
+        String host = "www.apache.org"; 
+        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
+        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/id/"); 
+        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/id/"); 
+        this.control.replay();
+        String result = "http://"+host+"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/id/";
+        assertEquals(result,this.feedRequest.getContextPath());
+        this.control.verify();
+        this.control.reset();
+        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
+        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/id"); 
+        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/id"); 
+        this.control.replay();
+        
+        assertEquals(result,this.feedRequest.getContextPath());
+        this.control.verify();
+        
+    }
+    
+    public void testCategoryQuery() throws GDataRequestException{
+        String host = "www.apache.org"; 
+        String feedAndEntryID = "/feed"; 
+        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
+        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
+        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/host"+"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/-/test"); 
+        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/-/test"); 
+         
+        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
+                null); 
+        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
+                null); 
+        this.control.replay(); 
+        this.feedRequest.initializeRequest(); 
+         
+     
+        assertTrue(this.feedRequest.isFeedRequested()); 
+        assertFalse(this.feedRequest.isEntryRequested()); 
+        assertNotNull(this.feedRequest.getTranslatedQuery());
+        this.control.verify();
+        this.control.reset();
+        this.feedRequest = new GDataRequest(this.request,GDataRequestType.GET); 
+        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
+        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
+        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/host"+"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/"); 
+        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/"); 
+         
+        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
+                null); 
+        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
+                null); 
+        this.control.replay(); 
+        this.feedRequest.initializeRequest(); 
+         
+     
+        assertTrue(this.feedRequest.isFeedRequested()); 
+        assertFalse(this.feedRequest.isEntryRequested()); 
+        assertNull(this.feedRequest.getTranslatedQuery());
+        this.control.verify();
+        this.control.reset(); 
+    }
+    
+    
+    
+} 
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/server/TestGDataResponse.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/server/TestGDataResponse.java
new file mode 100644
index 0000000..400ee5a
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/server/TestGDataResponse.java
@@ -0,0 +1,177 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.server; 
+ 
+import java.io.IOException; 
+import java.io.PrintWriter; 
+import java.io.StringWriter; 
+ 
+import javax.servlet.http.HttpServletResponse; 
+ 
+import junit.framework.TestCase; 
+ 
+import org.apache.lucene.gdata.server.GDataRequest.OutputFormat; 
+import org.apache.lucene.gdata.utils.ProvidedServiceStub;
+import org.easymock.MockControl; 
+ 
+import com.google.gdata.data.Entry; 
+import com.google.gdata.data.ExtensionProfile; 
+import com.google.gdata.data.Feed; 
+import com.google.gdata.data.PlainTextConstruct; 
+/** 
+ *  
+ * @author Simon Willnauer 
+ * 
+ */ 
+public class TestGDataResponse extends TestCase { 
+    private GDataResponse response; 
+    private HttpServletResponse httpResponse; 
+    private MockControl control; 
+    private static String generatedFeedAtom = "<?xml version='1.0'?><feed xmlns='http://www.w3.org/2005/Atom' xmlns:openSearch='http://a9.com/-/spec/opensearchrss/1.0/'><entry><title type='text'>Test</title></entry></feed>"; 
+    private static String generatedEntryAtom = "<?xml version='1.0'?><entry xmlns='http://www.w3.org/2005/Atom'><title type='text'>Test</title></entry>"; 
+    private static String generatedFeedRSS = "<?xml version='1.0'?><rss xmlns:atom='http://www.w3.org/2005/Atom' xmlns:openSearch='http://a9.com/-/spec/opensearchrss/1.0/' version='2.0'><channel><description></description><item><title>Test</title></item></channel></rss>"; 
+    private static String generatedEntryRSS = "<?xml version='1.0'?><item xmlns:atom='http://www.w3.org/2005/Atom'><title>Test</title></item>"; 
+    protected void setUp() throws Exception { 
+        this.control = MockControl.createControl(HttpServletResponse.class); 
+        this.httpResponse = (HttpServletResponse)this.control.getMock(); 
+        this.response = new GDataResponse(this.httpResponse); 
+         
+    } 
+ 
+    protected void tearDown() throws Exception { 
+        super.tearDown(); 
+    } 
+     
+     
+    public void testConstructor(){ 
+        try{ 
+        new GDataResponse(null); 
+        fail("IllegalArgumentExceptin expected"); 
+        }catch (IllegalArgumentException e) { 
+            // TODO: handle exception 
+        } 
+    } 
+    /* 
+     * Test method for 'org.apache.lucene.gdata.server.GDataResponse.sendResponse(BaseFeed, ExtensionProfile)' 
+     */ 
+    public void testSendResponseBaseFeedExtensionProfile() throws IOException { 
+        try{ 
+            Feed f = null; 
+            this.response.sendResponse(f, new ProvidedServiceStub()); 
+            fail("Exception expected"); 
+        }catch (IllegalArgumentException e) { 
+            // 
+        } 
+         
+        try{ 
+            Feed f = createFeed(); 
+            this.response.sendResponse(f,null); 
+            fail("Exception expected"); 
+        }catch (IllegalArgumentException e) { 
+            // 
+        } 
+        StringWriter stringWriter = new StringWriter(); 
+        PrintWriter writer = new PrintWriter(stringWriter); 
+         
+        this.control.expectAndReturn(this.httpResponse.getWriter(),writer);
+        this.httpResponse.setContentType(GDataResponse.XMLMIME_ATOM);
+        this.response.setOutputFormat(OutputFormat.ATOM); 
+        this.control.replay(); 
+         
+        this.response.sendResponse(createFeed(), new ProvidedServiceStub()); 
+        assertEquals("Simple XML representation",stringWriter.toString(),generatedFeedAtom); 
+        this.control.reset(); 
+         
+        stringWriter = new StringWriter(); 
+        writer = new PrintWriter(stringWriter); 
+         
+        this.control.expectAndReturn(this.httpResponse.getWriter(),writer); 
+        this.response.setOutputFormat(OutputFormat.RSS); 
+        this.httpResponse.setContentType(GDataResponse.XMLMIME_RSS);
+        this.control.replay(); 
+         
+        this.response.sendResponse(createFeed(), new ProvidedServiceStub()); 
+        assertEquals("Simple XML representation",stringWriter.toString(),generatedFeedRSS); 
+         
+         
+         
+ 
+    } 
+ 
+    /* 
+     * Test method for 'org.apache.lucene.gdata.server.GDataResponse.sendResponse(BaseEntry, ExtensionProfile)' 
+     */ 
+    public void testSendResponseBaseEntryExtensionProfile() throws IOException { 
+        try{ 
+            Entry e = null; 
+            this.response.sendResponse(e, new ProvidedServiceStub()); 
+            fail("Exception expected"); 
+        }catch (IllegalArgumentException e) { 
+            // 
+        } 
+        try{ 
+            Entry e = createEntry(); 
+            this.response.sendResponse(e,null); 
+            fail("Exception expected"); 
+        }catch (IllegalArgumentException e) { 
+            // 
+        } 
+//        // test Atom output 
+        StringWriter stringWriter = new StringWriter(); 
+        PrintWriter writer = new PrintWriter(stringWriter); 
+         
+        this.control.expectAndReturn(this.httpResponse.getWriter(),writer); 
+        this.httpResponse.setContentType(GDataResponse.XMLMIME_ATOM);
+        this.response.setOutputFormat(OutputFormat.ATOM); 
+        this.control.replay(); 
+         
+        this.response.sendResponse(createEntry(), new ProvidedServiceStub()); 
+        assertEquals("Simple XML representation ATOM",stringWriter.toString(),generatedEntryAtom); 
+         
+        // test rss output 
+        this.control.reset(); 
+        stringWriter = new StringWriter(); 
+        writer = new PrintWriter(stringWriter); 
+         
+        this.control.expectAndReturn(this.httpResponse.getWriter(),writer); 
+        this.httpResponse.setContentType(GDataResponse.XMLMIME_RSS);
+        this.response.setOutputFormat(OutputFormat.RSS); 
+        this.control.replay(); 
+         
+        this.response.sendResponse(createEntry(), new ProvidedServiceStub()); 
+         
+        assertEquals("Simple XML representation RSS",stringWriter.toString(),generatedEntryRSS); 
+         
+         
+         
+    } 
+     
+    /* create a simple feed */ 
+    private Feed createFeed(){ 
+        Feed feed = new Feed(); 
+         
+        feed.getEntries().add(createEntry()); 
+         
+        return feed; 
+    } 
+    /* create a simple entry */ 
+    private Entry createEntry(){ 
+        Entry e = new Entry(); 
+        e.setTitle(new PlainTextConstruct("Test")); 
+        return e; 
+    } 
+ 
+} 
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/server/administration/TestAccountBuilder.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/server/administration/TestAccountBuilder.java
new file mode 100644
index 0000000..7ed8586
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/server/administration/TestAccountBuilder.java
@@ -0,0 +1,92 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.server.administration;
+
+import java.io.IOException;
+import java.io.StringReader;
+import java.net.URL;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
+import org.xml.sax.SAXException;
+
+public class TestAccountBuilder extends TestCase {
+    private StringReader reader;
+    private String inputXML;
+    private StringReader invalidReader;
+    private String invalidInputXML;
+    protected void setUp() throws Exception {
+        this.inputXML = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" +
+                "<account>" +
+                "<account-name>simon</account-name>" +
+                "<password>simon</password>" +
+                "<account-role>6</account-role>" +
+                "<account-owner>" +
+                "<name>simon willnauer</name>" +
+                "<email-address>simon@gmail.com</email-address>" +
+                "<url>http://www.javawithchopsticks.de</url>" +
+                "</account-owner>" +
+                "</account>";
+
+        this.reader = new StringReader(this.inputXML);
+        this.invalidInputXML = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" +
+        "<account>" +
+        "<account-name>simon</account-name>" +
+        "<account-role>6</account-role>" +
+        "<account-owner>" +
+        "<name>simon willnauer</name>" +
+        "<email-address>simon@gmail.com</email-address>" +
+        "<url>http://www.javawithchopsticks.de</url>" +
+        "</account-owner>" +
+        "</account>";
+
+        this.invalidReader = new StringReader(this.invalidInputXML);
+        
+    }
+
+    protected void tearDown() throws Exception {
+        super.tearDown();
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.server.administration.AdminEntityBuilder.buildUser(Reader)'
+     */
+    public void testBuildUser() throws IOException, SAXException {
+        
+        GDataAccount user = AccountBuilder.buildAccount(this.reader);
+        assertEquals("simon",user.getName());
+        assertEquals("simon willnauer",user.getAuthorname());
+        assertEquals("simon@gmail.com",user.getAuthorMail());
+        assertEquals("simon",user.getPassword());
+        assertEquals(new URL("http://www.javawithchopsticks.de"),user.getAuthorLink());
+        assertTrue(user.isUserInRole(AccountRole.ENTRYAMINISTRATOR));
+        assertTrue(user.isUserInRole(AccountRole.FEEDAMINISTRATOR));
+        assertFalse(user.isUserInRole(AccountRole.USERADMINISTRATOR));
+        
+    }
+    
+    public void testBuildUserWrongXML() throws IOException{
+        try{
+        AccountBuilder.buildAccount(this.invalidReader);
+        fail("invalid xml");
+        }catch (SAXException e) {
+            
+        }
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/server/authentication/TestBlowfishAuthenticationController.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/server/authentication/TestBlowfishAuthenticationController.java
new file mode 100644
index 0000000..12c7a8d
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/server/authentication/TestBlowfishAuthenticationController.java
@@ -0,0 +1,95 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.server.authentication;
+
+import java.io.IOException;
+import java.io.UnsupportedEncodingException;
+
+import javax.crypto.BadPaddingException;
+import javax.crypto.IllegalBlockSizeException;
+
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
+
+import junit.framework.TestCase;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class TestBlowfishAuthenticationController extends TestCase {
+    private BlowfishAuthenticationController controller;
+    private String key = "myKey";
+    private String accountName = "simon";
+    
+    private String clientIp = "192.168.0.127";
+    protected void setUp() throws Exception {
+        this.controller = new BlowfishAuthenticationController();
+        this.controller.setKey(this.key);
+        
+        this.controller.initialize();
+    }
+
+    protected void tearDown() throws Exception {
+        super.tearDown();
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.server.authentication.AuthenticationController.authenticatAccount(HttpServletRequest)'
+     */
+    public void testAuthenticatAccount() throws IllegalBlockSizeException, BadPaddingException, AuthenticationException, IOException {
+        GDataAccount account = new GDataAccount();
+        account.setName(accountName);
+        account.setPassword("testme");
+        account.setRole(AccountRole.ENTRYAMINISTRATOR);
+        
+        String token = this.controller.authenticatAccount(account,this.clientIp);
+        String notSame = this.controller.calculateAuthToken("192.168.0",Integer.toString(account.getRolesAsInt()),this.accountName);
+        assertNotSame(notSame,token);
+        String authString = "192.168.0#"+this.accountName +"#"+account.getRolesAsInt()+"#";
+        assertTrue(this.controller.deCryptAuthToken(token).startsWith(authString));
+        assertTrue(this.controller.deCryptAuthToken(notSame).startsWith(authString));
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.server.authentication.AuthenticationController.authenticateToken(String)'
+     */
+    public void testAuthenticateToken() throws IllegalBlockSizeException, BadPaddingException, UnsupportedEncodingException, AuthenticationException {
+        GDataAccount account = new GDataAccount();
+        account.setName("simon");
+        account.setPassword("testme");
+        account.setRole(AccountRole.ENTRYAMINISTRATOR);
+        String token = this.controller.calculateAuthToken("192.168.0",Integer.toString(account.getRolesAsInt()),this.accountName);
+        
+        assertTrue(this.controller.authenticateToken(token,this.clientIp,AccountRole.ENTRYAMINISTRATOR,this.accountName));
+        assertTrue(this.controller.authenticateToken(token,this.clientIp,AccountRole.USER,this.accountName));
+        assertFalse(this.controller.authenticateToken(token,this.clientIp,AccountRole.USERADMINISTRATOR,"someOtherAccount"));
+        try{
+        this.controller.authenticateToken(token+"test",this.clientIp,AccountRole.ENTRYAMINISTRATOR,this.accountName);
+        fail("exception expected");
+        }catch (Exception e) {
+            // TODO: handle exception
+        }
+        this.controller.setLoginTimeout(0);
+        assertFalse(this.controller.authenticateToken(token,this.clientIp,AccountRole.ENTRYAMINISTRATOR,this.accountName));
+        
+    }
+
+    
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/server/registry/TestEntityBuilderIncomingEntry.xml b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/server/registry/TestEntityBuilderIncomingEntry.xml
new file mode 100644
index 0000000..35e4817
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/server/registry/TestEntityBuilderIncomingEntry.xml
@@ -0,0 +1,21 @@
+<?xml version='1.0' encoding='UTF-8'?> 
+<entry xmlns='http://www.w3.org/2005/Atom'> 
+    <id> 
+        http://www.google.com/calendar/feeds/simon.willnauer%40googlemail.com/public/basic/af4b5ca305c80f96f42c9af66c5b04a8473c949c 
+    </id> 
+    <published>2006-12-23T00:00:00.000Z</published> 
+    <updated>2006-05-23T16:42:48.000Z</updated> 
+    <category scheme='http://schemas.google.com/g/2005#kind' 
+        term='http://schemas.google.com/g/2005#event'> 
+    </category> 
+    <summary type='html'> 
+        When: 2006-12-23 to 2006-12-31 America/Los_Angeles&lt;br> 
+    </summary> 
+    <link rel='alternate' type='text/html' 
+        href='http://www.google.com/calendar/event?eid=YWY0YjVjYTMwNWM4MGY5NmY0MmM5YWY2NmM1YjA0YTg0NzNjOTQ5YyBzaW1vbi53aWxsbmF1ZXJAZ29vZ2xlbWFpbC5jb20' 
+        title='alternate'> 
+    </link> 
+    <link rel='self' type='application/atom+xml' 
+        href='http://www.google.com/calendar/feeds/simon.willnauer%40googlemail.com/public/basic/af4b5ca305c80f96f42c9af66c5b04a8473c949c'> 
+    </link> 
+</entry> 
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/server/registry/TestEntityBuilderIncomingFeed.xml b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/server/registry/TestEntityBuilderIncomingFeed.xml
new file mode 100644
index 0000000..47f7978
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/server/registry/TestEntityBuilderIncomingFeed.xml
@@ -0,0 +1,90 @@
+<?xml version='1.0' encoding='UTF-8'?> 
+<feed xmlns='http://www.w3.org/2005/Atom' 
+    xmlns:openSearch='http://a9.com/-/spec/opensearchrss/1.0/' 
+    xmlns:gd='http://schemas.google.com/g/2005'> 
+    <id> 
+        http://www.google.com/calendar/feeds/simon.willnauer%40googlemail.com/public/basic 
+    </id> 
+    <updated>2006-05-27T11:47:55.000Z</updated> 
+    <title type='text'>Simon Willnauer</title> 
+    <subtitle type='text'>Simon Willnauer</subtitle> 
+    <link rel='http://schemas.google.com/g/2005#feed' 
+        type='application/atom+xml' 
+        href='http://www.google.com/calendar/feeds/simon.willnauer%40googlemail.com/public/basic'> 
+    </link> 
+    <link rel='self' type='application/atom+xml' 
+        href='http://www.google.com/calendar/feeds/simon.willnauer%40googlemail.com/public/basic?max-results=25'> 
+    </link> 
+    <link rel='next' type='application/atom+xml' 
+        href='http://www.google.com/calendar/feeds/simon.willnauer%40googlemail.com/public/basic?start-index=26&amp;max-results=25'> 
+    </link> 
+    <author> 
+        <name>Simon Willnauer</name> 
+        <email>simon.willnauer@googlemail.com</email> 
+    </author> 
+    <generator version='1.0' uri='http://www.google.com/calendar'> 
+        Google Calendar 
+    </generator> 
+    <openSearch:itemsPerPage>25</openSearch:itemsPerPage> 
+    <entry> 
+        <id> 
+            http://www.google.com/calendar/feeds/simon.willnauer%40googlemail.com/public/basic/af4b5ca305c80f96f42c9af66c5b04a8473c949c 
+        </id> 
+        <published>2006-12-23T00:00:00.000Z</published> 
+        <updated>2006-05-23T16:42:48.000Z</updated> 
+        <category scheme='http://schemas.google.com/g/2005#kind' 
+            term='http://schemas.google.com/g/2005#event'> 
+        </category> 
+        <summary type='html'> 
+            When: 2006-12-23 to 2006-12-31 America/Los_Angeles&lt;br> 
+        </summary> 
+        <link rel='alternate' type='text/html' 
+            href='http://www.google.com/calendar/event?eid=YWY0YjVjYTMwNWM4MGY5NmY0MmM5YWY2NmM1YjA0YTg0NzNjOTQ5YyBzaW1vbi53aWxsbmF1ZXJAZ29vZ2xlbWFpbC5jb20' 
+            title='alternate'> 
+        </link> 
+        <link rel='self' type='application/atom+xml' 
+            href='http://www.google.com/calendar/feeds/simon.willnauer%40googlemail.com/public/basic/af4b5ca305c80f96f42c9af66c5b04a8473c949c'> 
+        </link> 
+    </entry> 
+    <entry> 
+        <id> 
+            http://www.google.com/calendar/feeds/simon.willnauer%40googlemail.com/public/basic/d5402951792ce690f6a45e51143deb78f4fffac4 
+        </id> 
+        <published>2006-05-26T00:00:00.000Z</published> 
+        <updated>2006-05-20T22:17:44.000Z</updated> 
+        <category scheme='http://schemas.google.com/g/2005#kind' 
+            term='http://schemas.google.com/g/2005#event'> 
+        </category> 
+        <summary type='html'> 
+            When: 2006-05-26 to 2006-05-27 America/Los_Angeles&lt;br> 
+        </summary> 
+        <link rel='alternate' type='text/html' 
+            href='http://www.google.com/calendar/event?eid=ZDU0MDI5NTE3OTJjZTY5MGY2YTQ1ZTUxMTQzZGViNzhmNGZmZmFjNCBzaW1vbi53aWxsbmF1ZXJAZ29vZ2xlbWFpbC5jb20' 
+            title='alternate'> 
+        </link> 
+        <link rel='self' type='application/atom+xml' 
+            href='http://www.google.com/calendar/feeds/simon.willnauer%40googlemail.com/public/basic/d5402951792ce690f6a45e51143deb78f4fffac4'> 
+        </link> 
+    </entry> 
+    <entry> 
+        <id> 
+            http://www.google.com/calendar/feeds/simon.willnauer%40googlemail.com/public/basic/21630e853795ea81d5e792d0ab082ad1c44256e4 
+        </id> 
+        <published>2006-06-19T14:00:00.000Z</published> 
+        <updated>2006-05-17T16:10:57.000Z</updated> 
+        <category scheme='http://schemas.google.com/g/2005#kind' 
+            term='http://schemas.google.com/g/2005#event'> 
+        </category> 
+        <summary type='html'> 
+            When: 2006-06-19 07:00:00 to 08:00:00 
+            America/Los_Angeles&lt;br> 
+        </summary> 
+        <link rel='alternate' type='text/html' 
+            href='http://www.google.com/calendar/event?eid=MjE2MzBlODUzNzk1ZWE4MWQ1ZTc5MmQwYWIwODJhZDFjNDQyNTZlNCBzaW1vbi53aWxsbmF1ZXJAZ29vZ2xlbWFpbC5jb20' 
+            title='alternate'> 
+        </link> 
+        <link rel='self' type='application/atom+xml' 
+            href='http://www.google.com/calendar/feeds/simon.willnauer%40googlemail.com/public/basic/21630e853795ea81d5e792d0ab082ad1c44256e4'> 
+        </link> 
+    </entry> 
+</feed> 
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/server/registry/TestFeedRegistry.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/server/registry/TestFeedRegistry.java
new file mode 100644
index 0000000..147b743
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/server/registry/TestFeedRegistry.java
@@ -0,0 +1,154 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.server.registry;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.gdata.server.ServiceFactory;
+import org.apache.lucene.gdata.servlet.handler.DefaultRequestHandlerFactory;
+import org.apache.lucene.gdata.servlet.handler.RequestHandlerFactory;
+import org.apache.lucene.gdata.storage.StorageController;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController;
+
+import com.google.gdata.data.Entry;
+import com.google.gdata.data.ExtensionProfile;
+import com.google.gdata.data.Feed;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class TestFeedRegistry extends TestCase {
+    private GDataServerRegistry reg;
+
+    private ProvidedServiceConfig configurator;
+
+    @Override
+    protected void setUp() {
+        this.reg = GDataServerRegistry.getRegistry();
+        this.configurator = new ProvidedServiceConfig();
+        this.configurator.setEntryType(Entry.class);
+        this.configurator.setFeedType(Feed.class);
+        this.configurator.setExtensionProfile(new ExtensionProfile());
+    }
+
+    /**
+     * @see junit.framework.TestCase#tearDown()
+     */
+    @Override
+    protected void tearDown() throws Exception {
+        this.reg.flushRegistry();
+
+    }
+
+    /**
+     * Test method for
+     * 'org.apache.lucene.gdata.server.registry.FeedRegistry.getRegistry()'
+     */
+    public void testGetRegistry() {
+
+        GDataServerRegistry reg1 = GDataServerRegistry.getRegistry();
+        assertEquals("test singleton", this.reg, reg1);
+    }
+
+    /**
+     * Test method for
+     * 'org.apache.lucene.gdata.server.registry.FeedRegistry.registerFeed(FeedInstanceConfigurator)'
+     */
+    public void testRegisterService() {
+        String service = "service";
+        registerService(service);
+        assertEquals("Registered Configurator", this.configurator, this.reg
+                .getProvidedService(service));
+        assertNull("not registered Configurator", this.reg
+                .getProvidedService("something"));
+        try {
+            this.reg.getProvidedService(null);
+            fail("Exception expected");
+        } catch (IllegalArgumentException e) {
+            //
+        }
+    }
+
+    /**
+     * Test method for
+     * 'org.apache.lucene.gdata.server.registry.FeedRegistry.getFeedConfigurator(String)'
+     */
+    public void testFlushRegistry() {
+        String service = "service";
+        registerService(service);
+
+        assertEquals("Registered Configurator", this.configurator, this.reg
+                .getProvidedService(service));
+        this.reg.flushRegistry();
+        assertNull("Registry flushed", this.reg.getProvidedService(service));
+
+    }
+
+    /**
+     * 
+     */
+    public void testIsFeedRegistered() {
+        String service = "service";
+        registerService(service);
+        assertTrue("Feed is registerd", this.reg.isServiceRegistered(service));
+        assertFalse("null Feed is not registerd", this.reg
+                .isServiceRegistered(null));
+        assertFalse("Feed is not registerd", this.reg
+                .isServiceRegistered("something"));
+
+    }
+
+    private void registerService(String servicename) {
+
+        this.configurator.setName(servicename);
+        this.reg.registerService(this.configurator);
+    }
+
+    public void testRegisterComponent() throws RegistryException {
+        try {
+            this.reg.registerComponent(StorageController.class, null);
+            fail("RegistryException expected");
+        } catch (RegistryException e) {
+            //
+        }
+        new GDataRequestListener();
+        try {
+            this.reg.registerComponent(StorageCoreController.class, null);
+            fail("no config");
+        } catch (Exception e) {
+            // TODO: handle exception
+        }
+        this.reg.registerComponent(DefaultRequestHandlerFactory.class, null);
+        RequestHandlerFactory factory = this.reg.lookup(
+                RequestHandlerFactory.class,
+                ComponentType.REQUESTHANDLERFACTORY);
+        try {
+            this.reg
+                    .registerComponent(DefaultRequestHandlerFactory.class, null);
+            fail("RegistryException expected");
+        } catch (RegistryException e) {
+            //
+        }
+        this.reg.registerComponent(ServiceFactory.class, null);
+        ServiceFactory servicefactory = this.reg.lookup(ServiceFactory.class,
+                ComponentType.SERVICEFACTORY);
+        assertNotNull(servicefactory);
+        assertNotNull(factory);
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/server/registry/TestGDataEntityBuilder.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/server/registry/TestGDataEntityBuilder.java
new file mode 100644
index 0000000..4556b59
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/server/registry/TestGDataEntityBuilder.java
@@ -0,0 +1,105 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */ 
+package org.apache.lucene.gdata.server.registry; 
+ 
+import java.io.File;
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.Reader;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.data.ServerBaseFeed;
+import org.apache.lucene.gdata.server.GDataEntityBuilder;
+
+import com.google.gdata.data.BaseEntry;
+import com.google.gdata.data.BaseFeed;
+import com.google.gdata.data.Entry;
+import com.google.gdata.data.ExtensionProfile;
+import com.google.gdata.data.Feed;
+import com.google.gdata.data.Source;
+import com.google.gdata.util.ParseException;
+ 
+/** 
+ * @author Simon Willnauer 
+ * 
+ */ 
+public class TestGDataEntityBuilder extends TestCase { 
+    private static File incomingFeed = new File("src/test/org/apache/lucene/gdata/server/registry/TestEntityBuilderIncomingFeed.xml"); 
+    private static File incomingEntry = new File("src/test/org/apache/lucene/gdata/server/registry/TestEntityBuilderIncomingEntry.xml"); 
+    private static String feedTitleFromXML = "Simon Willnauer"; 
+    private static String entrySummaryFromXML = "When: 2006-12-23 to 2006-12-31 America/Los_Angeles"; 
+    private static GDataServerRegistry reg = GDataServerRegistry.getRegistry(); 
+    private Reader reader;  
+    private static String feedID = "myFeed"; 
+    private ProvidedServiceConfig config;
+    private static Class feedType = Feed.class; 
+    private static Class entryType = Entry.class;
+     
+     
+    /** 
+     * @see junit.framework.TestCase#setUp() 
+     */ 
+    @Override 
+    protected void setUp() throws Exception { 
+        this.config = new ProvidedServiceConfig(); 
+        
+        this.config.setFeedType(feedType); 
+        this.config.setEntryType(entryType);
+        this.config.setExtensionProfile(new ExtensionProfile()); 
+        reg.registerService(this.config); 
+    } 
+ 
+    /** 
+     * @see junit.framework.TestCase#tearDown() 
+     */ 
+    @Override 
+    protected void tearDown() throws Exception { 
+        reg.flushRegistry(); 
+        this.reader = null; 
+    } 
+ 
+    /** 
+     * Test method for 'org.apache.lucene.gdata.data.GDataEntityBuilder.buildFeed(String, Reader)' 
+     */ 
+    public void testBuildFeedStringReader() throws  ParseException, IOException { 
+        this.reader = new FileReader(incomingFeed); 
+        BaseFeed feed = GDataEntityBuilder.buildFeed(this.reader,this.config); 
+        assertNotNull(feed); 
+        assertEquals("feed title",feed.getTitle().getPlainText(), feedTitleFromXML);
+        
+       
+         
+    } 
+ 
+    /**
+     * Test method for 'org.apache.lucene.gdata.data.GDataEntityBuilder.buildEntry(String, Reader)' 
+     */ 
+    public void testBuildEntryStringReader() throws  ParseException, IOException { 
+        this.reader = new FileReader(incomingEntry); 
+        BaseEntry entry = GDataEntityBuilder.buildEntry(this.reader,this.config); 
+        assertNotNull(entry); 
+        assertEquals("entry summary",entry.getSummary().getPlainText(),entrySummaryFromXML); 
+        
+        
+
+         
+    } 
+     
+     
+ 
+} 
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/server/registry/TestProvidedServiceConfig.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/server/registry/TestProvidedServiceConfig.java
new file mode 100755
index 0000000..cc8402a
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/server/registry/TestProvidedServiceConfig.java
@@ -0,0 +1,105 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.server.registry;
+
+import junit.framework.TestCase;
+
+import com.google.gdata.data.Entry;
+import com.google.gdata.data.ExtensionProfile;
+import com.google.gdata.data.Feed;
+
+public class TestProvidedServiceConfig extends TestCase {
+    ProvidedServiceConfig instance;
+    protected void setUp() throws Exception {
+        instance = new ProvidedServiceConfig();
+        instance.setExtensionProfileClass(ExtensionProfile.class);
+        instance.setFeedType(Feed.class);
+        instance.setEntryType(Entry.class);
+    }
+
+    protected void tearDown() throws Exception {
+        super.tearDown();
+        instance.destroy();
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.server.registry.ProvidedServiceConfig.getExtensionProfile()'
+     */
+    public void testGetExtensionProfile() {
+        try{
+        this.instance.setExtensionProfile(null);
+        fail("value must not be null");
+        }catch (IllegalArgumentException e) {
+
+        }
+        ExtensionProfile profile = this.instance.getExtensionProfile();
+        assertNotNull(profile);
+        assertSame(profile,this.instance.getExtensionProfile());
+        this.instance.visiteInitialize();
+        assertSame(profile,this.instance.getExtensionProfile());
+        assertNull(new ProvidedServiceConfig().getExtensionProfile());
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.server.registry.ProvidedServiceConfig.setExtensionProfile(ExtensionProfile)'
+     */
+    public void testSetPoolSize() throws InstantiationException, IllegalAccessException {
+        assertEquals(5,instance.getPoolSize());
+        instance.destroy();
+        instance = new ProvidedServiceConfig();
+        instance.setExtensionProfileClass(ExtensionProfile.class);
+        instance.setFeedType(Feed.class);
+        instance.setEntryType(Entry.class);
+        instance.setPoolSize(30);
+        instance.visiteInitialize();
+        assertEquals(30,instance.getPoolSize());
+        instance.destroy();
+        instance = new ProvidedServiceConfig();
+        instance.setExtensionProfileClass(ExtensionProfile.class);
+        instance.setFeedType(Feed.class);
+        instance.setEntryType(Entry.class);
+        instance.setPoolSize(-5);
+        instance.visiteInitialize();
+        assertEquals(5,instance.getPoolSize());
+    }
+
+   
+   
+   
+    /*
+     * Test method for 'org.apache.lucene.gdata.server.registry.ProvidedServiceConfig.visiteInitialize()'
+     */
+    public void testVisiteInitialize() {
+        instance.visiteInitialize();
+        assertNull(instance.extProfThreadLocal.get());
+        instance.getExtensionProfile();
+        assertNotNull(instance.extProfThreadLocal.get());
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.server.registry.ProvidedServiceConfig.visiteDestroy()'
+     */
+    public void testVisiteDestroy() {
+        ExtensionProfile profile = this.instance.getExtensionProfile();
+        assertNotNull(profile);
+        assertNotNull(instance.extProfThreadLocal.get());
+        instance.visiteDestroy();
+        assertNull(instance.extProfThreadLocal.get());
+        instance.visiteDestroy();
+        assertNull(instance.extProfThreadLocal.get());
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/server/registry/configuration/TestConfigurationBean.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/server/registry/configuration/TestConfigurationBean.java
new file mode 100755
index 0000000..f66d2a9
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/server/registry/configuration/TestConfigurationBean.java
@@ -0,0 +1,59 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.server.registry.configuration;
+
+import junit.framework.TestCase;
+
+public class TestConfigurationBean extends TestCase {
+    private ComponentConfiguration bean;
+
+    protected void setUp() throws Exception {
+        super.setUp();
+        this.bean = new ComponentConfiguration();
+
+    }
+
+    protected void tearDown() throws Exception {
+        super.tearDown();
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.server.registry.configuration.ConfigurationBean.set(String,
+     * String)'
+     */
+    public void testSet() {
+        this.bean.set("field", "value");
+        try {
+            this.bean.set("field", "value");
+            fail("field already set");
+        } catch (IllegalArgumentException e) {
+            //
+        }
+        assertEquals("value", this.bean.get("field"));
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.server.registry.configuration.ConfigurationBean.get(String)'
+     */
+    public void testGet() {
+        assertNull(this.bean.get("field"));
+        this.bean.set("field", "value");
+        assertEquals("value", this.bean.get("field"));
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/server/registry/configuration/TestPropertyInjector.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/server/registry/configuration/TestPropertyInjector.java
new file mode 100755
index 0000000..54b706a
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/server/registry/configuration/TestPropertyInjector.java
@@ -0,0 +1,192 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.server.registry.configuration;
+
+import junit.framework.TestCase;
+
+public class TestPropertyInjector extends TestCase {
+    private PropertyInjector injector;
+
+    protected void setUp() throws Exception {
+        super.setUp();
+        this.injector = new PropertyInjector();
+    }
+
+    protected void tearDown() throws Exception {
+        super.tearDown();
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.server.registry.configuration.PropertyInjector.setTargetObject(Object)'
+     */
+    public void testSetTargetObject() {
+        try {
+            this.injector.setTargetObject(null);
+            fail("must not be null");
+        } catch (IllegalArgumentException e) {
+            // TODO: handle exception
+        }
+        try {
+            this.injector.setTargetObject(new Object());
+            fail("no getter or setter methodes");
+        } catch (InjectionException e) {
+            // TODO: handle exception
+        }
+      
+       this.injector.setTargetObject(new TestBean());
+       assertEquals(1,this.injector.getOptionalSize());
+       assertEquals(1,this.injector.getRequiredSize());
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.server.registry.configuration.PropertyInjector.injectProperties(ConfigurationBean)'
+     */
+    public void testInjectProperties() throws Exception {
+        ComponentConfiguration bean = new ComponentConfiguration();
+        bean.set("someValue","bla");
+        try{
+            this.injector.injectProperties(bean);
+            fail("target is not set");
+            }catch (IllegalStateException e) {
+          
+            }
+        TestBean testBean = new TestBean();
+        this.injector.setTargetObject(testBean);
+        try{
+            this.injector.injectProperties(null);
+            fail("object is null");
+            }catch (IllegalArgumentException e) {
+          
+            }
+        try{
+        this.injector.injectProperties(bean);
+        fail("requiered Property is not available in config bean");
+        }catch (InjectionException e) {
+          
+        }
+        
+        bean.set("test","fooBar");
+        bean.set("testClass","java.lang.Object");
+        this.injector.injectProperties(bean);
+        
+        assertEquals("fooBar",testBean.getTest());
+        assertEquals(Object.class,testBean.getTestClass());
+        
+        
+        
+        this.injector = new PropertyInjector();
+        SubTestBean subTestBean = new SubTestBean();
+        this.injector.setTargetObject(subTestBean);
+        bean.set("number","333");
+        this.injector.injectProperties(bean);
+        
+        assertEquals("fooBar",subTestBean.getTest());
+        assertEquals(Object.class,subTestBean.getTestClass());
+        assertEquals(333,subTestBean.getNumber());
+        
+        bean = new ComponentConfiguration();
+        bean.set("test","fooBar");
+        bean.set("number","333");
+        bean.set("wrapper","1.2");
+       
+        subTestBean = new SubTestBean();
+        this.injector.setTargetObject(subTestBean);
+        this.injector.injectProperties(bean);
+        
+        assertEquals("fooBar",subTestBean.getTest());
+        assertEquals(333,subTestBean.getNumber());
+        assertEquals(new Float(1.2),subTestBean.getWrapper());
+    
+
+    }
+    
+    
+   public static class TestBean{
+       
+        private String test;
+        private Class testClass;
+        /**
+         * @return Returns the test.
+         */
+        public String getTest() {
+            return test;
+        }
+        /**
+         * @param test The test to set.
+         */
+        @Requiered
+        public void setTest(String test) {
+            this.test = test;
+        }
+        /**
+         * @return Returns the testClass.
+         */
+        public Class getTestClass() {
+            return testClass;
+        }
+        /**
+         * @param testClass The testClass to set.
+         */
+        public void setTestClass(Class testClass) {
+            this.testClass = testClass;
+        }
+        
+        
+    }
+   public static class SubTestBean extends TestBean{
+      private int number;
+      private Float wrapper;
+
+    /**
+     * @return Returns the wrapper.
+     */
+    public Float getWrapper() {
+        return wrapper;
+    }
+
+    /**
+     * @param wrapper The wrapper to set.
+     */
+    public void setWrapper(Float wrapper) {
+        this.wrapper = wrapper;
+    }
+
+    /**
+     * @return Returns the number.
+     */
+    
+    public int getNumber() {
+        return number;
+    }
+
+    /**
+     * @param number The number to set.
+     */
+    @Requiered
+    public void setNumber(int number) {
+        this.number = number;
+    }
+       
+       
+       
+       
+   }
+    
+
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/servlet/TestAbstractGdataServlet.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/servlet/TestAbstractGdataServlet.java
new file mode 100644
index 0000000..3a19426
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/servlet/TestAbstractGdataServlet.java
@@ -0,0 +1,297 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.servlet; 
+ 
+import java.io.IOException; 
+ 
+import javax.servlet.ServletException; 
+import javax.servlet.http.HttpServletRequest; 
+import javax.servlet.http.HttpServletResponse; 
+ 
+import org.easymock.MockControl; 
+ 
+import junit.framework.TestCase; 
+ 
+/** 
+ * @author Simon Willnauer 
+ * 
+ */ 
+public class TestAbstractGdataServlet extends TestCase { 
+    private static final String METHOD_DELETE = "DELETE"; 
+ 
+    private static final String METHOD_GET = "GET"; 
+ 
+    private static final String METHOD_POST = "POST"; 
+ 
+    private static final String METHOD_PUT = "PUT"; 
+ 
+    private static final String METHOD_HEADER_NAME = "x-http-method-override"; 
+ 
+    private HttpServletRequest mockRequest = null; 
+ 
+    private HttpServletResponse mockResponse = null; 
+ 
+    private AbstractGdataServlet servletInstance = null; 
+ 
+    private MockControl requestMockControl; 
+ 
+    private MockControl responseMockControl; 
+ 
+    protected void setUp() throws Exception { 
+        this.requestMockControl = MockControl 
+                .createControl(HttpServletRequest.class); 
+        this.responseMockControl = MockControl 
+                .createControl(HttpServletResponse.class); 
+        this.mockRequest = (HttpServletRequest) this.requestMockControl 
+                .getMock(); 
+        this.mockResponse = (HttpServletResponse) this.responseMockControl 
+                .getMock(); 
+        this.servletInstance = new StubGDataServlet(); 
+    } 
+ 
+    /** 
+     * Test method for 
+     * 'org.apache.lucene.gdata.servlet.AbstractGdataServlet.service(HttpServletRequest, 
+     * HttpServletResponse)' 
+     */ 
+    public void testServiceHttpServletRequestHttpServletResponseDelete() { 
+        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
+                .getMethod(), METHOD_DELETE); 
+        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
+                .getHeader(METHOD_HEADER_NAME), METHOD_DELETE); 
+        this.requestMockControl.replay(); 
+ 
+        try { 
+            this.servletInstance.service(this.mockRequest, this.mockResponse); 
+        } catch (ServletException e) { 
+            fail("ServeltExpception not expected"); 
+        } catch (IOException e) { 
+            fail("IOExpception not expected"); 
+        } 
+ 
+        this.requestMockControl.verify(); 
+        this.requestMockControl.reset(); 
+ 
+        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
+                .getMethod(), METHOD_POST); 
+        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
+                .getHeader(METHOD_HEADER_NAME), METHOD_DELETE); 
+        this.requestMockControl.replay(); 
+ 
+        try { 
+            this.servletInstance.service(this.mockRequest, this.mockResponse); 
+        } catch (ServletException e) { 
+            fail("ServeltExpception not expected"); 
+        } catch (IOException e) { 
+            fail("IOExpception not expected"); 
+        } 
+ 
+        this.requestMockControl.verify(); 
+    } 
+ 
+    /** 
+     *  
+     */ 
+    public void testServiceNullOverrideHeader() { 
+        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
+                .getMethod(), METHOD_POST); 
+        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
+                .getHeader(METHOD_HEADER_NAME), null); 
+        this.requestMockControl.replay(); 
+ 
+        try { 
+            this.servletInstance.service(this.mockRequest, this.mockResponse); 
+        } catch (ServletException e) { 
+            fail("ServeltExpception not expected"); 
+        } catch (IOException e) { 
+            fail("IOExpception not expected"); 
+        } 
+ 
+        this.requestMockControl.verify(); 
+        this.requestMockControl.reset(); 
+    } 
+ 
+    /** 
+     * Test method for 
+     * 'org.apache.lucene.gdata.servlet.AbstractGdataServlet.service(HttpServletRequest, 
+     * HttpServletResponse)' 
+     */ 
+    public void testServiceHttpServletRequestHttpServletResponsePOST() { 
+        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
+                .getMethod(), METHOD_POST); 
+        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
+                .getHeader(METHOD_HEADER_NAME), METHOD_POST); 
+        this.requestMockControl.replay(); 
+ 
+        try { 
+            this.servletInstance.service(this.mockRequest, this.mockResponse); 
+        } catch (ServletException e) { 
+            fail("ServeltExpception not expected"); 
+        } catch (IOException e) { 
+            fail("IOExpception not expected"); 
+        } 
+ 
+        this.requestMockControl.verify(); 
+        this.requestMockControl.reset(); 
+ 
+        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
+                .getMethod(), METHOD_PUT); 
+        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
+                .getHeader(METHOD_HEADER_NAME), METHOD_POST); 
+        this.requestMockControl.replay(); 
+ 
+        try { 
+            this.servletInstance.service(this.mockRequest, this.mockResponse); 
+        } catch (ServletException e) { 
+            fail("ServeltExpception not expected"); 
+        } catch (IOException e) { 
+            fail("IOExpception not expected"); 
+        } 
+ 
+        this.requestMockControl.verify(); 
+    } 
+ 
+    /** 
+     * Test method for 
+     * 'org.apache.lucene.gdata.servlet.AbstractGdataServlet.service(HttpServletRequest, 
+     * HttpServletResponse)' 
+     */ 
+    public void testServiceHttpServletRequestHttpServletResponsePUT() { 
+        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
+                .getMethod(), METHOD_PUT); 
+        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
+                .getHeader(METHOD_HEADER_NAME), METHOD_PUT); 
+        this.requestMockControl.replay(); 
+ 
+        try { 
+            this.servletInstance.service(this.mockRequest, this.mockResponse); 
+        } catch (ServletException e) { 
+            fail("ServeltExpception not expected"); 
+        } catch (IOException e) { 
+            fail("IOExpception not expected"); 
+        } 
+ 
+        this.requestMockControl.verify(); 
+        this.requestMockControl.reset(); 
+ 
+        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
+                .getMethod(), METHOD_POST); 
+        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
+                .getHeader(METHOD_HEADER_NAME), METHOD_PUT); 
+        this.requestMockControl.replay(); 
+ 
+        try { 
+            this.servletInstance.service(this.mockRequest, this.mockResponse); 
+        } catch (ServletException e) { 
+            fail("ServeltExpception not expected"); 
+        } catch (IOException e) { 
+            fail("IOExpception not expected"); 
+        } 
+ 
+        this.requestMockControl.verify(); 
+    } 
+ 
+    /** 
+     * Test method for 
+     * 'org.apache.lucene.gdata.servlet.AbstractGdataServlet.service(HttpServletRequest, 
+     * HttpServletResponse)' 
+     */ 
+    public void testServiceHttpServletRequestHttpServletResponseGET() { 
+        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
+                .getMethod(), METHOD_GET); 
+        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
+                .getHeader(METHOD_HEADER_NAME), METHOD_GET); 
+        this.requestMockControl.replay(); 
+ 
+        try { 
+            this.servletInstance.service(this.mockRequest, this.mockResponse); 
+        } catch (ServletException e) { 
+            fail("ServeltExpception not expected"); 
+        } catch (IOException e) { 
+            fail("IOExpception not expected"); 
+        } 
+ 
+        this.requestMockControl.verify(); 
+        this.requestMockControl.reset(); 
+ 
+        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
+                .getMethod(), METHOD_POST); 
+        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
+                .getHeader(METHOD_HEADER_NAME), METHOD_GET); 
+        this.requestMockControl.replay(); 
+ 
+        try { 
+            this.servletInstance.service(this.mockRequest, this.mockResponse); 
+        } catch (ServletException e) { 
+            fail("ServeltExpception not expected"); 
+        } catch (IOException e) { 
+            fail("IOExpception not expected"); 
+        } 
+ 
+        this.requestMockControl.verify(); 
+ 
+    } 
+    /** 
+     * Stub Implementation for <code>AbstractGdataServlet</code> 
+     * @author Simon Willnauer 
+     * 
+     */ 
+    static class StubGDataServlet extends AbstractGdataServlet { 
+ 
+        private static final long serialVersionUID = -6271464588547620925L; 
+ 
+        protected void doDelete(HttpServletRequest arg0, 
+                HttpServletResponse arg1) { 
+            if (arg0.getHeader(METHOD_HEADER_NAME) == null) 
+                assertEquals("Http-Method --DELETE--", METHOD_DELETE, arg0 
+                        .getMethod()); 
+            else 
+                assertEquals("Http-Method override --DELETE--", METHOD_DELETE, 
+                        arg0.getHeader(METHOD_HEADER_NAME)); 
+ 
+        } 
+ 
+        protected void doGet(HttpServletRequest arg0, HttpServletResponse arg1) { 
+            if (arg0.getHeader(METHOD_HEADER_NAME) == null) 
+                assertEquals("Http-Method --GET--", arg0.getMethod(), 
+                        METHOD_GET); 
+            else 
+                assertEquals("Http-Method override --GET--", arg0 
+                        .getHeader(METHOD_HEADER_NAME), METHOD_GET); 
+        } 
+ 
+        protected void doPost(HttpServletRequest arg0, HttpServletResponse arg1) { 
+            if (arg0.getHeader(METHOD_HEADER_NAME) == null) 
+                assertEquals("Http-Method --POST--", arg0.getMethod(), 
+                        METHOD_POST); 
+            else 
+                assertEquals("Http-Method override --POST--", METHOD_POST, arg0 
+                        .getHeader(METHOD_HEADER_NAME)); 
+ 
+        } 
+ 
+        protected void doPut(HttpServletRequest arg0, HttpServletResponse arg1) { 
+            if (arg0.getHeader(METHOD_HEADER_NAME) == null) 
+                assertEquals("Http-Method --PUT--", arg0.getMethod(), 
+                        METHOD_PUT); 
+            else 
+                assertEquals("Http-Method override --PUT--", arg0 
+                        .getHeader(METHOD_HEADER_NAME), METHOD_PUT); 
+        } 
+ 
+    } 
+ 
+} 
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/servlet/handler/TestAbstractFeedHandler.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/servlet/handler/TestAbstractFeedHandler.java
new file mode 100644
index 0000000..c3cd391
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/servlet/handler/TestAbstractFeedHandler.java
@@ -0,0 +1,215 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.servlet.handler;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileReader;
+import java.io.IOException;
+
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.data.ServerBaseFeed;
+import org.apache.lucene.gdata.server.GDataResponse;
+import org.apache.lucene.gdata.server.ServiceException;
+import org.apache.lucene.gdata.server.ServiceFactory;
+import org.apache.lucene.gdata.server.administration.AdminService;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
+import org.apache.lucene.gdata.server.registry.RegistryException;
+import org.apache.lucene.gdata.servlet.handler.AbstractFeedHandler.FeedHandlerException;
+import org.apache.lucene.gdata.utils.ProvidedServiceStub;
+import org.apache.lucene.gdata.utils.ServiceFactoryStub;
+import org.apache.lucene.gdata.utils.StorageStub;
+import org.easymock.MockControl;
+
+import com.google.gdata.util.ParseException;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class TestAbstractFeedHandler extends TestCase {
+    private MockControl requestMockControl; 
+    
+    private HttpServletRequest mockRequest = null; 
+    
+    private String accountName = "acc"; 
+    private MockControl adminServiceMockControl;
+    private AdminService adminService = null;
+    private ServiceFactoryStub stub;
+    private String serviceName = StorageStub.SERVICE_TYPE_RETURN;
+    private static File incomingFeed = new File("src/test/org/apache/lucene/gdata/server/registry/TestEntityBuilderIncomingFeed.xml");
+    BufferedReader reader;
+    static{
+        
+        try {
+            
+            GDataServerRegistry.getRegistry().registerComponent(StorageStub.class,null);
+            GDataServerRegistry.getRegistry().registerComponent(ServiceFactoryStub.class,null);
+        } catch (RegistryException e) {
+            
+            e.printStackTrace();
+        }
+    }
+    protected void setUp() throws Exception {
+        super.setUp();
+        
+        GDataServerRegistry.getRegistry().registerService(new ProvidedServiceStub());
+       this.requestMockControl = MockControl.createControl(HttpServletRequest.class);
+       this.adminServiceMockControl = MockControl.createControl(AdminService.class);
+       this.adminService = (AdminService)this.adminServiceMockControl.getMock();
+       this.mockRequest = (HttpServletRequest)this.requestMockControl.getMock();
+       this.stub = (ServiceFactoryStub)GDataServerRegistry.getRegistry().lookup(ServiceFactory.class,ComponentType.SERVICEFACTORY);
+       this.stub.setAdminService(this.adminService);
+       this.reader =  new BufferedReader(new FileReader(incomingFeed));
+    }
+
+    protected void tearDown() throws Exception {
+        super.tearDown();
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.servlet.handler.AbstractFeedHandler.createFeedFromRequest(HttpServletRequest)'
+     */
+    public void testCreateFeedFromRequest() throws ParseException, IOException, FeedHandlerException {
+        
+        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
+                .getParameter("service"), this.serviceName);
+        this.requestMockControl.expectAndReturn(this.mockRequest.getReader(),this.reader);
+        this.requestMockControl.replay();
+        AbstractFeedHandler handler = new InsertFeedHandler();
+        try{
+        ServerBaseFeed feed = handler.createFeedFromRequest(this.mockRequest);
+        assertNotNull(feed.getId());
+        
+        }catch (Exception e) {
+            e.printStackTrace();
+            fail("unexpected exception -- "+e.getMessage());
+            
+        }
+        this.requestMockControl.verify();
+        this.requestMockControl.reset();
+        /*
+         * Test for not registered service
+         */
+        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
+                .getParameter("service"), "some other service");
+        this.requestMockControl.replay();
+         handler = new InsertFeedHandler();
+        try{
+        ServerBaseFeed feed = handler.createFeedFromRequest(this.mockRequest);
+        
+        fail(" exception expected");
+        }catch (FeedHandlerException e) {
+            e.printStackTrace();
+            assertEquals(HttpServletResponse.SC_NOT_FOUND,handler.getErrorCode());
+        }
+        this.requestMockControl.verify();
+        
+        this.requestMockControl.reset();
+        /*
+         * Test for IOException
+         */
+        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
+                .getParameter("service"), this.serviceName);
+        this.reader.close();
+        this.requestMockControl.expectAndReturn(this.mockRequest.getReader(),this.reader);
+        this.requestMockControl.replay();
+         handler = new InsertFeedHandler();
+        try{
+        ServerBaseFeed feed = handler.createFeedFromRequest(this.mockRequest);
+        
+        fail(" exception expected");
+        }catch (IOException e) {
+            e.printStackTrace();
+            assertEquals(HttpServletResponse.SC_BAD_REQUEST,handler.getErrorCode());
+        }
+        this.requestMockControl.verify();
+        
+        
+        
+        
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.servlet.handler.AbstractFeedHandler.createRequestedAccount(HttpServletRequest)'
+     */
+    public void testCreateRequestedAccount() throws IOException, ParseException, ServiceException {
+        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
+                .getParameter(AbstractFeedHandler.PARAMETER_ACCOUNT), this.accountName);
+        GDataAccount a = new GDataAccount();
+        a.setName("helloworld");
+        this.adminServiceMockControl.expectAndReturn(this.adminService.getAccount(this.accountName),a );
+        this.requestMockControl.replay();
+        this.adminServiceMockControl.replay();
+        AbstractFeedHandler handler = new InsertFeedHandler();
+        try{
+            
+            GDataAccount account = handler.createRequestedAccount(this.mockRequest);
+       
+        assertEquals(a,account);
+        
+        }catch (Exception e) {
+            e.printStackTrace();
+            fail("unexpected exception -- "+e.getMessage());
+            
+        }
+        this.requestMockControl.verify();
+        this.requestMockControl.reset();
+        this.adminServiceMockControl.verify();
+        this.adminServiceMockControl.reset();
+        
+        /*
+         *Test for service exception 
+         */
+        
+        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
+                .getParameter(AbstractFeedHandler.PARAMETER_ACCOUNT), this.accountName);
+        
+        a.setName("helloworld");
+        this.adminServiceMockControl.expectAndDefaultThrow(this.adminService.getAccount(this.accountName),new ServiceException(GDataResponse.BAD_REQUEST) );
+        this.requestMockControl.replay();
+        this.adminServiceMockControl.replay();
+         handler = new InsertFeedHandler();
+        try{
+            
+            GDataAccount account = handler.createRequestedAccount(this.mockRequest);
+       
+            fail(" exception expected ");
+        
+        }catch (Exception e) {
+            e.printStackTrace();
+            assertEquals(HttpServletResponse.SC_BAD_REQUEST,handler.getErrorCode());
+            
+        }
+        this.requestMockControl.verify();
+        this.requestMockControl.reset();
+        this.adminServiceMockControl.verify();
+        this.adminServiceMockControl.reset();
+        
+        
+        
+        
+        
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/servlet/handler/TestRequestAuthenticator.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/servlet/handler/TestRequestAuthenticator.java
new file mode 100644
index 0000000..ace688a
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/servlet/handler/TestRequestAuthenticator.java
@@ -0,0 +1,94 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.servlet.handler;
+
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServletRequest;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.gdata.server.authentication.AuthenticationController;
+import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
+import org.easymock.MockControl;
+
+public class TestRequestAuthenticator extends TestCase {
+    private MockControl requestMock;
+    private HttpServletRequest request;
+    private RequestAuthenticator authenticator;
+    private String tokenHeader;
+    private String token;
+    private Cookie authCookie;
+    
+    protected void setUp() throws Exception {
+    createMocks();
+    this.authenticator = new RequestAuthenticator();
+    this.token = "myToken";
+    this.tokenHeader = "GoogleLogin auth="+this.token;
+    this.authCookie = new Cookie("Auth",this.token);
+    }
+    protected void createMocks() {
+        this.requestMock = MockControl.createControl(HttpServletRequest.class);
+        this.request = (HttpServletRequest)this.requestMock.getMock();
+        
+    }
+    protected void tearDown() throws Exception {
+        GDataServerRegistry.getRegistry().destroy();
+    }
+    /*
+     * Test method for 'org.apache.lucene.gdata.servlet.handler.RequestAuthenticator.authenticateAccount(GDataRequest, AccountRole)'
+     */
+    public void testGetTokenFromRequest() {
+        // test token present
+        this.requestMock.expectAndDefaultReturn(this.request.getHeader(AuthenticationController.AUTHORIZATION_HEADER), this.tokenHeader);
+        this.requestMock.replay();
+        assertEquals(this.token,this.authenticator.getTokenFromRequest(this.request));
+        this.requestMock.verify();
+        this.requestMock.reset();
+        
+        // test token null / cookie present
+        this.requestMock.expectAndDefaultReturn(this.request.getHeader(AuthenticationController.AUTHORIZATION_HEADER), null);
+        this.requestMock.expectAndDefaultReturn(this.request.getCookies(), new Cookie[]{this.authCookie});
+        this.requestMock.replay();
+        assertEquals(this.token,this.authenticator.getTokenFromRequest(this.request));
+        this.requestMock.verify();
+        this.requestMock.reset();
+        
+        // test token null / cookie not present
+        this.requestMock.expectAndDefaultReturn(this.request.getHeader(AuthenticationController.AUTHORIZATION_HEADER), null);
+        this.requestMock.expectAndDefaultReturn(this.request.getCookies(), new Cookie[]{new Cookie("somekey","someValue")});
+        this.requestMock.replay();
+        assertNull(this.authenticator.getTokenFromRequest(this.request));
+        this.requestMock.verify();
+        this.requestMock.reset();
+        
+//      test token null / cookie array emtpy 
+        this.requestMock.expectAndDefaultReturn(this.request.getHeader(AuthenticationController.AUTHORIZATION_HEADER), null);
+        this.requestMock.expectAndDefaultReturn(this.request.getCookies(), new Cookie[]{});
+        this.requestMock.replay();
+        assertNull(this.authenticator.getTokenFromRequest(this.request));
+        this.requestMock.verify();
+        this.requestMock.reset();
+        
+//      test token null / cookie array null
+        this.requestMock.expectAndDefaultReturn(this.request.getHeader(AuthenticationController.AUTHORIZATION_HEADER), null);
+        this.requestMock.expectAndDefaultReturn(this.request.getCookies(), null);
+        this.requestMock.replay();
+        assertNull(this.authenticator.getTokenFromRequest(this.request));
+        this.requestMock.verify();
+        this.requestMock.reset();
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/TestIDGenerator.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/TestIDGenerator.java
new file mode 100644
index 0000000..f320d16
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/TestIDGenerator.java
@@ -0,0 +1,69 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.storage; 
+ 
+import java.util.ArrayList; 
+import java.util.List; 
+ 
+import junit.framework.TestCase; 
+ 
+import org.apache.lucene.gdata.storage.IDGenerator; 
+ 
+/** 
+ * @author Simon Willnauer 
+ * 
+ */ 
+public class TestIDGenerator extends TestCase { 
+    private IDGenerator idgen; 
+ 
+    private int initialCap = 100; 
+ 
+    @Override 
+    protected void setUp() throws Exception { 
+        this.idgen = new IDGenerator(this.initialCap); 
+         
+         
+    } 
+ 
+    @Override 
+    protected void tearDown() throws Exception {
+        
+        this.idgen.stopIDGenerator();
+       
+    } 
+ 
+    /** 
+     * Test method for 'org.apache.lucene.gdata.storage.IDGenerator.getUID()' 
+     * @throws InterruptedException  
+     */ 
+    public void testGetUID() throws InterruptedException { 
+         
+        List<String> idlist = new ArrayList<String>(); 
+        //TODO think about a better way to test this 
+        for (int i = 0; i < 1000; i++) { 
+            String id = this.idgen.getUID(); 
+            assertNotNull(id); 
+            assertFalse(idlist.contains(id)); 
+            idlist.add(id); 
+             
+                         
+             
+        } 
+ 
+    } 
+ 
+     
+} 
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/db4o/TestDb4oStorage.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/db4o/TestDb4oStorage.java
new file mode 100755
index 0000000..ff2d094
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/db4o/TestDb4oStorage.java
@@ -0,0 +1,1040 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.storage.db4o;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.data.ServerBaseFeed;
+import org.apache.lucene.gdata.server.registry.ProvidedServiceConfig;
+import org.apache.lucene.gdata.storage.ModificationConflictException;
+import org.apache.lucene.gdata.storage.Storage;
+import org.apache.lucene.gdata.storage.StorageController;
+import org.apache.lucene.gdata.storage.StorageException;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper.StorageOperation;
+import org.apache.lucene.gdata.utils.MultiThreadEntryStub;
+import org.apache.lucene.gdata.utils.Visitor;
+
+import com.db4o.ObjectContainer;
+import com.db4o.ObjectSet;
+import com.db4o.query.Query;
+import com.google.gdata.data.BaseEntry;
+import com.google.gdata.data.BaseFeed;
+import com.google.gdata.data.DateTime;
+import com.google.gdata.data.PlainTextConstruct;
+
+public class TestDb4oStorage extends TestCase {
+    private static final String FEEDID = "myFeed";
+
+    private static final String ACCOUNTNAME = "myAccount";
+
+    private static final String SERVICENAME = "myService";
+
+    DB4oController controller;
+
+    static volatile boolean fail = false;
+
+    protected void setUp() throws Exception {
+        this.controller = new DB4oController();
+        this.controller.setContainerPoolSize(2);
+        this.controller.setFilePath("test.yap");
+        this.controller.setRunAsServer(true);
+        this.controller.setPassword("");
+        this.controller.setUser("");
+        this.controller.setUseWeakReferences(true);
+        this.controller.setPort(0);
+        this.controller.initialize();
+        this.controller.visiteInitialize();
+        clearDB();
+    }
+
+    protected void tearDown() throws Exception {
+        clearDB();
+        fail = false;
+        this.controller.getStorage().close();
+        this.controller.visiteDestroy();
+        this.controller.destroy();
+        File dbFile = new File("test.yap");
+        assertTrue(dbFile.delete());
+    }
+
+    private void clearDB() {
+        ObjectContainer container = this.controller.releaseContainer();
+        ObjectSet set = container.get(new Object());
+
+        for (Object object : set) {
+            container.delete(object);
+        }
+        container.ext().purge();
+        container.close();
+    }
+
+    ObjectContainer getContainer() {
+        return this.controller.releaseContainer();
+    }
+
+   
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.storage.db4o.DB4oStorage.storeEntry(ServerBaseEntry)'
+     */
+    @SuppressWarnings("unchecked")
+    public void testStoreEntry() throws StorageException {
+        Storage storage = this.controller.getStorage();
+        try {
+            ServerBaseEntry e = createServerBaseEntry();
+            storage.storeEntry(e);
+            fail("excption exp. for feed for the entry");
+        } catch (StorageException e) {
+            //
+        }
+
+        try {
+
+            storage.storeEntry(null);
+            fail("entry is null");
+        } catch (StorageException e) {
+            //
+        }
+        ServerBaseEntry exEntry = new ServerBaseEntry();
+        exEntry.setFeedId("some");
+        try {
+
+            storage.storeEntry(exEntry);
+            fail("entry id is null");
+        } catch (StorageException e) {
+            //
+        }
+        exEntry.setId("someID");
+        exEntry.setFeedId(null);
+        try {
+
+            storage.storeEntry(exEntry);
+            fail("feed id is null");
+        } catch (StorageException e) {
+            //
+        }
+
+        storeServerBaseFeed();
+        ServerBaseEntry e = createServerBaseEntry();
+        storage.storeEntry(e);
+        ServerBaseEntry e1 = createServerBaseEntry();
+        storage.storeEntry(e1);
+
+        storage = this.controller.getStorage();
+        Query query = getContainer().query();
+        query.constrain(BaseEntry.class);
+        query.descend("id").constrain(e.getId());
+        ObjectSet resultSet = query.execute();
+        assertEquals(1, resultSet.size());
+        BaseEntry storedEntry = (BaseEntry) resultSet.next();
+        assertEquals("1", storedEntry.getVersionId());
+
+        ServerBaseFeed bFeed = new ServerBaseFeed();
+        bFeed.setItemsPerPage(25);
+        bFeed.setId(FEEDID);
+        bFeed.setStartIndex(1);
+        bFeed.setServiceType(SERVICENAME);
+        BaseFeed<BaseFeed, BaseEntry> feed = storage.getFeed(bFeed);
+        assertEquals(2, feed.getEntries().size());
+        assertEquals(e.getId(), feed.getEntries().get(1).getId()); // last post
+        // ->
+        // previously
+        // created
+        assertEquals(e1.getId(), feed.getEntries().get(0).getId()); // first pos
+        // -> last
+        // created
+        assertEquals(feed.getUpdated(), feed.getEntries().get(0).getUpdated());
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.storage.db4o.DB4oStorage.deleteEntry(ServerBaseEntry)'
+     */
+    public void testDeleteEntry() throws StorageException, InterruptedException {
+        ObjectContainer container = getContainer();
+        storeServerBaseFeed();
+        Storage storage = this.controller.getStorage();
+        
+        try {
+
+            storage.deleteEntry(null);
+            fail("entry is null");
+        } catch (StorageException e) {
+            //
+        }
+        ServerBaseEntry exEntry = new ServerBaseEntry();
+        exEntry.setFeedId("some");
+        try {
+
+            storage.deleteEntry(exEntry);
+            fail("entry id is null");
+        } catch (StorageException e) {
+            //
+        }
+        exEntry.setId("someID");
+        exEntry.setFeedId(null);
+        try {
+
+            storage.storeEntry(exEntry);
+            fail("feed id is null");
+        } catch (StorageException e) {
+            //
+        }
+        
+        
+        ServerBaseEntry e = createServerBaseEntry();
+        storage.storeEntry(e);
+        ServerBaseEntry e1 = createServerBaseEntry();
+        storage.storeEntry(e1);
+
+        storage.deleteEntry(e);
+
+        container.close();
+        container = getContainer();
+        Query query = container.query();
+        query.constrain(BaseEntry.class);
+        query.descend("id").constrain(e.getId());
+        ObjectSet resultSet = query.execute();
+        assertEquals(0, resultSet.size());
+
+        // #### test version matching
+        ServerBaseEntry eVersion = createServerBaseEntry();
+        storage.storeEntry(eVersion);
+        eVersion.setVersion(33);
+        try {
+            storage.deleteEntry(eVersion);
+            fail("version does not match");
+        } catch (Exception ex) {
+            // TODO: handle exception
+        }
+        try {
+            storage.deleteEntry(null);
+            fail("entry id is null");
+        } catch (Exception ex) {
+            // TODO: handle exception
+        }
+        storage = this.controller.getStorage();
+        storage.deleteEntry(e1);
+        container.close();
+        container = getContainer();
+        query = container.query();
+        query.constrain(BaseEntry.class);
+        query.descend("id").constrain(e1.getId());
+        resultSet = query.execute();
+        assertEquals(0, resultSet.size());
+
+        // ############ test concurrency
+
+        // ############ test concurrency
+        Object monitor = new Object();
+        AtomicBoolean reached = new AtomicBoolean(false);
+        MultiThreadEntryStub concuEntry = new MultiThreadEntryStub();
+        concuEntry.setId(System.currentTimeMillis() + "");
+        ProvidedServiceConfig conf = new ProvidedServiceConfig();
+        conf.setName(SERVICENAME);
+        concuEntry.setServiceConfig(conf);
+        concuEntry.setUpdated(DateTime.now());
+        concuEntry.setFeedId(FEEDID);
+
+        storage = this.controller.getStorage();
+
+        storage.storeEntry(concuEntry);
+        storage.close();
+        concuEntry.acceptGetVersionVisitor(getMonitorVisitor(monitor, reached));
+
+        Thread t1 = getDelThread(controller, concuEntry, false);
+
+        Thread t2 = getDelThread(controller, concuEntry, true);
+        t1.start();
+        /*
+         * Wait active -- not nice but works fine here wait until thread parked
+         */
+
+        while (true) {
+            synchronized (monitor) {
+                if (reached.get())
+                    break;
+                monitor.wait(10);
+            }
+        }
+        t2.start();
+        t2.join(800);
+        /*
+         * Wait active -- not nice but works fine here wake up the waiting
+         * thread
+         */
+        while (true) {
+            synchronized (monitor) {
+                if (!reached.get())
+                    break;
+                monitor.notifyAll();
+            }
+        }
+        t1.join(300);
+        if (fail)
+            fail("thread failed -- see stacktrace");
+
+        container.close();
+
+    }
+
+    private Visitor getMonitorVisitor(final Object monitor,
+            final AtomicBoolean reached) {
+        /*
+         * The executing thread stops at a defined position while holding the
+         * semaphore inside the storageImpl
+         */
+        return new Visitor() {
+            public void execute(Object[] o) {
+                synchronized (monitor) {
+                    try {
+                        reached.set(true);
+                        monitor.wait();
+                        reached.set(false);
+
+                    } catch (InterruptedException e) {
+                        //                   
+                    }
+                }
+            }
+        };
+    }
+
+    private Thread getDelThread(StorageController c, ServerBaseEntry e,
+            boolean conflictExpected) {
+        Thread t1 = new Thread(new Runner(c, e, conflictExpected,
+                StorageOperation.DELETE));
+        t1.setPriority(Thread.MAX_PRIORITY);
+        return t1;
+    }
+
+    private Thread getUpdThread(StorageController c, ServerBaseEntry e,
+            boolean conflictExpected) {
+        Thread t1 = new Thread(new Runner(c, e, conflictExpected,
+                StorageOperation.UPDATE));
+        t1.setPriority(Thread.MAX_PRIORITY);
+        return t1;
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.storage.db4o.DB4oStorage.updateEntry(ServerBaseEntry)'
+     */
+    public void testUpdateEntry() throws StorageException, InterruptedException {
+        storeServerBaseFeed();
+        Storage storage = this.controller.getStorage();
+        ServerBaseEntry exEntry = new ServerBaseEntry();
+        
+
+        try {
+
+            storage.updateEntry(null);
+            fail("entry is null");
+        } catch (StorageException e) {
+            //
+        }
+
+        try {
+
+            storage.updateEntry(exEntry);
+            fail("entry id is null");
+        } catch (StorageException e) {
+            //
+        }
+        exEntry.setId("someID");
+        try {
+
+            storage.updateEntry(exEntry);
+            fail("feed id is null");
+        } catch (StorageException e) {
+            //
+        }
+        
+        
+        
+        ServerBaseEntry e = createServerBaseEntry();
+        ServerBaseEntry e1 = createServerBaseEntry();
+        try {
+            storage.updateEntry(e);
+            fail("entry does not exist");
+        } catch (StorageException ex) {
+            ex.printStackTrace();
+        }
+        storage.storeEntry(e);
+
+        storage = this.controller.getStorage();
+
+        storage.storeEntry(e1);
+        ServerBaseEntry e2 = createServerBaseEntry();
+        e2.setId(e.getId());
+        e2.setTitle(new PlainTextConstruct("new"));
+        e2.setUpdated(DateTime.now());
+        storage.updateEntry(e2);
+        ObjectContainer container = getContainer();
+        Query query = container.query();
+        query.constrain(BaseEntry.class);
+        query.descend("id").constrain(e.getId());
+        ObjectSet resultSet = query.execute();
+        assertEquals(1, resultSet.size());
+        BaseEntry result = (BaseEntry) resultSet.next();
+        assertEquals("new", result.getTitle().getPlainText());
+        assertEquals("2", result.getVersionId());
+
+        ServerBaseFeed bFeed = new ServerBaseFeed();
+        bFeed.setItemsPerPage(25);
+        bFeed.setId(FEEDID);
+        bFeed.setStartIndex(1);
+        bFeed.setServiceType(SERVICENAME);
+        storage = this.controller.getStorage();
+        BaseFeed<BaseFeed, BaseEntry> feed = storage.getFeed(bFeed);
+
+        assertEquals(2, feed.getEntries().size());
+        assertEquals(e.getId(), feed.getEntries().get(0).getId());
+        assertEquals(feed.getUpdated(), feed.getEntries().get(0).getUpdated());
+
+        storage = this.controller.getStorage();
+        storage.storeEntry(e);
+
+        e2.setVersion(5);
+        try {
+            storage.updateEntry(e2);
+            fail("version does not match");
+        } catch (Exception ex) {
+            // TODO: handle exception
+        }
+
+        // ############ test concurrency
+        Object monitor = new Object();
+        AtomicBoolean reached = new AtomicBoolean(false);
+
+        MultiThreadEntryStub concuEntry = new MultiThreadEntryStub();
+        concuEntry.setId(System.currentTimeMillis() + "");
+        ProvidedServiceConfig conf = new ProvidedServiceConfig();
+        conf.setName(SERVICENAME);
+        concuEntry.setServiceConfig(conf);
+        concuEntry.setUpdated(DateTime.now());
+        concuEntry.setFeedId(FEEDID);
+
+        storage = this.controller.getStorage();
+
+        storage.storeEntry(concuEntry);
+        storage.close();
+        concuEntry.acceptGetEntryVisitor(getMonitorVisitor(monitor, reached));
+
+        Thread t1 = getUpdThread(controller, concuEntry, false);
+
+        Thread t2 = getUpdThread(controller, concuEntry, true);
+        t1.start();
+        /*
+         * Wait active -- not nice but works fine here wait until thread parked
+         */
+
+        while (true) {
+            synchronized (monitor) {
+                if (reached.get())
+                    break;
+                monitor.wait(10);
+            }
+        }
+        t2.start();
+        t2.join(800);
+        /*
+         * Wait active -- not nice but works fine here wake up the waiting
+         * thread
+         */
+        while (true) {
+            synchronized (monitor) {
+                if (!reached.get())
+                    break;
+                monitor.notifyAll();
+            }
+        }
+        t1.join(300);
+        if (fail)
+            fail("thread failed -- see stacktrace");
+        container.close();
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.storage.db4o.DB4oStorage.getFeed(ServerBaseFeed)'
+     */
+    public void testGetFeed() throws StorageException {
+        storeServerBaseFeed();
+        Storage storage = this.controller.getStorage();
+        ServerBaseFeed feed = new ServerBaseFeed();
+        feed.setItemsPerPage(25);
+        feed.setStartIndex(1);
+        feed.setServiceType(SERVICENAME);
+        try{
+        storage.getFeed(feed);
+        fail("feedid is null");
+        }catch (StorageException e) {
+            // 
+        }
+        
+        feed.setId(FEEDID);
+        BaseFeed result = storage.getFeed(feed);
+        assertNotNull(result);
+        assertEquals(0, result.getEntries().size());
+        List<String> idlist = new ArrayList<String>(30);
+        ServerBaseEntry e1 = null;
+        for (int i = 0; i < 30; i++) {
+            e1 = createServerBaseEntry();
+            storage.storeEntry(e1);
+            idlist.add(0, e1.getId());
+        }
+        String firstId = e1.getId();
+
+        storage = this.controller.getStorage();
+        result = storage.getFeed(feed);
+        assertNotNull(result);
+        assertEquals(25, result.getEntries().size());
+        for (int i = 0; i < 25; i++) {
+            assertEquals(idlist.get(i),
+                    ((BaseEntry) result.getEntries().get(i)).getId());
+        }
+
+        storage = this.controller.getStorage();
+        feed.setItemsPerPage(5);
+        result = storage.getFeed(feed);
+        assertNotNull(result);
+        assertEquals(5, result.getEntries().size());
+        for (int i = 0; i < 5; i++) {
+            assertEquals(idlist.get(i),
+                    ((BaseEntry) result.getEntries().get(i)).getId());
+        }
+
+        storage = this.controller.getStorage();
+        feed.setItemsPerPage(1);
+        feed.setStartIndex(1);
+        result = storage.getFeed(feed);
+        assertNotNull(result);
+        assertEquals(1, result.getEntries().size());
+
+        assertEquals(idlist.get(0), ((BaseEntry) result.getEntries().get(0))
+                .getId());
+
+        storage = this.controller.getStorage();
+        feed.setItemsPerPage(50);
+        feed.setStartIndex(28);
+        result = storage.getFeed(feed);
+        assertNotNull(result);
+        assertEquals(3, result.getEntries().size());
+
+        assertEquals(idlist.get(27), ((BaseEntry) result.getEntries().get(0))
+                .getId());
+        assertEquals(idlist.get(28), ((BaseEntry) result.getEntries().get(1))
+                .getId());
+        assertEquals(idlist.get(29), ((BaseEntry) result.getEntries().get(2))
+                .getId());
+
+        storage = this.controller.getStorage();
+        feed.setItemsPerPage(50);
+        feed.setStartIndex(30);
+        result = storage.getFeed(feed);
+        assertNotNull(result);
+        assertEquals(1, result.getEntries().size());
+
+        assertEquals(idlist.get(29), ((BaseEntry) result.getEntries().get(0))
+                .getId());
+
+        // assertNotSame(firstId,((BaseEntry)result.getEntries().get(0)).getId());
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.storage.db4o.DB4oStorage.getEntry(ServerBaseEntry)'
+     */
+    public void testGetEntry() throws StorageException {
+        storeServerBaseFeed();
+        Storage storage = this.controller.getStorage();
+        ServerBaseEntry exEntry = createServerBaseEntry();
+        exEntry.setId(null);
+        try{
+        storage.getEntry(exEntry);
+        fail("id is null");
+        }catch (StorageException e) {
+
+        }
+        ServerBaseEntry e = createServerBaseEntry();
+        storage.storeEntry(e);
+        ServerBaseEntry e1 = createServerBaseEntry();
+        storage.storeEntry(e1);
+        
+        storage = this.controller.getStorage();
+        BaseEntry result = storage.getEntry(e);
+        assertNotNull(result);
+        assertEquals(e.getId(), result.getId());
+        try {
+            e1.setId("hello");
+            result = storage.getEntry(e1);
+            fail("no such entry");
+        } catch (StorageException ex) {
+            ex.printStackTrace();
+        }
+
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.storage.db4o.DB4oStorage.storeAccount(GDataAccount)'
+     */
+    public void testStoreAccount() throws StorageException {
+        GDataAccount account = new GDataAccount();
+        account.setName("simon");
+        account.setPassword("somepass");
+        Storage storage = this.controller.getStorage();
+        storage.storeAccount(account);
+        ObjectContainer container = getContainer();
+        Query q = container.query();
+        q.constrain(GDataAccount.class);
+        q.descend("name").constrain(account.getName());
+        ObjectSet set = q.execute();
+        assertEquals(1, set.size());
+        assertEquals(account.getPassword(), ((GDataAccount) set.next())
+                .getPassword());
+        try {
+            storage.storeAccount(account);
+            fail("Account already stored");
+        } catch (Exception e) {
+
+        }
+        container.close();
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.storage.db4o.DB4oStorage.updateAccount(GDataAccount)'
+     */
+    public void testUpdateAccount() throws StorageException {
+        GDataAccount account = new GDataAccount();
+        account.setName("simon");
+        account.setPassword("somepass");
+
+        Storage storage = this.controller.getStorage();
+        try {
+            storage.updateAccount(account);
+            fail("Account does not exist");
+        } catch (Exception e) {
+            //
+        }
+        try {
+            storage.updateAccount(null);
+            fail("Account is null");
+        } catch (Exception e) {
+            //
+        }
+        storage.storeAccount(account);
+        ObjectContainer container = getContainer();
+        Query q = container.query();
+        q.constrain(GDataAccount.class);
+        q.descend("name").constrain(account.getName());
+        ObjectSet set = q.execute();
+        assertEquals(1, set.size());
+        assertEquals(account.getPassword(), ((GDataAccount) set.next())
+                .getPassword());
+        account = new GDataAccount();
+        account.setName("simon");
+        account.setPassword("newPass");
+        storage.updateAccount(account);
+        container.close();
+        container = getContainer();
+        q = container.query();
+        q.constrain(GDataAccount.class);
+        q.descend("name").constrain(account.getName());
+        set = q.execute();
+        assertEquals(1, set.size());
+        assertEquals(account.getPassword(), ((GDataAccount) set.next())
+                .getPassword());
+        container.close();
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.storage.db4o.DB4oStorage.deleteAccount(String)'
+     */
+    public void testDeleteAccount() throws StorageException {
+        GDataAccount account = new GDataAccount();
+        account.setName("simon");
+        account.setPassword("somepass");
+        Storage storage = this.controller.getStorage();
+        storage.storeAccount(account);
+        ObjectContainer container = getContainer();
+        Query q = container.query();
+        q.constrain(GDataAccount.class);
+        q.descend("name").constrain(account.getName());
+        ObjectSet set = q.execute();
+        assertEquals(1, set.size());
+
+        storage.deleteAccount(account.getName());
+        container.close();
+        container = getContainer();
+        q = container.query();
+        q.constrain(GDataAccount.class);
+        q.descend("name").constrain(account.getName());
+        set = q.execute();
+        assertEquals(0, set.size());
+        try {
+            storage.deleteAccount("notstored");
+            fail("account not stored");
+        } catch (Exception e) {
+            // 
+        }
+        try {
+            storage.deleteAccount(null);
+            fail("name is null");
+        } catch (Exception e) {
+            // 
+        }
+        container.close();
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.storage.db4o.DB4oStorage.storeFeed(ServerBaseFeed,
+     * String)'
+     */
+    public void testStoreFeed() throws StorageException {
+        ObjectContainer container = getContainer();
+        ServerBaseFeed feed = new ServerBaseFeed();
+        feed.setId(FEEDID);
+        ProvidedServiceConfig conf = new ProvidedServiceConfig();
+        conf.setName(SERVICENAME);
+        feed.setServiceConfig(conf);
+
+        Storage storage = this.controller.getStorage();
+        try {
+            storage.storeFeed(feed, ACCOUNTNAME);
+            fail("no accoutn stored");
+        } catch (Exception e) {
+            // 
+        }
+        GDataAccount account = new GDataAccount();
+        account.setName(ACCOUNTNAME);
+        account.setPassword("somePass");
+        container.set(account);
+        container.commit();
+        container.close();
+        storage.storeFeed(feed, ACCOUNTNAME);
+
+        container = getContainer();
+        Query query = container.query();
+        query.constrain(ServerBaseFeed.class);
+        query.descend("feed").descend("id").constrain(FEEDID);
+        ObjectSet set = query.execute();
+        assertEquals(1, set.size());
+
+        assertEquals(feed.getId(), ((ServerBaseFeed) set.next()).getId());
+        container.close();
+
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.storage.db4o.DB4oStorage.deleteFeed(String)'
+     */
+    public void testDeleteFeed() throws StorageException {
+
+        ServerBaseFeed feed = new ServerBaseFeed();
+        feed.setId(FEEDID);
+        GDataAccount account = new GDataAccount();
+        account.setName(ACCOUNTNAME);
+        account.setPassword("somePass");
+        ObjectContainer container = getContainer();
+        container.set(account);
+        container.commit();
+        container.close();
+        Storage storage = this.controller.getStorage();
+        ProvidedServiceConfig conf = new ProvidedServiceConfig();
+        conf.setName(SERVICENAME);
+        feed.setServiceConfig(conf);
+        storage.storeFeed(feed, ACCOUNTNAME);
+
+        storage.deleteFeed(FEEDID);
+        container = getContainer();
+        Query query = container.query();
+        query.constrain(ServerBaseFeed.class);
+        query.descend("feed").descend("id").constrain(FEEDID);
+        ObjectSet set = query.execute();
+        assertEquals(0, set.size());
+
+        query = getContainer().query();
+        query.constrain(BaseFeed.class);
+        query.descend("id").constrain(FEEDID);
+        set = query.execute();
+        assertEquals(0, set.size());
+        container.close();
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.storage.db4o.DB4oStorage.getServiceForFeed(String)'
+     */
+    public void testGetServiceForFeed() throws StorageException {
+        ServerBaseFeed feed = new ServerBaseFeed();
+        ProvidedServiceConfig conf = new ProvidedServiceConfig();
+        conf.setName(SERVICENAME);
+        feed.setServiceConfig(conf);
+        feed.setId(FEEDID);
+        GDataAccount account = new GDataAccount();
+        account.setName(ACCOUNTNAME);
+        account.setPassword("somePass");
+        ObjectContainer container = getContainer();
+        container.set(account);
+        container.commit();
+        container.close();
+        Storage storage = this.controller.getStorage();
+        storage.storeFeed(feed, ACCOUNTNAME);
+
+        assertEquals(SERVICENAME, storage.getServiceForFeed(FEEDID));
+        try {
+            storage.getServiceForFeed(null);
+            fail("ID is null");
+        } catch (Exception e) {
+            // 
+        }
+
+        try {
+            storage.getServiceForFeed("someOtherId");
+            fail("feed for id is not stored");
+        } catch (Exception e) {
+            // 
+        }
+
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.storage.db4o.DB4oStorage.getAccount(String)'
+     */
+    public void testGetAccount() throws StorageException {
+        GDataAccount account = new GDataAccount();
+        account.setName(ACCOUNTNAME);
+        account.setPassword("somePass");
+        ObjectContainer container = getContainer();
+        container.set(account);
+        container.commit();
+        container.close();
+
+        Storage storage = this.controller.getStorage();
+        assertNotNull(storage.getAccount(ACCOUNTNAME));
+        assertEquals(account.getPassword(), storage.getAccount(ACCOUNTNAME)
+                .getPassword());
+        try {
+            storage.getAccount(null);
+            fail("accountname is null");
+        } catch (Exception e) {
+            // 
+        }
+        try {
+            storage.getAccount("someOtherAccount");
+            fail("accountname is not stored");
+        } catch (Exception e) {
+            // 
+        }
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.storage.db4o.DB4oStorage.updateFeed(ServerBaseFeed,
+     * String)'
+     */
+    public void testUpdateFeed() throws StorageException {
+        ObjectContainer container = getContainer();
+        ServerBaseFeed feed = new ServerBaseFeed();
+        ProvidedServiceConfig conf = new ProvidedServiceConfig();
+        conf.setName(SERVICENAME);
+        feed.setId(FEEDID);
+        feed.setServiceConfig(conf);
+        Storage storage = this.controller.getStorage();
+        GDataAccount account = new GDataAccount();
+        account.setName(ACCOUNTNAME);
+        account.setPassword("somePass");
+        container.set(account);
+        container.commit();
+        container.close();
+        storage.storeFeed(feed, ACCOUNTNAME);
+        assertNull(feed.getTitle());
+        ServerBaseFeed feedU = new ServerBaseFeed();
+        feedU.setServiceConfig(conf);
+        feedU.setId(FEEDID);
+        feedU.setTitle(new PlainTextConstruct("someText"));
+        feedU.setServiceType(SERVICENAME);
+
+        storage.updateFeed(feedU, ACCOUNTNAME);
+        ServerBaseFeed requestFeed = new ServerBaseFeed();
+        requestFeed.setId(FEEDID);
+        requestFeed.setServiceType(SERVICENAME);
+        assertNotNull(storage.getFeed(requestFeed));
+        assertEquals(feedU.getTitle(), storage.getFeed(requestFeed).getTitle());
+        try {
+            storage.updateFeed(null, ACCOUNTNAME);
+            fail("feed is null");
+        } catch (Exception e) {
+            // 
+        }
+        try {
+            storage.updateFeed(feedU, null);
+            fail("accountname is null");
+        } catch (Exception e) {
+            // 
+        }
+        try {
+            feedU.setServiceType(null);
+            storage.updateFeed(feedU, ACCOUNTNAME);
+            fail("servicetype is null");
+        } catch (Exception e) {
+            // 
+        }
+
+    }
+
+    private static ServerBaseEntry createServerBaseEntry() {
+        ServerBaseEntry e = new ServerBaseEntry();
+        e.setId(System.currentTimeMillis() + "");
+        ProvidedServiceConfig conf = new ProvidedServiceConfig();
+        conf.setName(SERVICENAME);
+        e.setServiceConfig(conf);
+        e.setUpdated(DateTime.now());
+        e.setFeedId(FEEDID);
+        try {
+            Thread.sleep(2);
+        } catch (InterruptedException e1) {
+
+            e1.printStackTrace();
+        }
+        return e;
+    }
+
+    private ServerBaseFeed storeServerBaseFeed() {
+        ServerBaseFeed f = new ServerBaseFeed();
+        ProvidedServiceConfig conf = new ProvidedServiceConfig();
+        conf.setName(SERVICENAME);
+        f.setServiceConfig(conf);
+        f.setId(System.currentTimeMillis() + "");
+        f.setId(FEEDID);
+        f.setUpdated(DateTime.now());
+        ObjectContainer con = this.controller.releaseContainer();
+        con.set(f);
+        con.commit();
+
+        con.close();
+        return f;
+    }
+
+    static class Runner implements Runnable {
+        Storage s;
+
+        StorageController c;
+
+        ServerBaseEntry e;
+
+        boolean expConf;
+
+        StorageOperation op;
+
+        public Runner(StorageController c, ServerBaseEntry e,
+                boolean expectConflict, StorageOperation op) {
+
+            this.c = c;
+
+            this.e = e;
+            this.expConf = expectConflict;
+            this.op = op;
+
+        }
+
+        public void run() {
+            try {
+                ((DB4oController) this.c).visiteInitialize();
+                this.s = this.c.getStorage();
+            } catch (StorageException e1) {
+
+                e1.printStackTrace();
+            }
+            try {
+                if (this.op == StorageOperation.DELETE)
+                    this.s.deleteEntry(e);
+                if (this.op == StorageOperation.UPDATE)
+                    this.s.updateEntry(e);
+                if (expConf)
+                    fail = true;
+            } catch (ModificationConflictException ex) {
+                if (!expConf)
+                    fail = true;
+                ex.printStackTrace();
+
+            } catch (StorageException ex) {
+                ex.printStackTrace();
+                fail = true;
+            } finally {
+                ((DB4oController) this.c).visiteDestroy();
+            }
+
+        }
+    }
+
+    public void testFeedLastModified() {
+        ServerBaseFeed feed = storeServerBaseFeed();
+        Storage s = this.controller.getStorage();
+        assertEquals(feed.getUpdated().getValue(), s
+                .getFeedLastModified(FEEDID).longValue());
+        try {
+            s.getFeedLastModified(null);
+            fail("id is null");
+        } catch (StorageException e) {
+
+        }
+        try {
+            s.getFeedLastModified("someOtherid");
+            fail("no such feed");
+        } catch (StorageException e) {
+
+        }
+
+    }
+
+    public void testEntryLastModified() {
+        ServerBaseFeed feed = storeServerBaseFeed();
+        Storage s = this.controller.getStorage();
+        ServerBaseEntry en = createServerBaseEntry();
+        s.storeEntry(en);
+        assertEquals(en.getUpdated().getValue(), s.getEntryLastModified(
+                en.getId(), FEEDID).longValue());
+        try {
+            s.getEntryLastModified(null, null);
+            fail("id is null");
+        } catch (StorageException e) {
+
+        }
+        try {
+            s.getEntryLastModified("someOtherid", "notinstorage");
+            fail("no such Entry");
+        } catch (StorageException e) {
+
+        }
+
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/db4o/TestObjectServerDecorator.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/db4o/TestObjectServerDecorator.java
new file mode 100755
index 0000000..4004fa9
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/db4o/TestObjectServerDecorator.java
@@ -0,0 +1,59 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.storage.db4o;
+
+import java.io.File;
+import java.lang.reflect.Proxy;
+
+import com.db4o.Db4o;
+import com.db4o.ObjectContainer;
+import com.db4o.ObjectServer;
+
+import junit.framework.TestCase;
+
+public class TestObjectServerDecorator extends TestCase {
+    ObjectServer decorator;
+    ObjectServer actualServer;
+    String dbFile = "test.yap";
+    protected void setUp() throws Exception {
+        decorator = (ObjectServer) Proxy.newProxyInstance(this.getClass().getClassLoader(),new Class[]{ObjectServer.class},new ObjectServerDecorator("u","p","127.0.0.1",10101));
+        actualServer= Db4o.openServer(dbFile,10101);
+        actualServer.grantAccess("u","p");
+        
+    }
+
+    protected void tearDown() throws Exception {
+        actualServer.close();
+        File dbF = new File(dbFile);
+        assertTrue(dbF.delete());
+        
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.storage.db4o.ObjectServerDecorator.invoke(Object, Method, Object[])'
+     */
+    public void testInvoke() {
+        assertFalse(this.decorator.close());
+        assertNull(this.decorator.ext());
+        assertEquals(0,this.decorator.hashCode());
+        ObjectContainer container = this.decorator.openClient(); 
+        assertNotNull(container);
+        assertTrue(this.decorator.openClient()instanceof ObjectContainer);
+        container.close();
+        
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/StorageCoreControllerStub.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/StorageCoreControllerStub.java
new file mode 100755
index 0000000..e648520
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/StorageCoreControllerStub.java
@@ -0,0 +1,211 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.storage.lucenestorage;
+
+import java.io.IOException;
+import java.security.NoSuchAlgorithmException;
+
+import org.apache.lucene.gdata.server.registry.Component;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+import org.apache.lucene.gdata.storage.IDGenerator;
+import org.apache.lucene.gdata.storage.Storage;
+import org.apache.lucene.gdata.storage.StorageException;
+import org.apache.lucene.gdata.utils.ReferenceCounter;
+import org.apache.lucene.index.IndexModifier;
+import org.apache.lucene.store.Directory;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+@Component(componentType = ComponentType.STORAGECONTROLLER)
+public class StorageCoreControllerStub extends StorageCoreController {
+    private final IDGenerator idGenerator;
+
+
+    public StorageCoreControllerStub() throws IOException, StorageException {
+        try{
+            this.idGenerator = new IDGenerator(5);
+        }catch (NoSuchAlgorithmException e) {
+            throw new StorageException(e);
+        }
+       
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController#createIndexModifier()
+     */
+    @Override
+    protected IndexModifier createIndexModifier() throws IOException {
+        
+        return null;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController#forceWrite()
+     */
+    @Override
+    public void forceWrite() throws IOException {
+        
+        
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController#getDirectory()
+     */
+    @Override
+    protected Directory getDirectory() {
+        
+        return null;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController#getBufferSize()
+     */
+    @Override
+    public int getBufferSize() {
+        
+        return 1;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController#getStorageModifier()
+     */
+    @Override
+    protected StorageModifier getStorageModifier() {
+        
+        try {
+            return new StorageModifierStub();
+        } catch (IOException e) {
+            
+            e.printStackTrace();
+        } catch (StorageException e) {
+            
+            e.printStackTrace();
+        }
+        return null;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController#getPersistFactor()
+     */
+    @Override
+    public int getPersistFactor() {
+        
+        return 1;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController#getStorageQuery()
+     */
+    @Override
+    protected ReferenceCounter<StorageQuery> getStorageQuery() {
+        
+        ReferenceCounter<StorageQuery> retVal =  new ReferenceCounter<StorageQuery>(new StorageQueryStub(null,null)){
+
+            @Override
+            protected void close() {
+                //
+            }
+            
+        };
+        retVal.increamentReference();
+        retVal.increamentReference();
+        return retVal;
+        
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController#registerNewStorageQuery()
+     */
+    @Override
+    protected void registerNewStorageQuery() throws IOException {
+        
+       
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController#releaseId()
+     */
+    @Override
+    public synchronized String releaseId() throws StorageException {
+        
+        try {
+            return this.idGenerator.getUID();
+        } catch (InterruptedException e) {
+            
+          throw new StorageException(e);
+        } 
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController#releaseNewStorageBuffer()
+     */
+    @Override
+    protected StorageBuffer releaseNewStorageBuffer() {
+        
+        return null;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController#setBufferSize(int)
+     */
+    @Override
+    public void setBufferSize(int storageBufferSize) {
+        
+        
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController#setPersistFactor(int)
+     */
+    @Override
+    public void setPersistFactor(int storagePersistFactor) {
+        
+       
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController#destroy()
+     */
+    @Override
+    public void destroy() {
+        
+        this.idGenerator.stopIDGenerator();
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController#getStorage()
+     */
+    @Override
+    public Storage getStorage() throws StorageException {
+        
+        return new StorageImplementation();
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController#initialize()
+     */
+    @Override
+    public void initialize() {
+//        this.setStorageDir(new RAMDirectory());
+//        super.initialize();
+    }
+
+   
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/StorageModifierStub.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/StorageModifierStub.java
new file mode 100644
index 0000000..b521dcd
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/StorageModifierStub.java
@@ -0,0 +1,169 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.storage.lucenestorage;
+
+import java.io.IOException;
+
+import org.apache.lucene.analysis.standard.StandardAnalyzer;
+import org.apache.lucene.gdata.storage.StorageException;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageBuffer;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageModifier;
+import org.apache.lucene.gdata.utils.StorageControllerStub;
+import org.apache.lucene.index.IndexModifier;
+import org.apache.lucene.store.RAMDirectory;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class StorageModifierStub extends StorageModifier {
+    public boolean throwException = false;
+    public StorageModifierStub() throws IOException, StorageException{
+        super(new StorageCoreControllerStub(), new IndexModifier(new RAMDirectory(),new StandardAnalyzer(),true), new StorageBuffer(1),1, 1);
+    }
+    /**
+     * @param controller
+     * @param modifier
+     * @param buffer
+     * @param persitsFactor
+     * @param optimizeInterval
+     * @throws IOException 
+     * @throws StorageException 
+     */
+    public StorageModifierStub(StorageCoreController controller,
+            IndexModifier modifier, StorageBuffer buffer, int persitsFactor,
+            int optimizeInterval) throws IOException, StorageException {
+        
+        super(new StorageCoreControllerStub(), new IndexModifier(new RAMDirectory(),new StandardAnalyzer(),true), new StorageBuffer(1),1, 1);
+        
+        // TODO Auto-generated constructor stub
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier#close()
+     */
+    @Override
+    protected void close() throws IOException {
+        if(throwException)
+            throw new IOException();
+        
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier#createAccount(org.apache.lucene.gdata.storage.lucenestorage.StorageAccountWrapper)
+     */
+    @Override
+    public void createAccount(StorageAccountWrapper account) throws StorageException {
+        if(throwException)
+            throw new StorageException();
+        
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier#createFeed(org.apache.lucene.gdata.storage.lucenestorage.StorageFeedWrapper)
+     */
+    @Override
+    public void createFeed(StorageFeedWrapper wrapper) throws StorageException {
+        if(throwException)
+            throw new StorageException();
+        
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier#deleteAccount(java.lang.String)
+     */
+    @Override
+    public void deleteAccount(String accountName) throws StorageException {
+        if(throwException)
+            throw new StorageException();
+        
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier#deleteEntry(org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper)
+     */
+    @Override
+    public void deleteEntry(StorageEntryWrapper wrapper) throws StorageException {
+        if(throwException)
+            throw new StorageException();
+        
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier#deleteFeed(java.lang.String)
+     */
+    @Override
+    public void deleteFeed(String feedId) throws StorageException {
+        if(throwException)
+            throw new StorageException();
+        
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier#forceWrite()
+     */
+    @Override
+   public void forceWrite() throws IOException {
+        if(throwException)
+            throw new IOException();
+        
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier#insertEntry(org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper)
+     */
+    @Override
+    public void insertEntry(StorageEntryWrapper wrapper) throws StorageException {
+        if(throwException)
+            throw new StorageException();
+        
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier#updateAccount(org.apache.lucene.gdata.storage.lucenestorage.StorageAccountWrapper)
+     */
+    @Override
+    public void updateAccount(StorageAccountWrapper user) throws StorageException {
+        if(throwException)
+            throw new StorageException();
+        
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier#updateEntry(org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper)
+     */
+    @Override
+    public void updateEntry(StorageEntryWrapper wrapper) throws StorageException {
+        if(throwException)
+            throw new StorageException();
+        if(wrapper != null)
+            wrapper.getEntry();
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier#updateFeed(org.apache.lucene.gdata.storage.lucenestorage.StorageFeedWrapper)
+     */
+    @Override
+    public void updateFeed(StorageFeedWrapper wrapper) throws StorageException {
+        if(throwException)
+            throw new StorageException();   
+        
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/StorageQueryStub.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/StorageQueryStub.java
new file mode 100755
index 0000000..707912e
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/StorageQueryStub.java
@@ -0,0 +1,157 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.storage.lucenestorage;
+
+import java.io.IOException;
+import java.util.List;
+
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.server.registry.ProvidedService;
+import org.apache.lucene.gdata.storage.StorageException;
+import org.apache.lucene.search.Searcher;
+
+import com.google.gdata.data.BaseEntry;
+import com.google.gdata.data.BaseFeed;
+import com.google.gdata.util.ParseException;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class StorageQueryStub extends StorageQuery {
+
+    public boolean booleanReturn = true;
+
+    /**
+     * @param buffer
+     * @param searcher
+     */
+    public StorageQueryStub(StorageBuffer buffer, Searcher searcher) {
+        super(buffer, searcher);
+        // TODO Auto-generated constructor stub
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageQuery#checkEntryVersion(java.lang.String, java.lang.String, int)
+     */
+    @Override
+    protected boolean checkEntryVersion(String id, String feedId, int version) throws IOException {
+        
+        return booleanReturn;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageQuery#close()
+     */
+    @Override
+    public void close() throws IOException {
+        
+        super.close();
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageQuery#entryQuery(java.util.List, java.lang.String, org.apache.lucene.gdata.server.registry.ProvidedService)
+     */
+    @Override
+    public List<BaseEntry> entryQuery(List<String> entryIds, String feedId, ProvidedService config) throws IOException, ParseException {
+        
+        return null;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageQuery#getAccountNameForFeedId(java.lang.String)
+     */
+    @Override
+    public String getAccountNameForFeedId(String feedId) throws IOException {
+        
+        return null;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageQuery#getEntryLastModified(java.lang.String, java.lang.String)
+     */
+    @Override
+    protected long getEntryLastModified(String entryId, String feedId) throws IOException, StorageException {
+        
+        return System.currentTimeMillis();
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageQuery#getFeedLastModified(java.lang.String)
+     */
+    @Override
+    protected long getFeedLastModified(String feedId) throws IOException {
+        
+        return System.currentTimeMillis();
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageQuery#getLatestFeedQuery(java.lang.String, int, int, org.apache.lucene.gdata.server.registry.ProvidedService)
+     */
+    @Override
+    public BaseFeed getLatestFeedQuery(String feedId, int resultCount, int startIndex, ProvidedService config) throws IOException, ParseException {
+        
+        return null;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageQuery#getService(java.lang.String)
+     */
+    @Override
+    public String getService(String feedID) throws IOException {
+        
+        return null;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageQuery#getUser(java.lang.String)
+     */
+    @Override
+    public GDataAccount getUser(String username) throws IOException {
+        
+        return null;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageQuery#isEntryStored(java.lang.String, java.lang.String)
+     */
+    @Override
+    protected boolean isEntryStored(String entryId, String feedId) throws IOException {
+        
+        return booleanReturn;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageQuery#isFeedStored(java.lang.String)
+     */
+    @Override
+    public boolean isFeedStored(String feedId) throws IOException {
+        
+        return booleanReturn;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageQuery#singleEntryQuery(java.lang.String, java.lang.String, org.apache.lucene.gdata.server.registry.ProvidedService)
+     */
+    @Override
+    public BaseEntry singleEntryQuery(String entryId, String feedId, ProvidedService config) throws IOException, ParseException {
+        
+        return null;
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/TestModifiedEntryFilter.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/TestModifiedEntryFilter.java
new file mode 100644
index 0000000..2d94209
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/TestModifiedEntryFilter.java
@@ -0,0 +1,70 @@
+package org.apache.lucene.gdata.storage.lucenestorage; 
+ 
+import java.io.IOException; 
+import java.util.ArrayList; 
+import java.util.List; 
+ 
+import junit.framework.TestCase; 
+ 
+import org.apache.lucene.analysis.standard.StandardAnalyzer; 
+import org.apache.lucene.document.Document; 
+import org.apache.lucene.document.Field; 
+import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper; 
+import org.apache.lucene.gdata.utils.ModifiedEntryFilter;
+import org.apache.lucene.index.IndexReader; 
+import org.apache.lucene.index.IndexWriter; 
+import org.apache.lucene.index.Term; 
+import org.apache.lucene.search.Hits; 
+import org.apache.lucene.search.IndexSearcher; 
+import org.apache.lucene.search.Query; 
+import org.apache.lucene.search.Searcher; 
+import org.apache.lucene.search.TermQuery; 
+import org.apache.lucene.store.RAMDirectory; 
+ 
+public class TestModifiedEntryFilter extends TestCase { 
+    IndexWriter writer; 
+    IndexReader reader; 
+    List<String> excludeList; 
+    String feedID = "feed"; 
+    String fieldFeedId = "feedID"; 
+    protected void setUp() throws Exception { 
+        RAMDirectory dir = new RAMDirectory(); 
+        this.writer = new IndexWriter(dir,new StandardAnalyzer(),true); 
+        Document doc = new Document(); 
+        doc.add(new Field(StorageEntryWrapper.FIELD_ENTRY_ID,"1",Field.Store.YES,Field.Index.UN_TOKENIZED)); 
+        doc.add(new Field(fieldFeedId,feedID,Field.Store.YES,Field.Index.UN_TOKENIZED)); 
+        Document doc1 = new Document(); 
+        doc1.add(new Field(StorageEntryWrapper.FIELD_ENTRY_ID,"2",Field.Store.YES,Field.Index.UN_TOKENIZED)); 
+        doc1.add(new Field(fieldFeedId,feedID,Field.Store.YES,Field.Index.UN_TOKENIZED)); 
+        this.writer.addDocument(doc); 
+        this.writer.addDocument(doc1); 
+        this.writer.close(); 
+        this.reader = IndexReader.open(dir); 
+        this.excludeList = new ArrayList(); 
+        this.excludeList.add("1"); 
+         
+         
+    } 
+ 
+    protected void tearDown() throws Exception { 
+        super.tearDown(); 
+    } 
+    public void testFilter() throws IOException{ 
+        Searcher s = new IndexSearcher(this.reader); 
+        Query q = new TermQuery(new Term(fieldFeedId,feedID)); 
+        Hits hits = s.search(q); 
+        assertEquals(2,hits.length()); 
+         
+        hits = s.search(q,new ModifiedEntryFilter(this.excludeList.toArray(new String[0]),StorageEntryWrapper.FIELD_ENTRY_ID)); 
+        assertEquals(1,hits.length()); 
+        this.excludeList.add("2"); 
+ 
+        hits = s.search(q,new ModifiedEntryFilter(this.excludeList.toArray(new String[0]),StorageEntryWrapper.FIELD_ENTRY_ID)); 
+        assertEquals(0,hits.length());
+        this.excludeList.add(null);
+        this.excludeList.add("5"); 
+        hits = s.search(q,new ModifiedEntryFilter(this.excludeList.toArray(new String[0]),StorageEntryWrapper.FIELD_ENTRY_ID)); 
+        assertEquals(0,hits.length()); 
+         
+    } 
+} 
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/TestSingelHostConcurrencyLock.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/TestSingelHostConcurrencyLock.java
new file mode 100755
index 0000000..c125768
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/TestSingelHostConcurrencyLock.java
@@ -0,0 +1,148 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.storage.lucenestorage;
+
+import org.apache.lucene.gdata.storage.lucenestorage.SingleHostConcurrentStorageLock.ConcurrencyException;
+
+import junit.framework.TestCase;
+
+public class TestSingelHostConcurrencyLock extends TestCase {
+    SingleHostConcurrentStorageLock lock;
+    boolean threadResult = false;
+    protected void setUp() throws Exception {
+        this.lock = (SingleHostConcurrentStorageLock)SingleHostConcurrentStorageLock.getConcurrentStorageLock();
+        super.setUp();
+    }
+
+    protected void tearDown() throws Exception {
+        super.tearDown();
+        threadResult = false;
+        this.lock.close();
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.SingleHostConcurrentStorageLock.getConcurrentStorageLock()'
+     */
+    public void testGetConcurrentStorageLock() {
+        ConcurrentStorageLock lock = SingleHostConcurrentStorageLock.getConcurrentStorageLock();
+        assertEquals(lock,SingleHostConcurrentStorageLock.getConcurrentStorageLock() );
+        
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.SingleHostConcurrentStorageLock.setLock(String)'
+     */
+    public void testSetLock() throws InterruptedException {
+        final String key = "someKey";
+        final String nextKey = "fooKey";
+        assertTrue(lock.setLock(key));
+        assertTrue(lock.isKeyLocked(key));
+        
+        try{
+            this.lock.setLock(key);
+            fail("thread has already locked the key");
+        }catch (Exception e) {
+            // TODO: handle exception
+        }
+        
+        try{
+            assertTrue(lock.setLock(nextKey));
+            fail("thread has already locked the key");
+        }catch (Exception e) {
+            // TODO: handle exception
+        }
+        
+        Thread t = new Thread(new Runnable(){
+            public void run(){
+                threadResult = lock.setLock(key);
+              
+                
+                
+            }
+        });
+        t.start();
+        t.join(300);
+        assertFalse(threadResult);
+        
+        t = new Thread(new Runnable(){
+            public void run(){
+                threadResult = lock.setLock(nextKey);
+              
+                
+                
+            }
+        });
+        t.start();
+        t.join(300);
+        assertTrue(threadResult);
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.SingleHostConcurrentStorageLock.releaseLock(String)'
+     */
+    public void testReleaseLock() throws InterruptedException {
+        final String key = "someKey";
+        final String nextKey = "fooKey";
+        assertTrue(lock.setLock(key));
+        assertTrue(lock.isKeyLocked(key));
+        assertTrue(lock.releaseLock(key));
+        assertTrue(this.lock.setLock(key));
+        try{
+            assertTrue(lock.setLock(nextKey));
+            fail("thread has already locked the key");
+        }catch (Exception e) {
+            // TODO: handle exception
+        }
+        
+        Thread t = new Thread(new Runnable(){
+            public void run(){
+                threadResult = lock.setLock(nextKey);
+            }
+        });
+        t.start();
+        t.join(300);
+        assertTrue(threadResult);
+        try{
+        this.lock.releaseLock(nextKey);
+           fail("current thread is not owner");
+        }catch (ConcurrencyException e) {
+            // TODO: handle exception
+        }
+
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.SingleHostConcurrentStorageLock.releaseThreadLocks()'
+     */
+    public void testReleaseThreadLocks() {
+        
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.SingleHostConcurrentStorageLock.isKeyLocked(String)'
+     */
+    public void testIsKeyLocked() {
+
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.SingleHostConcurrentStorageLock.close()'
+     */
+    public void testClose() {
+
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/TestStorageBuffer.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/TestStorageBuffer.java
new file mode 100755
index 0000000..d43154f
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/TestStorageBuffer.java
@@ -0,0 +1,251 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.storage.lucenestorage;
+
+import java.io.IOException;
+import java.util.List;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper.StorageOperation;
+import org.apache.lucene.gdata.utils.ProvidedServiceStub;
+
+import com.google.gdata.data.DateTime;
+
+public class TestStorageBuffer extends TestCase {
+    private static final String FEEDID = "feed";
+    private static final String ENTRYID = "someID";
+    private StorageBuffer buffer;
+    protected void setUp() throws Exception {
+        super.setUp();
+        this.buffer = new StorageBuffer(10);
+    }
+
+    protected void tearDown() throws Exception {
+        this.buffer.close();
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.StorageBuffer.StorageBuffer(int)'
+     */
+    public void testStorageBuffer() {
+        assertEquals(StorageBuffer.DEFAULT_BUFFER_COUNT,new StorageBuffer(StorageBuffer.DEFAULT_BUFFER_COUNT-1).getBufferSize());
+        assertEquals(StorageBuffer.DEFAULT_BUFFER_COUNT,new StorageBuffer(StorageBuffer.DEFAULT_BUFFER_COUNT).getBufferSize());
+        assertEquals(StorageBuffer.DEFAULT_BUFFER_COUNT+1,new StorageBuffer(StorageBuffer.DEFAULT_BUFFER_COUNT+1).getBufferSize());
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.StorageBuffer.addEntry(StorageEntryWrapper)'
+     */
+    public void testAddEntry() throws IOException {
+        
+        ServerBaseEntry e = createServerBaseEntry(ENTRYID,FEEDID);
+        StorageEntryWrapper wrapper = new StorageEntryWrapper(e,StorageOperation.INSERT);
+        this.buffer.addEntry(wrapper);
+        assertEquals(1,this.buffer.getSortedEntries(FEEDID).size());
+        this.buffer.addEntry(wrapper);
+        assertEquals(1,this.buffer.getSortedEntries(FEEDID).size());
+        
+        e.setId("someotherID");
+        e.setFeedId(FEEDID);
+        e.setServiceConfig(new ProvidedServiceStub());
+        wrapper = new StorageEntryWrapper(e,StorageOperation.INSERT);
+        this.buffer.addEntry(wrapper);
+        assertEquals(2,this.buffer.getSortedEntries(FEEDID).size());
+        e.setId("someotherID");
+        e.setFeedId("someOtherFeed");
+        e.setServiceConfig(new ProvidedServiceStub());
+        wrapper = new StorageEntryWrapper(e,StorageOperation.UPDATE);
+        this.buffer.addEntry(wrapper);
+        wrapper = new StorageEntryWrapper(e,StorageOperation.DELETE);
+        e.setId("deleted and ingnored");
+        e.setFeedId("someOtherFeed");
+        e.setServiceConfig(new ProvidedServiceStub());
+        this.buffer.addEntry(wrapper);
+        assertEquals(2,this.buffer.getSortedEntries(FEEDID).size());
+        assertEquals(1,this.buffer.getSortedEntries("someOtherFeed").size());
+        assertEquals("Contains 2 different IDs",2,this.buffer.getExculdList().length);
+        
+    }
+    /*
+     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.StorageBuffer.addDeleted(String, String)'
+     */
+    public void testAddDeleted() throws IOException {
+        
+        this.buffer.addDeleted(ENTRYID,FEEDID);
+        assertNull(this.buffer.getSortedEntries(FEEDID));
+        assertEquals(1,this.buffer.getExculdList().length);
+        assertEquals(ENTRYID,this.buffer.getExculdList()[0]);
+        
+        this.buffer.addDeleted(ENTRYID,FEEDID);
+        assertNull(this.buffer.getSortedEntries(FEEDID));
+        assertEquals(1,this.buffer.getExculdList().length);
+        assertEquals(ENTRYID,this.buffer.getExculdList()[0]);
+        
+        
+    }
+    /*
+     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.StorageBuffer.getFeedLastModified(String)'
+     */
+    public void testGetFeedLastModified() throws IOException, InterruptedException {
+        ServerBaseEntry e = createServerBaseEntry(ENTRYID,FEEDID);
+        e.setUpdated(new DateTime(System.currentTimeMillis()-200,0));
+        StorageEntryWrapper wrapper = new StorageEntryWrapper(e,StorageOperation.INSERT);
+        this.buffer.addEntry(wrapper);
+        assertEquals(new Long(e.getUpdated().getValue()),this.buffer.getFeedLastModified(FEEDID));
+        //test update
+//      force timestamp
+        e.setUpdated(new DateTime(System.currentTimeMillis()-180,0));
+        wrapper = new StorageEntryWrapper(e,StorageOperation.UPDATE);
+        this.buffer.addEntry(wrapper);
+        Long firstAddTimestamp = new Long(e.getUpdated().getValue());
+        assertEquals(firstAddTimestamp,this.buffer.getFeedLastModified(FEEDID));
+//      force timestamp
+        e.setUpdated(new DateTime(System.currentTimeMillis()-160,0));
+        assertFalse("updated after add" ,e.getUpdated().equals(this.buffer.getFeedLastModified(FEEDID)));
+        
+        //insert for other feed
+        String otherID = "someOtherFeedID";
+        e.setFeedId(otherID);
+//      force timestamp
+        e.setUpdated(new DateTime(System.currentTimeMillis()-140,0));
+        wrapper = new StorageEntryWrapper(e,StorageOperation.INSERT);
+        this.buffer.addEntry(wrapper);
+        assertEquals(new Long(e.getUpdated().getValue()),this.buffer.getFeedLastModified(otherID));
+        assertEquals(firstAddTimestamp,this.buffer.getFeedLastModified(FEEDID));
+        
+        assertTrue(firstAddTimestamp.equals(this.buffer.getFeedLastModified(FEEDID)));
+        this.buffer.addDeleted(e.getId(),FEEDID);
+        // time will be set inside the buffer
+        assertTrue(firstAddTimestamp < this.buffer.getFeedLastModified(FEEDID));
+        
+        
+    }
+    
+  
+    /*
+     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.StorageBuffer.getSortedEntries(String)'
+     */
+    public void testGetSortedEntries() throws IOException, InterruptedException {
+        assertNull(this.buffer.getSortedEntries(FEEDID));
+        ServerBaseEntry e = createServerBaseEntry("2",FEEDID);
+        e.setUpdated(new DateTime(System.currentTimeMillis()-200,0));
+        StorageEntryWrapper wrapper = new StorageEntryWrapper(e,StorageOperation.INSERT);
+        this.buffer.addEntry(wrapper);
+        e.setId("0");
+//      force timestamp
+        e.setUpdated(new DateTime(System.currentTimeMillis()-180,0));
+        wrapper = new StorageEntryWrapper(e,StorageOperation.INSERT);
+        this.buffer.addEntry(wrapper);
+        e.setId("1");
+//      force timestamp
+        e.setUpdated(new DateTime(System.currentTimeMillis()-160,0));
+        wrapper = new StorageEntryWrapper(e,StorageOperation.INSERT);
+        this.buffer.addEntry(wrapper);
+        e.setId("0");
+//      force timestamp
+        e.setUpdated(new DateTime(System.currentTimeMillis()-140,0));
+        wrapper = new StorageEntryWrapper(e,StorageOperation.UPDATE);
+        this.buffer.addEntry(wrapper);
+//      force timestamp
+        e.setUpdated(new DateTime(System.currentTimeMillis()-120,0));
+        wrapper = new StorageEntryWrapper(e,StorageOperation.DELETE);
+        this.buffer.addEntry(wrapper);
+        List<StorageEntryWrapper> list = this.buffer.getSortedEntries(FEEDID);
+       assertEquals(3,list.size());
+        for (int i = 0; i < 3; i++) {
+            assertEquals(""+i,list.get(i).getEntryId());   
+        }
+        
+
+    }
+
+  
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.StorageBuffer.getEntry(String, String)'
+     */
+    public void testGetEntry() throws IOException {
+        assertNull(this.buffer.getEntry(ENTRYID,FEEDID));
+        ServerBaseEntry e = createServerBaseEntry(ENTRYID,FEEDID);
+        StorageEntryWrapper wrapper = new StorageEntryWrapper(e,StorageOperation.INSERT);
+        this.buffer.addEntry(wrapper);
+        assertSame(wrapper,this.buffer.getEntry(ENTRYID,FEEDID));
+        
+        e = createServerBaseEntry("0",FEEDID);
+        wrapper = new StorageEntryWrapper(e,StorageOperation.UPDATE);
+        this.buffer.addEntry(wrapper);
+        assertSame(wrapper,this.buffer.getEntry("0",FEEDID));
+        
+        
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.StorageBuffer.getExculdList()'
+     */
+    public void testGetExculdList() throws IOException {
+        ServerBaseEntry e = createServerBaseEntry(ENTRYID,FEEDID);
+        StorageEntryWrapper wrapper = new StorageEntryWrapper(e,StorageOperation.INSERT);
+        this.buffer.addEntry(wrapper);
+        this.buffer.addEntry(wrapper);
+        assertEquals(1,this.buffer.getExculdList().length);
+        assertEquals(wrapper.getEntryId(),this.buffer.getExculdList()[0]);
+        
+        wrapper = new StorageEntryWrapper(e,StorageOperation.UPDATE);
+        this.buffer.addEntry(wrapper);
+        assertEquals(1,this.buffer.getExculdList().length);
+        assertEquals(wrapper.getEntryId(),this.buffer.getExculdList()[0]);
+        this.buffer.addDeleted(ENTRYID,FEEDID);
+        assertEquals(1,this.buffer.getExculdList().length);
+        assertEquals(wrapper.getEntryId(),this.buffer.getExculdList()[0]);
+        
+         e = createServerBaseEntry("someOtherEntry","someOtherFeed");
+        wrapper = new StorageEntryWrapper(e,StorageOperation.INSERT);
+        this.buffer.addEntry(wrapper);
+        this.buffer.addEntry(wrapper);
+        assertEquals(2,this.buffer.getExculdList().length);
+        
+        
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.StorageBuffer.close()'
+     */
+    public void testClose() throws IOException {
+        ServerBaseEntry e = createServerBaseEntry(ENTRYID,FEEDID);
+        StorageEntryWrapper wrapper = new StorageEntryWrapper(e,StorageOperation.INSERT);
+        
+        this.buffer.addEntry(wrapper);
+        assertNotNull(this.buffer.getSortedEntries(FEEDID));
+        assertNotNull(this.buffer.getEntry(ENTRYID,FEEDID));
+        assertEquals(1,this.buffer.getExculdList().length);
+        this.buffer.close();
+        assertNull(this.buffer.getSortedEntries(FEEDID));
+        assertNull(this.buffer.getEntry(ENTRYID,FEEDID));
+        assertEquals(0,this.buffer.getExculdList().length);
+        
+        
+
+    }
+    public ServerBaseEntry createServerBaseEntry(String entryID, String feedId) throws IOException{
+        ServerBaseEntry e = new ServerBaseEntry();
+        e.setId(entryID);
+        e.setFeedId(feedId);
+        e.setServiceConfig(new ProvidedServiceStub());
+       return e;
+    }
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/TestStorageImplementation.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/TestStorageImplementation.java
new file mode 100755
index 0000000..8f76d7e
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/TestStorageImplementation.java
@@ -0,0 +1,458 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.storage.lucenestorage;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
+import org.apache.lucene.gdata.server.registry.ProvidedService;
+import org.apache.lucene.gdata.storage.ModificationConflictException;
+import org.apache.lucene.gdata.storage.Storage;
+import org.apache.lucene.gdata.storage.StorageController;
+import org.apache.lucene.gdata.storage.StorageException;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper.StorageOperation;
+import org.apache.lucene.gdata.utils.MultiThreadEntryStub;
+import org.apache.lucene.gdata.utils.ProvidedServiceStub;
+import org.apache.lucene.gdata.utils.Visitor;
+
+import com.google.gdata.data.DateTime;
+
+public class TestStorageImplementation extends TestCase {
+    private static GDataServerRegistry reg = null;
+
+    private Storage storage;
+
+    public static boolean fail = false;
+
+    protected void setUp() throws Exception {
+
+        if (reg == null) {
+            reg = GDataServerRegistry.getRegistry();
+            if(reg.lookup(StorageController.class,ComponentType.STORAGECONTROLLER)!= null);
+                reg.destroy();
+            reg.registerComponent(StorageCoreControllerStub.class,null);
+
+        }
+        this.storage = reg.lookup(StorageController.class,
+                ComponentType.STORAGECONTROLLER).getStorage();
+    }
+
+    protected void tearDown() throws Exception {
+        this.storage.close();
+        fail = false;
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.storage.lucenestorage.StorageImplementation.storeEntry(ServerBaseEntry)'
+     */
+    public void testStoreEntry() {
+
+        try {
+            this.storage.storeEntry(null);
+            fail("entry is null");
+        } catch (StorageException e) {
+            //
+        }
+        ServerBaseEntry entry = new ServerBaseEntry();
+        entry.setServiceConfig(new ProvidedServiceStub());
+
+        try {
+            this.storage.storeEntry(entry);
+            fail("feed is null");
+        } catch (StorageException e) {
+            //
+        }
+
+        entry.setFeedId("someID");
+        try {
+            this.storage.storeEntry(entry);
+
+        } catch (StorageException e1) {
+            fail("unexpected exception");
+
+        }
+        entry.setServiceConfig(null);
+        try {
+            this.storage.storeEntry(entry);
+            fail("no service config");
+        } catch (StorageException e) {
+
+        }
+        entry.setVersion(5);
+        try {
+            this.storage.storeEntry(entry);
+            fail("version is greater than 1");
+        } catch (StorageException e) {
+
+        }
+
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.storage.lucenestorage.StorageImplementation.deleteEntry(ServerBaseEntry)'
+     */
+    public void testDeleteEntry() throws InterruptedException {
+        try {
+            this.storage.storeEntry(null);
+            fail("entry is null");
+        } catch (StorageException e) {
+            //
+        }
+        ServerBaseEntry entry = new ServerBaseEntry();
+        entry.setServiceConfig(new ProvidedServiceStub());
+        entry.setId("someID");
+        entry.setFeedId("someID");
+        try {
+            this.storage.storeEntry(entry);
+
+        } catch (StorageException e) {
+            fail("unexpected exception");
+            //
+        }
+        entry.setFeedId(null);
+        try {
+            this.storage.deleteEntry(entry);
+            fail("feed is null");
+        } catch (StorageException e) {
+            //
+        }
+
+        entry.setFeedId("someID");
+        try {
+            this.storage.deleteEntry(entry);
+
+        } catch (StorageException e1) {
+            e1.printStackTrace();
+            fail("unexpected exception");
+
+        }
+        entry.setFeedId("someID");
+        
+        try {
+            this.storage.deleteEntry(entry);
+
+        } catch (StorageException e1) {
+            e1.printStackTrace();
+            fail("unexpected exception");
+
+        }
+        
+        
+        
+        Object monitor = new Object();
+        AtomicBoolean reached = new AtomicBoolean(false);
+
+        MultiThreadEntryStub concuEntry = new MultiThreadEntryStub();
+        concuEntry.setId(System.currentTimeMillis() + "");
+        ProvidedService conf = new ProvidedServiceStub();
+        
+        concuEntry.setServiceConfig(conf);
+        concuEntry.setUpdated(DateTime.now());
+        concuEntry.setFeedId("feed");
+        this.storage.storeEntry(concuEntry);
+        storage.close();
+        concuEntry.acceptGetVersionVisitor(getMonitorVisitor(monitor,reached));
+
+
+        Thread t1 = getDelThread(storage, concuEntry, false);
+
+        Thread t2 = getDelThread(storage, concuEntry, true);
+        t1.start();
+        /*
+         * Wait active -- not nice but works fine here
+         * wait until thread parked
+         */
+
+        while (true) {
+            synchronized (monitor) {
+                if (reached.get())
+                    break;
+                monitor.wait(10);
+            }
+        }
+        t2.start();
+        t2.join(800);
+        /*
+         * Wait active -- not nice but works fine here
+         * wake up the waiting thread
+         */
+        while (true) {
+            synchronized (monitor) {
+                if (!reached.get())
+                    break;
+                monitor.notifyAll();
+            }
+        }
+        t1.join(300);
+        if (fail)
+            fail("thread failed -- see stacktrace");
+       
+       
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.storage.lucenestorage.StorageImplementation.updateEntry(ServerBaseEntry)'
+     */
+    public void testUpdateEntry() throws InterruptedException {
+        Object monitor = new Object();
+        AtomicBoolean reached = new AtomicBoolean(false);
+
+        MultiThreadEntryStub concuEntry = new MultiThreadEntryStub();
+        concuEntry.setId(System.currentTimeMillis() + "");
+        ProvidedService conf = new ProvidedServiceStub();
+        
+        concuEntry.setServiceConfig(conf);
+        concuEntry.setUpdated(DateTime.now());
+        concuEntry.setFeedId("feed");
+        this.storage.storeEntry(concuEntry);
+        storage.close();
+        concuEntry.acceptGetEntryVisitor(getMonitorVisitor(monitor,reached));
+
+
+        Thread t1 = getUpdThread(storage, concuEntry, false);
+
+        Thread t2 = getUpdThread(storage, concuEntry, true);
+        t1.start();
+        /*
+         * Wait active -- not nice but works fine here
+         * wait until thread parked
+         */
+
+        while (true) {
+            synchronized (monitor) {
+                if (reached.get())
+                    break;
+                monitor.wait(10);
+            }
+        }
+        t2.start();
+        t2.join(800);
+        /*
+         * Wait active -- not nice but works fine here
+         * wake up the waiting thread
+         */
+        while (true) {
+            synchronized (monitor) {
+                if (!reached.get())
+                    break;
+                monitor.notifyAll();
+            }
+        }
+        t1.join(300);
+        if (fail)
+            fail("thread failed -- see stacktrace");
+
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.storage.lucenestorage.StorageImplementation.getFeed(ServerBaseFeed)'
+     */
+    public void testGetFeed() {
+
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.storage.lucenestorage.StorageImplementation.getEntry(ServerBaseEntry)'
+     */
+    public void testGetEntry() {
+
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.storage.lucenestorage.StorageImplementation.close()'
+     */
+    public void testClose() {
+
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.storage.lucenestorage.StorageImplementation.storeAccount(GDataAccount)'
+     */
+    public void testStoreAccount() {
+
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.storage.lucenestorage.StorageImplementation.updateAccount(GDataAccount)'
+     */
+    public void testUpdateAccount() {
+
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.storage.lucenestorage.StorageImplementation.deleteAccount(String)'
+     */
+    public void testDeleteAccount() {
+
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.storage.lucenestorage.StorageImplementation.storeFeed(ServerBaseFeed,
+     * String)'
+     */
+    public void testStoreFeed() {
+
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.storage.lucenestorage.StorageImplementation.deleteFeed(String)'
+     */
+    public void testDeleteFeed() {
+
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.storage.lucenestorage.StorageImplementation.updateFeed(ServerBaseFeed,
+     * String)'
+     */
+    public void testUpdateFeed() {
+
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.storage.lucenestorage.StorageImplementation.getServiceForFeed(String)'
+     */
+    public void testGetServiceForFeed() {
+
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.storage.lucenestorage.StorageImplementation.getAccount(String)'
+     */
+    public void testGetAccount() {
+
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.storage.lucenestorage.StorageImplementation.getAccountNameForFeedId(String)'
+     */
+    public void testGetAccountNameForFeedId() {
+
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.storage.lucenestorage.StorageImplementation.getEntryLastModified(String,
+     * String)'
+     */
+    public void testGetEntryLastModified() {
+
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.storage.lucenestorage.StorageImplementation.getFeedLastModified(String)'
+     */
+    public void testGetFeedLastModified() {
+
+    }
+    static class Runner implements Runnable {
+        Storage s;
+
+        StorageController c;
+
+        ServerBaseEntry e;
+
+        boolean expConf;
+
+        StorageOperation op;
+
+        public Runner(Storage s, ServerBaseEntry e,
+                boolean expectConflict, StorageOperation op) {
+            this.s = s;
+            this.e = e;
+            this.expConf = expectConflict;
+            this.op = op;
+        }
+
+        public void run() {
+           
+            try {
+                if (this.op == StorageOperation.DELETE)
+                    this.s.deleteEntry(e);
+                if (this.op == StorageOperation.UPDATE)
+                    this.s.updateEntry(e);
+                if (expConf)
+                    fail = true;
+            } catch (ModificationConflictException ex) {
+                if (!expConf)
+                    fail = true;
+                ex.printStackTrace();
+
+            } catch (StorageException ex) {
+                ex.printStackTrace();
+                fail = true;
+            }
+
+        }
+    }
+    
+    private Visitor getMonitorVisitor(final Object monitor, final AtomicBoolean reached){
+        /*
+         * The executing thread stops at a defined position while holding the semaphore inside the storageImpl
+         */
+        return new Visitor(){
+          public void execute(Object[] o){
+            synchronized (monitor) {
+            try {
+                reached.set(true);
+                monitor.wait();
+                reached.set(false);
+              
+            } catch (InterruptedException e) {
+                //                   
+            }
+            }
+          }
+        };
+    }
+
+    private Thread getDelThread(Storage s, ServerBaseEntry e,
+            boolean conflictExpected) {
+        Thread t1 = new Thread(new Runner(s, e, conflictExpected,
+                StorageOperation.DELETE));
+        t1.setPriority(Thread.MAX_PRIORITY);
+        return t1;
+    }
+
+    private Thread getUpdThread(Storage s, ServerBaseEntry e,
+            boolean conflictExpected) {
+        Thread t1 = new Thread(new Runner(s, e, conflictExpected,
+                StorageOperation.UPDATE));
+        t1.setPriority(Thread.MAX_PRIORITY);
+        return t1;
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/TestStorageModifier.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/TestStorageModifier.java
new file mode 100644
index 0000000..91da27c
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/TestStorageModifier.java
@@ -0,0 +1,419 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.storage.lucenestorage;
+
+import java.io.IOException;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.data.ServerBaseFeed;
+import org.apache.lucene.gdata.server.registry.ProvidedService;
+import org.apache.lucene.gdata.storage.StorageException;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper.StorageOperation;
+import org.apache.lucene.gdata.utils.ProvidedServiceStub;
+import org.apache.lucene.gdata.utils.ReferenceCounter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.Hits;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.RAMDirectory;
+
+import com.google.gdata.data.BaseEntry;
+import com.google.gdata.data.DateTime;
+import com.google.gdata.data.Entry;
+import com.google.gdata.data.PlainTextConstruct;
+import com.google.gdata.data.TextContent;
+import com.google.gdata.util.ParseException;
+
+public class TestStorageModifier extends TestCase {
+    private StorageModifier modifier;
+
+    private int count = 1;
+
+    private ProvidedService configurator;
+
+    private Directory dir;
+
+    private StorageCoreController controller;
+
+    private static String feedId = "myFeed";
+
+    private static String username = "simon";
+
+    private static String password = "test";
+    private static String service = "myService";
+
+    protected void setUp() throws Exception {
+        this.controller = new StorageCoreController();
+        this.dir = new RAMDirectory();
+        this.controller.setStorageDir(this.dir);
+        this.controller.setKeepRecoveredFiles(false);
+        this.controller.setOptimizeInterval(10);
+        this.controller.setRecover(false);
+        this.controller.setBufferSize(10);
+        this.controller.setPersistFactor(10);
+        this.controller.initialize();
+        this.configurator = new ProvidedServiceStub();
+        this.modifier = this.controller.getStorageModifier();
+        this.dir = this.controller.getDirectory();
+
+    }
+
+    protected void tearDown() throws Exception {
+        this.count = 1;
+        // destroy all resources
+        this.controller.destroy();
+        
+
+
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.storage.lucenestorage.StorageModifier.updateEntry(StroageEntryWrapper)'
+     */
+    public void testUpdateEntry() throws IOException, InterruptedException,
+            ParseException, StorageException {
+        testInsertEntry();
+        for (int i = 1; i < this.count; i++) {
+            Entry e = new Entry();
+            e.setId("" + i);
+            String insertString = "Hello world" + i;
+            e.setTitle(new PlainTextConstruct(insertString));
+            ServerBaseEntry en = getServerEntry(e);
+            StorageEntryWrapper wrapper = new StorageEntryWrapper(en,
+                    StorageOperation.UPDATE);
+            this.modifier.updateEntry(wrapper);
+            ReferenceCounter<StorageQuery> innerQuery = this.controller
+                    .getStorageQuery();
+            BaseEntry fetchedEntry = innerQuery.get().singleEntryQuery("" + i,
+                    feedId, this.configurator);
+            assertEquals("updated Title:", insertString, fetchedEntry
+                    .getTitle().getPlainText());
+        }
+        // double updates
+        for (int i = 1; i < this.count; i++) {
+            Entry e = new Entry();
+            e.setId("" + i);
+            String insertString = "Hello world" + i;
+            e.setTitle(new PlainTextConstruct(insertString));
+            ServerBaseEntry en = getServerEntry(e);
+            StorageEntryWrapper wrapper = new StorageEntryWrapper(en,
+                    StorageOperation.UPDATE);
+            this.modifier.updateEntry(wrapper);
+
+            e = new Entry();
+            e.setId("" + i);
+            insertString = "Foo Bar" + i;
+            e.setTitle(new PlainTextConstruct(insertString));
+            en = getServerEntry(e);
+            wrapper = new StorageEntryWrapper(en,
+                    StorageOperation.UPDATE);
+            this.modifier.updateEntry(wrapper);
+
+            ReferenceCounter<StorageQuery> innerQuery = this.controller
+                    .getStorageQuery();
+
+            BaseEntry fetchedEntry = innerQuery.get().singleEntryQuery("" + i,
+                    feedId, this.configurator);
+            assertEquals("updated Title:", insertString, fetchedEntry
+                    .getTitle().getPlainText());
+        }
+        
+       
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.storage.lucenestorage.StorageModifier.insertEntry(StroageEntryWrapper)'
+     */
+    public void testInsertEntry() throws IOException, InterruptedException,
+            ParseException, StorageException {
+
+        Thread a = getRunnerThread(this.count);
+        
+
+        Thread b = getRunnerThread((this.count += 10));
+        b.start();
+        a.start();
+//         wait for the first thread to check for the inserted entries
+        a.join();  
+        try{
+        for (int i = 1; i < this.count; i++) {
+           
+            ReferenceCounter<StorageQuery> innerQuery = this.controller
+                    .getStorageQuery();
+            BaseEntry e = innerQuery.get().singleEntryQuery("" + i, feedId,
+                    this.configurator);
+            assertNotNull(e);
+            assertEquals("get entry for id" + i, "" + i, e.getId());
+
+        }
+        }finally{
+        	/*
+        	 * if an exception occures the tread can at least finnish running before the
+        	 * controller will be closed in the tearDown method
+        	 */
+        	 b.join();	
+        }
+      
+       
+        ReferenceCounter<StorageQuery> query = this.controller
+                .getStorageQuery();
+
+        this.count += 10;
+        for (int i = 1; i < this.count; i++) {
+            BaseEntry e = query.get().singleEntryQuery("" + i, feedId,
+                    this.configurator);
+            assertEquals("get entry for id" + i, "" + i, e.getId());
+        }
+
+        BaseEntry e = query.get().singleEntryQuery("" + this.count, feedId,
+                this.configurator);
+        assertNull("not entry for ID", e);
+        query.decrementRef();
+
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.storage.lucenestorage.StorageModifier.deleteEntry(String)'
+     */
+    public void testDeleteEntry() throws IOException, InterruptedException,
+            ParseException, StorageException {
+        testInsertEntry();
+        for (int i = 1; i < this.count; i++) {
+            if (i % 2 == 0 || i < 10) {
+                ServerBaseEntry entry = new ServerBaseEntry();
+                entry.setId("" + i);
+                entry.setFeedId(feedId);
+                this.modifier.deleteEntry(new StorageEntryWrapper(entry,StorageOperation.DELETE));
+            }
+            ReferenceCounter<StorageQuery> query = this.controller
+                    .getStorageQuery();
+            if (i % 2 == 0 || i < 10) {
+                assertNull(query.get().singleEntryQuery("" + i, feedId,
+                        this.configurator));
+            } else
+                assertEquals("" + i, query.get().singleEntryQuery("" + i,
+                        feedId, this.configurator).getId());
+            query.decrementRef();
+        }
+
+        this.controller.forceWrite();
+        IndexSearcher searcher = new IndexSearcher(this.dir);
+
+        for (int i = 1; i < this.count; i++) {
+            Query luceneQuery = new TermQuery(new Term(
+                    StorageEntryWrapper.FIELD_ENTRY_ID, "" + i));
+            Hits hits = searcher.search(luceneQuery);
+            if (i % 2 == 0 || i < 10) {
+
+                assertEquals(0, hits.length());
+            } else
+                assertEquals(1, hits.length());
+        }
+        searcher.close();
+
+    }
+
+    public void testSaveUser() throws StorageException, IOException {
+
+        GDataAccount user = new GDataAccount();
+        user.setName(username);
+        user.setPassword(password);
+        StorageAccountWrapper wrapper = new StorageAccountWrapper(user);
+        this.modifier.createAccount(wrapper);
+        IndexSearcher searcher = new IndexSearcher(this.dir);
+        Query q = new TermQuery(new Term(StorageAccountWrapper.FIELD_ACCOUNTNAME,
+                username));
+        Hits h = searcher.search(q);
+        assertEquals("length == 1", 1, h.length());
+        GDataAccount storedUser = StorageAccountWrapper.buildEntity(h.doc(0));
+        assertTrue(storedUser.equals(user));
+        searcher.close();
+    }
+
+    public void testDeleteUser() throws StorageException, IOException {
+        testSaveUser();
+        this.modifier.deleteAccount(username);
+        IndexSearcher searcher = new IndexSearcher(this.dir);
+        Query q = new TermQuery(new Term(StorageAccountWrapper.FIELD_ACCOUNTNAME,
+                username));
+        Hits h = searcher.search(q);
+        assertEquals("length == 0", 0, h.length());
+        searcher.close();
+    }
+
+    public void testUpdateUser() throws StorageException, IOException {
+        testSaveUser();
+        GDataAccount user = new GDataAccount();
+        user.setName(username);
+        user.setPassword("newPass");
+        StorageAccountWrapper wrapper = new StorageAccountWrapper(user);
+        this.modifier.updateAccount(wrapper);
+        IndexSearcher searcher = new IndexSearcher(this.dir);
+        Query q = new TermQuery(new Term(StorageAccountWrapper.FIELD_ACCOUNTNAME,
+                username));
+        Hits h = searcher.search(q);
+        assertEquals("length == 1", 1, h.length());
+        GDataAccount storedUser = StorageAccountWrapper.buildEntity(h.doc(0));
+        assertTrue(storedUser.equals(user));
+
+        assertFalse(storedUser.getPassword().equals(password));
+        searcher.close();
+    }
+
+    public void testSaveFeed() throws IOException, StorageException {
+        String title = "myTitle";
+        ServerBaseFeed feed = new ServerBaseFeed();
+        feed.setId(feedId);
+        feed.setTitle(new PlainTextConstruct(title));
+        feed.setServiceType(service);
+        feed.setServiceConfig(this.configurator);
+        StorageFeedWrapper wrapper = new StorageFeedWrapper(feed,username);
+        this.modifier.createFeed(wrapper);
+        
+        IndexSearcher searcher = new IndexSearcher(this.dir);
+        Query q = new TermQuery(new Term(StorageFeedWrapper.FIELD_FEED_ID,
+                feedId));
+        Hits h = searcher.search(q);
+        assertEquals("length == 1", 1, h.length());
+        searcher.close();
+        
+    }
+
+    public void testDeleteFeed() throws IOException, StorageException {
+        testSaveFeed();
+        Entry e = new Entry();
+        e.setTitle(new PlainTextConstruct("hello world"));
+        ServerBaseEntry entry = new ServerBaseEntry(e);
+        entry.setFeedId(feedId);
+        entry.setId("testme");
+        entry.setServiceConfig(this.configurator);
+        StorageEntryWrapper entryWrapper = new StorageEntryWrapper(entry,StorageOperation.INSERT);
+        this.modifier.insertEntry(entryWrapper);
+        this.modifier.forceWrite();
+        this.modifier.deleteFeed(feedId);
+        IndexSearcher searcher = new IndexSearcher(this.dir);
+        Query q = new TermQuery(new Term(StorageFeedWrapper.FIELD_FEED_ID,
+                feedId));
+        Query q1 = new TermQuery(new Term(StorageEntryWrapper.FIELD_FEED_REFERENCE,
+                feedId));
+        BooleanQuery boolQuery = new BooleanQuery();
+        boolQuery.add(q,BooleanClause.Occur.SHOULD);
+        boolQuery.add(q1,BooleanClause.Occur.SHOULD);
+        Hits h = searcher.search(boolQuery);
+        assertEquals("length == 0", 0, h.length());
+        searcher.close();
+        
+        
+        
+    }
+
+    /**
+     * @throws IOException
+     * @throws StorageException
+     */
+    public void testUpdateFeed() throws IOException, StorageException {
+        testSaveFeed();
+        ServerBaseFeed feed = new ServerBaseFeed();
+        String title = "myTitle";
+        String newusername = "doug";
+        feed.setTitle(new PlainTextConstruct(title));
+        feed.setId(feedId);
+        feed.setServiceType(service);
+        feed.setServiceConfig(this.configurator);
+        StorageFeedWrapper wrapper = new StorageFeedWrapper(feed,newusername);
+        this.modifier.updateFeed(wrapper);
+        IndexSearcher searcher = new IndexSearcher(this.dir);
+        Query q = new TermQuery(new Term(StorageFeedWrapper.FIELD_FEED_ID,
+                feedId));
+        Hits h = searcher.search(q);
+        assertEquals("length == 1", 1, h.length());
+        assertTrue(h.doc(0).get(StorageFeedWrapper.FIELD_ACCOUNTREFERENCE).equals(newusername));
+        searcher.close();
+
+    }
+
+    private Thread getRunnerThread(int idIndex) {
+        Thread t = new Thread(new Runner(idIndex));
+        return t;
+    }
+
+    private class Runner implements Runnable {
+        private int idIndex;
+
+        public Runner(int idIndex) {
+            this.idIndex = idIndex;
+        }
+
+        public void run() {
+            for (int i = idIndex; i < idIndex + 10; i++) {
+
+                BaseEntry e = buildEntry("" + i);
+                try {
+                    ServerBaseEntry en = new ServerBaseEntry(e);
+                    en.setFeedId(feedId);
+                    en.setServiceConfig(configurator);
+                    StorageEntryWrapper wrapper = new StorageEntryWrapper(en,
+                            StorageOperation.INSERT);
+                    modifier.insertEntry(wrapper);
+//                    System.out.println("insert: "+i+" Thread: "+Thread.currentThread().getName());
+                } catch (Exception e1) {
+
+                    e1.printStackTrace();
+                }
+
+            }
+
+        }// end run
+
+        private BaseEntry buildEntry(String id) {
+            Entry e = new Entry();
+            e.setId(id);
+            e.setTitle(new PlainTextConstruct("Monty Python"));
+
+            e.setPublished(DateTime.now());
+
+            e.setUpdated(DateTime.now());
+            String content = "1st soldier with a keen interest in birds: Who goes there?"
+                    + "King Arthur: It is I, Arthur, son of Uther Pendragon, from the castle of Camelot. King of the Britons, defeater of the Saxons, Sovereign of all England!"
+                    + "1st soldier with a keen interest in birds: Pull the other one!"
+                    + "King Arthur: I am, and this is my trusty servant Patsy. We have ridden the length and breadth of the land in search of knights who will join me in my court at Camelot. I must speak with your lord and master."
+                    + "1st soldier with a keen interest in birds: What? Ridden on a horse?"
+                    + "King Arthur: Yes!";
+            e.setContent(new TextContent(new PlainTextConstruct(content)));
+            e.setSummary(new PlainTextConstruct("The Holy Grail"));
+            return e;
+        }
+
+    }
+    
+    private ServerBaseEntry getServerEntry(BaseEntry e){
+        ServerBaseEntry en = new ServerBaseEntry(e);
+        en.setFeedId(feedId);
+        en.setServiceConfig(this.configurator);
+        return en;
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/TestStorageQuery.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/TestStorageQuery.java
new file mode 100644
index 0000000..32fae22
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/TestStorageQuery.java
@@ -0,0 +1,319 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.storage.lucenestorage;
+
+import java.io.IOException;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.List;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.data.ServerBaseFeed;
+import org.apache.lucene.gdata.server.registry.ProvidedService;
+import org.apache.lucene.gdata.storage.StorageException;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper.StorageOperation;
+import org.apache.lucene.gdata.utils.ProvidedServiceStub;
+import org.apache.lucene.gdata.utils.ReferenceCounter;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.RAMDirectory;
+
+import com.google.gdata.data.BaseEntry;
+import com.google.gdata.data.BaseFeed;
+import com.google.gdata.data.DateTime;
+import com.google.gdata.data.Entry;
+import com.google.gdata.util.ParseException;
+
+public class TestStorageQuery extends TestCase {
+    private StorageModifier modifier;
+    private int count = 30;
+    private ReferenceCounter<StorageQuery> query;
+    private ProvidedService configurator;
+    private StorageCoreController controller;
+    private  Directory dir;
+    private static String feedId = "myFeed";
+    private static String accountName = "simon";
+    private static String service = ProvidedServiceStub.SERVICE_NAME;
+    protected void setUp() throws Exception {
+        this.configurator = new ProvidedServiceStub();
+        this.controller = new StorageCoreController();
+        this.dir = new RAMDirectory();
+        this.controller.setStorageDir(this.dir);
+        this.controller.setKeepRecoveredFiles(false);
+        this.controller.setOptimizeInterval(10);
+        this.controller.setRecover(false);
+        this.controller.setBufferSize(10);
+        this.controller.setPersistFactor(10);
+        this.controller.initialize();
+        this.configurator = new ProvidedServiceStub();
+        this.modifier = this.controller.getStorageModifier();
+        this.dir = this.controller.getDirectory();        
+        ServerBaseFeed feed = new ServerBaseFeed();
+        feed.setId(feedId);
+        feed.setServiceType(service);
+        feed.setServiceConfig(this.configurator);
+        
+        StorageFeedWrapper wrapper = new StorageFeedWrapper(feed,accountName);
+        this.modifier.createFeed(wrapper);
+        insertEntries(this.count);
+        this.query = this.controller.getStorageQuery();
+        
+    }
+    
+    /**
+     * @param entrycount
+     * @throws IOException
+     * @throws InterruptedException
+     * @throws StorageException
+     */
+    public void insertEntries(int entrycount) throws IOException,InterruptedException, StorageException{
+        List<StorageEntryWrapper> tempList = new ArrayList<StorageEntryWrapper>();
+        for (int i = 0; i <= entrycount ; i++) {
+            ServerBaseEntry entry = new ServerBaseEntry(new Entry());
+            entry.setId(""+i);
+            entry.setServiceConfig(this.configurator);
+            entry.setUpdated(new DateTime(System.currentTimeMillis(),0));
+            entry.setFeedId(feedId);
+            StorageEntryWrapper wrapper = new StorageEntryWrapper(entry,StorageOperation.INSERT);
+            tempList.add(i,wrapper);
+           
+            // force different timestamps --> DateTime 2006-06-05T13:37:55.724Z
+            Thread.sleep(10);
+          
+        }
+        for (StorageEntryWrapper entry : tempList) {
+            this.modifier.insertEntry(entry);
+        }
+        
+        
+        
+        
+    }
+
+    protected void tearDown() throws Exception {
+        this.query.decrementRef();
+        this.controller.destroy();
+    }
+    
+    /*
+     *  
+     */
+    public void testAccountNameQuery() throws IOException, StorageException{
+        ReferenceCounter<StorageQuery> query = this.controller.getStorageQuery();
+        assertEquals(accountName,query.get().getAccountNameForFeedId(feedId));
+        assertNull(query.get().getAccountNameForFeedId("someId"));
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.storage.lucenestorage.StorageQuery.feedQuery(String, int, int)'
+     */
+    public void testFeedQuery() throws IOException,  ParseException, StorageException {
+        feedQueryHelper(this.query);
+        this.controller.forceWrite();
+        ReferenceCounter<StorageQuery> queryAssureWritten = this.controller.getStorageQuery();
+       
+        assertNotSame(queryAssureWritten,this.query);
+        feedQueryHelper(queryAssureWritten);
+        queryAssureWritten.decrementRef();
+    }
+    private void feedQueryHelper(ReferenceCounter<StorageQuery> currentQuery) throws IOException,  ParseException{
+       BaseFeed feed = currentQuery.get().getLatestFeedQuery(feedId,25,1,this.configurator);
+       List<BaseEntry> entryList = feed.getEntries(); 
+        assertTrue("listSize: "+entryList.size(),entryList.size() == 25);
+        
+        BaseEntry tempEntry = null;
+        for (BaseEntry entry : entryList) {
+          
+            assertNotNull("entry",entry);
+            if(tempEntry != null){
+                assertTrue(tempEntry.getUpdated().compareTo(entry.getUpdated())>=0) ;
+                tempEntry = entry;
+            }else
+                tempEntry = entry;
+            
+        }
+        // test sub retrieve sublist
+        int offset = 15;
+        int resultCount = 5; 
+        feed = currentQuery.get().getLatestFeedQuery(feedId,resultCount,offset,this.configurator);
+        List<BaseEntry> entrySubList = feed.getEntries();
+        
+        assertTrue("listSize: "+entrySubList.size(),entrySubList.size() == resultCount);
+        offset--;
+        for (BaseEntry entry : entrySubList) {
+            
+            assertEquals(entry.getId(),entryList.get(offset).getId());
+            offset++;
+            
+        }
+        
+        
+        
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.storage.lucenestorage.StorageQuery.singleEntryQuery(String, String)'
+     */
+    public void testSingleEntryQuery() throws  ParseException, IOException {
+        for (int i = 1; i <= this.count; i++) {
+            BaseEntry entry = this.query.get().singleEntryQuery(""+i,feedId,this.configurator);
+            assertEquals(""+i,entry.getId());
+        }
+        
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.storage.lucenestorage.StorageQuery.entryQuery(List<String>, String)'
+     */
+    public void testEntryQuery() throws  ParseException, IOException, StorageException {
+        entryQueryHelper(this.query);
+        this.controller.forceWrite();
+        ReferenceCounter<StorageQuery> queryAssureWritten = this.controller.getStorageQuery();
+       
+        assertNotSame(queryAssureWritten,query);
+        entryQueryHelper(queryAssureWritten);
+        queryAssureWritten.decrementRef();
+    }
+    public void testGetUser() throws StorageException, IOException{
+        this.modifier.forceWrite();
+        GDataAccount user = new GDataAccount();
+        user.setName("simon");
+        user.setPassword("pass");
+        user.setAuthorname("simon willnauer");
+        user.setAuthorMail("simon@apache.org");
+        user.setAuthorLink(new URL("http://www.apache.org"));
+        
+       
+     
+        this.modifier.createAccount(new StorageAccountWrapper(user));
+        GDataAccount queriedUser = this.query.get().getUser("simon");
+        assertNull(queriedUser);
+        ReferenceCounter<StorageQuery> tempQuery = this.controller.getStorageQuery();
+        queriedUser = tempQuery.get().getUser("simon");
+        assertTrue(queriedUser.equals(user));
+        assertTrue(queriedUser.getAuthorMail().equals(user.getAuthorMail()));
+        assertTrue(queriedUser.getAuthorLink().equals(user.getAuthorLink()));
+        assertTrue(queriedUser.getAuthorname().equals(user.getAuthorname()));
+        assertTrue(queriedUser.getPassword().equals(user.getPassword()));
+    }
+    
+    public void testIsEntryStored() throws IOException{
+        
+      assertTrue(this.query.get().isEntryStored(""+(this.count-1),feedId));
+      assertFalse(this.query.get().isEntryStored("someOther",feedId));
+      this.modifier.forceWrite();
+      assertTrue(this.query.get().isEntryStored(""+(this.count-1),feedId));
+      this.query = this.controller.getStorageQuery();
+      assertTrue(this.query.get().isEntryStored(""+(this.count-1),feedId));
+      assertFalse(this.query.get().isEntryStored("someOther",feedId));
+    }
+    
+    public void testGetEntryLastModied() throws IOException, StorageException{
+        ServerBaseEntry entry = new ServerBaseEntry(new Entry());
+        entry.setId("test");
+        entry.setServiceConfig(this.configurator);
+        entry.setUpdated(new DateTime(System.currentTimeMillis(),0));
+        entry.setFeedId(feedId);
+        StorageEntryWrapper wrapper = new StorageEntryWrapper(entry,StorageOperation.INSERT);
+        
+        this.modifier.insertEntry(wrapper);
+        assertEquals(entry.getUpdated().getValue(),this.query.get().getEntryLastModified("test",feedId));
+        this.modifier.forceWrite();
+        assertEquals(entry.getUpdated().getValue(),this.query.get().getEntryLastModified("test",feedId));
+        this.query = this.controller.getStorageQuery();
+        assertEquals(entry.getUpdated().getValue(),this.query.get().getEntryLastModified("test",feedId));
+        try{
+        this.query.get().getEntryLastModified("some",feedId);
+        fail("exception expected");
+        }catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+    
+    public void testGetFeedLastModified() throws StorageException, IOException{
+        ServerBaseEntry entry = new ServerBaseEntry(new Entry());
+        entry.setId("test");
+        entry.setServiceConfig(this.configurator);
+        entry.setUpdated(new DateTime(System.currentTimeMillis(),0));
+        entry.setFeedId(feedId);
+        StorageEntryWrapper wrapper = new StorageEntryWrapper(entry,StorageOperation.INSERT);
+        this.modifier.insertEntry(wrapper);
+        assertEquals(entry.getUpdated().getValue(),this.query.get().getFeedLastModified(feedId));
+        this.modifier.forceWrite();
+        assertEquals(entry.getUpdated().getValue(),this.query.get().getFeedLastModified(feedId));
+        this.query = this.controller.getStorageQuery();
+        assertEquals(entry.getUpdated().getValue(),this.query.get().getFeedLastModified(feedId));
+    }
+    
+    public void testCheckVersionId() throws IOException, StorageException{
+        this.modifier.forceWrite();
+        ReferenceCounter<StorageQuery> sQuery = this.controller.getStorageQuery();
+        ServerBaseEntry entry = new ServerBaseEntry(new Entry());
+        entry.setId("test");
+        entry.setServiceConfig(this.configurator);
+        entry.setUpdated(new DateTime(System.currentTimeMillis(),0));
+        entry.setFeedId(feedId);
+        entry.setVersion(5);
+        StorageEntryWrapper wrapper = new StorageEntryWrapper(entry,StorageOperation.INSERT);
+        this.modifier.insertEntry(wrapper);
+        //test in buffer
+        assertTrue(sQuery.get().checkEntryVersion(entry.getId(),entry.getFeedId(),entry.getVersion()));
+        assertFalse(sQuery.get().checkEntryVersion(entry.getId(),entry.getFeedId(),10000));
+        assertFalse(sQuery.get().checkEntryVersion(entry.getId(),"someOtherFeed",entry.getVersion()));
+        assertFalse(sQuery.get().checkEntryVersion("foobar",entry.getFeedId(),entry.getVersion()));
+        
+        
+        this.modifier.forceWrite();
+        //test in buffer after written
+        assertTrue(sQuery.get().checkEntryVersion(entry.getId(),entry.getFeedId(),entry.getVersion()));
+        assertFalse(sQuery.get().checkEntryVersion(entry.getId(),entry.getFeedId(),10000));
+        assertFalse(sQuery.get().checkEntryVersion(entry.getId(),"someOtherFeed",entry.getVersion()));
+        assertFalse(sQuery.get().checkEntryVersion("foobar",entry.getFeedId(),entry.getVersion()));
+        sQuery.decrementRef();
+        sQuery = this.controller.getStorageQuery();
+        //test in index
+        assertTrue(sQuery.get().checkEntryVersion(entry.getId(),entry.getFeedId(),entry.getVersion()));
+        assertFalse(sQuery.get().checkEntryVersion(entry.getId(),entry.getFeedId(),10000));
+        assertFalse(sQuery.get().checkEntryVersion("foobar",entry.getFeedId(),entry.getVersion()));
+        sQuery.decrementRef();
+        
+        
+        
+        
+    }
+    private void entryQueryHelper(ReferenceCounter<StorageQuery> currentQuery) throws IOException,  ParseException{
+        
+        List<String> entryIdList = new ArrayList<String>();
+        for (int i = 1; i <= this.count; i++) {
+           entryIdList.add(""+i);
+        }
+        List<BaseEntry> entryList = currentQuery.get().entryQuery(entryIdList,feedId,this.configurator);
+        assertEquals(entryIdList.size(),entryList.size());
+        List<String> entryIdCompare = new ArrayList<String>();
+        for (BaseEntry entry : entryList) {
+            assertEquals("1",entry.getVersionId());
+            entryIdCompare.add(entry.getId());
+            
+        }
+        assertTrue(entryIdList.containsAll(entryIdCompare));
+        
+    }
+    
+    
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/recover/TestRecoverController.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/recover/TestRecoverController.java
new file mode 100644
index 0000000..2c58f75
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/recover/TestRecoverController.java
@@ -0,0 +1,121 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.storage.lucenestorage.recover;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
+import org.apache.lucene.gdata.storage.StorageException;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageModifierStub;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper.StorageOperation;
+import org.apache.lucene.gdata.utils.ProvidedServiceStub;
+
+import com.google.gdata.data.DateTime;
+
+public class TestRecoverController extends TestCase {
+    private RecoverController writeController;
+    private RecoverController readController;
+    private File recDir;
+    private String feedId = "feedid";
+    private String entryId = "entryId";
+    
+    protected void setUp() throws Exception {
+        this.recDir = new File("unittest"+System.currentTimeMillis());
+        if(!this.recDir.exists())
+            this.recDir.mkdir();
+        this.recDir.deleteOnExit();
+        GDataServerRegistry.getRegistry().registerService(new ProvidedServiceStub());
+        this.writeController = new RecoverController(this.recDir,false,true);
+        this.readController = new RecoverController(this.recDir,true,true);
+        
+        
+
+        
+    }
+
+    protected void tearDown() throws Exception {
+        
+        
+        
+        File[] files = this.recDir.listFiles();
+        for (int i = 0; i < files.length; i++) {
+            files[i].delete();
+        }
+        this.recDir.delete();
+      GDataServerRegistry.getRegistry().destroy();
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.recover.RecoverController.storageModified(StorageEntryWrapper)'
+     */
+    public void testStorageModified() throws IOException, RecoverException {
+        this.writeController.initialize();
+        ServerBaseEntry entry = new ServerBaseEntry();
+        entry.setFeedId(this.feedId);
+        entry.setId(entryId);
+        entry.setUpdated(DateTime.now());
+        entry.setServiceConfig(new ProvidedServiceStub());
+        StorageEntryWrapper wrapper = new StorageEntryWrapper(entry,StorageOperation.INSERT);
+        this.writeController.storageModified(wrapper);
+        assertEquals(1,this.recDir.listFiles().length);
+        this.writeController.destroy();
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.recover.RecoverController.recoverEntries(StorageModifier)'
+     */
+    public void testRecoverEntries() throws IOException, StorageException, RecoverException {
+        testStorageModified();
+        
+        int length = this.recDir.listFiles().length;
+        assertEquals(1,length);
+        
+        this.readController.initialize();
+        try{
+        this.readController.recoverEntries(new StorageModifierStub(null,null,null,0,0));
+        }catch (Exception e) {
+            fail("unexpected exception"+e.getMessage());
+        }
+        this.readController.destroy();
+        assertEquals(1,this.recDir.listFiles().length);
+        
+        createCorruptedFile();
+        this.readController.initialize();
+        try{
+        this.readController.recoverEntries(new StorageModifierStub(null,null,null,0,0));
+        }catch (Exception e) {
+            fail("unexpected exception"+e.getMessage());
+        }
+        this.readController.destroy();
+        assertEquals(2,this.recDir.listFiles().length);
+    }
+    
+    
+    private void createCorruptedFile() throws IOException{
+        File file = new File(this.recDir,"somefile.rec");
+        file.deleteOnExit();
+        FileWriter writer = new FileWriter(file);
+        writer.write("someString\nSomeOtherString");
+        writer.close();
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/recover/TestRecoverWriter.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/recover/TestRecoverWriter.java
new file mode 100644
index 0000000..58d53eb
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/recover/TestRecoverWriter.java
@@ -0,0 +1,90 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.storage.lucenestorage.recover;
+
+import java.io.IOException;
+import java.io.StringWriter;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.server.registry.ProvidedService;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper.StorageOperation;
+import org.apache.lucene.gdata.utils.ProvidedServiceStub;
+
+import com.google.gdata.data.DateTime;
+import com.google.gdata.data.Entry;
+import com.google.gdata.data.PlainTextConstruct;
+
+public class TestRecoverWriter extends TestCase {
+    private static final String ENTRYID = "myID";
+    private static final String TITLE = "title";
+    private static final String FEEDID = "myFeed";
+    
+    private static final Long TIMESTAMP = 132326657L;
+    private DateTime dateTime = new DateTime(TIMESTAMP,0);
+    String compareEntry = "I;"+FEEDID+";"+ENTRYID+";"+TIMESTAMP+";" +ProvidedServiceStub.SERVICE_NAME+";"+RecoverWriter.META_DATA_ENTRY_SEPARATOR+
+            "<atom:entry xmlns:atom='http://www.w3.org/2005/Atom'><atom:id>"+ENTRYID+"</atom:id><atom:updated>"+this.dateTime.toString()+"</atom:updated><atom:title type='text'>" + TITLE+
+            "</atom:title></atom:entry>"+RecoverWriter.META_DATA_ENTRY_SEPARATOR+RecoverWriter.STORAGE_OPERATION_SEPARATOR+RecoverWriter.META_DATA_ENTRY_SEPARATOR;
+    String compareDelete = "D;"+FEEDID+";"+ENTRYID+";"+TIMESTAMP+";"+RecoverWriter.META_DATA_ENTRY_SEPARATOR+RecoverWriter.STORAGE_OPERATION_SEPARATOR+RecoverWriter.META_DATA_ENTRY_SEPARATOR;
+    StorageEntryWrapper wrapper;
+    StorageEntryWrapper deleteWrapper;
+
+    protected void setUp() throws Exception {
+        ServerBaseEntry entry = new ServerBaseEntry(new Entry());
+        entry.setId(ENTRYID);
+        
+        entry.setUpdated(new DateTime(TIMESTAMP,0));
+        entry.setTitle(new PlainTextConstruct(TITLE));
+        ProvidedService config = new ProvidedServiceStub();
+        entry.setFeedId(FEEDID);
+        entry.setServiceConfig(config);
+        this.wrapper = new StorageEntryWrapper(entry,StorageOperation.INSERT);
+        this.deleteWrapper = new StorageEntryWrapper(entry,StorageOperation.DELETE);
+        
+        
+    }
+
+    protected void tearDown() throws Exception {
+        super.tearDown();
+        
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.recover.RecoverWriter.writeEntry(StorageEntryWrapper, Writer)'
+     */
+    public void testWriteEntry() throws IOException {
+        RecoverWriter wr = new RecoverWriter();
+        StringWriter writer = new StringWriter();
+        wr.writeEntry(this.wrapper,writer);
+        assertEquals(compareEntry,writer.toString());
+        writer.close();
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.recover.RecoverWriter.writeDelete(String, String, Writer)'
+     */
+    public void testWriteDelete() throws IOException {
+        RecoverWriter wr = new RecoverWriter();
+        StringWriter writer = new StringWriter();
+        wr.writeEntry(this.deleteWrapper,writer);
+        System.out.println(writer.toString());
+        assertEquals(compareDelete,writer.toString());
+        writer.close();
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/recover/TestRevocerReader.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/recover/TestRevocerReader.java
new file mode 100644
index 0000000..c4a7b12
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/storage/lucenestorage/recover/TestRevocerReader.java
@@ -0,0 +1,96 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.storage.lucenestorage.recover;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.StringReader;
+import java.util.List;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper;
+import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper.StorageOperation;
+import org.apache.lucene.gdata.utils.ProvidedServiceStub;
+
+import com.google.gdata.data.DateTime;
+
+public class TestRevocerReader extends TestCase {
+    private RecoverReader recReader;
+    private static final String feedId = "myFeed";
+    private static final String entryId = "myID";
+    private static final Long timestamp = System.currentTimeMillis();
+    private String title = "myTitle";
+    private static final DateTime dateTime = DateTime.now();
+    private String delete = "D;"+feedId+";"+entryId+";"+timestamp+";\n###########\n";
+    private String insert = "I;"+feedId+";"+entryId+";"+timestamp+";" +ProvidedServiceStub.SERVICE_NAME+";"+RecoverWriter.META_DATA_ENTRY_SEPARATOR+
+    "<atom:entry xmlns:atom='http://www.w3.org/2005/Atom'><atom:id>"+entryId+"</atom:id><atom:updated>"+dateTime.toString()+"</atom:updated><atom:title type='text'>" + this.title+
+    "</atom:title></atom:entry>"+RecoverWriter.META_DATA_ENTRY_SEPARATOR+RecoverWriter.STORAGE_OPERATION_SEPARATOR+RecoverWriter.META_DATA_ENTRY_SEPARATOR;
+    protected void setUp() throws Exception {
+        this.recReader = new RecoverReader();
+        GDataServerRegistry.getRegistry().registerService(new ProvidedServiceStub());
+        
+    }
+
+    protected void tearDown() throws Exception {
+        super.tearDown();
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.recover.RecoverReader.getNonDeleteEntries(Reader)'
+     */
+    public void testRecoverDeletedEntries() throws IOException {
+        StringReader reader = new StringReader(this.delete);
+        assertNotNull(this.recReader.recoverEntries(new BufferedReader(reader)));
+        reader = new StringReader(this.delete);
+        List<StorageEntryWrapper> recList = this.recReader.recoverEntries(new BufferedReader(reader));
+        assertEquals(1,recList.size());
+        StorageEntryWrapper delWrapper = recList.get(0);
+        assertEquals(StorageOperation.DELETE,delWrapper.getOperation());
+        assertEquals(feedId,delWrapper.getFeedId());
+        assertEquals(entryId,delWrapper.getEntryId());
+        
+    }
+    public void testRecoverInsertedEntries() throws IOException {
+        
+        StringReader reader = new StringReader(this.insert);
+        List<StorageEntryWrapper> recList = this.recReader.recoverEntries(new BufferedReader(reader));
+        assertEquals(1,recList.size());
+        StorageEntryWrapper insWrapper = recList.get(0);
+        assertEquals(StorageOperation.INSERT,insWrapper.getOperation());
+        assertEquals(feedId,insWrapper.getFeedId());
+        assertEquals(entryId,insWrapper.getEntryId());
+        assertEquals(dateTime,insWrapper.getEntry().getUpdated());
+        assertEquals(this.title,insWrapper.getEntry().getTitle().getPlainText());
+        
+        
+    }
+    
+    public void testRecoverReader()throws IOException{
+        StringReader reader = new StringReader(this.insert+this.delete);
+        List<StorageEntryWrapper> recList = this.recReader.recoverEntries(new BufferedReader(reader));
+        assertEquals(2,recList.size());
+        assertEquals(StorageOperation.INSERT,recList.get(0).getOperation());
+        assertEquals(StorageOperation.DELETE,recList.get(1).getOperation());
+        
+        reader = new StringReader("some corrupted\n###########\n"+this.insert);
+        recList = this.recReader.recoverEntries(new BufferedReader(reader));
+        assertEquals(1,recList.size());
+        assertEquals(StorageOperation.INSERT,recList.get(0).getOperation());
+        
+    }
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/utils/AuthenticationContorllerStub.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/utils/AuthenticationContorllerStub.java
new file mode 100644
index 0000000..d0ff012
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/utils/AuthenticationContorllerStub.java
@@ -0,0 +1,71 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.utils;
+
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
+import org.apache.lucene.gdata.server.authentication.AuthenticationController;
+import org.apache.lucene.gdata.server.registry.Component;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+@Component(componentType=ComponentType.AUTHENTICATIONCONTROLLER)
+public class AuthenticationContorllerStub implements AuthenticationController {
+    public static AuthenticationController controller;
+    /**
+     * 
+     */
+    public AuthenticationContorllerStub() {
+        super();
+        // TODO Auto-generated constructor stub
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.authentication.AuthenticationController#authenticatAccount(org.apache.lucene.gdata.data.GDataAccount, java.lang.String, java.lang.String)
+     */
+    public String authenticatAccount(GDataAccount account, String requestIp
+            ) {
+
+        return controller.authenticatAccount(account,requestIp);
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.authentication.AuthenticationController#authenticateToken(java.lang.String, java.lang.String, org.apache.lucene.gdata.data.GDataAccount.AccountRole, java.lang.String)
+     */
+    public boolean authenticateToken(String token, String requestIp,
+            AccountRole role, String serviceName) {
+
+        return controller.authenticateToken(token,requestIp,role,serviceName);
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.registry.ServerComponent#initialize()
+     */
+    public void initialize() {
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.registry.ServerComponent#destroy()
+     */
+    public void destroy() {
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/utils/MultiThreadEntryStub.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/utils/MultiThreadEntryStub.java
new file mode 100755
index 0000000..d344c1b
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/utils/MultiThreadEntryStub.java
@@ -0,0 +1,93 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.utils;
+
+
+
+
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+
+import com.google.gdata.data.BaseEntry;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public class MultiThreadEntryStub extends ServerBaseEntry {
+    
+    
+    private Visitor getEntryVisitor;
+    private Visitor getVersionVisitor;
+    /**
+     * 
+     */
+    public MultiThreadEntryStub() {
+        
+     
+    }
+    
+    /**
+     * @param arg0
+     */
+    public MultiThreadEntryStub(BaseEntry arg0) {
+        super(arg0);
+        
+    }
+   
+    
+    
+    public void acceptGetEntryVisitor(Visitor visitor){
+        this.getEntryVisitor = visitor;
+    }
+    public void acceptGetVersionVisitor(Visitor visitor){
+       this.getVersionVisitor = visitor;
+    }
+    /**
+     * @see org.apache.lucene.gdata.data.ServerBaseEntry#getEntry()
+     */
+    @Override
+    public BaseEntry getEntry() {
+       
+        if(this.getEntryVisitor != null){
+            this.getEntryVisitor.execute(null);
+
+        }
+        return super.getEntry();
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.data.ServerBaseEntry#getVersion()
+     */
+    @Override
+    public int getVersion() {
+
+        if(this.getVersionVisitor != null){
+            this.getVersionVisitor.execute(null);
+
+        }
+        return super.getVersion();
+    }
+
+
+    
+    
+    
+    
+    
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/utils/ProvidedServiceStub.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/utils/ProvidedServiceStub.java
new file mode 100644
index 0000000..3e5c042
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/utils/ProvidedServiceStub.java
@@ -0,0 +1,76 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.utils;
+
+import javax.xml.transform.Templates;
+
+import org.apache.lucene.gdata.search.config.IndexSchema;
+import org.apache.lucene.gdata.server.registry.ProvidedService;
+
+import com.google.gdata.data.Entry;
+import com.google.gdata.data.ExtensionProfile;
+import com.google.gdata.data.Feed;
+
+public class ProvidedServiceStub implements ProvidedService {
+
+    public static final String SERVICE_NAME = "service";
+    private IndexSchema indexSchema;
+
+    public ProvidedServiceStub() {
+        super();
+        // TODO Auto-generated constructor stub
+    }
+
+    public Class getFeedType() {
+
+        return Feed.class;
+    }
+
+    public ExtensionProfile getExtensionProfile() {
+
+        return new ExtensionProfile();
+    }
+
+    public Class getEntryType() {
+
+        return Entry.class;
+    }
+
+    public String getName() {
+
+        return SERVICE_NAME;
+    }
+
+    public void destroy() {
+    }
+    public void setIndexSchema(IndexSchema schema){
+        this.indexSchema = schema;
+        this.indexSchema.setName(SERVICE_NAME);
+    }
+    public IndexSchema getIndexSchema() {
+        
+        return this.indexSchema;
+    }
+
+    public Templates getTransformTemplate() {
+        
+        return null;
+    }
+
+  
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/utils/ServiceFactoryStub.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/utils/ServiceFactoryStub.java
new file mode 100644
index 0000000..0311e9c
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/utils/ServiceFactoryStub.java
@@ -0,0 +1,64 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.utils;
+
+import org.apache.lucene.gdata.server.GDataRequest;
+import org.apache.lucene.gdata.server.Service;
+import org.apache.lucene.gdata.server.ServiceFactory;
+import org.apache.lucene.gdata.server.administration.AdminService;
+import org.apache.lucene.gdata.server.registry.Component;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+
+
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+@Component(componentType=ComponentType.SERVICEFACTORY)
+public class ServiceFactoryStub extends ServiceFactory {
+   
+    public Service service;
+    public AdminService adminService;
+    /**
+     * @see org.apache.lucene.gdata.server.ServiceFactory#getAdminService()
+     */
+    @Override
+    public AdminService getAdminService() {
+        
+        return adminService;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.ServiceFactory#getService()
+     */
+    @Override
+    public Service getService(GDataRequest request) {
+        
+        return service;
+    }
+
+    public void setAdminService(AdminService service) {
+        this.adminService = service;
+    }
+    public void setService(Service service) {
+        this.service = service;
+    }
+    
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/utils/StorageControllerStub.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/utils/StorageControllerStub.java
new file mode 100644
index 0000000..2667014
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/utils/StorageControllerStub.java
@@ -0,0 +1,66 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.utils;
+
+import org.apache.lucene.gdata.server.registry.Component;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+import org.apache.lucene.gdata.storage.Storage;
+import org.apache.lucene.gdata.storage.StorageController;
+import org.apache.lucene.gdata.storage.StorageException;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+@Component(componentType = ComponentType.STORAGECONTROLLER)
+public class StorageControllerStub implements StorageController {
+
+    /**
+     * 
+     */
+    public StorageControllerStub() {
+        super();
+        // TODO Auto-generated constructor stub
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.StorageController#destroy()
+     */
+    public void destroy() {
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.StorageController#getStorage()
+     */
+    public Storage getStorage() throws StorageException {
+
+        return new StorageStub();
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.server.registry.ServerComponent#initialize()
+     */
+    public void initialize() {
+    }
+
+    public String releaseId() {
+        
+        return null;
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/utils/StorageStub.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/utils/StorageStub.java
new file mode 100644
index 0000000..321d603
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/utils/StorageStub.java
@@ -0,0 +1,179 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.utils;
+
+import java.util.Date;
+
+import org.apache.lucene.gdata.data.GDataAccount;
+import org.apache.lucene.gdata.data.ServerBaseEntry;
+import org.apache.lucene.gdata.data.ServerBaseFeed;
+import org.apache.lucene.gdata.server.registry.Component;
+import org.apache.lucene.gdata.server.registry.ComponentType;
+import org.apache.lucene.gdata.storage.Storage;
+import org.apache.lucene.gdata.storage.StorageController;
+import org.apache.lucene.gdata.storage.StorageException;
+
+import com.google.gdata.data.BaseEntry;
+import com.google.gdata.data.BaseFeed;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+@Component(componentType=ComponentType.STORAGECONTROLLER)
+public class StorageStub implements Storage, StorageController {
+public static String SERVICE_TYPE_RETURN = "service";
+    /**
+     * 
+     */
+    public StorageStub() {
+        super();
+        // TODO Auto-generated constructor stub
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#storeEntry(org.apache.lucene.gdata.data.ServerBaseEntry)
+     */
+    public BaseEntry storeEntry(ServerBaseEntry entry)
+            throws StorageException {
+
+        return null;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#deleteEntry(org.apache.lucene.gdata.data.ServerBaseEntry)
+     */
+    public void deleteEntry(ServerBaseEntry entry) throws StorageException {
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#updateEntry(org.apache.lucene.gdata.data.ServerBaseEntry)
+     */
+    public BaseEntry updateEntry(ServerBaseEntry entry)
+            throws StorageException {
+
+        return null;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#getFeed(org.apache.lucene.gdata.data.ServerBaseFeed)
+     */
+    public BaseFeed getFeed(ServerBaseFeed feed) throws StorageException {
+
+        return null;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#getEntry(org.apache.lucene.gdata.data.ServerBaseEntry)
+     */
+    public BaseEntry getEntry(ServerBaseEntry entry)
+            throws StorageException {
+
+        return null;
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#storeAccount(org.apache.lucene.gdata.data.GDataAccount)
+     */
+    public void storeAccount(GDataAccount Account) throws StorageException {
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#updateAccount(org.apache.lucene.gdata.data.GDataAccount)
+     */
+    public void updateAccount(GDataAccount Account) throws StorageException {
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#deleteAccount(java.lang.String)
+     */
+    public void deleteAccount(String Accountname) throws StorageException {
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#storeFeed(org.apache.lucene.gdata.data.ServerBaseFeed, java.lang.String)
+     */
+    public void storeFeed(ServerBaseFeed feed, String accountname)
+            throws StorageException {
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#deleteFeed(java.lang.String)
+     */
+    public void deleteFeed(String feedId) throws StorageException {
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#updateFeed(org.apache.lucene.gdata.data.ServerBaseFeed, java.lang.String)
+     */
+    public void updateFeed(ServerBaseFeed feed, String accountname)
+            throws StorageException {
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#close()
+     */
+    public void close() {
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.storage.Storage#getServiceForFeed(java.lang.String)
+     */
+    public String getServiceForFeed(String feedId) throws StorageException {
+
+        return SERVICE_TYPE_RETURN;
+    }
+
+    public void destroy() {
+    }
+
+    public Storage getStorage() throws StorageException {
+        
+        return new StorageStub();
+    }
+
+    public GDataAccount getAccount(String accountName) throws StorageException {
+        
+        return null;
+    }
+
+    public String getAccountNameForFeedId(String feedId) throws StorageException {
+        
+        return null;
+    }
+
+    public void initialize() {
+    }
+
+
+    public Long getFeedLastModified(String feedId) throws StorageException {
+        
+        return null;
+    }
+
+    public Long getEntryLastModified(String entryId, String feedId) throws StorageException {
+        
+        return null;
+    }
+
+    public String releaseId() {
+        
+        return null;
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/utils/TestDateFormater.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/utils/TestDateFormater.java
new file mode 100644
index 0000000..9c586b9
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/utils/TestDateFormater.java
@@ -0,0 +1,59 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.utils;
+
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+
+import junit.framework.TestCase;
+
+public class TestDateFormater extends TestCase {
+
+    protected void setUp() throws Exception {
+        super.setUp();
+    }
+
+    protected void tearDown() throws Exception {
+        super.tearDown();
+    }
+    /*
+     * Test method for 'org.apache.lucene.gdata.utils.DateFormater.formatDate(Date, String)'
+     */
+    public void testFormatDate() throws ParseException {
+        // this reg. --> bit weak but does the job
+            java.util.regex.Pattern pattern =  java.util.regex.Pattern.compile("[A-Z][a-z]{1,2}, [0-9]{1,2} [A-Z][a-z]{2} [0-9]{4} [0-9]{1,2}:[0-9]{1,2}:[0-9]{1,2} [A-Z]{2,4}");
+            Date date = new Date();
+            String formatedDate = DateFormater.formatDate(date,DateFormater.HTTP_HEADER_DATE_FORMAT);
+            assertTrue(pattern.matcher(formatedDate).matches());    
+            DateFormater.parseDate("Sun, 25 Jun 2006 13:51:23 +0000",DateFormater.HTTP_HEADER_DATE_FORMAT,DateFormater.HTTP_HEADER_DATE_FORMAT_TIME_OFFSET);
+            DateFormater.parseDate("Sun, 25 Jun 2006 13:51:23 CEST",DateFormater.HTTP_HEADER_DATE_FORMAT,DateFormater.HTTP_HEADER_DATE_FORMAT_TIME_OFFSET);
+            //TODO extend this
+    }
+    
+    public void testFormatDateStack(){
+        DateFormater formater = new DateFormater();
+        SimpleDateFormat f1 = formater.getFormater();
+        SimpleDateFormat f2 = formater.getFormater();
+        assertNotSame(f1,f2);
+        formater.returnFomater(f1);
+        assertSame(f1,formater.getFormater());
+        formater.returnFomater(f2);
+        assertSame(f2,formater.getFormater());
+        
+    }
+    
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/utils/TestReflectionUtils.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/utils/TestReflectionUtils.java
new file mode 100755
index 0000000..127b3b0
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/utils/TestReflectionUtils.java
@@ -0,0 +1,119 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.utils;
+
+import org.apache.lucene.gdata.search.analysis.PlainTextStrategy;
+import org.apache.lucene.gdata.search.config.IndexSchemaField;
+import org.apache.lucene.gdata.utils.ReflectionUtils.ReflectionException;
+import org.apache.lucene.search.RangeQuery;
+
+import junit.framework.TestCase;
+
+public class TestReflectionUtils extends TestCase {
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.utils.ReflectionUtils.implementsType(Class, Class)'
+     */
+    public void testImplementsType() {
+
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.utils.ReflectionUtils.extendsType(Class, Class)'
+     */
+    public void testExtendsType() {
+        assertTrue(ReflectionUtils.isTypeOf(Integer.class,Number.class));
+        assertFalse(ReflectionUtils.isTypeOf(null,CharSequence.class));
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.utils.ReflectionUtils.isTypeOf(Class, Class)'
+     */
+    public void testIsTypeOf() {
+        assertTrue(ReflectionUtils.isTypeOf(String.class,CharSequence.class));
+        assertTrue(ReflectionUtils.isTypeOf(Integer.class,Number.class));
+        assertFalse(ReflectionUtils.isTypeOf(Integer.class,CharSequence.class));
+        assertFalse(ReflectionUtils.isTypeOf(null,CharSequence.class));
+        assertFalse(ReflectionUtils.isTypeOf(Integer.class,null));
+
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.utils.ReflectionUtils.getDefaultInstance(Class<T>) <T>'
+     */
+    public void testGetDefaultInstance() {
+        assertEquals(new String(),ReflectionUtils.getDefaultInstance(String.class));
+        try{
+        ReflectionUtils.getDefaultInstance(Integer.class);
+        fail("can not create instance");
+        }catch (ReflectionException e) {
+            
+        }
+        try{
+            ReflectionUtils.getDefaultInstance(null);
+            fail("can not create instance");
+            }catch (ReflectionException e) {
+                
+            }
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.utils.ReflectionUtils.canCreateInstance(Class)'
+     */
+    public void testCanCreateInstance() {
+        assertTrue(ReflectionUtils.canCreateInstance(String.class));
+        assertFalse(ReflectionUtils.canCreateInstance(Integer.class));
+        assertFalse(ReflectionUtils.canCreateInstance(Integer.TYPE));
+        assertFalse(ReflectionUtils.canCreateInstance(null));
+        
+        
+        
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.utils.ReflectionUtils.getPrimitiveWrapper(Class)'
+     */
+    public void testGetPrimitiveWrapper() {
+        
+        assertEquals(Integer.class,ReflectionUtils.getPrimitiveWrapper(Integer.TYPE));
+        assertEquals(Long.class,ReflectionUtils.getPrimitiveWrapper(Long.TYPE));
+        assertEquals(Float.class,ReflectionUtils.getPrimitiveWrapper(Float.TYPE));
+        assertEquals(Byte.class,ReflectionUtils.getPrimitiveWrapper(Byte.TYPE));
+        assertEquals(Double.class,ReflectionUtils.getPrimitiveWrapper(Double.TYPE));
+        assertEquals(Short.class,ReflectionUtils.getPrimitiveWrapper(Short.TYPE));
+        assertEquals(Boolean.class,ReflectionUtils.getPrimitiveWrapper(Boolean.TYPE));
+        try {
+        ReflectionUtils.getPrimitiveWrapper(null);
+        fail("type is null");
+        }catch (ReflectionException e) {
+            
+        }
+        try {
+            ReflectionUtils.getPrimitiveWrapper(String.class);
+            fail("type is not a primitive");
+            }catch (ReflectionException e) {
+                
+            }
+        
+    }
+    
+    public void testHasdesiredconstructor(){
+        assertFalse(ReflectionUtils.hasDesiredConstructor(PlainTextStrategy.class, new Class[]{IndexSchemaField.class}));
+        assertFalse(ReflectionUtils.hasDesiredConstructor(PlainTextStrategy.class, new Class[]{}));
+        assertTrue(ReflectionUtils.hasDesiredConstructor(String.class, new Class[]{String.class}));
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/utils/TestSimpleObjectPool.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/utils/TestSimpleObjectPool.java
new file mode 100755
index 0000000..0920c48
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/utils/TestSimpleObjectPool.java
@@ -0,0 +1,155 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissi/**
+ * 
+ */
+
+package org.apache.lucene.gdata.utils;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import junit.framework.TestCase;
+
+public class TestSimpleObjectPool extends TestCase {
+    private Pool testPool;
+    private int SIZE = 10;
+    protected void setUp() throws Exception {
+        this.testPool =new SimpleObjectPool(SIZE,new ObjectFactoryStub());
+    }
+
+    protected void tearDown() throws Exception {
+        super.tearDown();
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.utils.SimpleObjectPool.SimpleObjectPool(int, PoolObjectFactory<Type>)'
+     */
+    public void testSimpleObjectPool() {
+        SimpleObjectPool pool = new SimpleObjectPool(1,new ObjectFactoryStub());
+        assertEquals(pool.getSize(),SimpleObjectPool.MINIMALSIZE);
+        pool = new SimpleObjectPool(-100,new ObjectFactoryStub());
+        assertEquals(pool.getSize(),SimpleObjectPool.MINIMALSIZE);
+        pool = new SimpleObjectPool(new ObjectFactoryStub());
+        assertEquals(pool.getSize(),SimpleObjectPool.DEFAULTSIZE);
+        pool = new SimpleObjectPool(100,new ObjectFactoryStub());
+        
+        assertEquals(100,pool.getSize());
+        try{
+        pool = new SimpleObjectPool(1,null);
+            fail("factory must not be null");
+        }catch (Exception e) {
+            // TODO: handle exception
+        }
+        
+
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.utils.SimpleObjectPool.aquire()'
+     */
+    public void testAquire() {
+        List l = new ArrayList(SIZE);
+        for (int i = 0; i < SIZE; i++) {
+            Object o = this.testPool.aquire();
+            assertNotNull(o);
+            assertFalse(l.contains(o));
+            l.add(o);
+            
+        }
+        for (Object object : l) {
+            this.testPool.release(object);
+        }
+        for (int i = 0; i < SIZE; i++) {
+            Object o = this.testPool.aquire();
+            assertNotNull(o);
+            assertTrue(l.contains(o));
+         
+            
+        }
+        
+    }
+
+    /*
+     * Test method for 'org.apache.lucene.gdata.utils.SimpleObjectPool.release(Type)'
+     */
+    public void testRelease() {
+        List l = new ArrayList(SIZE);
+        for (int i = 0; i < SIZE; i++) {
+            Object o = this.testPool.aquire();
+            assertNotNull(o);
+            assertFalse(l.contains(o));
+            l.add(o);
+            
+        }
+        
+        for (Object object : l) {
+            this.testPool.release(object);
+        }
+        for (int i = 0; i < 10; i++) {
+            this.testPool.release(new Object());
+        }
+        
+        for (int i = 0; i < SIZE; i++) {
+            Object o = this.testPool.aquire();
+            assertNotNull(o);
+            assertTrue(l.contains(o));
+         
+            
+        }
+        
+        //############################
+        
+        for (Object object : l) {
+            this.testPool.release(object);
+        }
+        
+        for (int i = 0; i < SIZE +SIZE; i++) {
+            Object o = this.testPool.aquire();
+            assertNotNull(o);
+            
+            if(i>= SIZE)
+                assertFalse(l.contains(o));
+            else
+            assertTrue(l.contains(o));
+        }
+    }
+    
+    public void testDestroy(){
+        this.testPool.destroy();
+        try{
+        this.testPool.aquire();
+        fail("pool is already closed");
+        }catch (Exception e) {
+            // TODO: handle exception
+        }
+        this.testPool.release(new Object());
+    }
+    
+    static class ObjectFactoryStub implements PoolObjectFactory{
+
+        public Object getInstance() {
+            
+            return new Object();
+        }
+
+        
+
+        public void destroyInstance(Object type) {
+            //
+        }
+        
+        
+    }
+
+}
diff --git a/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/utils/Visitor.java b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/utils/Visitor.java
new file mode 100755
index 0000000..9824f6a
--- /dev/null
+++ b/contrib/gdata-server/src/core/src/test/org/apache/lucene/gdata/utils/Visitor.java
@@ -0,0 +1,24 @@
+/** 
+ * Copyright 2004 The Apache Software Foundation 
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ * 
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.apache.lucene.gdata.utils;
+
+/**
+ * @author Simon Willnauer
+ *
+ */
+public interface Visitor {
+    public void execute(Object[] objects);
+}
diff --git a/contrib/gdata-server/src/core/test/gdata-account.xsd b/contrib/gdata-server/src/core/test/gdata-account.xsd
deleted file mode 100755
index bc0b0e0..0000000
--- a/contrib/gdata-server/src/core/test/gdata-account.xsd
+++ /dev/null
@@ -1,50 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
-	<xs:element name="password">
-		<xs:simpleType>
-			<xs:restriction base="xs:string">
-				<xs:minLength value="5" />
-			</xs:restriction>
-		</xs:simpleType>
-	</xs:element> 
-	<xs:element name="account-name">
-		<xs:simpleType>
-			<xs:restriction base="xs:string">
-				<xs:whiteSpace value="collapse" />
-			</xs:restriction>
-		</xs:simpleType>
-	</xs:element>
-
-	<xs:element name="email-address" type="xs:string" />
-	<xs:element name="url" type="xs:anyURI" />
-	<xs:element name="name" type="xs:string" />
-	<xs:element name="account-role">
-		<xs:simpleType>
-			<xs:restriction base="xs:positiveInteger">
-				<xs:fractionDigits value="2" />
-			</xs:restriction>
-		</xs:simpleType>
-	</xs:element>
-
-
-	<xs:element name="account-owner">
-		<xs:complexType>
-			<xs:sequence>
-				<xs:element ref="name" />
-				<xs:element ref="email-address" />
-				<xs:element ref="url" />
-			</xs:sequence>
-		</xs:complexType>
-	</xs:element>
-
-	<xs:element name="account">
-		<xs:complexType>
-			<xs:sequence>
-				<xs:element ref="account-name" />
-				<xs:element ref="password" />
-				<xs:element ref="account-role" />
-				<xs:element ref="account-owner" minOccurs="0" />
-			</xs:sequence>
-		</xs:complexType>
-	</xs:element>
-</xs:schema>
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/test/gdata-config.xml b/contrib/gdata-server/src/core/test/gdata-config.xml
deleted file mode 100644
index e69de29..0000000
diff --git a/contrib/gdata-server/src/core/test/lucenestorage.properties.xml b/contrib/gdata-server/src/core/test/lucenestorage.properties.xml
deleted file mode 100644
index e69de29..0000000
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/data/TestGDataUser.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/data/TestGDataUser.java
deleted file mode 100644
index ec2a877..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/data/TestGDataUser.java
+++ /dev/null
@@ -1,132 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.data;
-
-import junit.framework.TestCase;
-
-import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
-
-/**
- * @author Simon Willnauer
- *
- */
-public class TestGDataUser extends TestCase {
-    private GDataAccount user;
-    @Override
-    protected void setUp() throws Exception {
-        this.user = new GDataAccount();
-        this.user.setName("simonW");
-        super.setUp();
-    }
-
-    @Override
-    protected void tearDown() throws Exception {
-        
-        super.tearDown();
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.data.GDataUser.isUserInRole(UserRole)'
-     */
-    public void testIsUserInRole() {
-        assertFalse(this.user.isUserInRole(null));
-        assertTrue(this.user.isUserInRole(AccountRole.USER));
-        assertFalse(this.user.isUserInRole(AccountRole.ENTRYAMINISTRATOR));
-        this.user.setRole(AccountRole.ENTRYAMINISTRATOR);
-        assertTrue(this.user.isUserInRole(AccountRole.ENTRYAMINISTRATOR));
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.data.GDataUser.getRolesAsInt()'
-     */
-    public void testGetRolesAsInt() {
-        assertEquals(1,this.user.getRolesAsInt());
-        this.user.setRole(AccountRole.ENTRYAMINISTRATOR);
-        assertEquals(3,this.user.getRolesAsInt());
-        this.user.setRole(AccountRole.FEEDAMINISTRATOR);
-        assertEquals(7,this.user.getRolesAsInt());
-        this.user.setRole(AccountRole.USERADMINISTRATOR);
-        assertEquals(15,this.user.getRolesAsInt());
-        
-        
-        
-    }
-    
-    public void testIsUserInRoleInt(){
-        assertFalse(GDataAccount.isInRole(1,AccountRole.ENTRYAMINISTRATOR));
-        assertFalse(GDataAccount.isInRole(1,AccountRole.FEEDAMINISTRATOR));
-        assertTrue(GDataAccount.isInRole(3,AccountRole.ENTRYAMINISTRATOR));
-        assertTrue(GDataAccount.isInRole(15,AccountRole.ENTRYAMINISTRATOR));
-        assertTrue(GDataAccount.isInRole(3,AccountRole.USER));
-        assertTrue(GDataAccount.isInRole(15,AccountRole.USERADMINISTRATOR));
-        assertFalse(GDataAccount.isInRole(7,AccountRole.USERADMINISTRATOR));
-        assertFalse(GDataAccount.isInRole(7,null));
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.data.GDataUser.setRolesAsInt(int)'
-     */
-    public void testSetRolesAsInt() {
-        this.user.setRolesAsInt(2);
-        this.user.setRolesAsInt(4);
-        this.user.setRolesAsInt(8);
-        assertEquals(4,this.user.getRoles().size()); 
-        this.user.setRolesAsInt(15);
-        assertEquals(4,this.user.getRoles().size());
-        this.user = new GDataAccount();
-        this.user.setName("simon");
-        this.user.setRolesAsInt(15);
-        assertEquals(4,this.user.getRoles().size());
-        
-    }
-    
-    public void testEquals(){
-        assertTrue(this.user.equals(this.user));
-        GDataAccount a = new GDataAccount();
-        a.setName(this.user.getName());
-        assertTrue(this.user.equals(a));
-        a.setName("someOtheraccount");
-        assertFalse(this.user.equals(a));
-        assertFalse(this.user.equals(null));
-        assertFalse(this.user.equals(new String()));
-        assertFalse(new GDataAccount().equals(new GDataAccount()));
-    }
-    public void testHashCode(){
-        assertEquals(this.user.hashCode(),this.user.hashCode());
-        assertFalse(this.user.hashCode()== this.user.getName().hashCode());
-        GDataAccount a = new GDataAccount();
-        a.setName(this.user.getName());
-        assertEquals(this.user.hashCode(),a.hashCode());
-        a.setName(null);
-        assertFalse(a.hashCode()== this.user.hashCode());
-    }
-    
-    public void testReqValuesSet(){
-        assertFalse(this.user.requiredValuesSet());
-        this.user.setPassword("hello");
-        assertFalse(this.user.requiredValuesSet());
-        this.user.setPassword("helloworld");
-        assertTrue(this.user.requiredValuesSet());
-        assertFalse(new GDataAccount().requiredValuesSet());
-    }
-    
-    public void testToStringPrevNulPEx(){
-        assertNotNull(this.user.toString());
-    }
-    
-    
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/TestStandardGdataSearcher.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/TestStandardGdataSearcher.java
deleted file mode 100755
index 26ee9df..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/TestStandardGdataSearcher.java
+++ /dev/null
@@ -1,222 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.search;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-
-import junit.framework.TestCase;
-
-import org.apache.lucene.analysis.standard.StandardAnalyzer;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.gdata.search.StandardGdataSearcher;
-import org.apache.lucene.gdata.search.index.IndexDocument;
-import org.apache.lucene.gdata.utils.ReferenceCounter;
-import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.Hits;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.RAMDirectory;
-
-/**
- * @author Simon Willnauer
- *
- */
-public class TestStandardGdataSearcher extends TestCase {
-    private Directory dir;
-
-    private int amountDocuments = 30;
-
-    private static final String FIELDNAME = "fname";
-
-    private static final String FIELDVALUE = "foobar";
-
-    private ReferenceCounter<IndexSearcher> searcher;
-
-    private StandardGdataSearcher gdataSearcher;
-
-    private List<String> idlist;
-    
-    private String feedId = "myFeed";
-
-    protected void setUp() throws Exception {
-        this.dir = new RAMDirectory();
-        IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(), true);
-        this.idlist = new ArrayList<String>();
-        for (int i = 0; i < this.amountDocuments; i++) {
-            Document doc = new Document();
-            doc.add(new Field(IndexDocument.FIELD_FEED_ID, this.feedId,
-                    Field.Store.YES, Field.Index.UN_TOKENIZED));
-            doc.add(new Field(IndexDocument.FIELD_ENTRY_ID, "" + i,
-                    Field.Store.YES, Field.Index.UN_TOKENIZED));
-            doc.add(new Field(FIELDNAME, FIELDVALUE, Field.Store.YES,
-                    Field.Index.UN_TOKENIZED));
-            writer.addDocument(doc);
-            this.idlist.add("" + i);
-        }
-        writer.close();
-        this.searcher = new TestRefcounter(new IndexSearcher(this.dir));
-        this.searcher.increamentReference();
-        this.gdataSearcher = new StandardGdataSearcher(this.searcher);
-    }
-
-    protected void tearDown() throws Exception {
-        this.searcher.decrementRef();
-        StandardGdataSearcher.flushFilterCache();
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.search.StandardGdataSearcher.StandardGdataSearcher(ReferenceCounter<IndexSearcher>)'
-     */
-    public void testStandardGdataSearcher() {
-        try {
-            new StandardGdataSearcher(null);
-            fail("searcher ref is null");
-        } catch (IllegalArgumentException e) {
-
-        }
-        new StandardGdataSearcher(this.searcher);
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.search.StandardGdataSearcher.search(Query, int,
-     * int)'
-     */
-    public void testSearch() throws IOException {
-        Query q = new TermQuery(new Term(FIELDNAME, FIELDVALUE));
-        Hits hits = this.searcher.get().search(q);
-        assertEquals(amountDocuments, hits.length());
-        List<String> returnValue = this.gdataSearcher.search(q,
-                this.amountDocuments, 0,this.feedId);
-        assertEquals(amountDocuments, returnValue.size());
-        assertTrue(returnValue.containsAll(this.idlist));
-        try {
-            this.gdataSearcher.search(null, 1, 0,this.feedId);
-            fail("searcher is null");
-        } catch (RuntimeException e) {
-        }
-
-        try {
-            this.gdataSearcher.search(q, -1, 5,this.feedId);
-            fail("hitcount is less than 0");
-        } catch (IllegalArgumentException e) {}
-        try {
-            this.gdataSearcher.search(q, 4, -1,this.feedId);
-            fail("offset is less than 0");
-        } catch (IllegalArgumentException e) {}
-        try {
-            this.gdataSearcher.search(q, 4, 5,null);
-            fail("feed id is null");
-        } catch (IllegalArgumentException e) {}
-      
-        returnValue = this.gdataSearcher.search(q,this.amountDocuments, 0,"SomeOtherFeed");
-        assertEquals(0,returnValue.size());
-        
-
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.search.StandardGdataSearcher.collectHits(Hits,
-     * int, int)'
-     */
-    public void testCollectHits() throws IOException {
-        Query q = new TermQuery(new Term(FIELDNAME, FIELDVALUE));
-        Hits hits = this.searcher.get().search(q);
-        assertEquals(amountDocuments, hits.length());
-        List<String> returnValue = this.gdataSearcher.collectHits(hits, 1, 0);
-        assertEquals(hits.doc(0).getField(IndexDocument.FIELD_ENTRY_ID)
-                .stringValue(), returnValue.get(0));
-
-        returnValue = this.gdataSearcher.collectHits(hits, 1, 1);
-        assertEquals(hits.doc(0).getField(IndexDocument.FIELD_ENTRY_ID)
-                .stringValue(), returnValue.get(0));
-
-        returnValue = this.gdataSearcher.collectHits(hits, 1,
-                this.amountDocuments);
-        assertEquals(1, returnValue.size());
-        assertEquals(hits.doc(this.amountDocuments - 1).getField(
-                IndexDocument.FIELD_ENTRY_ID).stringValue(), returnValue.get(0));
-
-        returnValue = this.gdataSearcher.collectHits(hits, 10,
-                this.amountDocuments);
-        assertEquals(1, returnValue.size());
-        assertEquals(hits.doc(this.amountDocuments - 1).getField(
-                IndexDocument.FIELD_ENTRY_ID).stringValue(), returnValue.get(0));
-
-        returnValue = this.gdataSearcher.collectHits(hits, 50, 0);
-        assertEquals(this.amountDocuments, returnValue.size());
-        assertTrue(returnValue.containsAll(this.idlist));
-
-        returnValue = this.gdataSearcher.collectHits(hits, 1, 5);
-        assertEquals(1, returnValue.size());
-        assertEquals(hits.doc(4).getField(IndexDocument.FIELD_ENTRY_ID)
-                .stringValue(), returnValue.get(0));
-
-        returnValue = this.gdataSearcher.collectHits(hits, 50,
-                this.amountDocuments);
-        assertEquals(1, returnValue.size());
-        assertEquals(hits.doc(this.amountDocuments - 1).getField(
-                IndexDocument.FIELD_ENTRY_ID).stringValue(), returnValue.get(0));
-
-        returnValue = this.gdataSearcher.collectHits(hits, 1,
-                this.amountDocuments + 1);
-        assertEquals(0, returnValue.size());
-
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.search.StandardGdataSearcher.close()'
-     */
-    public void testClose() throws IOException {
-        StandardGdataSearcher s = new StandardGdataSearcher(new TestRefcounter(
-                new IndexSearcher(this.dir)));
-        s.close();
-        try {
-            s.search(null, 0, 0,this.feedId);
-            fail("searcher is closed");
-        } catch (IllegalStateException e) {
-        }
-
-    }
-
-    private static class TestRefcounter extends ReferenceCounter<IndexSearcher> {
-
-        public TestRefcounter(IndexSearcher resource) {
-            super(resource);
-            // TODO Auto-generated constructor stub
-        }
-
-        @Override
-        protected void close() {
-            try {
-                this.resource.close();
-            } catch (Exception e) {
-                // TODO: handle exception
-            }
-        }
-
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/analysis/IndexableStub.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/analysis/IndexableStub.java
deleted file mode 100755
index f16c213..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/analysis/IndexableStub.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.search.analysis;
-
-import java.lang.reflect.InvocationHandler;
-import java.lang.reflect.Method;
-import java.lang.reflect.Proxy;
-
-import javax.xml.xpath.XPathExpressionException;
-
-import org.w3c.dom.NamedNodeMap;
-import org.w3c.dom.Node;
-
-/**
- * @author Simon Willnauer
- *
- */
-public class IndexableStub extends Indexable {
-
-    private String content;
-    private boolean retNull;
-    int times = 1;
-    int count = 0;
-    IndexableStub() {
-        super(null);
-
-    }
-    public void returnProxyTimes(int times){
-        this.times = times;
-    }
-    public void setReturnNull(boolean returnNull){
-        this.retNull = returnNull;
-    }
-    public void setReturnValueTextContent(String content){
-        this.content = content;
-    }
-    @Override
-    public Node applyPath(String xPath) throws XPathExpressionException {
-        if(xPath == null)
-            throw new XPathExpressionException("path is null");
-        if(this.retNull)
-            return null;
-        if(times == count)
-            return null;
-        times++;
-        return (Node)Proxy.newProxyInstance(this.getClass().getClassLoader(),new Class[] {Node.class,NamedNodeMap.class},new Handler(this.content));
-        
-    }
-
-    private static class Handler implements InvocationHandler{
-        String returnValue;
-        public Handler(String toReturn){
-            this.returnValue = toReturn;
-        }
-        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
-            if(method.getName().equals("getNextSibling")){
-                return null;
-            }
-            if(method.getReturnType() == String.class)
-                return this.returnValue;
-            if(method.getReturnType() == Node.class)
-                
-            return (Node)Proxy.newProxyInstance(this.getClass().getClassLoader(),new Class[] {Node.class,NamedNodeMap.class},new Handler(this.returnValue));
-            if(method.getReturnType() == NamedNodeMap.class)
-                return  (NamedNodeMap)Proxy.newProxyInstance(this.getClass().getClassLoader(),new Class[] {Node.class,NamedNodeMap.class},new Handler(this.returnValue));
-            return null;
-            
-        }
-        
-    }
-    
-
-
-}
-
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/analysis/TestContentStrategy.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/analysis/TestContentStrategy.java
deleted file mode 100755
index 2ae2fa5..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/analysis/TestContentStrategy.java
+++ /dev/null
@@ -1,131 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.search.analysis;
-
-import org.apache.lucene.document.Field;
-import org.apache.lucene.document.Field.Index;
-import org.apache.lucene.document.Field.Store;
-import org.apache.lucene.gdata.data.ServerBaseEntry;
-import org.apache.lucene.gdata.search.config.IndexSchemaField;
-import org.apache.lucene.gdata.search.index.GdataIndexerException;
-import org.w3c.dom.Node;
-
-import junit.framework.TestCase;
-
-public class TestContentStrategy extends TestCase {
-    private static final String FIELD = "foo";
-    private static final float BOOST = 2.0f;
-    ContentStrategy strategy;
-    
-    protected void setUp() throws Exception {
-        IndexSchemaField field = new IndexSchemaField();
-        field.setName(FIELD);
-        field.setStore(Field.Store.YES);
-        field.setIndex(Field.Index.UN_TOKENIZED);
-        field.setBoost(BOOST);
-        this.strategy = new TestStrategy(field);
-    }
-
-    protected void tearDown() throws Exception {
-        super.tearDown();
-    }
-    public void testContentStrategyIndexStoreField() throws NotIndexableException{
-        IndexSchemaField field = new IndexSchemaField();
-        field.setName(FIELD);
-        
-        
-        this.strategy = new TestStrategy(Field.Index.UN_TOKENIZED,Field.Store.YES,field);
-        this.strategy.processIndexable(null);
-        Field f = this.strategy.createLuceneField()[0];
-        assertEquals(FIELD,f.name());
-        assertEquals(TestStrategy.CONTENT,f.stringValue());
-        assertEquals(1.0f,f.getBoost());
-        assertTrue(f.isIndexed());
-        assertTrue(f.isStored());
-        assertFalse(f.isTokenized());
-        assertFalse(f.isCompressed());
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.search.analysis.ContentStrategy.ContentStrategy(Index, Store, IndexSchemaField)'
-     */
-    public void testContentStrategyIndexSchemaField() throws NotIndexableException {
-        IndexSchemaField field = new IndexSchemaField();
-        field.setName(FIELD);
-        
-        
-        this.strategy = new TestStrategy(field);
-        this.strategy.processIndexable(null);
-        Field f = this.strategy.createLuceneField()[0];
-        
-        assertEquals(FIELD,f.name());
-        assertEquals(TestStrategy.CONTENT,f.stringValue());
-        assertEquals(1.0f,f.getBoost());
-        assertTrue(f.isIndexed());
-        assertFalse(f.isStored());
-        assertTrue(f.isTokenized());
-        assertFalse(f.isCompressed());
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.search.analysis.ContentStrategy.createLuceneField()'
-     */
-    public void testCreateLuceneField() throws NotIndexableException {
-        try{
-        this.strategy.createLuceneField();
-        fail("processIndexable is not called");
-        }catch (GdataIndexerException e) {
-          //
-        }
-        this.strategy.processIndexable(null);
-        Field f = this.strategy.createLuceneField()[0];
-        
-        assertEquals(FIELD,f.name());
-        assertEquals(TestStrategy.CONTENT,f.stringValue());
-        assertEquals(BOOST,f.getBoost());
-        assertTrue(f.isIndexed());
-        assertTrue(f.isStored());
-        assertFalse(f.isTokenized());
-        assertFalse(f.isCompressed());
-       
-        
-        
-    }
-    
-    private static class TestStrategy extends ContentStrategy{
-
-        private static final String CONTENT = "someString";
-
-      
-        protected TestStrategy(Index index, Store store, IndexSchemaField fieldConfig) {
-            super(index, store, fieldConfig);
-      
-        }
-
-        protected TestStrategy(IndexSchemaField fieldConfiguration) {
-            super(fieldConfiguration);
-            
-        }
-
-        @Override
-        public void processIndexable(Indexable<? extends Node, ? extends ServerBaseEntry> indexable) throws NotIndexableException {
-            this.content = CONTENT;
-        }
-        
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/analysis/TestDomIndexable.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/analysis/TestDomIndexable.java
deleted file mode 100755
index 2555673..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/analysis/TestDomIndexable.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.search.analysis;
-
-import javax.xml.xpath.XPathExpressionException;
-
-import junit.framework.TestCase;
-
-import org.apache.lucene.gdata.data.ServerBaseEntry;
-import org.apache.lucene.gdata.server.registry.ProvidedServiceConfig;
-import org.apache.lucene.gdata.utils.ProvidedServiceStub;
-import org.w3c.dom.Attr;
-import org.w3c.dom.Node;
-
-import com.google.gdata.data.Category;
-import com.google.gdata.data.ExtensionProfile;
-import com.google.gdata.data.HtmlTextConstruct;
-import com.google.gdata.data.extensions.EventEntry;
-
-public class TestDomIndexable extends TestCase {
-
-   
-    public void testConstructor(){
-        try {
-            new DomIndexable(new ServerBaseEntry());
-            fail("no service config");
-        } catch (NotIndexableException e) {
-            
-            
-        }
-        ServerBaseEntry e = new ServerBaseEntry();
-        e.setServiceConfig(new ProvidedServiceConfig());
-        try {
-            new DomIndexable(e);
-            fail("no extension profile");
-        } catch (IllegalStateException e1) {
-            
-            
-        } catch (NotIndexableException e2) {
-            
-            fail("unexp. exception");   
-        }
-        e.setServiceConfig(new ProvidedServiceStub());
-        try {
-            new DomIndexable(e);
-        } catch (NotIndexableException e1) {
-         fail("unexp. exception");   
-         
-        }
-    }
-    /*
-     * Test method for 'org.apache.lucene.gdata.search.analysis.DomIndexable.applyPath(String)'
-     */
-    public void testApplyPath() throws NotIndexableException, XPathExpressionException {
-        String content = "fooo bar<br>";
-        ServerBaseEntry entry = new ServerBaseEntry();
-        entry.setContent(new HtmlTextConstruct(content));
-        entry.setServiceConfig(new ProvidedServiceStub());
-        
-            Indexable ind = new DomIndexable(entry);
-            Node n = ind.applyPath("/entry/content");
-            assertNotNull(n);
-            assertEquals(content,n.getTextContent());
-            Node attr = ind.applyPath("/entry/content/@type");
-            assertNotNull(attr);
-            assertEquals("html",attr.getTextContent());
-            assertTrue(attr instanceof Attr);
-            
-    }
-    
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/analysis/TestGdataCategoryStrategy.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/analysis/TestGdataCategoryStrategy.java
deleted file mode 100755
index 4d06e2a..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/analysis/TestGdataCategoryStrategy.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.search.analysis;
-
-import junit.framework.TestCase;
-
-import org.apache.lucene.document.Field;
-import org.apache.lucene.gdata.search.config.IndexSchemaField;
-import org.apache.lucene.gdata.search.index.GdataIndexerException;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class TestGdataCategoryStrategy extends TestCase {
-    private static final String FIELD = "foo";
-
-    private static final float BOOST = 2.0f;
-
-    GdataCategoryStrategy strategy;
-
-    private IndexSchemaField field;
-
-    protected void setUp() throws Exception {
-        this.field = new IndexSchemaField();
-        field.setName(FIELD);
-        //store and index will be ignored
-        field.setStore(Field.Store.NO);
-        field.setIndex(Field.Index.TOKENIZED);
-        field.setBoost(BOOST);
-        field.setPath("/path");
-        this.strategy = new GdataCategoryStrategy(field);
-    }
-
-    protected void tearDown() throws Exception {
-        super.tearDown();
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.search.analysis.PlainTextStrategy.processIndexable(Indexable<?
-     * extends Node, ? extends ServerBaseEntry>)'
-     */
-    public void testProcessIndexable() throws NotIndexableException {
-        IndexableStub stub = new IndexableStub();
-        stub.setReturnNull(true);
-        try {
-            this.strategy.processIndexable(stub);
-            fail("retun value is null must fail");
-        } catch (NotIndexableException e) {
-        }
-        assertNull(this.strategy.content);
-        try {
-            this.strategy.createLuceneField();
-            fail("content is not set");
-        } catch (GdataIndexerException e) {
-        }
-
-        String content = "fooBar";
-        stub.setReturnNull(false);
-        stub.setReturnValueTextContent(content);
-        this.strategy.processIndexable(stub);
-        assertNotNull(this.strategy.content);
-        assertNotNull(this.strategy.categoryScheme);
-        assertEquals(content+" "+content, this.strategy.content.trim());
-        assertEquals(content, this.strategy.categoryScheme);
-
-        Field[] fields = this.strategy.createLuceneField();
-        assertEquals(2, fields.length);
-        assertEquals(this.field.getName(), fields[0].name());
-        assertEquals(content+" "+content, fields[0].stringValue().trim());
-        assertEquals(this.strategy.categorySchemeField, fields[1].name());
-        assertEquals(content, fields[1].stringValue());
-        // this is also stored an untok.
-        assertFalse(fields[0].isStored());
-        assertTrue(fields[0].isTokenized());
-        // test for xpath exc.
-        this.field.setPath(null);
-        this.strategy = new GdataCategoryStrategy(field);
-        try {
-            this.strategy.processIndexable(stub);
-            fail("path is null must fail");
-        } catch (NotIndexableException e) {
-        }
-        try {
-            this.strategy.createLuceneField();
-            fail("content is not set");
-        } catch (GdataIndexerException e) {
-        }
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/analysis/TestGdataDateStrategy.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/analysis/TestGdataDateStrategy.java
deleted file mode 100755
index 13c4600..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/analysis/TestGdataDateStrategy.java
+++ /dev/null
@@ -1,116 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.search.analysis;
-
-import junit.framework.TestCase;
-
-import org.apache.lucene.document.Field;
-import org.apache.lucene.gdata.search.config.IndexSchemaField;
-import org.apache.lucene.gdata.search.index.GdataIndexerException;
-
-import com.google.gdata.data.DateTime;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class TestGdataDateStrategy extends TestCase {
-    private static final String FIELD = "foo";
-
-    private static final float BOOST = 2.0f;
-
-    ContentStrategy strategy;
-
-    private IndexSchemaField field;
-
-    protected void setUp() throws Exception {
-        this.field = new IndexSchemaField();
-        field.setName(FIELD);
-        field.setStore(Field.Store.NO);
-        field.setIndex(Field.Index.TOKENIZED);
-        field.setBoost(BOOST);
-        field.setPath("/path");
-        this.strategy = new GdataDateStrategy(field);
-    }
-
-    protected void tearDown() throws Exception {
-        super.tearDown();
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.search.analysis.PlainTextStrategy.processIndexable(Indexable<?
-     * extends Node, ? extends ServerBaseEntry>)'
-     */
-    public void testProcessIndexable() throws NotIndexableException {
-        IndexableStub stub = new IndexableStub();
-        stub.setReturnNull(true);
-        try {
-            this.strategy.processIndexable(stub);
-            fail("retun value is null must fail");
-        } catch (NotIndexableException e) {
-        }
-        assertNull(this.strategy.content);
-        try {
-            this.strategy.createLuceneField();
-            fail("content is not set");
-        } catch (GdataIndexerException e) {
-        }
-        // test with proper date 
-        String content = "2005-01-09T08:00:00Z";
-        String parsedConent = Long.toString(DateTime.parseDateTime(content)
-                .getValue());
-        stub.setReturnNull(false);
-        stub.setReturnValueTextContent(content);
-        this.strategy.processIndexable(stub);
-        assertNotNull(this.strategy.content);
-        assertEquals(parsedConent, this.strategy.content);
-
-        Field[] fields = this.strategy.createLuceneField();
-        assertEquals(1, fields.length);
-        assertEquals(this.field.getName(), fields[0].name());
-        assertEquals(parsedConent, fields[0].stringValue());
-        // timestamp is stored and untok.
-        assertTrue(fields[0].isStored());
-        assertFalse(fields[0].isTokenized());
-        
-        this.strategy = new GdataDateStrategy(this.field);
-        content = "2005-01-09T##08:00:00Z";
-        stub.setReturnValueTextContent(content);
-        try {
-            this.strategy.processIndexable(stub);
-            fail("unparsable date must fail");
-        } catch (NotIndexableException e) {
-        }
-        
-        
-        // test for xpath exc.
-        this.field.setPath(null);
-        this.strategy = new GdataDateStrategy(this.field);
-        try {
-            this.strategy.processIndexable(stub);
-            fail("path is null must fail");
-        } catch (NotIndexableException e) {
-        }
-        try {
-            this.strategy.createLuceneField();
-            fail("content is not set");
-        } catch (GdataIndexerException e) {
-        }
-
-    }
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/analysis/TestHTMLStrategy.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/analysis/TestHTMLStrategy.java
deleted file mode 100755
index 9b20936..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/analysis/TestHTMLStrategy.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.search.analysis;
-
-import junit.framework.TestCase;
-
-import org.apache.lucene.document.Field;
-import org.apache.lucene.gdata.search.config.IndexSchemaField;
-
-/**
- * @author Simon Willnauer
- *
- */
-public class TestHTMLStrategy extends TestCase {
-    private static final String FIELD = "foo";
-    private static final float BOOST = 2.0f;
-    ContentStrategy strategy;
-    private IndexSchemaField field;
-    protected void setUp() throws Exception {
-        this.field = new IndexSchemaField();
-        field.setName(FIELD);
-        field.setStore(Field.Store.YES);
-        field.setIndex(Field.Index.UN_TOKENIZED);
-        field.setBoost(BOOST);
-        field.setPath("/path");
-        this.strategy = new HTMLStrategy(field);
-    }
-
-    protected void tearDown() throws Exception {
-        super.tearDown();
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.search.analysis.PlainTextStrategy.processIndexable(Indexable<? extends Node, ? extends ServerBaseEntry>)'
-     */
-    public void testProcessIndexable() throws NotIndexableException {
-        IndexableStub stub = new IndexableStub();
-        stub.setReturnNull(true);
-        try{
-        this.strategy.processIndexable(stub);
-        fail("retun value is null must fail");
-        }catch (NotIndexableException e) {}
-        assertNull(this.strategy.content);
-        String content = "fooBar";
-        //just to make sure the filter is applied.
-        String htmlContent = "<b>"+content+"</b>";
-        stub.setReturnNull(false);
-        stub.setReturnValueTextContent(htmlContent);
-        this.strategy.processIndexable(stub);
-        assertNotNull(this.strategy.content);
-        assertEquals(content,this.strategy.content);
-        
-        
-        // test for xpath exc.
-        this.field.setPath(null);
-        try{
-            this.strategy.processIndexable(stub);
-            fail("path is null must fail");
-            }catch (NotIndexableException e) {}
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/analysis/TestKeywordStrategy.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/analysis/TestKeywordStrategy.java
deleted file mode 100755
index bd9cc9a..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/analysis/TestKeywordStrategy.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.search.analysis;
-
-import junit.framework.TestCase;
-
-import org.apache.lucene.document.Field;
-import org.apache.lucene.gdata.search.config.IndexSchemaField;
-import org.apache.lucene.gdata.search.index.GdataIndexerException;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class TestKeywordStrategy extends TestCase {
-    private static final String FIELD = "foo";
-
-    private static final float BOOST = 2.0f;
-
-    ContentStrategy strategy;
-
-    private IndexSchemaField field;
-
-    protected void setUp() throws Exception {
-        this.field = new IndexSchemaField();
-        field.setName(FIELD);
-        field.setStore(Field.Store.NO);
-        field.setIndex(Field.Index.TOKENIZED);
-        field.setBoost(BOOST);
-        field.setPath("/path");
-        
-        this.strategy = new KeywordStrategy(field);
-    }
-
-    protected void tearDown() throws Exception {
-        super.tearDown();
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.search.analysis.PlainTextStrategy.processIndexable(Indexable<?
-     * extends Node, ? extends ServerBaseEntry>)'
-     */
-    public void testProcessIndexable() throws NotIndexableException {
-        IndexableStub stub = new IndexableStub();
-        stub.setReturnNull(true);
-        try {
-            this.strategy.processIndexable(stub);
-            fail("retun value is null must fail");
-        } catch (NotIndexableException e) {
-        }
-        assertNull(this.strategy.content);
-        try {
-            this.strategy.createLuceneField();
-            fail("content is not set");
-        } catch (GdataIndexerException e) {
-        }
-
-        String content = "fooBar";
-        stub.setReturnNull(false);
-        stub.setReturnValueTextContent(content);
-        this.strategy.processIndexable(stub);
-        assertNotNull(this.strategy.content);
-        assertEquals(content, this.strategy.content);
-
-        Field[] fields = this.strategy.createLuceneField();
-        assertEquals(1, fields.length);
-        assertEquals(this.field.getName(), fields[0].name());
-        assertEquals(content, fields[0].stringValue());
-        // this is also stored an untok.
-        assertTrue(fields[0].isStored());
-        assertFalse(fields[0].isTokenized());
-        
-        
-        // test for xpath exc.
-        this.field.setPath(null);
-        this.strategy = new KeywordStrategy(field);
-        try {
-            this.strategy.processIndexable(stub);
-            fail("path is null must fail");
-        } catch (NotIndexableException e) {
-        }
-        try {
-            this.strategy.createLuceneField();
-            fail("content is not set");
-        } catch (GdataIndexerException e) {
-        }
-
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/analysis/TestMixedStrategy.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/analysis/TestMixedStrategy.java
deleted file mode 100755
index edb9b62..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/analysis/TestMixedStrategy.java
+++ /dev/null
@@ -1,103 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.search.analysis;
-
-import junit.framework.TestCase;
-
-import org.apache.lucene.document.Field;
-import org.apache.lucene.gdata.search.config.IndexSchemaField;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class TestMixedStrategy extends TestCase {
-    private static final String FIELD = "foo";
-
-    private static final float BOOST = 2.0f;
-
-    MixedContentStrategy strategy;
-
-    private IndexSchemaField field;
-
-    protected void setUp() throws Exception {
-        this.field = new IndexSchemaField();
-        field.setName(FIELD);
-
-        field.setStore(Field.Store.YES);
-        field.setIndex(Field.Index.UN_TOKENIZED);
-        field.setBoost(BOOST);
-        field.setPath("/path");
-        field.setTypePath("/path");
-        this.strategy = new MixedContentStrategy(field);
-    }
-
-    protected void tearDown() throws Exception {
-        super.tearDown();
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.search.analysis.PlainTextStrategy.processIndexable(Indexable<?
-     * extends Node, ? extends ServerBaseEntry>)'
-     */
-    public void testProcessIndexable() throws NotIndexableException {
-        IndexableStub stub = new IndexableStub();
-        stub.setReturnNull(true);
-        try {
-            this.strategy.processIndexable(stub);
-            fail("retun value is null must fail");
-        } catch (NotIndexableException e) {
-        }
-        assertNull(this.strategy.content);
-        String content = "fooBar";
-        stub.setReturnNull(false);
-        stub.setReturnValueTextContent(content);
-        this.strategy.processIndexable(stub);
-        assertNotNull(this.strategy.strategy.content);
-        assertEquals(content, this.strategy.strategy.content);
-        assertEquals(this.strategy.strategy.getClass(), PlainTextStrategy.class);
-
-       
-
-        content = "html";
-        stub.setReturnNull(false);
-        stub.setReturnValueTextContent(content);
-        this.strategy.processIndexable(stub);
-        assertNotNull(this.strategy.strategy.content);
-        assertEquals(content, this.strategy.strategy.content);
-        assertEquals(this.strategy.strategy.getClass(), HTMLStrategy.class);
-
-        content = "xhtml";
-        stub.setReturnNull(false);
-        stub.setReturnValueTextContent(content);
-        this.strategy.processIndexable(stub);
-        assertNotNull(this.strategy.strategy.content);
-        assertEquals(content, this.strategy.strategy.content);
-        assertEquals(this.strategy.strategy.getClass(), XHtmlStrategy.class);
-
-        
-        // test for xpath exc.
-        this.field.setPath(null);
-        try {
-            this.strategy.processIndexable(stub);
-            fail("path is null must fail");
-        } catch (NotIndexableException e) {
-        }
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/analysis/TestPlainTextStrategy.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/analysis/TestPlainTextStrategy.java
deleted file mode 100755
index 08a497b..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/analysis/TestPlainTextStrategy.java
+++ /dev/null
@@ -1,74 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.search.analysis;
-
-import junit.framework.TestCase;
-
-import org.apache.lucene.document.Field;
-import org.apache.lucene.gdata.search.config.IndexSchemaField;
-
-/**
- * @author Simon Willnauer
- *
- */
-public class TestPlainTextStrategy extends TestCase {
-    private static final String FIELD = "foo";
-    private static final float BOOST = 2.0f;
-    ContentStrategy strategy;
-    private IndexSchemaField field;
-    protected void setUp() throws Exception {
-        this.field = new IndexSchemaField();
-        field.setName(FIELD);
-        field.setStore(Field.Store.YES);
-        field.setIndex(Field.Index.UN_TOKENIZED);
-        field.setBoost(BOOST);
-        field.setPath("/path");
-        this.strategy = new PlainTextStrategy(field);
-    }
-
-    protected void tearDown() throws Exception {
-        super.tearDown();
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.search.analysis.PlainTextStrategy.processIndexable(Indexable<? extends Node, ? extends ServerBaseEntry>)'
-     */
-    public void testProcessIndexable() throws NotIndexableException {
-        IndexableStub stub = new IndexableStub();
-        stub.setReturnNull(true);
-        try{
-        this.strategy.processIndexable(stub);
-        fail("retun value is null must fail");
-        }catch (NotIndexableException e) {}
-        assertNull(this.strategy.content);
-        String content = "fooBar";
-        stub.setReturnNull(false);
-        stub.setReturnValueTextContent(content);
-        this.strategy.processIndexable(stub);
-        assertNotNull(this.strategy.content);
-        assertEquals(content,this.strategy.content);
-        
-        
-        // test for xpath exc.
-        this.field.setPath(null);
-        try{
-            this.strategy.processIndexable(stub);
-            fail("path is null must fail");
-            }catch (NotIndexableException e) {}
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/config/TestIndexSchema.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/config/TestIndexSchema.java
deleted file mode 100755
index 45113a9..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/config/TestIndexSchema.java
+++ /dev/null
@@ -1,159 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.search.config;
-
-import org.apache.lucene.analysis.PerFieldAnalyzerWrapper;
-import org.apache.lucene.analysis.StopAnalyzer;
-import org.apache.lucene.analysis.standard.StandardAnalyzer;
-import org.apache.lucene.gdata.search.config.IndexSchemaField.ContentType;
-import org.apache.lucene.gdata.search.index.IndexDocument;
-
-import junit.framework.TestCase;
-
-/**
- * @author Simon Willnauer
- *
- */
-public class TestIndexSchema extends TestCase {
-    IndexSchema schema;
-
-    protected void setUp() throws Exception {
-        schema = new IndexSchema();
-    }
-
-    protected void tearDown() throws Exception {
-        super.tearDown();
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.search.config.IndexSchema.initialize()'
-     */
-    public void testInitialize() {
-        try {
-            schema.initialize();
-            fail("def search field is null");
-        } catch (RuntimeException e) {
-            // TODO: handle exception
-        }
-        schema.setDefaultSearchField("someField");
-        try {
-            schema.initialize();
-            fail("name is null");
-        } catch (RuntimeException e) {
-            // TODO: handle exception
-        }
-        schema.setName("someName");
-        try {
-            schema.initialize();
-            fail("indexLocation  is null");
-        } catch (RuntimeException e) {
-            // TODO: handle exception
-        }
-        schema.setIndexLocation("/loc/loc");
-        try {
-            schema.initialize();
-            fail("default search field is not set as a field");
-        } catch (RuntimeException e) {
-            // TODO: handle exception
-        }
-        IndexSchemaField f = new IndexSchemaField();
-        f.setName(schema.getDefaultSearchField());
-        f.setContentType(ContentType.TEXT);
-        schema.addSchemaField(f);
-        try {
-            schema.initialize();
-            fail("field check failed");
-        } catch (RuntimeException e) {
-            // TODO: handle exception
-        }
-        f.setPath("path");
-        schema.initialize();
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.search.config.IndexSchema.addSchemaField(IndexSchemaField)'
-     */
-    public void testAddSchemaField() {
-        schema.addSchemaField(null);
-        assertEquals(0, schema.getFields().size());
-
-        IndexSchemaField f = new IndexSchemaField();
-        f.setName(IndexDocument.FIELD_ENTRY_ID);
-        schema.addSchemaField(f);
-        assertEquals(0, schema.getFields().size());
-
-        f.setName(IndexDocument.FIELD_FEED_ID);
-        schema.addSchemaField(f);
-        assertEquals(0, schema.getFields().size());
-
-        f.setName("some");
-        schema.addSchemaField(f);
-        assertEquals(1, schema.getFields().size());
-        assertEquals(StandardAnalyzer.class, schema.getServiceAnalyzer()
-                .getClass());
-        assertEquals(StandardAnalyzer.class, schema.getSchemaAnalyzer()
-                .getClass());
-        f.setName("someOther");
-        f.setAnalyzerClass(StopAnalyzer.class);
-        schema.addSchemaField(f);
-        assertEquals(2, schema.getFields().size());
-        assertEquals(PerFieldAnalyzerWrapper.class, schema.getSchemaAnalyzer()
-                .getClass());
-        schema.addSchemaField(f);
-        assertEquals(3, schema.getFields().size());
-
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.search.config.IndexSchema.getSearchableFieldNames()'
-     */
-    public void testGetSearchableFieldNames() {
-        IndexSchemaField f = new IndexSchemaField();
-        f.setName("some");
-        schema.addSchemaField(f);
-        assertEquals(1, schema.getSearchableFieldNames().size());
-        assertTrue(schema.getSearchableFieldNames().contains("some"));
-    }
-
-    public void testEquals() {
-        assertFalse(schema.equals(null));
-        assertFalse(schema.equals(new String()));
-        assertTrue(schema.equals(schema));
-        assertFalse(schema.equals(new IndexSchema()));
-        IndexSchema s1 = new IndexSchema();
-        s1.setName("someName");
-        assertFalse(schema.equals(s1));
-        schema.setName(s1.getName());
-        assertTrue(schema.equals(s1));
-    }
-
-    public void testHashCode() {
-        assertEquals(schema.hashCode(), schema.hashCode());
-        assertNotNull(schema.hashCode());
-        IndexSchema s1 = new IndexSchema();
-        s1.setName("someName");
-        assertTrue(schema.hashCode() != s1.hashCode());
-        schema.setName(s1.getName());
-        assertTrue(schema.hashCode() == s1.hashCode());
-    }
-
-    public void testToSTringNoNullPEx() {
-        assertNotNull(schema.toString());
-    }
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/config/TestIndexSchemaField.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/config/TestIndexSchemaField.java
deleted file mode 100755
index c4f4c5e..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/config/TestIndexSchemaField.java
+++ /dev/null
@@ -1,154 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.search.config;
-
-import junit.framework.TestCase;
-
-import org.apache.lucene.document.Field;
-import org.apache.lucene.gdata.data.ServerBaseEntry;
-import org.apache.lucene.gdata.search.analysis.ContentStrategy;
-import org.apache.lucene.gdata.search.analysis.Indexable;
-import org.apache.lucene.gdata.search.analysis.NotIndexableException;
-import org.apache.lucene.gdata.search.analysis.PlainTextStrategy;
-import org.apache.lucene.gdata.search.config.IndexSchemaField.ContentType;
-import org.w3c.dom.Node;
-
-/**
- * @author Simon Willnauer
- *
- */
-public class TestIndexSchemaField extends TestCase {
-
-    protected void setUp() throws Exception {
-        super.setUp();
-    }
-
-    protected void tearDown() throws Exception {
-        super.tearDown();
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.search.config.IndexSchemaField.checkRequieredValues()'
-     */
-    public void testCheckRequieredValues() {
-        IndexSchemaField f = new IndexSchemaField();
-        assertFalse(f.checkRequieredValues());
-        f.setName("someName");
-        assertFalse(f.checkRequieredValues());
-        f.setPath("somePath");
-        assertFalse(f.checkRequieredValues());
-        f.setType("text");
-        assertTrue(f.checkRequieredValues());
-        f.setType("mixed");
-        assertFalse(f.checkRequieredValues());
-        f.setTypePath("sometypepath");
-        assertTrue(f.checkRequieredValues());
-        
-        f.setType("custom");
-        assertFalse(f.checkRequieredValues());
-        f.setFieldClass(TestContentStragtegy.class);
-        assertTrue(f.checkRequieredValues());
-    }
-    public void testSetFieldType(){
-        IndexSchemaField f = new IndexSchemaField();
-        f.setFieldClass(TestContentStragtegy.class);
-        try{
-            f.setFieldClass(PlainTextStrategy.class);
-            fail("no pub const.");
-        }catch (RuntimeException e) {
-            
-        }
-        try{
-            f.setFieldClass(null);
-            fail("is null");
-        }catch (RuntimeException e) {
-            
-        }
-        
-    }
-    /*
-     * Test method for 'org.apache.lucene.gdata.search.config.IndexSchemaField.setAnalyzerClass(Class<? extends Analyzer>)'
-     */
-    public void testSetType() {
-        IndexSchemaField f = new IndexSchemaField();
-        f.setType("notatype");
-        assertNull(f.getContentType());
-        f.setType("custom");
-        assertEquals(ContentType.CUSTOM,f.getContentType());
-        f.setType("text");
-        assertEquals(ContentType.TEXT,f.getContentType());
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.search.config.IndexSchemaField.setStoreByName(String)'
-     */
-    public void testSetStoreByName() {
-        IndexSchemaField f = new IndexSchemaField();
-        f.setStoreByName("someother");
-        assertEquals(Field.Store.NO,f.getStore());
-        f.setStoreByName("COMPRESS");
-        assertEquals(Field.Store.COMPRESS,f.getStore());
-        f.setStoreByName("YeS");
-        assertEquals(Field.Store.YES,f.getStore());
-        f.setStoreByName("No");
-        assertEquals(Field.Store.NO,f.getStore());
-        
-        
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.search.config.IndexSchemaField.setIndexByName(String)'
-     */
-    public void testSetIndexByName() {
-        IndexSchemaField f = new IndexSchemaField();
-        f.setIndexByName("UN_done");
-        assertEquals(Field.Index.TOKENIZED,f.getIndex());
-        f.setIndexByName("UN_tokenized");
-        assertEquals(Field.Index.UN_TOKENIZED,f.getIndex());
-        f.setIndexByName("tokenized");
-        assertEquals(Field.Index.TOKENIZED,f.getIndex());
-        f.setIndexByName("no");
-        assertEquals(Field.Index.NO,f.getIndex());
-        f.setIndexByName("no_norms");
-        assertEquals(Field.Index.NO_NORMS,f.getIndex());
-        
-        
-    }
-    
-    public void testSetboost(){
-        IndexSchemaField f = new IndexSchemaField();
-        f.setBoost(-0.1f);
-        assertEquals(1.0f,f.getBoost());
-        f.setBoost(2.50f);
-        assertEquals(2.50f,f.getBoost());
-    }
-    
-    public void testToSTringNoNullPEx(){
-        assertNotNull(new IndexSchemaField().toString());
-    }
-    static class TestContentStragtegy extends ContentStrategy{
-        
-        public TestContentStragtegy(IndexSchemaField fieldConfiguration) {
-            super(fieldConfiguration);
-            // TODO Auto-generated constructor stub
-        }
-
-        @Override
-        public void processIndexable(Indexable<? extends Node, ? extends ServerBaseEntry> indexable) throws NotIndexableException {
-        }
-        
-    }
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/index/FutureStub.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/index/FutureStub.java
deleted file mode 100755
index cf8fecd..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/index/FutureStub.java
+++ /dev/null
@@ -1,104 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.search.index;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-
-/**
- * @author Simon Willnauer
- *
- */
-public class FutureStub<T> implements Future<T>{
-    T object;
-    CountDownLatch latch;
-    boolean wait;
-    
-    /**
-     * 
-     */
-    public FutureStub(T returnObject, CountDownLatch latch) {
-        this(returnObject,latch,false);
-    }
-    /**
-     * 
-     */
-    public FutureStub(T returnObject, CountDownLatch latch, boolean wait) {
-        super();
-        this.object = returnObject;
-        this.latch =latch;
-        this.wait =wait;
-    }
-    public FutureStub(T returnObject) {
-        this(returnObject,null);
-    }
-
-    /**
-     * @see java.util.concurrent.Future#cancel(boolean)
-     */
-    public boolean cancel(boolean arg0) {
-
-        return false;
-    }
-
-    /**
-     * @see java.util.concurrent.Future#isCancelled()
-     */
-    public boolean isCancelled() {
-
-        return false;
-    }
-
-    /**
-     * @see java.util.concurrent.Future#isDone()
-     */
-    public boolean isDone() {
-
-        return true;
-    }
-
-    /**
-     * @see java.util.concurrent.Future#get()
-     */
-    public T get() throws InterruptedException, ExecutionException {
-        doLatch(); 
-        return this.object;
-    }
-
-    /**
-     * @see java.util.concurrent.Future#get(long, java.util.concurrent.TimeUnit)
-     */
-    public T get(long arg0, TimeUnit arg1) throws InterruptedException,
-            ExecutionException, TimeoutException {
-       doLatch();
-        return this.object;
-    }
-    
-    private void doLatch() throws InterruptedException{
-        if(latch != null){
-            if(!wait)
-            this.latch.countDown();
-            else
-                this.latch.await(5000,TimeUnit.MILLISECONDS);
-        }
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/index/IndexDocumentStub.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/index/IndexDocumentStub.java
deleted file mode 100755
index c93dd56..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/index/IndexDocumentStub.java
+++ /dev/null
@@ -1,136 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.search.index;
-
-import java.util.concurrent.CountDownLatch;
-
-import org.apache.lucene.document.Document;
-import org.apache.lucene.index.Term;
-
-/**
- * @author Simon Willnauer
- *
- */
-public class IndexDocumentStub implements IndexDocument {
-    Document document;
-    Term deleteTerm;
-    IndexAction action;
-    CountDownLatch latch;
-    boolean commitAfter;
-    boolean optimizeAfter;
-    /**
-     * 
-     */
-    public IndexDocumentStub(Document doc, Term deleteTerm, IndexAction action, CountDownLatch latch) {
-        this.document = doc;
-        this.deleteTerm = deleteTerm;
-        this.action = action;
-        this.latch = latch;
-    }
-    public IndexDocumentStub(Document doc, Term deleteTerm, IndexAction action) {
-        this(doc,deleteTerm,action,null);
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.search.index.IndexDocument#isUpdate()
-     */
-    public boolean isUpdate() {
-
-        return isAction(IndexAction.UPDATE);
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.search.index.IndexDocument#isDelete()
-     */
-    public boolean isDelete() {
-
-        return isAction(IndexAction.DELETE);
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.search.index.IndexDocument#isInsert()
-     */
-    public boolean isInsert() {
-
-     return isAction(IndexAction.INSERT);
-    }
-    private boolean isAction(IndexAction currentAction){
-        return this.action == currentAction;
-    }
-    /**
-     * @see org.apache.lucene.gdata.search.index.IndexDocument#getWriteable()
-     */
-    public Document getWriteable() {
-        if(latch != null)
-        latch.countDown();        
-        return this.document;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.search.index.IndexDocument#getDeletealbe()
-     */
-    public Term getDeletealbe() {
-        if(latch != null)
-            latch.countDown();
-        return this.deleteTerm;
-    }
-    public boolean commitAfter() {
-        
-        return this.commitAfter;
-    }
-    public boolean optimizeAfter() {
-        
-        return this.optimizeAfter;
-    }
-    /**
-     * @param commitAfter The commitAfter to set.
-     */
-    public void setCommitAfter(boolean commitAfter) {
-        this.commitAfter = commitAfter;
-    }
-    /**
-     * @param optimizeAfter The optimizeAfter to set.
-     */
-    public void setOptimizeAfter(boolean optimizeAfter) {
-        this.optimizeAfter = optimizeAfter;
-    }
-    
-    /**
-     * @see java.lang.Object#equals(java.lang.Object)
-     */
-    @Override
-    public final boolean equals(Object obj) {
-        if(obj == null)
-            return false;
-        if(obj instanceof IndexDocumentStub){
-            IndexDocumentStub other = (IndexDocumentStub)obj;
-            return this.document.getField(IndexDocument.FIELD_ENTRY_ID).stringValue().equals(other.document.getField(IndexDocument.FIELD_ENTRY_ID).stringValue());
-              
-        }
-        return false; 
-    }
-
-    /**
-     * @see java.lang.Object#hashCode()
-     */
-    @Override
-    public final int hashCode() {
-        return this.document.getField(IndexDocument.FIELD_ENTRY_ID).stringValue().hashCode();
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/index/IndexEventListenerStub.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/index/IndexEventListenerStub.java
deleted file mode 100755
index 5b16bfe..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/index/IndexEventListenerStub.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.search.index;
-
-import java.util.concurrent.atomic.AtomicInteger;
-
-/**
- * @author Simon Willnauer
- *
- */
-public class IndexEventListenerStub implements IndexEventListener {
-    AtomicInteger count;
-    /**
-     * 
-     */
-    public IndexEventListenerStub() {
-        super();
-       this.count = new AtomicInteger(0);
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.search.index.IndexEventListener#commitCallBack(java.lang.String)
-     */
-    public void commitCallBack(String service) {
-        this.count.incrementAndGet();
-    }
-    
-    public int getCalledCount(){
-        return this.count.get();
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/index/TestGdataIndexDocument.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/index/TestGdataIndexDocument.java
deleted file mode 100755
index 6182a50..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/index/TestGdataIndexDocument.java
+++ /dev/null
@@ -1,123 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.search.index;
-
-import junit.framework.TestCase;
-
-import org.apache.lucene.document.Document;
-import org.apache.lucene.gdata.search.analysis.ContentStrategy;
-import org.apache.lucene.gdata.search.config.IndexSchemaField;
-import org.apache.lucene.gdata.search.config.IndexSchemaField.ContentType;
-import org.apache.lucene.index.Term;
-
-public class TestGdataIndexDocument extends TestCase {
-    static String ENTRYID = "someEId";
-    static String FEEDID = "someFId";
-    GDataIndexDocument delDocument;
-    GDataIndexDocument updDocument;
-    GDataIndexDocument insDocument;
-    protected void setUp() throws Exception {
-        this.delDocument = new GDataIndexDocument(IndexAction.DELETE,ENTRYID,FEEDID,false,true);
-        this.insDocument = new GDataIndexDocument(IndexAction.INSERT,ENTRYID,FEEDID,true,false);
-        this.updDocument = new GDataIndexDocument(IndexAction.UPDATE,ENTRYID,FEEDID,false,true);
-    }
-
-    protected void tearDown() throws Exception {
-        super.tearDown();
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.search.index.GDataIndexDocument.addField(ContentStrategy)'
-     */
-    public void testAddField() {
-        assertEquals(0,this.delDocument.fields.size());    
-        this.delDocument.addField(null);
-        assertEquals(0,this.delDocument.fields.size());
-        IndexSchemaField ifield = new IndexSchemaField();
-        ifield.setContentType(ContentType.TEXT);
-        this.delDocument.addField(ContentStrategy.getFieldStrategy(ifield));
-        assertEquals(1,this.delDocument.fields.size());
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.search.index.GDataIndexDocument.getWriteable()'
-     */
-    public void testGetWriteable() {
-        assertNotNull(this.insDocument.getWriteable());
-        Document doc = this.insDocument.getWriteable();
-        assertEquals(2,doc.getFields().size());
-        assertEquals(ENTRYID,doc.getField(GDataIndexDocument.FIELD_ENTRY_ID).stringValue());
-        assertEquals(FEEDID,doc.getField(GDataIndexDocument.FIELD_FEED_ID).stringValue());
-        
-        
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.search.index.GDataIndexDocument.getDeletealbe()'
-     */
-    public void testGetDeletealbe() {
-        assertNotNull(this.insDocument.getDeletealbe());
-        Term t = this.insDocument.getDeletealbe();
-        assertEquals(IndexDocument.FIELD_ENTRY_ID,t.field());
-        assertEquals(ENTRYID,t.text());
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.search.index.GDataIndexDocument.isUpdate()'
-     */
-    public void testIsUpdate() {
-        assertFalse(this.insDocument.isUpdate());
-        assertTrue(this.updDocument.isUpdate());
-        assertFalse(this.delDocument.isUpdate());
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.search.index.GDataIndexDocument.isDelete()'
-     */
-    public void testIsDelete() {
-        assertFalse(this.insDocument.isDelete());
-        assertFalse(this.updDocument.isDelete());
-        assertTrue(this.delDocument.isDelete());
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.search.index.GDataIndexDocument.isInsert()'
-     */
-    public void testIsInsert() {
-        assertTrue(this.insDocument.isInsert());
-        assertFalse(this.updDocument.isInsert());
-        assertFalse(this.delDocument.isInsert());
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.search.index.GDataIndexDocument.commitAfter()'
-     */
-    public void testCommitAfter() {
-        assertTrue(this.insDocument.commitAfter());
-        assertFalse(this.updDocument.commitAfter());
-        assertFalse(this.delDocument.commitAfter());
-    }
-    
-    /*
-     * Test method for 'org.apache.lucene.gdata.search.index.GDataIndexDocument.optimizeAfter()'
-     */
-    public void testOptimizeAfter() {
-        assertFalse(this.insDocument.optimizeAfter());
-        assertTrue(this.updDocument.optimizeAfter());
-        assertTrue(this.delDocument.optimizeAfter());
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/index/TestGdataIndexWriter.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/index/TestGdataIndexWriter.java
deleted file mode 100755
index 25a256d..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/index/TestGdataIndexWriter.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.search.index;
-
-import java.io.IOException;
-
-import junit.framework.TestCase;
-
-import org.apache.lucene.analysis.PerFieldAnalyzerWrapper;
-import org.apache.lucene.analysis.StopAnalyzer;
-import org.apache.lucene.analysis.standard.StandardAnalyzer;
-import org.apache.lucene.gdata.search.config.IndexSchema;
-import org.apache.lucene.gdata.search.config.IndexSchemaField;
-import org.apache.lucene.store.RAMDirectory;
-
-/**
- * @author Simon Willnauer
- *
- */
-public class TestGdataIndexWriter extends TestCase {
-    IndexSchema schemaNoPerFielAnalyzer;
-    IndexSchema schemaPerFielAnalyzer;
-    long VALUE_GT_DEFAULT_LONG = 15000;
-    int VALUE_GT_DEFAULT_INT = 10000;
-    
-    protected void setUp() throws Exception {
-        this.schemaNoPerFielAnalyzer = new IndexSchema();
-        this.schemaPerFielAnalyzer = new IndexSchema();
-        IndexSchemaField field = new IndexSchemaField();
-        field.setName("someField");
-        field.setAnalyzerClass(StopAnalyzer.class);
-        this.schemaPerFielAnalyzer.addSchemaField(field);
-        this.schemaPerFielAnalyzer.setCommitLockTimeout(VALUE_GT_DEFAULT_LONG);
-        this.schemaPerFielAnalyzer.setMaxBufferedDocs(VALUE_GT_DEFAULT_INT);
-        this.schemaPerFielAnalyzer.setMaxFieldLength(VALUE_GT_DEFAULT_INT);
-        this.schemaPerFielAnalyzer.setMaxMergeDocs(VALUE_GT_DEFAULT_INT);
-        this.schemaPerFielAnalyzer.setMergeFactor(VALUE_GT_DEFAULT_INT);
-        this.schemaPerFielAnalyzer.setWriteLockTimeout(VALUE_GT_DEFAULT_LONG);
-        this.schemaPerFielAnalyzer.setUseCompoundFile(true);
-    }
-
-
-    /**
-     * Test method for 'org.apache.lucene.gdata.search.index.GDataIndexWriter.GDataIndexWriter(Directory, boolean, IndexSchema)'
-     * @throws IOException 
-     */
-    public void testGDataIndexWriter() throws IOException {
-        try{
-        new GDataIndexWriter(new RAMDirectory(),true,null);
-        fail("no index schema");
-        }catch (IllegalArgumentException e) {}
-        GDataIndexWriter writer = new GDataIndexWriter(new RAMDirectory(),true,this.schemaNoPerFielAnalyzer);
-        assertTrue(writer.getAnalyzer().getClass() == StandardAnalyzer.class);
-        
-        writer = new GDataIndexWriter(new RAMDirectory(),true,this.schemaPerFielAnalyzer);
-        assertTrue(writer.getAnalyzer().getClass() == PerFieldAnalyzerWrapper.class);
-        //TODO fix this - index writer has no commitlocktimeout setter anymore (lockless commits)
-//        assertEquals(VALUE_GT_DEFAULT_LONG,writer.getCommitLockTimeout());
-        assertEquals(VALUE_GT_DEFAULT_LONG,writer.getWriteLockTimeout());
-        assertEquals(VALUE_GT_DEFAULT_INT,writer.getMaxBufferedDocs());
-        assertEquals(VALUE_GT_DEFAULT_INT,writer.getMaxMergeDocs());
-        assertEquals(VALUE_GT_DEFAULT_INT,writer.getMaxFieldLength());
-        assertEquals(VALUE_GT_DEFAULT_INT,writer.getMergeFactor());
-        assertTrue(writer.getUseCompoundFile());
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/index/TestGdataIndexer.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/index/TestGdataIndexer.java
deleted file mode 100755
index 87e16b7..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/index/TestGdataIndexer.java
+++ /dev/null
@@ -1,577 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.search.index;
-
-import java.io.IOException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-
-import junit.framework.TestCase;
-
-import org.apache.lucene.analysis.standard.StandardAnalyzer;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.gdata.search.config.IndexSchema;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.Hits;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.RAMDirectory;
-
-/**
- * @author Simon Willnauer
- *
- */
-public class TestGdataIndexer extends TestCase {
-    private GDataIndexer indexer;
-
-    private Directory dir;
-
-    private static IndexSchema config;
-
-    private static String FIELD_ID = IndexDocument.FIELD_ENTRY_ID;
-
-    static {
-        config = new IndexSchema();
-        config.setName("testService");
-        config.setCommitLockTimeout(-1);
-        config.setServiceAnalyzer(new StandardAnalyzer());
-        config.setMaxBufferedDocs(-1);
-        config.setMaxFieldLength(-1);
-        config.setMaxMergeDocs(-1);
-        config.setWriteLockTimeout(-1);
-        config.setMergeFactor(-1);
-    }
-
-    /**
-     * @see junit.framework.TestCase#setUp()
-     */
-    @Override
-    protected void setUp() throws Exception {
-        this.dir = new RAMDirectory();
-        this.indexer = GDataIndexer.createGdataIndexer(config, this.dir, true);
-        super.setUp();
-    }
-
-    /**
-     * @see junit.framework.TestCase#tearDown()
-     */
-    @Override
-    protected void tearDown() throws Exception {
-        this.indexer.destroy();
-    }
-    public void testStaticFactoryMethodes() throws IOException{
-        GDataIndexer i =GDataIndexer.createGdataIndexer(config, new RAMDirectory(), true);
-        assertNotNull(i);
-        assertEquals(IndexTask.class,i.indexTask.getClass());
-        
-        i =GDataIndexer.createTimedGdataIndexer(config, new RAMDirectory(), true,60);
-        assertNotNull(i);
-        assertEquals(TimedIndexTask.class,i.indexTask.getClass());
-        assertEquals(60,((TimedIndexTask)i.indexTask).getIdleTime());
-        
-        i.destroy();
-    }
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.search.index.GDataIndexer.GDataIndexer(IndexServiceConfiguration,
-     * Directory, boolean)'
-     */
-    public void testGDataIndexer() throws InterruptedException, IOException {
-        try {
-            new GDataIndexer(null, dir, true);
-            fail("config is null");
-        } catch (IllegalArgumentException e) {
-            //
-        }
-
-        try {
-            new GDataIndexer(config, null, true);
-            fail("dir is null");
-        } catch (IllegalArgumentException e) {
-            //
-        }
-        
-        GDataIndexer in = new GDataIndexer(config,new RAMDirectory(),true);
-        in.setIndexTask(null);
-        in.init();
-        assertNotNull(in.indexTask);
-        assertEquals(IndexTask.class,in.indexTask.getClass());
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.search.index.GDataIndexer.addIndexableDocumentTask(Future<IndexDocument>)'
-     */
-    public void testAddIndexableDocumentTask() throws InterruptedException,
-            IOException {
-        String id = "myID";
-        Field f = new Field(FIELD_ID, id, Field.Store.YES,
-                Field.Index.UN_TOKENIZED);
-        Document doc = new Document();
-        doc.add(f);
-        Term delTerm = new Term(FIELD_ID, id);
-        /*
-         * Latch will be decremented in FutureStub#get() and
-         * IndexDocumentStub#getIndexable
-         */
-        CountDownLatch l = new CountDownLatch(2);
-        IndexDocument iDoc = new IndexDocumentStub(doc, delTerm,
-                IndexAction.INSERT, l);
-        Future<IndexDocument> future = new FutureStub<IndexDocument>(iDoc, l);
-
-        this.indexer.addIndexableDocumentTask(future);
-        // wait for the latch do decrement
-        l.await(5000, TimeUnit.MILLISECONDS);
-
-        this.indexer.commit(false);
-        IndexSearcher s = new IndexSearcher(this.dir);
-        Hits h = s.search(new TermQuery(delTerm));
-        assertEquals(1, h.length());
-        s.close();
-        // test for update
-        /*
-         * Latch will be decremented in FutureStub#get() and
-         * IndexDocumentStub#getIndexable
-         */
-        l = new CountDownLatch(2);
-        iDoc = new IndexDocumentStub(doc, delTerm, IndexAction.UPDATE, l);
-        future = new FutureStub<IndexDocument>(iDoc, l);
-        this.indexer.addIndexableDocumentTask(future);
-        l.await(5000, TimeUnit.MILLISECONDS);
-        this.indexer.commit(false);
-        s = new IndexSearcher(this.dir);
-        h = s.search(new TermQuery(delTerm));
-        assertEquals(1, h.length());
-        s.close();
-
-        // test for delete
-        /*
-         * Latch will be decremented in FutureStub#get()
-         */
-        l = new CountDownLatch(1);
-        iDoc = new IndexDocumentStub(doc, delTerm, IndexAction.DELETE, l);
-        future = new FutureStub<IndexDocument>(iDoc, l);
-
-        this.indexer.addIndexableDocumentTask(future);
-        /*
-         * wait for the indexer task to add the deleted
-         */
-        while (this.indexer.docsDeleted.get() == 0)
-            l.await(5000, TimeUnit.MILLISECONDS);
-
-        this.indexer.commit(false);
-        s = new IndexSearcher(this.dir);
-        h = s.search(new TermQuery(delTerm));
-        assertEquals(0, h.length());
-        s.close();
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.search.index.GDataIndexer.addDocument(IndexDocument)'
-     */
-public void testAddDocument() throws IOException {
-        String id = "myID";
-        Field f = new Field(FIELD_ID, id, Field.Store.YES,
-                Field.Index.UN_TOKENIZED);
-        Document doc = new Document();
-        doc.add(f);
-        Term delTerm =  new Term(FIELD_ID, id);
-        IndexDocument iDoc = new IndexDocumentStub(doc,delTerm,
-                IndexAction.INSERT);
-        
-        this.indexer.addDocument(iDoc);
-        assertEquals(1,this.indexer.docsAdded.get());
-        assertEquals(0,this.indexer.docsDeleted.get());
-        assertEquals(0,this.indexer.docsUpdated.get());
-        this.indexer.addDocument(iDoc);
-        this.indexer.commit(false);
-        
-        
-        IndexSearcher s = new IndexSearcher(this.dir);
-        Hits h = s.search(new TermQuery(delTerm));
-        assertEquals(1, h.length());
-        s.close();
-        
-        iDoc = new IndexDocumentStub(doc,delTerm,
-                IndexAction.UPDATE);
-        try{
-            this.indexer.addDocument(iDoc);
-            fail("document has not insert action ");
-        }catch (GdataIndexerException e) {
-            
-        }
-        
-    }
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.search.index.GDataIndexer.updateDocument(IndexDocument)'
-     */
-    public void testUpdateDocument() throws IOException {
-        
-        String id = "myID";
-        Field f = new Field(FIELD_ID, id, Field.Store.YES,
-                Field.Index.UN_TOKENIZED);
-        Document doc = new Document();
-        doc.add(f);
-        Term delTerm =  new Term(FIELD_ID, id);
-        IndexDocument iDoc = new IndexDocumentStub(doc,delTerm,
-                IndexAction.INSERT);
-        /*
-         * write doc to index
-         */
-        this.indexer.writer.addDocument(doc);
-        this.indexer.closeWriter();
-        IndexSearcher s = new IndexSearcher(this.dir);
-        Hits h = s.search(new TermQuery(delTerm));
-        assertEquals(1, h.length());
-        s.close();
-        String testFieldName = "someTestFieldupdate";
-        doc.add(new Field(testFieldName,"someText",Field.Store.YES,Field.Index.TOKENIZED));
-        iDoc = new IndexDocumentStub(doc,delTerm,
-                IndexAction.UPDATE);
-        /*
-         * updateDoc via indexer 
-         */
-        this.indexer.updateDocument(iDoc);
-        assertEquals(0,this.indexer.docsAdded.get());
-        assertEquals(0,this.indexer.docsDeleted.get());
-        assertEquals(1,this.indexer.docsUpdated.get());
-        
-        this.indexer.commit(false);
-        
-        
-        s = new IndexSearcher(this.dir);
-        h = s.search(new TermQuery(delTerm));
-        assertEquals(1, h.length());
-        assertNotNull(h.doc(0).getField(testFieldName));
-        s.close();
-        
-        iDoc = new IndexDocumentStub(doc,delTerm,
-                IndexAction.DELETE);
-        try{
-            this.indexer.updateDocument(iDoc);
-            fail("document has not update action ");
-        }catch (GdataIndexerException e) {
-            
-        }
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.search.index.GDataIndexer.deleteDocument(IndexDocument)'
-     */
-    public void testDeleteDocument() throws IOException {
-        String id = "myID";
-        Field f = new Field(FIELD_ID, id, Field.Store.YES,
-                Field.Index.UN_TOKENIZED);
-        Document doc = new Document();
-        doc.add(f);
-        Term delTerm =  new Term(FIELD_ID, id);
-        IndexDocument iDoc = new IndexDocumentStub(doc,delTerm,
-                IndexAction.INSERT);
-        /*
-         * write doc to index
-         */
-        this.indexer.writer.addDocument(doc);
-       
-        this.indexer.closeWriter();
-        IndexSearcher s = new IndexSearcher(this.dir);
-        Hits h = s.search(new TermQuery(delTerm));
-        assertEquals(1, h.length());
-        s.close();
-        
-        /*
-         * del doc via indexer
-         */
-        iDoc = new IndexDocumentStub(doc,delTerm,
-                IndexAction.DELETE);
-        this.indexer.deleteDocument(iDoc);
-        assertEquals(0,this.indexer.docsAdded.get());
-        assertEquals(1,this.indexer.docsDeleted.get());
-        assertEquals(0,this.indexer.docsUpdated.get());
-        this.indexer.commit(false);
-        s = new IndexSearcher(this.dir);
-        h = s.search(new TermQuery(delTerm));
-        assertEquals(0, h.length());
-        s.close();
-        
-        /*
-         * test insert / del without optimize
-         */ 
-        iDoc = new IndexDocumentStub(doc,delTerm,
-                 IndexAction.INSERT);
-        this.indexer.addDocument(iDoc);
-        iDoc = new IndexDocumentStub(doc,delTerm,
-                IndexAction.DELETE);
-        this.indexer.deleteDocument(iDoc);
-        this.indexer.commit(false);
-        s = new IndexSearcher(this.dir);
-        h = s.search(new TermQuery(delTerm));
-        assertEquals(0, h.length());
-        s.close();
-        
-        
-        
-        /*
-         * test insert / del / update without optimize
-         */ 
-        iDoc = new IndexDocumentStub(doc,delTerm,
-                 IndexAction.INSERT);
-        this.indexer.addDocument(iDoc);
-        iDoc = new IndexDocumentStub(doc,delTerm,
-                IndexAction.DELETE);
-        this.indexer.deleteDocument(iDoc);
-        iDoc = new IndexDocumentStub(doc,delTerm,
-                IndexAction.INSERT);
-       this.indexer.addDocument(iDoc);
-        this.indexer.commit(false);
-        s = new IndexSearcher(this.dir);
-        h = s.search(new TermQuery(delTerm));
-        assertEquals(1, h.length());
-        s.close();
-        
-        
-        
-        
-        /*
-         * test insert / update / del without optimize
-         */
-        iDoc = new IndexDocumentStub(doc,delTerm,
-                IndexAction.INSERT);
-        this.indexer.addDocument(iDoc);
-        iDoc = new IndexDocumentStub(doc,delTerm,
-                IndexAction.UPDATE);
-        this.indexer.updateDocument(iDoc);
-        iDoc = new IndexDocumentStub(doc,delTerm,
-                IndexAction.DELETE);
-        this.indexer.deleteDocument(iDoc);
-        this.indexer.commit(false);
-        s = new IndexSearcher(this.dir);
-        h = s.search(new TermQuery(delTerm));
-        assertEquals(0, h.length());
-        s.close();
-        
-        
-        
-        iDoc = new IndexDocumentStub(doc,delTerm,
-                IndexAction.UPDATE);
-        try{
-            this.indexer.deleteDocument(iDoc);
-            fail("document has not delete action ");
-        }catch (GdataIndexerException e) {
-            
-        }
-        
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.search.index.GDataIndexer.commit(boolean)'
-     */
-    public void testCommit() throws IOException {
-        String id = "myID";
-        Field f = new Field(FIELD_ID, id, Field.Store.YES,
-                Field.Index.UN_TOKENIZED);
-        Document doc = new Document();
-        doc.add(f);
-        Term delTerm =  new Term(FIELD_ID, id);
-        IndexDocument iDoc = new IndexDocumentStub(doc,delTerm,
-                IndexAction.INSERT);
-        this.indexer.addDocument(iDoc);
-         iDoc = new IndexDocumentStub(doc,delTerm,
-                IndexAction.UPDATE);
-        this.indexer.updateDocument(iDoc);
-        this.indexer.updateDocument(iDoc);
-        iDoc = new IndexDocumentStub(doc,delTerm,
-                IndexAction.DELETE);
-        this.indexer.deleteDocument(iDoc);
-        IndexEventListenerStub evListener = new IndexEventListenerStub();
-        this.indexer.registerIndexEventListener(evListener);
-        assertEquals(1,this.indexer.docsAdded.get());
-        assertEquals(1,this.indexer.docsDeleted.get());
-        assertEquals(2,this.indexer.docsUpdated.get());
-        assertEquals(0,evListener.getCalledCount());
-        this.indexer.commit(true);
-        this.indexer.commit(false);
-        assertEquals(1,evListener.getCalledCount());
-        assertEquals(0,this.indexer.docsAdded.get());
-        assertEquals(0,this.indexer.docsDeleted.get());
-        assertEquals(0,this.indexer.docsUpdated.get());
-        IndexSearcher s = new IndexSearcher(this.dir);
-        Hits h = s.search(new TermQuery(delTerm));
-        assertEquals(0, h.length());
-        s.close();
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.search.index.GDataIndexer.registerIndexEventListener(IndexEventListener)'
-     */
-    public void testRegisterIndexEventListener() {
-        IndexEventListenerStub evListener = new IndexEventListenerStub();
-        this.indexer.registerIndexEventListener(evListener);
-        this.indexer.registerIndexEventListener(evListener);
-        assertEquals(0,evListener.getCalledCount());
-        this.indexer.notifyCommitListeners("someId");
-        this.indexer.notifyCommitListeners("someId");
-        assertEquals(2,evListener.getCalledCount());
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.search.index.GDataIndexer.removeIndexEventListener(IndexEventListener)'
-     */
-    public void testRemoveIndexEventListener() {
-        IndexEventListenerStub evListener = new IndexEventListenerStub();
-        this.indexer.registerIndexEventListener(evListener);
-        assertEquals(0,evListener.getCalledCount());
-        this.indexer.notifyCommitListeners("someId");
-        assertEquals(1,evListener.getCalledCount());
-        this.indexer.removeIndexEventListener(evListener);
-        this.indexer.removeIndexEventListener(evListener);
-        this.indexer.notifyCommitListeners("someId");
-        assertEquals(1,evListener.getCalledCount());
-        
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.search.index.GDataIndexer.notifyCommitListeners(String)'
-     */
-    public void testNotifyCommitListeners() {
-        IndexEventListenerStub evListener = new IndexEventListenerStub();
-        IndexEventListenerStub evListener1 = new IndexEventListenerStub();
-        IndexEventListenerStub evListener2 = new IndexEventListenerStub();
-        this.indexer.registerIndexEventListener(evListener);
-        this.indexer.registerIndexEventListener(evListener1);
-        this.indexer.registerIndexEventListener(evListener2);
-        assertEquals(0,evListener.getCalledCount());
-        this.indexer.notifyCommitListeners("someId");
-        assertEquals(1,evListener.getCalledCount());
-        assertEquals(1,evListener1.getCalledCount());
-        assertEquals(1,evListener2.getCalledCount());
-        this.indexer.removeIndexEventListener(evListener);
-        this.indexer.notifyCommitListeners("someId");
-        assertEquals(1,evListener.getCalledCount());
-        assertEquals(2,evListener1.getCalledCount());
-        assertEquals(2,evListener2.getCalledCount());
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.search.index.GDataIndexer.closeWriter()'
-     */
-    public void testCloseWriter() throws IOException{
-        assertNotNull(this.indexer.writer);
-        this.indexer.closeWriter();
-        assertNull(this.indexer.writer);
-
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.search.index.GDataIndexer.closeSearcher()'
-     */
-    public void testCloseSearcher() throws IOException {
-        this.indexer.openSearcher();
-        assertNotNull(this.indexer.searcher);
-        this.indexer.closeSearcher();
-        assertNull(this.indexer.searcher);
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.search.index.GDataIndexer.openSearcher()'
-     */
-    public void testOpenSearcher() throws IOException {
-        this.indexer.searcher = null;
-        this.indexer.openSearcher();
-         assertNotNull(this.indexer.searcher);
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.search.index.GDataIndexer.openWriter()'
-     */
-    public void testOpenWriter() throws IOException {
-        this.indexer.closeWriter();
-        assertNull(this.indexer.writer);
-       this.indexer.openWriter();
-        assertNotNull(this.indexer.writer);
-    }
-
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.search.index.GDataIndexer.destroy()'
-     */
-    public void testDestroy() throws InterruptedException, IOException {
-        this.indexer.destroy();
-        String id = "myID";
-        Field f = new Field(FIELD_ID, id, Field.Store.YES,
-                Field.Index.UN_TOKENIZED);
-        Document doc = new Document();
-        doc.add(f);
-        Term delTerm = new Term(FIELD_ID, id);
-        IndexDocument iDoc = new IndexDocumentStub(doc, delTerm,
-                IndexAction.INSERT);
-        Future<IndexDocument> future = new FutureStub<IndexDocument>(iDoc);
-        try{
-        this.indexer.addIndexableDocumentTask(future);
-        fail("indexer already closed exc. expected");
-        }catch (IllegalStateException e) {}
-        this.indexer = GDataIndexer.createGdataIndexer(config, dir, true);
-        CountDownLatch documentLatch = new CountDownLatch(1);
-        iDoc = new IndexDocumentStub(doc, delTerm,
-                IndexAction.INSERT,documentLatch);
-        
-        CountDownLatch latch = new CountDownLatch(1);
-        future = new FutureStub<IndexDocument>(iDoc,latch,true);
-        this.indexer.addIndexableDocumentTask(future);
-        this.indexer.destroy();
-        latch.countDown();
-        documentLatch.await(5000,TimeUnit.MILLISECONDS);
-        // wait active for the commit
-        while(this.indexer.writer != null){}
-        
-        IndexSearcher s = new IndexSearcher(this.dir);
-        Hits h = s.search(new TermQuery(delTerm));
-        assertEquals(1, h.length());
-        s.close();
-        
-        
-    }
-    
-    public void testInnerClassFuture() throws InterruptedException, ExecutionException, TimeoutException{
-        Future f = new GDataIndexer.FinishingFuture();
-        assertNull(f.get());
-        assertNull(f.get(0,TimeUnit.MICROSECONDS));
-        assertTrue(f.isDone());
-        assertFalse(f.isCancelled());
-        assertFalse(f.cancel(true));
-        
-    }
-
-   
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/index/TestIndexController.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/index/TestIndexController.java
deleted file mode 100755
index f8a3551..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/index/TestIndexController.java
+++ /dev/null
@@ -1,382 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.search.index;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.List;
-import java.util.concurrent.CountDownLatch;
-
-import junit.framework.TestCase;
-
-import org.apache.lucene.analysis.standard.StandardAnalyzer;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.gdata.data.ServerBaseEntry;
-import org.apache.lucene.gdata.search.GDataSearcher;
-import org.apache.lucene.gdata.search.config.IndexSchema;
-import org.apache.lucene.gdata.search.config.IndexSchemaField;
-import org.apache.lucene.gdata.search.config.IndexSchemaField.ContentType;
-import org.apache.lucene.gdata.search.index.IndexController.ServiceIndex;
-import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
-import org.apache.lucene.gdata.utils.ProvidedServiceStub;
-import org.apache.lucene.gdata.utils.ReferenceCounter;
-import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.TermQuery;
-
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class TestIndexController extends TestCase {
-    IndexController controller;
-
-    IndexSchema schema;
-
-    File indexLocation;
-
-    protected void setUp() throws Exception {
-        this.controller = new IndexController();
-        GDataServerRegistry reg = GDataServerRegistry.getRegistry();
-
-        this.indexLocation = new File(System.getProperty("java.io.tmpdir"));
-        
-        
-        ProvidedServiceStub stub = new ProvidedServiceStub();
-        this.schema = new IndexSchema();
-        // must be set
-        this.schema.setDefaultSearchField("content");
-        this.schema.setName(ProvidedServiceStub.SERVICE_NAME);
-        this.schema.setIndexLocation(this.indexLocation.getAbsolutePath());
-        IndexSchemaField field = new IndexSchemaField();
-        field.setName("content");
-        field.setPath("/somePath");
-        field.setContentType(ContentType.TEXT);
-        this.schema.addSchemaField(field);
-        stub.setIndexSchema(this.schema);
-
-        reg.registerService(stub);
-    }
-
-    protected void tearDown() throws Exception {
-        super.tearDown();
-        GDataServerRegistry.getRegistry().destroy();
-        this.controller.destroy();
-        /*
-         * this file will be created by the controller
-         */
-        File toDel = new File(this.indexLocation,
-                ProvidedServiceStub.SERVICE_NAME);
-        delAllFiles(toDel);
-    }
-
-    /*
-     * del all created files
-     */
-    private void delAllFiles(File dir) {
-        if (dir == null || !dir.exists())
-            return;
-        File[] files = dir.listFiles();
-        for (int i = 0; i < files.length; i++) {
-            while (!files[i].canWrite()) {
-            }
-            ;
-            files[i].delete();
-        }
-        dir.delete();
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.search.index.IndexController.initialize()'
-     */
-    public void testInitialize() {
-        this.controller.initialize();
-        assertTrue(this.controller.indexerMap
-                .containsKey(ProvidedServiceStub.SERVICE_NAME));
-        ServiceIndex bean = this.controller.indexerMap
-                .get(ProvidedServiceStub.SERVICE_NAME);
-        assertNotNull(bean);
-        assertNotNull(bean.getIndexer());
-        assertSame(this.schema, bean.getSchema());
-        assertTrue(GDataServerRegistry.getRegistry().getEntryEventMediator()
-                .isListenerRegistered(this.controller));
-
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.search.index.IndexController.initialize()'
-     */
-    public void testInitializeValueMissing() {
-        this.schema.setIndexLocation(null);
-        try {
-
-            this.controller.initialize();
-            fail("missing index location");
-        } catch (RuntimeException e) {
-        }
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.search.index.IndexController.addIndexSchema(IndexSchema)'
-     */
-    public void testAddIndexSchema() {
-        this.controller.initialize();
-        assertEquals(1, this.controller.indexerMap.size());
-        try {
-            this.controller.addIndexSchema(this.schema);
-            fail("schema already added");
-        } catch (IllegalStateException e) {
-
-        }
-        this.schema.setName(null);
-        try {
-            this.controller.addIndexSchema(this.schema);
-            fail("schema name is null");
-        } catch (IllegalStateException e) {
-
-        }
-
-        this.schema.setName("someOthername");
-        this.controller.addIndexSchema(this.schema);
-        assertEquals(2, this.controller.indexerMap.size());
-
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.search.index.IndexController.createIndexer(IndexSchema)'
-     */
-    public void testCreateIndexDirectory() throws IOException {
-        File f = new File(System.getProperty("java.io.tmpdir"), "gdataindexdir"
-                + System.currentTimeMillis());
-        f.mkdir();
-        f.deleteOnExit();
-        IndexWriter w = new IndexWriter(f, new StandardAnalyzer(), true);
-        Document d = new Document();
-        d.add(new Field("test", "test", Field.Store.NO, Field.Index.TOKENIZED));
-        w.addDocument(d);
-        w.close();
-        assertFalse(this.controller.createIndexDirectory(f));
-        // throw away files in the directory
-        delAllFiles(f);
-        File f1 = new File(System.getProperty("java.io.tmpdir"), "newIndexDir"
-                + System.currentTimeMillis());
-        f1.mkdir();
-        f1.deleteOnExit();
-        assertTrue(this.controller.createIndexDirectory(f1));
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.search.index.IndexController.createIndexLocation(String,
-     * String)'
-     */
-    public void testCreateIndexLocation() throws IOException {
-        File f = new File(System.getProperty("java.io.tmpdir"), "gdatadir"
-                + System.currentTimeMillis());
-        f.mkdir();
-        f.deleteOnExit();
-
-        assertEquals(f.getAbsolutePath(), this.controller.createIndexLocation(
-                f.getParent(), f.getName()).getAbsolutePath());
-        ;
-        File pFile = new File(System.getProperty("java.io.tmpdir"), "gdatafile"
-                + System.currentTimeMillis());
-        pFile.deleteOnExit();
-        try{
-        this.controller.createIndexLocation(pFile.getParent(),pFile.getAbsolutePath());
-        fail("can not create dir");
-        }catch (RuntimeException e) {
-            
-        }
-        assertTrue(pFile.createNewFile());
-        try {
-            this.controller.createIndexLocation(pFile.getParent(), pFile
-                    .getName());
-            fail("file is not a directory");
-        } catch (IllegalArgumentException e) {
-
-        }
-        try {
-            this.controller.createIndexLocation(pFile.getName(), pFile
-                    .getName());
-            fail("parent is not a directory");
-        } catch (IllegalArgumentException e) {
-
-        }
-        try{
-            this.controller.createIndexLocation(null,null);
-            fail("null");
-        }catch (GdataIndexerException e) {
-
-        }
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.search.index.IndexController.getServiceSearcher(ProvidedService)'
-     */
-    public void testGetServiceSearcher() {
-
-        this.controller.initialize();
-        ReferenceCounter<IndexSearcher> refCounter = this.controller.indexerMap
-                .get(ProvidedServiceStub.SERVICE_NAME).getSearcher();
-        GDataSearcher searcher = this.controller
-                .getServiceSearcher(new ProvidedServiceStub());
-        assertNotNull(searcher);
-        GDataSearcher sameSearcher = this.controller
-                .getServiceSearcher(new ProvidedServiceStub());
-        assertSame(refCounter, this.controller.indexerMap.get(
-                ProvidedServiceStub.SERVICE_NAME).getSearcher());
-
-        this.controller.commitCallBack(ProvidedServiceStub.SERVICE_NAME);
-        GDataSearcher newSearcher = this.controller
-                .getServiceSearcher(new ProvidedServiceStub());
-        assertNotSame(refCounter, this.controller.indexerMap.get(
-                ProvidedServiceStub.SERVICE_NAME).getSearcher());
-
-        sameSearcher.close();
-        searcher.close();
-        newSearcher.close();
-
-    }
-
-    public void testDestroy() {
-        this.controller.initialize();
-        try {
-            this.controller.initialize();
-            fail("controller is initialized");
-        } catch (IllegalStateException e) {
-        }
-        this.controller.destroy();
-        try {
-            this.controller.getServiceSearcher(null);
-            fail("controller is closed");
-        } catch (IllegalStateException e) {
-        }
-        try {
-            this.controller.commitCallBack("null");
-            fail("controller is closed");
-        } catch (IllegalStateException e) {
-        }
-        
-        try {
-            this.controller.destroy();
-            fail("controller is closed");
-        } catch (IllegalStateException e) {
-        }   
-        try {
-            this.controller.addIndexSchema(null);
-            fail("controller is closed");
-        } catch (IllegalStateException e) {
-        }
-        /*
-         * init again to destroy in teardown
-         */
-        this.controller.initialize();
-    }
-    
-    
-    public void testfireInsertEvent(){
-        try{
-        this.controller.fireInsertEvent(null);
-        fail("not initialized");
-        }catch (IllegalStateException e) {
-            // TODO: handle exception
-        }
-        this.controller.initialize();
-        ServerBaseEntry e = new ServerBaseEntry();
-        e.setId("someId");
-        e.setFeedId("someId");
-        e.setServiceConfig(new ProvidedServiceStub());
-        this.controller.fireInsertEvent(e);
-    }
-    
-    public void testCreateNewIndexTask() throws InterruptedException, IOException{
-        this.schema.setCommitAfterDocuments(1);
-        this.schema.setOptimizeAfterCommit(1);
-        IndexSchemaField f = new IndexSchemaField();
-        f.setName("myField");
-        f.setContentType(ContentType.KEYWORD);
-        f.setPath("entry/id");
-        this.schema.addSchemaField(f);
-        this.controller.initialize();
-        ServerBaseEntry e = new ServerBaseEntry();
-        e.setId("someId");
-        e.setFeedId("someId");
-        e.setServiceConfig(new ProvidedServiceStub());
-        CommitListener l = new CommitListener();
-        l.createLatch(1);
-        ServiceIndex sIndex = this.controller.indexerMap.get(this.schema.getName());
-        sIndex.getIndexer().registerIndexEventListener(l);
-        this.controller.fireInsertEvent(e);
-        l.waitOnLatch();      
-       
-       assertEquals(1,sIndex.getIndexer().optimized.get());
-       assertEquals(1,sIndex.getIndexer().committed.get());
-       
-       sIndex.getIndexer().removeIndexEventListener(l);
-       
-       
-       e = new ServerBaseEntry();
-       e.setId("someId");
-       e.setFeedId("someId");
-       e.setServiceConfig(new ProvidedServiceStub());
-       l = new CommitListener();
-       l.createLatch(1);
-        sIndex = this.controller.indexerMap.get(this.schema.getName());
-       sIndex.getIndexer().registerIndexEventListener(l);
-       this.controller.fireUpdateEvent(e);
-       l.waitOnLatch();      
-      
-      assertEquals(2,sIndex.getIndexer().optimized.get());
-      assertEquals(2,sIndex.getIndexer().committed.get());
-      
-      GDataSearcher<String> searcher = this.controller.getServiceSearcher(e.getServiceConfig());
-      List<String> results = searcher.search(new TermQuery(new Term(IndexDocument.FIELD_ENTRY_ID,"someId")),10,0,"someId");
-      assertEquals(1,results.size());
-      searcher.close();
-      
-       
-        
-    }
-    
-    static class CommitListener implements IndexEventListener{
-        public CountDownLatch latch;
-        
-        public void createLatch(int count){
-            this.latch = new CountDownLatch(count);
-        }
-        public void waitOnLatch() throws InterruptedException{
-            if(latch != null)
-            latch.await();
-        }
-
-        public void commitCallBack(String service) {
-            if(this.latch != null)
-            this.latch.countDown();
-        }
-        
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/index/TestIndexLogReader.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/index/TestIndexLogReader.java
deleted file mode 100755
index 2de309f..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/index/TestIndexLogReader.java
+++ /dev/null
@@ -1,139 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.search.index;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Set;
-
-import org.xml.sax.SAXException;
-
-import junit.framework.TestCase;
-
-/**
- * @author Simon Willnauer
- *
- */
-public class TestIndexLogReader extends TestCase {
-    File logFile;
-    Map<String, IndexAction> actions;
-    protected void setUp() throws Exception {
-        this.logFile = new File(System.getProperty("java.io.tmpdir"),"log");
-        this.logFile.deleteOnExit();
-        this.logFile.createNewFile();
-        this.actions = new HashMap<String,IndexAction>();
-   
-        
-    }
-    private IndexLogWriter writeLog() throws IOException{
-        this.actions = new HashMap<String,IndexAction>();
-        IndexLogWriter writer = new IndexLogWriter(this.logFile);
-        boolean totwice = true;
-        for (int i = 0; i < 10; i++) {
-            IndexAction a = null;
-            if(i%3 ==0)
-                a= IndexAction.INSERT;
-            if(i%3 ==1)
-                a= IndexAction.UPDATE;
-            if(i%3 ==2)
-                a= IndexAction.DELETE;
-            this.actions.put(""+i,a);
-            writer.writeAction(""+i,a);
-            /*
-             * double action
-             */
-            if(i == 9 && totwice){
-                i = 0;
-                totwice = false;
-            }
-        }
-        return writer;
-    }
-    protected void tearDown() throws Exception {
-        super.tearDown();
-        this.logFile.delete();
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.search.index.IndexLogReader.readIndexLog(File, Map<String, IndexAction>)'
-     */
-    public void testReadIndexLog() throws SAXException, IOException {
-        writeLog().close();
-        
-        Map<String,IndexAction> readActionMap = new HashMap<String,IndexAction>();
-        IndexLogReader.readIndexLog(this.logFile,readActionMap);
-        Set<String> keySet = this.actions.keySet();
-        assertEquals(10,keySet.size());
-        for (String string : keySet) {
-            assertTrue(readActionMap.get(string).equals(actions.get(string)));
-        }
-        
-       
-        
-    }
-    
-    /*
-     * Test method for 'org.apache.lucene.gdata.search.index.IndexLogReader.readIndexLog(File, Map<String, IndexAction>)'
-     */
-    public void testReadIndexLogNoInputMap() throws SAXException, IOException {
-        writeLog().close();
-      
-        Map<String,IndexAction> readActionMap = IndexLogReader.readIndexLog(this.logFile,null);
-        Set<String> keySet = this.actions.keySet();
-        assertEquals(10,keySet.size());
-        for (String string : keySet) {
-            assertTrue(readActionMap.get(string).equals(actions.get(string)));
-        }
-        
-    }
-    
-    /*
-     * Test method for 'org.apache.lucene.gdata.search.index.IndexLogReader.readIndexLog(File, Map<String, IndexAction>)'
-     */
-    public void testReadIndexLogFixLogFile() throws SAXException, IOException {
-        writeLog();
-          
-        Map<String,IndexAction> readActionMap = IndexLogReader.readIndexLog(this.logFile,null);
-        Set<String> keySet = this.actions.keySet();
-        assertEquals(10,keySet.size());
-        for (String string : keySet) {
-            assertTrue(readActionMap.get(string).equals(actions.get(string)));
-        }
-        
-    }
-    
-    public void testWriterClosed()throws SAXException, IOException{
-        IndexLogWriter writer = writeLog();
-        writer.close();
-        try{
-            writer.writeAction(null,null);
-            fail("writer is closed");
-        }catch (IllegalStateException e) {
-          
-        }
-        try{
-            writer.close();
-            fail("writer is closed");
-        }catch (IllegalStateException e) {
-          
-        }
-        
-        
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/index/TestindexDocumentBuilderTask.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/index/TestindexDocumentBuilderTask.java
deleted file mode 100755
index 0d7f130..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/index/TestindexDocumentBuilderTask.java
+++ /dev/null
@@ -1,163 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.search.index;
-
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-
-import junit.framework.TestCase;
-
-import org.apache.lucene.gdata.data.ServerBaseEntry;
-import org.apache.lucene.gdata.search.config.IndexSchema;
-import org.apache.lucene.gdata.search.config.IndexSchemaField;
-import org.apache.lucene.gdata.search.config.IndexSchemaField.ContentType;
-import org.apache.lucene.gdata.utils.ProvidedServiceStub;
-
-import com.google.gdata.data.PlainTextConstruct;
-
-/**
- * @author Simon Willnauer
- *
- */
-public class TestindexDocumentBuilderTask extends TestCase {
-    IndexDocumentBuilder fineBuilder;
-    IndexDocumentBuilder failInStrategyBuilder;
-    IndexDocumentBuilder builder;
-    IndexDocumentBuilderTask zeroFields;
-    static String ID = "someId";
-    static String CONTENT_FIELD = "someId";
-    static String CONTENT = "foo bar";
-    protected void setUp() throws Exception {
-        ServerBaseEntry entry = new ServerBaseEntry();
-        entry.setVersionId("1");
-        entry.setFeedId("myFeed");
-        entry.setId(ID);
-        entry.setContent(new PlainTextConstruct(CONTENT));
-        entry.setServiceConfig(new ProvidedServiceStub());
-        IndexSchema schema = new IndexSchema();
-        schema.setName("mySchema");
-        IndexSchemaField field = new IndexSchemaField();
-        field.setName(CONTENT_FIELD);
-        field.setPath("/entry/content");
-        field.setContentType(ContentType.TEXT);
-        schema.addSchemaField(field);
-        this.fineBuilder = new IndexDocumentBuilderTask(entry,schema,IndexAction.INSERT,true,true);
-        
-        /*
-         * two fields, one will fail due to broken xpath.
-         * One will remain.
-         */
-        schema = new IndexSchema();
-        schema.setName("mySchema");
-        field = new IndexSchemaField();
-        field.setName("someContent");
-        //broken xpath
-        field.setPath("/entry///wrongXPath");
-        field.setContentType(ContentType.TEXT);
-        schema.addSchemaField(field);
-        field = new IndexSchemaField();
-        field.setName(CONTENT_FIELD);
-        field.setPath("/entry/content");
-        field.setContentType(ContentType.TEXT);
-        schema.addSchemaField(field);
-        this.failInStrategyBuilder = new IndexDocumentBuilderTask(entry,schema,IndexAction.INSERT,false,false);
-        //fail with no fields
-        schema = new IndexSchema();
-        schema.setName("mySchema");
-        this.zeroFields = new IndexDocumentBuilderTask(entry,schema,IndexAction.INSERT,false,false);
-        
-        
-    }
-
-    protected void tearDown() throws Exception {
-        super.tearDown();
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.search.index.IndexDocumentBuilderTask.IndexDocumentBuilderTask(ServerBaseEntry, IndexSchema, IndexAction, boolean)'
-     */
-    public void testIndexDocumentBuilderTask() {
-        IndexDocument doc = this.fineBuilder.call();
-        assertNotNull(doc.getDeletealbe());
-        assertNotNull(doc.getWriteable());
-        assertEquals(IndexDocument.FIELD_ENTRY_ID,doc.getDeletealbe().field());
-        assertEquals(ID,doc.getDeletealbe().text());
-        assertEquals(ID,doc.getWriteable().getField(IndexDocument.FIELD_ENTRY_ID).stringValue());
-        assertNotNull(doc.getWriteable().getField(CONTENT_FIELD).stringValue());
-      
-        /*
-         * the broken xpath fails but the other fields will be indexed
-         */
-        doc = this.failInStrategyBuilder.call();
-        assertNotNull(doc.getDeletealbe());
-        assertNotNull(doc.getWriteable());
-        assertEquals(IndexDocument.FIELD_ENTRY_ID,doc.getDeletealbe().field());
-        assertEquals(ID,doc.getDeletealbe().text());
-        assertEquals(ID,doc.getWriteable().getField(IndexDocument.FIELD_ENTRY_ID).stringValue());
-        assertNotNull(doc.getWriteable().getField(CONTENT_FIELD).stringValue());
-        
-        try{
-        this.zeroFields.call();
-        fail("zero fields in document");
-        }catch (GdataIndexerException e) {}
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.search.index.IndexDocumentBuilderTask.call()'
-     */
-    public void testCall() throws InterruptedException, ExecutionException {
-        ExecutorService service = Executors.newSingleThreadExecutor();
-        Future<IndexDocument> future = service.submit(this.fineBuilder);
-        IndexDocument doc = future.get();
-        assertNotNull(doc.getDeletealbe());
-        assertNotNull(doc.getWriteable());
-        assertEquals(IndexDocument.FIELD_ENTRY_ID,doc.getDeletealbe().field());
-        assertEquals(ID,doc.getDeletealbe().text());
-        assertEquals(ID,doc.getWriteable().getField(IndexDocument.FIELD_ENTRY_ID).stringValue());
-        assertNotNull(doc.getWriteable().getField(CONTENT_FIELD).stringValue());
-        assertTrue(doc.commitAfter());
-        assertTrue(doc.optimizeAfter());
-      
-        /*
-         * the broken xpath fails but the other fields will be indexed
-         */
-        future = service.submit(this.failInStrategyBuilder);
-         doc = future.get();
-        
-        assertNotNull(doc.getDeletealbe());
-        assertNotNull(doc.getWriteable());
-        assertEquals(IndexDocument.FIELD_ENTRY_ID,doc.getDeletealbe().field());
-        assertEquals(ID,doc.getDeletealbe().text());
-        assertEquals(ID,doc.getWriteable().getField(IndexDocument.FIELD_ENTRY_ID).stringValue());
-        assertNotNull(doc.getWriteable().getField(CONTENT_FIELD).stringValue());
-        future = service.submit(this.zeroFields);
-        
-        try{
-         future.get();
-        fail("zero fields in document");
-        }catch (ExecutionException e) {
-            assertTrue(e.getCause().getClass() == GdataIndexerException.class);
-            
-        }
-        service.shutdownNow();
-    }
-    
-    
-    
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/query/TestGdataQueryParser.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/query/TestGdataQueryParser.java
deleted file mode 100755
index 09a1927..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/query/TestGdataQueryParser.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.search.query;
-
-import org.apache.lucene.analysis.standard.StandardAnalyzer;
-import org.apache.lucene.gdata.search.config.IndexSchema;
-import org.apache.lucene.queryParser.QueryParser.Operator;
-
-import junit.framework.TestCase;
-
-public class TestGdataQueryParser extends TestCase {
-
-    
-    public void testConstructor(){
-        String field = "someField";
-        IndexSchema s = new IndexSchema();
-        s.setDefaultSearchField(field);
-        GDataQueryParser p = new GDataQueryParser(s);
-        assertEquals(field,p.getField());
-        assertEquals(Operator.AND,p.getDefaultOperator());
-        assertEquals(StandardAnalyzer.class,p.getAnalyzer().getClass());
-    }
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/query/TestQueryTranslator.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/query/TestQueryTranslator.java
deleted file mode 100755
index bdfe3e7..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/search/query/TestQueryTranslator.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */ 
-package org.apache.lucene.gdata.search.query;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import org.apache.lucene.gdata.search.config.IndexSchema;
-import org.apache.lucene.gdata.search.config.IndexSchemaField;
-import org.apache.lucene.gdata.search.config.IndexSchemaField.ContentType;
-import org.apache.lucene.gdata.utils.ProvidedServiceStub;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.RangeQuery;
-
-import junit.framework.TestCase;
-
-/**
- * @author Simon Willnauer
- *
- */
-public class TestQueryTranslator extends TestCase {
-    private static final String CONTENT_FIELD = "content";
-    private static final String UPDATED_FIELD = "updated";
-    private IndexSchema schema;
-    Map<String,String[]> parameterMap;
-    /*
-     * @see junit.framework.TestCase#setUp()
-     */
-    @Override
-    protected void setUp() throws Exception {
-        this.schema = new IndexSchema();
-        //must be set
-        this.schema.setDefaultSearchField(CONTENT_FIELD);
-        this.schema.setIndexLocation("/tmp/");
-        this.schema.setName(ProvidedServiceStub.SERVICE_NAME);
-        IndexSchemaField field = new IndexSchemaField();
-        
-        field.setName(CONTENT_FIELD);
-        field.setContentType(ContentType.TEXT);
-        
-        IndexSchemaField field1 = new IndexSchemaField();
-        field1.setName(UPDATED_FIELD);
-        field1.setContentType(ContentType.GDATADATE);
-        this.schema.addSchemaField(field);
-        this.schema.addSchemaField(field1);
-        parameterMap = new HashMap<String,String[]>();
-        
-
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.search.query.QueryTranslator.translateHttpSearchRequest(IndexSchema, Map<String, String>, String, String)'
-     */
-    public void testTranslateHttpSearchRequest() {
-        assertNull(QueryTranslator.translateHttpSearchRequest(this.schema,this.parameterMap,null));
-        String contentQuery = "content1 -content2 \"exact Content\""; 
-        parameterMap.put("q", new String[]{contentQuery});
-        String expected = CONTENT_FIELD+":("+contentQuery+") ";
-      
-        assertEquals(expected,QueryTranslator.translateHttpSearchRequest(this.schema,this.parameterMap,null));
-        parameterMap.put("updated-min", new String[]{"2005-08-09T10:57:00-08:00"});
-        parameterMap.put("updated-max", new String[]{"2005-10-09T10:57:00-08:00"});
-        parameterMap.put("max-results", new String[]{"3"});
-        parameterMap.remove("q");
-        parameterMap.put(CONTENT_FIELD, new String[]{"apache"});
-        
-        String tranlatedQuery = QueryTranslator.translateHttpSearchRequest(this.schema,this.parameterMap,"test |{urn:google.com} {urn:apache.org}");
-        assertTrue(tranlatedQuery.contains("updated:[1123613820000 TO 1128884219999]"));
-        assertTrue(tranlatedQuery.contains(CONTENT_FIELD+":(apache)"));
-        
-        parameterMap.remove("updated-max");
-        tranlatedQuery = QueryTranslator.translateHttpSearchRequest(this.schema,this.parameterMap,"test |{urn:google.com} {urn:apache.org}");
-        assertTrue(tranlatedQuery.contains("updated:[1123613820000 TO "+Long.MAX_VALUE+"]"));
-        assertTrue(tranlatedQuery.contains(CONTENT_FIELD+":(apache)"));
-        parameterMap.put("updated-max", new String[]{"2005-10-09T10:57:00-08:00"});
-        parameterMap.remove("updated-min");
-        tranlatedQuery = QueryTranslator.translateHttpSearchRequest(this.schema,this.parameterMap,"test |{urn:google.com} {urn:apache.org}");
-        assertTrue(tranlatedQuery.contains("updated:["+0+" TO 1128884219999]"));
-        assertTrue(tranlatedQuery.contains(CONTENT_FIELD+":(apache)"));
-        
-        
-        
-        parameterMap.put("wrong-parameter", new String[]{"3"});
-        try{
-        QueryTranslator.translateHttpSearchRequest(this.schema,this.parameterMap,"test |{urn:google.com} {urn:apache.org}");
-        fail("illegal parameter");
-        }catch (RuntimeException e) {
-           
-        }
-       
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/server/TestGDataRequest.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/server/TestGDataRequest.java
deleted file mode 100644
index f635a8e..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/server/TestGDataRequest.java
+++ /dev/null
@@ -1,681 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */ 
-package org.apache.lucene.gdata.server; 
- 
-import java.util.Enumeration;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.StringTokenizer;
-
-import javax.servlet.http.HttpServletRequest;
-
-import junit.framework.TestCase;
-
-import org.apache.lucene.gdata.search.config.IndexSchema;
-import org.apache.lucene.gdata.search.config.IndexSchemaField;
-import org.apache.lucene.gdata.search.config.IndexSchemaField.ContentType;
-import org.apache.lucene.gdata.server.GDataRequest.GDataRequestType;
-import org.apache.lucene.gdata.server.GDataRequest.OutputFormat;
-import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
-import org.apache.lucene.gdata.server.registry.ProvidedService;
-import org.apache.lucene.gdata.utils.ProvidedServiceStub;
-import org.apache.lucene.gdata.utils.StorageStub;
-import org.easymock.MockControl;
- 
-/** 
- *  
- * @author Simon Willnauer 
- *  
- */ 
-public class TestGDataRequest extends TestCase { 
-    private HttpServletRequest request; 
- 
-    private MockControl control; 
- 
-    private GDataRequest feedRequest; 
-    
-    private Map parametermap = new HashMap();
-    
-    @Override 
-    protected void setUp() throws Exception {
-        try{
-            GDataServerRegistry.getRegistry().registerComponent(StorageStub.class,null);
-        }catch (Exception e) {
-
-        }
-        ProvidedService configurator = new ProvidedServiceStub();
-        GDataServerRegistry.getRegistry().registerService(configurator);
-        IndexSchema schema = new IndexSchema();
-        //must be set
-        schema.setDefaultSearchField("field");
-        schema.setIndexLocation("/tmp/");
-        schema.setName(ProvidedServiceStub.SERVICE_NAME);
-        
-        ((ProvidedServiceStub)configurator).setIndexSchema(schema);
-            
-        this.control = MockControl.createControl(HttpServletRequest.class); 
-        this.request = (HttpServletRequest) this.control.getMock(); 
-        this.feedRequest = new GDataRequest(this.request,GDataRequestType.GET); 
-         
-    } 
- 
-    protected void tearDown() throws Exception { 
-        super.tearDown(); 
-        this.control.reset(); 
-        GDataServerRegistry.getRegistry().destroy();
-    } 
- 
-    public void testConstructor() { 
-        try { 
-            new GDataRequest(null,GDataRequestType.GET); 
-            fail("IllegalArgumentException expected"); 
-        } catch (IllegalArgumentException e) { 
-            //  
-        } 
-        try { 
-            new GDataRequest(null,null); 
-            fail("IllegalArgumentException expected"); 
-        } catch (IllegalArgumentException e) { 
-            //  
-        } 
-        try { 
-            new GDataRequest(this.request,null); 
-            fail("IllegalArgumentException expected"); 
-        } catch (IllegalArgumentException e) { 
-            //  
-        } 
-    } 
- 
-    public void testGetFeedId() throws GDataRequestException { 
-        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
-        this.control.expectAndDefaultReturn(this.request.getPathInfo(), 
-                "/"+ProvidedServiceStub.SERVICE_NAME+"/feed/1/1"); 
-        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
-                null); 
-        this.control.replay(); 
-        this.feedRequest.initializeRequest(); 
-        assertEquals("feedID", this.feedRequest.getFeedId(), "feed"); 
-        this.control.reset(); 
- 
-    } 
- 
-    public void testEmptyPathInfo() { 
-        this.control.expectAndDefaultReturn(this.request.getPathInfo(), "/"); 
-        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
-                null); 
-        this.control.replay(); 
-        try { 
-            this.feedRequest.initializeRequest(); 
- 
-            fail("FeedRequestException expected"); 
-        } catch (GDataRequestException e) { 
-            // expected 
-        } catch (Exception e) { 
-            fail("FeedRequestException expected"); 
-        } 
- 
-    } 
- 
-    public void testGetFeedIdWithoutEntry() throws GDataRequestException { 
-        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
-        this.control 
-                .expectAndDefaultReturn(this.request.getPathInfo(), "/"+ProvidedServiceStub.SERVICE_NAME+"/feed"); 
-        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
-                null); 
-        this.control.replay(); 
-        this.feedRequest.initializeRequest(); 
-        assertEquals("feedID", this.feedRequest.getFeedId(), "feed"); 
-    } 
- 
-    public void testGetEntyId() throws GDataRequestException { 
-        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
-        this.control.expectAndDefaultReturn(this.request.getPathInfo(), 
-                "/"+ProvidedServiceStub.SERVICE_NAME+"/feed/1/15"); 
-        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
-                null); 
-        this.control.replay(); 
-        this.feedRequest.initializeRequest(); 
-        assertEquals("entryid", this.feedRequest.getEntryId(), "1"); 
-        assertEquals("feedId", this.feedRequest.getFeedId(), "feed"); 
-        assertEquals("entryid", this.feedRequest.getEntryVersion(), "15"); 
-        this.control.reset(); 
- 
-    } 
- 
-    public void testSetResponseFormatAtom() throws GDataRequestException { 
-        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
-        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
-                "atom"); 
-        this.control 
-                .expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+ "/feed"); 
-        this.control.replay(); 
-        this.feedRequest.initializeRequest(); 
-        assertEquals("ResponseFromat Atom", this.feedRequest 
-                .getRequestedResponseFormat(), OutputFormat.ATOM); 
-        this.control.reset(); 
-    } 
- 
-    public void testSetResponseFormatRSS() throws GDataRequestException { 
-        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
-        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
-                "rss"); 
-        this.control 
-                .expectAndDefaultReturn(this.request.getPathInfo(), "/"+ProvidedServiceStub.SERVICE_NAME+"/feed"); 
-        this.control.replay(); 
-        this.feedRequest.initializeRequest(); 
-        assertEquals("ResponseFromat RSS", this.feedRequest 
-                .getRequestedResponseFormat(), OutputFormat.RSS); 
-        this.control.reset(); 
-    } 
- 
-    public void testSetResponseFormatKeepAtom() throws GDataRequestException { 
-        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
-        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
-                "fooBar"); 
-        this.control 
-                .expectAndDefaultReturn(this.request.getPathInfo(), "/"+ProvidedServiceStub.SERVICE_NAME+"/feed"); 
-        this.control.replay(); 
-        this.feedRequest.initializeRequest(); 
-        assertEquals("ResponseFromat Atom", this.feedRequest 
-                .getRequestedResponseFormat(), OutputFormat.ATOM); 
-        this.control.reset(); 
-    } 
- 
-    public void testSetResponseFormatNull() throws GDataRequestException { 
-        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
-        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
-                null); 
- 
-        this.control 
-                .expectAndDefaultReturn(this.request.getPathInfo(), "/"+ProvidedServiceStub.SERVICE_NAME+"/feed"); 
-        this.control.replay(); 
-        this.feedRequest.initializeRequest(); 
-        assertEquals("ResponseFromat Atom", this.feedRequest 
-                .getRequestedResponseFormat(), OutputFormat.ATOM); 
-        this.control.reset(); 
-    } 
- 
-    public void testGetItemsPerPage() throws GDataRequestException { 
-        this.control.expectAndReturn(this.request.getParameter("max-results"), 
-                null); 
-        this.control.replay(); 
-        assertEquals("default value 25", 25, this.feedRequest.getItemsPerPage()); 
-        this.control.verify(); 
-        this.control.reset(); 
- 
-        this.control.expectAndReturn(this.request.getParameter("max-results"), 
-                "24", 2); 
-        this.control.replay(); 
-        assertEquals("24 results", 24, this.feedRequest.getItemsPerPage()); 
-        this.control.verify(); 
-        this.control.reset(); 
-         
-        this.control.expectAndReturn(this.request.getParameter("max-results"), 
-                "-1", 2); 
-        this.control.replay(); 
-        assertEquals("25 results", 25, this.feedRequest.getItemsPerPage()); 
-        this.control.verify(); 
-        this.control.reset(); 
- 
-        this.control.expectAndReturn(this.request.getParameter("max-results"), 
-                "helloworld", 2); 
-        this.control.replay(); 
-        assertEquals("25 results", 25, this.feedRequest.getItemsPerPage()); 
-        this.control.verify(); 
-        this.control.reset(); 
-    } 
-     
-    public void testGetSelfId() throws GDataRequestException{ 
-        String host = "www.apache.org"; 
-        String feedAndEntryID = "/"+ProvidedServiceStub.SERVICE_NAME+"/feed/entryid"; 
-        String queryString = "max-results=25"; 
-        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
-        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
-        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/host"+"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/entryId/15/"); 
-        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/entryId/15"); 
-        this.control.expectAndReturn(this.request.getParameter("max-results"),"25",2); 
-        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
-                null); 
-        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
-                queryString); 
-        this.control.replay(); 
-        this.feedRequest.initializeRequest(); 
-        String selfID = "http://"+host+"/host"+"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/entryId/15?"+queryString; 
-        assertEquals("Self ID",selfID,this.feedRequest.getSelfId()); 
-        this.control.reset(); 
-         
-         
-        queryString = "alt=rss&max-results=25";
-        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
-        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
-        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/host"+"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/entryId/15/"); 
-        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/entryId/15"); 
-        this.control.expectAndReturn(this.request.getParameter("max-results"),"25",2); 
-        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
-                null); 
-        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
-                queryString); 
-        this.control.replay(); 
-        this.feedRequest.initializeRequest(); 
-        selfID = "http://"+host+"/host"+"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/entryId/15?"+queryString; 
-     
-        assertEquals("Self ID",selfID,this.feedRequest.getSelfId()); 
-        this.control.reset(); 
-         
-        queryString = ""; 
-        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
-        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
-        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/host"+"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/entryId/15/"); 
-        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/entryId/15"); 
-        this.control.expectAndDefaultReturn(this.request.getParameter("max-results"),null); 
-        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
-                null); 
-        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
-                null); 
-        this.control.replay(); 
-        this.feedRequest.initializeRequest(); 
-        selfID = "http://"+host+"/host"+"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/entryId/15"+"?max-results=25"; 
-     
-        assertEquals("Self ID",selfID,this.feedRequest.getSelfId()); 
-        this.control.reset(); 
-    } 
-     
-    public void testGetQueryString(){ 
-        String maxResults  = "max-results=25"; 
-        String queryString = "?"+maxResults; 
-        this.control.expectAndReturn(this.request.getParameter("max-results"),"25",2); 
-         
-        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
-                queryString); 
-        this.control.replay(); 
-         
-        assertEquals(queryString,this.feedRequest.getQueryString()); 
-        this.control.reset(); 
-        // test no result defined 
-        queryString = "?alt=rss"; 
-        this.control.expectAndDefaultReturn(this.request.getParameter("max-results"),null); 
-         
-        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
-                queryString); 
-        this.control.replay(); 
-         
-        assertEquals(queryString+"&"+maxResults,this.feedRequest.getQueryString()); 
-        this.control.reset(); 
-         
-//         test no result defined && query == null 
-        queryString = null; 
-        this.control.expectAndDefaultReturn(this.request.getParameter("max-results"),null); 
-         
-        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
-                queryString); 
-        this.control.replay(); 
-         
-        assertEquals(maxResults,this.feedRequest.getQueryString()); 
-        this.control.reset(); 
-     
-    } 
-     
-    public void testIsFeedRequest() throws GDataRequestException{ 
-        String host = "www.apache.org"; 
-        String feedAndEntryID = "/feed"; 
-        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
-        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
-        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/host"+"/"+ProvidedServiceStub.SERVICE_NAME+"/feed"); 
-        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed"); 
-         
-        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
-                null); 
-        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
-                null); 
-        this.control.replay(); 
-        this.feedRequest.initializeRequest(); 
-         
-     
-        assertTrue(this.feedRequest.isFeedRequested()); 
-        assertFalse(this.feedRequest.isEntryRequested()); 
-        this.control.reset(); 
-         
-        host = "www.apache.org"; 
-        feedAndEntryID = "/"+ProvidedServiceStub.SERVICE_NAME+"/feed/1"; 
-        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
-        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
-        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/host"+"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/1"); 
-        this.control.expectAndDefaultReturn(this.request.getPathInfo(),feedAndEntryID); 
-         
-        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
-                null); 
-        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
-                null); 
-        this.control.replay(); 
-        this.feedRequest.initializeRequest(); 
-         
-     
-        assertFalse(this.feedRequest.isFeedRequested()); 
-        assertTrue(this.feedRequest.isEntryRequested()); 
-        this.control.reset(); 
-        
-        host = "www.apache.org"; 
-        feedAndEntryID = "/"+ProvidedServiceStub.SERVICE_NAME+"/feed/1"; 
-        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
-        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
-        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/host"+"/"+"NOTREGISTERED"+"/feed/1"); 
-        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+"NOTREGISTERED"+"/feed/1"); 
-         
-        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
-                null); 
-        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
-                null); 
-        this.control.replay(); 
-        try{
-        this.feedRequest.initializeRequest();
-        fail("service not registered");
-        }catch (GDataRequestException e) {
-            //
-        }
-        this.control.reset(); 
-        
-        host = "www.apache.org"; 
-        feedAndEntryID = "/"+ProvidedServiceStub.SERVICE_NAME+"/feed/1"; 
-        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
-        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
-        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/host"+"/"+ProvidedServiceStub.SERVICE_NAME+"/"); 
-        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+"/"); 
-         
-        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
-                null); 
-        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
-                null); 
-        this.control.replay(); 
-        try{
-        this.feedRequest.initializeRequest();
-        fail("service not registered");
-        }catch (GDataRequestException e) {
-//
-        }
-        this.control.reset(); 
-         
-         
-    } 
-    public void testgetAuthToken(){ 
-        this.control.expectAndDefaultReturn(this.request.getHeader("Authentication"),"GoogleLogin auth=bla");
-        this.control.replay();
-        assertEquals("bla",this.feedRequest.getAuthToken());
-        this.control.verify();
-        this.control.reset();
-        
-        this.control.expectAndDefaultReturn(this.request.getHeader("Authentication"),null);
-        this.control.replay();
-        assertNull(this.feedRequest.getAuthToken());
-        this.control.verify();
-        this.control.reset();
-        
-    } 
-    
-    public void testGetStartIndex(){
-        this.control.expectAndDefaultReturn(this.request.getParameter("start-index"),"5");
-        this.control.replay();
-        assertEquals(5,this.feedRequest.getStartIndex());
-        this.control.verify();
-        this.control.reset();
-        this.control.expectAndDefaultReturn(this.request.getParameter("start-index"),"-5");
-        this.control.replay();
-        assertEquals(1,this.feedRequest.getStartIndex());
-        this.control.verify();
-        this.control.reset();
-        this.control.expectAndDefaultReturn(this.request.getParameter("start-index"),"unparsable");
-        this.control.replay();
-        assertEquals(1,this.feedRequest.getStartIndex());
-        this.control.verify();
-        this.control.reset();
-    }
-     
-    public void testGetNextId() throws GDataRequestException{ 
-        String host = "www.apache.org"; 
-        String feedAndEntryID = "/"+ProvidedServiceStub.SERVICE_NAME+"/feed/entryid"; 
-        String queryString = "max-results=25"; 
-        String startIndex = "start-index=26"; 
-        Enumeration enu = new StringTokenizer("max-results",",");
-        
-        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
-        this.control.expectAndDefaultReturn(this.request.getParameterNames(),enu);
-        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
-        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/"); 
-        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/"); 
-        this.control.expectAndReturn(this.request.getParameter("max-results"),"25",3); 
-        this.control.expectAndReturn(this.request.getParameter("start-index"),null); 
-        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
-                null); 
-        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
-                queryString); 
-        this.control.replay(); 
-
-        this.feedRequest.initializeRequest(); 
-        String nextID = "http://"+host+"/"+ProvidedServiceStub.SERVICE_NAME+"/feed?"+startIndex+"&"+queryString; 
-     
-        assertEquals("Next ID",nextID,this.feedRequest.getNextId());
-        this.control.verify();
-        this.control.reset(); 
-         
-        enu = new StringTokenizer("alt,max-results,start-index",",");
-        queryString = "alt=rss&max-results=25"; 
-        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
-        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
-        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/"); 
-        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/"); 
-        this.control.expectAndReturn(this.request.getParameter("max-results"),"25",4); 
-        this.control.expectAndReturn(this.request.getParameter("start-index"),"26",4); 
-        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
-                "rss"); 
-        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
-                queryString+"&"+startIndex); 
-        
-        this.control.expectAndDefaultReturn(this.request.getParameterNames(),enu);
-        
-        
-        this.control.replay(); 
-        this.feedRequest.initializeRequest(); 
-        startIndex = "&start-index=51"; 
-        nextID = "http://"+host+"/"+ProvidedServiceStub.SERVICE_NAME+"/feed?"+queryString+startIndex; 
-     
-        assertEquals("Next ID 51",nextID,this.feedRequest.getNextId()); 
-        this.control.reset(); 
-         
-        queryString = ""; 
-        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
-        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
-        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/"); 
-        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/entryId/15"); 
-        this.control.expectAndDefaultReturn(this.request.getParameter("max-results"),null); 
-        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
-                null); 
-        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
-                null); 
-        this.control.replay(); 
-        this.feedRequest.initializeRequest(); 
-        String nextId = "http://"+host+"/"+ProvidedServiceStub.SERVICE_NAME+"/feed"+"?max-results=25&start-index=26"; 
-     
-        assertEquals("next ID",nextId,this.feedRequest.getNextId()); 
-        this.control.reset();
-
-        
-        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
-        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
-        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/"); 
-        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/entryId/15"); 
-        this.control.expectAndReturn(this.request.getParameter("max-results"),null,3); 
-        this.control.expectAndReturn(this.request.getParameter("start-index"),null,3);
-        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
-                null); 
-        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
-                null); 
-        this.control.replay(); 
-        this.feedRequest.initializeRequest(); 
-        nextId = "http://"+host+"/"+ProvidedServiceStub.SERVICE_NAME+"/feed"+"?max-results=25&start-index=26"; 
-        assertEquals("nextID",nextId,this.feedRequest.getNextId());
-    } 
-    
-    public void testGetpreviousId() throws GDataRequestException{ 
-        String host = "www.apache.org"; 
-        String feedAndEntryID = "/"+ProvidedServiceStub.SERVICE_NAME+"/feed/entryid"; 
-        String queryString = "max-results=25"; 
-         
-        Enumeration enu = new StringTokenizer("max-results",",");
-        
-        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
-        this.control.expectAndDefaultReturn(this.request.getParameterNames(),enu);
-        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
-        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/"); 
-        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/"); 
-        this.control.expectAndReturn(this.request.getParameter("start-index"),null); 
-        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
-                null); 
-        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
-                queryString); 
-        this.control.replay(); 
-
-        this.feedRequest.initializeRequest(); 
-         
-     
-        assertNull(this.feedRequest.getPreviousId());
-        this.control.verify();
-        this.control.reset(); 
-        String startIndex = "start-index="; 
-        enu = new StringTokenizer("alt,max-results,start-index",",");
-        queryString = "alt=rss&max-results=25&start-index=26"; 
-        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
-        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
-        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/"); 
-        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/"); 
-        this.control.expectAndReturn(this.request.getParameter("max-results"),"25",4); 
-        this.control.expectAndReturn(this.request.getParameter("start-index"),"26",4); 
-        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
-                "rss"); 
-        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
-                queryString); 
-        
-        this.control.expectAndDefaultReturn(this.request.getParameterNames(),enu);
-        
-        
-        this.control.replay(); 
-        this.feedRequest.initializeRequest(); 
-        
-        String prevId = "http://"+host+"/"+ProvidedServiceStub.SERVICE_NAME+"/feed"+"?alt=rss&max-results=25&start-index=1"; 
-        assertEquals("prevID",prevId,this.feedRequest.getPreviousId());
-        
-        this.control.reset(); 
-         
-        queryString = ""; 
-        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
-        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
-        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/"); 
-        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/entryId/15"); 
-        this.control.expectAndDefaultReturn(this.request.getParameter("max-results"),null); 
-        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
-                null); 
-        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
-                null); 
-        this.control.replay(); 
-        this.feedRequest.initializeRequest(); 
-        assertNull(this.feedRequest.getPreviousId());
-     
-        
-        this.control.reset(); 
-        
-        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
-        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
-        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/"); 
-        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/entryId/15"); 
-        this.control.expectAndReturn(this.request.getParameter("max-results"),"35",3); 
-        this.control.expectAndReturn(this.request.getParameter("start-index"),"5",3);
-        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
-                null); 
-        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
-                "max-results=35&start-index=5"); 
-        this.control.replay(); 
-        this.feedRequest.initializeRequest(); 
-        prevId = "http://"+host+"/"+ProvidedServiceStub.SERVICE_NAME+"/feed"+"?max-results=35&start-index=1"; 
-        assertEquals("prevID",prevId,this.feedRequest.getPreviousId());
-        
-        
-        
-        
-    } 
-    
-    public void testGetContextPath(){
-        String host = "www.apache.org"; 
-        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
-        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/id/"); 
-        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/id/"); 
-        this.control.replay();
-        String result = "http://"+host+"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/id/";
-        assertEquals(result,this.feedRequest.getContextPath());
-        this.control.verify();
-        this.control.reset();
-        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
-        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/id"); 
-        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/id"); 
-        this.control.replay();
-        
-        assertEquals(result,this.feedRequest.getContextPath());
-        this.control.verify();
-        
-    }
-    
-    public void testCategoryQuery() throws GDataRequestException{
-        String host = "www.apache.org"; 
-        String feedAndEntryID = "/feed"; 
-        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
-        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
-        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/host"+"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/-/test"); 
-        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/-/test"); 
-         
-        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
-                null); 
-        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
-                null); 
-        this.control.replay(); 
-        this.feedRequest.initializeRequest(); 
-         
-     
-        assertTrue(this.feedRequest.isFeedRequested()); 
-        assertFalse(this.feedRequest.isEntryRequested()); 
-        assertNotNull(this.feedRequest.getTranslatedQuery());
-        this.control.verify();
-        this.control.reset();
-        this.feedRequest = new GDataRequest(this.request,GDataRequestType.GET); 
-        this.control.expectAndDefaultReturn(this.request.getParameterMap(),this.parametermap);
-        this.control.expectAndDefaultReturn(this.request.getHeader("Host"),host); 
-        this.control.expectAndDefaultReturn(this.request.getRequestURI(),"/host"+"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/"); 
-        this.control.expectAndDefaultReturn(this.request.getPathInfo(),"/"+ProvidedServiceStub.SERVICE_NAME+"/feed/"); 
-         
-        this.control.expectAndDefaultReturn(this.request.getParameter("alt"), 
-                null); 
-        this.control.expectAndDefaultReturn(this.request.getQueryString(), 
-                null); 
-        this.control.replay(); 
-        this.feedRequest.initializeRequest(); 
-         
-     
-        assertTrue(this.feedRequest.isFeedRequested()); 
-        assertFalse(this.feedRequest.isEntryRequested()); 
-        assertNull(this.feedRequest.getTranslatedQuery());
-        this.control.verify();
-        this.control.reset(); 
-    }
-    
-    
-    
-} 
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/server/TestGDataResponse.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/server/TestGDataResponse.java
deleted file mode 100644
index 400ee5a..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/server/TestGDataResponse.java
+++ /dev/null
@@ -1,177 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.server; 
- 
-import java.io.IOException; 
-import java.io.PrintWriter; 
-import java.io.StringWriter; 
- 
-import javax.servlet.http.HttpServletResponse; 
- 
-import junit.framework.TestCase; 
- 
-import org.apache.lucene.gdata.server.GDataRequest.OutputFormat; 
-import org.apache.lucene.gdata.utils.ProvidedServiceStub;
-import org.easymock.MockControl; 
- 
-import com.google.gdata.data.Entry; 
-import com.google.gdata.data.ExtensionProfile; 
-import com.google.gdata.data.Feed; 
-import com.google.gdata.data.PlainTextConstruct; 
-/** 
- *  
- * @author Simon Willnauer 
- * 
- */ 
-public class TestGDataResponse extends TestCase { 
-    private GDataResponse response; 
-    private HttpServletResponse httpResponse; 
-    private MockControl control; 
-    private static String generatedFeedAtom = "<?xml version='1.0'?><feed xmlns='http://www.w3.org/2005/Atom' xmlns:openSearch='http://a9.com/-/spec/opensearchrss/1.0/'><entry><title type='text'>Test</title></entry></feed>"; 
-    private static String generatedEntryAtom = "<?xml version='1.0'?><entry xmlns='http://www.w3.org/2005/Atom'><title type='text'>Test</title></entry>"; 
-    private static String generatedFeedRSS = "<?xml version='1.0'?><rss xmlns:atom='http://www.w3.org/2005/Atom' xmlns:openSearch='http://a9.com/-/spec/opensearchrss/1.0/' version='2.0'><channel><description></description><item><title>Test</title></item></channel></rss>"; 
-    private static String generatedEntryRSS = "<?xml version='1.0'?><item xmlns:atom='http://www.w3.org/2005/Atom'><title>Test</title></item>"; 
-    protected void setUp() throws Exception { 
-        this.control = MockControl.createControl(HttpServletResponse.class); 
-        this.httpResponse = (HttpServletResponse)this.control.getMock(); 
-        this.response = new GDataResponse(this.httpResponse); 
-         
-    } 
- 
-    protected void tearDown() throws Exception { 
-        super.tearDown(); 
-    } 
-     
-     
-    public void testConstructor(){ 
-        try{ 
-        new GDataResponse(null); 
-        fail("IllegalArgumentExceptin expected"); 
-        }catch (IllegalArgumentException e) { 
-            // TODO: handle exception 
-        } 
-    } 
-    /* 
-     * Test method for 'org.apache.lucene.gdata.server.GDataResponse.sendResponse(BaseFeed, ExtensionProfile)' 
-     */ 
-    public void testSendResponseBaseFeedExtensionProfile() throws IOException { 
-        try{ 
-            Feed f = null; 
-            this.response.sendResponse(f, new ProvidedServiceStub()); 
-            fail("Exception expected"); 
-        }catch (IllegalArgumentException e) { 
-            // 
-        } 
-         
-        try{ 
-            Feed f = createFeed(); 
-            this.response.sendResponse(f,null); 
-            fail("Exception expected"); 
-        }catch (IllegalArgumentException e) { 
-            // 
-        } 
-        StringWriter stringWriter = new StringWriter(); 
-        PrintWriter writer = new PrintWriter(stringWriter); 
-         
-        this.control.expectAndReturn(this.httpResponse.getWriter(),writer);
-        this.httpResponse.setContentType(GDataResponse.XMLMIME_ATOM);
-        this.response.setOutputFormat(OutputFormat.ATOM); 
-        this.control.replay(); 
-         
-        this.response.sendResponse(createFeed(), new ProvidedServiceStub()); 
-        assertEquals("Simple XML representation",stringWriter.toString(),generatedFeedAtom); 
-        this.control.reset(); 
-         
-        stringWriter = new StringWriter(); 
-        writer = new PrintWriter(stringWriter); 
-         
-        this.control.expectAndReturn(this.httpResponse.getWriter(),writer); 
-        this.response.setOutputFormat(OutputFormat.RSS); 
-        this.httpResponse.setContentType(GDataResponse.XMLMIME_RSS);
-        this.control.replay(); 
-         
-        this.response.sendResponse(createFeed(), new ProvidedServiceStub()); 
-        assertEquals("Simple XML representation",stringWriter.toString(),generatedFeedRSS); 
-         
-         
-         
- 
-    } 
- 
-    /* 
-     * Test method for 'org.apache.lucene.gdata.server.GDataResponse.sendResponse(BaseEntry, ExtensionProfile)' 
-     */ 
-    public void testSendResponseBaseEntryExtensionProfile() throws IOException { 
-        try{ 
-            Entry e = null; 
-            this.response.sendResponse(e, new ProvidedServiceStub()); 
-            fail("Exception expected"); 
-        }catch (IllegalArgumentException e) { 
-            // 
-        } 
-        try{ 
-            Entry e = createEntry(); 
-            this.response.sendResponse(e,null); 
-            fail("Exception expected"); 
-        }catch (IllegalArgumentException e) { 
-            // 
-        } 
-//        // test Atom output 
-        StringWriter stringWriter = new StringWriter(); 
-        PrintWriter writer = new PrintWriter(stringWriter); 
-         
-        this.control.expectAndReturn(this.httpResponse.getWriter(),writer); 
-        this.httpResponse.setContentType(GDataResponse.XMLMIME_ATOM);
-        this.response.setOutputFormat(OutputFormat.ATOM); 
-        this.control.replay(); 
-         
-        this.response.sendResponse(createEntry(), new ProvidedServiceStub()); 
-        assertEquals("Simple XML representation ATOM",stringWriter.toString(),generatedEntryAtom); 
-         
-        // test rss output 
-        this.control.reset(); 
-        stringWriter = new StringWriter(); 
-        writer = new PrintWriter(stringWriter); 
-         
-        this.control.expectAndReturn(this.httpResponse.getWriter(),writer); 
-        this.httpResponse.setContentType(GDataResponse.XMLMIME_RSS);
-        this.response.setOutputFormat(OutputFormat.RSS); 
-        this.control.replay(); 
-         
-        this.response.sendResponse(createEntry(), new ProvidedServiceStub()); 
-         
-        assertEquals("Simple XML representation RSS",stringWriter.toString(),generatedEntryRSS); 
-         
-         
-         
-    } 
-     
-    /* create a simple feed */ 
-    private Feed createFeed(){ 
-        Feed feed = new Feed(); 
-         
-        feed.getEntries().add(createEntry()); 
-         
-        return feed; 
-    } 
-    /* create a simple entry */ 
-    private Entry createEntry(){ 
-        Entry e = new Entry(); 
-        e.setTitle(new PlainTextConstruct("Test")); 
-        return e; 
-    } 
- 
-} 
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/server/administration/TestAccountBuilder.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/server/administration/TestAccountBuilder.java
deleted file mode 100644
index 7ed8586..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/server/administration/TestAccountBuilder.java
+++ /dev/null
@@ -1,92 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.server.administration;
-
-import java.io.IOException;
-import java.io.StringReader;
-import java.net.URL;
-
-import junit.framework.TestCase;
-
-import org.apache.lucene.gdata.data.GDataAccount;
-import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
-import org.xml.sax.SAXException;
-
-public class TestAccountBuilder extends TestCase {
-    private StringReader reader;
-    private String inputXML;
-    private StringReader invalidReader;
-    private String invalidInputXML;
-    protected void setUp() throws Exception {
-        this.inputXML = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" +
-                "<account>" +
-                "<account-name>simon</account-name>" +
-                "<password>simon</password>" +
-                "<account-role>6</account-role>" +
-                "<account-owner>" +
-                "<name>simon willnauer</name>" +
-                "<email-address>simon@gmail.com</email-address>" +
-                "<url>http://www.javawithchopsticks.de</url>" +
-                "</account-owner>" +
-                "</account>";
-
-        this.reader = new StringReader(this.inputXML);
-        this.invalidInputXML = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" +
-        "<account>" +
-        "<account-name>simon</account-name>" +
-        "<account-role>6</account-role>" +
-        "<account-owner>" +
-        "<name>simon willnauer</name>" +
-        "<email-address>simon@gmail.com</email-address>" +
-        "<url>http://www.javawithchopsticks.de</url>" +
-        "</account-owner>" +
-        "</account>";
-
-        this.invalidReader = new StringReader(this.invalidInputXML);
-        
-    }
-
-    protected void tearDown() throws Exception {
-        super.tearDown();
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.server.administration.AdminEntityBuilder.buildUser(Reader)'
-     */
-    public void testBuildUser() throws IOException, SAXException {
-        
-        GDataAccount user = AccountBuilder.buildAccount(this.reader);
-        assertEquals("simon",user.getName());
-        assertEquals("simon willnauer",user.getAuthorname());
-        assertEquals("simon@gmail.com",user.getAuthorMail());
-        assertEquals("simon",user.getPassword());
-        assertEquals(new URL("http://www.javawithchopsticks.de"),user.getAuthorLink());
-        assertTrue(user.isUserInRole(AccountRole.ENTRYAMINISTRATOR));
-        assertTrue(user.isUserInRole(AccountRole.FEEDAMINISTRATOR));
-        assertFalse(user.isUserInRole(AccountRole.USERADMINISTRATOR));
-        
-    }
-    
-    public void testBuildUserWrongXML() throws IOException{
-        try{
-        AccountBuilder.buildAccount(this.invalidReader);
-        fail("invalid xml");
-        }catch (SAXException e) {
-            
-        }
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/server/authentication/TestBlowfishAuthenticationController.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/server/authentication/TestBlowfishAuthenticationController.java
deleted file mode 100644
index 12c7a8d..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/server/authentication/TestBlowfishAuthenticationController.java
+++ /dev/null
@@ -1,95 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.server.authentication;
-
-import java.io.IOException;
-import java.io.UnsupportedEncodingException;
-
-import javax.crypto.BadPaddingException;
-import javax.crypto.IllegalBlockSizeException;
-
-import org.apache.lucene.gdata.data.GDataAccount;
-import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
-
-import junit.framework.TestCase;
-
-/**
- * @author Simon Willnauer
- *
- */
-public class TestBlowfishAuthenticationController extends TestCase {
-    private BlowfishAuthenticationController controller;
-    private String key = "myKey";
-    private String accountName = "simon";
-    
-    private String clientIp = "192.168.0.127";
-    protected void setUp() throws Exception {
-        this.controller = new BlowfishAuthenticationController();
-        this.controller.setKey(this.key);
-        
-        this.controller.initialize();
-    }
-
-    protected void tearDown() throws Exception {
-        super.tearDown();
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.server.authentication.AuthenticationController.authenticatAccount(HttpServletRequest)'
-     */
-    public void testAuthenticatAccount() throws IllegalBlockSizeException, BadPaddingException, AuthenticationException, IOException {
-        GDataAccount account = new GDataAccount();
-        account.setName(accountName);
-        account.setPassword("testme");
-        account.setRole(AccountRole.ENTRYAMINISTRATOR);
-        
-        String token = this.controller.authenticatAccount(account,this.clientIp);
-        String notSame = this.controller.calculateAuthToken("192.168.0",Integer.toString(account.getRolesAsInt()),this.accountName);
-        assertNotSame(notSame,token);
-        String authString = "192.168.0#"+this.accountName +"#"+account.getRolesAsInt()+"#";
-        assertTrue(this.controller.deCryptAuthToken(token).startsWith(authString));
-        assertTrue(this.controller.deCryptAuthToken(notSame).startsWith(authString));
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.server.authentication.AuthenticationController.authenticateToken(String)'
-     */
-    public void testAuthenticateToken() throws IllegalBlockSizeException, BadPaddingException, UnsupportedEncodingException, AuthenticationException {
-        GDataAccount account = new GDataAccount();
-        account.setName("simon");
-        account.setPassword("testme");
-        account.setRole(AccountRole.ENTRYAMINISTRATOR);
-        String token = this.controller.calculateAuthToken("192.168.0",Integer.toString(account.getRolesAsInt()),this.accountName);
-        
-        assertTrue(this.controller.authenticateToken(token,this.clientIp,AccountRole.ENTRYAMINISTRATOR,this.accountName));
-        assertTrue(this.controller.authenticateToken(token,this.clientIp,AccountRole.USER,this.accountName));
-        assertFalse(this.controller.authenticateToken(token,this.clientIp,AccountRole.USERADMINISTRATOR,"someOtherAccount"));
-        try{
-        this.controller.authenticateToken(token+"test",this.clientIp,AccountRole.ENTRYAMINISTRATOR,this.accountName);
-        fail("exception expected");
-        }catch (Exception e) {
-            // TODO: handle exception
-        }
-        this.controller.setLoginTimeout(0);
-        assertFalse(this.controller.authenticateToken(token,this.clientIp,AccountRole.ENTRYAMINISTRATOR,this.accountName));
-        
-    }
-
-    
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/server/registry/TestEntityBuilderIncomingEntry.xml b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/server/registry/TestEntityBuilderIncomingEntry.xml
deleted file mode 100644
index 35e4817..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/server/registry/TestEntityBuilderIncomingEntry.xml
+++ /dev/null
@@ -1,21 +0,0 @@
-<?xml version='1.0' encoding='UTF-8'?> 
-<entry xmlns='http://www.w3.org/2005/Atom'> 
-    <id> 
-        http://www.google.com/calendar/feeds/simon.willnauer%40googlemail.com/public/basic/af4b5ca305c80f96f42c9af66c5b04a8473c949c 
-    </id> 
-    <published>2006-12-23T00:00:00.000Z</published> 
-    <updated>2006-05-23T16:42:48.000Z</updated> 
-    <category scheme='http://schemas.google.com/g/2005#kind' 
-        term='http://schemas.google.com/g/2005#event'> 
-    </category> 
-    <summary type='html'> 
-        When: 2006-12-23 to 2006-12-31 America/Los_Angeles&lt;br> 
-    </summary> 
-    <link rel='alternate' type='text/html' 
-        href='http://www.google.com/calendar/event?eid=YWY0YjVjYTMwNWM4MGY5NmY0MmM5YWY2NmM1YjA0YTg0NzNjOTQ5YyBzaW1vbi53aWxsbmF1ZXJAZ29vZ2xlbWFpbC5jb20' 
-        title='alternate'> 
-    </link> 
-    <link rel='self' type='application/atom+xml' 
-        href='http://www.google.com/calendar/feeds/simon.willnauer%40googlemail.com/public/basic/af4b5ca305c80f96f42c9af66c5b04a8473c949c'> 
-    </link> 
-</entry> 
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/server/registry/TestEntityBuilderIncomingFeed.xml b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/server/registry/TestEntityBuilderIncomingFeed.xml
deleted file mode 100644
index 47f7978..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/server/registry/TestEntityBuilderIncomingFeed.xml
+++ /dev/null
@@ -1,90 +0,0 @@
-<?xml version='1.0' encoding='UTF-8'?> 
-<feed xmlns='http://www.w3.org/2005/Atom' 
-    xmlns:openSearch='http://a9.com/-/spec/opensearchrss/1.0/' 
-    xmlns:gd='http://schemas.google.com/g/2005'> 
-    <id> 
-        http://www.google.com/calendar/feeds/simon.willnauer%40googlemail.com/public/basic 
-    </id> 
-    <updated>2006-05-27T11:47:55.000Z</updated> 
-    <title type='text'>Simon Willnauer</title> 
-    <subtitle type='text'>Simon Willnauer</subtitle> 
-    <link rel='http://schemas.google.com/g/2005#feed' 
-        type='application/atom+xml' 
-        href='http://www.google.com/calendar/feeds/simon.willnauer%40googlemail.com/public/basic'> 
-    </link> 
-    <link rel='self' type='application/atom+xml' 
-        href='http://www.google.com/calendar/feeds/simon.willnauer%40googlemail.com/public/basic?max-results=25'> 
-    </link> 
-    <link rel='next' type='application/atom+xml' 
-        href='http://www.google.com/calendar/feeds/simon.willnauer%40googlemail.com/public/basic?start-index=26&amp;max-results=25'> 
-    </link> 
-    <author> 
-        <name>Simon Willnauer</name> 
-        <email>simon.willnauer@googlemail.com</email> 
-    </author> 
-    <generator version='1.0' uri='http://www.google.com/calendar'> 
-        Google Calendar 
-    </generator> 
-    <openSearch:itemsPerPage>25</openSearch:itemsPerPage> 
-    <entry> 
-        <id> 
-            http://www.google.com/calendar/feeds/simon.willnauer%40googlemail.com/public/basic/af4b5ca305c80f96f42c9af66c5b04a8473c949c 
-        </id> 
-        <published>2006-12-23T00:00:00.000Z</published> 
-        <updated>2006-05-23T16:42:48.000Z</updated> 
-        <category scheme='http://schemas.google.com/g/2005#kind' 
-            term='http://schemas.google.com/g/2005#event'> 
-        </category> 
-        <summary type='html'> 
-            When: 2006-12-23 to 2006-12-31 America/Los_Angeles&lt;br> 
-        </summary> 
-        <link rel='alternate' type='text/html' 
-            href='http://www.google.com/calendar/event?eid=YWY0YjVjYTMwNWM4MGY5NmY0MmM5YWY2NmM1YjA0YTg0NzNjOTQ5YyBzaW1vbi53aWxsbmF1ZXJAZ29vZ2xlbWFpbC5jb20' 
-            title='alternate'> 
-        </link> 
-        <link rel='self' type='application/atom+xml' 
-            href='http://www.google.com/calendar/feeds/simon.willnauer%40googlemail.com/public/basic/af4b5ca305c80f96f42c9af66c5b04a8473c949c'> 
-        </link> 
-    </entry> 
-    <entry> 
-        <id> 
-            http://www.google.com/calendar/feeds/simon.willnauer%40googlemail.com/public/basic/d5402951792ce690f6a45e51143deb78f4fffac4 
-        </id> 
-        <published>2006-05-26T00:00:00.000Z</published> 
-        <updated>2006-05-20T22:17:44.000Z</updated> 
-        <category scheme='http://schemas.google.com/g/2005#kind' 
-            term='http://schemas.google.com/g/2005#event'> 
-        </category> 
-        <summary type='html'> 
-            When: 2006-05-26 to 2006-05-27 America/Los_Angeles&lt;br> 
-        </summary> 
-        <link rel='alternate' type='text/html' 
-            href='http://www.google.com/calendar/event?eid=ZDU0MDI5NTE3OTJjZTY5MGY2YTQ1ZTUxMTQzZGViNzhmNGZmZmFjNCBzaW1vbi53aWxsbmF1ZXJAZ29vZ2xlbWFpbC5jb20' 
-            title='alternate'> 
-        </link> 
-        <link rel='self' type='application/atom+xml' 
-            href='http://www.google.com/calendar/feeds/simon.willnauer%40googlemail.com/public/basic/d5402951792ce690f6a45e51143deb78f4fffac4'> 
-        </link> 
-    </entry> 
-    <entry> 
-        <id> 
-            http://www.google.com/calendar/feeds/simon.willnauer%40googlemail.com/public/basic/21630e853795ea81d5e792d0ab082ad1c44256e4 
-        </id> 
-        <published>2006-06-19T14:00:00.000Z</published> 
-        <updated>2006-05-17T16:10:57.000Z</updated> 
-        <category scheme='http://schemas.google.com/g/2005#kind' 
-            term='http://schemas.google.com/g/2005#event'> 
-        </category> 
-        <summary type='html'> 
-            When: 2006-06-19 07:00:00 to 08:00:00 
-            America/Los_Angeles&lt;br> 
-        </summary> 
-        <link rel='alternate' type='text/html' 
-            href='http://www.google.com/calendar/event?eid=MjE2MzBlODUzNzk1ZWE4MWQ1ZTc5MmQwYWIwODJhZDFjNDQyNTZlNCBzaW1vbi53aWxsbmF1ZXJAZ29vZ2xlbWFpbC5jb20' 
-            title='alternate'> 
-        </link> 
-        <link rel='self' type='application/atom+xml' 
-            href='http://www.google.com/calendar/feeds/simon.willnauer%40googlemail.com/public/basic/21630e853795ea81d5e792d0ab082ad1c44256e4'> 
-        </link> 
-    </entry> 
-</feed> 
\ No newline at end of file
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/server/registry/TestFeedRegistry.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/server/registry/TestFeedRegistry.java
deleted file mode 100644
index 147b743..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/server/registry/TestFeedRegistry.java
+++ /dev/null
@@ -1,154 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.server.registry;
-
-import junit.framework.TestCase;
-
-import org.apache.lucene.gdata.server.ServiceFactory;
-import org.apache.lucene.gdata.servlet.handler.DefaultRequestHandlerFactory;
-import org.apache.lucene.gdata.servlet.handler.RequestHandlerFactory;
-import org.apache.lucene.gdata.storage.StorageController;
-import org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController;
-
-import com.google.gdata.data.Entry;
-import com.google.gdata.data.ExtensionProfile;
-import com.google.gdata.data.Feed;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class TestFeedRegistry extends TestCase {
-    private GDataServerRegistry reg;
-
-    private ProvidedServiceConfig configurator;
-
-    @Override
-    protected void setUp() {
-        this.reg = GDataServerRegistry.getRegistry();
-        this.configurator = new ProvidedServiceConfig();
-        this.configurator.setEntryType(Entry.class);
-        this.configurator.setFeedType(Feed.class);
-        this.configurator.setExtensionProfile(new ExtensionProfile());
-    }
-
-    /**
-     * @see junit.framework.TestCase#tearDown()
-     */
-    @Override
-    protected void tearDown() throws Exception {
-        this.reg.flushRegistry();
-
-    }
-
-    /**
-     * Test method for
-     * 'org.apache.lucene.gdata.server.registry.FeedRegistry.getRegistry()'
-     */
-    public void testGetRegistry() {
-
-        GDataServerRegistry reg1 = GDataServerRegistry.getRegistry();
-        assertEquals("test singleton", this.reg, reg1);
-    }
-
-    /**
-     * Test method for
-     * 'org.apache.lucene.gdata.server.registry.FeedRegistry.registerFeed(FeedInstanceConfigurator)'
-     */
-    public void testRegisterService() {
-        String service = "service";
-        registerService(service);
-        assertEquals("Registered Configurator", this.configurator, this.reg
-                .getProvidedService(service));
-        assertNull("not registered Configurator", this.reg
-                .getProvidedService("something"));
-        try {
-            this.reg.getProvidedService(null);
-            fail("Exception expected");
-        } catch (IllegalArgumentException e) {
-            //
-        }
-    }
-
-    /**
-     * Test method for
-     * 'org.apache.lucene.gdata.server.registry.FeedRegistry.getFeedConfigurator(String)'
-     */
-    public void testFlushRegistry() {
-        String service = "service";
-        registerService(service);
-
-        assertEquals("Registered Configurator", this.configurator, this.reg
-                .getProvidedService(service));
-        this.reg.flushRegistry();
-        assertNull("Registry flushed", this.reg.getProvidedService(service));
-
-    }
-
-    /**
-     * 
-     */
-    public void testIsFeedRegistered() {
-        String service = "service";
-        registerService(service);
-        assertTrue("Feed is registerd", this.reg.isServiceRegistered(service));
-        assertFalse("null Feed is not registerd", this.reg
-                .isServiceRegistered(null));
-        assertFalse("Feed is not registerd", this.reg
-                .isServiceRegistered("something"));
-
-    }
-
-    private void registerService(String servicename) {
-
-        this.configurator.setName(servicename);
-        this.reg.registerService(this.configurator);
-    }
-
-    public void testRegisterComponent() throws RegistryException {
-        try {
-            this.reg.registerComponent(StorageController.class, null);
-            fail("RegistryException expected");
-        } catch (RegistryException e) {
-            //
-        }
-        new GDataRequestListener();
-        try {
-            this.reg.registerComponent(StorageCoreController.class, null);
-            fail("no config");
-        } catch (Exception e) {
-            // TODO: handle exception
-        }
-        this.reg.registerComponent(DefaultRequestHandlerFactory.class, null);
-        RequestHandlerFactory factory = this.reg.lookup(
-                RequestHandlerFactory.class,
-                ComponentType.REQUESTHANDLERFACTORY);
-        try {
-            this.reg
-                    .registerComponent(DefaultRequestHandlerFactory.class, null);
-            fail("RegistryException expected");
-        } catch (RegistryException e) {
-            //
-        }
-        this.reg.registerComponent(ServiceFactory.class, null);
-        ServiceFactory servicefactory = this.reg.lookup(ServiceFactory.class,
-                ComponentType.SERVICEFACTORY);
-        assertNotNull(servicefactory);
-        assertNotNull(factory);
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/server/registry/TestGDataEntityBuilder.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/server/registry/TestGDataEntityBuilder.java
deleted file mode 100644
index 4556b59..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/server/registry/TestGDataEntityBuilder.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */ 
-package org.apache.lucene.gdata.server.registry; 
- 
-import java.io.File;
-import java.io.FileReader;
-import java.io.IOException;
-import java.io.Reader;
-
-import junit.framework.TestCase;
-
-import org.apache.lucene.gdata.data.ServerBaseEntry;
-import org.apache.lucene.gdata.data.ServerBaseFeed;
-import org.apache.lucene.gdata.server.GDataEntityBuilder;
-
-import com.google.gdata.data.BaseEntry;
-import com.google.gdata.data.BaseFeed;
-import com.google.gdata.data.Entry;
-import com.google.gdata.data.ExtensionProfile;
-import com.google.gdata.data.Feed;
-import com.google.gdata.data.Source;
-import com.google.gdata.util.ParseException;
- 
-/** 
- * @author Simon Willnauer 
- * 
- */ 
-public class TestGDataEntityBuilder extends TestCase { 
-    private static File incomingFeed = new File("src/test/org/apache/lucene/gdata/server/registry/TestEntityBuilderIncomingFeed.xml"); 
-    private static File incomingEntry = new File("src/test/org/apache/lucene/gdata/server/registry/TestEntityBuilderIncomingEntry.xml"); 
-    private static String feedTitleFromXML = "Simon Willnauer"; 
-    private static String entrySummaryFromXML = "When: 2006-12-23 to 2006-12-31 America/Los_Angeles"; 
-    private static GDataServerRegistry reg = GDataServerRegistry.getRegistry(); 
-    private Reader reader;  
-    private static String feedID = "myFeed"; 
-    private ProvidedServiceConfig config;
-    private static Class feedType = Feed.class; 
-    private static Class entryType = Entry.class;
-     
-     
-    /** 
-     * @see junit.framework.TestCase#setUp() 
-     */ 
-    @Override 
-    protected void setUp() throws Exception { 
-        this.config = new ProvidedServiceConfig(); 
-        
-        this.config.setFeedType(feedType); 
-        this.config.setEntryType(entryType);
-        this.config.setExtensionProfile(new ExtensionProfile()); 
-        reg.registerService(this.config); 
-    } 
- 
-    /** 
-     * @see junit.framework.TestCase#tearDown() 
-     */ 
-    @Override 
-    protected void tearDown() throws Exception { 
-        reg.flushRegistry(); 
-        this.reader = null; 
-    } 
- 
-    /** 
-     * Test method for 'org.apache.lucene.gdata.data.GDataEntityBuilder.buildFeed(String, Reader)' 
-     */ 
-    public void testBuildFeedStringReader() throws  ParseException, IOException { 
-        this.reader = new FileReader(incomingFeed); 
-        BaseFeed feed = GDataEntityBuilder.buildFeed(this.reader,this.config); 
-        assertNotNull(feed); 
-        assertEquals("feed title",feed.getTitle().getPlainText(), feedTitleFromXML);
-        
-       
-         
-    } 
- 
-    /**
-     * Test method for 'org.apache.lucene.gdata.data.GDataEntityBuilder.buildEntry(String, Reader)' 
-     */ 
-    public void testBuildEntryStringReader() throws  ParseException, IOException { 
-        this.reader = new FileReader(incomingEntry); 
-        BaseEntry entry = GDataEntityBuilder.buildEntry(this.reader,this.config); 
-        assertNotNull(entry); 
-        assertEquals("entry summary",entry.getSummary().getPlainText(),entrySummaryFromXML); 
-        
-        
-
-         
-    } 
-     
-     
- 
-} 
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/server/registry/TestProvidedServiceConfig.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/server/registry/TestProvidedServiceConfig.java
deleted file mode 100755
index cc8402a..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/server/registry/TestProvidedServiceConfig.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.server.registry;
-
-import junit.framework.TestCase;
-
-import com.google.gdata.data.Entry;
-import com.google.gdata.data.ExtensionProfile;
-import com.google.gdata.data.Feed;
-
-public class TestProvidedServiceConfig extends TestCase {
-    ProvidedServiceConfig instance;
-    protected void setUp() throws Exception {
-        instance = new ProvidedServiceConfig();
-        instance.setExtensionProfileClass(ExtensionProfile.class);
-        instance.setFeedType(Feed.class);
-        instance.setEntryType(Entry.class);
-    }
-
-    protected void tearDown() throws Exception {
-        super.tearDown();
-        instance.destroy();
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.server.registry.ProvidedServiceConfig.getExtensionProfile()'
-     */
-    public void testGetExtensionProfile() {
-        try{
-        this.instance.setExtensionProfile(null);
-        fail("value must not be null");
-        }catch (IllegalArgumentException e) {
-
-        }
-        ExtensionProfile profile = this.instance.getExtensionProfile();
-        assertNotNull(profile);
-        assertSame(profile,this.instance.getExtensionProfile());
-        this.instance.visiteInitialize();
-        assertSame(profile,this.instance.getExtensionProfile());
-        assertNull(new ProvidedServiceConfig().getExtensionProfile());
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.server.registry.ProvidedServiceConfig.setExtensionProfile(ExtensionProfile)'
-     */
-    public void testSetPoolSize() throws InstantiationException, IllegalAccessException {
-        assertEquals(5,instance.getPoolSize());
-        instance.destroy();
-        instance = new ProvidedServiceConfig();
-        instance.setExtensionProfileClass(ExtensionProfile.class);
-        instance.setFeedType(Feed.class);
-        instance.setEntryType(Entry.class);
-        instance.setPoolSize(30);
-        instance.visiteInitialize();
-        assertEquals(30,instance.getPoolSize());
-        instance.destroy();
-        instance = new ProvidedServiceConfig();
-        instance.setExtensionProfileClass(ExtensionProfile.class);
-        instance.setFeedType(Feed.class);
-        instance.setEntryType(Entry.class);
-        instance.setPoolSize(-5);
-        instance.visiteInitialize();
-        assertEquals(5,instance.getPoolSize());
-    }
-
-   
-   
-   
-    /*
-     * Test method for 'org.apache.lucene.gdata.server.registry.ProvidedServiceConfig.visiteInitialize()'
-     */
-    public void testVisiteInitialize() {
-        instance.visiteInitialize();
-        assertNull(instance.extProfThreadLocal.get());
-        instance.getExtensionProfile();
-        assertNotNull(instance.extProfThreadLocal.get());
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.server.registry.ProvidedServiceConfig.visiteDestroy()'
-     */
-    public void testVisiteDestroy() {
-        ExtensionProfile profile = this.instance.getExtensionProfile();
-        assertNotNull(profile);
-        assertNotNull(instance.extProfThreadLocal.get());
-        instance.visiteDestroy();
-        assertNull(instance.extProfThreadLocal.get());
-        instance.visiteDestroy();
-        assertNull(instance.extProfThreadLocal.get());
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/server/registry/configuration/TestConfigurationBean.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/server/registry/configuration/TestConfigurationBean.java
deleted file mode 100755
index f66d2a9..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/server/registry/configuration/TestConfigurationBean.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.server.registry.configuration;
-
-import junit.framework.TestCase;
-
-public class TestConfigurationBean extends TestCase {
-    private ComponentConfiguration bean;
-
-    protected void setUp() throws Exception {
-        super.setUp();
-        this.bean = new ComponentConfiguration();
-
-    }
-
-    protected void tearDown() throws Exception {
-        super.tearDown();
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.server.registry.configuration.ConfigurationBean.set(String,
-     * String)'
-     */
-    public void testSet() {
-        this.bean.set("field", "value");
-        try {
-            this.bean.set("field", "value");
-            fail("field already set");
-        } catch (IllegalArgumentException e) {
-            //
-        }
-        assertEquals("value", this.bean.get("field"));
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.server.registry.configuration.ConfigurationBean.get(String)'
-     */
-    public void testGet() {
-        assertNull(this.bean.get("field"));
-        this.bean.set("field", "value");
-        assertEquals("value", this.bean.get("field"));
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/server/registry/configuration/TestPropertyInjector.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/server/registry/configuration/TestPropertyInjector.java
deleted file mode 100755
index 54b706a..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/server/registry/configuration/TestPropertyInjector.java
+++ /dev/null
@@ -1,192 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.server.registry.configuration;
-
-import junit.framework.TestCase;
-
-public class TestPropertyInjector extends TestCase {
-    private PropertyInjector injector;
-
-    protected void setUp() throws Exception {
-        super.setUp();
-        this.injector = new PropertyInjector();
-    }
-
-    protected void tearDown() throws Exception {
-        super.tearDown();
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.server.registry.configuration.PropertyInjector.setTargetObject(Object)'
-     */
-    public void testSetTargetObject() {
-        try {
-            this.injector.setTargetObject(null);
-            fail("must not be null");
-        } catch (IllegalArgumentException e) {
-            // TODO: handle exception
-        }
-        try {
-            this.injector.setTargetObject(new Object());
-            fail("no getter or setter methodes");
-        } catch (InjectionException e) {
-            // TODO: handle exception
-        }
-      
-       this.injector.setTargetObject(new TestBean());
-       assertEquals(1,this.injector.getOptionalSize());
-       assertEquals(1,this.injector.getRequiredSize());
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.server.registry.configuration.PropertyInjector.injectProperties(ConfigurationBean)'
-     */
-    public void testInjectProperties() throws Exception {
-        ComponentConfiguration bean = new ComponentConfiguration();
-        bean.set("someValue","bla");
-        try{
-            this.injector.injectProperties(bean);
-            fail("target is not set");
-            }catch (IllegalStateException e) {
-          
-            }
-        TestBean testBean = new TestBean();
-        this.injector.setTargetObject(testBean);
-        try{
-            this.injector.injectProperties(null);
-            fail("object is null");
-            }catch (IllegalArgumentException e) {
-          
-            }
-        try{
-        this.injector.injectProperties(bean);
-        fail("requiered Property is not available in config bean");
-        }catch (InjectionException e) {
-          
-        }
-        
-        bean.set("test","fooBar");
-        bean.set("testClass","java.lang.Object");
-        this.injector.injectProperties(bean);
-        
-        assertEquals("fooBar",testBean.getTest());
-        assertEquals(Object.class,testBean.getTestClass());
-        
-        
-        
-        this.injector = new PropertyInjector();
-        SubTestBean subTestBean = new SubTestBean();
-        this.injector.setTargetObject(subTestBean);
-        bean.set("number","333");
-        this.injector.injectProperties(bean);
-        
-        assertEquals("fooBar",subTestBean.getTest());
-        assertEquals(Object.class,subTestBean.getTestClass());
-        assertEquals(333,subTestBean.getNumber());
-        
-        bean = new ComponentConfiguration();
-        bean.set("test","fooBar");
-        bean.set("number","333");
-        bean.set("wrapper","1.2");
-       
-        subTestBean = new SubTestBean();
-        this.injector.setTargetObject(subTestBean);
-        this.injector.injectProperties(bean);
-        
-        assertEquals("fooBar",subTestBean.getTest());
-        assertEquals(333,subTestBean.getNumber());
-        assertEquals(new Float(1.2),subTestBean.getWrapper());
-    
-
-    }
-    
-    
-   public static class TestBean{
-       
-        private String test;
-        private Class testClass;
-        /**
-         * @return Returns the test.
-         */
-        public String getTest() {
-            return test;
-        }
-        /**
-         * @param test The test to set.
-         */
-        @Requiered
-        public void setTest(String test) {
-            this.test = test;
-        }
-        /**
-         * @return Returns the testClass.
-         */
-        public Class getTestClass() {
-            return testClass;
-        }
-        /**
-         * @param testClass The testClass to set.
-         */
-        public void setTestClass(Class testClass) {
-            this.testClass = testClass;
-        }
-        
-        
-    }
-   public static class SubTestBean extends TestBean{
-      private int number;
-      private Float wrapper;
-
-    /**
-     * @return Returns the wrapper.
-     */
-    public Float getWrapper() {
-        return wrapper;
-    }
-
-    /**
-     * @param wrapper The wrapper to set.
-     */
-    public void setWrapper(Float wrapper) {
-        this.wrapper = wrapper;
-    }
-
-    /**
-     * @return Returns the number.
-     */
-    
-    public int getNumber() {
-        return number;
-    }
-
-    /**
-     * @param number The number to set.
-     */
-    @Requiered
-    public void setNumber(int number) {
-        this.number = number;
-    }
-       
-       
-       
-       
-   }
-    
-
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/servlet/TestAbstractGdataServlet.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/servlet/TestAbstractGdataServlet.java
deleted file mode 100644
index 3a19426..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/servlet/TestAbstractGdataServlet.java
+++ /dev/null
@@ -1,297 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.servlet; 
- 
-import java.io.IOException; 
- 
-import javax.servlet.ServletException; 
-import javax.servlet.http.HttpServletRequest; 
-import javax.servlet.http.HttpServletResponse; 
- 
-import org.easymock.MockControl; 
- 
-import junit.framework.TestCase; 
- 
-/** 
- * @author Simon Willnauer 
- * 
- */ 
-public class TestAbstractGdataServlet extends TestCase { 
-    private static final String METHOD_DELETE = "DELETE"; 
- 
-    private static final String METHOD_GET = "GET"; 
- 
-    private static final String METHOD_POST = "POST"; 
- 
-    private static final String METHOD_PUT = "PUT"; 
- 
-    private static final String METHOD_HEADER_NAME = "x-http-method-override"; 
- 
-    private HttpServletRequest mockRequest = null; 
- 
-    private HttpServletResponse mockResponse = null; 
- 
-    private AbstractGdataServlet servletInstance = null; 
- 
-    private MockControl requestMockControl; 
- 
-    private MockControl responseMockControl; 
- 
-    protected void setUp() throws Exception { 
-        this.requestMockControl = MockControl 
-                .createControl(HttpServletRequest.class); 
-        this.responseMockControl = MockControl 
-                .createControl(HttpServletResponse.class); 
-        this.mockRequest = (HttpServletRequest) this.requestMockControl 
-                .getMock(); 
-        this.mockResponse = (HttpServletResponse) this.responseMockControl 
-                .getMock(); 
-        this.servletInstance = new StubGDataServlet(); 
-    } 
- 
-    /** 
-     * Test method for 
-     * 'org.apache.lucene.gdata.servlet.AbstractGdataServlet.service(HttpServletRequest, 
-     * HttpServletResponse)' 
-     */ 
-    public void testServiceHttpServletRequestHttpServletResponseDelete() { 
-        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
-                .getMethod(), METHOD_DELETE); 
-        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
-                .getHeader(METHOD_HEADER_NAME), METHOD_DELETE); 
-        this.requestMockControl.replay(); 
- 
-        try { 
-            this.servletInstance.service(this.mockRequest, this.mockResponse); 
-        } catch (ServletException e) { 
-            fail("ServeltExpception not expected"); 
-        } catch (IOException e) { 
-            fail("IOExpception not expected"); 
-        } 
- 
-        this.requestMockControl.verify(); 
-        this.requestMockControl.reset(); 
- 
-        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
-                .getMethod(), METHOD_POST); 
-        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
-                .getHeader(METHOD_HEADER_NAME), METHOD_DELETE); 
-        this.requestMockControl.replay(); 
- 
-        try { 
-            this.servletInstance.service(this.mockRequest, this.mockResponse); 
-        } catch (ServletException e) { 
-            fail("ServeltExpception not expected"); 
-        } catch (IOException e) { 
-            fail("IOExpception not expected"); 
-        } 
- 
-        this.requestMockControl.verify(); 
-    } 
- 
-    /** 
-     *  
-     */ 
-    public void testServiceNullOverrideHeader() { 
-        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
-                .getMethod(), METHOD_POST); 
-        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
-                .getHeader(METHOD_HEADER_NAME), null); 
-        this.requestMockControl.replay(); 
- 
-        try { 
-            this.servletInstance.service(this.mockRequest, this.mockResponse); 
-        } catch (ServletException e) { 
-            fail("ServeltExpception not expected"); 
-        } catch (IOException e) { 
-            fail("IOExpception not expected"); 
-        } 
- 
-        this.requestMockControl.verify(); 
-        this.requestMockControl.reset(); 
-    } 
- 
-    /** 
-     * Test method for 
-     * 'org.apache.lucene.gdata.servlet.AbstractGdataServlet.service(HttpServletRequest, 
-     * HttpServletResponse)' 
-     */ 
-    public void testServiceHttpServletRequestHttpServletResponsePOST() { 
-        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
-                .getMethod(), METHOD_POST); 
-        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
-                .getHeader(METHOD_HEADER_NAME), METHOD_POST); 
-        this.requestMockControl.replay(); 
- 
-        try { 
-            this.servletInstance.service(this.mockRequest, this.mockResponse); 
-        } catch (ServletException e) { 
-            fail("ServeltExpception not expected"); 
-        } catch (IOException e) { 
-            fail("IOExpception not expected"); 
-        } 
- 
-        this.requestMockControl.verify(); 
-        this.requestMockControl.reset(); 
- 
-        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
-                .getMethod(), METHOD_PUT); 
-        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
-                .getHeader(METHOD_HEADER_NAME), METHOD_POST); 
-        this.requestMockControl.replay(); 
- 
-        try { 
-            this.servletInstance.service(this.mockRequest, this.mockResponse); 
-        } catch (ServletException e) { 
-            fail("ServeltExpception not expected"); 
-        } catch (IOException e) { 
-            fail("IOExpception not expected"); 
-        } 
- 
-        this.requestMockControl.verify(); 
-    } 
- 
-    /** 
-     * Test method for 
-     * 'org.apache.lucene.gdata.servlet.AbstractGdataServlet.service(HttpServletRequest, 
-     * HttpServletResponse)' 
-     */ 
-    public void testServiceHttpServletRequestHttpServletResponsePUT() { 
-        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
-                .getMethod(), METHOD_PUT); 
-        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
-                .getHeader(METHOD_HEADER_NAME), METHOD_PUT); 
-        this.requestMockControl.replay(); 
- 
-        try { 
-            this.servletInstance.service(this.mockRequest, this.mockResponse); 
-        } catch (ServletException e) { 
-            fail("ServeltExpception not expected"); 
-        } catch (IOException e) { 
-            fail("IOExpception not expected"); 
-        } 
- 
-        this.requestMockControl.verify(); 
-        this.requestMockControl.reset(); 
- 
-        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
-                .getMethod(), METHOD_POST); 
-        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
-                .getHeader(METHOD_HEADER_NAME), METHOD_PUT); 
-        this.requestMockControl.replay(); 
- 
-        try { 
-            this.servletInstance.service(this.mockRequest, this.mockResponse); 
-        } catch (ServletException e) { 
-            fail("ServeltExpception not expected"); 
-        } catch (IOException e) { 
-            fail("IOExpception not expected"); 
-        } 
- 
-        this.requestMockControl.verify(); 
-    } 
- 
-    /** 
-     * Test method for 
-     * 'org.apache.lucene.gdata.servlet.AbstractGdataServlet.service(HttpServletRequest, 
-     * HttpServletResponse)' 
-     */ 
-    public void testServiceHttpServletRequestHttpServletResponseGET() { 
-        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
-                .getMethod(), METHOD_GET); 
-        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
-                .getHeader(METHOD_HEADER_NAME), METHOD_GET); 
-        this.requestMockControl.replay(); 
- 
-        try { 
-            this.servletInstance.service(this.mockRequest, this.mockResponse); 
-        } catch (ServletException e) { 
-            fail("ServeltExpception not expected"); 
-        } catch (IOException e) { 
-            fail("IOExpception not expected"); 
-        } 
- 
-        this.requestMockControl.verify(); 
-        this.requestMockControl.reset(); 
- 
-        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
-                .getMethod(), METHOD_POST); 
-        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
-                .getHeader(METHOD_HEADER_NAME), METHOD_GET); 
-        this.requestMockControl.replay(); 
- 
-        try { 
-            this.servletInstance.service(this.mockRequest, this.mockResponse); 
-        } catch (ServletException e) { 
-            fail("ServeltExpception not expected"); 
-        } catch (IOException e) { 
-            fail("IOExpception not expected"); 
-        } 
- 
-        this.requestMockControl.verify(); 
- 
-    } 
-    /** 
-     * Stub Implementation for <code>AbstractGdataServlet</code> 
-     * @author Simon Willnauer 
-     * 
-     */ 
-    static class StubGDataServlet extends AbstractGdataServlet { 
- 
-        private static final long serialVersionUID = -6271464588547620925L; 
- 
-        protected void doDelete(HttpServletRequest arg0, 
-                HttpServletResponse arg1) { 
-            if (arg0.getHeader(METHOD_HEADER_NAME) == null) 
-                assertEquals("Http-Method --DELETE--", METHOD_DELETE, arg0 
-                        .getMethod()); 
-            else 
-                assertEquals("Http-Method override --DELETE--", METHOD_DELETE, 
-                        arg0.getHeader(METHOD_HEADER_NAME)); 
- 
-        } 
- 
-        protected void doGet(HttpServletRequest arg0, HttpServletResponse arg1) { 
-            if (arg0.getHeader(METHOD_HEADER_NAME) == null) 
-                assertEquals("Http-Method --GET--", arg0.getMethod(), 
-                        METHOD_GET); 
-            else 
-                assertEquals("Http-Method override --GET--", arg0 
-                        .getHeader(METHOD_HEADER_NAME), METHOD_GET); 
-        } 
- 
-        protected void doPost(HttpServletRequest arg0, HttpServletResponse arg1) { 
-            if (arg0.getHeader(METHOD_HEADER_NAME) == null) 
-                assertEquals("Http-Method --POST--", arg0.getMethod(), 
-                        METHOD_POST); 
-            else 
-                assertEquals("Http-Method override --POST--", METHOD_POST, arg0 
-                        .getHeader(METHOD_HEADER_NAME)); 
- 
-        } 
- 
-        protected void doPut(HttpServletRequest arg0, HttpServletResponse arg1) { 
-            if (arg0.getHeader(METHOD_HEADER_NAME) == null) 
-                assertEquals("Http-Method --PUT--", arg0.getMethod(), 
-                        METHOD_PUT); 
-            else 
-                assertEquals("Http-Method override --PUT--", arg0 
-                        .getHeader(METHOD_HEADER_NAME), METHOD_PUT); 
-        } 
- 
-    } 
- 
-} 
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/servlet/handler/TestAbstractFeedHandler.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/servlet/handler/TestAbstractFeedHandler.java
deleted file mode 100644
index c3cd391..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/servlet/handler/TestAbstractFeedHandler.java
+++ /dev/null
@@ -1,215 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.servlet.handler;
-
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.FileReader;
-import java.io.IOException;
-
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import junit.framework.TestCase;
-
-import org.apache.lucene.gdata.data.GDataAccount;
-import org.apache.lucene.gdata.data.ServerBaseFeed;
-import org.apache.lucene.gdata.server.GDataResponse;
-import org.apache.lucene.gdata.server.ServiceException;
-import org.apache.lucene.gdata.server.ServiceFactory;
-import org.apache.lucene.gdata.server.administration.AdminService;
-import org.apache.lucene.gdata.server.registry.ComponentType;
-import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
-import org.apache.lucene.gdata.server.registry.RegistryException;
-import org.apache.lucene.gdata.servlet.handler.AbstractFeedHandler.FeedHandlerException;
-import org.apache.lucene.gdata.utils.ProvidedServiceStub;
-import org.apache.lucene.gdata.utils.ServiceFactoryStub;
-import org.apache.lucene.gdata.utils.StorageStub;
-import org.easymock.MockControl;
-
-import com.google.gdata.util.ParseException;
-
-/**
- * @author Simon Willnauer
- *
- */
-public class TestAbstractFeedHandler extends TestCase {
-    private MockControl requestMockControl; 
-    
-    private HttpServletRequest mockRequest = null; 
-    
-    private String accountName = "acc"; 
-    private MockControl adminServiceMockControl;
-    private AdminService adminService = null;
-    private ServiceFactoryStub stub;
-    private String serviceName = StorageStub.SERVICE_TYPE_RETURN;
-    private static File incomingFeed = new File("src/test/org/apache/lucene/gdata/server/registry/TestEntityBuilderIncomingFeed.xml");
-    BufferedReader reader;
-    static{
-        
-        try {
-            
-            GDataServerRegistry.getRegistry().registerComponent(StorageStub.class,null);
-            GDataServerRegistry.getRegistry().registerComponent(ServiceFactoryStub.class,null);
-        } catch (RegistryException e) {
-            
-            e.printStackTrace();
-        }
-    }
-    protected void setUp() throws Exception {
-        super.setUp();
-        
-        GDataServerRegistry.getRegistry().registerService(new ProvidedServiceStub());
-       this.requestMockControl = MockControl.createControl(HttpServletRequest.class);
-       this.adminServiceMockControl = MockControl.createControl(AdminService.class);
-       this.adminService = (AdminService)this.adminServiceMockControl.getMock();
-       this.mockRequest = (HttpServletRequest)this.requestMockControl.getMock();
-       this.stub = (ServiceFactoryStub)GDataServerRegistry.getRegistry().lookup(ServiceFactory.class,ComponentType.SERVICEFACTORY);
-       this.stub.setAdminService(this.adminService);
-       this.reader =  new BufferedReader(new FileReader(incomingFeed));
-    }
-
-    protected void tearDown() throws Exception {
-        super.tearDown();
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.servlet.handler.AbstractFeedHandler.createFeedFromRequest(HttpServletRequest)'
-     */
-    public void testCreateFeedFromRequest() throws ParseException, IOException, FeedHandlerException {
-        
-        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
-                .getParameter("service"), this.serviceName);
-        this.requestMockControl.expectAndReturn(this.mockRequest.getReader(),this.reader);
-        this.requestMockControl.replay();
-        AbstractFeedHandler handler = new InsertFeedHandler();
-        try{
-        ServerBaseFeed feed = handler.createFeedFromRequest(this.mockRequest);
-        assertNotNull(feed.getId());
-        
-        }catch (Exception e) {
-            e.printStackTrace();
-            fail("unexpected exception -- "+e.getMessage());
-            
-        }
-        this.requestMockControl.verify();
-        this.requestMockControl.reset();
-        /*
-         * Test for not registered service
-         */
-        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
-                .getParameter("service"), "some other service");
-        this.requestMockControl.replay();
-         handler = new InsertFeedHandler();
-        try{
-        ServerBaseFeed feed = handler.createFeedFromRequest(this.mockRequest);
-        
-        fail(" exception expected");
-        }catch (FeedHandlerException e) {
-            e.printStackTrace();
-            assertEquals(HttpServletResponse.SC_NOT_FOUND,handler.getErrorCode());
-        }
-        this.requestMockControl.verify();
-        
-        this.requestMockControl.reset();
-        /*
-         * Test for IOException
-         */
-        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
-                .getParameter("service"), this.serviceName);
-        this.reader.close();
-        this.requestMockControl.expectAndReturn(this.mockRequest.getReader(),this.reader);
-        this.requestMockControl.replay();
-         handler = new InsertFeedHandler();
-        try{
-        ServerBaseFeed feed = handler.createFeedFromRequest(this.mockRequest);
-        
-        fail(" exception expected");
-        }catch (IOException e) {
-            e.printStackTrace();
-            assertEquals(HttpServletResponse.SC_BAD_REQUEST,handler.getErrorCode());
-        }
-        this.requestMockControl.verify();
-        
-        
-        
-        
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.servlet.handler.AbstractFeedHandler.createRequestedAccount(HttpServletRequest)'
-     */
-    public void testCreateRequestedAccount() throws IOException, ParseException, ServiceException {
-        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
-                .getParameter(AbstractFeedHandler.PARAMETER_ACCOUNT), this.accountName);
-        GDataAccount a = new GDataAccount();
-        a.setName("helloworld");
-        this.adminServiceMockControl.expectAndReturn(this.adminService.getAccount(this.accountName),a );
-        this.requestMockControl.replay();
-        this.adminServiceMockControl.replay();
-        AbstractFeedHandler handler = new InsertFeedHandler();
-        try{
-            
-            GDataAccount account = handler.createRequestedAccount(this.mockRequest);
-       
-        assertEquals(a,account);
-        
-        }catch (Exception e) {
-            e.printStackTrace();
-            fail("unexpected exception -- "+e.getMessage());
-            
-        }
-        this.requestMockControl.verify();
-        this.requestMockControl.reset();
-        this.adminServiceMockControl.verify();
-        this.adminServiceMockControl.reset();
-        
-        /*
-         *Test for service exception 
-         */
-        
-        this.requestMockControl.expectAndDefaultReturn(this.mockRequest 
-                .getParameter(AbstractFeedHandler.PARAMETER_ACCOUNT), this.accountName);
-        
-        a.setName("helloworld");
-        this.adminServiceMockControl.expectAndDefaultThrow(this.adminService.getAccount(this.accountName),new ServiceException(GDataResponse.BAD_REQUEST) );
-        this.requestMockControl.replay();
-        this.adminServiceMockControl.replay();
-         handler = new InsertFeedHandler();
-        try{
-            
-            GDataAccount account = handler.createRequestedAccount(this.mockRequest);
-       
-            fail(" exception expected ");
-        
-        }catch (Exception e) {
-            e.printStackTrace();
-            assertEquals(HttpServletResponse.SC_BAD_REQUEST,handler.getErrorCode());
-            
-        }
-        this.requestMockControl.verify();
-        this.requestMockControl.reset();
-        this.adminServiceMockControl.verify();
-        this.adminServiceMockControl.reset();
-        
-        
-        
-        
-        
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/servlet/handler/TestRequestAuthenticator.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/servlet/handler/TestRequestAuthenticator.java
deleted file mode 100644
index ace688a..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/servlet/handler/TestRequestAuthenticator.java
+++ /dev/null
@@ -1,94 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.servlet.handler;
-
-import javax.servlet.http.Cookie;
-import javax.servlet.http.HttpServletRequest;
-
-import junit.framework.TestCase;
-
-import org.apache.lucene.gdata.server.authentication.AuthenticationController;
-import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
-import org.easymock.MockControl;
-
-public class TestRequestAuthenticator extends TestCase {
-    private MockControl requestMock;
-    private HttpServletRequest request;
-    private RequestAuthenticator authenticator;
-    private String tokenHeader;
-    private String token;
-    private Cookie authCookie;
-    
-    protected void setUp() throws Exception {
-    createMocks();
-    this.authenticator = new RequestAuthenticator();
-    this.token = "myToken";
-    this.tokenHeader = "GoogleLogin auth="+this.token;
-    this.authCookie = new Cookie("Auth",this.token);
-    }
-    protected void createMocks() {
-        this.requestMock = MockControl.createControl(HttpServletRequest.class);
-        this.request = (HttpServletRequest)this.requestMock.getMock();
-        
-    }
-    protected void tearDown() throws Exception {
-        GDataServerRegistry.getRegistry().destroy();
-    }
-    /*
-     * Test method for 'org.apache.lucene.gdata.servlet.handler.RequestAuthenticator.authenticateAccount(GDataRequest, AccountRole)'
-     */
-    public void testGetTokenFromRequest() {
-        // test token present
-        this.requestMock.expectAndDefaultReturn(this.request.getHeader(AuthenticationController.AUTHORIZATION_HEADER), this.tokenHeader);
-        this.requestMock.replay();
-        assertEquals(this.token,this.authenticator.getTokenFromRequest(this.request));
-        this.requestMock.verify();
-        this.requestMock.reset();
-        
-        // test token null / cookie present
-        this.requestMock.expectAndDefaultReturn(this.request.getHeader(AuthenticationController.AUTHORIZATION_HEADER), null);
-        this.requestMock.expectAndDefaultReturn(this.request.getCookies(), new Cookie[]{this.authCookie});
-        this.requestMock.replay();
-        assertEquals(this.token,this.authenticator.getTokenFromRequest(this.request));
-        this.requestMock.verify();
-        this.requestMock.reset();
-        
-        // test token null / cookie not present
-        this.requestMock.expectAndDefaultReturn(this.request.getHeader(AuthenticationController.AUTHORIZATION_HEADER), null);
-        this.requestMock.expectAndDefaultReturn(this.request.getCookies(), new Cookie[]{new Cookie("somekey","someValue")});
-        this.requestMock.replay();
-        assertNull(this.authenticator.getTokenFromRequest(this.request));
-        this.requestMock.verify();
-        this.requestMock.reset();
-        
-//      test token null / cookie array emtpy 
-        this.requestMock.expectAndDefaultReturn(this.request.getHeader(AuthenticationController.AUTHORIZATION_HEADER), null);
-        this.requestMock.expectAndDefaultReturn(this.request.getCookies(), new Cookie[]{});
-        this.requestMock.replay();
-        assertNull(this.authenticator.getTokenFromRequest(this.request));
-        this.requestMock.verify();
-        this.requestMock.reset();
-        
-//      test token null / cookie array null
-        this.requestMock.expectAndDefaultReturn(this.request.getHeader(AuthenticationController.AUTHORIZATION_HEADER), null);
-        this.requestMock.expectAndDefaultReturn(this.request.getCookies(), null);
-        this.requestMock.replay();
-        assertNull(this.authenticator.getTokenFromRequest(this.request));
-        this.requestMock.verify();
-        this.requestMock.reset();
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/TestIDGenerator.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/TestIDGenerator.java
deleted file mode 100644
index f320d16..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/TestIDGenerator.java
+++ /dev/null
@@ -1,69 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.storage; 
- 
-import java.util.ArrayList; 
-import java.util.List; 
- 
-import junit.framework.TestCase; 
- 
-import org.apache.lucene.gdata.storage.IDGenerator; 
- 
-/** 
- * @author Simon Willnauer 
- * 
- */ 
-public class TestIDGenerator extends TestCase { 
-    private IDGenerator idgen; 
- 
-    private int initialCap = 100; 
- 
-    @Override 
-    protected void setUp() throws Exception { 
-        this.idgen = new IDGenerator(this.initialCap); 
-         
-         
-    } 
- 
-    @Override 
-    protected void tearDown() throws Exception {
-        
-        this.idgen.stopIDGenerator();
-       
-    } 
- 
-    /** 
-     * Test method for 'org.apache.lucene.gdata.storage.IDGenerator.getUID()' 
-     * @throws InterruptedException  
-     */ 
-    public void testGetUID() throws InterruptedException { 
-         
-        List<String> idlist = new ArrayList<String>(); 
-        //TODO think about a better way to test this 
-        for (int i = 0; i < 1000; i++) { 
-            String id = this.idgen.getUID(); 
-            assertNotNull(id); 
-            assertFalse(idlist.contains(id)); 
-            idlist.add(id); 
-             
-                         
-             
-        } 
- 
-    } 
- 
-     
-} 
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/db4o/TestDb4oStorage.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/db4o/TestDb4oStorage.java
deleted file mode 100755
index ff2d094..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/db4o/TestDb4oStorage.java
+++ /dev/null
@@ -1,1040 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.storage.db4o;
-
-import java.io.File;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.atomic.AtomicBoolean;
-
-import junit.framework.TestCase;
-
-import org.apache.lucene.gdata.data.GDataAccount;
-import org.apache.lucene.gdata.data.ServerBaseEntry;
-import org.apache.lucene.gdata.data.ServerBaseFeed;
-import org.apache.lucene.gdata.server.registry.ProvidedServiceConfig;
-import org.apache.lucene.gdata.storage.ModificationConflictException;
-import org.apache.lucene.gdata.storage.Storage;
-import org.apache.lucene.gdata.storage.StorageController;
-import org.apache.lucene.gdata.storage.StorageException;
-import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper.StorageOperation;
-import org.apache.lucene.gdata.utils.MultiThreadEntryStub;
-import org.apache.lucene.gdata.utils.Visitor;
-
-import com.db4o.ObjectContainer;
-import com.db4o.ObjectSet;
-import com.db4o.query.Query;
-import com.google.gdata.data.BaseEntry;
-import com.google.gdata.data.BaseFeed;
-import com.google.gdata.data.DateTime;
-import com.google.gdata.data.PlainTextConstruct;
-
-public class TestDb4oStorage extends TestCase {
-    private static final String FEEDID = "myFeed";
-
-    private static final String ACCOUNTNAME = "myAccount";
-
-    private static final String SERVICENAME = "myService";
-
-    DB4oController controller;
-
-    static volatile boolean fail = false;
-
-    protected void setUp() throws Exception {
-        this.controller = new DB4oController();
-        this.controller.setContainerPoolSize(2);
-        this.controller.setFilePath("test.yap");
-        this.controller.setRunAsServer(true);
-        this.controller.setPassword("");
-        this.controller.setUser("");
-        this.controller.setUseWeakReferences(true);
-        this.controller.setPort(0);
-        this.controller.initialize();
-        this.controller.visiteInitialize();
-        clearDB();
-    }
-
-    protected void tearDown() throws Exception {
-        clearDB();
-        fail = false;
-        this.controller.getStorage().close();
-        this.controller.visiteDestroy();
-        this.controller.destroy();
-        File dbFile = new File("test.yap");
-        assertTrue(dbFile.delete());
-    }
-
-    private void clearDB() {
-        ObjectContainer container = this.controller.releaseContainer();
-        ObjectSet set = container.get(new Object());
-
-        for (Object object : set) {
-            container.delete(object);
-        }
-        container.ext().purge();
-        container.close();
-    }
-
-    ObjectContainer getContainer() {
-        return this.controller.releaseContainer();
-    }
-
-   
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.storage.db4o.DB4oStorage.storeEntry(ServerBaseEntry)'
-     */
-    @SuppressWarnings("unchecked")
-    public void testStoreEntry() throws StorageException {
-        Storage storage = this.controller.getStorage();
-        try {
-            ServerBaseEntry e = createServerBaseEntry();
-            storage.storeEntry(e);
-            fail("excption exp. for feed for the entry");
-        } catch (StorageException e) {
-            //
-        }
-
-        try {
-
-            storage.storeEntry(null);
-            fail("entry is null");
-        } catch (StorageException e) {
-            //
-        }
-        ServerBaseEntry exEntry = new ServerBaseEntry();
-        exEntry.setFeedId("some");
-        try {
-
-            storage.storeEntry(exEntry);
-            fail("entry id is null");
-        } catch (StorageException e) {
-            //
-        }
-        exEntry.setId("someID");
-        exEntry.setFeedId(null);
-        try {
-
-            storage.storeEntry(exEntry);
-            fail("feed id is null");
-        } catch (StorageException e) {
-            //
-        }
-
-        storeServerBaseFeed();
-        ServerBaseEntry e = createServerBaseEntry();
-        storage.storeEntry(e);
-        ServerBaseEntry e1 = createServerBaseEntry();
-        storage.storeEntry(e1);
-
-        storage = this.controller.getStorage();
-        Query query = getContainer().query();
-        query.constrain(BaseEntry.class);
-        query.descend("id").constrain(e.getId());
-        ObjectSet resultSet = query.execute();
-        assertEquals(1, resultSet.size());
-        BaseEntry storedEntry = (BaseEntry) resultSet.next();
-        assertEquals("1", storedEntry.getVersionId());
-
-        ServerBaseFeed bFeed = new ServerBaseFeed();
-        bFeed.setItemsPerPage(25);
-        bFeed.setId(FEEDID);
-        bFeed.setStartIndex(1);
-        bFeed.setServiceType(SERVICENAME);
-        BaseFeed<BaseFeed, BaseEntry> feed = storage.getFeed(bFeed);
-        assertEquals(2, feed.getEntries().size());
-        assertEquals(e.getId(), feed.getEntries().get(1).getId()); // last post
-        // ->
-        // previously
-        // created
-        assertEquals(e1.getId(), feed.getEntries().get(0).getId()); // first pos
-        // -> last
-        // created
-        assertEquals(feed.getUpdated(), feed.getEntries().get(0).getUpdated());
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.storage.db4o.DB4oStorage.deleteEntry(ServerBaseEntry)'
-     */
-    public void testDeleteEntry() throws StorageException, InterruptedException {
-        ObjectContainer container = getContainer();
-        storeServerBaseFeed();
-        Storage storage = this.controller.getStorage();
-        
-        try {
-
-            storage.deleteEntry(null);
-            fail("entry is null");
-        } catch (StorageException e) {
-            //
-        }
-        ServerBaseEntry exEntry = new ServerBaseEntry();
-        exEntry.setFeedId("some");
-        try {
-
-            storage.deleteEntry(exEntry);
-            fail("entry id is null");
-        } catch (StorageException e) {
-            //
-        }
-        exEntry.setId("someID");
-        exEntry.setFeedId(null);
-        try {
-
-            storage.storeEntry(exEntry);
-            fail("feed id is null");
-        } catch (StorageException e) {
-            //
-        }
-        
-        
-        ServerBaseEntry e = createServerBaseEntry();
-        storage.storeEntry(e);
-        ServerBaseEntry e1 = createServerBaseEntry();
-        storage.storeEntry(e1);
-
-        storage.deleteEntry(e);
-
-        container.close();
-        container = getContainer();
-        Query query = container.query();
-        query.constrain(BaseEntry.class);
-        query.descend("id").constrain(e.getId());
-        ObjectSet resultSet = query.execute();
-        assertEquals(0, resultSet.size());
-
-        // #### test version matching
-        ServerBaseEntry eVersion = createServerBaseEntry();
-        storage.storeEntry(eVersion);
-        eVersion.setVersion(33);
-        try {
-            storage.deleteEntry(eVersion);
-            fail("version does not match");
-        } catch (Exception ex) {
-            // TODO: handle exception
-        }
-        try {
-            storage.deleteEntry(null);
-            fail("entry id is null");
-        } catch (Exception ex) {
-            // TODO: handle exception
-        }
-        storage = this.controller.getStorage();
-        storage.deleteEntry(e1);
-        container.close();
-        container = getContainer();
-        query = container.query();
-        query.constrain(BaseEntry.class);
-        query.descend("id").constrain(e1.getId());
-        resultSet = query.execute();
-        assertEquals(0, resultSet.size());
-
-        // ############ test concurrency
-
-        // ############ test concurrency
-        Object monitor = new Object();
-        AtomicBoolean reached = new AtomicBoolean(false);
-        MultiThreadEntryStub concuEntry = new MultiThreadEntryStub();
-        concuEntry.setId(System.currentTimeMillis() + "");
-        ProvidedServiceConfig conf = new ProvidedServiceConfig();
-        conf.setName(SERVICENAME);
-        concuEntry.setServiceConfig(conf);
-        concuEntry.setUpdated(DateTime.now());
-        concuEntry.setFeedId(FEEDID);
-
-        storage = this.controller.getStorage();
-
-        storage.storeEntry(concuEntry);
-        storage.close();
-        concuEntry.acceptGetVersionVisitor(getMonitorVisitor(monitor, reached));
-
-        Thread t1 = getDelThread(controller, concuEntry, false);
-
-        Thread t2 = getDelThread(controller, concuEntry, true);
-        t1.start();
-        /*
-         * Wait active -- not nice but works fine here wait until thread parked
-         */
-
-        while (true) {
-            synchronized (monitor) {
-                if (reached.get())
-                    break;
-                monitor.wait(10);
-            }
-        }
-        t2.start();
-        t2.join(800);
-        /*
-         * Wait active -- not nice but works fine here wake up the waiting
-         * thread
-         */
-        while (true) {
-            synchronized (monitor) {
-                if (!reached.get())
-                    break;
-                monitor.notifyAll();
-            }
-        }
-        t1.join(300);
-        if (fail)
-            fail("thread failed -- see stacktrace");
-
-        container.close();
-
-    }
-
-    private Visitor getMonitorVisitor(final Object monitor,
-            final AtomicBoolean reached) {
-        /*
-         * The executing thread stops at a defined position while holding the
-         * semaphore inside the storageImpl
-         */
-        return new Visitor() {
-            public void execute(Object[] o) {
-                synchronized (monitor) {
-                    try {
-                        reached.set(true);
-                        monitor.wait();
-                        reached.set(false);
-
-                    } catch (InterruptedException e) {
-                        //                   
-                    }
-                }
-            }
-        };
-    }
-
-    private Thread getDelThread(StorageController c, ServerBaseEntry e,
-            boolean conflictExpected) {
-        Thread t1 = new Thread(new Runner(c, e, conflictExpected,
-                StorageOperation.DELETE));
-        t1.setPriority(Thread.MAX_PRIORITY);
-        return t1;
-    }
-
-    private Thread getUpdThread(StorageController c, ServerBaseEntry e,
-            boolean conflictExpected) {
-        Thread t1 = new Thread(new Runner(c, e, conflictExpected,
-                StorageOperation.UPDATE));
-        t1.setPriority(Thread.MAX_PRIORITY);
-        return t1;
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.storage.db4o.DB4oStorage.updateEntry(ServerBaseEntry)'
-     */
-    public void testUpdateEntry() throws StorageException, InterruptedException {
-        storeServerBaseFeed();
-        Storage storage = this.controller.getStorage();
-        ServerBaseEntry exEntry = new ServerBaseEntry();
-        
-
-        try {
-
-            storage.updateEntry(null);
-            fail("entry is null");
-        } catch (StorageException e) {
-            //
-        }
-
-        try {
-
-            storage.updateEntry(exEntry);
-            fail("entry id is null");
-        } catch (StorageException e) {
-            //
-        }
-        exEntry.setId("someID");
-        try {
-
-            storage.updateEntry(exEntry);
-            fail("feed id is null");
-        } catch (StorageException e) {
-            //
-        }
-        
-        
-        
-        ServerBaseEntry e = createServerBaseEntry();
-        ServerBaseEntry e1 = createServerBaseEntry();
-        try {
-            storage.updateEntry(e);
-            fail("entry does not exist");
-        } catch (StorageException ex) {
-            ex.printStackTrace();
-        }
-        storage.storeEntry(e);
-
-        storage = this.controller.getStorage();
-
-        storage.storeEntry(e1);
-        ServerBaseEntry e2 = createServerBaseEntry();
-        e2.setId(e.getId());
-        e2.setTitle(new PlainTextConstruct("new"));
-        e2.setUpdated(DateTime.now());
-        storage.updateEntry(e2);
-        ObjectContainer container = getContainer();
-        Query query = container.query();
-        query.constrain(BaseEntry.class);
-        query.descend("id").constrain(e.getId());
-        ObjectSet resultSet = query.execute();
-        assertEquals(1, resultSet.size());
-        BaseEntry result = (BaseEntry) resultSet.next();
-        assertEquals("new", result.getTitle().getPlainText());
-        assertEquals("2", result.getVersionId());
-
-        ServerBaseFeed bFeed = new ServerBaseFeed();
-        bFeed.setItemsPerPage(25);
-        bFeed.setId(FEEDID);
-        bFeed.setStartIndex(1);
-        bFeed.setServiceType(SERVICENAME);
-        storage = this.controller.getStorage();
-        BaseFeed<BaseFeed, BaseEntry> feed = storage.getFeed(bFeed);
-
-        assertEquals(2, feed.getEntries().size());
-        assertEquals(e.getId(), feed.getEntries().get(0).getId());
-        assertEquals(feed.getUpdated(), feed.getEntries().get(0).getUpdated());
-
-        storage = this.controller.getStorage();
-        storage.storeEntry(e);
-
-        e2.setVersion(5);
-        try {
-            storage.updateEntry(e2);
-            fail("version does not match");
-        } catch (Exception ex) {
-            // TODO: handle exception
-        }
-
-        // ############ test concurrency
-        Object monitor = new Object();
-        AtomicBoolean reached = new AtomicBoolean(false);
-
-        MultiThreadEntryStub concuEntry = new MultiThreadEntryStub();
-        concuEntry.setId(System.currentTimeMillis() + "");
-        ProvidedServiceConfig conf = new ProvidedServiceConfig();
-        conf.setName(SERVICENAME);
-        concuEntry.setServiceConfig(conf);
-        concuEntry.setUpdated(DateTime.now());
-        concuEntry.setFeedId(FEEDID);
-
-        storage = this.controller.getStorage();
-
-        storage.storeEntry(concuEntry);
-        storage.close();
-        concuEntry.acceptGetEntryVisitor(getMonitorVisitor(monitor, reached));
-
-        Thread t1 = getUpdThread(controller, concuEntry, false);
-
-        Thread t2 = getUpdThread(controller, concuEntry, true);
-        t1.start();
-        /*
-         * Wait active -- not nice but works fine here wait until thread parked
-         */
-
-        while (true) {
-            synchronized (monitor) {
-                if (reached.get())
-                    break;
-                monitor.wait(10);
-            }
-        }
-        t2.start();
-        t2.join(800);
-        /*
-         * Wait active -- not nice but works fine here wake up the waiting
-         * thread
-         */
-        while (true) {
-            synchronized (monitor) {
-                if (!reached.get())
-                    break;
-                monitor.notifyAll();
-            }
-        }
-        t1.join(300);
-        if (fail)
-            fail("thread failed -- see stacktrace");
-        container.close();
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.storage.db4o.DB4oStorage.getFeed(ServerBaseFeed)'
-     */
-    public void testGetFeed() throws StorageException {
-        storeServerBaseFeed();
-        Storage storage = this.controller.getStorage();
-        ServerBaseFeed feed = new ServerBaseFeed();
-        feed.setItemsPerPage(25);
-        feed.setStartIndex(1);
-        feed.setServiceType(SERVICENAME);
-        try{
-        storage.getFeed(feed);
-        fail("feedid is null");
-        }catch (StorageException e) {
-            // 
-        }
-        
-        feed.setId(FEEDID);
-        BaseFeed result = storage.getFeed(feed);
-        assertNotNull(result);
-        assertEquals(0, result.getEntries().size());
-        List<String> idlist = new ArrayList<String>(30);
-        ServerBaseEntry e1 = null;
-        for (int i = 0; i < 30; i++) {
-            e1 = createServerBaseEntry();
-            storage.storeEntry(e1);
-            idlist.add(0, e1.getId());
-        }
-        String firstId = e1.getId();
-
-        storage = this.controller.getStorage();
-        result = storage.getFeed(feed);
-        assertNotNull(result);
-        assertEquals(25, result.getEntries().size());
-        for (int i = 0; i < 25; i++) {
-            assertEquals(idlist.get(i),
-                    ((BaseEntry) result.getEntries().get(i)).getId());
-        }
-
-        storage = this.controller.getStorage();
-        feed.setItemsPerPage(5);
-        result = storage.getFeed(feed);
-        assertNotNull(result);
-        assertEquals(5, result.getEntries().size());
-        for (int i = 0; i < 5; i++) {
-            assertEquals(idlist.get(i),
-                    ((BaseEntry) result.getEntries().get(i)).getId());
-        }
-
-        storage = this.controller.getStorage();
-        feed.setItemsPerPage(1);
-        feed.setStartIndex(1);
-        result = storage.getFeed(feed);
-        assertNotNull(result);
-        assertEquals(1, result.getEntries().size());
-
-        assertEquals(idlist.get(0), ((BaseEntry) result.getEntries().get(0))
-                .getId());
-
-        storage = this.controller.getStorage();
-        feed.setItemsPerPage(50);
-        feed.setStartIndex(28);
-        result = storage.getFeed(feed);
-        assertNotNull(result);
-        assertEquals(3, result.getEntries().size());
-
-        assertEquals(idlist.get(27), ((BaseEntry) result.getEntries().get(0))
-                .getId());
-        assertEquals(idlist.get(28), ((BaseEntry) result.getEntries().get(1))
-                .getId());
-        assertEquals(idlist.get(29), ((BaseEntry) result.getEntries().get(2))
-                .getId());
-
-        storage = this.controller.getStorage();
-        feed.setItemsPerPage(50);
-        feed.setStartIndex(30);
-        result = storage.getFeed(feed);
-        assertNotNull(result);
-        assertEquals(1, result.getEntries().size());
-
-        assertEquals(idlist.get(29), ((BaseEntry) result.getEntries().get(0))
-                .getId());
-
-        // assertNotSame(firstId,((BaseEntry)result.getEntries().get(0)).getId());
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.storage.db4o.DB4oStorage.getEntry(ServerBaseEntry)'
-     */
-    public void testGetEntry() throws StorageException {
-        storeServerBaseFeed();
-        Storage storage = this.controller.getStorage();
-        ServerBaseEntry exEntry = createServerBaseEntry();
-        exEntry.setId(null);
-        try{
-        storage.getEntry(exEntry);
-        fail("id is null");
-        }catch (StorageException e) {
-
-        }
-        ServerBaseEntry e = createServerBaseEntry();
-        storage.storeEntry(e);
-        ServerBaseEntry e1 = createServerBaseEntry();
-        storage.storeEntry(e1);
-        
-        storage = this.controller.getStorage();
-        BaseEntry result = storage.getEntry(e);
-        assertNotNull(result);
-        assertEquals(e.getId(), result.getId());
-        try {
-            e1.setId("hello");
-            result = storage.getEntry(e1);
-            fail("no such entry");
-        } catch (StorageException ex) {
-            ex.printStackTrace();
-        }
-
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.storage.db4o.DB4oStorage.storeAccount(GDataAccount)'
-     */
-    public void testStoreAccount() throws StorageException {
-        GDataAccount account = new GDataAccount();
-        account.setName("simon");
-        account.setPassword("somepass");
-        Storage storage = this.controller.getStorage();
-        storage.storeAccount(account);
-        ObjectContainer container = getContainer();
-        Query q = container.query();
-        q.constrain(GDataAccount.class);
-        q.descend("name").constrain(account.getName());
-        ObjectSet set = q.execute();
-        assertEquals(1, set.size());
-        assertEquals(account.getPassword(), ((GDataAccount) set.next())
-                .getPassword());
-        try {
-            storage.storeAccount(account);
-            fail("Account already stored");
-        } catch (Exception e) {
-
-        }
-        container.close();
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.storage.db4o.DB4oStorage.updateAccount(GDataAccount)'
-     */
-    public void testUpdateAccount() throws StorageException {
-        GDataAccount account = new GDataAccount();
-        account.setName("simon");
-        account.setPassword("somepass");
-
-        Storage storage = this.controller.getStorage();
-        try {
-            storage.updateAccount(account);
-            fail("Account does not exist");
-        } catch (Exception e) {
-            //
-        }
-        try {
-            storage.updateAccount(null);
-            fail("Account is null");
-        } catch (Exception e) {
-            //
-        }
-        storage.storeAccount(account);
-        ObjectContainer container = getContainer();
-        Query q = container.query();
-        q.constrain(GDataAccount.class);
-        q.descend("name").constrain(account.getName());
-        ObjectSet set = q.execute();
-        assertEquals(1, set.size());
-        assertEquals(account.getPassword(), ((GDataAccount) set.next())
-                .getPassword());
-        account = new GDataAccount();
-        account.setName("simon");
-        account.setPassword("newPass");
-        storage.updateAccount(account);
-        container.close();
-        container = getContainer();
-        q = container.query();
-        q.constrain(GDataAccount.class);
-        q.descend("name").constrain(account.getName());
-        set = q.execute();
-        assertEquals(1, set.size());
-        assertEquals(account.getPassword(), ((GDataAccount) set.next())
-                .getPassword());
-        container.close();
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.storage.db4o.DB4oStorage.deleteAccount(String)'
-     */
-    public void testDeleteAccount() throws StorageException {
-        GDataAccount account = new GDataAccount();
-        account.setName("simon");
-        account.setPassword("somepass");
-        Storage storage = this.controller.getStorage();
-        storage.storeAccount(account);
-        ObjectContainer container = getContainer();
-        Query q = container.query();
-        q.constrain(GDataAccount.class);
-        q.descend("name").constrain(account.getName());
-        ObjectSet set = q.execute();
-        assertEquals(1, set.size());
-
-        storage.deleteAccount(account.getName());
-        container.close();
-        container = getContainer();
-        q = container.query();
-        q.constrain(GDataAccount.class);
-        q.descend("name").constrain(account.getName());
-        set = q.execute();
-        assertEquals(0, set.size());
-        try {
-            storage.deleteAccount("notstored");
-            fail("account not stored");
-        } catch (Exception e) {
-            // 
-        }
-        try {
-            storage.deleteAccount(null);
-            fail("name is null");
-        } catch (Exception e) {
-            // 
-        }
-        container.close();
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.storage.db4o.DB4oStorage.storeFeed(ServerBaseFeed,
-     * String)'
-     */
-    public void testStoreFeed() throws StorageException {
-        ObjectContainer container = getContainer();
-        ServerBaseFeed feed = new ServerBaseFeed();
-        feed.setId(FEEDID);
-        ProvidedServiceConfig conf = new ProvidedServiceConfig();
-        conf.setName(SERVICENAME);
-        feed.setServiceConfig(conf);
-
-        Storage storage = this.controller.getStorage();
-        try {
-            storage.storeFeed(feed, ACCOUNTNAME);
-            fail("no accoutn stored");
-        } catch (Exception e) {
-            // 
-        }
-        GDataAccount account = new GDataAccount();
-        account.setName(ACCOUNTNAME);
-        account.setPassword("somePass");
-        container.set(account);
-        container.commit();
-        container.close();
-        storage.storeFeed(feed, ACCOUNTNAME);
-
-        container = getContainer();
-        Query query = container.query();
-        query.constrain(ServerBaseFeed.class);
-        query.descend("feed").descend("id").constrain(FEEDID);
-        ObjectSet set = query.execute();
-        assertEquals(1, set.size());
-
-        assertEquals(feed.getId(), ((ServerBaseFeed) set.next()).getId());
-        container.close();
-
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.storage.db4o.DB4oStorage.deleteFeed(String)'
-     */
-    public void testDeleteFeed() throws StorageException {
-
-        ServerBaseFeed feed = new ServerBaseFeed();
-        feed.setId(FEEDID);
-        GDataAccount account = new GDataAccount();
-        account.setName(ACCOUNTNAME);
-        account.setPassword("somePass");
-        ObjectContainer container = getContainer();
-        container.set(account);
-        container.commit();
-        container.close();
-        Storage storage = this.controller.getStorage();
-        ProvidedServiceConfig conf = new ProvidedServiceConfig();
-        conf.setName(SERVICENAME);
-        feed.setServiceConfig(conf);
-        storage.storeFeed(feed, ACCOUNTNAME);
-
-        storage.deleteFeed(FEEDID);
-        container = getContainer();
-        Query query = container.query();
-        query.constrain(ServerBaseFeed.class);
-        query.descend("feed").descend("id").constrain(FEEDID);
-        ObjectSet set = query.execute();
-        assertEquals(0, set.size());
-
-        query = getContainer().query();
-        query.constrain(BaseFeed.class);
-        query.descend("id").constrain(FEEDID);
-        set = query.execute();
-        assertEquals(0, set.size());
-        container.close();
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.storage.db4o.DB4oStorage.getServiceForFeed(String)'
-     */
-    public void testGetServiceForFeed() throws StorageException {
-        ServerBaseFeed feed = new ServerBaseFeed();
-        ProvidedServiceConfig conf = new ProvidedServiceConfig();
-        conf.setName(SERVICENAME);
-        feed.setServiceConfig(conf);
-        feed.setId(FEEDID);
-        GDataAccount account = new GDataAccount();
-        account.setName(ACCOUNTNAME);
-        account.setPassword("somePass");
-        ObjectContainer container = getContainer();
-        container.set(account);
-        container.commit();
-        container.close();
-        Storage storage = this.controller.getStorage();
-        storage.storeFeed(feed, ACCOUNTNAME);
-
-        assertEquals(SERVICENAME, storage.getServiceForFeed(FEEDID));
-        try {
-            storage.getServiceForFeed(null);
-            fail("ID is null");
-        } catch (Exception e) {
-            // 
-        }
-
-        try {
-            storage.getServiceForFeed("someOtherId");
-            fail("feed for id is not stored");
-        } catch (Exception e) {
-            // 
-        }
-
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.storage.db4o.DB4oStorage.getAccount(String)'
-     */
-    public void testGetAccount() throws StorageException {
-        GDataAccount account = new GDataAccount();
-        account.setName(ACCOUNTNAME);
-        account.setPassword("somePass");
-        ObjectContainer container = getContainer();
-        container.set(account);
-        container.commit();
-        container.close();
-
-        Storage storage = this.controller.getStorage();
-        assertNotNull(storage.getAccount(ACCOUNTNAME));
-        assertEquals(account.getPassword(), storage.getAccount(ACCOUNTNAME)
-                .getPassword());
-        try {
-            storage.getAccount(null);
-            fail("accountname is null");
-        } catch (Exception e) {
-            // 
-        }
-        try {
-            storage.getAccount("someOtherAccount");
-            fail("accountname is not stored");
-        } catch (Exception e) {
-            // 
-        }
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.storage.db4o.DB4oStorage.updateFeed(ServerBaseFeed,
-     * String)'
-     */
-    public void testUpdateFeed() throws StorageException {
-        ObjectContainer container = getContainer();
-        ServerBaseFeed feed = new ServerBaseFeed();
-        ProvidedServiceConfig conf = new ProvidedServiceConfig();
-        conf.setName(SERVICENAME);
-        feed.setId(FEEDID);
-        feed.setServiceConfig(conf);
-        Storage storage = this.controller.getStorage();
-        GDataAccount account = new GDataAccount();
-        account.setName(ACCOUNTNAME);
-        account.setPassword("somePass");
-        container.set(account);
-        container.commit();
-        container.close();
-        storage.storeFeed(feed, ACCOUNTNAME);
-        assertNull(feed.getTitle());
-        ServerBaseFeed feedU = new ServerBaseFeed();
-        feedU.setServiceConfig(conf);
-        feedU.setId(FEEDID);
-        feedU.setTitle(new PlainTextConstruct("someText"));
-        feedU.setServiceType(SERVICENAME);
-
-        storage.updateFeed(feedU, ACCOUNTNAME);
-        ServerBaseFeed requestFeed = new ServerBaseFeed();
-        requestFeed.setId(FEEDID);
-        requestFeed.setServiceType(SERVICENAME);
-        assertNotNull(storage.getFeed(requestFeed));
-        assertEquals(feedU.getTitle(), storage.getFeed(requestFeed).getTitle());
-        try {
-            storage.updateFeed(null, ACCOUNTNAME);
-            fail("feed is null");
-        } catch (Exception e) {
-            // 
-        }
-        try {
-            storage.updateFeed(feedU, null);
-            fail("accountname is null");
-        } catch (Exception e) {
-            // 
-        }
-        try {
-            feedU.setServiceType(null);
-            storage.updateFeed(feedU, ACCOUNTNAME);
-            fail("servicetype is null");
-        } catch (Exception e) {
-            // 
-        }
-
-    }
-
-    private static ServerBaseEntry createServerBaseEntry() {
-        ServerBaseEntry e = new ServerBaseEntry();
-        e.setId(System.currentTimeMillis() + "");
-        ProvidedServiceConfig conf = new ProvidedServiceConfig();
-        conf.setName(SERVICENAME);
-        e.setServiceConfig(conf);
-        e.setUpdated(DateTime.now());
-        e.setFeedId(FEEDID);
-        try {
-            Thread.sleep(2);
-        } catch (InterruptedException e1) {
-
-            e1.printStackTrace();
-        }
-        return e;
-    }
-
-    private ServerBaseFeed storeServerBaseFeed() {
-        ServerBaseFeed f = new ServerBaseFeed();
-        ProvidedServiceConfig conf = new ProvidedServiceConfig();
-        conf.setName(SERVICENAME);
-        f.setServiceConfig(conf);
-        f.setId(System.currentTimeMillis() + "");
-        f.setId(FEEDID);
-        f.setUpdated(DateTime.now());
-        ObjectContainer con = this.controller.releaseContainer();
-        con.set(f);
-        con.commit();
-
-        con.close();
-        return f;
-    }
-
-    static class Runner implements Runnable {
-        Storage s;
-
-        StorageController c;
-
-        ServerBaseEntry e;
-
-        boolean expConf;
-
-        StorageOperation op;
-
-        public Runner(StorageController c, ServerBaseEntry e,
-                boolean expectConflict, StorageOperation op) {
-
-            this.c = c;
-
-            this.e = e;
-            this.expConf = expectConflict;
-            this.op = op;
-
-        }
-
-        public void run() {
-            try {
-                ((DB4oController) this.c).visiteInitialize();
-                this.s = this.c.getStorage();
-            } catch (StorageException e1) {
-
-                e1.printStackTrace();
-            }
-            try {
-                if (this.op == StorageOperation.DELETE)
-                    this.s.deleteEntry(e);
-                if (this.op == StorageOperation.UPDATE)
-                    this.s.updateEntry(e);
-                if (expConf)
-                    fail = true;
-            } catch (ModificationConflictException ex) {
-                if (!expConf)
-                    fail = true;
-                ex.printStackTrace();
-
-            } catch (StorageException ex) {
-                ex.printStackTrace();
-                fail = true;
-            } finally {
-                ((DB4oController) this.c).visiteDestroy();
-            }
-
-        }
-    }
-
-    public void testFeedLastModified() {
-        ServerBaseFeed feed = storeServerBaseFeed();
-        Storage s = this.controller.getStorage();
-        assertEquals(feed.getUpdated().getValue(), s
-                .getFeedLastModified(FEEDID).longValue());
-        try {
-            s.getFeedLastModified(null);
-            fail("id is null");
-        } catch (StorageException e) {
-
-        }
-        try {
-            s.getFeedLastModified("someOtherid");
-            fail("no such feed");
-        } catch (StorageException e) {
-
-        }
-
-    }
-
-    public void testEntryLastModified() {
-        ServerBaseFeed feed = storeServerBaseFeed();
-        Storage s = this.controller.getStorage();
-        ServerBaseEntry en = createServerBaseEntry();
-        s.storeEntry(en);
-        assertEquals(en.getUpdated().getValue(), s.getEntryLastModified(
-                en.getId(), FEEDID).longValue());
-        try {
-            s.getEntryLastModified(null, null);
-            fail("id is null");
-        } catch (StorageException e) {
-
-        }
-        try {
-            s.getEntryLastModified("someOtherid", "notinstorage");
-            fail("no such Entry");
-        } catch (StorageException e) {
-
-        }
-
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/db4o/TestObjectServerDecorator.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/db4o/TestObjectServerDecorator.java
deleted file mode 100755
index 4004fa9..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/db4o/TestObjectServerDecorator.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.storage.db4o;
-
-import java.io.File;
-import java.lang.reflect.Proxy;
-
-import com.db4o.Db4o;
-import com.db4o.ObjectContainer;
-import com.db4o.ObjectServer;
-
-import junit.framework.TestCase;
-
-public class TestObjectServerDecorator extends TestCase {
-    ObjectServer decorator;
-    ObjectServer actualServer;
-    String dbFile = "test.yap";
-    protected void setUp() throws Exception {
-        decorator = (ObjectServer) Proxy.newProxyInstance(this.getClass().getClassLoader(),new Class[]{ObjectServer.class},new ObjectServerDecorator("u","p","127.0.0.1",10101));
-        actualServer= Db4o.openServer(dbFile,10101);
-        actualServer.grantAccess("u","p");
-        
-    }
-
-    protected void tearDown() throws Exception {
-        actualServer.close();
-        File dbF = new File(dbFile);
-        assertTrue(dbF.delete());
-        
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.storage.db4o.ObjectServerDecorator.invoke(Object, Method, Object[])'
-     */
-    public void testInvoke() {
-        assertFalse(this.decorator.close());
-        assertNull(this.decorator.ext());
-        assertEquals(0,this.decorator.hashCode());
-        ObjectContainer container = this.decorator.openClient(); 
-        assertNotNull(container);
-        assertTrue(this.decorator.openClient()instanceof ObjectContainer);
-        container.close();
-        
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/StorageCoreControllerStub.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/StorageCoreControllerStub.java
deleted file mode 100755
index e648520..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/StorageCoreControllerStub.java
+++ /dev/null
@@ -1,211 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.storage.lucenestorage;
-
-import java.io.IOException;
-import java.security.NoSuchAlgorithmException;
-
-import org.apache.lucene.gdata.server.registry.Component;
-import org.apache.lucene.gdata.server.registry.ComponentType;
-import org.apache.lucene.gdata.storage.IDGenerator;
-import org.apache.lucene.gdata.storage.Storage;
-import org.apache.lucene.gdata.storage.StorageException;
-import org.apache.lucene.gdata.utils.ReferenceCounter;
-import org.apache.lucene.index.IndexModifier;
-import org.apache.lucene.store.Directory;
-
-/**
- * @author Simon Willnauer
- *
- */
-@Component(componentType = ComponentType.STORAGECONTROLLER)
-public class StorageCoreControllerStub extends StorageCoreController {
-    private final IDGenerator idGenerator;
-
-
-    public StorageCoreControllerStub() throws IOException, StorageException {
-        try{
-            this.idGenerator = new IDGenerator(5);
-        }catch (NoSuchAlgorithmException e) {
-            throw new StorageException(e);
-        }
-       
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController#createIndexModifier()
-     */
-    @Override
-    protected IndexModifier createIndexModifier() throws IOException {
-        
-        return null;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController#forceWrite()
-     */
-    @Override
-    public void forceWrite() throws IOException {
-        
-        
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController#getDirectory()
-     */
-    @Override
-    protected Directory getDirectory() {
-        
-        return null;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController#getBufferSize()
-     */
-    @Override
-    public int getBufferSize() {
-        
-        return 1;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController#getStorageModifier()
-     */
-    @Override
-    protected StorageModifier getStorageModifier() {
-        
-        try {
-            return new StorageModifierStub();
-        } catch (IOException e) {
-            
-            e.printStackTrace();
-        } catch (StorageException e) {
-            
-            e.printStackTrace();
-        }
-        return null;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController#getPersistFactor()
-     */
-    @Override
-    public int getPersistFactor() {
-        
-        return 1;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController#getStorageQuery()
-     */
-    @Override
-    protected ReferenceCounter<StorageQuery> getStorageQuery() {
-        
-        ReferenceCounter<StorageQuery> retVal =  new ReferenceCounter<StorageQuery>(new StorageQueryStub(null,null)){
-
-            @Override
-            protected void close() {
-                //
-            }
-            
-        };
-        retVal.increamentReference();
-        retVal.increamentReference();
-        return retVal;
-        
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController#registerNewStorageQuery()
-     */
-    @Override
-    protected void registerNewStorageQuery() throws IOException {
-        
-       
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController#releaseId()
-     */
-    @Override
-    public synchronized String releaseId() throws StorageException {
-        
-        try {
-            return this.idGenerator.getUID();
-        } catch (InterruptedException e) {
-            
-          throw new StorageException(e);
-        } 
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController#releaseNewStorageBuffer()
-     */
-    @Override
-    protected StorageBuffer releaseNewStorageBuffer() {
-        
-        return null;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController#setBufferSize(int)
-     */
-    @Override
-    public void setBufferSize(int storageBufferSize) {
-        
-        
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController#setPersistFactor(int)
-     */
-    @Override
-    public void setPersistFactor(int storagePersistFactor) {
-        
-       
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController#destroy()
-     */
-    @Override
-    public void destroy() {
-        
-        this.idGenerator.stopIDGenerator();
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController#getStorage()
-     */
-    @Override
-    public Storage getStorage() throws StorageException {
-        
-        return new StorageImplementation();
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController#initialize()
-     */
-    @Override
-    public void initialize() {
-//        this.setStorageDir(new RAMDirectory());
-//        super.initialize();
-    }
-
-   
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/StorageModifierStub.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/StorageModifierStub.java
deleted file mode 100644
index b521dcd..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/StorageModifierStub.java
+++ /dev/null
@@ -1,169 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.storage.lucenestorage;
-
-import java.io.IOException;
-
-import org.apache.lucene.analysis.standard.StandardAnalyzer;
-import org.apache.lucene.gdata.storage.StorageException;
-import org.apache.lucene.gdata.storage.lucenestorage.StorageBuffer;
-import org.apache.lucene.gdata.storage.lucenestorage.StorageCoreController;
-import org.apache.lucene.gdata.storage.lucenestorage.StorageModifier;
-import org.apache.lucene.gdata.utils.StorageControllerStub;
-import org.apache.lucene.index.IndexModifier;
-import org.apache.lucene.store.RAMDirectory;
-
-/**
- * @author Simon Willnauer
- *
- */
-public class StorageModifierStub extends StorageModifier {
-    public boolean throwException = false;
-    public StorageModifierStub() throws IOException, StorageException{
-        super(new StorageCoreControllerStub(), new IndexModifier(new RAMDirectory(),new StandardAnalyzer(),true), new StorageBuffer(1),1, 1);
-    }
-    /**
-     * @param controller
-     * @param modifier
-     * @param buffer
-     * @param persitsFactor
-     * @param optimizeInterval
-     * @throws IOException 
-     * @throws StorageException 
-     */
-    public StorageModifierStub(StorageCoreController controller,
-            IndexModifier modifier, StorageBuffer buffer, int persitsFactor,
-            int optimizeInterval) throws IOException, StorageException {
-        
-        super(new StorageCoreControllerStub(), new IndexModifier(new RAMDirectory(),new StandardAnalyzer(),true), new StorageBuffer(1),1, 1);
-        
-        // TODO Auto-generated constructor stub
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier#close()
-     */
-    @Override
-    protected void close() throws IOException {
-        if(throwException)
-            throw new IOException();
-        
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier#createAccount(org.apache.lucene.gdata.storage.lucenestorage.StorageAccountWrapper)
-     */
-    @Override
-    public void createAccount(StorageAccountWrapper account) throws StorageException {
-        if(throwException)
-            throw new StorageException();
-        
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier#createFeed(org.apache.lucene.gdata.storage.lucenestorage.StorageFeedWrapper)
-     */
-    @Override
-    public void createFeed(StorageFeedWrapper wrapper) throws StorageException {
-        if(throwException)
-            throw new StorageException();
-        
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier#deleteAccount(java.lang.String)
-     */
-    @Override
-    public void deleteAccount(String accountName) throws StorageException {
-        if(throwException)
-            throw new StorageException();
-        
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier#deleteEntry(org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper)
-     */
-    @Override
-    public void deleteEntry(StorageEntryWrapper wrapper) throws StorageException {
-        if(throwException)
-            throw new StorageException();
-        
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier#deleteFeed(java.lang.String)
-     */
-    @Override
-    public void deleteFeed(String feedId) throws StorageException {
-        if(throwException)
-            throw new StorageException();
-        
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier#forceWrite()
-     */
-    @Override
-   public void forceWrite() throws IOException {
-        if(throwException)
-            throw new IOException();
-        
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier#insertEntry(org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper)
-     */
-    @Override
-    public void insertEntry(StorageEntryWrapper wrapper) throws StorageException {
-        if(throwException)
-            throw new StorageException();
-        
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier#updateAccount(org.apache.lucene.gdata.storage.lucenestorage.StorageAccountWrapper)
-     */
-    @Override
-    public void updateAccount(StorageAccountWrapper user) throws StorageException {
-        if(throwException)
-            throw new StorageException();
-        
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier#updateEntry(org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper)
-     */
-    @Override
-    public void updateEntry(StorageEntryWrapper wrapper) throws StorageException {
-        if(throwException)
-            throw new StorageException();
-        if(wrapper != null)
-            wrapper.getEntry();
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageModifier#updateFeed(org.apache.lucene.gdata.storage.lucenestorage.StorageFeedWrapper)
-     */
-    @Override
-    public void updateFeed(StorageFeedWrapper wrapper) throws StorageException {
-        if(throwException)
-            throw new StorageException();   
-        
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/StorageQueryStub.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/StorageQueryStub.java
deleted file mode 100755
index 707912e..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/StorageQueryStub.java
+++ /dev/null
@@ -1,157 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.storage.lucenestorage;
-
-import java.io.IOException;
-import java.util.List;
-
-import org.apache.lucene.gdata.data.GDataAccount;
-import org.apache.lucene.gdata.server.registry.ProvidedService;
-import org.apache.lucene.gdata.storage.StorageException;
-import org.apache.lucene.search.Searcher;
-
-import com.google.gdata.data.BaseEntry;
-import com.google.gdata.data.BaseFeed;
-import com.google.gdata.util.ParseException;
-
-/**
- * @author Simon Willnauer
- *
- */
-public class StorageQueryStub extends StorageQuery {
-
-    public boolean booleanReturn = true;
-
-    /**
-     * @param buffer
-     * @param searcher
-     */
-    public StorageQueryStub(StorageBuffer buffer, Searcher searcher) {
-        super(buffer, searcher);
-        // TODO Auto-generated constructor stub
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageQuery#checkEntryVersion(java.lang.String, java.lang.String, int)
-     */
-    @Override
-    protected boolean checkEntryVersion(String id, String feedId, int version) throws IOException {
-        
-        return booleanReturn;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageQuery#close()
-     */
-    @Override
-    public void close() throws IOException {
-        
-        super.close();
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageQuery#entryQuery(java.util.List, java.lang.String, org.apache.lucene.gdata.server.registry.ProvidedService)
-     */
-    @Override
-    public List<BaseEntry> entryQuery(List<String> entryIds, String feedId, ProvidedService config) throws IOException, ParseException {
-        
-        return null;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageQuery#getAccountNameForFeedId(java.lang.String)
-     */
-    @Override
-    public String getAccountNameForFeedId(String feedId) throws IOException {
-        
-        return null;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageQuery#getEntryLastModified(java.lang.String, java.lang.String)
-     */
-    @Override
-    protected long getEntryLastModified(String entryId, String feedId) throws IOException, StorageException {
-        
-        return System.currentTimeMillis();
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageQuery#getFeedLastModified(java.lang.String)
-     */
-    @Override
-    protected long getFeedLastModified(String feedId) throws IOException {
-        
-        return System.currentTimeMillis();
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageQuery#getLatestFeedQuery(java.lang.String, int, int, org.apache.lucene.gdata.server.registry.ProvidedService)
-     */
-    @Override
-    public BaseFeed getLatestFeedQuery(String feedId, int resultCount, int startIndex, ProvidedService config) throws IOException, ParseException {
-        
-        return null;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageQuery#getService(java.lang.String)
-     */
-    @Override
-    public String getService(String feedID) throws IOException {
-        
-        return null;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageQuery#getUser(java.lang.String)
-     */
-    @Override
-    public GDataAccount getUser(String username) throws IOException {
-        
-        return null;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageQuery#isEntryStored(java.lang.String, java.lang.String)
-     */
-    @Override
-    protected boolean isEntryStored(String entryId, String feedId) throws IOException {
-        
-        return booleanReturn;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageQuery#isFeedStored(java.lang.String)
-     */
-    @Override
-    public boolean isFeedStored(String feedId) throws IOException {
-        
-        return booleanReturn;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.lucenestorage.StorageQuery#singleEntryQuery(java.lang.String, java.lang.String, org.apache.lucene.gdata.server.registry.ProvidedService)
-     */
-    @Override
-    public BaseEntry singleEntryQuery(String entryId, String feedId, ProvidedService config) throws IOException, ParseException {
-        
-        return null;
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/TestModifiedEntryFilter.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/TestModifiedEntryFilter.java
deleted file mode 100644
index 2d94209..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/TestModifiedEntryFilter.java
+++ /dev/null
@@ -1,70 +0,0 @@
-package org.apache.lucene.gdata.storage.lucenestorage; 
- 
-import java.io.IOException; 
-import java.util.ArrayList; 
-import java.util.List; 
- 
-import junit.framework.TestCase; 
- 
-import org.apache.lucene.analysis.standard.StandardAnalyzer; 
-import org.apache.lucene.document.Document; 
-import org.apache.lucene.document.Field; 
-import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper; 
-import org.apache.lucene.gdata.utils.ModifiedEntryFilter;
-import org.apache.lucene.index.IndexReader; 
-import org.apache.lucene.index.IndexWriter; 
-import org.apache.lucene.index.Term; 
-import org.apache.lucene.search.Hits; 
-import org.apache.lucene.search.IndexSearcher; 
-import org.apache.lucene.search.Query; 
-import org.apache.lucene.search.Searcher; 
-import org.apache.lucene.search.TermQuery; 
-import org.apache.lucene.store.RAMDirectory; 
- 
-public class TestModifiedEntryFilter extends TestCase { 
-    IndexWriter writer; 
-    IndexReader reader; 
-    List<String> excludeList; 
-    String feedID = "feed"; 
-    String fieldFeedId = "feedID"; 
-    protected void setUp() throws Exception { 
-        RAMDirectory dir = new RAMDirectory(); 
-        this.writer = new IndexWriter(dir,new StandardAnalyzer(),true); 
-        Document doc = new Document(); 
-        doc.add(new Field(StorageEntryWrapper.FIELD_ENTRY_ID,"1",Field.Store.YES,Field.Index.UN_TOKENIZED)); 
-        doc.add(new Field(fieldFeedId,feedID,Field.Store.YES,Field.Index.UN_TOKENIZED)); 
-        Document doc1 = new Document(); 
-        doc1.add(new Field(StorageEntryWrapper.FIELD_ENTRY_ID,"2",Field.Store.YES,Field.Index.UN_TOKENIZED)); 
-        doc1.add(new Field(fieldFeedId,feedID,Field.Store.YES,Field.Index.UN_TOKENIZED)); 
-        this.writer.addDocument(doc); 
-        this.writer.addDocument(doc1); 
-        this.writer.close(); 
-        this.reader = IndexReader.open(dir); 
-        this.excludeList = new ArrayList(); 
-        this.excludeList.add("1"); 
-         
-         
-    } 
- 
-    protected void tearDown() throws Exception { 
-        super.tearDown(); 
-    } 
-    public void testFilter() throws IOException{ 
-        Searcher s = new IndexSearcher(this.reader); 
-        Query q = new TermQuery(new Term(fieldFeedId,feedID)); 
-        Hits hits = s.search(q); 
-        assertEquals(2,hits.length()); 
-         
-        hits = s.search(q,new ModifiedEntryFilter(this.excludeList.toArray(new String[0]),StorageEntryWrapper.FIELD_ENTRY_ID)); 
-        assertEquals(1,hits.length()); 
-        this.excludeList.add("2"); 
- 
-        hits = s.search(q,new ModifiedEntryFilter(this.excludeList.toArray(new String[0]),StorageEntryWrapper.FIELD_ENTRY_ID)); 
-        assertEquals(0,hits.length());
-        this.excludeList.add(null);
-        this.excludeList.add("5"); 
-        hits = s.search(q,new ModifiedEntryFilter(this.excludeList.toArray(new String[0]),StorageEntryWrapper.FIELD_ENTRY_ID)); 
-        assertEquals(0,hits.length()); 
-         
-    } 
-} 
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/TestSingelHostConcurrencyLock.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/TestSingelHostConcurrencyLock.java
deleted file mode 100755
index c125768..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/TestSingelHostConcurrencyLock.java
+++ /dev/null
@@ -1,148 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.storage.lucenestorage;
-
-import org.apache.lucene.gdata.storage.lucenestorage.SingleHostConcurrentStorageLock.ConcurrencyException;
-
-import junit.framework.TestCase;
-
-public class TestSingelHostConcurrencyLock extends TestCase {
-    SingleHostConcurrentStorageLock lock;
-    boolean threadResult = false;
-    protected void setUp() throws Exception {
-        this.lock = (SingleHostConcurrentStorageLock)SingleHostConcurrentStorageLock.getConcurrentStorageLock();
-        super.setUp();
-    }
-
-    protected void tearDown() throws Exception {
-        super.tearDown();
-        threadResult = false;
-        this.lock.close();
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.SingleHostConcurrentStorageLock.getConcurrentStorageLock()'
-     */
-    public void testGetConcurrentStorageLock() {
-        ConcurrentStorageLock lock = SingleHostConcurrentStorageLock.getConcurrentStorageLock();
-        assertEquals(lock,SingleHostConcurrentStorageLock.getConcurrentStorageLock() );
-        
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.SingleHostConcurrentStorageLock.setLock(String)'
-     */
-    public void testSetLock() throws InterruptedException {
-        final String key = "someKey";
-        final String nextKey = "fooKey";
-        assertTrue(lock.setLock(key));
-        assertTrue(lock.isKeyLocked(key));
-        
-        try{
-            this.lock.setLock(key);
-            fail("thread has already locked the key");
-        }catch (Exception e) {
-            // TODO: handle exception
-        }
-        
-        try{
-            assertTrue(lock.setLock(nextKey));
-            fail("thread has already locked the key");
-        }catch (Exception e) {
-            // TODO: handle exception
-        }
-        
-        Thread t = new Thread(new Runnable(){
-            public void run(){
-                threadResult = lock.setLock(key);
-              
-                
-                
-            }
-        });
-        t.start();
-        t.join(300);
-        assertFalse(threadResult);
-        
-        t = new Thread(new Runnable(){
-            public void run(){
-                threadResult = lock.setLock(nextKey);
-              
-                
-                
-            }
-        });
-        t.start();
-        t.join(300);
-        assertTrue(threadResult);
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.SingleHostConcurrentStorageLock.releaseLock(String)'
-     */
-    public void testReleaseLock() throws InterruptedException {
-        final String key = "someKey";
-        final String nextKey = "fooKey";
-        assertTrue(lock.setLock(key));
-        assertTrue(lock.isKeyLocked(key));
-        assertTrue(lock.releaseLock(key));
-        assertTrue(this.lock.setLock(key));
-        try{
-            assertTrue(lock.setLock(nextKey));
-            fail("thread has already locked the key");
-        }catch (Exception e) {
-            // TODO: handle exception
-        }
-        
-        Thread t = new Thread(new Runnable(){
-            public void run(){
-                threadResult = lock.setLock(nextKey);
-            }
-        });
-        t.start();
-        t.join(300);
-        assertTrue(threadResult);
-        try{
-        this.lock.releaseLock(nextKey);
-           fail("current thread is not owner");
-        }catch (ConcurrencyException e) {
-            // TODO: handle exception
-        }
-
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.SingleHostConcurrentStorageLock.releaseThreadLocks()'
-     */
-    public void testReleaseThreadLocks() {
-        
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.SingleHostConcurrentStorageLock.isKeyLocked(String)'
-     */
-    public void testIsKeyLocked() {
-
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.SingleHostConcurrentStorageLock.close()'
-     */
-    public void testClose() {
-
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/TestStorageBuffer.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/TestStorageBuffer.java
deleted file mode 100755
index d43154f..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/TestStorageBuffer.java
+++ /dev/null
@@ -1,251 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.storage.lucenestorage;
-
-import java.io.IOException;
-import java.util.List;
-
-import junit.framework.TestCase;
-
-import org.apache.lucene.gdata.data.ServerBaseEntry;
-import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper.StorageOperation;
-import org.apache.lucene.gdata.utils.ProvidedServiceStub;
-
-import com.google.gdata.data.DateTime;
-
-public class TestStorageBuffer extends TestCase {
-    private static final String FEEDID = "feed";
-    private static final String ENTRYID = "someID";
-    private StorageBuffer buffer;
-    protected void setUp() throws Exception {
-        super.setUp();
-        this.buffer = new StorageBuffer(10);
-    }
-
-    protected void tearDown() throws Exception {
-        this.buffer.close();
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.StorageBuffer.StorageBuffer(int)'
-     */
-    public void testStorageBuffer() {
-        assertEquals(StorageBuffer.DEFAULT_BUFFER_COUNT,new StorageBuffer(StorageBuffer.DEFAULT_BUFFER_COUNT-1).getBufferSize());
-        assertEquals(StorageBuffer.DEFAULT_BUFFER_COUNT,new StorageBuffer(StorageBuffer.DEFAULT_BUFFER_COUNT).getBufferSize());
-        assertEquals(StorageBuffer.DEFAULT_BUFFER_COUNT+1,new StorageBuffer(StorageBuffer.DEFAULT_BUFFER_COUNT+1).getBufferSize());
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.StorageBuffer.addEntry(StorageEntryWrapper)'
-     */
-    public void testAddEntry() throws IOException {
-        
-        ServerBaseEntry e = createServerBaseEntry(ENTRYID,FEEDID);
-        StorageEntryWrapper wrapper = new StorageEntryWrapper(e,StorageOperation.INSERT);
-        this.buffer.addEntry(wrapper);
-        assertEquals(1,this.buffer.getSortedEntries(FEEDID).size());
-        this.buffer.addEntry(wrapper);
-        assertEquals(1,this.buffer.getSortedEntries(FEEDID).size());
-        
-        e.setId("someotherID");
-        e.setFeedId(FEEDID);
-        e.setServiceConfig(new ProvidedServiceStub());
-        wrapper = new StorageEntryWrapper(e,StorageOperation.INSERT);
-        this.buffer.addEntry(wrapper);
-        assertEquals(2,this.buffer.getSortedEntries(FEEDID).size());
-        e.setId("someotherID");
-        e.setFeedId("someOtherFeed");
-        e.setServiceConfig(new ProvidedServiceStub());
-        wrapper = new StorageEntryWrapper(e,StorageOperation.UPDATE);
-        this.buffer.addEntry(wrapper);
-        wrapper = new StorageEntryWrapper(e,StorageOperation.DELETE);
-        e.setId("deleted and ingnored");
-        e.setFeedId("someOtherFeed");
-        e.setServiceConfig(new ProvidedServiceStub());
-        this.buffer.addEntry(wrapper);
-        assertEquals(2,this.buffer.getSortedEntries(FEEDID).size());
-        assertEquals(1,this.buffer.getSortedEntries("someOtherFeed").size());
-        assertEquals("Contains 2 different IDs",2,this.buffer.getExculdList().length);
-        
-    }
-    /*
-     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.StorageBuffer.addDeleted(String, String)'
-     */
-    public void testAddDeleted() throws IOException {
-        
-        this.buffer.addDeleted(ENTRYID,FEEDID);
-        assertNull(this.buffer.getSortedEntries(FEEDID));
-        assertEquals(1,this.buffer.getExculdList().length);
-        assertEquals(ENTRYID,this.buffer.getExculdList()[0]);
-        
-        this.buffer.addDeleted(ENTRYID,FEEDID);
-        assertNull(this.buffer.getSortedEntries(FEEDID));
-        assertEquals(1,this.buffer.getExculdList().length);
-        assertEquals(ENTRYID,this.buffer.getExculdList()[0]);
-        
-        
-    }
-    /*
-     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.StorageBuffer.getFeedLastModified(String)'
-     */
-    public void testGetFeedLastModified() throws IOException, InterruptedException {
-        ServerBaseEntry e = createServerBaseEntry(ENTRYID,FEEDID);
-        e.setUpdated(new DateTime(System.currentTimeMillis()-200,0));
-        StorageEntryWrapper wrapper = new StorageEntryWrapper(e,StorageOperation.INSERT);
-        this.buffer.addEntry(wrapper);
-        assertEquals(new Long(e.getUpdated().getValue()),this.buffer.getFeedLastModified(FEEDID));
-        //test update
-//      force timestamp
-        e.setUpdated(new DateTime(System.currentTimeMillis()-180,0));
-        wrapper = new StorageEntryWrapper(e,StorageOperation.UPDATE);
-        this.buffer.addEntry(wrapper);
-        Long firstAddTimestamp = new Long(e.getUpdated().getValue());
-        assertEquals(firstAddTimestamp,this.buffer.getFeedLastModified(FEEDID));
-//      force timestamp
-        e.setUpdated(new DateTime(System.currentTimeMillis()-160,0));
-        assertFalse("updated after add" ,e.getUpdated().equals(this.buffer.getFeedLastModified(FEEDID)));
-        
-        //insert for other feed
-        String otherID = "someOtherFeedID";
-        e.setFeedId(otherID);
-//      force timestamp
-        e.setUpdated(new DateTime(System.currentTimeMillis()-140,0));
-        wrapper = new StorageEntryWrapper(e,StorageOperation.INSERT);
-        this.buffer.addEntry(wrapper);
-        assertEquals(new Long(e.getUpdated().getValue()),this.buffer.getFeedLastModified(otherID));
-        assertEquals(firstAddTimestamp,this.buffer.getFeedLastModified(FEEDID));
-        
-        assertTrue(firstAddTimestamp.equals(this.buffer.getFeedLastModified(FEEDID)));
-        this.buffer.addDeleted(e.getId(),FEEDID);
-        // time will be set inside the buffer
-        assertTrue(firstAddTimestamp < this.buffer.getFeedLastModified(FEEDID));
-        
-        
-    }
-    
-  
-    /*
-     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.StorageBuffer.getSortedEntries(String)'
-     */
-    public void testGetSortedEntries() throws IOException, InterruptedException {
-        assertNull(this.buffer.getSortedEntries(FEEDID));
-        ServerBaseEntry e = createServerBaseEntry("2",FEEDID);
-        e.setUpdated(new DateTime(System.currentTimeMillis()-200,0));
-        StorageEntryWrapper wrapper = new StorageEntryWrapper(e,StorageOperation.INSERT);
-        this.buffer.addEntry(wrapper);
-        e.setId("0");
-//      force timestamp
-        e.setUpdated(new DateTime(System.currentTimeMillis()-180,0));
-        wrapper = new StorageEntryWrapper(e,StorageOperation.INSERT);
-        this.buffer.addEntry(wrapper);
-        e.setId("1");
-//      force timestamp
-        e.setUpdated(new DateTime(System.currentTimeMillis()-160,0));
-        wrapper = new StorageEntryWrapper(e,StorageOperation.INSERT);
-        this.buffer.addEntry(wrapper);
-        e.setId("0");
-//      force timestamp
-        e.setUpdated(new DateTime(System.currentTimeMillis()-140,0));
-        wrapper = new StorageEntryWrapper(e,StorageOperation.UPDATE);
-        this.buffer.addEntry(wrapper);
-//      force timestamp
-        e.setUpdated(new DateTime(System.currentTimeMillis()-120,0));
-        wrapper = new StorageEntryWrapper(e,StorageOperation.DELETE);
-        this.buffer.addEntry(wrapper);
-        List<StorageEntryWrapper> list = this.buffer.getSortedEntries(FEEDID);
-       assertEquals(3,list.size());
-        for (int i = 0; i < 3; i++) {
-            assertEquals(""+i,list.get(i).getEntryId());   
-        }
-        
-
-    }
-
-  
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.StorageBuffer.getEntry(String, String)'
-     */
-    public void testGetEntry() throws IOException {
-        assertNull(this.buffer.getEntry(ENTRYID,FEEDID));
-        ServerBaseEntry e = createServerBaseEntry(ENTRYID,FEEDID);
-        StorageEntryWrapper wrapper = new StorageEntryWrapper(e,StorageOperation.INSERT);
-        this.buffer.addEntry(wrapper);
-        assertSame(wrapper,this.buffer.getEntry(ENTRYID,FEEDID));
-        
-        e = createServerBaseEntry("0",FEEDID);
-        wrapper = new StorageEntryWrapper(e,StorageOperation.UPDATE);
-        this.buffer.addEntry(wrapper);
-        assertSame(wrapper,this.buffer.getEntry("0",FEEDID));
-        
-        
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.StorageBuffer.getExculdList()'
-     */
-    public void testGetExculdList() throws IOException {
-        ServerBaseEntry e = createServerBaseEntry(ENTRYID,FEEDID);
-        StorageEntryWrapper wrapper = new StorageEntryWrapper(e,StorageOperation.INSERT);
-        this.buffer.addEntry(wrapper);
-        this.buffer.addEntry(wrapper);
-        assertEquals(1,this.buffer.getExculdList().length);
-        assertEquals(wrapper.getEntryId(),this.buffer.getExculdList()[0]);
-        
-        wrapper = new StorageEntryWrapper(e,StorageOperation.UPDATE);
-        this.buffer.addEntry(wrapper);
-        assertEquals(1,this.buffer.getExculdList().length);
-        assertEquals(wrapper.getEntryId(),this.buffer.getExculdList()[0]);
-        this.buffer.addDeleted(ENTRYID,FEEDID);
-        assertEquals(1,this.buffer.getExculdList().length);
-        assertEquals(wrapper.getEntryId(),this.buffer.getExculdList()[0]);
-        
-         e = createServerBaseEntry("someOtherEntry","someOtherFeed");
-        wrapper = new StorageEntryWrapper(e,StorageOperation.INSERT);
-        this.buffer.addEntry(wrapper);
-        this.buffer.addEntry(wrapper);
-        assertEquals(2,this.buffer.getExculdList().length);
-        
-        
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.StorageBuffer.close()'
-     */
-    public void testClose() throws IOException {
-        ServerBaseEntry e = createServerBaseEntry(ENTRYID,FEEDID);
-        StorageEntryWrapper wrapper = new StorageEntryWrapper(e,StorageOperation.INSERT);
-        
-        this.buffer.addEntry(wrapper);
-        assertNotNull(this.buffer.getSortedEntries(FEEDID));
-        assertNotNull(this.buffer.getEntry(ENTRYID,FEEDID));
-        assertEquals(1,this.buffer.getExculdList().length);
-        this.buffer.close();
-        assertNull(this.buffer.getSortedEntries(FEEDID));
-        assertNull(this.buffer.getEntry(ENTRYID,FEEDID));
-        assertEquals(0,this.buffer.getExculdList().length);
-        
-        
-
-    }
-    public ServerBaseEntry createServerBaseEntry(String entryID, String feedId) throws IOException{
-        ServerBaseEntry e = new ServerBaseEntry();
-        e.setId(entryID);
-        e.setFeedId(feedId);
-        e.setServiceConfig(new ProvidedServiceStub());
-       return e;
-    }
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/TestStorageImplementation.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/TestStorageImplementation.java
deleted file mode 100755
index 8f76d7e..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/TestStorageImplementation.java
+++ /dev/null
@@ -1,458 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.storage.lucenestorage;
-
-import java.util.concurrent.atomic.AtomicBoolean;
-
-import junit.framework.TestCase;
-
-import org.apache.lucene.gdata.data.ServerBaseEntry;
-import org.apache.lucene.gdata.server.registry.ComponentType;
-import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
-import org.apache.lucene.gdata.server.registry.ProvidedService;
-import org.apache.lucene.gdata.storage.ModificationConflictException;
-import org.apache.lucene.gdata.storage.Storage;
-import org.apache.lucene.gdata.storage.StorageController;
-import org.apache.lucene.gdata.storage.StorageException;
-import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper.StorageOperation;
-import org.apache.lucene.gdata.utils.MultiThreadEntryStub;
-import org.apache.lucene.gdata.utils.ProvidedServiceStub;
-import org.apache.lucene.gdata.utils.Visitor;
-
-import com.google.gdata.data.DateTime;
-
-public class TestStorageImplementation extends TestCase {
-    private static GDataServerRegistry reg = null;
-
-    private Storage storage;
-
-    public static boolean fail = false;
-
-    protected void setUp() throws Exception {
-
-        if (reg == null) {
-            reg = GDataServerRegistry.getRegistry();
-            if(reg.lookup(StorageController.class,ComponentType.STORAGECONTROLLER)!= null);
-                reg.destroy();
-            reg.registerComponent(StorageCoreControllerStub.class,null);
-
-        }
-        this.storage = reg.lookup(StorageController.class,
-                ComponentType.STORAGECONTROLLER).getStorage();
-    }
-
-    protected void tearDown() throws Exception {
-        this.storage.close();
-        fail = false;
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.storage.lucenestorage.StorageImplementation.storeEntry(ServerBaseEntry)'
-     */
-    public void testStoreEntry() {
-
-        try {
-            this.storage.storeEntry(null);
-            fail("entry is null");
-        } catch (StorageException e) {
-            //
-        }
-        ServerBaseEntry entry = new ServerBaseEntry();
-        entry.setServiceConfig(new ProvidedServiceStub());
-
-        try {
-            this.storage.storeEntry(entry);
-            fail("feed is null");
-        } catch (StorageException e) {
-            //
-        }
-
-        entry.setFeedId("someID");
-        try {
-            this.storage.storeEntry(entry);
-
-        } catch (StorageException e1) {
-            fail("unexpected exception");
-
-        }
-        entry.setServiceConfig(null);
-        try {
-            this.storage.storeEntry(entry);
-            fail("no service config");
-        } catch (StorageException e) {
-
-        }
-        entry.setVersion(5);
-        try {
-            this.storage.storeEntry(entry);
-            fail("version is greater than 1");
-        } catch (StorageException e) {
-
-        }
-
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.storage.lucenestorage.StorageImplementation.deleteEntry(ServerBaseEntry)'
-     */
-    public void testDeleteEntry() throws InterruptedException {
-        try {
-            this.storage.storeEntry(null);
-            fail("entry is null");
-        } catch (StorageException e) {
-            //
-        }
-        ServerBaseEntry entry = new ServerBaseEntry();
-        entry.setServiceConfig(new ProvidedServiceStub());
-        entry.setId("someID");
-        entry.setFeedId("someID");
-        try {
-            this.storage.storeEntry(entry);
-
-        } catch (StorageException e) {
-            fail("unexpected exception");
-            //
-        }
-        entry.setFeedId(null);
-        try {
-            this.storage.deleteEntry(entry);
-            fail("feed is null");
-        } catch (StorageException e) {
-            //
-        }
-
-        entry.setFeedId("someID");
-        try {
-            this.storage.deleteEntry(entry);
-
-        } catch (StorageException e1) {
-            e1.printStackTrace();
-            fail("unexpected exception");
-
-        }
-        entry.setFeedId("someID");
-        
-        try {
-            this.storage.deleteEntry(entry);
-
-        } catch (StorageException e1) {
-            e1.printStackTrace();
-            fail("unexpected exception");
-
-        }
-        
-        
-        
-        Object monitor = new Object();
-        AtomicBoolean reached = new AtomicBoolean(false);
-
-        MultiThreadEntryStub concuEntry = new MultiThreadEntryStub();
-        concuEntry.setId(System.currentTimeMillis() + "");
-        ProvidedService conf = new ProvidedServiceStub();
-        
-        concuEntry.setServiceConfig(conf);
-        concuEntry.setUpdated(DateTime.now());
-        concuEntry.setFeedId("feed");
-        this.storage.storeEntry(concuEntry);
-        storage.close();
-        concuEntry.acceptGetVersionVisitor(getMonitorVisitor(monitor,reached));
-
-
-        Thread t1 = getDelThread(storage, concuEntry, false);
-
-        Thread t2 = getDelThread(storage, concuEntry, true);
-        t1.start();
-        /*
-         * Wait active -- not nice but works fine here
-         * wait until thread parked
-         */
-
-        while (true) {
-            synchronized (monitor) {
-                if (reached.get())
-                    break;
-                monitor.wait(10);
-            }
-        }
-        t2.start();
-        t2.join(800);
-        /*
-         * Wait active -- not nice but works fine here
-         * wake up the waiting thread
-         */
-        while (true) {
-            synchronized (monitor) {
-                if (!reached.get())
-                    break;
-                monitor.notifyAll();
-            }
-        }
-        t1.join(300);
-        if (fail)
-            fail("thread failed -- see stacktrace");
-       
-       
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.storage.lucenestorage.StorageImplementation.updateEntry(ServerBaseEntry)'
-     */
-    public void testUpdateEntry() throws InterruptedException {
-        Object monitor = new Object();
-        AtomicBoolean reached = new AtomicBoolean(false);
-
-        MultiThreadEntryStub concuEntry = new MultiThreadEntryStub();
-        concuEntry.setId(System.currentTimeMillis() + "");
-        ProvidedService conf = new ProvidedServiceStub();
-        
-        concuEntry.setServiceConfig(conf);
-        concuEntry.setUpdated(DateTime.now());
-        concuEntry.setFeedId("feed");
-        this.storage.storeEntry(concuEntry);
-        storage.close();
-        concuEntry.acceptGetEntryVisitor(getMonitorVisitor(monitor,reached));
-
-
-        Thread t1 = getUpdThread(storage, concuEntry, false);
-
-        Thread t2 = getUpdThread(storage, concuEntry, true);
-        t1.start();
-        /*
-         * Wait active -- not nice but works fine here
-         * wait until thread parked
-         */
-
-        while (true) {
-            synchronized (monitor) {
-                if (reached.get())
-                    break;
-                monitor.wait(10);
-            }
-        }
-        t2.start();
-        t2.join(800);
-        /*
-         * Wait active -- not nice but works fine here
-         * wake up the waiting thread
-         */
-        while (true) {
-            synchronized (monitor) {
-                if (!reached.get())
-                    break;
-                monitor.notifyAll();
-            }
-        }
-        t1.join(300);
-        if (fail)
-            fail("thread failed -- see stacktrace");
-
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.storage.lucenestorage.StorageImplementation.getFeed(ServerBaseFeed)'
-     */
-    public void testGetFeed() {
-
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.storage.lucenestorage.StorageImplementation.getEntry(ServerBaseEntry)'
-     */
-    public void testGetEntry() {
-
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.storage.lucenestorage.StorageImplementation.close()'
-     */
-    public void testClose() {
-
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.storage.lucenestorage.StorageImplementation.storeAccount(GDataAccount)'
-     */
-    public void testStoreAccount() {
-
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.storage.lucenestorage.StorageImplementation.updateAccount(GDataAccount)'
-     */
-    public void testUpdateAccount() {
-
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.storage.lucenestorage.StorageImplementation.deleteAccount(String)'
-     */
-    public void testDeleteAccount() {
-
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.storage.lucenestorage.StorageImplementation.storeFeed(ServerBaseFeed,
-     * String)'
-     */
-    public void testStoreFeed() {
-
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.storage.lucenestorage.StorageImplementation.deleteFeed(String)'
-     */
-    public void testDeleteFeed() {
-
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.storage.lucenestorage.StorageImplementation.updateFeed(ServerBaseFeed,
-     * String)'
-     */
-    public void testUpdateFeed() {
-
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.storage.lucenestorage.StorageImplementation.getServiceForFeed(String)'
-     */
-    public void testGetServiceForFeed() {
-
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.storage.lucenestorage.StorageImplementation.getAccount(String)'
-     */
-    public void testGetAccount() {
-
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.storage.lucenestorage.StorageImplementation.getAccountNameForFeedId(String)'
-     */
-    public void testGetAccountNameForFeedId() {
-
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.storage.lucenestorage.StorageImplementation.getEntryLastModified(String,
-     * String)'
-     */
-    public void testGetEntryLastModified() {
-
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.storage.lucenestorage.StorageImplementation.getFeedLastModified(String)'
-     */
-    public void testGetFeedLastModified() {
-
-    }
-    static class Runner implements Runnable {
-        Storage s;
-
-        StorageController c;
-
-        ServerBaseEntry e;
-
-        boolean expConf;
-
-        StorageOperation op;
-
-        public Runner(Storage s, ServerBaseEntry e,
-                boolean expectConflict, StorageOperation op) {
-            this.s = s;
-            this.e = e;
-            this.expConf = expectConflict;
-            this.op = op;
-        }
-
-        public void run() {
-           
-            try {
-                if (this.op == StorageOperation.DELETE)
-                    this.s.deleteEntry(e);
-                if (this.op == StorageOperation.UPDATE)
-                    this.s.updateEntry(e);
-                if (expConf)
-                    fail = true;
-            } catch (ModificationConflictException ex) {
-                if (!expConf)
-                    fail = true;
-                ex.printStackTrace();
-
-            } catch (StorageException ex) {
-                ex.printStackTrace();
-                fail = true;
-            }
-
-        }
-    }
-    
-    private Visitor getMonitorVisitor(final Object monitor, final AtomicBoolean reached){
-        /*
-         * The executing thread stops at a defined position while holding the semaphore inside the storageImpl
-         */
-        return new Visitor(){
-          public void execute(Object[] o){
-            synchronized (monitor) {
-            try {
-                reached.set(true);
-                monitor.wait();
-                reached.set(false);
-              
-            } catch (InterruptedException e) {
-                //                   
-            }
-            }
-          }
-        };
-    }
-
-    private Thread getDelThread(Storage s, ServerBaseEntry e,
-            boolean conflictExpected) {
-        Thread t1 = new Thread(new Runner(s, e, conflictExpected,
-                StorageOperation.DELETE));
-        t1.setPriority(Thread.MAX_PRIORITY);
-        return t1;
-    }
-
-    private Thread getUpdThread(Storage s, ServerBaseEntry e,
-            boolean conflictExpected) {
-        Thread t1 = new Thread(new Runner(s, e, conflictExpected,
-                StorageOperation.UPDATE));
-        t1.setPriority(Thread.MAX_PRIORITY);
-        return t1;
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/TestStorageModifier.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/TestStorageModifier.java
deleted file mode 100644
index 91da27c..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/TestStorageModifier.java
+++ /dev/null
@@ -1,419 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.storage.lucenestorage;
-
-import java.io.IOException;
-
-import junit.framework.TestCase;
-
-import org.apache.lucene.gdata.data.GDataAccount;
-import org.apache.lucene.gdata.data.ServerBaseEntry;
-import org.apache.lucene.gdata.data.ServerBaseFeed;
-import org.apache.lucene.gdata.server.registry.ProvidedService;
-import org.apache.lucene.gdata.storage.StorageException;
-import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper.StorageOperation;
-import org.apache.lucene.gdata.utils.ProvidedServiceStub;
-import org.apache.lucene.gdata.utils.ReferenceCounter;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.BooleanClause;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.Hits;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.RAMDirectory;
-
-import com.google.gdata.data.BaseEntry;
-import com.google.gdata.data.DateTime;
-import com.google.gdata.data.Entry;
-import com.google.gdata.data.PlainTextConstruct;
-import com.google.gdata.data.TextContent;
-import com.google.gdata.util.ParseException;
-
-public class TestStorageModifier extends TestCase {
-    private StorageModifier modifier;
-
-    private int count = 1;
-
-    private ProvidedService configurator;
-
-    private Directory dir;
-
-    private StorageCoreController controller;
-
-    private static String feedId = "myFeed";
-
-    private static String username = "simon";
-
-    private static String password = "test";
-    private static String service = "myService";
-
-    protected void setUp() throws Exception {
-        this.controller = new StorageCoreController();
-        this.dir = new RAMDirectory();
-        this.controller.setStorageDir(this.dir);
-        this.controller.setKeepRecoveredFiles(false);
-        this.controller.setOptimizeInterval(10);
-        this.controller.setRecover(false);
-        this.controller.setBufferSize(10);
-        this.controller.setPersistFactor(10);
-        this.controller.initialize();
-        this.configurator = new ProvidedServiceStub();
-        this.modifier = this.controller.getStorageModifier();
-        this.dir = this.controller.getDirectory();
-
-    }
-
-    protected void tearDown() throws Exception {
-        this.count = 1;
-        // destroy all resources
-        this.controller.destroy();
-        
-
-
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.storage.lucenestorage.StorageModifier.updateEntry(StroageEntryWrapper)'
-     */
-    public void testUpdateEntry() throws IOException, InterruptedException,
-            ParseException, StorageException {
-        testInsertEntry();
-        for (int i = 1; i < this.count; i++) {
-            Entry e = new Entry();
-            e.setId("" + i);
-            String insertString = "Hello world" + i;
-            e.setTitle(new PlainTextConstruct(insertString));
-            ServerBaseEntry en = getServerEntry(e);
-            StorageEntryWrapper wrapper = new StorageEntryWrapper(en,
-                    StorageOperation.UPDATE);
-            this.modifier.updateEntry(wrapper);
-            ReferenceCounter<StorageQuery> innerQuery = this.controller
-                    .getStorageQuery();
-            BaseEntry fetchedEntry = innerQuery.get().singleEntryQuery("" + i,
-                    feedId, this.configurator);
-            assertEquals("updated Title:", insertString, fetchedEntry
-                    .getTitle().getPlainText());
-        }
-        // double updates
-        for (int i = 1; i < this.count; i++) {
-            Entry e = new Entry();
-            e.setId("" + i);
-            String insertString = "Hello world" + i;
-            e.setTitle(new PlainTextConstruct(insertString));
-            ServerBaseEntry en = getServerEntry(e);
-            StorageEntryWrapper wrapper = new StorageEntryWrapper(en,
-                    StorageOperation.UPDATE);
-            this.modifier.updateEntry(wrapper);
-
-            e = new Entry();
-            e.setId("" + i);
-            insertString = "Foo Bar" + i;
-            e.setTitle(new PlainTextConstruct(insertString));
-            en = getServerEntry(e);
-            wrapper = new StorageEntryWrapper(en,
-                    StorageOperation.UPDATE);
-            this.modifier.updateEntry(wrapper);
-
-            ReferenceCounter<StorageQuery> innerQuery = this.controller
-                    .getStorageQuery();
-
-            BaseEntry fetchedEntry = innerQuery.get().singleEntryQuery("" + i,
-                    feedId, this.configurator);
-            assertEquals("updated Title:", insertString, fetchedEntry
-                    .getTitle().getPlainText());
-        }
-        
-       
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.storage.lucenestorage.StorageModifier.insertEntry(StroageEntryWrapper)'
-     */
-    public void testInsertEntry() throws IOException, InterruptedException,
-            ParseException, StorageException {
-
-        Thread a = getRunnerThread(this.count);
-        
-
-        Thread b = getRunnerThread((this.count += 10));
-        b.start();
-        a.start();
-//         wait for the first thread to check for the inserted entries
-        a.join();  
-        try{
-        for (int i = 1; i < this.count; i++) {
-           
-            ReferenceCounter<StorageQuery> innerQuery = this.controller
-                    .getStorageQuery();
-            BaseEntry e = innerQuery.get().singleEntryQuery("" + i, feedId,
-                    this.configurator);
-            assertNotNull(e);
-            assertEquals("get entry for id" + i, "" + i, e.getId());
-
-        }
-        }finally{
-        	/*
-        	 * if an exception occures the tread can at least finnish running before the
-        	 * controller will be closed in the tearDown method
-        	 */
-        	 b.join();	
-        }
-      
-       
-        ReferenceCounter<StorageQuery> query = this.controller
-                .getStorageQuery();
-
-        this.count += 10;
-        for (int i = 1; i < this.count; i++) {
-            BaseEntry e = query.get().singleEntryQuery("" + i, feedId,
-                    this.configurator);
-            assertEquals("get entry for id" + i, "" + i, e.getId());
-        }
-
-        BaseEntry e = query.get().singleEntryQuery("" + this.count, feedId,
-                this.configurator);
-        assertNull("not entry for ID", e);
-        query.decrementRef();
-
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.storage.lucenestorage.StorageModifier.deleteEntry(String)'
-     */
-    public void testDeleteEntry() throws IOException, InterruptedException,
-            ParseException, StorageException {
-        testInsertEntry();
-        for (int i = 1; i < this.count; i++) {
-            if (i % 2 == 0 || i < 10) {
-                ServerBaseEntry entry = new ServerBaseEntry();
-                entry.setId("" + i);
-                entry.setFeedId(feedId);
-                this.modifier.deleteEntry(new StorageEntryWrapper(entry,StorageOperation.DELETE));
-            }
-            ReferenceCounter<StorageQuery> query = this.controller
-                    .getStorageQuery();
-            if (i % 2 == 0 || i < 10) {
-                assertNull(query.get().singleEntryQuery("" + i, feedId,
-                        this.configurator));
-            } else
-                assertEquals("" + i, query.get().singleEntryQuery("" + i,
-                        feedId, this.configurator).getId());
-            query.decrementRef();
-        }
-
-        this.controller.forceWrite();
-        IndexSearcher searcher = new IndexSearcher(this.dir);
-
-        for (int i = 1; i < this.count; i++) {
-            Query luceneQuery = new TermQuery(new Term(
-                    StorageEntryWrapper.FIELD_ENTRY_ID, "" + i));
-            Hits hits = searcher.search(luceneQuery);
-            if (i % 2 == 0 || i < 10) {
-
-                assertEquals(0, hits.length());
-            } else
-                assertEquals(1, hits.length());
-        }
-        searcher.close();
-
-    }
-
-    public void testSaveUser() throws StorageException, IOException {
-
-        GDataAccount user = new GDataAccount();
-        user.setName(username);
-        user.setPassword(password);
-        StorageAccountWrapper wrapper = new StorageAccountWrapper(user);
-        this.modifier.createAccount(wrapper);
-        IndexSearcher searcher = new IndexSearcher(this.dir);
-        Query q = new TermQuery(new Term(StorageAccountWrapper.FIELD_ACCOUNTNAME,
-                username));
-        Hits h = searcher.search(q);
-        assertEquals("length == 1", 1, h.length());
-        GDataAccount storedUser = StorageAccountWrapper.buildEntity(h.doc(0));
-        assertTrue(storedUser.equals(user));
-        searcher.close();
-    }
-
-    public void testDeleteUser() throws StorageException, IOException {
-        testSaveUser();
-        this.modifier.deleteAccount(username);
-        IndexSearcher searcher = new IndexSearcher(this.dir);
-        Query q = new TermQuery(new Term(StorageAccountWrapper.FIELD_ACCOUNTNAME,
-                username));
-        Hits h = searcher.search(q);
-        assertEquals("length == 0", 0, h.length());
-        searcher.close();
-    }
-
-    public void testUpdateUser() throws StorageException, IOException {
-        testSaveUser();
-        GDataAccount user = new GDataAccount();
-        user.setName(username);
-        user.setPassword("newPass");
-        StorageAccountWrapper wrapper = new StorageAccountWrapper(user);
-        this.modifier.updateAccount(wrapper);
-        IndexSearcher searcher = new IndexSearcher(this.dir);
-        Query q = new TermQuery(new Term(StorageAccountWrapper.FIELD_ACCOUNTNAME,
-                username));
-        Hits h = searcher.search(q);
-        assertEquals("length == 1", 1, h.length());
-        GDataAccount storedUser = StorageAccountWrapper.buildEntity(h.doc(0));
-        assertTrue(storedUser.equals(user));
-
-        assertFalse(storedUser.getPassword().equals(password));
-        searcher.close();
-    }
-
-    public void testSaveFeed() throws IOException, StorageException {
-        String title = "myTitle";
-        ServerBaseFeed feed = new ServerBaseFeed();
-        feed.setId(feedId);
-        feed.setTitle(new PlainTextConstruct(title));
-        feed.setServiceType(service);
-        feed.setServiceConfig(this.configurator);
-        StorageFeedWrapper wrapper = new StorageFeedWrapper(feed,username);
-        this.modifier.createFeed(wrapper);
-        
-        IndexSearcher searcher = new IndexSearcher(this.dir);
-        Query q = new TermQuery(new Term(StorageFeedWrapper.FIELD_FEED_ID,
-                feedId));
-        Hits h = searcher.search(q);
-        assertEquals("length == 1", 1, h.length());
-        searcher.close();
-        
-    }
-
-    public void testDeleteFeed() throws IOException, StorageException {
-        testSaveFeed();
-        Entry e = new Entry();
-        e.setTitle(new PlainTextConstruct("hello world"));
-        ServerBaseEntry entry = new ServerBaseEntry(e);
-        entry.setFeedId(feedId);
-        entry.setId("testme");
-        entry.setServiceConfig(this.configurator);
-        StorageEntryWrapper entryWrapper = new StorageEntryWrapper(entry,StorageOperation.INSERT);
-        this.modifier.insertEntry(entryWrapper);
-        this.modifier.forceWrite();
-        this.modifier.deleteFeed(feedId);
-        IndexSearcher searcher = new IndexSearcher(this.dir);
-        Query q = new TermQuery(new Term(StorageFeedWrapper.FIELD_FEED_ID,
-                feedId));
-        Query q1 = new TermQuery(new Term(StorageEntryWrapper.FIELD_FEED_REFERENCE,
-                feedId));
-        BooleanQuery boolQuery = new BooleanQuery();
-        boolQuery.add(q,BooleanClause.Occur.SHOULD);
-        boolQuery.add(q1,BooleanClause.Occur.SHOULD);
-        Hits h = searcher.search(boolQuery);
-        assertEquals("length == 0", 0, h.length());
-        searcher.close();
-        
-        
-        
-    }
-
-    /**
-     * @throws IOException
-     * @throws StorageException
-     */
-    public void testUpdateFeed() throws IOException, StorageException {
-        testSaveFeed();
-        ServerBaseFeed feed = new ServerBaseFeed();
-        String title = "myTitle";
-        String newusername = "doug";
-        feed.setTitle(new PlainTextConstruct(title));
-        feed.setId(feedId);
-        feed.setServiceType(service);
-        feed.setServiceConfig(this.configurator);
-        StorageFeedWrapper wrapper = new StorageFeedWrapper(feed,newusername);
-        this.modifier.updateFeed(wrapper);
-        IndexSearcher searcher = new IndexSearcher(this.dir);
-        Query q = new TermQuery(new Term(StorageFeedWrapper.FIELD_FEED_ID,
-                feedId));
-        Hits h = searcher.search(q);
-        assertEquals("length == 1", 1, h.length());
-        assertTrue(h.doc(0).get(StorageFeedWrapper.FIELD_ACCOUNTREFERENCE).equals(newusername));
-        searcher.close();
-
-    }
-
-    private Thread getRunnerThread(int idIndex) {
-        Thread t = new Thread(new Runner(idIndex));
-        return t;
-    }
-
-    private class Runner implements Runnable {
-        private int idIndex;
-
-        public Runner(int idIndex) {
-            this.idIndex = idIndex;
-        }
-
-        public void run() {
-            for (int i = idIndex; i < idIndex + 10; i++) {
-
-                BaseEntry e = buildEntry("" + i);
-                try {
-                    ServerBaseEntry en = new ServerBaseEntry(e);
-                    en.setFeedId(feedId);
-                    en.setServiceConfig(configurator);
-                    StorageEntryWrapper wrapper = new StorageEntryWrapper(en,
-                            StorageOperation.INSERT);
-                    modifier.insertEntry(wrapper);
-//                    System.out.println("insert: "+i+" Thread: "+Thread.currentThread().getName());
-                } catch (Exception e1) {
-
-                    e1.printStackTrace();
-                }
-
-            }
-
-        }// end run
-
-        private BaseEntry buildEntry(String id) {
-            Entry e = new Entry();
-            e.setId(id);
-            e.setTitle(new PlainTextConstruct("Monty Python"));
-
-            e.setPublished(DateTime.now());
-
-            e.setUpdated(DateTime.now());
-            String content = "1st soldier with a keen interest in birds: Who goes there?"
-                    + "King Arthur: It is I, Arthur, son of Uther Pendragon, from the castle of Camelot. King of the Britons, defeater of the Saxons, Sovereign of all England!"
-                    + "1st soldier with a keen interest in birds: Pull the other one!"
-                    + "King Arthur: I am, and this is my trusty servant Patsy. We have ridden the length and breadth of the land in search of knights who will join me in my court at Camelot. I must speak with your lord and master."
-                    + "1st soldier with a keen interest in birds: What? Ridden on a horse?"
-                    + "King Arthur: Yes!";
-            e.setContent(new TextContent(new PlainTextConstruct(content)));
-            e.setSummary(new PlainTextConstruct("The Holy Grail"));
-            return e;
-        }
-
-    }
-    
-    private ServerBaseEntry getServerEntry(BaseEntry e){
-        ServerBaseEntry en = new ServerBaseEntry(e);
-        en.setFeedId(feedId);
-        en.setServiceConfig(this.configurator);
-        return en;
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/TestStorageQuery.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/TestStorageQuery.java
deleted file mode 100644
index 32fae22..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/TestStorageQuery.java
+++ /dev/null
@@ -1,319 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.storage.lucenestorage;
-
-import java.io.IOException;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.List;
-
-import junit.framework.TestCase;
-
-import org.apache.lucene.gdata.data.GDataAccount;
-import org.apache.lucene.gdata.data.ServerBaseEntry;
-import org.apache.lucene.gdata.data.ServerBaseFeed;
-import org.apache.lucene.gdata.server.registry.ProvidedService;
-import org.apache.lucene.gdata.storage.StorageException;
-import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper.StorageOperation;
-import org.apache.lucene.gdata.utils.ProvidedServiceStub;
-import org.apache.lucene.gdata.utils.ReferenceCounter;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.RAMDirectory;
-
-import com.google.gdata.data.BaseEntry;
-import com.google.gdata.data.BaseFeed;
-import com.google.gdata.data.DateTime;
-import com.google.gdata.data.Entry;
-import com.google.gdata.util.ParseException;
-
-public class TestStorageQuery extends TestCase {
-    private StorageModifier modifier;
-    private int count = 30;
-    private ReferenceCounter<StorageQuery> query;
-    private ProvidedService configurator;
-    private StorageCoreController controller;
-    private  Directory dir;
-    private static String feedId = "myFeed";
-    private static String accountName = "simon";
-    private static String service = ProvidedServiceStub.SERVICE_NAME;
-    protected void setUp() throws Exception {
-        this.configurator = new ProvidedServiceStub();
-        this.controller = new StorageCoreController();
-        this.dir = new RAMDirectory();
-        this.controller.setStorageDir(this.dir);
-        this.controller.setKeepRecoveredFiles(false);
-        this.controller.setOptimizeInterval(10);
-        this.controller.setRecover(false);
-        this.controller.setBufferSize(10);
-        this.controller.setPersistFactor(10);
-        this.controller.initialize();
-        this.configurator = new ProvidedServiceStub();
-        this.modifier = this.controller.getStorageModifier();
-        this.dir = this.controller.getDirectory();        
-        ServerBaseFeed feed = new ServerBaseFeed();
-        feed.setId(feedId);
-        feed.setServiceType(service);
-        feed.setServiceConfig(this.configurator);
-        
-        StorageFeedWrapper wrapper = new StorageFeedWrapper(feed,accountName);
-        this.modifier.createFeed(wrapper);
-        insertEntries(this.count);
-        this.query = this.controller.getStorageQuery();
-        
-    }
-    
-    /**
-     * @param entrycount
-     * @throws IOException
-     * @throws InterruptedException
-     * @throws StorageException
-     */
-    public void insertEntries(int entrycount) throws IOException,InterruptedException, StorageException{
-        List<StorageEntryWrapper> tempList = new ArrayList<StorageEntryWrapper>();
-        for (int i = 0; i <= entrycount ; i++) {
-            ServerBaseEntry entry = new ServerBaseEntry(new Entry());
-            entry.setId(""+i);
-            entry.setServiceConfig(this.configurator);
-            entry.setUpdated(new DateTime(System.currentTimeMillis(),0));
-            entry.setFeedId(feedId);
-            StorageEntryWrapper wrapper = new StorageEntryWrapper(entry,StorageOperation.INSERT);
-            tempList.add(i,wrapper);
-           
-            // force different timestamps --> DateTime 2006-06-05T13:37:55.724Z
-            Thread.sleep(10);
-          
-        }
-        for (StorageEntryWrapper entry : tempList) {
-            this.modifier.insertEntry(entry);
-        }
-        
-        
-        
-        
-    }
-
-    protected void tearDown() throws Exception {
-        this.query.decrementRef();
-        this.controller.destroy();
-    }
-    
-    /*
-     *  
-     */
-    public void testAccountNameQuery() throws IOException, StorageException{
-        ReferenceCounter<StorageQuery> query = this.controller.getStorageQuery();
-        assertEquals(accountName,query.get().getAccountNameForFeedId(feedId));
-        assertNull(query.get().getAccountNameForFeedId("someId"));
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.storage.lucenestorage.StorageQuery.feedQuery(String, int, int)'
-     */
-    public void testFeedQuery() throws IOException,  ParseException, StorageException {
-        feedQueryHelper(this.query);
-        this.controller.forceWrite();
-        ReferenceCounter<StorageQuery> queryAssureWritten = this.controller.getStorageQuery();
-       
-        assertNotSame(queryAssureWritten,this.query);
-        feedQueryHelper(queryAssureWritten);
-        queryAssureWritten.decrementRef();
-    }
-    private void feedQueryHelper(ReferenceCounter<StorageQuery> currentQuery) throws IOException,  ParseException{
-       BaseFeed feed = currentQuery.get().getLatestFeedQuery(feedId,25,1,this.configurator);
-       List<BaseEntry> entryList = feed.getEntries(); 
-        assertTrue("listSize: "+entryList.size(),entryList.size() == 25);
-        
-        BaseEntry tempEntry = null;
-        for (BaseEntry entry : entryList) {
-          
-            assertNotNull("entry",entry);
-            if(tempEntry != null){
-                assertTrue(tempEntry.getUpdated().compareTo(entry.getUpdated())>=0) ;
-                tempEntry = entry;
-            }else
-                tempEntry = entry;
-            
-        }
-        // test sub retrieve sublist
-        int offset = 15;
-        int resultCount = 5; 
-        feed = currentQuery.get().getLatestFeedQuery(feedId,resultCount,offset,this.configurator);
-        List<BaseEntry> entrySubList = feed.getEntries();
-        
-        assertTrue("listSize: "+entrySubList.size(),entrySubList.size() == resultCount);
-        offset--;
-        for (BaseEntry entry : entrySubList) {
-            
-            assertEquals(entry.getId(),entryList.get(offset).getId());
-            offset++;
-            
-        }
-        
-        
-        
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.storage.lucenestorage.StorageQuery.singleEntryQuery(String, String)'
-     */
-    public void testSingleEntryQuery() throws  ParseException, IOException {
-        for (int i = 1; i <= this.count; i++) {
-            BaseEntry entry = this.query.get().singleEntryQuery(""+i,feedId,this.configurator);
-            assertEquals(""+i,entry.getId());
-        }
-        
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.storage.lucenestorage.StorageQuery.entryQuery(List<String>, String)'
-     */
-    public void testEntryQuery() throws  ParseException, IOException, StorageException {
-        entryQueryHelper(this.query);
-        this.controller.forceWrite();
-        ReferenceCounter<StorageQuery> queryAssureWritten = this.controller.getStorageQuery();
-       
-        assertNotSame(queryAssureWritten,query);
-        entryQueryHelper(queryAssureWritten);
-        queryAssureWritten.decrementRef();
-    }
-    public void testGetUser() throws StorageException, IOException{
-        this.modifier.forceWrite();
-        GDataAccount user = new GDataAccount();
-        user.setName("simon");
-        user.setPassword("pass");
-        user.setAuthorname("simon willnauer");
-        user.setAuthorMail("simon@apache.org");
-        user.setAuthorLink(new URL("http://www.apache.org"));
-        
-       
-     
-        this.modifier.createAccount(new StorageAccountWrapper(user));
-        GDataAccount queriedUser = this.query.get().getUser("simon");
-        assertNull(queriedUser);
-        ReferenceCounter<StorageQuery> tempQuery = this.controller.getStorageQuery();
-        queriedUser = tempQuery.get().getUser("simon");
-        assertTrue(queriedUser.equals(user));
-        assertTrue(queriedUser.getAuthorMail().equals(user.getAuthorMail()));
-        assertTrue(queriedUser.getAuthorLink().equals(user.getAuthorLink()));
-        assertTrue(queriedUser.getAuthorname().equals(user.getAuthorname()));
-        assertTrue(queriedUser.getPassword().equals(user.getPassword()));
-    }
-    
-    public void testIsEntryStored() throws IOException{
-        
-      assertTrue(this.query.get().isEntryStored(""+(this.count-1),feedId));
-      assertFalse(this.query.get().isEntryStored("someOther",feedId));
-      this.modifier.forceWrite();
-      assertTrue(this.query.get().isEntryStored(""+(this.count-1),feedId));
-      this.query = this.controller.getStorageQuery();
-      assertTrue(this.query.get().isEntryStored(""+(this.count-1),feedId));
-      assertFalse(this.query.get().isEntryStored("someOther",feedId));
-    }
-    
-    public void testGetEntryLastModied() throws IOException, StorageException{
-        ServerBaseEntry entry = new ServerBaseEntry(new Entry());
-        entry.setId("test");
-        entry.setServiceConfig(this.configurator);
-        entry.setUpdated(new DateTime(System.currentTimeMillis(),0));
-        entry.setFeedId(feedId);
-        StorageEntryWrapper wrapper = new StorageEntryWrapper(entry,StorageOperation.INSERT);
-        
-        this.modifier.insertEntry(wrapper);
-        assertEquals(entry.getUpdated().getValue(),this.query.get().getEntryLastModified("test",feedId));
-        this.modifier.forceWrite();
-        assertEquals(entry.getUpdated().getValue(),this.query.get().getEntryLastModified("test",feedId));
-        this.query = this.controller.getStorageQuery();
-        assertEquals(entry.getUpdated().getValue(),this.query.get().getEntryLastModified("test",feedId));
-        try{
-        this.query.get().getEntryLastModified("some",feedId);
-        fail("exception expected");
-        }catch (Exception e) {
-            e.printStackTrace();
-        }
-    }
-    
-    public void testGetFeedLastModified() throws StorageException, IOException{
-        ServerBaseEntry entry = new ServerBaseEntry(new Entry());
-        entry.setId("test");
-        entry.setServiceConfig(this.configurator);
-        entry.setUpdated(new DateTime(System.currentTimeMillis(),0));
-        entry.setFeedId(feedId);
-        StorageEntryWrapper wrapper = new StorageEntryWrapper(entry,StorageOperation.INSERT);
-        this.modifier.insertEntry(wrapper);
-        assertEquals(entry.getUpdated().getValue(),this.query.get().getFeedLastModified(feedId));
-        this.modifier.forceWrite();
-        assertEquals(entry.getUpdated().getValue(),this.query.get().getFeedLastModified(feedId));
-        this.query = this.controller.getStorageQuery();
-        assertEquals(entry.getUpdated().getValue(),this.query.get().getFeedLastModified(feedId));
-    }
-    
-    public void testCheckVersionId() throws IOException, StorageException{
-        this.modifier.forceWrite();
-        ReferenceCounter<StorageQuery> sQuery = this.controller.getStorageQuery();
-        ServerBaseEntry entry = new ServerBaseEntry(new Entry());
-        entry.setId("test");
-        entry.setServiceConfig(this.configurator);
-        entry.setUpdated(new DateTime(System.currentTimeMillis(),0));
-        entry.setFeedId(feedId);
-        entry.setVersion(5);
-        StorageEntryWrapper wrapper = new StorageEntryWrapper(entry,StorageOperation.INSERT);
-        this.modifier.insertEntry(wrapper);
-        //test in buffer
-        assertTrue(sQuery.get().checkEntryVersion(entry.getId(),entry.getFeedId(),entry.getVersion()));
-        assertFalse(sQuery.get().checkEntryVersion(entry.getId(),entry.getFeedId(),10000));
-        assertFalse(sQuery.get().checkEntryVersion(entry.getId(),"someOtherFeed",entry.getVersion()));
-        assertFalse(sQuery.get().checkEntryVersion("foobar",entry.getFeedId(),entry.getVersion()));
-        
-        
-        this.modifier.forceWrite();
-        //test in buffer after written
-        assertTrue(sQuery.get().checkEntryVersion(entry.getId(),entry.getFeedId(),entry.getVersion()));
-        assertFalse(sQuery.get().checkEntryVersion(entry.getId(),entry.getFeedId(),10000));
-        assertFalse(sQuery.get().checkEntryVersion(entry.getId(),"someOtherFeed",entry.getVersion()));
-        assertFalse(sQuery.get().checkEntryVersion("foobar",entry.getFeedId(),entry.getVersion()));
-        sQuery.decrementRef();
-        sQuery = this.controller.getStorageQuery();
-        //test in index
-        assertTrue(sQuery.get().checkEntryVersion(entry.getId(),entry.getFeedId(),entry.getVersion()));
-        assertFalse(sQuery.get().checkEntryVersion(entry.getId(),entry.getFeedId(),10000));
-        assertFalse(sQuery.get().checkEntryVersion("foobar",entry.getFeedId(),entry.getVersion()));
-        sQuery.decrementRef();
-        
-        
-        
-        
-    }
-    private void entryQueryHelper(ReferenceCounter<StorageQuery> currentQuery) throws IOException,  ParseException{
-        
-        List<String> entryIdList = new ArrayList<String>();
-        for (int i = 1; i <= this.count; i++) {
-           entryIdList.add(""+i);
-        }
-        List<BaseEntry> entryList = currentQuery.get().entryQuery(entryIdList,feedId,this.configurator);
-        assertEquals(entryIdList.size(),entryList.size());
-        List<String> entryIdCompare = new ArrayList<String>();
-        for (BaseEntry entry : entryList) {
-            assertEquals("1",entry.getVersionId());
-            entryIdCompare.add(entry.getId());
-            
-        }
-        assertTrue(entryIdList.containsAll(entryIdCompare));
-        
-    }
-    
-    
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/recover/TestRecoverController.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/recover/TestRecoverController.java
deleted file mode 100644
index 2c58f75..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/recover/TestRecoverController.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.storage.lucenestorage.recover;
-
-import java.io.File;
-import java.io.FileWriter;
-import java.io.IOException;
-
-import junit.framework.TestCase;
-
-import org.apache.lucene.gdata.data.ServerBaseEntry;
-import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
-import org.apache.lucene.gdata.storage.StorageException;
-import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper;
-import org.apache.lucene.gdata.storage.lucenestorage.StorageModifierStub;
-import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper.StorageOperation;
-import org.apache.lucene.gdata.utils.ProvidedServiceStub;
-
-import com.google.gdata.data.DateTime;
-
-public class TestRecoverController extends TestCase {
-    private RecoverController writeController;
-    private RecoverController readController;
-    private File recDir;
-    private String feedId = "feedid";
-    private String entryId = "entryId";
-    
-    protected void setUp() throws Exception {
-        this.recDir = new File("unittest"+System.currentTimeMillis());
-        if(!this.recDir.exists())
-            this.recDir.mkdir();
-        this.recDir.deleteOnExit();
-        GDataServerRegistry.getRegistry().registerService(new ProvidedServiceStub());
-        this.writeController = new RecoverController(this.recDir,false,true);
-        this.readController = new RecoverController(this.recDir,true,true);
-        
-        
-
-        
-    }
-
-    protected void tearDown() throws Exception {
-        
-        
-        
-        File[] files = this.recDir.listFiles();
-        for (int i = 0; i < files.length; i++) {
-            files[i].delete();
-        }
-        this.recDir.delete();
-      GDataServerRegistry.getRegistry().destroy();
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.recover.RecoverController.storageModified(StorageEntryWrapper)'
-     */
-    public void testStorageModified() throws IOException, RecoverException {
-        this.writeController.initialize();
-        ServerBaseEntry entry = new ServerBaseEntry();
-        entry.setFeedId(this.feedId);
-        entry.setId(entryId);
-        entry.setUpdated(DateTime.now());
-        entry.setServiceConfig(new ProvidedServiceStub());
-        StorageEntryWrapper wrapper = new StorageEntryWrapper(entry,StorageOperation.INSERT);
-        this.writeController.storageModified(wrapper);
-        assertEquals(1,this.recDir.listFiles().length);
-        this.writeController.destroy();
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.recover.RecoverController.recoverEntries(StorageModifier)'
-     */
-    public void testRecoverEntries() throws IOException, StorageException, RecoverException {
-        testStorageModified();
-        
-        int length = this.recDir.listFiles().length;
-        assertEquals(1,length);
-        
-        this.readController.initialize();
-        try{
-        this.readController.recoverEntries(new StorageModifierStub(null,null,null,0,0));
-        }catch (Exception e) {
-            fail("unexpected exception"+e.getMessage());
-        }
-        this.readController.destroy();
-        assertEquals(1,this.recDir.listFiles().length);
-        
-        createCorruptedFile();
-        this.readController.initialize();
-        try{
-        this.readController.recoverEntries(new StorageModifierStub(null,null,null,0,0));
-        }catch (Exception e) {
-            fail("unexpected exception"+e.getMessage());
-        }
-        this.readController.destroy();
-        assertEquals(2,this.recDir.listFiles().length);
-    }
-    
-    
-    private void createCorruptedFile() throws IOException{
-        File file = new File(this.recDir,"somefile.rec");
-        file.deleteOnExit();
-        FileWriter writer = new FileWriter(file);
-        writer.write("someString\nSomeOtherString");
-        writer.close();
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/recover/TestRecoverWriter.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/recover/TestRecoverWriter.java
deleted file mode 100644
index 58d53eb..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/recover/TestRecoverWriter.java
+++ /dev/null
@@ -1,90 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.storage.lucenestorage.recover;
-
-import java.io.IOException;
-import java.io.StringWriter;
-
-import junit.framework.TestCase;
-
-import org.apache.lucene.gdata.data.ServerBaseEntry;
-import org.apache.lucene.gdata.server.registry.ProvidedService;
-import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper;
-import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper.StorageOperation;
-import org.apache.lucene.gdata.utils.ProvidedServiceStub;
-
-import com.google.gdata.data.DateTime;
-import com.google.gdata.data.Entry;
-import com.google.gdata.data.PlainTextConstruct;
-
-public class TestRecoverWriter extends TestCase {
-    private static final String ENTRYID = "myID";
-    private static final String TITLE = "title";
-    private static final String FEEDID = "myFeed";
-    
-    private static final Long TIMESTAMP = 132326657L;
-    private DateTime dateTime = new DateTime(TIMESTAMP,0);
-    String compareEntry = "I;"+FEEDID+";"+ENTRYID+";"+TIMESTAMP+";" +ProvidedServiceStub.SERVICE_NAME+";"+RecoverWriter.META_DATA_ENTRY_SEPARATOR+
-            "<atom:entry xmlns:atom='http://www.w3.org/2005/Atom'><atom:id>"+ENTRYID+"</atom:id><atom:updated>"+this.dateTime.toString()+"</atom:updated><atom:title type='text'>" + TITLE+
-            "</atom:title></atom:entry>"+RecoverWriter.META_DATA_ENTRY_SEPARATOR+RecoverWriter.STORAGE_OPERATION_SEPARATOR+RecoverWriter.META_DATA_ENTRY_SEPARATOR;
-    String compareDelete = "D;"+FEEDID+";"+ENTRYID+";"+TIMESTAMP+";"+RecoverWriter.META_DATA_ENTRY_SEPARATOR+RecoverWriter.STORAGE_OPERATION_SEPARATOR+RecoverWriter.META_DATA_ENTRY_SEPARATOR;
-    StorageEntryWrapper wrapper;
-    StorageEntryWrapper deleteWrapper;
-
-    protected void setUp() throws Exception {
-        ServerBaseEntry entry = new ServerBaseEntry(new Entry());
-        entry.setId(ENTRYID);
-        
-        entry.setUpdated(new DateTime(TIMESTAMP,0));
-        entry.setTitle(new PlainTextConstruct(TITLE));
-        ProvidedService config = new ProvidedServiceStub();
-        entry.setFeedId(FEEDID);
-        entry.setServiceConfig(config);
-        this.wrapper = new StorageEntryWrapper(entry,StorageOperation.INSERT);
-        this.deleteWrapper = new StorageEntryWrapper(entry,StorageOperation.DELETE);
-        
-        
-    }
-
-    protected void tearDown() throws Exception {
-        super.tearDown();
-        
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.recover.RecoverWriter.writeEntry(StorageEntryWrapper, Writer)'
-     */
-    public void testWriteEntry() throws IOException {
-        RecoverWriter wr = new RecoverWriter();
-        StringWriter writer = new StringWriter();
-        wr.writeEntry(this.wrapper,writer);
-        assertEquals(compareEntry,writer.toString());
-        writer.close();
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.recover.RecoverWriter.writeDelete(String, String, Writer)'
-     */
-    public void testWriteDelete() throws IOException {
-        RecoverWriter wr = new RecoverWriter();
-        StringWriter writer = new StringWriter();
-        wr.writeEntry(this.deleteWrapper,writer);
-        System.out.println(writer.toString());
-        assertEquals(compareDelete,writer.toString());
-        writer.close();
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/recover/TestRevocerReader.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/recover/TestRevocerReader.java
deleted file mode 100644
index c4a7b12..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/storage/lucenestorage/recover/TestRevocerReader.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.storage.lucenestorage.recover;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.StringReader;
-import java.util.List;
-
-import junit.framework.TestCase;
-
-import org.apache.lucene.gdata.server.registry.GDataServerRegistry;
-import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper;
-import org.apache.lucene.gdata.storage.lucenestorage.StorageEntryWrapper.StorageOperation;
-import org.apache.lucene.gdata.utils.ProvidedServiceStub;
-
-import com.google.gdata.data.DateTime;
-
-public class TestRevocerReader extends TestCase {
-    private RecoverReader recReader;
-    private static final String feedId = "myFeed";
-    private static final String entryId = "myID";
-    private static final Long timestamp = System.currentTimeMillis();
-    private String title = "myTitle";
-    private static final DateTime dateTime = DateTime.now();
-    private String delete = "D;"+feedId+";"+entryId+";"+timestamp+";\n###########\n";
-    private String insert = "I;"+feedId+";"+entryId+";"+timestamp+";" +ProvidedServiceStub.SERVICE_NAME+";"+RecoverWriter.META_DATA_ENTRY_SEPARATOR+
-    "<atom:entry xmlns:atom='http://www.w3.org/2005/Atom'><atom:id>"+entryId+"</atom:id><atom:updated>"+dateTime.toString()+"</atom:updated><atom:title type='text'>" + this.title+
-    "</atom:title></atom:entry>"+RecoverWriter.META_DATA_ENTRY_SEPARATOR+RecoverWriter.STORAGE_OPERATION_SEPARATOR+RecoverWriter.META_DATA_ENTRY_SEPARATOR;
-    protected void setUp() throws Exception {
-        this.recReader = new RecoverReader();
-        GDataServerRegistry.getRegistry().registerService(new ProvidedServiceStub());
-        
-    }
-
-    protected void tearDown() throws Exception {
-        super.tearDown();
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.storage.lucenestorage.recover.RecoverReader.getNonDeleteEntries(Reader)'
-     */
-    public void testRecoverDeletedEntries() throws IOException {
-        StringReader reader = new StringReader(this.delete);
-        assertNotNull(this.recReader.recoverEntries(new BufferedReader(reader)));
-        reader = new StringReader(this.delete);
-        List<StorageEntryWrapper> recList = this.recReader.recoverEntries(new BufferedReader(reader));
-        assertEquals(1,recList.size());
-        StorageEntryWrapper delWrapper = recList.get(0);
-        assertEquals(StorageOperation.DELETE,delWrapper.getOperation());
-        assertEquals(feedId,delWrapper.getFeedId());
-        assertEquals(entryId,delWrapper.getEntryId());
-        
-    }
-    public void testRecoverInsertedEntries() throws IOException {
-        
-        StringReader reader = new StringReader(this.insert);
-        List<StorageEntryWrapper> recList = this.recReader.recoverEntries(new BufferedReader(reader));
-        assertEquals(1,recList.size());
-        StorageEntryWrapper insWrapper = recList.get(0);
-        assertEquals(StorageOperation.INSERT,insWrapper.getOperation());
-        assertEquals(feedId,insWrapper.getFeedId());
-        assertEquals(entryId,insWrapper.getEntryId());
-        assertEquals(dateTime,insWrapper.getEntry().getUpdated());
-        assertEquals(this.title,insWrapper.getEntry().getTitle().getPlainText());
-        
-        
-    }
-    
-    public void testRecoverReader()throws IOException{
-        StringReader reader = new StringReader(this.insert+this.delete);
-        List<StorageEntryWrapper> recList = this.recReader.recoverEntries(new BufferedReader(reader));
-        assertEquals(2,recList.size());
-        assertEquals(StorageOperation.INSERT,recList.get(0).getOperation());
-        assertEquals(StorageOperation.DELETE,recList.get(1).getOperation());
-        
-        reader = new StringReader("some corrupted\n###########\n"+this.insert);
-        recList = this.recReader.recoverEntries(new BufferedReader(reader));
-        assertEquals(1,recList.size());
-        assertEquals(StorageOperation.INSERT,recList.get(0).getOperation());
-        
-    }
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/utils/AuthenticationContorllerStub.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/utils/AuthenticationContorllerStub.java
deleted file mode 100644
index d0ff012..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/utils/AuthenticationContorllerStub.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.utils;
-
-import org.apache.lucene.gdata.data.GDataAccount;
-import org.apache.lucene.gdata.data.GDataAccount.AccountRole;
-import org.apache.lucene.gdata.server.authentication.AuthenticationController;
-import org.apache.lucene.gdata.server.registry.Component;
-import org.apache.lucene.gdata.server.registry.ComponentType;
-
-/**
- * @author Simon Willnauer
- *
- */
-@Component(componentType=ComponentType.AUTHENTICATIONCONTROLLER)
-public class AuthenticationContorllerStub implements AuthenticationController {
-    public static AuthenticationController controller;
-    /**
-     * 
-     */
-    public AuthenticationContorllerStub() {
-        super();
-        // TODO Auto-generated constructor stub
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.authentication.AuthenticationController#authenticatAccount(org.apache.lucene.gdata.data.GDataAccount, java.lang.String, java.lang.String)
-     */
-    public String authenticatAccount(GDataAccount account, String requestIp
-            ) {
-
-        return controller.authenticatAccount(account,requestIp);
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.authentication.AuthenticationController#authenticateToken(java.lang.String, java.lang.String, org.apache.lucene.gdata.data.GDataAccount.AccountRole, java.lang.String)
-     */
-    public boolean authenticateToken(String token, String requestIp,
-            AccountRole role, String serviceName) {
-
-        return controller.authenticateToken(token,requestIp,role,serviceName);
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.registry.ServerComponent#initialize()
-     */
-    public void initialize() {
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.registry.ServerComponent#destroy()
-     */
-    public void destroy() {
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/utils/MultiThreadEntryStub.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/utils/MultiThreadEntryStub.java
deleted file mode 100755
index d344c1b..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/utils/MultiThreadEntryStub.java
+++ /dev/null
@@ -1,93 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.utils;
-
-
-
-
-import org.apache.lucene.gdata.data.ServerBaseEntry;
-
-import com.google.gdata.data.BaseEntry;
-
-/**
- * @author Simon Willnauer
- *
- */
-public class MultiThreadEntryStub extends ServerBaseEntry {
-    
-    
-    private Visitor getEntryVisitor;
-    private Visitor getVersionVisitor;
-    /**
-     * 
-     */
-    public MultiThreadEntryStub() {
-        
-     
-    }
-    
-    /**
-     * @param arg0
-     */
-    public MultiThreadEntryStub(BaseEntry arg0) {
-        super(arg0);
-        
-    }
-   
-    
-    
-    public void acceptGetEntryVisitor(Visitor visitor){
-        this.getEntryVisitor = visitor;
-    }
-    public void acceptGetVersionVisitor(Visitor visitor){
-       this.getVersionVisitor = visitor;
-    }
-    /**
-     * @see org.apache.lucene.gdata.data.ServerBaseEntry#getEntry()
-     */
-    @Override
-    public BaseEntry getEntry() {
-       
-        if(this.getEntryVisitor != null){
-            this.getEntryVisitor.execute(null);
-
-        }
-        return super.getEntry();
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.data.ServerBaseEntry#getVersion()
-     */
-    @Override
-    public int getVersion() {
-
-        if(this.getVersionVisitor != null){
-            this.getVersionVisitor.execute(null);
-
-        }
-        return super.getVersion();
-    }
-
-
-    
-    
-    
-    
-    
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/utils/ProvidedServiceStub.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/utils/ProvidedServiceStub.java
deleted file mode 100644
index 3e5c042..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/utils/ProvidedServiceStub.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.utils;
-
-import javax.xml.transform.Templates;
-
-import org.apache.lucene.gdata.search.config.IndexSchema;
-import org.apache.lucene.gdata.server.registry.ProvidedService;
-
-import com.google.gdata.data.Entry;
-import com.google.gdata.data.ExtensionProfile;
-import com.google.gdata.data.Feed;
-
-public class ProvidedServiceStub implements ProvidedService {
-
-    public static final String SERVICE_NAME = "service";
-    private IndexSchema indexSchema;
-
-    public ProvidedServiceStub() {
-        super();
-        // TODO Auto-generated constructor stub
-    }
-
-    public Class getFeedType() {
-
-        return Feed.class;
-    }
-
-    public ExtensionProfile getExtensionProfile() {
-
-        return new ExtensionProfile();
-    }
-
-    public Class getEntryType() {
-
-        return Entry.class;
-    }
-
-    public String getName() {
-
-        return SERVICE_NAME;
-    }
-
-    public void destroy() {
-    }
-    public void setIndexSchema(IndexSchema schema){
-        this.indexSchema = schema;
-        this.indexSchema.setName(SERVICE_NAME);
-    }
-    public IndexSchema getIndexSchema() {
-        
-        return this.indexSchema;
-    }
-
-    public Templates getTransformTemplate() {
-        
-        return null;
-    }
-
-  
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/utils/ServiceFactoryStub.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/utils/ServiceFactoryStub.java
deleted file mode 100644
index 0311e9c..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/utils/ServiceFactoryStub.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.utils;
-
-import org.apache.lucene.gdata.server.GDataRequest;
-import org.apache.lucene.gdata.server.Service;
-import org.apache.lucene.gdata.server.ServiceFactory;
-import org.apache.lucene.gdata.server.administration.AdminService;
-import org.apache.lucene.gdata.server.registry.Component;
-import org.apache.lucene.gdata.server.registry.ComponentType;
-
-
-
-/**
- * @author Simon Willnauer
- *
- */
-@Component(componentType=ComponentType.SERVICEFACTORY)
-public class ServiceFactoryStub extends ServiceFactory {
-   
-    public Service service;
-    public AdminService adminService;
-    /**
-     * @see org.apache.lucene.gdata.server.ServiceFactory#getAdminService()
-     */
-    @Override
-    public AdminService getAdminService() {
-        
-        return adminService;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.ServiceFactory#getService()
-     */
-    @Override
-    public Service getService(GDataRequest request) {
-        
-        return service;
-    }
-
-    public void setAdminService(AdminService service) {
-        this.adminService = service;
-    }
-    public void setService(Service service) {
-        this.service = service;
-    }
-    
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/utils/StorageControllerStub.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/utils/StorageControllerStub.java
deleted file mode 100644
index 2667014..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/utils/StorageControllerStub.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.utils;
-
-import org.apache.lucene.gdata.server.registry.Component;
-import org.apache.lucene.gdata.server.registry.ComponentType;
-import org.apache.lucene.gdata.storage.Storage;
-import org.apache.lucene.gdata.storage.StorageController;
-import org.apache.lucene.gdata.storage.StorageException;
-
-/**
- * @author Simon Willnauer
- *
- */
-@Component(componentType = ComponentType.STORAGECONTROLLER)
-public class StorageControllerStub implements StorageController {
-
-    /**
-     * 
-     */
-    public StorageControllerStub() {
-        super();
-        // TODO Auto-generated constructor stub
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.StorageController#destroy()
-     */
-    public void destroy() {
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.StorageController#getStorage()
-     */
-    public Storage getStorage() throws StorageException {
-
-        return new StorageStub();
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.server.registry.ServerComponent#initialize()
-     */
-    public void initialize() {
-    }
-
-    public String releaseId() {
-        
-        return null;
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/utils/StorageStub.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/utils/StorageStub.java
deleted file mode 100644
index 321d603..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/utils/StorageStub.java
+++ /dev/null
@@ -1,179 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.utils;
-
-import java.util.Date;
-
-import org.apache.lucene.gdata.data.GDataAccount;
-import org.apache.lucene.gdata.data.ServerBaseEntry;
-import org.apache.lucene.gdata.data.ServerBaseFeed;
-import org.apache.lucene.gdata.server.registry.Component;
-import org.apache.lucene.gdata.server.registry.ComponentType;
-import org.apache.lucene.gdata.storage.Storage;
-import org.apache.lucene.gdata.storage.StorageController;
-import org.apache.lucene.gdata.storage.StorageException;
-
-import com.google.gdata.data.BaseEntry;
-import com.google.gdata.data.BaseFeed;
-
-/**
- * @author Simon Willnauer
- *
- */
-@Component(componentType=ComponentType.STORAGECONTROLLER)
-public class StorageStub implements Storage, StorageController {
-public static String SERVICE_TYPE_RETURN = "service";
-    /**
-     * 
-     */
-    public StorageStub() {
-        super();
-        // TODO Auto-generated constructor stub
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#storeEntry(org.apache.lucene.gdata.data.ServerBaseEntry)
-     */
-    public BaseEntry storeEntry(ServerBaseEntry entry)
-            throws StorageException {
-
-        return null;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#deleteEntry(org.apache.lucene.gdata.data.ServerBaseEntry)
-     */
-    public void deleteEntry(ServerBaseEntry entry) throws StorageException {
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#updateEntry(org.apache.lucene.gdata.data.ServerBaseEntry)
-     */
-    public BaseEntry updateEntry(ServerBaseEntry entry)
-            throws StorageException {
-
-        return null;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#getFeed(org.apache.lucene.gdata.data.ServerBaseFeed)
-     */
-    public BaseFeed getFeed(ServerBaseFeed feed) throws StorageException {
-
-        return null;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#getEntry(org.apache.lucene.gdata.data.ServerBaseEntry)
-     */
-    public BaseEntry getEntry(ServerBaseEntry entry)
-            throws StorageException {
-
-        return null;
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#storeAccount(org.apache.lucene.gdata.data.GDataAccount)
-     */
-    public void storeAccount(GDataAccount Account) throws StorageException {
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#updateAccount(org.apache.lucene.gdata.data.GDataAccount)
-     */
-    public void updateAccount(GDataAccount Account) throws StorageException {
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#deleteAccount(java.lang.String)
-     */
-    public void deleteAccount(String Accountname) throws StorageException {
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#storeFeed(org.apache.lucene.gdata.data.ServerBaseFeed, java.lang.String)
-     */
-    public void storeFeed(ServerBaseFeed feed, String accountname)
-            throws StorageException {
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#deleteFeed(java.lang.String)
-     */
-    public void deleteFeed(String feedId) throws StorageException {
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#updateFeed(org.apache.lucene.gdata.data.ServerBaseFeed, java.lang.String)
-     */
-    public void updateFeed(ServerBaseFeed feed, String accountname)
-            throws StorageException {
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#close()
-     */
-    public void close() {
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.storage.Storage#getServiceForFeed(java.lang.String)
-     */
-    public String getServiceForFeed(String feedId) throws StorageException {
-
-        return SERVICE_TYPE_RETURN;
-    }
-
-    public void destroy() {
-    }
-
-    public Storage getStorage() throws StorageException {
-        
-        return new StorageStub();
-    }
-
-    public GDataAccount getAccount(String accountName) throws StorageException {
-        
-        return null;
-    }
-
-    public String getAccountNameForFeedId(String feedId) throws StorageException {
-        
-        return null;
-    }
-
-    public void initialize() {
-    }
-
-
-    public Long getFeedLastModified(String feedId) throws StorageException {
-        
-        return null;
-    }
-
-    public Long getEntryLastModified(String entryId, String feedId) throws StorageException {
-        
-        return null;
-    }
-
-    public String releaseId() {
-        
-        return null;
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/utils/TestDateFormater.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/utils/TestDateFormater.java
deleted file mode 100644
index 9c586b9..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/utils/TestDateFormater.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.utils;
-
-import java.text.ParseException;
-import java.text.SimpleDateFormat;
-import java.util.Date;
-
-import junit.framework.TestCase;
-
-public class TestDateFormater extends TestCase {
-
-    protected void setUp() throws Exception {
-        super.setUp();
-    }
-
-    protected void tearDown() throws Exception {
-        super.tearDown();
-    }
-    /*
-     * Test method for 'org.apache.lucene.gdata.utils.DateFormater.formatDate(Date, String)'
-     */
-    public void testFormatDate() throws ParseException {
-        // this reg. --> bit weak but does the job
-            java.util.regex.Pattern pattern =  java.util.regex.Pattern.compile("[A-Z][a-z]{1,2}, [0-9]{1,2} [A-Z][a-z]{2} [0-9]{4} [0-9]{1,2}:[0-9]{1,2}:[0-9]{1,2} [A-Z]{2,4}");
-            Date date = new Date();
-            String formatedDate = DateFormater.formatDate(date,DateFormater.HTTP_HEADER_DATE_FORMAT);
-            assertTrue(pattern.matcher(formatedDate).matches());    
-            DateFormater.parseDate("Sun, 25 Jun 2006 13:51:23 +0000",DateFormater.HTTP_HEADER_DATE_FORMAT,DateFormater.HTTP_HEADER_DATE_FORMAT_TIME_OFFSET);
-            DateFormater.parseDate("Sun, 25 Jun 2006 13:51:23 CEST",DateFormater.HTTP_HEADER_DATE_FORMAT,DateFormater.HTTP_HEADER_DATE_FORMAT_TIME_OFFSET);
-            //TODO extend this
-    }
-    
-    public void testFormatDateStack(){
-        DateFormater formater = new DateFormater();
-        SimpleDateFormat f1 = formater.getFormater();
-        SimpleDateFormat f2 = formater.getFormater();
-        assertNotSame(f1,f2);
-        formater.returnFomater(f1);
-        assertSame(f1,formater.getFormater());
-        formater.returnFomater(f2);
-        assertSame(f2,formater.getFormater());
-        
-    }
-    
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/utils/TestReflectionUtils.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/utils/TestReflectionUtils.java
deleted file mode 100755
index 127b3b0..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/utils/TestReflectionUtils.java
+++ /dev/null
@@ -1,119 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.utils;
-
-import org.apache.lucene.gdata.search.analysis.PlainTextStrategy;
-import org.apache.lucene.gdata.search.config.IndexSchemaField;
-import org.apache.lucene.gdata.utils.ReflectionUtils.ReflectionException;
-import org.apache.lucene.search.RangeQuery;
-
-import junit.framework.TestCase;
-
-public class TestReflectionUtils extends TestCase {
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.utils.ReflectionUtils.implementsType(Class, Class)'
-     */
-    public void testImplementsType() {
-
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.utils.ReflectionUtils.extendsType(Class, Class)'
-     */
-    public void testExtendsType() {
-        assertTrue(ReflectionUtils.isTypeOf(Integer.class,Number.class));
-        assertFalse(ReflectionUtils.isTypeOf(null,CharSequence.class));
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.utils.ReflectionUtils.isTypeOf(Class, Class)'
-     */
-    public void testIsTypeOf() {
-        assertTrue(ReflectionUtils.isTypeOf(String.class,CharSequence.class));
-        assertTrue(ReflectionUtils.isTypeOf(Integer.class,Number.class));
-        assertFalse(ReflectionUtils.isTypeOf(Integer.class,CharSequence.class));
-        assertFalse(ReflectionUtils.isTypeOf(null,CharSequence.class));
-        assertFalse(ReflectionUtils.isTypeOf(Integer.class,null));
-
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.utils.ReflectionUtils.getDefaultInstance(Class<T>) <T>'
-     */
-    public void testGetDefaultInstance() {
-        assertEquals(new String(),ReflectionUtils.getDefaultInstance(String.class));
-        try{
-        ReflectionUtils.getDefaultInstance(Integer.class);
-        fail("can not create instance");
-        }catch (ReflectionException e) {
-            
-        }
-        try{
-            ReflectionUtils.getDefaultInstance(null);
-            fail("can not create instance");
-            }catch (ReflectionException e) {
-                
-            }
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.utils.ReflectionUtils.canCreateInstance(Class)'
-     */
-    public void testCanCreateInstance() {
-        assertTrue(ReflectionUtils.canCreateInstance(String.class));
-        assertFalse(ReflectionUtils.canCreateInstance(Integer.class));
-        assertFalse(ReflectionUtils.canCreateInstance(Integer.TYPE));
-        assertFalse(ReflectionUtils.canCreateInstance(null));
-        
-        
-        
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.utils.ReflectionUtils.getPrimitiveWrapper(Class)'
-     */
-    public void testGetPrimitiveWrapper() {
-        
-        assertEquals(Integer.class,ReflectionUtils.getPrimitiveWrapper(Integer.TYPE));
-        assertEquals(Long.class,ReflectionUtils.getPrimitiveWrapper(Long.TYPE));
-        assertEquals(Float.class,ReflectionUtils.getPrimitiveWrapper(Float.TYPE));
-        assertEquals(Byte.class,ReflectionUtils.getPrimitiveWrapper(Byte.TYPE));
-        assertEquals(Double.class,ReflectionUtils.getPrimitiveWrapper(Double.TYPE));
-        assertEquals(Short.class,ReflectionUtils.getPrimitiveWrapper(Short.TYPE));
-        assertEquals(Boolean.class,ReflectionUtils.getPrimitiveWrapper(Boolean.TYPE));
-        try {
-        ReflectionUtils.getPrimitiveWrapper(null);
-        fail("type is null");
-        }catch (ReflectionException e) {
-            
-        }
-        try {
-            ReflectionUtils.getPrimitiveWrapper(String.class);
-            fail("type is not a primitive");
-            }catch (ReflectionException e) {
-                
-            }
-        
-    }
-    
-    public void testHasdesiredconstructor(){
-        assertFalse(ReflectionUtils.hasDesiredConstructor(PlainTextStrategy.class, new Class[]{IndexSchemaField.class}));
-        assertFalse(ReflectionUtils.hasDesiredConstructor(PlainTextStrategy.class, new Class[]{}));
-        assertTrue(ReflectionUtils.hasDesiredConstructor(String.class, new Class[]{String.class}));
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/utils/TestSimpleObjectPool.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/utils/TestSimpleObjectPool.java
deleted file mode 100755
index 0920c48..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/utils/TestSimpleObjectPool.java
+++ /dev/null
@@ -1,155 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissi/**
- * 
- */
-
-package org.apache.lucene.gdata.utils;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import junit.framework.TestCase;
-
-public class TestSimpleObjectPool extends TestCase {
-    private Pool testPool;
-    private int SIZE = 10;
-    protected void setUp() throws Exception {
-        this.testPool =new SimpleObjectPool(SIZE,new ObjectFactoryStub());
-    }
-
-    protected void tearDown() throws Exception {
-        super.tearDown();
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.utils.SimpleObjectPool.SimpleObjectPool(int, PoolObjectFactory<Type>)'
-     */
-    public void testSimpleObjectPool() {
-        SimpleObjectPool pool = new SimpleObjectPool(1,new ObjectFactoryStub());
-        assertEquals(pool.getSize(),SimpleObjectPool.MINIMALSIZE);
-        pool = new SimpleObjectPool(-100,new ObjectFactoryStub());
-        assertEquals(pool.getSize(),SimpleObjectPool.MINIMALSIZE);
-        pool = new SimpleObjectPool(new ObjectFactoryStub());
-        assertEquals(pool.getSize(),SimpleObjectPool.DEFAULTSIZE);
-        pool = new SimpleObjectPool(100,new ObjectFactoryStub());
-        
-        assertEquals(100,pool.getSize());
-        try{
-        pool = new SimpleObjectPool(1,null);
-            fail("factory must not be null");
-        }catch (Exception e) {
-            // TODO: handle exception
-        }
-        
-
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.utils.SimpleObjectPool.aquire()'
-     */
-    public void testAquire() {
-        List l = new ArrayList(SIZE);
-        for (int i = 0; i < SIZE; i++) {
-            Object o = this.testPool.aquire();
-            assertNotNull(o);
-            assertFalse(l.contains(o));
-            l.add(o);
-            
-        }
-        for (Object object : l) {
-            this.testPool.release(object);
-        }
-        for (int i = 0; i < SIZE; i++) {
-            Object o = this.testPool.aquire();
-            assertNotNull(o);
-            assertTrue(l.contains(o));
-         
-            
-        }
-        
-    }
-
-    /*
-     * Test method for 'org.apache.lucene.gdata.utils.SimpleObjectPool.release(Type)'
-     */
-    public void testRelease() {
-        List l = new ArrayList(SIZE);
-        for (int i = 0; i < SIZE; i++) {
-            Object o = this.testPool.aquire();
-            assertNotNull(o);
-            assertFalse(l.contains(o));
-            l.add(o);
-            
-        }
-        
-        for (Object object : l) {
-            this.testPool.release(object);
-        }
-        for (int i = 0; i < 10; i++) {
-            this.testPool.release(new Object());
-        }
-        
-        for (int i = 0; i < SIZE; i++) {
-            Object o = this.testPool.aquire();
-            assertNotNull(o);
-            assertTrue(l.contains(o));
-         
-            
-        }
-        
-        //############################
-        
-        for (Object object : l) {
-            this.testPool.release(object);
-        }
-        
-        for (int i = 0; i < SIZE +SIZE; i++) {
-            Object o = this.testPool.aquire();
-            assertNotNull(o);
-            
-            if(i>= SIZE)
-                assertFalse(l.contains(o));
-            else
-            assertTrue(l.contains(o));
-        }
-    }
-    
-    public void testDestroy(){
-        this.testPool.destroy();
-        try{
-        this.testPool.aquire();
-        fail("pool is already closed");
-        }catch (Exception e) {
-            // TODO: handle exception
-        }
-        this.testPool.release(new Object());
-    }
-    
-    static class ObjectFactoryStub implements PoolObjectFactory{
-
-        public Object getInstance() {
-            
-            return new Object();
-        }
-
-        
-
-        public void destroyInstance(Object type) {
-            //
-        }
-        
-        
-    }
-
-}
diff --git a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/utils/Visitor.java b/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/utils/Visitor.java
deleted file mode 100755
index 9824f6a..0000000
--- a/contrib/gdata-server/src/core/test/org/apache/lucene/gdata/utils/Visitor.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/** 
- * Copyright 2004 The Apache Software Foundation 
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License. 
- */
-package org.apache.lucene.gdata.utils;
-
-/**
- * @author Simon Willnauer
- *
- */
-public interface Visitor {
-    public void execute(Object[] objects);
-}
diff --git a/contrib/gdata-server/src/gom/build.xml b/contrib/gdata-server/src/gom/build.xml
new file mode 100644
index 0000000..3d10e89
--- /dev/null
+++ b/contrib/gdata-server/src/gom/build.xml
@@ -0,0 +1,34 @@
+<?xml version="1.0"?>
+<!-- 
+  Licensed to the Apache Software Foundation (ASF) under one or more
+  contributor license agreements.  See the NOTICE file distributed with
+  this work for additional information regarding copyright ownership.
+  The ASF licenses this file to You under the Apache License, Version 2.0
+  (the "License"); you may not use this file except in compliance with
+  the License.  You may obtain a copy of the License at
+ 
+      http://www.apache.org/licenses/LICENSE-2.0
+ 
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+ 
+-->
+<project name="gdata-gom" default="default">
+
+  <description>
+	Lucene gdata server GData Object Model build file
+  </description>
+	<path id="additional.dependencies">
+			<fileset dir="../../${gdata.external.lib.dir}">
+				<include name="stax-1.1.2-dev.jar" />
+				<include name="stax-api-1.0.1.jar" />
+			</fileset>
+		</path>
+	<property name="build.dir" location="../../../build/contrib/gdata-server/gom" />
+	<property name="dist.dir" location="../../../dist/contrib/gdata-server/gom" />
+	<pathconvert property="project.classpath" targetos="unix" refid="additional.dependencies" />
+  <import file="../../../contrib-build.xml" />
+</project>
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/AtomMediaType.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/AtomMediaType.java
deleted file mode 100644
index a030cfd..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/AtomMediaType.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom;
-
-/**
- * Describes an abstraction of a mime-type used to define the content of a
- * atom:content element. This could be every possible mimetype but has to match
- * this ".+/.+" Pattern.
- * 
- * @author Simon Willnauer
- * 
- */
-public enum AtomMediaType {
-	/**
-	 * A xml media type (mime-type)
-	 */
-	XML, 
-	/**
-	 *A text but no xml media type (mime-type) 
-	 */
-	TEXT,
-	/**
-	 * A binary media type (mime-type)
-	 */
-	BINARY
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/ContentType.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/ContentType.java
deleted file mode 100644
index 38101a9..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/ContentType.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom;
-
-/**
- * Atom e.g. feed element can contain text, html and xhtml content as character
- * values
- * 
- * @author Simon Willnauer
- * 
- */
-public enum ContentType {
-	/**
-	 * GOM content type text
-	 */
-	TEXT,
-	/**
-	 * GOM content type XHTML
-	 */
-	XHTML,
-	/**
-	 * GOM content type HTML
-	 */
-	HTML,
-
-	/**
-	 * GOM atom media type
-	 * @see AtomMediaType
-	 */
-	ATOM_MEDIA_TYPE
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMAttribute.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMAttribute.java
deleted file mode 100644
index 1a0ed0a..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMAttribute.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom;
-
-/**
- * This class is a object representation of a XML Attribute used in the
- * GO-Model.
- * 
- * @author Simon Willnauer
- * 
- */
-public interface GOMAttribute extends GOMXmlEntity {
-
-	/**
-	 * 
-	 * @return <code>true</code> if and only if this attribute has the default
-	 *         namespace, otherwise <code>false</code>
-	 */
-	public abstract boolean hasDefaultNamespace();
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMAuthor.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMAuthor.java
deleted file mode 100644
index 4473a09..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMAuthor.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom;
-
-/**
- * GOMAuthor elmement used in feed and entries as a representation of a atom:author element.
- * The "atom:author" element is a Person construct that indicates the author of the entry or feed.
- * <pre>
- * atomAuthor = 
- * 	element atom:author { atomPersonConstruct }
- * </pre>
- * @see org.apache.lucene.gdata.gom.GOMPerson
- * @author Simon Willnauer
- * 
- */
-public interface GOMAuthor extends GOMPerson {
-	/**
-	 * Atom 1.0 local name for the xml element
-	 */
-	public static final String LOCALNAME = "author";
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMCategory.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMCategory.java
deleted file mode 100644
index 8057555..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMCategory.java
+++ /dev/null
@@ -1,100 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom;
-
-/**
- * 
- * GOMCategory type<br>
- * <p>
- * The <b>"category"</b> element conveys information about a category
- * associated with an entry or feed. This specification assigns no meaning to
- * the content (if any) of this element.
- * </p>
- * <p>
- * RelaxNG Schema:
- * </p>
- * 
- * <pre>
- *      atomCategory =
- *      element atom:category {
- *      	atomCommonAttributes,
- *      	attribute term { text },
- *      	attribute scheme { atomUri }?,
- *      	attribute label { text }?,
- *      	undefinedContent
- *      }
- * </pre>
- * 
- * 
- * @author Simon Willnauer
- * 
- */
-public interface GOMCategory extends GOMElement {
-	/**
-	 * Atom local name for the xml element
-	 */
-	public static final String LOCALNAME = "category";
-
-	/**
-	 * Attribute name (attribute term { text })
-	 */
-	public static final String TERM_ATTRIBUTE = "term";
-
-	/**
-	 * Attribute name (attribute label { text })
-	 */
-	public static final String LABLE_ATTRIBUTE = "label";
-
-	/**
-	 * Attribute name (attribute scheme { atomUri })
-	 */
-	public static final String SCHEME_ATTRIBUTE = "scheme";
-
-	/**
-	 * @param aTerm -
-	 *            the attribute term { text }
-	 */
-	public abstract void setTerm(String aTerm);
-
-	/**
-	 * @param aLabel -
-	 *            the attribute lable { text }
-	 */
-	public abstract void setLabel(String aLabel);
-
-	/**
-	 * @param aScheme -
-	 *            the attribute scheme { atomUri }
-	 */
-	public abstract void setScheme(String aScheme);
-
-	/**
-	 * @return the attribute term { text }
-	 */
-	public abstract String getTerm();
-
-	/**
-	 * @return the attribute scheme { atomUri }
-	 */
-	public abstract String getScheme();
-
-	/**
-	 * @return the attribute lable { text }
-	 */
-	public abstract String getLabel();
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMContent.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMContent.java
deleted file mode 100644
index 8cbbc8f..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMContent.java
+++ /dev/null
@@ -1,99 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom;
-
-/**
- * <p>
- * GOMContent represents the atom:content element.
- * </p>
- * The "atom:content" element either contains or links to the content of the
- * entry. The content of atom:content is Language-Sensitive.
- * 
- * <pre>
- *   atomInlineTextContent =
- *   element atom:content {
- *   atomCommonAttributes,
- *   attribute type { &quot;text&quot; | &quot;html&quot; }?,
- *   (text)*
- *   }
- *  
- *   atomInlineXHTMLContent =
- *   element atom:content {
- *   atomCommonAttributes,
- *   attribute type { &quot;xhtml&quot; },
- *   xhtmlDiv
- *   }
- *  
- *   atomInlineOtherContent =
- *   element atom:content {
- *   atomCommonAttributes,
- *   attribute type { atomMediaType }?,
- *   (text|anyElement)*
- *   }
- *  
- *  
- *   atomOutOfLineContent =
- *   element atom:content {
- *   atomCommonAttributes,
- *   attribute type { atomMediaType }?,
- *   attribute src { atomUri },
- *   empty
- *   }
- *  
- *   atomContent = atomInlineTextContent
- *   | atomInlineXHTMLContent
- *  
- *   | atomInlineOtherContent
- *   | atomOutOfLineContent
- * </pre>
- * 
- * @author Simon Willnauer
- * @see org.apache.lucene.gdata.gom.GOMTextConstruct
- *
- * 
- */
-public interface GOMContent extends GOMTextConstruct {
-	/**
-	 * Atom local name for the xml element
-	 */
-	public static final String LOCALNAME = "content";
-	/**
-	 * RSS local name for the xml element
-	 */
-	public static final String LOCAL_NAME_RSS = "description";
-	/**
-	 * The src attribute value
-	 * @return - the value of the src attribute
-	 */
-	public abstract String getSrc();
-	/**
-	 * The src attribute value
-	 * @param aSrc - the src attribute value to set
-	 */
-	public abstract void setSrc(String aSrc);
-	/**
-	 * The contents abstract media type
-	 * @param aMediaType - 
-	 */
-	public abstract void setAtomMediaType(AtomMediaType aMediaType);
-
-	/**
-	 * @return - the atom media type of the content element
-	 * @see AtomMediaType
-	 */
-	public abstract AtomMediaType getAtomMediaType();
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMContributor.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMContributor.java
deleted file mode 100644
index 9eac160..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMContributor.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/**
- * contributor license agreements.  See the NOTICE file distributed with
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom;
-
-/**
- * The "atom:contributor" element is a Person construct that indicates a person
- * or other entity who contributed to the entry or feed.
- * 
- * <pre>
- * atomContributor = element atom:contributor { atomPersonConstruct }
- * </pre>
- * 
- * @author Simon Willnauer
- * 
- */
-public interface GOMContributor extends GOMPerson {
-	/**
-	 * Atom 1.0 local name for the xml element
-	 */
-	public static final String LOCALNAME = "contributor";
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMDateConstruct.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMDateConstruct.java
deleted file mode 100644
index 79875bd..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMDateConstruct.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom;
-
-import java.util.Date;
-
-/**
- * 
- * <P>
- * GOMDateConstruct is a base interface for several concrete DateConstruct
- * implementations like {@link org.apache.lucene.gdata.gom.GOMUpdated} or
- * {@link org.apache.lucene.gdata.gom.GOMPublished}
- * </p>
- * <p>
- * A Date construct is an element whose content MUST conform to the "date-time"
- * production in [RFC3339]. In addition, an uppercase "T" character MUST be used
- * to separate date and time, and an uppercase "Z" character MUST be present in
- * the absence of a numeric time zone offset.
- * 
- * <pre>
- *  atomDateConstruct = atomCommonAttributes, xsd:dateTime
- * </pre>
- * 
- * Such date values happen to be compatible with the following specifications:
- * [ISO.8601.1988], [W3C.NOTE-datetime-19980827], and
- * [W3C.REC-xmlschema-2-20041028].
- * </p>
- * <p>
- * Example Date constructs:
- * 
- * <pre>
- *    &lt;updated&gt;2003-12-13T18:30:02Z&lt;/updated&gt;
- *   
- *    &lt;updated&gt;2003-12-13T18:30:02.25Z&lt;/updated&gt;
- *    &lt;updated&gt;2003-12-13T18:30:02+01:00&lt;/updated&gt;
- *    &lt;updated&gt;2003-12-13T18:30:02.25+01:00&lt;/updated&gt;
- * </pre>
- * 
- * Date values SHOULD be as accurate as possible. For example, it would be
- * generally inappropriate for a publishing system to apply the same timestamp
- * to several entries that were published during the course of a single day.
- * </p>
- * 
- * @author Simon Willnauer
- * 
- * @see org.apache.lucene.gdata.gom.GOMUpdated
- * @see org.apache.lucene.gdata.gom.GOMPublished
- */
-public abstract interface GOMDateConstruct extends GOMElement {
-	/**
-	 * 
-	 * @param date -
-	 *            the date to set
-	 */
-	public abstract void setDate(Date date);
-
-	/**
-	 * 
-	 * @return - the date object, if no date has been set this method will
-	 *         return a <code>new Date(0)</code> date object
-	 */
-	public abstract Date getDate();
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMDocument.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMDocument.java
deleted file mode 100644
index e895dc8..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMDocument.java
+++ /dev/null
@@ -1,110 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom;
-
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-/**
- * <p>
- * GOMDocument acts as a container for GOMElements to render the containing
- * GOMElement as a valid xml document. This class renderes the
- * 
- * <pre>
- *  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
- * </pre>
- * 
- * header to the outputstream before the containing element will be rendered.
- * </p>
- * 
- * @author Simon Willnauer
- * 
- * @param <T>
- */
-public interface GOMDocument<T extends GOMElement> {
-	/**
-	 * setter for the root element of the xml e.g GOMDocument
-	 * 
-	 * @param aRootElement -
-	 *            the root element to set
-	 */
-	public abstract void setRootElement(T aRootElement);
-
-	/**
-	 * Getter for the root element of the xml e.g GOMDocument
-	 * 
-	 * @return - the root elmenent
-	 */
-	public abstract T getRootElement();
-
-	/**
-	 * Sets the xml version
-	 * 
-	 * @param aVersion -
-	 *            the version string
-	 */
-	public abstract void setVersion(String aVersion);
-
-	/**
-	 * Gets the xml version
-	 * 
-	 * @return - the xml version string
-	 */
-	public abstract String getVersion();
-
-	/**
-	 * Gets the xml charset encoding
-	 * 
-	 * @return - the specified char encoding
-	 */
-	public abstract String getCharacterEncoding();
-
-	/**
-	 * Sets the xml charset encoding
-	 * 
-	 * @param aEncoding -
-	 *            the charset encoding to set
-	 */
-	public abstract void setCharacterEncoding(String aEncoding);
-
-	/**
-	 * Generates a complete xml document starting with the header followed by
-	 * the output of the specified root element in the ATOM 1.0 formate. 
-	 * 
-	 * @param aStreamWriter -
-	 *            the {@link GOMOutputWriter} implementation to write the output
-	 * @throws XMLStreamException -
-	 *             if the {@link GOMOutputWriter} throws an exception
-	 */
-	public abstract void writeAtomOutput(final GOMOutputWriter aStreamWriter)
-			throws XMLStreamException;
-
-	/**
-	 *
-	 * Generates a complete xml document starting with the header followed by
-	 * the output of the specified root element in the RSS 2.0 formate. 
-	 * 
-	 * @param aStreamWriter -
-	 *            the {@link GOMOutputWriter} implementation to write the output
-	 * @throws XMLStreamException -
-	 *             if the {@link GOMOutputWriter} throws an exception
-	 */
-	public abstract void writeRssOutput(final GOMOutputWriter aStreamWriter)
-			throws XMLStreamException;
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMElement.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMElement.java
deleted file mode 100644
index 83495ab..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMElement.java
+++ /dev/null
@@ -1,92 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom;
-
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.core.AtomParser;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-/**
- * Abstract interface which should be assignable from all classes representing
- * xml elements within the GData Object Model.
- * 
- * @author Simon Willnauer
- * 
- */
-public abstract interface GOMElement extends GOMXmlEntity, AtomParser {
-	/**
-	 * <code>xml:lang</code> attribute localpart
-	 */
-	public static final String XML_LANG = "lang";
-
-	/**
-	 * <code>xml:base</code> attribute localpart
-	 */
-	public static final String XML_BASE = "base";
-
-	/**
-	 * 
-	 * @return the xml:base attribute value
-	 */
-	public abstract String getXmlBase();
-
-	/**
-	 * 
-	 * @return the xml:lang attribute value
-	 */
-	public abstract String getXmlLang();
-
-	/**
-	 * Generates the xml element represented by this class in the ATOM 1.0
-	 * formate.
-	 * 
-	 * @param aStreamWriter -
-	 *            the {@link GOMOutputWriter} implementation to write the output
-	 * @throws XMLStreamException -
-	 *             if the {@link GOMOutputWriter} throws an exception
-	 */
-	public abstract void writeAtomOutput(final GOMOutputWriter aStreamWriter)
-			throws XMLStreamException;
-
-	/**
-	 * Generates the xml element represented by this class in the RSS 2.0
-	 * formate.
-	 * 
-	 * @param aStreamWriter -
-	 *            the {@link GOMOutputWriter} implementation to write the output
-	 * @throws XMLStreamException -
-	 *             if the {@link GOMOutputWriter} throws an exception
-	 */
-	public abstract void writeRssOutput(final GOMOutputWriter aStreamWriter)
-			throws XMLStreamException;
-
-	/**
-	 * Generates the xml element represented by this class in the RSS 2.0
-	 * formate using the parameter rssName as the element local name
-	 * 
-	 * @param rssName -
-	 *            the local name to render the element
-	 * @param aStreamWriter -
-	 *            the {@link GOMOutputWriter} implementation to write the output
-	 * @throws XMLStreamException -
-	 *             if the {@link GOMOutputWriter} throws an exception
-	 */
-	public abstract void writeRssOutput(final GOMOutputWriter aStreamWriter,
-			String rssName) throws XMLStreamException;
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMEntry.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMEntry.java
deleted file mode 100644
index 56903cb..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMEntry.java
+++ /dev/null
@@ -1,255 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom;
-
-import java.util.List;
-
-/**
- * 
- * <p>
- * The GOMEntry class represents a "atom:entry" element in the GData Object
- * Model.
- * </p>
- * <p>
- * The "atom:entry" element represents an individual entry, acting as a
- * container for metadata and data associated with the entry. This element can
- * appear as a child of the atom:feed element, or it can appear as the document
- * (i.e., top-level) element of a stand-alone Atom Entry Document.
- * </p>
- * <p>
- * RelaxNG Schema:
- * </p>
- * 
- * <pre>
- *     atomEntry =
- *     element atom:entry {
- *     atomCommonAttributes,
- *     (	atomAuthor*
- *     	&amp; atomCategory*
- *     	&amp; atomContent?
- *     	&amp; atomContributor*
- *     	&amp; atomId
- *     	&amp; atomLink*
- *     	&amp; atomPublished?
- *   	 	&amp; atomRights?
- *     	&amp; atomSource?
- *     	&amp; atomSummary?
- *     	&amp; atomTitle
- *     	&amp; atomUpdated
- *     	&amp; extensionElement*)
- *     }
- * </pre>
- * 
- * @author Simon Willnauer
- * 
- */
-public interface GOMEntry extends GOMXmlEntity, GOMElement, GOMExtensible {
-	/**
-	 * Atom 1.0 local name for the xml element
-	 */
-	public static final String LOCALNAME = "entry";
-
-	/**
-	 * RSS 2.0 local name for the xml element
-	 */
-	public static final String LOCALNAME_RSS = "item";
-
-	/**
-	 * @param aAuthor -
-	 *            a author to add
-	 * @see GOMAuthor
-	 */
-	public abstract void addAuthor(GOMAuthor aAuthor);
-
-	/**
-	 * @param aCategory -
-	 *            a category to add
-	 * @see GOMCategory
-	 */
-	public abstract void addCategory(GOMCategory aCategory);
-
-	/**
-	 * @param aContributor -
-	 *            a contributor to add
-	 * @see GOMContributor
-	 */
-	public abstract void addContributor(GOMContributor aContributor);
-
-	/**
-	 * @param aLink -
-	 *            a link to add
-	 * @see GOMLink
-	 */
-	public abstract void addLink(GOMLink aLink);
-
-	/**
-	 * @return - the entry author
-	 * @see GOMAuthor
-	 */
-	public abstract List<GOMAuthor> getAuthors();
-
-	/**
-	 * 
-	 * This method returns all categories and will never return<code>null</code>
-	 * 
-	 * @return - a list of categories
-	 * @see GOMCategory
-	 */
-	public abstract List<GOMCategory> getCategories();
-
-	/**
-	 * 
-	 * This method returns all contributors and will never return<code>null</code>
-	 * 
-	 * @return - a list of contributors
-	 * @see GOMContributor
-	 */
-	public abstract List<GOMContributor> getContributor();
-
-	/**
-	 * @return - the feed id
-	 * @see GOMId
-	 */
-	public abstract GOMId getId();
-
-	/**
-	 * @param aId -
-	 *            the entry id
-	 * @see GOMId
-	 */
-	public abstract void setId(GOMId aId);
-
-	/**
-	 * @return - the entry rights
-	 * @see GOMRights
-	 */
-	public abstract GOMRights getRights();
-
-	/**
-	 * @param aRights -
-	 *            the GOMRights to set
-	 * @see GOMRights
-	 */
-	public abstract void setRights(GOMRights aRights);
-
-	/**
-	 * @return - the entries title
-	 * @see GOMTitle
-	 */
-	public abstract GOMTitle getTitle();
-
-	/**
-	 * @param aTitle -
-	 *            the title to set
-	 * @see GOMTitle
-	 */
-	public abstract void setTitle(GOMTitle aTitle);
-
-	/**
-	 * @return - the last updated element
-	 * @see GOMUpdated
-	 */
-	public abstract GOMUpdated getUpdated();
-
-	/**
-	 * @param aUpdated -
-	 *            the updated element to set
-	 * @see GOMUpdated
-	 */
-	public abstract void setUpdated(GOMUpdated aUpdated);
-
-	/**
-	 * 
-	 * This method returns all links and will never return<code>null</code>
-	 * 
-	 * @return - a list of links
-	 * @see GOMLink
-	 */
-	public abstract List<GOMLink> getLinks();
-
-	/**
-	 * @param aSummary -
-	 *            a summary to set
-	 * @see GOMSummary
-	 */
-	public abstract void setSummary(GOMSummary aSummary);
-
-	/**
-	 * @return - the summary
-	 * @see GOMSummary
-	 */
-	public abstract GOMSummary getSummary();
-
-	/**
-	 * @param aSource -
-	 *            the source to set
-	 * @see GOMSource
-	 */
-	public abstract void setSource(GOMSource aSource);
-
-	/**
-	 * @return - the entry source
-	 * @see GOMSource
-	 */
-	public abstract GOMSource getSource();
-
-	/**
-	 * @param aPublished -
-	 *            the published element to set
-	 * @see GOMPublished
-	 */
-	public abstract void setPublished(GOMPublished aPublished);
-
-	/**
-	 * @return - the published element
-	 * @see GOMPublished
-	 */
-	public abstract GOMPublished getPublished();
-
-	/**
-	 * @return - the content element
-	 * @see GOMContent
-	 */
-	public abstract GOMContent getContent();
-
-	/**
-	 * @param content -
-	 *            the content to set
-	 * @see GOMContent
-	 */
-	public abstract void setContent(GOMContent content);
-
-	/**
-	 * @param aNamespace -
-	 *            a Namespace to add
-	 * @see GOMNamespace
-	 */
-	public abstract void addNamespace(GOMNamespace aNamespace);
-
-	/**
-	 * @return - list of all namespaces - will never be null
-	 * @see GOMNamespace
-	 */
-	public abstract List<GOMNamespace> getNamespaces();
-
-	/**
-	 * @return - the default namespace
-	 * @see GOMNamespace
-	 */
-	public abstract GOMNamespace getDefaultNamespace();
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMExtensible.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMExtensible.java
deleted file mode 100644
index 1bd4c38..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMExtensible.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom;
-
-import java.util.List;
-
-import org.apache.lucene.gdata.gom.core.extension.GOMExtensionFactory;
-
-/**
- * <p>
- * The Gdata Object Model describes an abstract object model for the gdata
- * protocol. GData is supposed to be very flexible and extensible. Users should
- * be able to extend {@link org.apache.lucene.gdata.gom.GOMFeed} and
- * {@link org.apache.lucene.gdata.gom.GOMEntry} elements to create extensions
- * and custom classes for their own model.
- * </p>
- * 
- * <p>
- * This interface describes the extensible GOM entities.
- * </p>
- * 
- * @author Simon Willnauer
- * @see org.apache.lucene.gdata.gom.GOMFeed
- * @see org.apache.lucene.gdata.gom.GOMEntry
- * 
- */
-public interface GOMExtensible {
-	//TODO add setter!
-	//TODO add how to
-	/**
-	 * @return - a list of all extensions specified to the extended element
-	 */
-	public List<GOMExtension> getExtensions();
-
-	/**
-	 * 
-	 * @param factory - the extension factory to set
-	 */
-	public void setExtensionFactory(GOMExtensionFactory factory);
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMExtension.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMExtension.java
deleted file mode 100644
index dbfc50a..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMExtension.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom;
-
-/**
- * The GData Object Model is like the Google Data Api highly extensible and
- * offers a lot of base classes to extend as a {@link GOMExtension}. All
- * extensions returned by
- * {@link org.apache.lucene.gdata.gom.core.extension.GOMExtensionFactory#canHandleExtensionElement(QName)}
- * must implement this interface. <br>
- * GOM extensions can either be created via the
- * {@link org.apache.lucene.gdata.gom.core.extension.GOMExtensionFactory} or by
- * subclassing either {@link org.apache.lucene.gdata.gom.GOMFeed} or
- * {@link org.apache.lucene.gdata.gom.GOMEntry}.
- * 
- * @author Simon Willnauer
- * @see org.apache.lucene.gdata.gom.GOMExtensible
- * @see org.apache.lucene.gdata.gom.core.extension.GOMExtensionFactory 
- */
-public interface GOMExtension extends GOMXmlEntity, GOMElement {
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMFeed.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMFeed.java
deleted file mode 100644
index 20733c8..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMFeed.java
+++ /dev/null
@@ -1,130 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom;
-
-import java.util.List;
-
-/**
- * Class representing the "atom:feed" element. The "atom:feed" element is the
- * document (i.e., top-level) element of an Atom Feed Document, acting as a
- * container for metadata and data associated with the feed. Its element
- * children consist of metadata elements followed by zero or more atom:entry
- * child elements.
- * 
- * <pre>
- *        atom:feed {
- *        	atomCommonAttributes, 
- *         	(atomAuthor* &amp; atomCategory* &amp;
- *        	atomContributor* &amp;
- *         	atomGenerator? &amp; atomIcon? &amp;
- *         	atomId &amp; 
- *         	atomLink* &amp;
- *        	atomLogo? &amp;
- *        	atomRights? &amp;
- *        	atomSubtitle? &amp;
- *        	atomTitle &amp; 
- *        	atomUpdated &amp;
- *        	extensionElement*),
- *        	 atomEntry* }
- * </pre>
- * 
- * 
- * @author Simon Willnauer
- * @see org.apache.lucene.gdata.gom.GOMExtensible
- * @see org.apache.lucene.gdata.gom.GOMExtension
- * @see org.apache.lucene.gdata.gom.GOMDocument
- */
-public interface GOMFeed extends GOMSource, GOMExtensible {
-	/**
-	 * Atom local name for the xml element
-	 */
-	public static final String LOCALNAME = "feed";
-
-	/**
-	 * RSS local name for the xml element
-	 */
-	public static final String LOCALNAME_RSS = "rss";
-
-	/**
-	 * RSS channel localname as Rss starts with
-	 * 
-	 * <pre>
-	 *     &lt;rss&gt;&lt;channel&gt;
-	 * </pre>
-	 */
-	public static final String RSS_CHANNEL_ELEMENT_NAME = "channel";
-
-	/**
-	 * this class can contain namespaces which will be rendered into the start
-	 * element.
-	 * 
-	 * <pre>
-	 *     &lt;feed xmlns:myNs=&quot;someNamespace&quot;&gt;&lt;/feed&gt;
-	 * </pre>
-	 * 
-	 * @param aNamespace -
-	 *            a namespace to add
-	 */
-	public void addNamespace(GOMNamespace aNamespace);
-
-	/**
-	 * @return - all declared namespaces, excluding the default namespace, this
-	 *         method will never return <code>null</code>.
-	 * @see GOMFeed#getDefaultNamespace()
-	 */
-	public List<GOMNamespace> getNamespaces();
-
-	/**
-	 * 
-	 * @return - a list of added entries, this method will never return
-	 *         <code>null</code>.
-	 */
-	public List<GOMEntry> getEntries();
-
-	/**
-	 * @return - the OpenSearch namespace element <i>itemsPerPage</i> text
-	 *         value.
-	 */
-	public int getItemsPerPage();
-
-	/**
-	 * @return - the OpenSearch namespace element <i>startIndex</i> text value.
-	 */
-	public int getStartIndex();
-
-	/**
-	 * @param aIndex -
-	 *            the OpenSearch namespace element <i>startIndex</i> text value
-	 *            as an integer.
-	 */
-	public void setStartIndex(int aIndex);
-
-	/**
-	 * @param aInt -
-	 *            the OpenSearch namespace element <i>itemsPerPage</i> text
-	 *            value as an integer.
-	 */
-	public void setItemsPerPage(int aInt);
-
-	/**
-	 * 
-	 * @return the default namespace - this will always be
-	 *         {@link GOMNamespace#ATOM_NAMESPACE}
-	 */
-	public GOMNamespace getDefaultNamespace();
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMGenerator.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMGenerator.java
deleted file mode 100644
index a8ee0c0..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMGenerator.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom;
-
-/**
- * Class representing the "atom:generator" element. The "atom:generator"
- * element's content identifies the agent used to generate a feed, for debugging
- * and other purposes.
- * 
- * <pre>
- *   atomGenerator = element atom:generator {
- *   atomCommonAttributes,
- *   attribute uri { atomUri }?,
- *   attribute version { text }?,
- *   text
- *   }
- * </pre>
- * 
- * 
- * @author Simon Willnauer
- * 
- */
-public interface GOMGenerator extends GOMElement {
-	/**
-	 * Atom local name for the xml element
-	 */
-	public static final String LOCALNAME = "generator";
-
-	/**
-	 * Sets the the atom:generator <i>uri</i> attribute value
-	 * 
-	 * @param uri -
-	 *            the generator <i>uri</i> attribute value to set
-	 */
-	public void setUri(String uri);
-
-	/**
-	 * Sets the the atom:generator <i>version</i> attribute value
-	 * 
-	 * @param version -
-	 *            the version value to set
-	 */
-	public void setGeneratorVersion(String version);
-
-	/**
-	 * 
-	 * @return - the atom:generator <i>version</i> attribute value
-	 */
-	public String getGeneratorVersion();
-
-	/**
-	 * 
-	 * @return - the atom:generator <i>uri</i> attribute value
-	 */
-	public String getUri();
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMIcon.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMIcon.java
deleted file mode 100644
index 35c58b4..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMIcon.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom;
-
-/**
- * 
- * Simple atom:icon element class. The "atom:icon" element's content is an IRI
- * reference [RFC3987] that identifies an image that provides iconic visual
- * identification for a feed.
- * 
- * <pre>
- *  atomIcon = element atom:icon {
- *  atomCommonAttributes,
- *  (atomUri)
- *  }
- * </pre>
- * 
- * @author Simon Willnauer
- * 
- */
-public interface GOMIcon extends GOMElement {
-	/**
-	 * Atom local name for the xml element
-	 */
-	String LOCALNAME = "icon";
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMId.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMId.java
deleted file mode 100644
index 840613f..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMId.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom;
-
-/**
- * 
- * The "atom:id" element conveys a permanent, universally unique identifier for
- * an entry or feed.
- * 
- * <pre>
- *  atomId = element atom:id {
- *  atomCommonAttributes,
- *  (atomUri)
- *  }
- * </pre>
- * 
- * @author Simon Willnauer
- * 
- */
-public interface GOMId extends GOMElement {
-	/**
-	 * Atom local name for the xml element
-	 */
-	public static final String LOCALNAME = "id";
-
-	/**
-	 * RSS local name for the xml element
-	 */
-	public static final String LOCALNAME_RSS = "uid";
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMLink.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMLink.java
deleted file mode 100644
index 5c59005..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMLink.java
+++ /dev/null
@@ -1,113 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom;
-
-/**
- * The "atom:link" element defines a reference from an entry or feed to a Web
- * resource. This specification assigns no meaning to the content (if any) of
- * this element.
- * 
- * <pre>
- *  atomLink =
- *  element atom:link {
- *  atomCommonAttributes,
- *  attribute href { atomUri },
- *  attribute rel { atomNCName | atomUri }?,
- *  attribute type { atomMediaType }?,
- *  attribute hreflang { atomLanguageTag }?,
- *  attribute title { text }?,
- *  attribute length { text }?,
- *  undefinedContent
- *  }
- * </pre>
- * 
- * @author Simon Willnauer
- * 
- */
-public interface GOMLink extends GOMElement {
-	/**
-	 * Atom local name for the xml element
-	 */
-	public static final String LOCALNAME = "link";
-
-	/**
-	 * @return - the href attribute value of the element link
-	 */
-	public String getHref();
-
-	/**
-	 * @param aHref -
-	 *            the href attribute value of the element link to set.
-	 */
-	public void setHref(String aHref);
-
-	/**
-	 * @return the hreflang attribute value of the element link
-	 */
-	public String getHrefLang();
-
-	/**
-	 * @param aHrefLang -
-	 *            the hreflang attribute value of the element link to set.
-	 */
-	public void setHrefLang(String aHrefLang);
-
-	/**
-	 * @return - the length attribute value of the element link.
-	 */
-	public Integer getLength();
-
-	/**
-	 * @param aLength -
-	 *            the length attribute value of the element link to set.
-	 */
-	public void setLength(Integer aLength);
-
-	/**
-	 * @return - the rel attribute value of the element link.
-	 */
-	public String getRel();
-
-	/**
-	 * @param aRel -
-	 *            the rel attribute value of the element link to set
-	 */
-	public void setRel(String aRel);
-
-	/**
-	 * @return - the title attribute value of the element link.
-	 */
-	public String getTitle();
-
-	/**
-	 * @param aTitle -
-	 *            the title attribute value of the element link to set
-	 */
-	public void setTitle(String aTitle);
-
-	/**
-	 * @return - the type attribute value of the element link.
-	 */
-	public String getType();
-
-	/**
-	 * @param aType -
-	 *            the type attribute value of the element link.
-	 */
-	public void setType(String aType);
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMLogo.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMLogo.java
deleted file mode 100644
index 440b9af..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMLogo.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom;
-
-import org.apache.lucene.gdata.gom.GOMElement;
-
-// TODO add descrition
-/**
- * Simple atom:logo element. The "atom:logo" element's content is an IRI
- * reference [RFC3987] that identifies an image that provides visual
- * identification for a feed.
- * 
- * <pre>
- *  atomLogo = element atom:logo {
- *  atomCommonAttributes,
- *  (atomUri)
- * </pre>
- * 
- * @author Simon Willnauer
- * 
- */
-public interface GOMLogo extends GOMElement {
-	/**
-	 * Atom local name for the xml element
-	 */
-	public static final String LOCALNAME = "logo";
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMNamespace.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMNamespace.java
deleted file mode 100644
index 6cfa41d..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMNamespace.java
+++ /dev/null
@@ -1,151 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom;
-
-/**
- * A simple domain object to represent a xml namespace.
- * 
- * @author Simon Willnauer
- * 
- */
-public final class GOMNamespace {
-
-	/**
-	 * XML namespace uri
-	 */
-	public static final String XML_NS_URI = "http://www.w3.org/XML/1998/namespace";
-
-	/**
-	 * XML namespace prefix
-	 */
-	public static final String XML_NS_PREFIX = "xml";
-
-	/**
-	 * Amazon "opensearch" namespace prefix
-	 */
-	public static final String OPENSEARCH_NS_PREFIX = "openSearch";
-
-	/**
-	 * Amazon "opensearch" namespace uri
-	 */
-	public static final String OPENSEARCH_NS_URI = "http://a9.com/-/spec/opensearchrss/1.0/";
-
-	/**
-	 * ATOM namespace uri
-	 */
-	public static final String ATOM_NS_URI = "http://www.w3.org/2005/Atom";
-
-	/**
-	 * ATOM namespace prefix
-	 */
-	public static final String ATOM_NS_PREFIX = "atom";
-
-	/**
-	 * ATOM namespace
-	 */
-	public static final GOMNamespace ATOM_NAMESPACE = new GOMNamespace(
-			ATOM_NS_URI, ATOM_NS_PREFIX);
-
-	/**
-	 * Amazon "opensearch" namespace
-	 */
-	public static final GOMNamespace OPENSEARCH_NAMESPACE = new GOMNamespace(
-			OPENSEARCH_NS_URI, OPENSEARCH_NS_PREFIX);
-
-	private final String namespaceUri;
-
-	private final String namespacePrefix;
-
-	/**
-	 * Class constructor for GOMNamespace
-	 * 
-	 * @param aNamespaceUri -
-	 *            the namespace uri (must not be null)
-	 * @param aNamespacePrefix -
-	 *            the namespace prefix (if null an empty string will be
-	 *            assigned)
-	 * 
-	 */
-	public GOMNamespace(final String aNamespaceUri,
-			final String aNamespacePrefix) {
-		if (aNamespaceUri == null)
-			throw new IllegalArgumentException("uri must not be null");
-		this.namespacePrefix = aNamespacePrefix == null ? "" : aNamespacePrefix;
-		this.namespaceUri = aNamespaceUri;
-	}
-
-	/**
-	 * @return Returns the namespacePrefix.
-	 */
-	public String getNamespacePrefix() {
-		return this.namespacePrefix;
-	}
-
-	/**
-	 * @return Returns the namespaceUri.
-	 */
-	public String getNamespaceUri() {
-		return this.namespaceUri;
-	}
-
-	/**
-	 * @see java.lang.Object#equals(java.lang.Object)
-	 */
-	@Override
-	public boolean equals(Object arg0) {
-		if (arg0 == null)
-			return false;
-		if (arg0 == this)
-			return true;
-		if (arg0 instanceof GOMNamespace) {
-			GOMNamespace other = (GOMNamespace) arg0;
-			return this.namespacePrefix.equals(other.getNamespacePrefix())
-					&& this.namespaceUri.equals(other.getNamespaceUri());
-		}
-		return false;
-	}
-
-	/**
-	 * @see java.lang.Object#hashCode()
-	 */
-	@Override
-	public int hashCode() {
-		/*
-		 * The multiplier 37 was chosen because it is an odd prime. If it was
-		 * even and the multiplication overflowed, information would be lost
-		 * because multiplication by two is equivalent to shifting The value 17
-		 * is arbitrary. see
-		 * http://java.sun.com/developer/Books/effectivejava/Chapter3.pdf
-		 */
-		int hash = 17;
-		hash = 37 * hash + this.namespacePrefix.hashCode();
-		hash = 37 * hash + this.namespaceUri.hashCode();
-		return hash;
-	}
-
-	/**
-	 * @see java.lang.Object#toString()
-	 */
-	@Override
-	public String toString() {
-		StringBuilder builder = new StringBuilder(this.getClass().getName());
-		builder.append(" uri: ").append(this.namespaceUri);
-		builder.append(" prefix: ").append(this.namespacePrefix);
-		return builder.toString();
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMPerson.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMPerson.java
deleted file mode 100644
index 6fedc07..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMPerson.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom;
-
-
-/**
- * 
- * GOMPerson type used for feed and entry authors and contributors. It may also
- * be used by custom elements.
- * 
- * <pre>
- *  
- *   atomPersonConstruct =
- *   atomCommonAttributes,
- *   (element atom:name { text }
- *   &amp; element atom:uri { atomUri }?
- *   &amp; element atom:email { atomEmailAddress }?
- *   &amp; extensionElement*)
- *   }
- * </pre>
- * 
- * @author Simon Willnauer
- * @see org.apache.lucene.gdata.gom.GOMAuthor
- */
-public interface GOMPerson extends GOMElement {
-	/**
-	 *  Atom local name for the xml element
-	 */
-	public static final String LOCALNAME = "person";
-
-	/**
-	 * @param aName - the person name value
-	 */
-	public abstract void setName(String aName);
-
-	/**
-	 * @param aEmail - the person email value
-	 */
-	public abstract void setEmail(String aEmail);
-
-	/**
-	 * @param uri - the person uri value
-	 */
-	public abstract void setUri(String uri);
-
-	/**
-	 * @return - the person name value
-	 */
-	public abstract String getName();
-
-	/**
-	 * @return - the person email value
-	 */
-	public abstract String getEmail();
-
-	/**
-	 * @return - the person uri value
-	 */
-	public abstract String getUri();
-	// TODO needs extension possibility
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMPublished.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMPublished.java
deleted file mode 100644
index 55036a8..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMPublished.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom;
-
-/**
- * 
- * The "atom:published" element is a Date construct indicating an instant in
- * time associated with an event early in the life cycle of the entry.
- * Typically, atom:published will be associated with the initial creation or
- * first availability of the resource.
- * 
- * <pre>
- *  atomPublished = element atom:published { atomDateConstruct}
- * </pre>
- * 
- * @author Simon Willnauer
- * @see org.apache.lucene.gdata.gom.GOMDateConstruct
- */
-public interface GOMPublished extends GOMDateConstruct {
-	/**
-	 * Atom local name for the xml element
-	 */
-	public static final String LOCALNAME = "published";
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMRights.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMRights.java
deleted file mode 100644
index ff794c6..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMRights.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom;
-
-import org.apache.lucene.gdata.gom.GOMElement;
-
-/**
- * 
- * The "atom:rights" element is a Text construct that conveys information about
- * rights held in and over an entry or feed. The atom:rights element SHOULD NOT
- * be used to convey machine-readable licensing information.
- * 
- * <pre>
- *  atomRights = element atom:rights { atomTextConstruct }
- * </pre>
- * 
- * @author Simon Willnauer
- * 
- */
-public interface GOMRights extends GOMElement {
-	/**
-	 * Atom local name for the xml element
-	 */
-	public static final String LOCALNAME = "rights";
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMSource.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMSource.java
deleted file mode 100644
index 2e17711..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMSource.java
+++ /dev/null
@@ -1,120 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom;
-
-import java.util.List;
-
-/**
- * If an atom:entry is copied from one feed into another feed, then the source
- * atom:feed's metadata (all child elements of atom:feed other than the
- * atom:entry elements) MAY be preserved within the copied entry by adding an
- * atom:source child element, if it is not already present in the entry, and
- * including some or all of the source feed's Metadata elements as the
- * atom:source element's children. Such metadata SHOULD be preserved if the
- * source atom:feed contains any of the child elements atom:author,
- * atom:contributor, atom:rights, or atom:category and those child elements are
- * not present in the source atom:entry.
- * 
- * <pre>
- *    atomSource =
- *    element atom:source {
- *    atomCommonAttributes,
- *    (atomAuthor*
- *    &amp; atomCategory*
- *    &amp; atomContributor*
- *    &amp; atomGenerator?
- *    &amp; atomIcon?
- *    &amp; atomId?
- *    &amp; atomLink*
- *    &amp; atomLogo?
- *    &amp; atomRights?
- *    &amp; atomSubtitle?
- *    &amp; atomTitle?
- *    &amp; atomUpdated?
- *    &amp; extensionElement*)
- *    }
- * </pre>
- * 
- * @author Simon Willnauer
- * 
- */
-public interface GOMSource extends GOMXmlEntity, GOMElement {
-	public static final String LOCALNAME = "source";
-
-	/**
-	 * @param aAuthor
-	 */
-	public void addAuthor(GOMAuthor aAuthor);
-
-	/**
-	 * @param aCategory
-	 */
-	public void addCategory(GOMCategory aCategory);
-
-	/**
-	 * @param aContributor
-	 */
-	public void addContributor(GOMContributor aContributor);
-
-	/**
-	 * @param aLink
-	 */
-	public void addLink(GOMLink aLink);
-
-	public List<GOMAuthor> getAuthors();
-
-	public List<GOMCategory> getCategories();
-
-	public List<GOMContributor> getContributor();
-
-	public GOMGenerator getGenerator();
-
-	public GOMId getId();
-
-	public void setGenerator(GOMGenerator aGenerator);
-
-	public void setIcon(GOMIcon aIcon);
-
-	public void setId(GOMId aId);
-
-	public GOMLogo getLogo();
-
-	public void setLogo(GOMLogo aLogo);
-
-	public GOMRights getRights();
-
-	public void setRights(GOMRights aRights);
-
-	public GOMSubtitle getSubtitle();
-
-	public void setSubtitle(GOMSubtitle aSubtitle);
-
-	public GOMTitle getTitle();
-
-	public void setTitle(GOMTitle aTitle);
-
-	public GOMUpdated getUpdated();
-
-	public void setUpdated(GOMUpdated aUpdated);
-
-	public GOMIcon getIcon();
-
-	public List<GOMLink> getLinks();
-	
-	//TODO needs extension elements
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMSubtitle.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMSubtitle.java
deleted file mode 100644
index c5116c5..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMSubtitle.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom;
-
-/**
- * 
- * The "atom:subtitle" element is a Text construct that conveys a human-readable
- * description or subtitle for a feed.
- * 
- * <pre>
- *  atomSubtitle = element atom:subtitle { atomTextConstruct }
- * </pre>
- * 
- * @author Simon Willnauer
- * @see org.apache.lucene.gdata.gom.GOMTextConstruct
- */
-public interface GOMSubtitle extends GOMTextConstruct {
-	/**
-	 * Atom local name for the xml element
-	 */
-	public static final String LOCALNAME = "subtitle";
-
-	/**
-	 * RSS local name for the xml element
-	 */
-	public static final String RSS_LOCALNAME = "description";
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMSummary.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMSummary.java
deleted file mode 100644
index def9765..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMSummary.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public interface GOMSummary extends GOMTextConstruct {
-
-	/**
-	 * Atom local name for the xml element
-	 */
-	public static final String LOCALNAME = "summary";
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMTextConstruct.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMTextConstruct.java
deleted file mode 100644
index be72991..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMTextConstruct.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public interface GOMTextConstruct extends GOMElement {
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMTime.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMTime.java
deleted file mode 100644
index e2653be..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMTime.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom;
-
-import org.apache.lucene.gdata.gom.GOMElement;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public interface GOMTime extends GOMElement {
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMTitle.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMTitle.java
deleted file mode 100644
index 75f8e14..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMTitle.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom;
-
-/**
- * 
- * The "atom:title" element is a Text construct that conveys a human-readable
- * title for an entry or feed.
- * 
- * <pre>
- *  atomTitle = element atom:title { atomTextConstruct }
- * </pre>
- * 
- * @author Simon Willnauer
- * 
- */
-public interface GOMTitle extends GOMElement {
-
-	/**
-	 * Atom local name for the xml element
-	 */
-	public static final String LOCALNAME = "title";
-
-	/**
-	 * @return - the content type attribute value as a {@link ContentType}
-	 * @see ContentType
-	 */
-	public abstract ContentType getContentType();
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMUpdated.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMUpdated.java
deleted file mode 100644
index e0bd13a..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMUpdated.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom;
-
-/**
- * 
- * The "atom:updated" element is a Date construct indicating the most recent
- * instant in time when an entry or feed was modified in a way the publisher
- * considers significant. Therefore, not all modifications necessarily result in
- * a changed atom:updated value.
- * 
- * <pre>
- *  atomUpdated = element atom:updated { atomDateConstruct}
- * </pre>
- * 
- * @author Simon Willnauer
- * @see org.apache.lucene.gdata.gom.GOMDateConstruct
- */
-public interface GOMUpdated extends GOMDateConstruct {
-	/**
-	 * Atom local name for the xml element
-	 */
-	public static final String LOCALNAME = "updated";
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMXmlEntity.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMXmlEntity.java
deleted file mode 100644
index b73ed26..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/GOMXmlEntity.java
+++ /dev/null
@@ -1,69 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.gom;
-
-import javax.xml.namespace.QName;
-
-/**
- * GOMXmlEntity is a abstract base interface for all Gdata Object Model
- * Interfaces to be implemented by any class which is a part of the GOM. This
- * interface defines a basic interface for xml attributes and elements
- * 
- * @author Simon Willnauer
- * 
- */
-public abstract interface GOMXmlEntity {
-
-	/**
-	 * @return - the entities QName
-	 * @see QName
-	 * 
-	 */
-	public abstract QName getQname();
-
-	/**
-	 * @param aString - the namespace uri to set
-	 */
-	public abstract void setNamespaceUri(String aString);
-
-	/**
-	 * @param aString - the namespace prefix to set
-	 */
-	public abstract void setNamespacePrefix(String aString);
-
-	/**
-	 * @param aLocalName - the localname of the entitiy
-	 */
-	public abstract void setLocalName(String aLocalName);
-
-	/**
-	 * @return - the local name of the entitiy
-	 */
-	public abstract String getLocalName();
-
-	/**
-	 * @return - the text value of the entity
-	 */
-	public abstract String getTextValue();
-
-	/**
-	 * @param aTextValue - the text value of the entity
-	 */
-	public abstract void setTextValue(String aTextValue);
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/AbstractGOMElement.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/AbstractGOMElement.java
deleted file mode 100644
index ab2c694..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/AbstractGOMElement.java
+++ /dev/null
@@ -1,232 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import java.util.LinkedList;
-import java.util.List;
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.GOMAttribute;
-import org.apache.lucene.gdata.gom.GOMElement;
-import org.apache.lucene.gdata.gom.GOMNamespace;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-/**
- * @author Simon Willnauer
- */
-public abstract class AbstractGOMElement implements GOMElement {
-	/**
-	 * atomCommonAttribute <br/> attribute xml:lang { atomLanguageTag }?
-	 */
-	protected String xmlLang;
-
-	/**
-	 * atomCommonAttribute <br/> attribute xml:base { atomUri }?
-	 */
-	protected String xmlBase;
-
-	protected QName qname;
-
-	protected String textValue;
-
-	protected String localName;
-
-	protected String nsUri;
-
-	protected String nsPrefix;
-
-	/**
-	 * atomCommonAttributes <br/> undefinedAttribute*
-	 */
-	protected List<GOMAttribute> extensionAttributes = new LinkedList<GOMAttribute>();
-
-	/**
-	 * {@inheritDoc}
-	 * 
-	 * @see org.apache.lucene.gdata.gom.GOMXmlEntity#getQname()
-	 */
-	public QName getQname() {
-		return this.qname;
-	}
-
-	/**
-	 * {@inheritDoc}
-	 * 
-	 * @see org.apache.lucene.gdata.gom.GOMXmlEntity#getTextValue()
-	 */
-	public String getTextValue() {
-		return this.textValue;
-	}
-
-	/**
-	 * {@inheritDoc}
-	 * 
-	 * @see org.apache.lucene.gdata.gom.GOMXmlEntity#setTextValue(java.lang.String)
-	 */
-	public void setTextValue(String aTextValue) {
-		this.textValue = aTextValue;
-
-	}
-
-	/**
-	 * {@inheritDoc}
-	 * 
-	 * @see org.apache.lucene.gdata.gom.GOMXmlEntity#getLocalName()
-	 */
-	public String getLocalName() {
-		return this.localName;
-	}
-
-	/**
-	 * {@inheritDoc}
-	 * 
-	 * @see org.apache.lucene.gdata.gom.GOMXmlEntity#setLocalName(java.lang.String)
-	 */
-	public void setLocalName(String aLocalName) {
-		// must override
-	}
-
-	protected void addAttribute(GOMAttribute aAttribute) {
-		if (aAttribute != null)
-			this.extensionAttributes.add(aAttribute);
-
-	}
-
-	/**
-	 * {@inheritDoc}
-	 * 
-	 * @see org.apache.lucene.gdata.gom.core.AtomParser#getChildParser(javax.xml.namespace.QName)
-	 */
-	public AtomParser getChildParser(QName aName) {
-		throw new GDataParseException(String.format(UNEXPECTED_ELEMENT_CHILD,
-				this.qname));
-	}
-
-	/**
-	 * {@inheritDoc}
-	 * 
-	 * @see org.apache.lucene.gdata.gom.core.AtomParser#processAttribute(javax.xml.namespace.QName,
-	 *      java.lang.String)
-	 */
-	public void processAttribute(QName aQName, String aValue) {
-		if (aQName == null)
-			throw new GDataParseException("QName must not be null");
-		if (aQName.getNamespaceURI().equals(GOMNamespace.XML_NS_URI)) {
-			if (aQName.getLocalPart().equals(XML_BASE))
-				this.xmlBase = aValue;
-			else if (aQName.getLocalPart().equals(XML_LANG))
-				this.xmlLang = aValue;
-
-		} else {
-			GOMAttributeImpl impl = new GOMAttributeImpl(aQName
-					.getNamespaceURI(), aQName.getPrefix(), aQName
-					.getLocalPart(), aValue);
-			this.addAttribute(impl);
-		}
-
-	}
-
-	/**
-	 * {@inheritDoc}
-	 * 
-	 * @see org.apache.lucene.gdata.gom.core.AtomParser#processElementValue(java.lang.String)
-	 */
-	public void processElementValue(String aValue) {
-		throw new GDataParseException(String.format(UNEXPECTED_ELEMENT_VALUE,
-				this.qname));
-	}
-
-	/**
-	 * {@inheritDoc}
-	 * 
-	 * @see org.apache.lucene.gdata.gom.core.AtomParser#processEndElement()
-	 */
-	public void processEndElement() {
-		// no post processing
-
-	}
-
-	/**
-	 * {@inheritDoc}
-	 * 
-	 * @see org.apache.lucene.gdata.gom.GOMXmlEntity#setNamespaceUri(java.lang.String)
-	 */
-	public void setNamespaceUri(String aString) {
-		this.nsUri = aString;
-
-	}
-
-	/**
-	 * 
-	 * {@inheritDoc}
-	 * 
-	 * @see org.apache.lucene.gdata.gom.GOMXmlEntity#setNamespacePrefix(java.lang.String)
-	 */
-	public void setNamespacePrefix(String aString) {
-		this.nsPrefix = aString;
-	}
-
-	protected List<GOMAttribute> getXmlNamespaceAttributes() {
-		List<GOMAttribute> retVal = new LinkedList<GOMAttribute>();
-		if (this.xmlBase != null)
-			retVal.add(new GOMAttributeImpl(GOMNamespace.XML_NS_URI,
-					GOMNamespace.XML_NS_PREFIX, "base", this.xmlBase));
-		if (this.xmlLang != null)
-			retVal.add(new GOMAttributeImpl(GOMNamespace.XML_NS_URI,
-					GOMNamespace.XML_NS_PREFIX, "lang", this.xmlLang));
-		return retVal;
-
-	}
-
-	/**
-	 * {@inheritDoc}
-	 * 
-	 * @see org.apache.lucene.gdata.gom.GOMElement#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter,
-	 *      java.lang.String)
-	 */
-	public void writeRssOutput(GOMOutputWriter aStreamWriter, String aRssName)
-			throws XMLStreamException {
-
-	}
-
-
-
-
-	/**
-	 * 
-	 * {@inheritDoc}
-	 * 
-	 * @see org.apache.lucene.gdata.gom.GOMElement#getXmlBase()
-	 */
-	public String getXmlBase() {
-		return this.xmlBase;
-	}
-
-	/**
-	 * 
-	 * {@inheritDoc}
-	 * 
-	 * @see org.apache.lucene.gdata.gom.GOMElement#getXmlLang()
-	 */
-	public String getXmlLang() {
-
-		return this.xmlLang;
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/ArbitraryGOMXml.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/ArbitraryGOMXml.java
deleted file mode 100644
index 37e2de6..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/ArbitraryGOMXml.java
+++ /dev/null
@@ -1,162 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import java.util.LinkedList;
-import java.util.List;
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.GOMAttribute;
-import org.apache.lucene.gdata.gom.GOMElement;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-//TODO add java doc
-/**
- * 
- * @author Simon Willnauer
- * 
- */
-public class ArbitraryGOMXml extends AbstractGOMElement {
-	private List<GOMElement> children = new LinkedList<GOMElement>();
-
-	private List<GOMAttribute> attributes = new LinkedList<GOMAttribute>();
-
-	/**
-	 * this method will never return <code>null</code>
-	 * 
-	 * @return Returns the attributes of this xml element.
-	 */
-	public List<GOMAttribute> getAttributes() {
-		return this.attributes;
-	}
-
-	/**
-	 * this method will never return <code>null</code>
-	 * 
-	 * @return - the child elements of this xml element
-	 */
-	public List<GOMElement> getChildren() {
-		return this.children;
-	}
-
-	/**
-	 * Class constructor
-	 * 
-	 * @param qname -
-	 *            the elements qname
-	 */
-	public ArbitraryGOMXml(QName qname) {
-		if (qname == null)
-			throw new IllegalArgumentException("QName must not be null");
-
-		this.qname = qname;
-		this.localName = qname.getLocalPart();
-	}
-
-	/**
-	 * {@inheritDoc} 
-	 * 
-	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#getChildParser(javax.xml.namespace.QName)
-	 */
-	@Override
-	public AtomParser getChildParser(QName aName) {
-		if (aName == null)
-			throw new GDataParseException("QName must not be null");
-		/*
-		 * either a text value or a child
-		 */
-		if (this.textValue != null)
-			throw new GDataParseException(String.format(
-					AtomParser.UNEXPECTED_ELEMENT_CHILD, this.localName));
-		GOMElement element = new ArbitraryGOMXml(aName);
-		this.children.add(element);
-		return element;
-	}
-
-	/**
-	 * {@inheritDoc} 
-	 * 
-	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#processAttribute(javax.xml.namespace.QName,
-	 *      java.lang.String)
-	 */
-	@Override
-	public void processAttribute(QName aQName, String aValue) {
-		if (aQName == null)
-			throw new GDataParseException("QName must not be null");
-		GOMAttributeImpl impl = new GOMAttributeImpl(aQName.getNamespaceURI(),
-				aQName.getPrefix(), aQName.getLocalPart(), aValue);
-		this.attributes.add(impl);
-
-	}
-
-	/**
-	 * {@inheritDoc}
-	 * 
-	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#processElementValue(java.lang.String)
-	 */
-	@Override
-	public void processElementValue(String aValue) {
-		if (aValue == null)
-			throw new GDataParseException("Element value must not be null");
-		/*
-		 * either a text value or a child
-		 */
-		if (this.children.size() > 0)
-			throw new GDataParseException(String.format(
-					AtomParser.UNEXPECTED_ELEMENT_VALUE, this.localName));
-		if (this.textValue != null)
-			throw new GDataParseException(String.format(
-					AtomParser.UNEXPECTED_ELEMENT_VALUE, this.localName));
-		this.textValue = aValue;
-
-	}
-
-	/**
-	 * {@inheritDoc}
-	 * 
-	 * @see org.apache.lucene.gdata.gom.GOMElement#writeAtomOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
-	 */
-	public void writeAtomOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-		if (aStreamWriter == null)
-			throw new NullPointerException("StreamWriter is null");
-		aStreamWriter.writeStartElement(this.qname, this.attributes);
-		if (this.textValue == null) {
-			for (GOMElement element : this.children) {
-				element.writeAtomOutput(aStreamWriter);
-			}
-		} else {
-			aStreamWriter.writeContent(this.textValue);
-		}
-		aStreamWriter.writeEndElement();
-
-	}
-
-	/**
-	 * {@inheritDoc}
-	 * 
-	 * @see org.apache.lucene.gdata.gom.GOMElement#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
-	 */
-	public void writeRssOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-		// delegate it by default
-		this.writeAtomOutput(aStreamWriter);
-
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/AtomParser.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/AtomParser.java
deleted file mode 100644
index a0178c9..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/AtomParser.java
+++ /dev/null
@@ -1,134 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import javax.xml.namespace.QName;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public interface AtomParser {
-
-	/**
-	 * Error message for an unexpected element
-	 * @see String#format(java.lang.String, java.lang.Object[])
-	 */
-	public static final String UNEXPECTED_ELEMENT = "Expected Element '%s' but was '%s' ";
-
-
-	/**
-	 * Error message for an unexpected element child
-	 * @see String#format(java.lang.String, java.lang.Object[])
-	 */
-	public static final String UNEXPECTED_ELEMENT_CHILD = "Element '%s' can not contain child elements ";
-
-	/**
-	 * Error message for an urecognized element child
-	 * @see String#format(java.lang.String, java.lang.Object[])
-	 */
-	public static final String URECOGNIZED_ELEMENT_CHILD = "Element '%s' can not contain child elements of the type %s";
-
-	/**
-	 * Error message for an unexpected attribute
-	 * @see String#format(java.lang.String, java.lang.Object[])
-	 */
-	public static final String UNEXPECTED_ATTRIBUTE = "Element '%s' can not contain attributes ";
-
-	/**
-	 * Error message for an unexpected element value
-	 * @see String#format(java.lang.String, java.lang.Object[])
-	 */
-	public static final String UNEXPECTED_ELEMENT_VALUE = "Element '%s' can not contain any element value";
-
-	/**
-	 * Error message for a missing element attribute
-	 * @see String#format(java.lang.String, java.lang.Object[])
-	 */
-	public static final String MISSING_ELEMENT_ATTRIBUTE = "Element '%s' requires an '%s' attribute";
-
-	/**
-	 * Error message for a missing element child
-	 * @see String#format(java.lang.String, java.lang.Object[])
-	 */
-	public static final String MISSING_ELEMENT_CHILD = "Element '%s' requires a child of the type '%s'";
-
-	/**
-	 * Error message for a missing element value
-	 * @see String#format(java.lang.String, java.lang.Object[])
-	 */
-	public static final String MISSING_ELEMENT_VALUE = "Element '%s' requires a element value of the type '%s'";
-
-	/**
-	 * Error message for a missing element value 
-	 * @see String#format(java.lang.String, java.lang.Object[])
-	 */
-	public static final String MISSING_ELEMENT_VALUE_PLAIN = "Element '%s' requires a element value'";
-
-	/**
-	 * Error message for a duplicated element
-	 * @see String#format(java.lang.String, java.lang.Object[])
-	 */
-	public static final String DUPLICATE_ELEMENT = "Duplicated Element '%s'";
-
-	/**
-	 * Error message for a duplicated element value
-	 * @see String#format(java.lang.String, java.lang.Object[])
-	 */
-	public static final String DUPLICATE_ELEMENT_VALUE = "Duplicated Element value for element '%s'";
-
-	/**
-	 * Error message for a duplicated attribute
-	 * @see String#format(java.lang.String, java.lang.Object[])
-	 */
-	public static final String DUPLICATE_ATTRIBUTE = "Duplicated Attribute '%s'";
-
-	/**
-	 * Error message for an invalid attribute
-	 * @see String#format(java.lang.String, java.lang.Object[])
-	 */
-	public static final String INVALID_ATTRIBUTE = "The attribute '%s' must be an %s";
-
-	/**
-	 * Error message for an invalid element value
-	 * @see String#format(java.lang.String, java.lang.Object[])
-	 */
-	public static final String INVALID_ELEMENT_VALUE = "The element value '%s' must be an %s";
-
-	/**
-	 * @param aValue
-	 */
-	public abstract void processElementValue(String aValue);
-
-	/**
-	 * @param aQName
-	 * @param aValue
-	 */
-	public abstract void processAttribute(QName aQName, String aValue);
-
-	/**
-	 * 
-	 */
-	public abstract void processEndElement();
-
-	/**
-	 * @param name
-	 * @return
-	 */
-	public abstract AtomParser getChildParser(QName name);
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/AtomUriElement.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/AtomUriElement.java
deleted file mode 100644
index 8bade2e..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/AtomUriElement.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import java.net.URISyntaxException;
-
-import org.apache.lucene.gdata.gom.core.utils.AtomParserUtils;
-
-/**
- * @author Simon Willnauer
- * 
- */
-abstract class AtomUriElement extends SimpleGOMElementImpl {
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.SimpleGOMElementImpl#processEndElement()
-	 */
-	@Override
-	public void processEndElement() {
-		if (this.textValue == null)
-			throw new GDataParseException(String.format(
-					MISSING_ELEMENT_VALUE, this.localName, "atomUri"));
-		try {
-			AtomParserUtils.getAbsolutAtomURI(this.xmlBase, this.textValue);
-		} catch (URISyntaxException e) {
-			throw new GDataParseException(String.format(INVALID_ELEMENT_VALUE,
-					this.localName, "absolute uri"), e);
-		}
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GDataParseException.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GDataParseException.java
deleted file mode 100644
index 3978198..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GDataParseException.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class GDataParseException extends RuntimeException {
-
-	/**
-	 * Serial Version ID -- implements {@link java.io.Serializable}
-	 */
-	private static final long serialVersionUID = -3633604155009277238L;
-
-	/**
-	 * 
-	 */
-	public GDataParseException() {
-	}
-
-	/**
-	 * @param arg0
-	 */
-	public GDataParseException(String arg0) {
-		super(arg0);
-	}
-
-	/**
-	 * @param arg0
-	 */
-	public GDataParseException(Throwable arg0) {
-		super(arg0);
-	}
-
-	/**
-	 * @param arg0
-	 * @param arg1
-	 */
-	public GDataParseException(String arg0, Throwable arg1) {
-		super(arg0, arg1);
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMAttributeImpl.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMAttributeImpl.java
deleted file mode 100644
index 8e6baab..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMAttributeImpl.java
+++ /dev/null
@@ -1,151 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import javax.xml.namespace.QName;
-
-import org.apache.lucene.gdata.gom.GOMAttribute;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class GOMAttributeImpl implements GOMAttribute {
-	private boolean hasDefaultNamespace;
-
-	private QName qName;
-
-	private String localName;
-
-	private String uri;
-
-	private String prefix;
-
-	private String value;
-
-	/**
-	 * 
-	 */
-	public GOMAttributeImpl() {
-		super();
-	}
-
-	/**
-	 * @param localName
-	 * @param value
-	 */
-	public GOMAttributeImpl(String localName, String value) {
-		this.hasDefaultNamespace = true;
-		this.value = value;
-		this.localName = localName;
-	}
-
-	/**
-	 * @param namespaceUri
-	 * @param namespacePrefix
-	 * @param localName
-	 * @param value
-	 */
-	public GOMAttributeImpl(String namespaceUri, String namespacePrefix,
-			String localName, String value) {
-		this.localName = localName;
-		this.uri = namespaceUri;
-		this.prefix = namespacePrefix;
-		this.value = value;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMXmlEntity#getQname()
-	 */
-	public QName getQname() {
-		if (this.qName == null)
-			this.qName = new QName(this.uri, (this.localName == null ? ""
-					: this.localName), (this.prefix == null ? "" : this.prefix));
-		return this.qName;
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMXmlEntity#setLocalName(java.lang.String)
-	 */
-	public void setLocalName(String aLocalName) {
-		if (aLocalName == null)
-			return;
-		this.qName = null;
-		this.localName = aLocalName;
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMXmlEntity#getLocalName()
-	 */
-	public String getLocalName() {
-		return this.localName;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMXmlEntity#getTextValue()
-	 */
-	public String getTextValue() {
-		return this.value == null ? "" : this.value;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMXmlEntity#setTextValue(java.lang.String)
-	 */
-	public void setTextValue(String aTextValue) {
-		this.value = aTextValue;
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMAttribute#hasDefaultNamespace()
-	 */
-	public boolean hasDefaultNamespace() {
-
-		return this.hasDefaultNamespace;
-	}
-
-	void setHasDefaultNamespace(boolean aBoolean) {
-		this.hasDefaultNamespace = aBoolean;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMXmlEntity#setNamespaceUri(java.lang.String)
-	 */
-	public void setNamespaceUri(String aString) {
-		if (aString == null)
-			return;
-		this.qName = null;
-		this.hasDefaultNamespace = false;
-		this.uri = aString;
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMXmlEntity#setNamespacePrefix(java.lang.String)
-	 */
-	public void setNamespacePrefix(String aString) {
-		if (aString == null)
-			return;
-		this.qName = null;
-		this.hasDefaultNamespace = false;
-		this.prefix = aString;
-
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMAuthorImpl.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMAuthorImpl.java
deleted file mode 100644
index 4045c1c..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMAuthorImpl.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.GOMAuthor;
-import org.apache.lucene.gdata.gom.GOMNamespace;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class GOMAuthorImpl extends GOMPersonImpl implements GOMAuthor {
-	/**
-	 * 
-	 */
-	public GOMAuthorImpl() {
-		this.localName = GOMAuthor.LOCALNAME;
-		this.qname = new QName(GOMNamespace.ATOM_NS_URI, this.localName);
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.GOMPersonImpl#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
-	 */
-	@Override
-	public void writeRssOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-		writeRssOutput(aStreamWriter, this.localName);
-
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMBuilder.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMBuilder.java
deleted file mode 100644
index e92cfb5..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMBuilder.java
+++ /dev/null
@@ -1,154 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import java.util.Stack;
-
-import javax.xml.stream.XMLStreamConstants;
-import javax.xml.stream.XMLStreamException;
-import javax.xml.stream.XMLStreamReader;
-
-import org.apache.lucene.gdata.gom.GOMDocument;
-import org.apache.lucene.gdata.gom.GOMEntry;
-import org.apache.lucene.gdata.gom.GOMFeed;
-import org.apache.lucene.gdata.gom.GOMNamespace;
-
-/**
- * @author Simon Willnauer
- */
-public class GOMBuilder {
-
-	private final XMLStreamReader streamReader;
-
-	private final GOMFactory factory;
-
-	private final Stack<AtomParser> parserStack;
-
-	/**
-	 * @param arg0
-	 */
-	public GOMBuilder(XMLStreamReader arg0) {
-		if (arg0 == null)
-			throw new IllegalArgumentException(
-					"XMLStreamReader instance must not be null");
-		this.streamReader = arg0;
-		this.factory = GOMFactory.createInstance();
-		this.parserStack = new Stack<AtomParser>();
-	}
-
-	public GOMDocument<GOMFeed> buildGOMFeed() throws XMLStreamException {
-		GOMDocument<GOMFeed> document = new GOMDocumentImpl<GOMFeed>();
-		GOMFeed element = startFeedDocument(document);
-		document.setRootElement(element);
-		parse(this.streamReader);
-
-		return document;
-	}
-
-	private void parse(XMLStreamReader aReader) throws XMLStreamException {
-
-		int next = 0;
-
-		while ((next = next()) != XMLStreamConstants.END_DOCUMENT) {
-
-			if (next == XMLStreamConstants.START_ELEMENT) {
-				AtomParser childParser = this.parserStack.peek()
-						.getChildParser(this.streamReader.getName());
-				processAttributes(childParser);
-				this.parserStack.push(childParser);
-			} else if (next == XMLStreamConstants.END_ELEMENT) {
-				this.parserStack.pop().processEndElement();
-			} else if (next == XMLStreamConstants.CHARACTERS) {
-				this.parserStack.peek().processElementValue(
-						this.streamReader.getText());
-			} else if (next == XMLStreamConstants.CDATA) {
-				System.out.println("CDdata");
-			}
-			// System.out.println(next);
-		}
-
-	}
-
-	/**
-	 * @param childParser
-	 */
-	private void processAttributes(AtomParser childParser) {
-		int attributeCount = this.streamReader.getAttributeCount();
-		for (int i = 0; i < attributeCount; i++) {
-			childParser.processAttribute(this.streamReader.getAttributeName(i),
-					this.streamReader.getAttributeValue(i));
-		}
-	}
-
-	public GOMDocument<GOMEntry> buildGOMEntry() throws XMLStreamException {
-		GOMDocument<GOMEntry> document = new GOMDocumentImpl<GOMEntry>();
-		GOMEntry element = startEntryDocument(document);
-		document.setRootElement(element);
-		parse(this.streamReader);
-
-		return document;
-
-	}
-
-	private GOMEntry startEntryDocument(GOMDocument aDocument)
-			throws XMLStreamException {
-		aDocument.setVersion(this.streamReader.getVersion());
-		aDocument.setCharacterEncoding(this.streamReader
-				.getCharacterEncodingScheme());
-		GOMEntry entry = this.factory.createEntry();
-		if (next() != XMLStreamConstants.START_ELEMENT)
-			throw new GDataParseException("Expected start of feed element");
-		processAttributes(entry);
-		this.parserStack.push(entry);
-		int count = this.streamReader.getNamespaceCount();
-		for (int i = 0; i < count; i++) {
-			GOMNamespace namespace = new GOMNamespace(this.streamReader
-					.getNamespaceURI(i), this.streamReader
-					.getNamespacePrefix(i));
-			entry.addNamespace(namespace);
-		}
-		return entry;
-	}
-
-	private GOMFeed startFeedDocument(GOMDocument aDocument)
-			throws XMLStreamException {
-		aDocument.setVersion(this.streamReader.getVersion());
-		aDocument.setCharacterEncoding(this.streamReader
-				.getCharacterEncodingScheme());
-		GOMFeed feed = this.factory.createFeed();
-		if (next() != XMLStreamConstants.START_ELEMENT)
-			throw new GDataParseException("Expected start of feed element");
-		processAttributes(feed);
-		this.parserStack.push(feed);
-		int count = this.streamReader.getNamespaceCount();
-		for (int i = 0; i < count; i++) {
-
-			GOMNamespace namespace = new GOMNamespace(this.streamReader
-					.getNamespaceURI(i), this.streamReader
-					.getNamespacePrefix(i));
-			System.out.println(namespace);
-			feed.addNamespace(namespace);
-		}
-		return feed;
-	}
-
-	private int next() throws XMLStreamException {
-		return this.streamReader.next();
-
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMCategoryImpl.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMCategoryImpl.java
deleted file mode 100644
index 91b69b6..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMCategoryImpl.java
+++ /dev/null
@@ -1,206 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import java.net.URISyntaxException;
-import java.util.LinkedList;
-import java.util.List;
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.GOMAttribute;
-import org.apache.lucene.gdata.gom.GOMCategory;
-import org.apache.lucene.gdata.gom.GOMNamespace;
-import org.apache.lucene.gdata.gom.core.utils.AtomParserUtils;
-import org.apache.lucene.gdata.gom.core.utils.GOMUtils;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class GOMCategoryImpl extends AbstractGOMElement implements GOMCategory {
-
-	private static final String DOMAIN = "domain";
-
-	protected String term;
-
-	protected String label;
-
-	protected String scheme;
-
-	/**
-	 * 
-	 */
-	public GOMCategoryImpl() {
-		super();
-		this.localName = LOCALNAME;
-		this.qname = new QName(GOMNamespace.ATOM_NS_URI, this.localName);
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMCategory#setTerm(java.lang.String)
-	 */
-	public void setTerm(String aTerm) {
-
-		this.term = aTerm;
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMCategory#setLabel(java.lang.String)
-	 */
-	public void setLabel(String aLabel) {
-		this.label = aLabel;
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMCategory#setScheme(java.lang.String)
-	 */
-	public void setScheme(String aScheme) {
-		this.scheme = aScheme;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMCategory#getTerm()
-	 */
-	public String getTerm() {
-		return this.term;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMCategory#getScheme()
-	 */
-	public String getScheme() {
-		return this.scheme;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMCategory#getLabel()
-	 */
-	public String getLabel() {
-		return this.label;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#processAttribute(javax.xml.namespace.QName,
-	 *      java.lang.String)
-	 */
-	@Override
-	public void processAttribute(QName aQName, String aValue) {
-		if (aQName == null)
-			throw new GDataParseException("QName must not be null");
-		if (aQName.getNamespaceURI().equals(GOMNamespace.ATOM_NS_URI)
-				|| aQName.getNamespaceURI().equals("")) {
-			String localPart = aQName.getLocalPart();
-			if (localPart.equals(TERM_ATTRIBUTE)) {
-				if (this.term != null)
-					throw new GDataParseException(String.format(
-							AtomParser.DUPLICATE_ATTRIBUTE, TERM_ATTRIBUTE));
-				this.term = aValue;
-			} else if (localPart.equals(LABLE_ATTRIBUTE)) {
-				if (this.label != null)
-					throw new GDataParseException(String.format(
-							AtomParser.DUPLICATE_ATTRIBUTE, LABLE_ATTRIBUTE));
-				this.label = aValue;
-			} else if (localPart.equals(SCHEME_ATTRIBUTE)) {
-				if (this.scheme != null)
-					throw new GDataParseException(String.format(
-							AtomParser.DUPLICATE_ATTRIBUTE, SCHEME_ATTRIBUTE));
-				this.scheme = aValue;
-			} else {
-				super.processAttribute(aQName, aValue);
-			}
-
-		} else {
-			super.processAttribute(aQName, aValue);
-		}
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#processEndElement()
-	 */
-	@Override
-	public void processEndElement() {
-		/*
-		 * ATOM defines "undefinedContent" for this. GData defines this as no
-		 * content containing element
-		 */
-		if (this.term == null)
-			throw new GDataParseException(String.format(
-					AtomParser.MISSING_ELEMENT_ATTRIBUTE, this.localName,
-					TERM_ATTRIBUTE));
-		if (this.scheme != null) {
-			try {
-				AtomParserUtils.getAbsolutAtomURI(this.xmlBase, this.scheme);
-			} catch (URISyntaxException e) {
-				throw new GDataParseException(String.format(
-						AtomParser.INVALID_ATTRIBUTE, this.localName
-								+ " attribute " + GOMCategory.SCHEME_ATTRIBUTE,
-						"absolute uri"), e);
-			}
-		}
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMElement#writeAtomOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
-	 */
-	public void writeAtomOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-		if (aStreamWriter == null)
-			throw new NullPointerException("StreamWriter is null");
-		List<GOMAttribute> list = new LinkedList<GOMAttribute>();
-		/*
-		 * term attribute is requiered for a category. attribute term { text },
-		 */
-		list.add(GOMUtils.buildDefaultNamespaceAttribute(this.term,
-				TERM_ATTRIBUTE));
-		if (this.scheme != null)
-			list.add(GOMUtils.buildDefaultNamespaceAttribute(this.scheme,
-					SCHEME_ATTRIBUTE));
-		if (this.label != null)
-			list.add(GOMUtils.buildDefaultNamespaceAttribute(this.label,
-					LABLE_ATTRIBUTE));
-
-		if (this.xmlLang != null)
-			list.add(GOMUtils
-					.buildXMLNamespaceAttribute(this.xmlLang, XML_LANG));
-		aStreamWriter.writeSimpleXMLElement(this.localName, list, null);
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMElement#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
-	 */
-	public void writeRssOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-		if (aStreamWriter == null)
-			throw new NullPointerException("StreamWriter is null");
-		List<GOMAttribute> list = getXmlNamespaceAttributes();
-		/*
-		 * build this domain attr. even if scheme is null or empty
-		 */
-		list.add(GOMUtils.buildDefaultNamespaceAttribute(this.scheme, DOMAIN));
-
-		aStreamWriter.writeSimpleXMLElement(this.localName, list, this.term);
-
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMContentImpl.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMContentImpl.java
deleted file mode 100644
index 4263045..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMContentImpl.java
+++ /dev/null
@@ -1,216 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import java.net.URISyntaxException;
-import java.util.List;
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.AtomMediaType;
-import org.apache.lucene.gdata.gom.GOMAttribute;
-import org.apache.lucene.gdata.gom.GOMContent;
-import org.apache.lucene.gdata.gom.GOMNamespace;
-import org.apache.lucene.gdata.gom.core.utils.AtomParserUtils;
-import org.apache.lucene.gdata.gom.core.utils.GOMUtils;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class GOMContentImpl extends GOMTextContructImpl implements GOMContent {
-	private String src;
-
-	private String type;
-
-	private AtomMediaType mediaType;
-
-	/**
-	 * 
-	 */
-	public GOMContentImpl() {
-		this.localName = GOMContent.LOCALNAME;
-		this.qname = new QName(GOMNamespace.ATOM_NS_URI, this.localName);
-		this.rssLocalName = GOMContent.LOCAL_NAME_RSS;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMContent#getSrc()
-	 */
-	public String getSrc() {
-		return this.src;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMContent#setSrc(java.lang.String)
-	 */
-	public void setSrc(String aSrc) {
-		this.src = aSrc;
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.GOMTextContructImpl#processAttribute(javax.xml.namespace.QName,
-	 *      java.lang.String)
-	 */
-	@Override
-	public void processAttribute(QName aQName, String aValue) {
-		if (aQName == null)
-			throw new GDataParseException("QName must not be null");
-		if (aValue == null)
-			throw new GDataParseException("Value must not be null");
-		if ("src".equals(aQName.getLocalPart())) {
-			if (this.src != null)
-				throw new GDataParseException(String.format(
-						DUPLICATE_ATTRIBUTE, "src"));
-			this.src = aValue;
-			return;
-		}
-		if ("type".equals(aQName.getLocalPart())) {
-			if (this.contentType != null || this.mediaType != null)
-				throw new GDataParseException(String.format(
-						DUPLICATE_ATTRIBUTE, "type"));
-			if (AtomParserUtils.isAtomMediaType(aValue)) {
-				this.type = aValue;
-				this.mediaType = AtomParserUtils.getAtomMediaType(aValue);
-				return;
-			}
-
-		}
-		super.processAttribute(aQName, aValue);
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.GOMTextContructImpl#processElementValue(java.lang.String)
-	 */
-	@Override
-	public void processElementValue(String aValue) {
-		if (this.src != null)
-			throw new GDataParseException(String.format(
-					AtomParser.UNEXPECTED_ELEMENT_VALUE, this.localName
-							+ " with attribute src set "));
-		super.processElementValue(aValue);
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.GOMTextContructImpl#processEndElement()
-	 */
-	@Override
-	public void processEndElement() {
-		if (this.src != null)
-			try {
-				AtomParserUtils.getAbsolutAtomURI(this.xmlBase, this.src);
-			} catch (URISyntaxException e) {
-				throw new GDataParseException(String.format(INVALID_ATTRIBUTE,
-						"src", "absolute uri"), e);
-			}
-
-		if (this.mediaType == null)
-			super.processEndElement();
-		else if (this.blobParser != null) {
-			this.textValue = this.blobParser.toString();
-			this.blobParser.close();
-			this.blobParser = null;
-		}
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.GOMTextContructImpl#getChildParser(javax.xml.namespace.QName)
-	 */
-	@Override
-	public AtomParser getChildParser(QName aName) {
-		if (aName == null)
-			throw new GDataParseException("QName must not be null");
-		if (this.mediaType == AtomMediaType.XML) {
-			if (this.blobParser != null)
-				throw new GDataParseException(String.format(
-						DUPLICATE_ELEMENT, aName.getLocalPart()));
-			this.blobParser = new XMLBlobContentParser();
-			return this.blobParser.getChildParser(aName);
-		}
-		return super.getChildParser(aName);
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMElement#writeAtomOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
-	 */
-	public void writeAtomOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-
-		if (this.mediaType != null) {
-			List<GOMAttribute> xmlNamespaceAttributes = getXmlNamespaceAttributes();
-			xmlNamespaceAttributes.add(GOMUtils.buildDefaultNamespaceAttribute(
-					this.type, "type"));
-			aStreamWriter.writeStartElement(this.localName,
-					xmlNamespaceAttributes);
-			if (this.src == null)
-				aStreamWriter.writeContentUnescaped(this.textValue);
-			else
-				aStreamWriter.writeAttribute(GOMUtils
-						.buildDefaultNamespaceAttribute(this.src, "src"));
-			aStreamWriter.writeEndElement();
-
-		} else {
-			super.writeAtomOutput(aStreamWriter);
-		}
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.GOMTextContructImpl#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
-	 */
-	@Override
-	public void writeRssOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-		if (this.mediaType != null) {
-			// if content is atomOutOfLineContent (has not textValue) ->
-			// generate a <link> element.
-			if (src != null) {
-				aStreamWriter.writeSimpleXMLElement("link", null, this.src);
-			} else if (this.mediaType == AtomMediaType.TEXT) {
-				aStreamWriter.writeSimpleXMLElement("description", null,
-						this.textValue);
-			} else {
-				// RSS doesn't support non-text content --> write atom type
-				this.writeAtomOutput(aStreamWriter);
-			}
-		} else {
-			super.writeRssOutput(aStreamWriter);
-		}
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMContent#setAtomMediaType(org.apache.lucene.gdata.gom.AtomMediaType)
-	 */
-	public void setAtomMediaType(AtomMediaType aMediaType) {
-
-		this.mediaType = aMediaType;
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMContent#getAtomMediaType()
-	 */
-	public AtomMediaType getAtomMediaType() {
-		return this.mediaType;
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMContributorImpl.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMContributorImpl.java
deleted file mode 100644
index 26c2d32..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMContributorImpl.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.GOMAuthor;
-import org.apache.lucene.gdata.gom.GOMContributor;
-import org.apache.lucene.gdata.gom.GOMNamespace;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class GOMContributorImpl extends GOMPersonImpl implements GOMContributor {
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.GOMPersonImpl#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMOutputWriter)
-	 */
-	@Override
-	public void writeRssOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-		writeRssOutput(aStreamWriter, GOMAuthor.LOCALNAME);
-	}
-
-	/**
-	 * 
-	 */
-	public GOMContributorImpl() {
-		this.localName = GOMContributor.LOCALNAME;
-		this.qname = new QName(GOMNamespace.ATOM_NS_URI, this.localName);
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMDateConstructImpl.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMDateConstructImpl.java
deleted file mode 100644
index 0a124ea..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMDateConstructImpl.java
+++ /dev/null
@@ -1,100 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import java.util.Date;
-
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.GOMDateConstruct;
-import org.apache.lucene.gdata.gom.core.utils.GOMUtils;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-/**
- * A Date construct is an element whose content MUST conform to the "date-time"
- * production in [RFC3339]. In addition, an uppercase "T" character MUST be used
- * to separate date and time, and an uppercase "Z" character MUST be present in
- * the absence of a numeric time zone offset.
- * 
- * @author Simon Willnauer
- */
-public abstract class GOMDateConstructImpl extends AbstractGOMElement implements
-		GOMDateConstruct {
-	protected long date;
-
-	/*
-	 * save the rfcString to skip the building while rendering the element
-	 */
-	protected String rfc3339String;
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMDateConstruct#setDate(java.util.Date)
-	 */
-	public void setDate(Date aDate) {
-		if (aDate == null)
-			return;
-		this.date = aDate.getTime();
-		this.rfc3339String = GOMUtils.buildRfc3339DateFormat(this.date);
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMDateConstruct#getDate()
-	 */
-	public Date getDate() {
-		return new Date(this.date);
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#processElementValue(java.lang.String)
-	 */
-	@Override
-	public void processElementValue(String aValue) {
-		if (aValue == null)
-			throw new IllegalArgumentException("element value must not be null");
-		this.date = GOMUtils.parseRfc3339DateFormat(aValue);
-		this.rfc3339String = aValue;
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#processEndElement()
-	 */
-	@Override
-	public void processEndElement() {
-		if (this.rfc3339String == null)
-			throw new GDataParseException(String.format(
-					MISSING_ELEMENT_VALUE, this.localName,
-					"RFC3339 Date Time"));
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMElement#writeAtomOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
-	 */
-	public void writeAtomOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-		if (this.rfc3339String == null)
-			this.rfc3339String = GOMUtils
-					.buildRfc3339DateFormat(this.date == 0 ? System
-							.currentTimeMillis() : this.date);
-		aStreamWriter.writeSimpleXMLElement(this.qname,
-				getXmlNamespaceAttributes(), this.rfc3339String);
-
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMDocumentImpl.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMDocumentImpl.java
deleted file mode 100644
index ba0b8bd..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMDocumentImpl.java
+++ /dev/null
@@ -1,135 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.GOMDocument;
-import org.apache.lucene.gdata.gom.GOMElement;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-/**
- * @author Simon Willnauer
- * @param <T>
- */
-public class GOMDocumentImpl<T extends GOMElement> implements GOMDocument<T> {
-
-	private static final String DEFAULT_ENCODING = "UTF-8";
-
-	private static final String DEFAULT_VERSION = "1.0";
-
-	private T root;
-
-	private String version;
-
-	private String charEncoding;
-
-	/**
-	 * 
-	 */
-	public GOMDocumentImpl() {
-		super();
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMDocument#setRootElement(org.apache.lucene.gdata.gom.GOMElement)
-	 */
-	public void setRootElement(T aRootElement) {
-		this.root = aRootElement;
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMDocument#getRootElement()
-	 */
-	public T getRootElement() {
-		return this.root;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMDocument#setVersion(java.lang.String)
-	 */
-	public void setVersion(String aVersion) {
-		this.version = aVersion;
-
-	}
-
-	/**
-	 * @return the version
-	 * @uml.property name="version"
-	 */
-	public String getVersion() {
-		return this.version;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMDocument#getCharacterEncoding()
-	 */
-	public String getCharacterEncoding() {
-		return this.charEncoding;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMDocument#setCharacterEncoding(java.lang.String)
-	 */
-	public void setCharacterEncoding(String aEncoding) {
-		this.charEncoding = aEncoding;
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMDocument#writeAtomOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
-	 */
-	public void writeAtomOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-		try {
-			aStreamWriter.writeStartDocument(
-					this.charEncoding == null ? DEFAULT_ENCODING
-							: this.charEncoding,
-					this.version == null ? DEFAULT_VERSION : this.version);
-			if (this.root != null)
-				this.root.writeAtomOutput(aStreamWriter);
-			aStreamWriter.writeEndDocument();
-			aStreamWriter.flush();
-		} finally {
-			aStreamWriter.close();
-		}
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMDocument#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
-	 */
-	public void writeRssOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-		try {
-			aStreamWriter.writeStartDocument(
-					this.charEncoding == null ? DEFAULT_ENCODING
-							: this.charEncoding,
-					this.version == null ? DEFAULT_VERSION : this.version);
-			if (this.root != null) {
-				this.root.writeRssOutput(aStreamWriter);
-			}
-			aStreamWriter.writeEndDocument();
-			aStreamWriter.flush();
-		} finally {
-			aStreamWriter.close();
-		}
-
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMEntryImpl.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMEntryImpl.java
deleted file mode 100644
index 3c3e002..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMEntryImpl.java
+++ /dev/null
@@ -1,668 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import java.util.LinkedList;
-import java.util.List;
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.AtomMediaType;
-import org.apache.lucene.gdata.gom.GOMAuthor;
-import org.apache.lucene.gdata.gom.GOMCategory;
-import org.apache.lucene.gdata.gom.GOMContent;
-import org.apache.lucene.gdata.gom.GOMContributor;
-import org.apache.lucene.gdata.gom.GOMEntry;
-import org.apache.lucene.gdata.gom.GOMExtension;
-import org.apache.lucene.gdata.gom.GOMId;
-import org.apache.lucene.gdata.gom.GOMLink;
-import org.apache.lucene.gdata.gom.GOMNamespace;
-import org.apache.lucene.gdata.gom.GOMPublished;
-import org.apache.lucene.gdata.gom.GOMRights;
-import org.apache.lucene.gdata.gom.GOMSource;
-import org.apache.lucene.gdata.gom.GOMSummary;
-import org.apache.lucene.gdata.gom.GOMTitle;
-import org.apache.lucene.gdata.gom.GOMUpdated;
-import org.apache.lucene.gdata.gom.core.extension.GOMExtensionFactory;
-import org.apache.lucene.gdata.gom.core.utils.AtomParserUtils;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-/**
- * 
- * The default implementation of {@link org.apache.lucene.gdata.gom.GOMEntry}
- * 
- * <pre>
- *         atomEntry =
- *         element atom:entry {
- *         atomCommonAttributes,
- *         (	atomAuthor*
- *         	&amp; atomCategory*
- *         	&amp; atomContent?
- *         	&amp; atomContributor*
- *         	&amp; atomId
- *         	&amp; atomLink*
- *         	&amp; atomPublished?
- *       	 	&amp; atomRights?
- *         	&amp; atomSource?
- *         	&amp; atomSummary?
- *         	&amp; atomTitle
- *         	&amp; atomUpdated
- *         	&amp; extensionElement*)
- *         }
- * </pre>
- * 
- * @author Simon Willnauer
- * 
- */
-public class GOMEntryImpl extends AbstractGOMElement implements GOMEntry {
-
-	protected List<GOMNamespace> namespaces = new LinkedList<GOMNamespace>();
-
-	protected List<GOMExtension> extensions = new LinkedList<GOMExtension>();
-
-	private List<GOMAuthor> authors = new LinkedList<GOMAuthor>();
-
-	private List<GOMCategory> categories = new LinkedList<GOMCategory>();
-
-	private List<GOMContributor> contributors = new LinkedList<GOMContributor>();
-
-	private GOMId id;
-
-	private List<GOMLink> links = new LinkedList<GOMLink>();
-
-	private GOMPublished published;
-
-	private GOMRights rights;
-
-	private GOMSource source;
-
-	private GOMSummary summary;
-
-	private GOMTitle title;
-
-	private GOMUpdated updated;
-
-	private GOMExtensionFactory extensionFactory;
-
-	private GOMContent content;
-
-	private final GOMNamespace defaultNamespace = GOMNamespace.ATOM_NAMESPACE;
-
-	/**
-	 * 
-	 */
-	public GOMEntryImpl() {
-		super();
-		this.localName = GOMEntry.LOCALNAME;
-		this.qname = new QName(GOMNamespace.ATOM_NS_URI, this.localName);
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMEntry#addAuthor(org.apache.lucene.gdata.gom.GOMAuthor)
-	 */
-	public void addAuthor(GOMAuthor aAuthor) {
-		if (aAuthor != null)
-			this.authors.add(aAuthor);
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMEntry#addCategory(org.apache.lucene.gdata.gom.GOMCategory)
-	 */
-	public void addCategory(GOMCategory aCategory) {
-		if (aCategory != null)
-			this.categories.add(aCategory);
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMEntry#addContributor(org.apache.lucene.gdata.gom.GOMContributor)
-	 */
-	public void addContributor(GOMContributor aContributor) {
-		if (aContributor != null)
-			this.contributors.add(aContributor);
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMEntry#addLink(org.apache.lucene.gdata.gom.GOMLink)
-	 */
-	public void addLink(GOMLink aLink) {
-		if (aLink != null)
-			this.links.add(aLink);
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMEntry#getAuthors()
-	 */
-	public List<GOMAuthor> getAuthors() {
-		return this.authors;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMEntry#getCategories()
-	 */
-	public List<GOMCategory> getCategories() {
-		return this.categories;
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMEntry#getContributor()
-	 */
-	public List<GOMContributor> getContributor() {
-		return this.contributors;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMEntry#getId()
-	 */
-	public GOMId getId() {
-		return this.id;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMEntry#getLinks()
-	 */
-	public List<GOMLink> getLinks() {
-		return this.links;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMEntry#getPublished()
-	 */
-	public GOMPublished getPublished() {
-		return this.published;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMEntry#getRights()
-	 */
-	public GOMRights getRights() {
-		return this.rights;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMEntry#getSource()
-	 */
-	public GOMSource getSource() {
-		return this.source;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMEntry#getSummary()
-	 */
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMEntry#getSummary()
-	 */
-	public GOMSummary getSummary() {
-		return this.summary;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMEntry#getTitle()
-	 */
-	public GOMTitle getTitle() {
-		return this.title;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMEntry#getUpdated()
-	 */
-	public GOMUpdated getUpdated() {
-		return this.updated;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMEntry#setId(org.apache.lucene.gdata.gom.GOMId)
-	 */
-	public void setId(GOMId aId) {
-		this.id = aId;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMEntry#setPublished(org.apache.lucene.gdata.gom.GOMPublished)
-	 */
-	public void setPublished(GOMPublished aPublished) {
-		this.published = aPublished;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMEntry#setRights(org.apache.lucene.gdata.gom.GOMRights)
-	 */
-	public void setRights(GOMRights aRights) {
-		this.rights = aRights;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMEntry#setSource(org.apache.lucene.gdata.gom.GOMSource)
-	 */
-	public void setSource(GOMSource aSource) {
-		this.source = aSource;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMEntry#setSummary(org.apache.lucene.gdata.gom.GOMSummary)
-	 */
-	public void setSummary(GOMSummary aSummary) {
-		this.summary = aSummary;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMEntry#setTitle(org.apache.lucene.gdata.gom.GOMTitle)
-	 */
-	public void setTitle(GOMTitle aTitle) {
-		this.title = aTitle;
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMEntry#setUpdated(org.apache.lucene.gdata.gom.GOMUpdated)
-	 */
-	public void setUpdated(GOMUpdated aUpdated) {
-		this.updated = aUpdated;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMEntry#addNamespace(org.apache.lucene.gdata.gom.GOMNamespace)
-	 */
-	public void addNamespace(GOMNamespace aNamespace) {
-		if (aNamespace == null)
-			return;
-		// namespace overrides hash / equals
-		if (this.namespaces.contains(aNamespace))
-			return;
-		if ("".equals(aNamespace.getNamespacePrefix())
-				|| aNamespace.getNamespaceUri()
-						.equals(GOMNamespace.ATOM_NS_URI))
-			return;
-		else
-			this.namespaces.add(aNamespace);
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMEntry#getNamespaces()
-	 */
-	public List<GOMNamespace> getNamespaces() {
-		return this.namespaces;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMEntry#getDefaultNamespace()
-	 */
-	public GOMNamespace getDefaultNamespace() {
-
-		return this.defaultNamespace;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMElement#writeAtomOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
-	 */
-	public void writeAtomOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-		aStreamWriter
-				.writeStartElement(this.qname, getXmlNamespaceAttributes());
-		if (this.defaultNamespace != null)
-			aStreamWriter.writeDefaultNamespace(this.defaultNamespace);
-		for (GOMNamespace namespace : this.namespaces) {
-			aStreamWriter.writeNamespace(namespace);
-		}
-		if (this.id != null)
-			this.id.writeAtomOutput(aStreamWriter);
-		if (this.published != null)
-			this.published.writeAtomOutput(aStreamWriter);
-		if (this.updated != null)
-			this.updated.writeAtomOutput(aStreamWriter);
-		for (GOMCategory category : this.categories) {
-			category.writeAtomOutput(aStreamWriter);
-		}
-		if (this.title != null)
-			this.title.writeAtomOutput(aStreamWriter);
-		if (this.summary != null)
-			this.summary.writeAtomOutput(aStreamWriter);
-		if (this.content != null)
-			this.content.writeAtomOutput(aStreamWriter);
-		for (GOMLink link : this.links) {
-			link.writeAtomOutput(aStreamWriter);
-		}
-		for (GOMAuthor autor : this.authors) {
-			autor.writeAtomOutput(aStreamWriter);
-		}
-		for (GOMContributor contributor : this.contributors) {
-			contributor.writeAtomOutput(aStreamWriter);
-		}
-		if (this.rights != null) {
-			this.rights.writeAtomOutput(aStreamWriter);
-		}
-		if (this.source != null) {
-			this.source.writeAtomOutput(aStreamWriter);
-		}
-
-		for (GOMExtension extension : this.extensions) {
-			extension.writeAtomOutput(aStreamWriter);
-		}
-		aStreamWriter.writeEndElement();
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMElement#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
-	 */
-	public void writeRssOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-		aStreamWriter.writeStartElement(GOMEntry.LOCALNAME_RSS,
-				getXmlNamespaceAttributes());
-		if (this.defaultNamespace != null)
-			aStreamWriter.writeNamespace(this.defaultNamespace);
-		for (GOMNamespace namespace : this.namespaces) {
-			aStreamWriter.writeNamespace(namespace);
-		}
-		if (this.id != null)
-			this.id.writeRssOutput(aStreamWriter, GOMId.LOCALNAME_RSS);
-		String xmlLang = null;
-
-		if (this.content != null) {
-			xmlLang = this.content.getXmlLang();
-		}
-		if (xmlLang == null && this.summary != null) {
-			xmlLang = this.summary.getXmlLang();
-		}
-
-		if (xmlLang == null && this.title != null) {
-			xmlLang = this.title.getXmlLang();
-		}
-
-		if (xmlLang != null) {
-			aStreamWriter.writeSimpleXMLElement("language", xmlLang, null);
-		}
-		if (this.published != null) {
-			this.published.writeRssOutput(aStreamWriter);
-		}
-		if (this.updated != null)
-			this.updated.writeRssOutput(aStreamWriter);
-		for (GOMCategory category : this.categories) {
-			category.writeRssOutput(aStreamWriter);
-		}
-		if (this.title != null)
-			this.title.writeRssOutput(aStreamWriter);
-		if (this.summary != null)
-			this.summary.writeRssOutput(aStreamWriter);
-		if (this.content != null)
-			this.content.writeRssOutput(aStreamWriter);
-		for (GOMLink link : this.links) {
-			link.writeRssOutput(aStreamWriter);
-		}
-		for (GOMAuthor author : this.authors) {
-			author.writeRssOutput(aStreamWriter);
-		}
-
-		for (GOMContributor contributors : this.contributors) {
-			contributors.writeRssOutput(aStreamWriter);
-		}
-
-		for (GOMExtension extension : this.extensions) {
-			extension.writeRssOutput(aStreamWriter);
-		}
-		aStreamWriter.writeEndElement();
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#getChildParser(javax.xml.namespace.QName)
-	 */
-	@Override
-	public AtomParser getChildParser(QName aName) {
-		if (aName.getNamespaceURI().equals(GOMNamespace.ATOM_NS_URI)) {
-			if (aName.getLocalPart().equals(GOMId.LOCALNAME)) {
-				// atom:feed elements MUST contain exactly one atom:id element.
-				if (this.id != null)
-					throw new GDataParseException(String.format(
-							AtomParser.DUPLICATE_ELEMENT, GOMId.LOCALNAME));
-				this.id = new GOMIdImpl();
-				return this.id;
-			}
-			if (aName.getLocalPart().equals(GOMTitle.LOCALNAME)) {
-				// atom:entry elements MUST contain exactly one atom:title
-				// element.
-				if (this.title != null)
-					throw new GDataParseException(String.format(
-							AtomParser.DUPLICATE_ELEMENT, GOMTitle.LOCALNAME));
-				this.title = new GOMTitleImpl();
-				return this.title;
-			}
-			if (aName.getLocalPart().equals(GOMAuthor.LOCALNAME)) {
-				GOMAuthor author = new GOMAuthorImpl();
-				this.authors.add(author);
-				return author;
-			}
-			if (aName.getLocalPart().equals(GOMCategory.LOCALNAME)) {
-				GOMCategory category = new GOMCategoryImpl();
-				this.categories.add(category);
-				return category;
-			}
-			if (aName.getLocalPart().equals(GOMContributor.LOCALNAME)) {
-				GOMContributorImpl impl = new GOMContributorImpl();
-				this.contributors.add(impl);
-				return impl;
-			}
-			if (aName.getLocalPart().equals(GOMLink.LOCALNAME)) {
-				GOMLinkImpl impl = new GOMLinkImpl();
-				this.links.add(impl);
-				return impl;
-			}
-
-			if (aName.getLocalPart().equals(GOMUpdated.LOCALNAME)) {
-				if (this.updated != null)
-					throw new GDataParseException(String.format(
-							AtomParser.DUPLICATE_ELEMENT,
-							GOMUpdated.LOCALNAME));
-				GOMUpdated updatedImpl = new GOMUpdatedImpl();
-				this.updated = updatedImpl;
-				return this.updated;
-
-			}
-			if (aName.getLocalPart().equals(GOMRights.LOCALNAME)) {
-				if (this.rights != null)
-					throw new GDataParseException(String
-							.format(AtomParser.DUPLICATE_ELEMENT,
-									GOMRights.LOCALNAME));
-
-				this.rights = new GOMRightsImpl();
-				return this.rights;
-
-			}
-			if (aName.getLocalPart().equals(GOMSource.LOCALNAME)) {
-				if (this.source != null)
-					throw new GDataParseException(String
-							.format(AtomParser.DUPLICATE_ELEMENT,
-									GOMSource.LOCALNAME));
-				this.source = new GOMSourceImpl();
-
-				return this.source;
-
-			}
-			if (aName.getLocalPart().equals(GOMSummary.LOCALNAME)) {
-				if (this.summary != null)
-					throw new GDataParseException(String.format(
-							AtomParser.DUPLICATE_ELEMENT,
-							GOMSummary.LOCALNAME));
-
-				this.summary = new GOMSummaryImpl();
-				return this.summary;
-
-			}
-			if (aName.getLocalPart().equals(GOMPublished.LOCALNAME)) {
-				if (this.published != null)
-					throw new GDataParseException(String.format(
-							AtomParser.DUPLICATE_ELEMENT,
-							GOMPublished.LOCALNAME));
-
-				this.published = new GOMPublishedImpl();
-				return this.published;
-
-			}
-			if (aName.getLocalPart().endsWith(GOMContent.LOCALNAME)) {
-				if (this.content != null)
-					throw new GDataParseException(String.format(
-							AtomParser.DUPLICATE_ELEMENT,
-							GOMContent.LOCALNAME));
-				this.content = new GOMContentImpl();
-				return this.content;
-
-			}
-
-		}
-		if (this.extensionFactory != null) {
-			GOMExtension extension = this.extensionFactory
-					.canHandleExtensionElement(aName);
-			if (extension != null) {
-				this.extensions.add(extension);
-				return extension;
-			}
-		}
-		return super.getChildParser(aName);
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#processEndElement()
-	 */
-	@Override
-	public void processEndElement() {
-
-		/*
-		 * atom:entry elements MUST contain an atom:summary element in either of
-		 * the following cases:
-		 * 
-		 * the atom:entry contains an atom:content that has a "src" attribute
-		 * (and is thus empty). the atom:entry contains content that is encoded
-		 * in Base64; i.e., the "type" attribute of atom:content is a MIME media
-		 * type [MIMEREG], but is not an XML media type [RFC3023], does not
-		 * begin with "text/", and does not end with "/xml" or "+xml".
-		 * 
-		 * 
-		 */
-		if (this.summary == null && this.content != null) {
-
-			if (this.content.getAtomMediaType() == AtomMediaType.BINARY
-					|| "".equals(this.content.getSrc())) {
-				throw new GDataParseException(String.format(
-						MISSING_ELEMENT_CHILD, this.localName,
-						GOMSummary.LOCALNAME));
-			}
-		}
-
-		/*
-		 * atom:entry elements MUST contain exactly one atom:id element.
-		 */
-		if (this.id == null)
-			throw new GDataParseException(String.format(
-					MISSING_ELEMENT_CHILD, this.localName, GOMId.LOCALNAME));
-		/*
-		 * atom:entry elements MUST contain exactly one atom:title element.
-		 */
-		if (this.title == null)
-			throw new GDataParseException(String
-					.format(MISSING_ELEMENT_CHILD, this.localName,
-							GOMTitle.LOCALNAME));
-		/*
-		 * atom:entry elements MUST contain exactly one atom:updated element.
-		 */
-		if (this.updated == null)
-			throw new GDataParseException(String.format(
-					MISSING_ELEMENT_CHILD, this.localName,
-					GOMUpdated.LOCALNAME));
-
-		/*
-		 * atom:entry elements MUST NOT contain more than one atom:link element
-		 * with a rel attribute value of "alternate" that has the same
-		 * combination of type and hreflang attribute values.
-		 */
-		List<GOMLink> alternateLinks = new LinkedList<GOMLink>();
-		for (GOMLink link : this.links) {
-			/*
-			 * atom:link elements MAY have a "rel" attribute that indicates the
-			 * link relation type. If the "rel" attribute is not present, the
-			 * link element MUST be interpreted as if the link relation type is
-			 * "alternate".
-			 */
-			if (link.getRel() == null
-					|| link.getRel().equalsIgnoreCase("alternate"))
-				alternateLinks.add(link);
-		}
-
-		/*
-		 * atom:entry elements MUST NOT contain more than one atom:link element
-		 * with a rel attribute value of "alternate" that has the same
-		 * combination of type and hreflang attribute values.
-		 */
-		if (alternateLinks.size() > 1) {
-			for (GOMLink link : alternateLinks) {
-				for (GOMLink link2 : alternateLinks) {
-					if (AtomParserUtils.compareAlternateLinks(link, link2))
-						throw new GDataParseException(
-								String
-										.format(DUPLICATE_ELEMENT,
-												"link with rel=\"alternate\" and same href and type attributes"));
-
-				}
-			}
-		} else if (this.content == null && alternateLinks.size() == 0) {
-			throw new GDataParseException(
-					"Element Entry must contain a element link with attribute alternate if no content element is set");
-		}
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMExtensible#getExtensions()
-	 */
-	public List<GOMExtension> getExtensions() {
-		return this.extensions;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMExtensible#setExtensionFactory(org.apache.lucene.gdata.gom.core.extension.GOMExtensionFactory)
-	 */
-	public void setExtensionFactory(GOMExtensionFactory aFactory) {
-		if (extensionFactory != null) {
-			List<GOMNamespace> namespaces2 = extensionFactory.getNamespaces();
-			if (namespaces2 != null)
-				for (GOMNamespace namespace : namespaces2) {
-					this.addNamespace(namespace);
-				}
-
-		}
-		this.extensionFactory = aFactory;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMEntry#getContent()
-	 */
-	public GOMContent getContent() {
-		return this.content;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMEntry#setContent(org.apache.lucene.gdata.gom.GOMContent)
-	 */
-	public void setContent(GOMContent aContent) {
-		this.content = aContent;
-
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMFactory.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMFactory.java
deleted file mode 100644
index c58999b..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMFactory.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import org.apache.lucene.gdata.gom.GOMEntry;
-import org.apache.lucene.gdata.gom.GOMFeed;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class GOMFactory {
-	/**
-	 * 
-	 */
-	private GOMFactory() {
-		super();
-	}
-
-	public static GOMFactory createInstance() {
-		return new GOMFactory();
-	}
-
-	public GOMFeed createFeed() {
-		return new GOMFeedImpl();
-	}
-
-	public GOMEntry createEntry() {
-		return new GOMEntryImpl();
-
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMFeedImpl.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMFeedImpl.java
deleted file mode 100644
index ed3c673..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMFeedImpl.java
+++ /dev/null
@@ -1,381 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import java.util.LinkedList;
-import java.util.List;
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.GOMAttribute;
-import org.apache.lucene.gdata.gom.GOMAuthor;
-import org.apache.lucene.gdata.gom.GOMCategory;
-import org.apache.lucene.gdata.gom.GOMEntry;
-import org.apache.lucene.gdata.gom.GOMExtension;
-import org.apache.lucene.gdata.gom.GOMFeed;
-import org.apache.lucene.gdata.gom.GOMLink;
-import org.apache.lucene.gdata.gom.GOMNamespace;
-import org.apache.lucene.gdata.gom.core.extension.GOMExtensionFactory;
-import org.apache.lucene.gdata.gom.core.utils.GOMUtils;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-/**
- * atom:feed { atomCommonAttributes, (atomAuthor* & atomCategory* &
- * atomContributor* & atomGenerator? & atomIcon? & atomId & atomLink* &
- * atomLogo? & atomRights? & atomSubtitle? & atomTitle & atomUpdated &
- * extensionElement*), atomEntry* }
- * 
- * @author Simon Willnauer
- */
-class GOMFeedImpl extends GOMSourceImpl implements GOMFeed {
-	// TODO add totalResults OS namespace
-
-	static final int DEFAULT_START_INDEX = 1;
-
-	static final int DEFAULT_ITEMS_PER_PAGE = 25;
-
-	private static final GOMAttribute RSS_VERSION_ATTRIBUTE = new GOMAttributeImpl(
-			"version", "2.0");
-
-	protected List<GOMEntry> entries = new LinkedList<GOMEntry>();
-
-	protected List<GOMExtension> extensions = new LinkedList<GOMExtension>();
-
-	protected List<GOMNamespace> namespaces = new LinkedList<GOMNamespace>();
-
-	private SimpleGOMElementImpl startIndexElement;
-
-	private SimpleGOMElementImpl itemsPerPageElement;
-
-	private GOMExtensionFactory extensionFactory;
-
-	private GOMNamespace defaultNamespace = GOMNamespace.ATOM_NAMESPACE;
-
-	GOMFeedImpl() {
-		this.localName = GOMFeed.LOCALNAME;
-		this.qname = new QName(GOMNamespace.ATOM_NS_URI, this.localName);
-		startIndexElement = new SimpleGOMElementImpl(
-				SimpleGOMElementImpl.ELEMENT_OS_START_INDEX,
-				GOMNamespace.OPENSEARCH_NAMESPACE);
-		itemsPerPageElement = new SimpleGOMElementImpl(
-				SimpleGOMElementImpl.ELEMENT_OS_ITEMS_PER_PAGE,
-				GOMNamespace.OPENSEARCH_NAMESPACE);
-		itemsPerPageElement.setTextValue(Integer
-				.toString(DEFAULT_ITEMS_PER_PAGE));
-		startIndexElement.setTextValue(Integer.toString(DEFAULT_START_INDEX));
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMSource#addEntry(org.apache.lucene.gdata.gom.GOMEntry)
-	 */
-	public void addEntry(GOMEntry aEntry) {
-		if (aEntry != null)
-			this.entries.add(aEntry);
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMFeed#getEntries()
-	 */
-	public List<GOMEntry> getEntries() {
-		return this.entries;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMFeed#getItemsPerPage()
-	 */
-	public int getItemsPerPage() {
-		return Integer.parseInt(this.itemsPerPageElement.getTextValue());
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMFeed#getStartIndex()
-	 */
-	public int getStartIndex() {
-		return Integer.parseInt(this.startIndexElement.getTextValue());
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMFeed#setStartIndex(int)
-	 */
-	public void setStartIndex(int aIndex) {
-		if (aIndex < 1)
-			return;
-		this.startIndexElement.textValue = Integer.toString(aIndex);
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMFeed#setItemsPerPage(int)
-	 */
-	public void setItemsPerPage(int aInt) {
-		if (aInt < 0)
-			return;
-		this.itemsPerPageElement.textValue = Integer.toString(aInt);
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMFeed#addNamespace(org.apache.lucene.gdata.gom.GOMNamespace)
-	 */
-	public void addNamespace(GOMNamespace aNamespace) {
-		if (aNamespace == null)
-			return;
-		// namespace overrides hash / equals
-		if (this.namespaces.contains(aNamespace))
-			return;
-		if ("".equals(aNamespace.getNamespacePrefix())
-				|| aNamespace.getNamespaceUri()
-						.equals(GOMNamespace.ATOM_NS_URI))
-			return;
-		else
-			this.namespaces.add(aNamespace);
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMFeed#getDefaultNamespace()
-	 */
-	public GOMNamespace getDefaultNamespace() {
-		return this.defaultNamespace;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMFeed#getNamespaces()
-	 * 
-	 */
-	public List<GOMNamespace> getNamespaces() {
-		return this.namespaces;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.AtomParser#getChildParser(javax.xml.namespace.QName)
-	 */
-	public AtomParser getChildParser(QName aName) {
-		if (aName.getNamespaceURI().equals(GOMNamespace.OPENSEARCH_NS_URI)) {
-			if (aName.getLocalPart().equals(
-					SimpleGOMElementImpl.ELEMENT_OS_ITEMS_PER_PAGE)) {
-
-				this.itemsPerPageElement = new SimpleGOMElementImpl(
-						SimpleGOMElementImpl.ELEMENT_OS_ITEMS_PER_PAGE,
-						GOMNamespace.OPENSEARCH_NAMESPACE);
-				this.itemsPerPageElement
-						.setValidator(new PositiveIntegerValidator(
-								SimpleGOMElementImpl.ELEMENT_OS_ITEMS_PER_PAGE));
-				return this.itemsPerPageElement;
-			}
-			if (aName.getLocalPart().equals(
-					SimpleGOMElementImpl.ELEMENT_OS_START_INDEX)) {
-				this.startIndexElement = new SimpleGOMElementImpl(
-						SimpleGOMElementImpl.ELEMENT_OS_START_INDEX,
-						GOMNamespace.OPENSEARCH_NAMESPACE);
-				this.startIndexElement
-						.setValidator(new PositiveIntegerValidator(
-								SimpleGOMElementImpl.ELEMENT_OS_START_INDEX));
-				return this.startIndexElement;
-			}
-
-		}
-		if (aName.getNamespaceURI().equals(GOMNamespace.ATOM_NS_URI)
-				&& aName.getLocalPart().equals(GOMEntry.LOCALNAME)) {
-			GOMEntry entry = new GOMEntryImpl();
-			this.entries.add(entry);
-			return entry;
-
-		}
-		if (this.extensionFactory != null) {
-			GOMExtension extension = this.extensionFactory
-					.canHandleExtensionElement(aName);
-			if (extension != null) {
-				this.extensions.add(extension);
-				return extension;
-			}
-		}
-		return super.getChildParser(aName);
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMElement#writeAtomOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
-	 */
-	public void writeAtomOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-		aStreamWriter.writeStartElement(this.localName,
-				this.extensionAttributes);
-		if (this.defaultNamespace != null)
-			aStreamWriter.writeDefaultNamespace(this.defaultNamespace);
-		for (GOMNamespace namespace : this.namespaces) {
-			aStreamWriter.writeNamespace(namespace);
-		}
-		List<GOMAttribute> xmlNamespaceAttributes = getXmlNamespaceAttributes();
-		for (GOMAttribute attribute : xmlNamespaceAttributes) {
-			aStreamWriter.writeAttribute(attribute);
-		}
-		writeInnerAtomOutput(aStreamWriter);
-		if (this.itemsPerPageElement != null)
-			this.itemsPerPageElement.writeAtomOutput(aStreamWriter);
-		if (this.startIndexElement != null)
-			this.startIndexElement.writeAtomOutput(aStreamWriter);
-		for (GOMExtension extension : this.extensions) {
-			extension.writeAtomOutput(aStreamWriter);
-		}
-		for (GOMEntry entry : this.entries) {
-			entry.writeAtomOutput(aStreamWriter);
-		}
-
-		aStreamWriter.writeEndElement();
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMElement#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
-	 */
-	public void writeRssOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-		aStreamWriter
-				.writeStartElement(LOCALNAME_RSS, this.extensionAttributes);
-		List<GOMAttribute> xmlNamespaceAttributes = getXmlNamespaceAttributes();
-		for (GOMAttribute attribute : xmlNamespaceAttributes) {
-			aStreamWriter.writeAttribute(attribute);
-		}
-		if (this.defaultNamespace != null)
-			aStreamWriter.writeNamespace(this.defaultNamespace);
-		for (GOMNamespace namespace : this.namespaces) {
-			aStreamWriter.writeNamespace(namespace);
-		}
-		aStreamWriter.writeAttribute(RSS_VERSION_ATTRIBUTE);
-
-		aStreamWriter.writeStartElement(RSS_CHANNEL_ELEMENT_NAME);
-
-		if (this.id != null)
-			this.id.writeRssOutput(aStreamWriter);
-		if (this.title != null)
-			this.title.writeRssOutput(aStreamWriter);
-		if (this.subtitle != null)
-			this.subtitle.writeRssOutput(aStreamWriter);
-		if (this.rights != null)
-			this.rights.writeRssOutput(aStreamWriter);
-		for (GOMAuthor authors : this.authors) {
-			authors.writeRssOutput(aStreamWriter, "managingEditor");
-		}
-		for (GOMCategory category : this.categories) {
-			category.writeRssOutput(aStreamWriter);
-		}
-		for (GOMLink link : this.links) {
-			link.writeRssOutput(aStreamWriter);
-		}
-		if (this.updated != null) {
-			// udated.getDate can not be null
-			aStreamWriter.writeSimpleXMLElement("lastBuildDate", GOMUtils
-					.buildRfc822Date(this.updated.getDate().getTime()), null);
-		}
-
-		if (this.logo != null || this.icon != null) {
-			aStreamWriter.writeStartElement("image");
-			if (this.logo != null)
-				this.logo.writeRssOutput(aStreamWriter);
-			else
-				this.icon.writeRssOutput(aStreamWriter);
-			aStreamWriter.writeEndElement();
-
-		}
-
-		if (this.generator != null)
-			this.generator.writeRssOutput(aStreamWriter);
-		if (this.itemsPerPageElement != null)
-			this.itemsPerPageElement.writeRssOutput(aStreamWriter);
-		if (this.startIndexElement != null)
-			this.startIndexElement.writeRssOutput(aStreamWriter);
-		for (GOMExtension extension : this.extensions) {
-			extension.writeRssOutput(aStreamWriter);
-		}
-		for (GOMExtension extension : this.extensions) {
-			extension.writeRssOutput(aStreamWriter);
-		}
-		for (GOMEntry entry : this.entries) {
-			entry.writeRssOutput(aStreamWriter);
-		}
-		// channel
-		aStreamWriter.writeEndElement();
-		// rss
-		aStreamWriter.writeEndElement();
-
-	}
-
-	static class PositiveIntegerValidator extends
-			SimpleGOMElementImpl.SimpleValidator {
-
-		protected PositiveIntegerValidator(String aLocalName) {
-			super(aLocalName);
-
-		}
-
-		/**
-		 * @see org.apache.lucene.gdata.gom.core.SimpleGOMElementImpl.SimpleValidator#validate(java.lang.String)
-		 */
-		@Override
-		protected void validate(String aTextValue) {
-			super.validate(aTextValue);
-			try {
-				int i = Integer.parseInt(aTextValue);
-				if (i < 0)
-					throw new GDataParseException(String.format(
-							AtomParser.INVALID_ELEMENT_VALUE, this.localName,
-							"positive integer value"));
-			} catch (NumberFormatException e) {
-				throw new GDataParseException(String.format(
-						AtomParser.INVALID_ELEMENT_VALUE, this.localName,
-						"positive integer value"));
-			}
-
-		}
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMFeed#getExtensions()
-	 */
-	public List<GOMExtension> getExtensions() {
-		return this.extensions;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMFeed#setExtensionFactory(org.apache.lucene.gdata.gom.core.extension.GOMExtensionFactory)
-	 */
-	public void setExtensionFactory(GOMExtensionFactory aFactory) {
-		if (extensionFactory != null) {
-			List<GOMNamespace> namespaces2 = extensionFactory.getNamespaces();
-			if (namespaces2 != null)
-				for (GOMNamespace namespace : namespaces2) {
-					this.addNamespace(namespace);
-				}
-
-		}
-
-		this.extensionFactory = aFactory;
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMFeed#addLink(org.apache.lucene.gdata.gom.GOMLink)
-	 */
-	public void addLink(GOMLink aLink) {
-		if (aLink == null)
-			return;
-		this.links.add(aLink);
-
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMGeneratorImpl.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMGeneratorImpl.java
deleted file mode 100644
index 690fb95..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMGeneratorImpl.java
+++ /dev/null
@@ -1,158 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import java.net.URISyntaxException;
-import java.util.List;
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.GOMAttribute;
-import org.apache.lucene.gdata.gom.GOMGenerator;
-import org.apache.lucene.gdata.gom.GOMNamespace;
-import org.apache.lucene.gdata.gom.core.utils.AtomParserUtils;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class GOMGeneratorImpl extends AbstractGOMElement implements
-		GOMGenerator {
-
-	private String generatorVersion;
-
-	private String uri;
-
-	/**
-	 * 
-	 */
-	public GOMGeneratorImpl() {
-		super();
-		this.localName = GOMGenerator.LOCALNAME;
-		this.qname = new QName(GOMNamespace.ATOM_NS_URI, this.localName);
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMGenerator#setUri(java.lang.String)
-	 */
-	public void setUri(String aUri) {
-		this.uri = aUri;
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMGenerator#setGeneratorVersion(java.lang.String)
-	 */
-	public void setGeneratorVersion(String aVersion) {
-		this.generatorVersion = aVersion;
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMGenerator#getGeneratorVersion()
-	 */
-	public String getGeneratorVersion() {
-		return this.generatorVersion;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMGenerator#getUri()
-	 */
-	public String getUri() {
-		return this.uri;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#processAttribute(javax.xml.namespace.QName,
-	 *      java.lang.String)
-	 */
-	@Override
-	public void processAttribute(QName aQName, String aValue) {
-		if (aQName == null)
-			throw new IllegalArgumentException("Qname must not be null");
-		if (aValue == null)
-			throw new IllegalArgumentException("Value must not be null");
-		if (aQName.getNamespaceURI().equals(GOMNamespace.ATOM_NS_URI)) {
-			if (aQName.getLocalPart().equals("uri")) {
-				if (this.uri != null)
-					throw new GDataParseException(String.format(
-							AtomParser.DUPLICATE_ATTRIBUTE, "uri"));
-				this.uri = aValue;
-			} else if (aQName.getLocalPart().equals("version")) {
-				if (this.generatorVersion != null)
-					throw new GDataParseException(String.format(
-							AtomParser.DUPLICATE_ATTRIBUTE, "version"));
-				this.generatorVersion = aValue;
-			}
-		}
-		super.processAttribute(aQName, aValue);
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#processElementValue(java.lang.String)
-	 */
-	@Override
-	public void processElementValue(String aValue) {
-		if (this.textValue != null)
-			throw new GDataParseException(String.format(
-					AtomParser.DUPLICATE_ELEMENT_VALUE, this.localName));
-		this.textValue = aValue;
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#processEndElement()
-	 */
-	@Override
-	public void processEndElement() {
-		if (this.uri != null)
-			try {
-				AtomParserUtils.getAbsolutAtomURI(this.xmlBase, this.uri);
-			} catch (URISyntaxException e) {
-				throw new GDataParseException(String.format(
-						AtomParser.INVALID_ELEMENT_VALUE, this.localName,
-						"absolute uri"));
-			}
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMElement#writeAtomOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
-	 */
-	public void writeAtomOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-		List<GOMAttribute> list = getXmlNamespaceAttributes();
-		if (this.uri != null)
-			list.add(new GOMAttributeImpl("uri", this.uri));
-		if (this.generatorVersion != null)
-			list.add(new GOMAttributeImpl("version", this.generatorVersion));
-
-		aStreamWriter.writeSimpleXMLElement(this.qname, list, this.textValue);
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMElement#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
-	 */
-	public void writeRssOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-		aStreamWriter.writeSimpleXMLElement(this.localName,
-				getXmlNamespaceAttributes(), this.textValue);
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMIconImpl.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMIconImpl.java
deleted file mode 100644
index c84c738..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMIconImpl.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.GOMIcon;
-import org.apache.lucene.gdata.gom.GOMNamespace;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class GOMIconImpl extends AtomUriElement implements GOMIcon {
-
-	/**
-	 * 
-	 */
-	public GOMIconImpl() {
-		this.localName = GOMIcon.LOCALNAME;
-		this.qname = new QName(GOMNamespace.ATOM_NS_URI, this.localName);
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.SimpleGOMElementImpl#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
-	 */
-	@Override
-	public void writeRssOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-		aStreamWriter.writeSimpleXMLElement("url", getXmlNamespaceAttributes(),
-				this.textValue);
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMIdImpl.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMIdImpl.java
deleted file mode 100644
index b8a582a..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMIdImpl.java
+++ /dev/null
@@ -1,103 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.GOMId;
-import org.apache.lucene.gdata.gom.GOMNamespace;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-/**
- * @author Simon Willnauer
- * 
- */
-class GOMIdImpl extends AbstractGOMElement implements GOMId {
-
-	protected static final QName ATOM_QNAME = new QName(
-			GOMNamespace.ATOM_NS_URI, LOCALNAME, GOMNamespace.ATOM_NS_PREFIX);
-
-	GOMIdImpl() {
-		this.localName = LOCALNAME;
-		this.qname = new QName(GOMNamespace.ATOM_NS_URI, this.localName);
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#getLocalName()
-	 */
-	@Override
-	public String getLocalName() {
-		return this.localName;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.AtomParser#processElementValue(java.lang.String)
-	 */
-	public void processElementValue(String aValue) {
-		this.textValue = aValue;
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.AtomParser#processEndElement()
-	 */
-	public void processEndElement() {
-		if (this.textValue == null)
-			throw new GDataParseException(
-					"Element id must have a unique id value -- is null");
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMElement#writeAtomOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
-	 */
-	public void writeAtomOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-		if (aStreamWriter == null)
-			throw new GDataParseException("GOMWriter must not be null");
-		aStreamWriter.writeSimpleXMLElement(LOCALNAME,
-				getXmlNamespaceAttributes(), this.textValue);
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMElement#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
-	 */
-	public void writeRssOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-		if (aStreamWriter == null)
-			throw new GDataParseException("GOMWriter must not be null");
-		aStreamWriter.writeSimpleXMLElement(ATOM_QNAME,
-				getXmlNamespaceAttributes(), this.textValue);
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMOutputWriter,
-	 *      java.lang.String)
-	 */
-	@Override
-	public void writeRssOutput(GOMOutputWriter aStreamWriter, String aRssName)
-			throws XMLStreamException {
-		if (aStreamWriter == null)
-			throw new GDataParseException("GOMWriter must not be null");
-		aStreamWriter.writeSimpleXMLElement(aRssName,
-				getXmlNamespaceAttributes(), this.textValue);
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMLinkImpl.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMLinkImpl.java
deleted file mode 100644
index 3ed47b3..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMLinkImpl.java
+++ /dev/null
@@ -1,270 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import java.net.URISyntaxException;
-import java.util.List;
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.GOMAttribute;
-import org.apache.lucene.gdata.gom.GOMLink;
-import org.apache.lucene.gdata.gom.GOMNamespace;
-import org.apache.lucene.gdata.gom.core.utils.AtomParserUtils;
-import org.apache.lucene.gdata.gom.core.utils.GOMUtils;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-/**
- * element atom:link { atomCommonAttributes, attribute href { atomUri },
- * attribute rel { atomNCName | atomUri }?, attribute type { atomMediaType }?,
- * attribute hreflang { atomLanguageTag }?, attribute title { text }?, attribute
- * length { text }?, undefinedContent }
- * 
- * @author Simon Willnauer
- * 
- */
-public class GOMLinkImpl extends AbstractGOMElement implements GOMLink {
-	private String href;
-
-	private String rel;
-
-	private String type;
-
-	private String hrefLang;
-
-	private String title;
-
-	private Integer length;
-
-	/**
-	 * 
-	 */
-	public GOMLinkImpl() {
-		super();
-		this.localName = LOCALNAME;
-		this.qname = new QName(this.localName);
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMLink#getHref()
-	 */
-	public String getHref() {
-		return this.href;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMLink#setHref(java.lang.String)
-	 */
-	public void setHref(String aHref) {
-		href = aHref;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMLink#getHrefLang()
-	 */
-	public String getHrefLang() {
-		return this.hrefLang;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMLink#setHrefLang(java.lang.String)
-	 */
-	public void setHrefLang(String aHrefLang) {
-		hrefLang = aHrefLang;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMLink#getLength()
-	 */
-	public Integer getLength() {
-		return this.length;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMLink#setLength(java.lang.String)
-	 */
-	public void setLength(Integer aLength) {
-		length = aLength;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMLink#getRel()
-	 */
-	public String getRel() {
-		return this.rel;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMLink#setRel(java.lang.String)
-	 */
-	public void setRel(String aRel) {
-		rel = aRel;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMLink#getTitle()
-	 */
-	public String getTitle() {
-		return this.title;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMLink#setTitle(java.lang.String)
-	 */
-	public void setTitle(String aTitle) {
-		title = aTitle;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMLink#getType()
-	 */
-	public String getType() {
-		return this.type;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMLink#setType(java.lang.String)
-	 */
-	public void setType(String aType) {
-		type = aType;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#processAttribute(javax.xml.namespace.QName,
-	 *      java.lang.String)
-	 */
-	@Override
-	public void processAttribute(QName aQName, String aValue) {
-		if (aQName == null)
-			throw new IllegalArgumentException("QName must not be null");
-
-		if (aQName.getNamespaceURI().equals(GOMNamespace.ATOM_NS_URI)
-				|| aQName.getNamespaceURI().equals("")) {
-			String localName = aQName.getLocalPart();
-
-			if (localName.equals("href")) {
-				if (this.href != null)
-					throw new GDataParseException(String.format(
-							DUPLICATE_ATTRIBUTE, "href"));
-				this.href = aValue;
-			} else if (localName.equals("type")) {
-				if (this.type != null)
-					throw new GDataParseException(String.format(
-							DUPLICATE_ATTRIBUTE, "type"));
-				this.type = aValue;
-			} else if (localName.equals("rel")) {
-				if (this.rel != null)
-					throw new GDataParseException(String.format(
-							DUPLICATE_ATTRIBUTE, "rel"));
-				this.rel = aValue;
-			} else if (localName.equals("title")) {
-				if (this.title != null)
-					throw new GDataParseException(String.format(
-							DUPLICATE_ATTRIBUTE, "title"));
-				this.title = aValue;
-
-			} else if (localName.equals("hreflang")) {
-				if (this.hrefLang != null)
-					throw new GDataParseException(String.format(
-							DUPLICATE_ATTRIBUTE, "hreflang"));
-				this.hrefLang = aValue;
-			} else if (localName.equals("length")) {
-				if (this.length != null)
-					throw new GDataParseException(String.format(
-							DUPLICATE_ATTRIBUTE, "length"));
-				try {
-					this.length = new Integer(Integer.parseInt(aValue));
-				} catch (NumberFormatException e) {
-					throw new GDataParseException(
-							"attribute lenght must be an integer");
-				}
-			}
-
-		}
-		super.processAttribute(aQName, aValue);
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#processEndElement()
-	 */
-	@Override
-	public void processEndElement() {
-		if (this.href == null)
-			throw new GDataParseException(String.format(
-					MISSING_ELEMENT_ATTRIBUTE, this.localName, "href"));
-		try {
-			AtomParserUtils.getAbsolutAtomURI(this.xmlBase, this.href);
-		} catch (URISyntaxException e) {
-			throw new GDataParseException(String.format(INVALID_ATTRIBUTE,
-					"href", "absolute uri"), e);
-		}
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMElement#writeAtomOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
-	 */
-	public void writeAtomOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-		List<GOMAttribute> attList = getXmlNamespaceAttributes();
-		attList.add(GOMUtils.buildDefaultNamespaceAttribute(
-				this.href == null ? "" : this.href, "href"));
-		if (this.rel != null)
-			attList.add(GOMUtils
-					.buildDefaultNamespaceAttribute(this.rel, "rel"));
-		if (this.title != null)
-			attList.add(GOMUtils.buildDefaultNamespaceAttribute(this.title,
-					"title"));
-		if (this.type != null)
-			attList.add(GOMUtils.buildDefaultNamespaceAttribute(this.type,
-					"type"));
-		if (this.hrefLang != null)
-			attList.add(GOMUtils.buildDefaultNamespaceAttribute(this.hrefLang,
-					"hreflang"));
-		if (this.length != null)
-			attList.add(GOMUtils.buildDefaultNamespaceAttribute(this.length
-					.toString(), "length"));
-
-		aStreamWriter.writeSimpleXMLElement(this.qname, attList, null);
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMElement#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
-	 */
-	public void writeRssOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-		List<GOMAttribute> xmlNamespaceAttributes = getXmlNamespaceAttributes();
-		if (this.rel != null && rel.equalsIgnoreCase("enclosure")) {
-			if (type != null)
-				xmlNamespaceAttributes.add(GOMUtils
-						.buildDefaultNamespaceAttribute(type, "type"));
-			if (href != null)
-				xmlNamespaceAttributes.add(GOMUtils
-						.buildDefaultNamespaceAttribute(href, "href"));
-
-			aStreamWriter.writeSimpleXMLElement("enclosure",
-					xmlNamespaceAttributes, null);
-		} else if ("comments".equalsIgnoreCase(this.rel))
-			aStreamWriter.writeSimpleXMLElement("comments", null, this.href);
-
-		else if ("alternate".equalsIgnoreCase(this.rel))
-			aStreamWriter.writeSimpleXMLElement("link", null, this.href);
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMLogoImpl.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMLogoImpl.java
deleted file mode 100644
index 93f9ab6..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMLogoImpl.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.GOMLogo;
-import org.apache.lucene.gdata.gom.GOMNamespace;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class GOMLogoImpl extends AtomUriElement implements GOMLogo {
-
-	/**
-	 * default class constructor
-	 */
-	public GOMLogoImpl() {
-		this.localName = GOMLogo.LOCALNAME;
-		this.qname = new QName(GOMNamespace.ATOM_NS_URI, this.localName);
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.SimpleGOMElementImpl#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
-	 */
-	@Override
-	public void writeRssOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-		aStreamWriter.writeSimpleXMLElement("url", getXmlNamespaceAttributes(),
-				this.textValue);
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMPersonImpl.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMPersonImpl.java
deleted file mode 100644
index 6938541..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMPersonImpl.java
+++ /dev/null
@@ -1,245 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.GOMAttribute;
-import org.apache.lucene.gdata.gom.GOMNamespace;
-import org.apache.lucene.gdata.gom.core.utils.GOMUtils;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class GOMPersonImpl extends AbstractGOMElement implements
-		org.apache.lucene.gdata.gom.GOMPerson {
-
-	private final static String NAME_LOCAL_NAME = "name";
-
-	private final static String EMAIL_LOCAL_NAME = "email";
-
-	private final static String URI_LOCAL_NAME = "uri";
-
-	protected String uri;
-
-	protected String email;
-
-	protected String name;
-
-	/**
-	 * 
-	 */
-	public GOMPersonImpl() {
-		super();
-		this.localName = LOCALNAME;
-		this.qname = new QName(GOMNamespace.ATOM_NS_URI, this.localName);
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMPerson#setName(java.lang.String)
-	 */
-	public void setName(String aName) {
-		this.name = aName;
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMPerson#setEmail(java.lang.String)
-	 */
-	public void setEmail(String aEmail) {
-		this.email = aEmail;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMPerson#setUri(java.lang.String)
-	 */
-	public void setUri(String aUri) {
-		this.uri = aUri;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMPerson#getName()
-	 */
-	public String getName() {
-
-		return this.name;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMPerson#getEmail()
-	 */
-	public String getEmail() {
-		return this.email;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMPerson#getUri()
-	 */
-	public String getUri() {
-
-		return this.uri;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMElement#writeAtomOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
-	 */
-	public void writeAtomOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-		if (aStreamWriter == null)
-			throw new GDataParseException("GOMWriter must not be null");
-		List<GOMAttribute> list = getXmlNamespaceAttributes();
-		if (this.xmlLang != null) {
-			list = new ArrayList<GOMAttribute>(1);
-			list.add(GOMUtils
-					.buildXMLNamespaceAttribute(this.xmlLang, XML_LANG));
-		}
-		aStreamWriter.writeStartElement(this.qname, list);
-		aStreamWriter.writeSimpleXMLElement(NAME_LOCAL_NAME, this.name, null);
-		if (this.email != null)
-			aStreamWriter.writeSimpleXMLElement(EMAIL_LOCAL_NAME, this.email,
-					null);
-		if (this.uri != null)
-			aStreamWriter.writeSimpleXMLElement(URI_LOCAL_NAME, this.uri, null);
-
-		aStreamWriter.writeEndElement();
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMElement#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
-	 */
-	public void writeRssOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-		//
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#getChildParser(javax.xml.namespace.QName)
-	 */
-	@Override
-	public AtomParser getChildParser(QName aName) {
-		if (aName == null)
-			throw new GDataParseException("QName must not be null");
-		if (aName.getNamespaceURI().equals(GOMNamespace.ATOM_NS_URI)) {
-			if (aName.getLocalPart().equals(NAME_LOCAL_NAME))
-				return this.new NameParser();
-			if (aName.getLocalPart().equals(URI_LOCAL_NAME))
-				return this.new UriParser();
-			if (aName.getLocalPart().equals(EMAIL_LOCAL_NAME))
-				return this.new EmailParser();
-		}
-		return super.getChildParser(aName);
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#processEndElement()
-	 */
-	@Override
-	public void processEndElement() {
-		if (this.name == null)
-			throw new GDataParseException(String.format(
-					AtomParser.MISSING_ELEMENT_CHILD, this.localName,
-					NAME_LOCAL_NAME));
-	}
-
-	class NameParser extends SimpleElementParser {
-
-		NameParser() {
-			this.localname = NAME_LOCAL_NAME;
-		}
-
-		/**
-		 * @see org.apache.lucene.gdata.gom.core.AtomParser#processEndElement()
-		 */
-		public void processEndElement() {
-			if (name != null)
-				throw new GDataParseException(String.format(
-						AtomParser.DUPLICATE_ELEMENT, this.localname));
-			if (this.aString != null)
-				name = this.aString;
-
-		}
-
-	}
-
-	class UriParser extends SimpleElementParser {
-
-		UriParser() {
-			this.localname = URI_LOCAL_NAME;
-		}
-
-		/**
-		 * @see org.apache.lucene.gdata.gom.core.AtomParser#processEndElement()
-		 */
-		public void processEndElement() {
-			if (uri != null)
-				throw new GDataParseException(String.format(
-						AtomParser.DUPLICATE_ELEMENT, this.localname));
-			if (this.aString != null)
-				uri = this.aString;
-
-		}
-
-	}
-
-	class EmailParser extends SimpleElementParser {
-
-		EmailParser() {
-			this.localname = EMAIL_LOCAL_NAME;
-		}
-
-		/**
-		 * @see org.apache.lucene.gdata.gom.core.AtomParser#processEndElement()
-		 */
-		public void processEndElement() {
-			if (email != null)
-				throw new GDataParseException(String.format(
-						AtomParser.DUPLICATE_ELEMENT, this.localname));
-			if (this.aString != null)
-				email = this.aString;
-
-		}
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMOutputWriter,
-	 *      java.lang.String)
-	 */
-	@Override
-	public void writeRssOutput(GOMOutputWriter aStreamWriter, String aRssName)
-			throws XMLStreamException {
-		if (aStreamWriter == null)
-			throw new GDataParseException("GOMWriter must not be null");
-		StringBuilder builder = new StringBuilder("");
-		if (this.email != null)
-			builder.append(this.email);
-		if (this.name != null)
-			builder.append("(").append(this.name).append(")");
-		aStreamWriter.writeSimpleXMLElement(aRssName,
-				getXmlNamespaceAttributes(), builder.toString());
-
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMPublishedImpl.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMPublishedImpl.java
deleted file mode 100644
index 274ac90..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMPublishedImpl.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.GOMPublished;
-import org.apache.lucene.gdata.gom.core.utils.GOMUtils;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class GOMPublishedImpl extends GOMDateConstructImpl implements
-		GOMPublished {
-	protected static final QName RSS_QNAME = new QName("pubDate");
-
-	/**
-	 * 
-	 */
-	public GOMPublishedImpl() {
-		this.localName = GOMPublished.LOCALNAME;
-		this.qname = new QName(this.localName);
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMElement#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
-	 */
-	public void writeRssOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-		String rssRFC3339Date = GOMUtils
-				.buildRfc822Date(this.date == 0 ? System.currentTimeMillis()
-						: this.date);
-		aStreamWriter.writeSimpleXMLElement(RSS_QNAME,
-				getXmlNamespaceAttributes(), rssRFC3339Date);
-
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMRightsImpl.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMRightsImpl.java
deleted file mode 100644
index 94b9a15..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMRightsImpl.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.GOMNamespace;
-import org.apache.lucene.gdata.gom.GOMRights;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class GOMRightsImpl extends GOMTextContructImpl implements GOMRights {
-
-	/**
-	 * 
-	 */
-	public GOMRightsImpl() {
-		this.localName = GOMRights.LOCALNAME;
-		this.rssLocalName = GOMRights.LOCALNAME;
-		this.qname = new QName(GOMNamespace.ATOM_NS_URI, this.localName);
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.GOMTextContructImpl#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
-	 */
-	@Override
-	public void writeRssOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-		aStreamWriter.writeSimpleXMLElement("copyright", null, this.textValue);
-	}
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMSourceImpl.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMSourceImpl.java
deleted file mode 100644
index 6e0ad96..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMSourceImpl.java
+++ /dev/null
@@ -1,544 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import java.util.LinkedList;
-import java.util.List;
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.GOMAttribute;
-import org.apache.lucene.gdata.gom.GOMAuthor;
-import org.apache.lucene.gdata.gom.GOMCategory;
-import org.apache.lucene.gdata.gom.GOMContributor;
-import org.apache.lucene.gdata.gom.GOMGenerator;
-import org.apache.lucene.gdata.gom.GOMIcon;
-import org.apache.lucene.gdata.gom.GOMId;
-import org.apache.lucene.gdata.gom.GOMLink;
-import org.apache.lucene.gdata.gom.GOMLogo;
-import org.apache.lucene.gdata.gom.GOMNamespace;
-import org.apache.lucene.gdata.gom.GOMRights;
-import org.apache.lucene.gdata.gom.GOMSource;
-import org.apache.lucene.gdata.gom.GOMSubtitle;
-import org.apache.lucene.gdata.gom.GOMTitle;
-import org.apache.lucene.gdata.gom.GOMUpdated;
-import org.apache.lucene.gdata.gom.core.utils.AtomParserUtils;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class GOMSourceImpl extends AbstractGOMElement implements GOMSource {
-
-	protected List<GOMAuthor> authors = new LinkedList<GOMAuthor>();
-
-	protected List<GOMCategory> categories = new LinkedList<GOMCategory>();
-
-	protected List<GOMLink> links = new LinkedList<GOMLink>();
-
-	protected List<GOMContributor> contributors = new LinkedList<GOMContributor>();
-
-	protected GOMGenerator generator;
-
-	protected GOMId id;
-
-	protected GOMLogo logo;
-
-	protected GOMRights rights;
-
-	protected GOMSubtitle subtitle;
-
-	protected GOMTitle title;
-
-	protected GOMUpdated updated;
-
-	protected GOMIcon icon;
-
-	GOMSourceImpl() {
-		this.localName = LOCALNAME;
-		this.qname = new QName(GOMNamespace.ATOM_NS_URI, this.localName);
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#getLocalName()
-	 */
-	@Override
-	public String getLocalName() {
-		return this.localName;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMSource#addAuthor(org.apache.lucene.gdata.gom.GOMAuthor)
-	 */
-	public void addAuthor(GOMAuthor aAuthor) {
-		if (aAuthor != null)
-			this.authors.add(aAuthor);
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMSource#addCategory(org.apache.lucene.gdata.gom.GOMCategory)
-	 */
-	public void addCategory(GOMCategory aCategory) {
-		if (aCategory != null)
-			this.categories.add(aCategory);
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMSource#addContributor(org.apache.lucene.gdata.gom.GOMContributor)
-	 */
-	public void addContributor(GOMContributor aContributor) {
-		if (aContributor != null)
-			this.contributors.add(aContributor);
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMSource#getAuthors()
-	 * 
-	 */
-	public List<GOMAuthor> getAuthors() {
-		return this.authors;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMSource#getCategories()
-	 * 
-	 */
-	public List<GOMCategory> getCategories() {
-		return this.categories;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMSource#getContributor()
-	 */
-	public List<GOMContributor> getContributor() {
-		return this.contributors;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMSource#getGenerator()
-	 * 
-	 */
-	public GOMGenerator getGenerator() {
-		return this.generator;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMSource#getId()
-	 * 
-	 */
-	public GOMId getId() {
-		return this.id;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMSource#setGenerator(org.apache.lucene.gdata.gom.GOMGenerator)
-	 * 
-	 */
-	public void setGenerator(GOMGenerator aGenerator) {
-		this.generator = aGenerator;
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMSource#setIcon(org.apache.lucene.gdata.gom.GOMIcon)
-	 * 
-	 */
-	public void setIcon(GOMIcon aIcon) {
-		this.icon = aIcon;
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMSource#setId(org.apache.lucene.gdata.gom.GOMId)
-	 * 
-	 */
-	public void setId(GOMId aId) {
-		this.id = aId;
-
-	}
-
-	/**
-	 * @return the logo
-	 * 
-	 */
-	public GOMLogo getLogo() {
-		return this.logo;
-	}
-
-	/**
-	 * @param aLogo
-	 *            the logo to set
-	 * 
-	 */
-	public void setLogo(GOMLogo aLogo) {
-		this.logo = aLogo;
-	}
-
-	/**
-	 * @return the rights
-	 * 
-	 */
-	public GOMRights getRights() {
-		return this.rights;
-	}
-
-	/**
-	 * @param aRights
-	 *            the rights to set
-	 * 
-	 */
-	public void setRights(GOMRights aRights) {
-		rights = aRights;
-	}
-
-	/**
-	 * @return the subtitle
-	 * 
-	 */
-	public GOMSubtitle getSubtitle() {
-		return this.subtitle;
-	}
-
-	/**
-	 * @param aSubtitle
-	 *            the subtitle to set
-	 * 
-	 */
-	public void setSubtitle(GOMSubtitle aSubtitle) {
-		this.subtitle = aSubtitle;
-	}
-
-	/**
-	 * @return the title
-	 * 
-	 */
-	public GOMTitle getTitle() {
-		return this.title;
-	}
-
-	/**
-	 * @param aTitle
-	 *            the title to set
-	 * 
-	 */
-	public void setTitle(GOMTitle aTitle) {
-		this.title = aTitle;
-	}
-
-	/**
-	 * @return the updated
-	 * 
-	 */
-	public GOMUpdated getUpdated() {
-		return this.updated;
-	}
-
-	/**
-	 * @param aUpdated
-	 *            the updated to set
-	 * 
-	 */
-	public void setUpdated(GOMUpdated aUpdated) {
-		this.updated = aUpdated;
-	}
-
-	/**
-	 * @return the icon
-	 * 
-	 */
-	public GOMIcon getIcon() {
-		return this.icon;
-	}
-
-	/**
-	 * @return the links
-	 * 
-	 */
-	public List<GOMLink> getLinks() {
-		return this.links;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMSource#addLink(org.apache.lucene.gdata.gom.GOMLink)
-	 */
-	public void addLink(GOMLink aLink) {
-		if (aLink == null)
-			return;
-		this.links.add(aLink);
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.AtomParser#processElementValue(java.lang.String)
-	 */
-	public void processElementValue(String aValue) {
-		throw new GDataParseException(String.format(
-				AtomParser.UNEXPECTED_ELEMENT_VALUE, this.localName));
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.AtomParser#processEndElement()
-	 */
-	public void processEndElement() {
-		/*
-		 * atom:feed elements MUST contain exactly one atom:id element.
-		 */
-		if (this.id == null)
-			throw new GDataParseException(String.format(
-					MISSING_ELEMENT_CHILD, this.localName, GOMId.LOCALNAME));
-		/*
-		 * atom:feed elements MUST contain exactly one atom:title element.
-		 */
-		if (this.title == null)
-			throw new GDataParseException(String
-					.format(MISSING_ELEMENT_CHILD, this.localName,
-							GOMTitle.LOCALNAME));
-		/*
-		 * atom:feed elements MUST contain exactly one atom:updated element.
-		 */
-		if (this.updated == null)
-			throw new GDataParseException(String.format(
-					MISSING_ELEMENT_CHILD, this.localName,
-					GOMUpdated.LOCALNAME));
-		/*
-		 * atom:feed elements MUST contain one or more atom:author elements,
-		 * unless all of the
-		 */
-		if (this.authors.size() < 1)
-			throw new GDataParseException(String.format(
-					MISSING_ELEMENT_CHILD, this.localName,
-					GOMAuthor.LOCALNAME));
-
-		/*
-		 * atom:feed elements MUST NOT contain more than one atom:link element
-		 * with a rel attribute value of "alternate" that has the same
-		 * combination of type and hreflang attribute values.
-		 */
-		List<GOMLink> alternateLinks = new LinkedList<GOMLink>();
-		for (GOMLink link : this.links) {
-			/*
-			 * atom:link elements MAY have a "rel" attribute that indicates the
-			 * link relation type. If the "rel" attribute is not present, the
-			 * link element MUST be interpreted as if the link relation type is
-			 * "alternate".
-			 */
-			if (link.getRel() == null
-					|| link.getRel().equalsIgnoreCase("alternate"))
-				alternateLinks.add(link);
-		}
-
-		/*
-		 * atom:feed elements MUST NOT contain more than one atom:link element
-		 * with a rel attribute value of "alternate" that has the same
-		 * combination of type and hreflang attribute values.
-		 */
-		if (alternateLinks.size() > 1) {
-			for (GOMLink link : alternateLinks) {
-				for (GOMLink link2 : alternateLinks) {
-					if (link != link2)
-						if (AtomParserUtils.compareAlternateLinks(link, link2))
-							throw new GDataParseException(
-									String
-											.format(DUPLICATE_ELEMENT,
-													"link with rel=\"alternate\" and same href and type attributes"));
-
-				}
-			}
-		}
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.AtomParser#getChildParser(javax.xml.namespace.QName)
-	 */
-	public AtomParser getChildParser(QName aName) {
-		if (aName.getNamespaceURI().equals(GOMNamespace.ATOM_NS_URI)) {
-			if (aName.getLocalPart().equals(GOMId.LOCALNAME)) {
-				// atom:feed / atom:source elements MUST contain exactly one
-				// atom:id element.
-				if (this.id != null)
-					throw new GDataParseException(String.format(
-							AtomParser.DUPLICATE_ELEMENT, GOMId.LOCALNAME));
-				this.id = new GOMIdImpl();
-				return this.id;
-			}
-			if (aName.getLocalPart().equals(GOMTitle.LOCALNAME)) {
-				// atom:feed / atom:source elements MUST contain exactly one
-				// atom:title
-				// element.
-				if (this.title != null)
-					throw new GDataParseException(String.format(
-							AtomParser.DUPLICATE_ELEMENT, GOMTitle.LOCALNAME));
-				this.title = new GOMTitleImpl();
-				return this.title;
-			}
-			if (aName.getLocalPart().equals(GOMAuthor.LOCALNAME)) {
-				GOMAuthor author = new GOMAuthorImpl();
-				this.authors.add(author);
-				return author;
-			}
-			if (aName.getLocalPart().equals(GOMCategory.LOCALNAME)) {
-				GOMCategory category = new GOMCategoryImpl();
-				this.categories.add(category);
-				return category;
-			}
-			if (aName.getLocalPart().equals(GOMContributor.LOCALNAME)) {
-				GOMContributorImpl impl = new GOMContributorImpl();
-				this.contributors.add(impl);
-				return impl;
-			}
-			if (aName.getLocalPart().equals(GOMLink.LOCALNAME)) {
-				GOMLinkImpl impl = new GOMLinkImpl();
-				this.links.add(impl);
-				return impl;
-			}
-			if (aName.getLocalPart().equals(GOMSubtitle.LOCALNAME)) {
-				GOMSubtitleImpl impl = new GOMSubtitleImpl();
-				/*
-				 * atom:feed elements MUST NOT contain more than one
-				 * atom:subtitle element.
-				 */
-				if (this.subtitle != null)
-					throw new GDataParseException(String.format(
-							AtomParser.DUPLICATE_ELEMENT,
-							GOMSubtitle.LOCALNAME));
-				this.subtitle = impl;
-				return this.subtitle;
-			}
-			if (aName.getLocalPart().equals(GOMUpdated.LOCALNAME)) {
-				if (this.updated != null)
-					throw new GDataParseException(String.format(
-							AtomParser.DUPLICATE_ELEMENT,
-							GOMUpdated.LOCALNAME));
-				GOMUpdated updatedImpl = new GOMUpdatedImpl();
-				this.updated = updatedImpl;
-				return this.updated;
-
-			}
-			if (aName.getLocalPart().equals(GOMLogo.LOCALNAME)) {
-				if (this.logo != null)
-					throw new GDataParseException(String.format(
-							AtomParser.DUPLICATE_ELEMENT, GOMLogo.LOCALNAME));
-
-				this.logo = new GOMLogoImpl();
-				return this.logo;
-
-			}
-			if (aName.getLocalPart().equals(GOMIcon.LOCALNAME)) {
-				if (this.icon != null)
-					throw new GDataParseException(String.format(
-							AtomParser.DUPLICATE_ELEMENT, GOMIcon.LOCALNAME));
-
-				this.icon = new GOMIconImpl();
-				return this.icon;
-
-			}
-			if (aName.getLocalPart().equals(GOMGenerator.LOCALNAME)) {
-				if (this.generator != null)
-					throw new GDataParseException(String.format(
-							AtomParser.DUPLICATE_ELEMENT,
-							GOMGenerator.LOCALNAME));
-
-				this.generator = new GOMGeneratorImpl();
-				return this.generator;
-
-			}
-			if (aName.getLocalPart().equals(GOMRights.LOCALNAME)) {
-				if (this.rights != null)
-					throw new GDataParseException(String
-							.format(AtomParser.DUPLICATE_ELEMENT,
-									GOMRights.LOCALNAME));
-
-				this.rights = new GOMRightsImpl();
-				return this.rights;
-
-			}
-
-		}
-		throw new GDataParseException(String.format(
-				AtomParser.URECOGNIZED_ELEMENT_CHILD, this.localName, aName
-						.getLocalPart()));
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMElement#writeAtomOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
-	 */
-	public void writeAtomOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-		aStreamWriter.writeStartElement(this.localName,
-				this.extensionAttributes);
-		List<GOMAttribute> xmlNamespaceAttributes = getXmlNamespaceAttributes();
-		for (GOMAttribute attribute : xmlNamespaceAttributes) {
-			aStreamWriter.writeAttribute(attribute);
-		}
-		writeInnerAtomOutput(aStreamWriter);
-		aStreamWriter.writeEndElement();
-
-	}
-
-	/**
-	 * @param aStreamWriter
-	 * @throws XMLStreamException
-	 */
-	protected void writeInnerAtomOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-		if (this.id != null)
-			this.id.writeAtomOutput(aStreamWriter);
-		if (this.title != null)
-			this.title.writeAtomOutput(aStreamWriter);
-		if (this.subtitle != null)
-			this.subtitle.writeAtomOutput(aStreamWriter);
-		for (GOMAuthor authors : this.authors) {
-			authors.writeAtomOutput(aStreamWriter);
-		}
-		for (GOMCategory category : this.categories) {
-			category.writeAtomOutput(aStreamWriter);
-		}
-		for (GOMContributor contributor : this.contributors) {
-			contributor.writeAtomOutput(aStreamWriter);
-		}
-		for (GOMLink link : this.links) {
-			link.writeAtomOutput(aStreamWriter);
-		}
-		if (this.rights != null)
-			this.rights.writeAtomOutput(aStreamWriter);
-		if (this.updated != null)
-			this.updated.writeAtomOutput(aStreamWriter);
-		if (this.logo != null)
-			this.logo.writeAtomOutput(aStreamWriter);
-		if (this.icon != null)
-			this.icon.writeAtomOutput(aStreamWriter);
-		if (this.generator != null)
-			this.generator.writeAtomOutput(aStreamWriter);
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMElement#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
-	 */
-	public void writeRssOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-		// no rss output
-
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMSubtitleImpl.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMSubtitleImpl.java
deleted file mode 100644
index 6037595..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMSubtitleImpl.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import javax.xml.namespace.QName;
-
-import org.apache.lucene.gdata.gom.GOMNamespace;
-import org.apache.lucene.gdata.gom.GOMSubtitle;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class GOMSubtitleImpl extends GOMTextContructImpl implements GOMSubtitle {
-
-	/**
-	 * 
-	 */
-	public GOMSubtitleImpl() {
-		this.localName = GOMSubtitle.LOCALNAME;
-		this.rssLocalName = GOMSubtitle.RSS_LOCALNAME;
-		this.qname = new QName(GOMNamespace.ATOM_NS_URI, this.localName);
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMSummaryImpl.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMSummaryImpl.java
deleted file mode 100644
index dd5e249..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMSummaryImpl.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.GOMNamespace;
-import org.apache.lucene.gdata.gom.GOMSummary;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class GOMSummaryImpl extends GOMTextContructImpl implements GOMSummary {
-	protected static final QName ATOM_QNAME = new QName(
-			GOMNamespace.ATOM_NS_URI, LOCALNAME, GOMNamespace.ATOM_NS_PREFIX);
-
-	/**
-	 * 
-	 */
-	public GOMSummaryImpl() {
-		this.localName = GOMSummary.LOCALNAME;
-		this.qname = new QName(GOMNamespace.ATOM_NS_URI, this.localName);
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.GOMTextContructImpl#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
-	 */
-	@Override
-	public void writeRssOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-		/*
-		 * RSS does not support markup as child elements StaX Writer will encode
-		 * all containing markup into valid xml entities
-		 */
-		aStreamWriter.writeSimpleXMLElement(ATOM_QNAME,
-				getXmlNamespaceAttributes(), this.textValue);
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMTextContructImpl.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMTextContructImpl.java
deleted file mode 100644
index 564f313..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMTextContructImpl.java
+++ /dev/null
@@ -1,270 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import java.io.StringWriter;
-import java.util.List;
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.XMLOutputFactory;
-import javax.xml.stream.XMLStreamException;
-import javax.xml.stream.XMLStreamWriter;
-
-import org.apache.lucene.gdata.gom.ContentType;
-import org.apache.lucene.gdata.gom.GOMAttribute;
-import org.apache.lucene.gdata.gom.GOMTextConstruct;
-import org.apache.lucene.gdata.gom.core.utils.GOMUtils;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public abstract class GOMTextContructImpl extends AbstractGOMElement implements
-		GOMTextConstruct {
-
-	protected ContentType contentType;
-
-	protected String rssLocalName;
-
-	/*
-	 * parses the xhtml content
-	 */
-	protected transient XMLBlobContentParser blobParser = null;
-
-	/*
-	 * this string builder contains the html while parsing the incoming text
-	 * contruct. process element value will be called multiple times
-	 */
-	protected transient StringBuilder htmlBuilder = null;
-
-	/**
-	 * @return the contentType
-	 * 
-	 */
-	public ContentType getContentType() {
-		return this.contentType;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.AtomParser#processElementValue(java.lang.String)
-	 */
-	public void processElementValue(String aValue) {
-		if (this.htmlBuilder != null)
-			this.htmlBuilder.append(aValue);
-		else {
-			this.textValue = aValue;
-		}
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.AtomParser#processAttribute(javax.xml.namespace.QName,
-	 *      java.lang.String)
-	 */
-	public void processAttribute(QName aQName, String aValue) {
-		if (aQName == null)
-			throw new GDataParseException("QName must not be null");
-		if ("type".equals(aQName.getLocalPart()) && aValue != null) {
-			if (this.contentType != null)
-				throw new GDataParseException(String.format(
-						DUPLICATE_ATTRIBUTE, "type"));
-			this.contentType = ContentType.valueOf(aValue.toUpperCase());
-			if (this.contentType == ContentType.HTML)
-				this.htmlBuilder = new StringBuilder();
-		}
-		super.processAttribute(aQName, aValue);
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.AtomParser#processEndElement()
-	 */
-	public void processEndElement() {
-		if (this.contentType == null)
-			throw new GDataParseException(String.format(
-					MISSING_ELEMENT_ATTRIBUTE, this.qname, "type"));
-		switch (this.contentType) {
-		case XHTML:
-			if (this.blobParser != null) {
-				this.textValue = this.blobParser.toString();
-				this.blobParser.close();
-				this.blobParser = null;
-			}
-
-			break;
-		case HTML:
-			if (this.htmlBuilder != null) {
-				this.textValue = this.htmlBuilder.toString();
-				this.htmlBuilder = null;
-			}
-
-		default:
-			break;
-		}
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMElement#writeAtomOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
-	 */
-	public void writeAtomOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-		List<GOMAttribute> xmlNamespaceAttributes = getXmlNamespaceAttributes();
-		xmlNamespaceAttributes.add(GOMUtils
-				.getAttributeByContentTypeDefaultNs(this.contentType));
-		if (this.contentType == ContentType.XHTML) {
-			/*
-			 * if the content is xhtml write it unescaped
-			 */
-			aStreamWriter.writeStartElement(this.localName,
-					xmlNamespaceAttributes);
-			aStreamWriter.writeContentUnescaped(this.textValue);
-			aStreamWriter.writeEndElement();
-
-		} else {
-			// html and text will be escaped by stax writer
-			aStreamWriter.writeSimpleXMLElement(this.localName,
-					xmlNamespaceAttributes, this.textValue);
-		}
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMElement#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
-	 */
-	public void writeRssOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-		/*
-		 * RSS does not support markup as child elements StaX Writer will encode
-		 * all containing markup into valid xml entities
-		 */
-		aStreamWriter.writeSimpleXMLElement(this.rssLocalName,
-				getXmlNamespaceAttributes(), this.textValue);
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.AtomParser#getChildParser(javax.xml.namespace.QName)
-	 */
-	@Override
-	public AtomParser getChildParser(QName aName) {
-		if (aName == null)
-			throw new GDataParseException("QName must not be null");
-		if (this.contentType == ContentType.XHTML
-				&& aName.getLocalPart().equals("div")) {
-			if (this.blobParser != null)
-				throw new GDataParseException(String.format(
-						DUPLICATE_ELEMENT, "div"));
-			this.blobParser = new XMLBlobContentParser();
-			return this.blobParser.getChildParser(aName);
-		}
-
-		return super.getChildParser(aName);
-
-	}
-
-	class XMLBlobContentParser implements AtomParser {
-		private StringWriter writer;
-
-		private XMLStreamWriter xmlWriter;
-
-		/**
-		 * 
-		 */
-		public XMLBlobContentParser() {
-			super();
-			this.writer = new StringWriter();
-			try {
-				this.xmlWriter = XMLOutputFactory.newInstance()
-						.createXMLStreamWriter(this.writer);
-			} catch (Exception e) {
-				throw new GDataParseException(e);
-			}
-		}
-
-		/**
-		 * @see org.apache.lucene.gdata.gom.core.AtomParser#processElementValue(java.lang.String)
-		 */
-		public void processElementValue(String aValue) {
-			try {
-				this.xmlWriter.writeCharacters(aValue);
-			} catch (XMLStreamException e) {
-				throw new GDataParseException(e);
-			}
-
-		}
-
-		/**
-		 * @see org.apache.lucene.gdata.gom.core.AtomParser#processAttribute(javax.xml.namespace.QName,
-		 *      java.lang.String)
-		 */
-		public void processAttribute(QName aQName, String aValue) {
-			try {
-				this.xmlWriter.writeAttribute(aQName.getNamespaceURI(), aQName
-						.getLocalPart(), aQName.getPrefix(), aValue);
-			} catch (XMLStreamException e) {
-				throw new GDataParseException(e);
-			}
-
-		}
-
-		/**
-		 * @see org.apache.lucene.gdata.gom.core.AtomParser#processEndElement()
-		 */
-		public void processEndElement() {
-			try {
-				this.xmlWriter.writeEndElement();
-			} catch (XMLStreamException e) {
-				throw new GDataParseException(e);
-			}
-
-		}
-
-		/**
-		 * @see org.apache.lucene.gdata.gom.core.AtomParser#getChildParser(javax.xml.namespace.QName)
-		 */
-		public AtomParser getChildParser(QName aName) {
-			try {
-				this.xmlWriter.writeStartElement(aName.getNamespaceURI(), aName
-						.getLocalPart(), aName.getPrefix());
-			} catch (XMLStreamException e) {
-				throw new GDataParseException(e);
-			}
-			return this;
-		}
-
-		/**
-		 * @see java.lang.Object#toString()
-		 */
-		public String toString() {
-			return this.writer.toString();
-		}
-
-		/**
-		 * 
-		 */
-		public void close() {
-			try {
-				this.xmlWriter.close();
-				this.writer.close();
-			} catch (Exception e) {
-				throw new GDataParseException(e);
-			}
-		}
-
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMTitleImpl.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMTitleImpl.java
deleted file mode 100644
index 2db8328..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMTitleImpl.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import javax.xml.namespace.QName;
-
-import org.apache.lucene.gdata.gom.GOMNamespace;
-import org.apache.lucene.gdata.gom.GOMTitle;
-
-/**
- * @author Simon Willnauer
- */
-public class GOMTitleImpl extends GOMTextContructImpl implements GOMTitle {
-	/**
-	 * 
-	 */
-	public GOMTitleImpl() {
-		super();
-		this.localName = LOCALNAME;
-		this.rssLocalName = LOCALNAME;
-		this.qname = new QName(GOMNamespace.ATOM_NS_URI, this.localName);
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMUpdatedImpl.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMUpdatedImpl.java
deleted file mode 100644
index 7d27ca2..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/GOMUpdatedImpl.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.GOMNamespace;
-import org.apache.lucene.gdata.gom.GOMUpdated;
-import org.apache.lucene.gdata.gom.core.utils.GOMUtils;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class GOMUpdatedImpl extends GOMDateConstructImpl implements GOMUpdated {
-	protected static final QName ATOM_QNAME = new QName(
-			GOMNamespace.ATOM_NS_URI, LOCALNAME, GOMNamespace.ATOM_NS_PREFIX);
-
-	/**
-	 * 
-	 */
-	public GOMUpdatedImpl() {
-		super();
-		this.localName = LOCALNAME;
-		this.qname = new QName(GOMNamespace.ATOM_NS_URI, this.localName);
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMElement#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
-	 */
-	public void writeRssOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-		if (this.rfc3339String == null)
-			this.rfc3339String = GOMUtils
-					.buildRfc3339DateFormat(this.date == 0 ? System
-							.currentTimeMillis() : this.date);
-		aStreamWriter.writeSimpleXMLElement(ATOM_QNAME,
-				getXmlNamespaceAttributes(), this.rfc3339String);
-
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/SimpleElementParser.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/SimpleElementParser.java
deleted file mode 100644
index 495b07b..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/SimpleElementParser.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import javax.xml.namespace.QName;
-
-/**
- * @author Simon Willnauer
- * 
- */
-abstract class SimpleElementParser implements AtomParser {
-	protected String aString = null;
-
-	protected String localname = null;
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.AtomParser#processElementValue(java.lang.String)
-	 */
-	public void processElementValue(String aValue) {
-		this.aString = aValue;
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.AtomParser#processAttribute(javax.xml.namespace.QName,
-	 *      java.lang.String)
-	 */
-	public void processAttribute(QName aQName, String aValue) {
-		//
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.AtomParser#processEndElement()
-	 */
-	public abstract void processEndElement();
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.AtomParser#getChildParser(javax.xml.namespace.QName)
-	 */
-	public AtomParser getChildParser(QName aName) {
-		if (aName == null)
-			throw new GDataParseException("QName must not be null");
-		throw new GDataParseException(String.format(
-				AtomParser.UNEXPECTED_ELEMENT_CHILD, this.localname));
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/SimpleGOMElementImpl.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/SimpleGOMElementImpl.java
deleted file mode 100644
index 8c1cc21..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/SimpleGOMElementImpl.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.GOMNamespace;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class SimpleGOMElementImpl extends AbstractGOMElement {
-	public static final String ELEMENT_OS_ITEMS_PER_PAGE = "itemsPerPage";
-
-	public static final String ELEMENT_OS_START_INDEX = "startIndex";
-
-	private SimpleValidator validator;
-
-	/**
-	 * 
-	 */
-	public SimpleGOMElementImpl(String aLocalName, GOMNamespace aNamespace) {
-		super();
-		if (aLocalName == null)
-			throw new IllegalArgumentException("localname must not be null");
-		if (aNamespace == null)
-			throw new IllegalArgumentException("Namespace must not be null");
-		this.localName = aLocalName;
-		this.qname = new QName(aNamespace.getNamespaceUri(), this.localName,
-				aNamespace.getNamespacePrefix());
-	}
-
-	SimpleGOMElementImpl() {
-		// for subclasses
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#processElementValue(java.lang.String)
-	 */
-	@Override
-	public void processElementValue(String aValue) {
-		if (this.textValue != null)
-			throw new GDataParseException(String.format(
-					AtomParser.DUPLICATE_ELEMENT_VALUE, this.localName));
-		this.textValue = aValue;
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#processEndElement()
-	 */
-	@Override
-	public void processEndElement() {
-		if (this.validator != null)
-			this.validator.validate(this.textValue);
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMElement#writeAtomOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
-	 */
-	public void writeAtomOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-		aStreamWriter.writeSimpleXMLElement(this.qname,
-				getXmlNamespaceAttributes(), this.textValue);
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.GOMElement#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
-	 */
-	public void writeRssOutput(GOMOutputWriter aStreamWriter)
-			throws XMLStreamException {
-		writeAtomOutput(aStreamWriter);
-
-	}
-
-	protected abstract static class SimpleValidator {
-		String localName;
-
-		protected SimpleValidator(String aLocalName) {
-			this.localName = aLocalName;
-		}
-
-		/**
-		 * @param aTextValue
-		 */
-		protected void validate(String aTextValue) {
-			if (aTextValue == null)
-				throw new GDataParseException(String.format(
-						AtomParser.MISSING_ELEMENT_VALUE_PLAIN,
-						this.localName));
-		}
-
-	}
-
-	/**
-	 * @param aValidator
-	 *            The validator to set.
-	 */
-	public void setValidator(SimpleValidator aValidator) {
-		validator = aValidator;
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/core-aid.gif b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/core-aid.gif
deleted file mode 100644
index 9d42f36..0000000
Binary files a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/core-aid.gif and /dev/null differ
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/core-aid.ucd b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/core-aid.ucd
deleted file mode 100644
index 01145fb..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/core-aid.ucd
+++ /dev/null
@@ -1,257 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<editmodel:ClassDiagramEditModel xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:editmodel="editmodel.xmi" xmlns:options="options.xmi" name="core-aid" description="" id="org.apache.lucene.gdata.gom.core" metadata="uml2-1.0" initialized="true" zoom="1.5" scrolledX="1601" scrolledY="503" tag="1000" key="3230303631303036204764617461556D6C2F73696D6F6E">
-  <children xsi:type="editmodel:ClassEditModel" name="GDataParseException" location="50,1339" size="240,151" id="org.apache.lucene.gdata.gom.core/GDataParseException" runTimeClassModel="GDataParseException(Ljava.lang.String;),GDataParseException(),GDataParseException(Ljava.lang.String;Ljava.lang.Throwable;),GDataParseException(Ljava.lang.Throwable;)">
-    <children xsi:type="editmodel:CompartmentEditModel"/>
-    <children xsi:type="editmodel:CompartmentEditModel" size="217,72">
-      <children xsi:type="editmodel:MethodEditModel" name="GDataParseException" id="org.apache.lucene.gdata.gom.core/GDataParseException#GDataParseException()"/>
-      <children xsi:type="editmodel:MethodEditModel" name="GDataParseException" id="org.apache.lucene.gdata.gom.core/GDataParseException#GDataParseException(Ljava.lang.String;)"/>
-      <children xsi:type="editmodel:MethodEditModel" name="GDataParseException" id="org.apache.lucene.gdata.gom.core/GDataParseException#GDataParseException(Ljava.lang.Throwable;)"/>
-      <children xsi:type="editmodel:MethodEditModel" name="GDataParseException" id="org.apache.lucene.gdata.gom.core/GDataParseException#GDataParseException(Ljava.lang.String;Ljava.lang.Throwable;)"/>
-    </children>
-    <children xsi:type="editmodel:CompartmentEditModel"/>
-    <classifierPreferences xsi:type="editmodel:UMLClassDiagramClassifierPreference" showStereotype="true" showMethodsParameterTypes="true" showMethodsReturnType="true" showMethodsParameterNames="true" showMethodsParameterKinds="true" attributeSorter="Natural" methodSorter="Natural" innerClassSorter="Natural" showPrivateAttributes="true" showProtectedAttributes="true" showPublicAttributes="true" showPackageAttributes="true" showStaticAttributes="true" showProtectedMethods="true" showPublicMethods="true" showPackageMethods="true" showPrivateMethods="true" showStaticMethods="true" showProtectedInnerClasses="true" showPublicInnerClasses="true" showPackageInnerClasses="true" showPrivateInnerClasses="true" showStaticInnerClasses="true" showAssociationMember="true" showMethods="true" showAttributes="true" showLiterals="true"/>
-  </children>
-  <children xsi:type="editmodel:ClassEditModel" targetConnections="//@children.6/@sourceConnections.0" name="GOMFeedImpl" location="220,250" size="233,889" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl" runTimeClassModel="getId(),contributors,getTitle(),getLogo(),namespaces,getIcon(),setIcon(Lorg.apache.lucene.gdata.gom.GOMIcon;),id,logo,links,getNamespaces(),setTitle(Lorg.apache.lucene.gdata.gom.GOMTitle;),getLinks(),rights,entries,setSubtitle(Lorg.apache.lucene.gdata.gom.GOMSubtitle;),getChildren(),setLogo(Lorg.apache.lucene.gdata.gom.GOMLogo;),GOMFeedImpl(),getGenerator(),addCategory(Lorg.apache.lucene.gdata.gom.GOMCategory;),processEndElement(),processAttribute(Ljavax.xml.namespace.QName;Ljava.lang.String;),getContributor(),addAuthor(Lorg.apache.lucene.gdata.gom.GOMAuthor;),addEntry(Lorg.apache.lucene.gdata.gom.GOMEntry;),title,getRights(),categories,setId(Lorg.apache.lucene.gdata.gom.GOMId;),updated,setGenerator(Lorg.apache.lucene.gdata.gom.GOMGenerator;),addChild(Lorg.apache.lucene.gdata.gom.GOMElement;),getChildParser(Ljavax.xml.namespace.QName;),getAuthors(),icon,writeRssOutput(Ljavax.xml.stream.XMLStreamWriter;),setRights(Lorg.apache.lucene.gdata.gom.GOMRights;),writeAtomOutput(Ljavax.xml.stream.XMLStreamWriter;),addContributor(Lorg.apache.lucene.gdata.gom.GOMContributor;),addNamespace(Lorg.apache.lucene.gdata.gom.core.GOMNamespace;),processElementValue(Ljava.lang.String;),authors,getLocalName(),getUpdated(),getSubtitle(),setUpdated(Lorg.apache.lucene.gdata.gom.GOMTime;),generator,getEntries(),subtitle,getCategories()">
-    <children xsi:type="editmodel:CompartmentEditModel" size="109,144">
-      <children xsi:type="editmodel:AttributeEditModel" name="generator" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#generator"/>
-      <children xsi:type="editmodel:AttributeEditModel" name="icon" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#icon"/>
-      <children xsi:type="editmodel:AttributeEditModel" name="id" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#id"/>
-      <children xsi:type="editmodel:AttributeEditModel" name="logo" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#logo"/>
-      <children xsi:type="editmodel:AttributeEditModel" name="rights" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#rights"/>
-      <children xsi:type="editmodel:AttributeEditModel" name="subtitle" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#subtitle"/>
-      <children xsi:type="editmodel:AttributeEditModel" name="title" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#title"/>
-      <children xsi:type="editmodel:AttributeEditModel" name="updated" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#updated"/>
-    </children>
-    <children xsi:type="editmodel:CompartmentEditModel" size="210,666">
-      <children xsi:type="editmodel:MethodEditModel" name="GOMFeedImpl" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#GOMFeedImpl()"/>
-      <children xsi:type="editmodel:MethodEditModel" name="addAuthor" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#addAuthor(Lorg.apache.lucene.gdata.gom.GOMAuthor;)"/>
-      <children xsi:type="editmodel:MethodEditModel" name="addCategory" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#addCategory(Lorg.apache.lucene.gdata.gom.GOMCategory;)"/>
-      <children xsi:type="editmodel:MethodEditModel" name="addChild" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#addChild(Lorg.apache.lucene.gdata.gom.GOMElement;)"/>
-      <children xsi:type="editmodel:MethodEditModel" name="addContributor" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#addContributor(Lorg.apache.lucene.gdata.gom.GOMContributor;)"/>
-      <children xsi:type="editmodel:MethodEditModel" name="addEntry" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#addEntry(Lorg.apache.lucene.gdata.gom.GOMEntry;)"/>
-      <children xsi:type="editmodel:MethodEditModel" name="addNamespace" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#addNamespace(Lorg.apache.lucene.gdata.gom.core.GOMNamespace;)"/>
-      <children xsi:type="editmodel:MethodEditModel" name="getAuthors" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#getAuthors()"/>
-      <children xsi:type="editmodel:MethodEditModel" name="getCategories" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#getCategories()"/>
-      <children xsi:type="editmodel:MethodEditModel" name="getChildParser" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#getChildParser(Ljavax.xml.namespace.QName;)"/>
-      <children xsi:type="editmodel:MethodEditModel" name="getChildren" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#getChildren()"/>
-      <children xsi:type="editmodel:MethodEditModel" name="getContributor" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#getContributor()"/>
-      <children xsi:type="editmodel:MethodEditModel" name="getEntries" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#getEntries()"/>
-      <children xsi:type="editmodel:MethodEditModel" name="getGenerator" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#getGenerator()"/>
-      <children xsi:type="editmodel:MethodEditModel" name="getIcon" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#getIcon()"/>
-      <children xsi:type="editmodel:MethodEditModel" name="getId" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#getId()"/>
-      <children xsi:type="editmodel:MethodEditModel" name="getLinks" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#getLinks()"/>
-      <children xsi:type="editmodel:MethodEditModel" name="getLocalName" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#getLocalName()"/>
-      <children xsi:type="editmodel:MethodEditModel" name="getLogo" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#getLogo()"/>
-      <children xsi:type="editmodel:MethodEditModel" name="getNamespaces" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#getNamespaces()"/>
-      <children xsi:type="editmodel:MethodEditModel" name="getRights" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#getRights()"/>
-      <children xsi:type="editmodel:MethodEditModel" name="getSubtitle" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#getSubtitle()"/>
-      <children xsi:type="editmodel:MethodEditModel" name="getTitle" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#getTitle()"/>
-      <children xsi:type="editmodel:MethodEditModel" name="getUpdated" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#getUpdated()"/>
-      <children xsi:type="editmodel:MethodEditModel" name="processAttribute" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#processAttribute(Ljavax.xml.namespace.QName;Ljava.lang.String;)"/>
-      <children xsi:type="editmodel:MethodEditModel" name="processElementValue" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#processElementValue(Ljava.lang.String;)"/>
-      <children xsi:type="editmodel:MethodEditModel" name="processEndElement" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#processEndElement()"/>
-      <children xsi:type="editmodel:MethodEditModel" name="setGenerator" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#setGenerator(Lorg.apache.lucene.gdata.gom.GOMGenerator;)"/>
-      <children xsi:type="editmodel:MethodEditModel" name="setIcon" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#setIcon(Lorg.apache.lucene.gdata.gom.GOMIcon;)"/>
-      <children xsi:type="editmodel:MethodEditModel" name="setId" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#setId(Lorg.apache.lucene.gdata.gom.GOMId;)"/>
-      <children xsi:type="editmodel:MethodEditModel" name="setLogo" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#setLogo(Lorg.apache.lucene.gdata.gom.GOMLogo;)"/>
-      <children xsi:type="editmodel:MethodEditModel" name="setRights" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#setRights(Lorg.apache.lucene.gdata.gom.GOMRights;)"/>
-      <children xsi:type="editmodel:MethodEditModel" name="setSubtitle" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#setSubtitle(Lorg.apache.lucene.gdata.gom.GOMSubtitle;)"/>
-      <children xsi:type="editmodel:MethodEditModel" name="setTitle" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#setTitle(Lorg.apache.lucene.gdata.gom.GOMTitle;)"/>
-      <children xsi:type="editmodel:MethodEditModel" name="setUpdated" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#setUpdated(Lorg.apache.lucene.gdata.gom.GOMTime;)"/>
-      <children xsi:type="editmodel:MethodEditModel" name="writeAtomOutput" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#writeAtomOutput(Ljavax.xml.stream.XMLStreamWriter;)"/>
-      <children xsi:type="editmodel:MethodEditModel" name="writeRssOutput" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#writeRssOutput(Ljavax.xml.stream.XMLStreamWriter;)"/>
-    </children>
-    <children xsi:type="editmodel:CompartmentEditModel"/>
-    <sourceConnections xsi:type="editmodel:DependencyEditModel" autoLocated="true" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl->org.apache.lucene.gdata.gom.core/AtomParser" source="//@children.1" target="//@children.3" targetEnd="//@children.1/@sourceConnections.0/@children.2" label="//@children.1/@sourceConnections.0/@children.0" sourceEnd="//@children.1/@sourceConnections.0/@children.1" connectionRouterKind="Manhattan">
-      <children xsi:type="editmodel:WireLabelEditModel" name="import" size="29,10" fontInfo="Arial-8-0" anchorKind="MiddlePart"/>
-      <children xsi:type="editmodel:AssociationEndEditModel" location="233,34" attachSource="true"/>
-      <children xsi:type="editmodel:AssociationEndEditModel" location="0,234"/>
-    </sourceConnections>
-    <sourceConnections xsi:type="editmodel:DependencyEditModel" autoLocated="true" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl->org.apache.lucene.gdata.gom.core/GOMNamespace" source="//@children.1" target="//@children.6" targetEnd="//@children.1/@sourceConnections.1/@children.2" label="//@children.1/@sourceConnections.1/@children.0" sourceEnd="//@children.1/@sourceConnections.1/@children.1" connectionRouterKind="Manhattan">
-      <children xsi:type="editmodel:WireLabelEditModel" name="import" size="29,10" fontInfo="Arial-8-0" anchorKind="MiddlePart"/>
-      <children xsi:type="editmodel:AssociationEndEditModel" location="233,592" attachSource="true"/>
-      <children xsi:type="editmodel:AssociationEndEditModel" location="0,102"/>
-    </sourceConnections>
-    <sourceConnections xsi:type="editmodel:DependencyEditModel" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl->org.apache.lucene.gdata.gom.core/GOMAttributeImpl" source="//@children.1" target="//@children.7" targetEnd="//@children.1/@sourceConnections.2/@children.2" label="//@children.1/@sourceConnections.2/@children.0" sourceEnd="//@children.1/@sourceConnections.2/@children.1" connectionRouterKind="Manhattan">
-      <children xsi:type="editmodel:WireLabelEditModel" size="0,10" fontInfo="Arial-8-0" anchorKind="MiddlePart"/>
-      <children xsi:type="editmodel:AssociationEndEditModel" location="0,12" attachSource="true"/>
-      <children xsi:type="editmodel:AssociationEndEditModel" location="173,193"/>
-    </sourceConnections>
-    <sourceConnections xsi:type="editmodel:DependencyEditModel" autoLocated="true" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl->org.apache.lucene.gdata.gom.core/GOMAttributeImpl" source="//@children.1" target="//@children.7" targetEnd="//@children.1/@sourceConnections.3/@children.2" label="//@children.1/@sourceConnections.3/@children.0" sourceEnd="//@children.1/@sourceConnections.3/@children.1" connectionRouterKind="Manhattan">
-      <children xsi:type="editmodel:WireLabelEditModel" name="import" size="29,10" fontInfo="Arial-8-0" anchorKind="MiddlePart"/>
-      <children xsi:type="editmodel:AssociationEndEditModel" location="233,10" attachSource="true"/>
-      <children xsi:type="editmodel:AssociationEndEditModel" location="10,205"/>
-    </sourceConnections>
-    <classifierPreferences xsi:type="editmodel:UMLClassDiagramClassifierPreference" showStereotype="true" showMethodsParameterTypes="true" showMethodsReturnType="true" showMethodsParameterNames="true" showMethodsParameterKinds="true" attributeSorter="Natural" methodSorter="Natural" innerClassSorter="Natural" showPrivateAttributes="true" showProtectedAttributes="true" showPublicAttributes="true" showPackageAttributes="true" showStaticAttributes="true" showProtectedMethods="true" showPublicMethods="true" showPackageMethods="true" showPrivateMethods="true" showStaticMethods="true" showProtectedInnerClasses="true" showPublicInnerClasses="true" showPackageInnerClasses="true" showPrivateInnerClasses="true" showStaticInnerClasses="true" packageIndication="2" showAssociationMember="true" showMethods="true" showAttributes="true" showLiterals="true"/>
-  </children>
-  <children xsi:type="editmodel:ClassEditModel" targetConnections="//@children.5/@sourceConnections.2 //@children.5/@sourceConnections.4" name="GOMFactory" location="1873,241" size="147,133" id="org.apache.lucene.gdata.gom.core/GOMFactory" runTimeClassModel="createInstance(),createFeed(),GOMFactory()">
-    <children xsi:type="editmodel:CompartmentEditModel"/>
-    <children xsi:type="editmodel:CompartmentEditModel" size="124,54">
-      <children xsi:type="editmodel:MethodEditModel" name="GOMFactory" id="org.apache.lucene.gdata.gom.core/GOMFactory#GOMFactory()"/>
-      <children xsi:type="editmodel:MethodEditModel" name="createInstance" id="org.apache.lucene.gdata.gom.core/GOMFactory#createInstance()"/>
-      <children xsi:type="editmodel:MethodEditModel" name="createFeed" id="org.apache.lucene.gdata.gom.core/GOMFactory#createFeed()"/>
-    </children>
-    <children xsi:type="editmodel:CompartmentEditModel"/>
-    <classifierPreferences xsi:type="editmodel:UMLClassDiagramClassifierPreference" showStereotype="true" showMethodsParameterTypes="true" showMethodsReturnType="true" showMethodsParameterNames="true" showMethodsParameterKinds="true" attributeSorter="Natural" methodSorter="Natural" innerClassSorter="Natural" showPrivateAttributes="true" showProtectedAttributes="true" showPublicAttributes="true" showPackageAttributes="true" showStaticAttributes="true" showProtectedMethods="true" showPublicMethods="true" showPackageMethods="true" showPrivateMethods="true" showStaticMethods="true" showProtectedInnerClasses="true" showPublicInnerClasses="true" showPackageInnerClasses="true" showPrivateInnerClasses="true" showStaticInnerClasses="true" showAssociationMember="true" showMethods="true" showAttributes="true" showLiterals="true"/>
-  </children>
-  <children xsi:type="editmodel:InterfaceEditModel" targetConnections="//@children.5/@sourceConnections.0 //@children.1/@sourceConnections.0" name="AtomParser" location="1051,50" size="233,269" id="org.apache.lucene.gdata.gom.core/AtomParser" runTimeClassModel="uNEXPECTED_ATTRIBUTE,uNEXPECTED_ELEMENENT_VALUE,uNEXPECTED_ELEMENENT_CHILD,getChildParser(Ljavax.xml.namespace.QName;),uNEXPECTED_ELEMENENT,processEndElement(),mISSING_ELEMEMENT_CHILD,processElementValue(Ljava.lang.String;),processAttribute(Ljavax.xml.namespace.QName;Ljava.lang.String;),mISSING_ELEMEMENT_ATTRIBUTE">
-    <children xsi:type="editmodel:CompartmentEditModel" size="179,108">
-      <children xsi:type="editmodel:AttributeEditModel" name="uNEXPECTED_ELEMENENT" id="org.apache.lucene.gdata.gom.core/AtomParser#uNEXPECTED_ELEMENENT"/>
-      <children xsi:type="editmodel:AttributeEditModel" name="uNEXPECTED_ELEMENENT_CHILD" id="org.apache.lucene.gdata.gom.core/AtomParser#uNEXPECTED_ELEMENENT_CHILD"/>
-      <children xsi:type="editmodel:AttributeEditModel" name="uNEXPECTED_ATTRIBUTE" id="org.apache.lucene.gdata.gom.core/AtomParser#uNEXPECTED_ATTRIBUTE"/>
-      <children xsi:type="editmodel:AttributeEditModel" name="uNEXPECTED_ELEMENENT_VALUE" id="org.apache.lucene.gdata.gom.core/AtomParser#uNEXPECTED_ELEMENENT_VALUE"/>
-      <children xsi:type="editmodel:AttributeEditModel" name="mISSING_ELEMEMENT_ATTRIBUTE" id="org.apache.lucene.gdata.gom.core/AtomParser#mISSING_ELEMEMENT_ATTRIBUTE"/>
-      <children xsi:type="editmodel:AttributeEditModel" name="mISSING_ELEMEMENT_CHILD" id="org.apache.lucene.gdata.gom.core/AtomParser#mISSING_ELEMEMENT_CHILD"/>
-    </children>
-    <children xsi:type="editmodel:CompartmentEditModel" size="210,72">
-      <children xsi:type="editmodel:MethodEditModel" name="processElementValue" id="org.apache.lucene.gdata.gom.core/AtomParser#processElementValue(Ljava.lang.String;)"/>
-      <children xsi:type="editmodel:MethodEditModel" name="processAttribute" id="org.apache.lucene.gdata.gom.core/AtomParser#processAttribute(Ljavax.xml.namespace.QName;Ljava.lang.String;)"/>
-      <children xsi:type="editmodel:MethodEditModel" name="processEndElement" id="org.apache.lucene.gdata.gom.core/AtomParser#processEndElement()"/>
-      <children xsi:type="editmodel:MethodEditModel" name="getChildParser" id="org.apache.lucene.gdata.gom.core/AtomParser#getChildParser(Ljavax.xml.namespace.QName;)"/>
-    </children>
-    <children xsi:type="editmodel:CompartmentEditModel"/>
-    <sourceConnections xsi:type="editmodel:AssociationEditModel" autoLocated="true" id="org.apache.lucene.gdata.gom.core/AtomParser@parserStack+org.apache.lucene.gdata.gom.core/GOMBuilder@" source="//@children.3" target="//@children.5" targetEnd="//@children.3/@sourceConnections.0/@children.2" label="//@children.3/@sourceConnections.0/@children.0" sourceEnd="//@children.3/@sourceConnections.0/@children.1" connectionRouterKind="Manhattan">
-      <children xsi:type="editmodel:WireLabelEditModel" size="0,10" fontInfo="Arial-8-0" anchorKind="MiddlePart"/>
-      <children xsi:type="editmodel:AssociationEndEditModel" name="parserStack" location="233,259" id="org.apache.lucene.gdata.gom.core/AtomParser@parserStack+org.apache.lucene.gdata.gom.core/GOMBuilder@|org.apache.lucene.gdata.gom.core/AtomParser#parserStack" attachSource="true" multiplicityLabel="//@children.3/@sourceConnections.0/@children.1/@children.1" roleLabel="//@children.3/@sourceConnections.0/@children.1/@children.0" navigable="true">
-        <children xsi:type="editmodel:LabelEditModel" name=" - parserStack" location="1291,291" size="47,10" fontInfo="Arial-8-0" anchorKind="FirstPart"/>
-        <children xsi:type="editmodel:LabelEditModel" name="*" location="1291,315" size="3,10" fontInfo="Arial-8-0" anchorKind="FirstPart"/>
-      </children>
-      <children xsi:type="editmodel:AssociationEndEditModel" location="10,0" id="org.apache.lucene.gdata.gom.core/AtomParser@parserStack+org.apache.lucene.gdata.gom.core/GOMBuilder@|org.apache.lucene.gdata.gom.core/GOMBuilder#" roleLabel="//@children.3/@sourceConnections.0/@children.2/@children.0">
-        <children xsi:type="editmodel:LabelEditModel" location="1391,481" size="0,10" fontInfo="Arial-8-0" anchorKind="LastPart"/>
-      </children>
-    </sourceConnections>
-    <classifierPreferences xsi:type="editmodel:UMLClassDiagramClassifierPreference" showStereotype="true" showMethodsParameterTypes="true" showMethodsReturnType="true" showMethodsParameterNames="true" showMethodsParameterKinds="true" attributeSorter="Natural" methodSorter="Natural" innerClassSorter="Natural" showPrivateAttributes="true" showProtectedAttributes="true" showPublicAttributes="true" showPackageAttributes="true" showStaticAttributes="true" showProtectedMethods="true" showPublicMethods="true" showPackageMethods="true" showPrivateMethods="true" showStaticMethods="true" showProtectedInnerClasses="true" showPublicInnerClasses="true" showPackageInnerClasses="true" showPrivateInnerClasses="true" showStaticInnerClasses="true" showAssociationMember="true" showMethods="true" showAttributes="true" showLiterals="true"/>
-  </children>
-  <children xsi:type="editmodel:ClassEditModel" targetConnections="//@children.5/@sourceConnections.3 //@children.5/@sourceConnections.6 //@children.5/@sourceConnections.8" name="GOMDocumentImpl" location="1623,994" size="227,295" id="org.apache.lucene.gdata.gom.core/GOMDocumentImpl" runTimeClassModel="setCharacterEncoding(Ljava.lang.String;),charEncoding,GOMDocumentImpl(),setVersion(Ljava.lang.String;),getCharacterEncoding(),writeRssOutput(Ljavax.xml.stream.XMLStreamWriter;),root,getRootElement(),getVersion(),writeAtomOutput(Ljavax.xml.stream.XMLStreamWriter;),setRootElement,version">
-    <children xsi:type="editmodel:CompartmentEditModel" size="91,54">
-      <children xsi:type="editmodel:AttributeEditModel" name="root" id="org.apache.lucene.gdata.gom.core/GOMDocumentImpl#root"/>
-      <children xsi:type="editmodel:AttributeEditModel" name="version" id="org.apache.lucene.gdata.gom.core/GOMDocumentImpl#version"/>
-      <children xsi:type="editmodel:AttributeEditModel" name="charEncoding" id="org.apache.lucene.gdata.gom.core/GOMDocumentImpl#charEncoding"/>
-    </children>
-    <children xsi:type="editmodel:CompartmentEditModel" size="204,162">
-      <children xsi:type="editmodel:MethodEditModel" name="GOMDocumentImpl" id="org.apache.lucene.gdata.gom.core/GOMDocumentImpl#GOMDocumentImpl()"/>
-      <children xsi:type="editmodel:MethodEditModel" name="getRootElement" id="org.apache.lucene.gdata.gom.core/GOMDocumentImpl#getRootElement()"/>
-      <children xsi:type="editmodel:MethodEditModel" name="setVersion" id="org.apache.lucene.gdata.gom.core/GOMDocumentImpl#setVersion(Ljava.lang.String;)"/>
-      <children xsi:type="editmodel:MethodEditModel" name="getVersion" id="org.apache.lucene.gdata.gom.core/GOMDocumentImpl#getVersion()"/>
-      <children xsi:type="editmodel:MethodEditModel" name="getCharacterEncoding" id="org.apache.lucene.gdata.gom.core/GOMDocumentImpl#getCharacterEncoding()"/>
-      <children xsi:type="editmodel:MethodEditModel" name="setCharacterEncoding" id="org.apache.lucene.gdata.gom.core/GOMDocumentImpl#setCharacterEncoding(Ljava.lang.String;)"/>
-      <children xsi:type="editmodel:MethodEditModel" name="writeAtomOutput" id="org.apache.lucene.gdata.gom.core/GOMDocumentImpl#writeAtomOutput(Ljavax.xml.stream.XMLStreamWriter;)"/>
-      <children xsi:type="editmodel:MethodEditModel" name="setRootElement" id="org.apache.lucene.gdata.gom.core/GOMDocumentImpl#setRootElement"/>
-      <children xsi:type="editmodel:MethodEditModel" name="writeRssOutput" id="org.apache.lucene.gdata.gom.core/GOMDocumentImpl#writeRssOutput(Ljavax.xml.stream.XMLStreamWriter;)"/>
-    </children>
-    <children xsi:type="editmodel:CompartmentEditModel"/>
-    <classifierPreferences xsi:type="editmodel:UMLClassDiagramClassifierPreference" showStereotype="true" showMethodsParameterTypes="true" showMethodsReturnType="true" showMethodsParameterNames="true" showMethodsParameterKinds="true" attributeSorter="Natural" methodSorter="Natural" innerClassSorter="Natural" showPrivateAttributes="true" showProtectedAttributes="true" showPublicAttributes="true" showPackageAttributes="true" showStaticAttributes="true" showProtectedMethods="true" showPublicMethods="true" showPackageMethods="true" showPrivateMethods="true" showStaticMethods="true" showProtectedInnerClasses="true" showPublicInnerClasses="true" showPackageInnerClasses="true" showPrivateInnerClasses="true" showStaticInnerClasses="true" showAssociationMember="true" showMethods="true" showAttributes="true" showLiterals="true"/>
-  </children>
-  <children xsi:type="editmodel:ClassEditModel" targetConnections="//@children.3/@sourceConnections.0" name="GOMBuilder" location="1388,498" size="259,295" id="org.apache.lucene.gdata.gom.core/GOMBuilder" runTimeClassModel="parserStack,next(),processAttributes(Lorg.apache.lucene.gdata.gom.core.AtomParser;),buildGOMEntry(),lastLocalName,streamReader,parse(Ljavax.xml.stream.XMLStreamReader;),buildGOMFeed(),GOMBuilder(Ljavax.xml.stream.XMLStreamReader;),startFeedDocument(Lorg.apache.lucene.gdata.gom.GOMDocument;),factory">
-    <children xsi:type="editmodel:CompartmentEditModel" size="136,54">
-      <children xsi:type="editmodel:AttributeEditModel" name="streamReader" id="org.apache.lucene.gdata.gom.core/GOMBuilder#streamReader"/>
-      <children xsi:type="editmodel:AttributeEditModel" name="factory" id="org.apache.lucene.gdata.gom.core/GOMBuilder#factory"/>
-      <children xsi:type="editmodel:AttributeEditModel" name="lastLocalName" id="org.apache.lucene.gdata.gom.core/GOMBuilder#lastLocalName"/>
-      <children xsi:type="editmodel:AttributeEditModel" name="parserStack" id="org.apache.lucene.gdata.gom.core/AtomParser@parserStack+org.apache.lucene.gdata.gom.core/GOMBuilder@|org.apache.lucene.gdata.gom.core/AtomParser#parserStack"/>
-    </children>
-    <children xsi:type="editmodel:CompartmentEditModel" size="236,126">
-      <children xsi:type="editmodel:MethodEditModel" name="GOMBuilder" id="org.apache.lucene.gdata.gom.core/GOMBuilder#GOMBuilder(Ljavax.xml.stream.XMLStreamReader;)"/>
-      <children xsi:type="editmodel:MethodEditModel" name="buildGOMFeed" id="org.apache.lucene.gdata.gom.core/GOMBuilder#buildGOMFeed()"/>
-      <children xsi:type="editmodel:MethodEditModel" name="parse" id="org.apache.lucene.gdata.gom.core/GOMBuilder#parse(Ljavax.xml.stream.XMLStreamReader;)"/>
-      <children xsi:type="editmodel:MethodEditModel" name="processAttributes" id="org.apache.lucene.gdata.gom.core/GOMBuilder#processAttributes(Lorg.apache.lucene.gdata.gom.core.AtomParser;)"/>
-      <children xsi:type="editmodel:MethodEditModel" name="buildGOMEntry" id="org.apache.lucene.gdata.gom.core/GOMBuilder#buildGOMEntry()"/>
-      <children xsi:type="editmodel:MethodEditModel" name="startFeedDocument" id="org.apache.lucene.gdata.gom.core/GOMBuilder#startFeedDocument(Lorg.apache.lucene.gdata.gom.GOMDocument;)"/>
-      <children xsi:type="editmodel:MethodEditModel" name="next" id="org.apache.lucene.gdata.gom.core/GOMBuilder#next()"/>
-    </children>
-    <children xsi:type="editmodel:CompartmentEditModel"/>
-    <sourceConnections xsi:type="editmodel:DependencyEditModel" id="org.apache.lucene.gdata.gom.core/GOMBuilder->org.apache.lucene.gdata.gom.core/AtomParser" source="//@children.5" target="//@children.3" targetEnd="//@children.5/@sourceConnections.0/@children.2" label="//@children.5/@sourceConnections.0/@children.0" sourceEnd="//@children.5/@sourceConnections.0/@children.1" connectionRouterKind="Manhattan">
-      <children xsi:type="editmodel:WireLabelEditModel" name="import" size="29,10" fontInfo="Arial-8-0" anchorKind="MiddlePart"/>
-      <children xsi:type="editmodel:AssociationEndEditModel" location="0,20" attachSource="true"/>
-      <children xsi:type="editmodel:AssociationEndEditModel" location="213,269"/>
-    </sourceConnections>
-    <sourceConnections xsi:type="editmodel:DependencyEditModel" id="org.apache.lucene.gdata.gom.core/GOMBuilder->org.apache.lucene.gdata.gom.core/GOMNamespace" source="//@children.5" target="//@children.6" targetEnd="//@children.5/@sourceConnections.1/@children.2" label="//@children.5/@sourceConnections.1/@children.0" sourceEnd="//@children.5/@sourceConnections.1/@children.1" connectionRouterKind="Manhattan">
-      <children xsi:type="editmodel:WireLabelEditModel" size="0,10" fontInfo="Arial-8-0" anchorKind="MiddlePart"/>
-      <children xsi:type="editmodel:AssociationEndEditModel" location="0,236" attachSource="true"/>
-      <children xsi:type="editmodel:AssociationEndEditModel" location="135,58"/>
-    </sourceConnections>
-    <sourceConnections xsi:type="editmodel:DependencyEditModel" autoLocated="true" id="org.apache.lucene.gdata.gom.core/GOMBuilder->org.apache.lucene.gdata.gom.core/GOMFactory" source="//@children.5" target="//@children.2" targetEnd="//@children.5/@sourceConnections.2/@children.2" label="//@children.5/@sourceConnections.2/@children.0" sourceEnd="//@children.5/@sourceConnections.2/@children.1" connectionRouterKind="Manhattan">
-      <children xsi:type="editmodel:WireLabelEditModel" name="access" size="32,10" fontInfo="Arial-8-0" anchorKind="MiddlePart"/>
-      <children xsi:type="editmodel:AssociationEndEditModel" location="249,0" attachSource="true"/>
-      <children xsi:type="editmodel:AssociationEndEditModel" location="0,123"/>
-    </sourceConnections>
-    <sourceConnections xsi:type="editmodel:DependencyEditModel" id="org.apache.lucene.gdata.gom.core/GOMBuilder->org.apache.lucene.gdata.gom.core/GOMDocumentImpl" source="//@children.5" target="//@children.4" targetEnd="//@children.5/@sourceConnections.3/@children.2" label="//@children.5/@sourceConnections.3/@children.0" sourceEnd="//@children.5/@sourceConnections.3/@children.1" connectionRouterKind="Manhattan">
-      <children xsi:type="editmodel:WireLabelEditModel" size="0,10" fontInfo="Arial-8-0" anchorKind="MiddlePart"/>
-      <children xsi:type="editmodel:AssociationEndEditModel" location="256,295" attachSource="true"/>
-      <children xsi:type="editmodel:AssociationEndEditModel" location="21,0"/>
-    </sourceConnections>
-    <sourceConnections xsi:type="editmodel:DependencyEditModel" id="org.apache.lucene.gdata.gom.core/GOMBuilder->org.apache.lucene.gdata.gom.core/GOMFactory" source="//@children.5" target="//@children.2" targetEnd="//@children.5/@sourceConnections.4/@children.2" label="//@children.5/@sourceConnections.4/@children.0" sourceEnd="//@children.5/@sourceConnections.4/@children.1" connectionRouterKind="Manhattan">
-      <children xsi:type="editmodel:WireLabelEditModel" name="import" size="29,10" fontInfo="Arial-8-0" anchorKind="MiddlePart"/>
-      <children xsi:type="editmodel:AssociationEndEditModel" location="258,0" attachSource="true"/>
-      <children xsi:type="editmodel:AssociationEndEditModel" location="10,143"/>
-    </sourceConnections>
-    <sourceConnections xsi:type="editmodel:DependencyEditModel" id="org.apache.lucene.gdata.gom.core/GOMBuilder->org.apache.lucene.gdata.gom.core/GOMNamespace" source="//@children.5" target="//@children.6" targetEnd="//@children.5/@sourceConnections.5/@children.2" label="//@children.5/@sourceConnections.5/@children.0" sourceEnd="//@children.5/@sourceConnections.5/@children.1" connectionRouterKind="Manhattan">
-      <children xsi:type="editmodel:WireLabelEditModel" name="import" size="29,10" fontInfo="Arial-8-0" anchorKind="MiddlePart"/>
-      <children xsi:type="editmodel:AssociationEndEditModel" location="0,216" attachSource="true"/>
-      <children xsi:type="editmodel:AssociationEndEditModel" location="135,78"/>
-    </sourceConnections>
-    <sourceConnections xsi:type="editmodel:DependencyEditModel" id="org.apache.lucene.gdata.gom.core/GOMBuilder->org.apache.lucene.gdata.gom.core/GOMDocumentImpl" source="//@children.5" target="//@children.4" targetEnd="//@children.5/@sourceConnections.6/@children.2" label="//@children.5/@sourceConnections.6/@children.0" sourceEnd="//@children.5/@sourceConnections.6/@children.1" connectionRouterKind="Manhattan">
-      <children xsi:type="editmodel:WireLabelEditModel" size="0,10" fontInfo="Arial-8-0" anchorKind="MiddlePart"/>
-      <children xsi:type="editmodel:AssociationEndEditModel" location="236,295" attachSource="true"/>
-      <children xsi:type="editmodel:AssociationEndEditModel" location="1,0"/>
-    </sourceConnections>
-    <sourceConnections xsi:type="editmodel:DependencyEditModel" autoLocated="true" id="org.apache.lucene.gdata.gom.core/GOMBuilder->org.apache.lucene.gdata.gom.core/GOMNamespace" source="//@children.5" target="//@children.6" targetEnd="//@children.5/@sourceConnections.7/@children.2" label="//@children.5/@sourceConnections.7/@children.0" sourceEnd="//@children.5/@sourceConnections.7/@children.1" connectionRouterKind="Manhattan">
-      <children xsi:type="editmodel:WireLabelEditModel" size="0,10" fontInfo="Arial-8-0" anchorKind="MiddlePart"/>
-      <children xsi:type="editmodel:AssociationEndEditModel" location="0,268" attachSource="true"/>
-      <children xsi:type="editmodel:AssociationEndEditModel" location="135,26"/>
-    </sourceConnections>
-    <sourceConnections xsi:type="editmodel:DependencyEditModel" autoLocated="true" id="org.apache.lucene.gdata.gom.core/GOMBuilder->org.apache.lucene.gdata.gom.core/GOMDocumentImpl" source="//@children.5" target="//@children.4" targetEnd="//@children.5/@sourceConnections.8/@children.2" label="//@children.5/@sourceConnections.8/@children.0" sourceEnd="//@children.5/@sourceConnections.8/@children.1" connectionRouterKind="Manhattan">
-      <children xsi:type="editmodel:WireLabelEditModel" size="0,10" fontInfo="Arial-8-0" anchorKind="MiddlePart"/>
-      <children xsi:type="editmodel:AssociationEndEditModel" location="246,295" attachSource="true"/>
-      <children xsi:type="editmodel:AssociationEndEditModel" location="11,0"/>
-    </sourceConnections>
-    <sourceConnections xsi:type="editmodel:DependencyEditModel" id="org.apache.lucene.gdata.gom.core/GOMBuilder->org.apache.lucene.gdata.gom.core/GOMNamespace" source="//@children.5" target="//@children.6" targetEnd="//@children.5/@sourceConnections.9/@children.2" label="//@children.5/@sourceConnections.9/@children.0" sourceEnd="//@children.5/@sourceConnections.9/@children.1" connectionRouterKind="Manhattan">
-      <children xsi:type="editmodel:WireLabelEditModel" size="0,10" fontInfo="Arial-8-0" anchorKind="MiddlePart"/>
-      <children xsi:type="editmodel:AssociationEndEditModel" location="0,246" attachSource="true"/>
-      <children xsi:type="editmodel:AssociationEndEditModel" location="135,48"/>
-    </sourceConnections>
-    <classifierPreferences xsi:type="editmodel:UMLClassDiagramClassifierPreference" showStereotype="true" showMethodsParameterTypes="true" showMethodsReturnType="true" showMethodsParameterNames="true" showMethodsParameterKinds="true" attributeSorter="Natural" methodSorter="Natural" innerClassSorter="Natural" showPrivateAttributes="true" showProtectedAttributes="true" showPublicAttributes="true" showPackageAttributes="true" showStaticAttributes="true" showProtectedMethods="true" showPublicMethods="true" showPackageMethods="true" showPrivateMethods="true" showStaticMethods="true" showProtectedInnerClasses="true" showPublicInnerClasses="true" showPackageInnerClasses="true" showPrivateInnerClasses="true" showStaticInnerClasses="true" showAssociationMember="true" showMethods="true" showAttributes="true" showLiterals="true"/>
-  </children>
-  <children xsi:type="editmodel:ClassEditModel" targetConnections="//@children.5/@sourceConnections.1 //@children.5/@sourceConnections.5 //@children.1/@sourceConnections.1 //@children.5/@sourceConnections.7 //@children.5/@sourceConnections.9" name="GOMNamespace" location="590,740" size="135,205" id="org.apache.lucene.gdata.gom.core/GOMNamespace" runTimeClassModel="setUri(Ljava.lang.String;),GOMNamespace(),getUri(),getPrefix(),uri,prefix,setPrefix(Ljava.lang.String;)">
-    <children xsi:type="editmodel:CompartmentEditModel" size="62,36">
-      <children xsi:type="editmodel:AttributeEditModel" name="prefix" id="org.apache.lucene.gdata.gom.core/GOMNamespace#prefix"/>
-      <children xsi:type="editmodel:AttributeEditModel" name="uri" id="org.apache.lucene.gdata.gom.core/GOMNamespace#uri"/>
-    </children>
-    <children xsi:type="editmodel:CompartmentEditModel" size="112,90">
-      <children xsi:type="editmodel:MethodEditModel" name="GOMNamespace" id="org.apache.lucene.gdata.gom.core/GOMNamespace#GOMNamespace()"/>
-      <children xsi:type="editmodel:MethodEditModel" name="getPrefix" id="org.apache.lucene.gdata.gom.core/GOMNamespace#getPrefix()"/>
-      <children xsi:type="editmodel:MethodEditModel" name="setPrefix" id="org.apache.lucene.gdata.gom.core/GOMNamespace#setPrefix(Ljava.lang.String;)"/>
-      <children xsi:type="editmodel:MethodEditModel" name="getUri" id="org.apache.lucene.gdata.gom.core/GOMNamespace#getUri()"/>
-      <children xsi:type="editmodel:MethodEditModel" name="setUri" id="org.apache.lucene.gdata.gom.core/GOMNamespace#setUri(Ljava.lang.String;)"/>
-    </children>
-    <children xsi:type="editmodel:CompartmentEditModel"/>
-    <sourceConnections xsi:type="editmodel:AssociationEditModel" id="org.apache.lucene.gdata.gom.core/GOMNamespace@namespaces+org.apache.lucene.gdata.gom.core/GOMFeedImpl@" source="//@children.6" target="//@children.1" targetEnd="//@children.6/@sourceConnections.0/@children.2" label="//@children.6/@sourceConnections.0/@children.0" sourceEnd="//@children.6/@sourceConnections.0/@children.1" connectionRouterKind="Manhattan">
-      <children xsi:type="editmodel:WireLabelEditModel" size="0,10" fontInfo="Arial-8-0" anchorKind="MiddlePart"/>
-      <children xsi:type="editmodel:AssociationEndEditModel" name="namespaces" location="0,112" id="org.apache.lucene.gdata.gom.core/GOMNamespace@namespaces+org.apache.lucene.gdata.gom.core/GOMFeedImpl@|org.apache.lucene.gdata.gom.core/GOMNamespace#namespaces" attachSource="true" multiplicityLabel="//@children.6/@sourceConnections.0/@children.1/@children.1" roleLabel="//@children.6/@sourceConnections.0/@children.1/@children.0" navigable="true">
-        <children xsi:type="editmodel:LabelEditModel" name=" - namespaces" location="534,859" size="49,10" fontInfo="Arial-8-0" anchorKind="FirstPart"/>
-        <children xsi:type="editmodel:LabelEditModel" name="*" location="580,835" size="3,10" fontInfo="Arial-8-0" anchorKind="FirstPart"/>
-      </children>
-      <children xsi:type="editmodel:AssociationEndEditModel" location="233,532" id="org.apache.lucene.gdata.gom.core/GOMNamespace@namespaces+org.apache.lucene.gdata.gom.core/GOMFeedImpl@|org.apache.lucene.gdata.gom.core/GOMFeedImpl#"/>
-    </sourceConnections>
-    <classifierPreferences xsi:type="editmodel:UMLClassDiagramClassifierPreference" showStereotype="true" showMethodsParameterTypes="true" showMethodsReturnType="true" showMethodsParameterNames="true" showMethodsParameterKinds="true" attributeSorter="Natural" methodSorter="Natural" innerClassSorter="Natural" showPrivateAttributes="true" showProtectedAttributes="true" showPublicAttributes="true" showPackageAttributes="true" showStaticAttributes="true" showProtectedMethods="true" showPublicMethods="true" showPackageMethods="true" showPrivateMethods="true" showStaticMethods="true" showProtectedInnerClasses="true" showPublicInnerClasses="true" showPackageInnerClasses="true" showPrivateInnerClasses="true" showStaticInnerClasses="true" showAssociationMember="true" showMethods="true" showAttributes="true" showLiterals="true"/>
-  </children>
-  <children xsi:type="editmodel:ClassEditModel" targetConnections="//@children.1/@sourceConnections.2 //@children.1/@sourceConnections.3" name="GOMAttributeImpl" location="640,-20" size="173,205" id="org.apache.lucene.gdata.gom.core/GOMAttributeImpl" runTimeClassModel="GOMAttributeImpl(),setLocalName(Ljava.lang.String;),setTextValue(Ljava.lang.String;),setQName(Ljavax.xml.namespace.QName;),getQname(),getTextValue(),getLocalName()">
-    <children xsi:type="editmodel:CompartmentEditModel"/>
-    <children xsi:type="editmodel:CompartmentEditModel" size="150,126">
-      <children xsi:type="editmodel:MethodEditModel" name="GOMAttributeImpl" id="org.apache.lucene.gdata.gom.core/GOMAttributeImpl#GOMAttributeImpl()"/>
-      <children xsi:type="editmodel:MethodEditModel" name="getQname" id="org.apache.lucene.gdata.gom.core/GOMAttributeImpl#getQname()"/>
-      <children xsi:type="editmodel:MethodEditModel" name="setQName" id="org.apache.lucene.gdata.gom.core/GOMAttributeImpl#setQName(Ljavax.xml.namespace.QName;)"/>
-      <children xsi:type="editmodel:MethodEditModel" name="setLocalName" id="org.apache.lucene.gdata.gom.core/GOMAttributeImpl#setLocalName(Ljava.lang.String;)"/>
-      <children xsi:type="editmodel:MethodEditModel" name="getLocalName" id="org.apache.lucene.gdata.gom.core/GOMAttributeImpl#getLocalName()"/>
-      <children xsi:type="editmodel:MethodEditModel" name="getTextValue" id="org.apache.lucene.gdata.gom.core/GOMAttributeImpl#getTextValue()"/>
-      <children xsi:type="editmodel:MethodEditModel" name="setTextValue" id="org.apache.lucene.gdata.gom.core/GOMAttributeImpl#setTextValue(Ljava.lang.String;)"/>
-    </children>
-    <children xsi:type="editmodel:CompartmentEditModel"/>
-    <classifierPreferences xsi:type="editmodel:UMLClassDiagramClassifierPreference" showStereotype="true" showMethodsParameterTypes="true" showMethodsReturnType="true" showMethodsParameterNames="true" showMethodsParameterKinds="true" attributeSorter="Natural" methodSorter="Natural" innerClassSorter="Natural" showPrivateAttributes="true" showProtectedAttributes="true" showPublicAttributes="true" showPackageAttributes="true" showStaticAttributes="true" showProtectedMethods="true" showPublicMethods="true" showPackageMethods="true" showPrivateMethods="true" showStaticMethods="true" showProtectedInnerClasses="true" showPublicInnerClasses="true" showPackageInnerClasses="true" showPrivateInnerClasses="true" showStaticInnerClasses="true" showAssociationMember="true" showMethods="true" showAttributes="true" showLiterals="true"/>
-  </children>
-  <diagramOptions xsi:type="options:ClassDiagramOptions" properties="wireOptions=0"/>
-  <boardSetting snapToGeometry="true" gridEnabled="true" gridSpacing="10,10" gridOrigin="0,0" rulerUnit="pixel">
-    <leftRuler/>
-    <topRuler/>
-  </boardSetting>
-  <classDiagramPreferences xsi:type="editmodel:UMLClassDiagramPreference" showMethodsParameterTypes="true" showMethodsReturnType="true" showMethodsParameterNames="true" showMethodsParameterKinds="true" attributeSorter="Natural" methodSorter="Natural" showClassStereotype="true" showPackageStereotype="true" innerClassSorter="Natural" showPrivateAttributes="true" showProtectedAttributes="true" showPublicAttributes="true" showPackageAttributes="true" showStaticAttributes="true" showProtectedMethods="true" showPublicMethods="true" showPackageMethods="true" showPrivateMethods="true" showStaticMethods="true" showProtectedInnerClasses="true" showPublicInnerClasses="true" showPackageInnerClasses="true" showPrivateInnerClasses="true" showStaticInnerClasses="true" packageIndication="2" showInterfaceStereotype="true" showAssociationMember="true" showMethods="true" showAttributes="true" showLiterlas="true"/>
-</editmodel:ClassDiagramEditModel>
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/core-aid.uml b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/core-aid.uml
deleted file mode 100644
index 7bce9e6..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/core-aid.uml
+++ /dev/null
@@ -1,968 +0,0 @@
-<?xml version="1.0" encoding="ASCII"?>
-<uml:Model xmi:version="2.1" xmlns:xmi="http://schema.omg.org/spec/XMI/2.1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:uml="http://www.eclipse.org/uml2/2.0.0/UML" xmi:id="_B7TvIH5gEdujQd6ed5A7Ug" name="core">
-  <packagedElement xmi:type="uml:Interface" xmi:id="_r7Q00H5eEdujQd6ed5A7Ug" name="AtomParser" clientDependency="_r7sSoH5eEdujQd6ed5A7Ug _r7uu4X5eEdujQd6ed5A7Ug">
-    <ownedAttribute xmi:id="_r7dCEH5eEdujQd6ed5A7Ug" name="uNEXPECTED_ELEMENENT_VALUE" visibility="public" isLeaf="true" isStatic="true" type="_r7dpIX5eEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_r7lk8H5eEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_r7k94X5eEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedAttribute xmi:id="_r7eQMH5eEdujQd6ed5A7Ug" name="uNEXPECTED_ATTRIBUTE" visibility="public" isLeaf="true" isStatic="true" type="_r7dpIX5eEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_r7pPUX5eEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_r7pPUH5eEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedAttribute xmi:id="_r7e3QH5eEdujQd6ed5A7Ug" name="uNEXPECTED_ELEMENENT_CHILD" visibility="public" isLeaf="true" isStatic="true" type="_r7dpIX5eEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_r7p2YH5eEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_r7pPUn5eEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedAttribute xmi:id="_r7e3QX5eEdujQd6ed5A7Ug" name="uNEXPECTED_ELEMENENT" visibility="public" isLeaf="true" isStatic="true" type="_r7dpIX5eEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_r7p2Yn5eEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_r7p2YX5eEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedAttribute xmi:id="_r7feUH5eEdujQd6ed5A7Ug" name="mISSING_ELEMEMENT_CHILD" visibility="public" isLeaf="true" isStatic="true" type="_r7dpIX5eEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_r7qdcH5eEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_r7p2Y35eEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedAttribute xmi:id="_r7gFYH5eEdujQd6ed5A7Ug" name="mISSING_ELEMEMENT_ATTRIBUTE" visibility="public" isLeaf="true" isStatic="true" type="_r7dpIX5eEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_r7qdcn5eEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_r7qdcX5eEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedOperation xmi:id="_r7gscH5eEdujQd6ed5A7Ug" name="processAttribute" visibility="public" isAbstract="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_-KrWIH5fEdujQd6ed5A7Ug" name="aQName" type="_r7h6kH5eEdujQd6ed5A7Ug"/>
-      <ownedParameter xmi:id="_-KrWIX5fEdujQd6ed5A7Ug" name="aValue" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_r7jIsH5eEdujQd6ed5A7Ug" name="getChildParser" visibility="public" isAbstract="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_-Kr9MH5fEdujQd6ed5A7Ug" name="name" type="_r7h6kH5eEdujQd6ed5A7Ug"/>
-      <ownedParameter xmi:id="_-KskQH5fEdujQd6ed5A7Ug" type="_r7Q00H5eEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_r7jvwX5eEdujQd6ed5A7Ug" name="processEndElement" visibility="public" isAbstract="true" concurrency="concurrent"/>
-    <ownedOperation xmi:id="_r7kW0H5eEdujQd6ed5A7Ug" name="processElementValue" visibility="public" isAbstract="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_-KtLUH5fEdujQd6ed5A7Ug" name="aValue" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Class" xmi:id="_r7h6kH5eEdujQd6ed5A7Ug" name="QName"/>
-  <packagedElement xmi:type="uml:Class" xmi:id="_r8CQ4H5eEdujQd6ed5A7Ug" name="GOMNamespace" clientDependency="_r8qjAH5eEdujQd6ed5A7Ug">
-    <ownedAttribute xmi:id="_r8kcYH5eEdujQd6ed5A7Ug" name="uri" visibility="private" type="_r7dpIX5eEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_r8ot0X5eEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_r8ot0H5eEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedAttribute xmi:id="_r8lDcH5eEdujQd6ed5A7Ug" name="prefix" visibility="private" type="_r7dpIX5eEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_r8pU4X5eEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_r8pU4H5eEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedOperation xmi:id="_r8lqgH5eEdujQd6ed5A7Ug" name="setUri" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_r8mRkH5eEdujQd6ed5A7Ug" name="aUri" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_r8mRkX5eEdujQd6ed5A7Ug" name="getPrefix" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_r8m4oH5eEdujQd6ed5A7Ug" type="_r7dpIX5eEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_r8m4oX5eEdujQd6ed5A7Ug" name="setPrefix" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_r8nfsH5eEdujQd6ed5A7Ug" name="aPrefix" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_r8nfsX5eEdujQd6ed5A7Ug" name="getUri" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_r8oGwH5eEdujQd6ed5A7Ug" type="_r7dpIX5eEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_r8oGwX5eEdujQd6ed5A7Ug" name="GOMNamespace" visibility="public" concurrency="concurrent"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Class" xmi:id="_r8824H5eEdujQd6ed5A7Ug" name="GDataParseException" clientDependency="_r9GA0H5eEdujQd6ed5A7Ug _r9IdEn5eEdujQd6ed5A7Ug">
-    <generalization xmi:id="_r8-FAH5eEdujQd6ed5A7Ug" general="_r89d8H5eEdujQd6ed5A7Ug"/>
-    <ownedOperation xmi:id="_r9AhQH5eEdujQd6ed5A7Ug" name="GDataParseException" visibility="public" concurrency="concurrent"/>
-    <ownedOperation xmi:id="_r9BIUH5eEdujQd6ed5A7Ug" name="GDataParseException" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_r9CWcH5eEdujQd6ed5A7Ug" name="arg0" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_r9CWcX5eEdujQd6ed5A7Ug" name="GDataParseException" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_r9C9gH5eEdujQd6ed5A7Ug" name="arg0" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
-      <ownedParameter xmi:id="_r9ELoX5eEdujQd6ed5A7Ug" name="arg1" type="_r9ELoH5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_r9EysH5eEdujQd6ed5A7Ug" name="GDataParseException" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_r9EysX5eEdujQd6ed5A7Ug" name="arg0" type="_r9ELoH5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Class" xmi:id="_r9WfgH5eEdujQd6ed5A7Ug" name="GOMAttributeImpl" clientDependency="_r9lJAH5eEdujQd6ed5A7Ug _r9nlQn5eEdujQd6ed5A7Ug">
-    <generalization xmi:id="_r9YUsH5eEdujQd6ed5A7Ug" general="_r9XtoH5eEdujQd6ed5A7Ug"/>
-    <ownedOperation xmi:id="_r9fCYH5eEdujQd6ed5A7Ug" name="setQName" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_r9fpcH5eEdujQd6ed5A7Ug" name="aQname" type="_r7h6kH5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_r9fpcX5eEdujQd6ed5A7Ug" name="getTextValue" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_r9gQgH5eEdujQd6ed5A7Ug" type="_r7dpIX5eEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_r9gQgX5eEdujQd6ed5A7Ug" name="setTextValue" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_r9g3kH5eEdujQd6ed5A7Ug" name="aTextValue" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_r9g3kX5eEdujQd6ed5A7Ug" name="setLocalName" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_r9heoH5eEdujQd6ed5A7Ug" name="aLocalName" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_r9iFsH5eEdujQd6ed5A7Ug" name="getLocalName" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_r9iFsX5eEdujQd6ed5A7Ug" type="_r7dpIX5eEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_r9iswH5eEdujQd6ed5A7Ug" name="GOMAttributeImpl" visibility="public" concurrency="concurrent"/>
-    <ownedOperation xmi:id="_r9iswX5eEdujQd6ed5A7Ug" name="getQname" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_r9j64H5eEdujQd6ed5A7Ug" type="_r7h6kH5eEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Interface" xmi:id="_r9XtoH5eEdujQd6ed5A7Ug" name="GOMAttribute">
-    <generalization xmi:id="_sHItoH5eEdujQd6ed5A7Ug" general="_sHIGkH5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Class" xmi:id="_r-JwwH5eEdujQd6ed5A7Ug" name="GOMFactory" clientDependency="_r-RskH5eEdujQd6ed5A7Ug _r-Thwn5eEdujQd6ed5A7Ug">
-    <ownedOperation xmi:id="_r-OpQH5eEdujQd6ed5A7Ug" name="GOMFactory" visibility="private" concurrency="concurrent"/>
-    <ownedOperation xmi:id="_r-OpQX5eEdujQd6ed5A7Ug" name="createInstance" visibility="public" isStatic="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_r-PQUH5eEdujQd6ed5A7Ug" type="_r-JwwH5eEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_r-PQUX5eEdujQd6ed5A7Ug" name="createFeed" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_r-QecH5eEdujQd6ed5A7Ug" type="_r-P3YH5eEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Interface" xmi:id="_r-P3YH5eEdujQd6ed5A7Ug" name="GOMFeed" clientDependency="_ibYkkH5fEdujQd6ed5A7Ug _ibaZwn5fEdujQd6ed5A7Ug _ibc2AH5fEdujQd6ed5A7Ug _iberMn5fEdujQd6ed5A7Ug _ibggYn5fEdujQd6ed5A7Ug _ibi8oX5fEdujQd6ed5A7Ug _ibkx0n5fEdujQd6ed5A7Ug _ibmnAn5fEdujQd6ed5A7Ug _ibpDQH5fEdujQd6ed5A7Ug _ibq4cn5fEdujQd6ed5A7Ug _ibston5fEdujQd6ed5A7Ug _ibui0n5fEdujQd6ed5A7Ug _ibw_EX5fEdujQd6ed5A7Ug _iby0Qn5fEdujQd6ed5A7Ug _ib13kH5fEdujQd6ed5A7Ug">
-    <generalization xmi:id="_iaGyMH5fEdujQd6ed5A7Ug" general="_sHIGkH5eEdujQd6ed5A7Ug"/>
-    <generalization xmi:id="_iaIAUH5fEdujQd6ed5A7Ug" general="_r-kngH5eEdujQd6ed5A7Ug"/>
-    <ownedAttribute xmi:id="_ia3AIH5fEdujQd6ed5A7Ug" name="oPENSEARCH_NS_PREFIX" visibility="public" isLeaf="true" isStatic="true" type="_r7dpIX5eEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_ibR24X5fEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_ibR24H5fEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedAttribute xmi:id="_ia3AIX5fEdujQd6ed5A7Ug" name="lOCALNAME_RSS" visibility="public" isLeaf="true" isStatic="true" type="_r7dpIX5eEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_ibSd8X5fEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_ibSd8H5fEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedAttribute xmi:id="_ia3nMH5fEdujQd6ed5A7Ug" name="oPENSEARCH_NS_URI" visibility="public" isLeaf="true" isStatic="true" type="_r7dpIX5eEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_ibSd835fEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_ibSd8n5fEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedAttribute xmi:id="_ia4OQH5fEdujQd6ed5A7Ug" name="lOCALNAME" visibility="public" isLeaf="true" isStatic="true" type="_r7dpIX5eEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_ibTFAX5fEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_ibTFAH5fEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedOperation xmi:id="_ia41UH5fEdujQd6ed5A7Ug" name="getAuthors" visibility="public" isAbstract="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_ia6DcH5fEdujQd6ed5A7Ug" type="_sAnO4H5eEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_ia6DcX5fEdujQd6ed5A7Ug" name="addAuthor" visibility="public" isAbstract="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_ia6qgH5fEdujQd6ed5A7Ug" name="aAuthor" type="_iKeawH5fEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_ia6qgX5fEdujQd6ed5A7Ug" name="setRights" visibility="public" isAbstract="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_ia7RkH5fEdujQd6ed5A7Ug" name="aRights" type="_iJx3MX5fEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_ia74oH5fEdujQd6ed5A7Ug" name="getSubtitle" visibility="public" isAbstract="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_ia8fsH5fEdujQd6ed5A7Ug" type="_iJ5L8X5fEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_ia8fsX5fEdujQd6ed5A7Ug" name="getNamespaces" visibility="public" isAbstract="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_ia9t0H5fEdujQd6ed5A7Ug" type="_sAnO4H5eEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_ia-U4H5fEdujQd6ed5A7Ug" name="getCategories" visibility="public" isAbstract="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_ia_jAH5fEdujQd6ed5A7Ug" type="_sAnO4H5eEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_ia_jAX5fEdujQd6ed5A7Ug" name="setLogo" visibility="public" isAbstract="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_ibAKEH5fEdujQd6ed5A7Ug" name="aLogo" type="_iJ2vsH5fEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_ibAxIH5fEdujQd6ed5A7Ug" name="addEntry" visibility="public" isAbstract="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_ibB_QH5fEdujQd6ed5A7Ug" name="aEntry" type="_sA-bQH5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_ibCmUH5fEdujQd6ed5A7Ug" name="getTitle" visibility="public" isAbstract="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_ibDNYH5fEdujQd6ed5A7Ug" type="_iJxQIH5fEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_ibDNYX5fEdujQd6ed5A7Ug" name="addCategory" visibility="public" isAbstract="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_ibD0cH5fEdujQd6ed5A7Ug" name="aCategory" type="_iKVQ0H5fEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_ibD0cX5fEdujQd6ed5A7Ug" name="setSubtitle" visibility="public" isAbstract="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_ibEbgH5fEdujQd6ed5A7Ug" name="aSubtitle" type="_iJ5L8X5fEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_ibEbgX5fEdujQd6ed5A7Ug" name="getContributor" visibility="public" isAbstract="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_ibGQsH5fEdujQd6ed5A7Ug" type="_sAnO4H5eEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_ibGQsX5fEdujQd6ed5A7Ug" name="getRights" visibility="public" isAbstract="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_ibG3wH5fEdujQd6ed5A7Ug" type="_iJx3MX5fEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_ibG3wX5fEdujQd6ed5A7Ug" name="getEntries" visibility="public" isAbstract="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_ibHe0H5fEdujQd6ed5A7Ug" type="_sAnO4H5eEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_ibHe0X5fEdujQd6ed5A7Ug" name="addContributor" visibility="public" isAbstract="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_ibIF4H5fEdujQd6ed5A7Ug" name="aContributor" type="_iKC88X5fEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_ibIF4X5fEdujQd6ed5A7Ug" name="getIcon" visibility="public" isAbstract="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_ibIs8H5fEdujQd6ed5A7Ug" type="_iJ390H5fEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_ibIs8X5fEdujQd6ed5A7Ug" name="addNamespace" visibility="public" isAbstract="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_ibJUAH5fEdujQd6ed5A7Ug" name="aNamespace" type="_r8CQ4H5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_ibJUAX5fEdujQd6ed5A7Ug" name="setIcon" visibility="public" isAbstract="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_ibJ7EH5fEdujQd6ed5A7Ug" name="aIcon" type="_iJ390H5fEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_ibKiIH5fEdujQd6ed5A7Ug" name="getId" visibility="public" isAbstract="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_ibKiIX5fEdujQd6ed5A7Ug" type="_iJ1hkH5fEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_ibLJMH5fEdujQd6ed5A7Ug" name="getGenerator" visibility="public" isAbstract="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_ibLJMX5fEdujQd6ed5A7Ug" type="_iJ4k4H5fEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_ibLwQH5fEdujQd6ed5A7Ug" name="setId" visibility="public" isAbstract="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_ibLwQX5fEdujQd6ed5A7Ug" name="aId" type="_iJ1hkH5fEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_ibMXUH5fEdujQd6ed5A7Ug" name="getUpdated" visibility="public" isAbstract="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_ibM-YH5fEdujQd6ed5A7Ug" type="_iJ06gH5fEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_ibM-YX5fEdujQd6ed5A7Ug" name="getLogo" visibility="public" isAbstract="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_ibNlcH5fEdujQd6ed5A7Ug" type="_iJ2vsH5fEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_ibNlcX5fEdujQd6ed5A7Ug" name="setGenerator" visibility="public" isAbstract="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_ibOMgH5fEdujQd6ed5A7Ug" name="aGenerator" type="_iJ4k4H5fEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_ibOMgX5fEdujQd6ed5A7Ug" name="getLinks" visibility="public" isAbstract="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_ibPaoH5fEdujQd6ed5A7Ug" type="_sAnO4H5eEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_ibQBsH5fEdujQd6ed5A7Ug" name="setUpdated" visibility="public" isAbstract="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_ibQowH5fEdujQd6ed5A7Ug" name="aUpdated" type="_iJ06gH5fEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_ibQowX5fEdujQd6ed5A7Ug" name="setTitle" visibility="public" isAbstract="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_ibRP0H5fEdujQd6ed5A7Ug" name="aTitle" type="_iJxQIH5fEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Class" xmi:id="_r-RFgH5eEdujQd6ed5A7Ug" name="GOMFeedImpl" visibility="package" clientDependency="_iL0ekH5fEdujQd6ed5A7Ug _iL2TwX5fEdujQd6ed5A7Ug _iL4wAH5fEdujQd6ed5A7Ug _iL6lMn5fEdujQd6ed5A7Ug _iL8aYn5fEdujQd6ed5A7Ug _iL-2oX5fEdujQd6ed5A7Ug _iMAr0n5fEdujQd6ed5A7Ug _iMChAn5fEdujQd6ed5A7Ug _iMEWMn5fEdujQd6ed5A7Ug _iMGycX5fEdujQd6ed5A7Ug _iMInon5fEdujQd6ed5A7Ug _iMKc0n5fEdujQd6ed5A7Ug _iMM5En5fEdujQd6ed5A7Ug _iMOuQn5fEdujQd6ed5A7Ug _iMQjcn5fEdujQd6ed5A7Ug _iMSYoX5fEdujQd6ed5A7Ug _iMU04X5fEdujQd6ed5A7Ug _iMWqEn5fEdujQd6ed5A7Ug _iMYfQn5fEdujQd6ed5A7Ug _iMa7gH5fEdujQd6ed5A7Ug _iMcwsn5fEdujQd6ed5A7Ug _iMel4n5fEdujQd6ed5A7Ug _iMgbEn5fEdujQd6ed5A7Ug _iMi3Un5fEdujQd6ed5A7Ug _iMksgn5fEdujQd6ed5A7Ug _iMmhsn5fEdujQd6ed5A7Ug _iMo98X5fEdujQd6ed5A7Ug _iMqzIn5fEdujQd6ed5A7Ug _iMsoUX5fEdujQd6ed5A7Ug _iMudgn5fEdujQd6ed5A7Ug">
-    <generalization xmi:id="_iHk3wH5fEdujQd6ed5A7Ug" general="_iHkQsH5fEdujQd6ed5A7Ug"/>
-    <generalization xmi:id="_iHnUAH5fEdujQd6ed5A7Ug" general="_r-P3YH5eEdujQd6ed5A7Ug"/>
-    <ownedAttribute xmi:id="_iJwCAH5fEdujQd6ed5A7Ug" name="contributors" visibility="private" type="_iKC88X5fEdujQd6ed5A7Ug" association="_iKwHkX5fEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iKfo4H5fEdujQd6ed5A7Ug" value="*"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iKfB0X5fEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedAttribute xmi:id="_iJwpEH5fEdujQd6ed5A7Ug" name="title" visibility="private" type="_iJxQIH5fEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iKfo435fEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iKfo4n5fEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedAttribute xmi:id="_iJx3MH5fEdujQd6ed5A7Ug" name="rights" visibility="private" type="_iJx3MX5fEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iKgP8X5fEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iKgP8H5fEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedAttribute xmi:id="_iJyeQH5fEdujQd6ed5A7Ug" name="categories" visibility="private" type="_iKVQ0H5fEdujQd6ed5A7Ug" association="_iK5RgH5fEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iKgP835fEdujQd6ed5A7Ug" value="*"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iKgP8n5fEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedAttribute xmi:id="_iJzFUH5fEdujQd6ed5A7Ug" name="namespaces" visibility="private" type="_r8CQ4H5eEdujQd6ed5A7Ug" association="_iK6foH5fEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iKg3An5fEdujQd6ed5A7Ug" value="*"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iKg3AX5fEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedAttribute xmi:id="_iJzFUX5fEdujQd6ed5A7Ug" name="authors" visibility="private" type="_iKeawH5fEdujQd6ed5A7Ug" association="_iLiKsX5fEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iKheEH5fEdujQd6ed5A7Ug" value="*"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iKg3BH5fEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedAttribute xmi:id="_iJzsYH5fEdujQd6ed5A7Ug" name="entries" visibility="private" type="_sA-bQH5eEdujQd6ed5A7Ug" association="_iLEQoX5fEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iKheE35fEdujQd6ed5A7Ug" value="*"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iKheEn5fEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedAttribute xmi:id="_iJ0TcH5fEdujQd6ed5A7Ug" name="updated" visibility="private" type="_iJ06gH5fEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iKjTQX5fEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iKjTQH5fEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedAttribute xmi:id="_iJ06gX5fEdujQd6ed5A7Ug" name="id" visibility="private" type="_iJ1hkH5fEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iKj6UX5fEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iKj6UH5fEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedAttribute xmi:id="_iJ2IoH5fEdujQd6ed5A7Ug" name="logo" visibility="private" type="_iJ2vsH5fEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iKkhYH5fEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iKj6Un5fEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedAttribute xmi:id="_iJ2vsX5fEdujQd6ed5A7Ug" name="links" visibility="private" type="_iLjY0H5fEdujQd6ed5A7Ug" association="_iLr7sH5fEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iKkhYn5fEdujQd6ed5A7Ug" value="*"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iKkhYX5fEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedAttribute xmi:id="_iJ3WwH5fEdujQd6ed5A7Ug" name="icon" visibility="private" type="_iJ390H5fEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iKlIcX5fEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iKlIcH5fEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedAttribute xmi:id="_iJ390X5fEdujQd6ed5A7Ug" name="generator" visibility="private" type="_iJ4k4H5fEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iKlIc35fEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iKlIcn5fEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedAttribute xmi:id="_iJ5L8H5fEdujQd6ed5A7Ug" name="subtitle" visibility="private" type="_iJ5L8X5fEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iKlvgX5fEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iKlvgH5fEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedOperation xmi:id="_iJ5zAH5fEdujQd6ed5A7Ug" name="getAuthors" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iJ6aEH5fEdujQd6ed5A7Ug" type="_sAnO4H5eEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iJ6aEX5fEdujQd6ed5A7Ug" name="setLogo" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iJ7BIH5fEdujQd6ed5A7Ug" name="aLogo" type="_iJ2vsH5fEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iJ7BIX5fEdujQd6ed5A7Ug" name="processEndElement" visibility="public" concurrency="concurrent"/>
-    <ownedOperation xmi:id="_iJ7oMH5fEdujQd6ed5A7Ug" name="getRights" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iJ8PQH5fEdujQd6ed5A7Ug" type="_iJx3MX5fEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iJ8PQX5fEdujQd6ed5A7Ug" name="setIcon" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iJ82UH5fEdujQd6ed5A7Ug" name="aIcon" type="_iJ390H5fEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iJ82UX5fEdujQd6ed5A7Ug" name="getUpdated" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iJ9dYH5fEdujQd6ed5A7Ug" type="_iJ06gH5fEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iJ9dYX5fEdujQd6ed5A7Ug" name="setId" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iJ-rgH5fEdujQd6ed5A7Ug" name="aId" type="_iJ1hkH5fEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iJ-rgX5fEdujQd6ed5A7Ug" name="getIcon" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iJ_SkH5fEdujQd6ed5A7Ug" type="_iJ390H5fEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iJ_SkX5fEdujQd6ed5A7Ug" name="getId" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iJ_5oH5fEdujQd6ed5A7Ug" type="_iJ1hkH5fEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iJ_5oX5fEdujQd6ed5A7Ug" name="getGenerator" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iKAgsH5fEdujQd6ed5A7Ug" type="_iJ4k4H5fEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iKAgsX5fEdujQd6ed5A7Ug" name="getEntries" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iKBHwH5fEdujQd6ed5A7Ug" type="_sAnO4H5eEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iKBHwX5fEdujQd6ed5A7Ug" name="getNamespaces" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iKBu0H5fEdujQd6ed5A7Ug" type="_sAnO4H5eEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iKBu0X5fEdujQd6ed5A7Ug" name="GOMFeedImpl" visibility="package" concurrency="concurrent"/>
-    <ownedOperation xmi:id="_iKCV4H5fEdujQd6ed5A7Ug" name="getLocalName" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iKCV4X5fEdujQd6ed5A7Ug" type="_r7dpIX5eEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iKC88H5fEdujQd6ed5A7Ug" name="addContributor" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iKDkAH5fEdujQd6ed5A7Ug" name="aContributor" type="_iKC88X5fEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iKELEH5fEdujQd6ed5A7Ug" name="getLinks" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iKEyIH5fEdujQd6ed5A7Ug" type="_sAnO4H5eEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iKEyIX5fEdujQd6ed5A7Ug" name="getTitle" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iKFZMH5fEdujQd6ed5A7Ug" type="_iJxQIH5fEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iKFZMX5fEdujQd6ed5A7Ug" name="setSubtitle" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iKFZMn5fEdujQd6ed5A7Ug" name="aSubtitle" type="_iJ5L8X5fEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iKGAQH5fEdujQd6ed5A7Ug" name="addNamespace" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iKGnUH5fEdujQd6ed5A7Ug" name="aNamespace" type="_r8CQ4H5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iKGnUX5fEdujQd6ed5A7Ug" name="addChild" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iKJDkH5fEdujQd6ed5A7Ug" name="aElement" type="_r-kngH5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iKJqoH5fEdujQd6ed5A7Ug" name="setRights" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iKKRsH5fEdujQd6ed5A7Ug" name="aRights" type="_iJx3MX5fEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iKKRsX5fEdujQd6ed5A7Ug" name="getSubtitle" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iKK4wH5fEdujQd6ed5A7Ug" type="_iJ5L8X5fEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iKK4wX5fEdujQd6ed5A7Ug" name="addEntry" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iKLf0H5fEdujQd6ed5A7Ug" name="aEntry" type="_sA-bQH5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iKMG4H5fEdujQd6ed5A7Ug" name="setTitle" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iKMt8H5fEdujQd6ed5A7Ug" name="aTitle" type="_iJxQIH5fEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iKMt8X5fEdujQd6ed5A7Ug" name="setGenerator" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iKNVAH5fEdujQd6ed5A7Ug" name="aGenerator" type="_iJ4k4H5fEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iKNVAX5fEdujQd6ed5A7Ug" name="getCategories" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iKN8EH5fEdujQd6ed5A7Ug" type="_sAnO4H5eEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iKOjIH5fEdujQd6ed5A7Ug" name="processAttribute" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iKQYUH5fEdujQd6ed5A7Ug" name="aQName" type="_r7h6kH5eEdujQd6ed5A7Ug"/>
-      <ownedParameter xmi:id="_iKQ_YH5fEdujQd6ed5A7Ug" name="aValue" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iKQ_YX5fEdujQd6ed5A7Ug" name="setUpdated" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iKRmcH5fEdujQd6ed5A7Ug" name="aUpdated" type="_iJ06gH5fEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iKSNgH5fEdujQd6ed5A7Ug" name="getContributor" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iKS0kH5fEdujQd6ed5A7Ug" type="_sAnO4H5eEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iKS0kX5fEdujQd6ed5A7Ug" name="processElementValue" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iKTboH5fEdujQd6ed5A7Ug" name="aValue" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iKTboX5fEdujQd6ed5A7Ug" name="getChildren" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iKUpwH5fEdujQd6ed5A7Ug" type="_iKUCsH5fEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iKUpwX5fEdujQd6ed5A7Ug" name="addCategory" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iKVQ0X5fEdujQd6ed5A7Ug" name="aCategory" type="_iKVQ0H5fEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iKV34H5fEdujQd6ed5A7Ug" name="writeAtomOutput" visibility="public" concurrency="concurrent" raisedException="_r_OHwH5eEdujQd6ed5A7Ug">
-      <ownedParameter xmi:id="_iKYUIH5fEdujQd6ed5A7Ug" name="aStreamWriter" type="_r_MSkH5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iKawYH5fEdujQd6ed5A7Ug" name="getChildParser" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iKbXcH5fEdujQd6ed5A7Ug" name="aName" type="_r7h6kH5eEdujQd6ed5A7Ug"/>
-      <ownedParameter xmi:id="_iKb-gH5fEdujQd6ed5A7Ug" type="_r7Q00H5eEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iKb-gX5fEdujQd6ed5A7Ug" name="getLogo" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iKclkH5fEdujQd6ed5A7Ug" type="_iJ2vsH5fEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iKclkX5fEdujQd6ed5A7Ug" name="writeRssOutput" visibility="public" concurrency="concurrent" raisedException="_r_OHwH5eEdujQd6ed5A7Ug">
-      <ownedParameter xmi:id="_iKdMoH5fEdujQd6ed5A7Ug" name="aStreamWriter" type="_r_MSkH5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iKdzsH5fEdujQd6ed5A7Ug" name="addAuthor" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iKfB0H5fEdujQd6ed5A7Ug" name="aAuthor" type="_iKeawH5fEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Interface" xmi:id="_r-kngH5eEdujQd6ed5A7Ug" name="GOMElement"/>
-  <packagedElement xmi:type="uml:Class" xmi:id="_r-yp8H5eEdujQd6ed5A7Ug" name="GOMDocumentImpl" clientDependency="_r_vsMH5eEdujQd6ed5A7Ug _r_xhYn5eEdujQd6ed5A7Ug _r_z9on5eEdujQd6ed5A7Ug _r_1y0n5eEdujQd6ed5A7Ug _r_3oAX5eEdujQd6ed5A7Ug">
-    <generalization xmi:id="_r-1GMH5eEdujQd6ed5A7Ug" general="_r-0fIH5eEdujQd6ed5A7Ug"/>
-    <ownedAttribute xmi:id="_r_HaEH5eEdujQd6ed5A7Ug" name="charEncoding" visibility="private" type="_r7dpIX5eEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_r_l7MX5eEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_r_l7MH5eEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedAttribute xmi:id="_r_HaEX5eEdujQd6ed5A7Ug" name="root" visibility="private">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_r_miQX5eEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_r_miQH5eEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedAttribute xmi:id="_r_KdYH5eEdujQd6ed5A7Ug" name="version" visibility="private" type="_r7dpIX5eEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_r_nJUH5eEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_r_miQn5eEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedOperation xmi:id="_r_LEcH5eEdujQd6ed5A7Ug" name="writeRssOutput" visibility="public" concurrency="concurrent" raisedException="_r_OHwH5eEdujQd6ed5A7Ug">
-      <ownedParameter xmi:id="_r_M5oH5eEdujQd6ed5A7Ug" name="aStreamWriter" type="_r_MSkH5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_r_Ou0H5eEdujQd6ed5A7Ug" name="getRootElement" visibility="public" concurrency="concurrent"/>
-    <ownedOperation xmi:id="_r_RyIH5eEdujQd6ed5A7Ug" name="writeAtomOutput" visibility="public" concurrency="concurrent" raisedException="_r_OHwH5eEdujQd6ed5A7Ug">
-      <ownedParameter xmi:id="_r_SZMH5eEdujQd6ed5A7Ug" name="aStreamWriter" type="_r_MSkH5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_r_SZMX5eEdujQd6ed5A7Ug" name="setVersion" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_r_TAQH5eEdujQd6ed5A7Ug" name="aVersion" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_r_TnUH5eEdujQd6ed5A7Ug" name="getCharacterEncoding" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_r_hCsH5eEdujQd6ed5A7Ug" type="_r7dpIX5eEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_r_hCsX5eEdujQd6ed5A7Ug" name="setCharacterEncoding" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_r_hpwH5eEdujQd6ed5A7Ug" name="aEncoding" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_r_iQ0H5eEdujQd6ed5A7Ug" name="getVersion" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_r_iQ0X5eEdujQd6ed5A7Ug" type="_r7dpIX5eEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_r_i34H5eEdujQd6ed5A7Ug" name="GOMDocumentImpl" visibility="public" concurrency="concurrent"/>
-    <ownedOperation xmi:id="_r_i34X5eEdujQd6ed5A7Ug" name="setRootElement" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_r_lUIH5eEdujQd6ed5A7Ug" name="aRootElement"/>
-    </ownedOperation>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Interface" xmi:id="_r-0fIH5eEdujQd6ed5A7Ug" name="GOMDocument" clientDependency="_sH6wwH5eEdujQd6ed5A7Ug _sH9NAn5eEdujQd6ed5A7Ug _sH_CMn5eEdujQd6ed5A7Ug _sIA3Yn5eEdujQd6ed5A7Ug _sIDToX5eEdujQd6ed5A7Ug">
-    <ownedOperation xmi:id="_sHmAoH5eEdujQd6ed5A7Ug" name="writeAtomOutput" visibility="public" isAbstract="true" concurrency="concurrent" raisedException="_r_OHwH5eEdujQd6ed5A7Ug">
-      <ownedParameter xmi:id="_sHnOwH5eEdujQd6ed5A7Ug" name="aStreamWriter" type="_r_MSkH5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_sHoc4H5eEdujQd6ed5A7Ug" name="writeRssOutput" visibility="public" isAbstract="true" concurrency="concurrent" raisedException="_r_OHwH5eEdujQd6ed5A7Ug">
-      <ownedParameter xmi:id="_sHpD8H5eEdujQd6ed5A7Ug" name="aStreamWriter" type="_r_MSkH5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_sHprAH5eEdujQd6ed5A7Ug" name="getVersion" visibility="public" isAbstract="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_sHqSEH5eEdujQd6ed5A7Ug" type="_r7dpIX5eEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_sHqSEX5eEdujQd6ed5A7Ug" name="getCharacterEncoding" visibility="public" isAbstract="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_sHq5IH5eEdujQd6ed5A7Ug" type="_r7dpIX5eEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_sHq5IX5eEdujQd6ed5A7Ug" name="getRootElement" visibility="public" isAbstract="true" concurrency="concurrent"/>
-    <ownedOperation xmi:id="_sHwYsH5eEdujQd6ed5A7Ug" name="setCharacterEncoding" visibility="public" isAbstract="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_sHw_wH5eEdujQd6ed5A7Ug" name="aEncoding" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_sHxm0H5eEdujQd6ed5A7Ug" name="setVersion" visibility="public" isAbstract="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_sHxm0X5eEdujQd6ed5A7Ug" name="aVersion" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_sHyN4H5eEdujQd6ed5A7Ug" name="setRootElement" visibility="public" isAbstract="true" concurrency="concurrent">
-      <ownedParameter xmi:id="_sH0qIH5eEdujQd6ed5A7Ug" name="aRootElement"/>
-    </ownedOperation>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Interface" xmi:id="_r_MSkH5eEdujQd6ed5A7Ug" name="XMLStreamWriter" isAbstract="true"/>
-  <packagedElement xmi:type="uml:Class" xmi:id="_r_OHwH5eEdujQd6ed5A7Ug" name="XMLStreamException"/>
-  <packagedElement xmi:type="uml:Class" xmi:id="_sAJ74H5eEdujQd6ed5A7Ug" name="GOMBuilder" clientDependency="_sBMdsX5eEdujQd6ed5A7Ug _sBOS4X5eEdujQd6ed5A7Ug _sBQIEn5eEdujQd6ed5A7Ug _sBSkUX5eEdujQd6ed5A7Ug _sBUZgX5eEdujQd6ed5A7Ug _sBWOsn5eEdujQd6ed5A7Ug _sBYq8n5eEdujQd6ed5A7Ug _sBagIn5eEdujQd6ed5A7Ug _sBcVUX5eEdujQd6ed5A7Ug _sBexkn5eEdujQd6ed5A7Ug _sBhN0H5eEdujQd6ed5A7Ug _sBjDAn5eEdujQd6ed5A7Ug _sBmGUH5eEdujQd6ed5A7Ug _sBn7gn5eEdujQd6ed5A7Ug _sBqXwX5eEdujQd6ed5A7Ug _sBsM8X5eEdujQd6ed5A7Ug _sBuCIn5eEdujQd6ed5A7Ug _lnc38H5fEdujQd6ed5A7Ug _lngiUX5fEdujQd6ed5A7Ug _lni-kH5fEdujQd6ed5A7Ug _lnkzwX5fEdujQd6ed5A7Ug _ln4VwH5fEdujQd6ed5A7Ug _ln8AIX5fEdujQd6ed5A7Ug _ln-cYX5fEdujQd6ed5A7Ug _loA4oH5fEdujQd6ed5A7Ug _-nSZoH5fEdujQd6ed5A7Ug _-nUO0X5fEdujQd6ed5A7Ug _-nWrEH5fEdujQd6ed5A7Ug _-nYgQX5fEdujQd6ed5A7Ug _BYTvwH5gEdujQd6ed5A7Ug _BYWMAX5gEdujQd6ed5A7Ug _BYYBMX5gEdujQd6ed5A7Ug _BYadcH5gEdujQd6ed5A7Ug">
-    <ownedAttribute xmi:id="_sAkyoH5eEdujQd6ed5A7Ug" name="parserStack" visibility="private" isLeaf="true" type="_r7Q00H5eEdujQd6ed5A7Ug" association="_sBCFoH5eEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_sA_CUX5eEdujQd6ed5A7Ug" value="*"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_sA_CUH5eEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedAttribute xmi:id="_sAnO4X5eEdujQd6ed5A7Ug" name="lastLocalName" visibility="private" type="_r7h6kH5eEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_sBAQcn5eEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_sBAQcX5eEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedAttribute xmi:id="_sAn18H5eEdujQd6ed5A7Ug" name="streamReader" visibility="private" isLeaf="true" type="_sAodAH5eEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_sBAQdH5eEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_sBAQc35eEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedAttribute xmi:id="_sAodAX5eEdujQd6ed5A7Ug" name="factory" visibility="private" isLeaf="true" type="_r-JwwH5eEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_sBA3gX5eEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_sBA3gH5eEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedOperation xmi:id="_sApEEH5eEdujQd6ed5A7Ug" name="next" visibility="private" concurrency="concurrent" raisedException="_r_OHwH5eEdujQd6ed5A7Ug">
-      <ownedParameter xmi:id="_BYLM4H5gEdujQd6ed5A7Ug" direction="return">
-        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/JavaPrimitiveTypes.library.uml#int"/>
-      </ownedParameter>
-    </ownedOperation>
-    <ownedOperation xmi:id="_sArgUH5eEdujQd6ed5A7Ug" name="parse" visibility="private" concurrency="concurrent" raisedException="_r_OHwH5eEdujQd6ed5A7Ug">
-      <ownedParameter xmi:id="_BYMbAH5gEdujQd6ed5A7Ug" name="aReader" type="_sAodAH5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_sA6w4H5eEdujQd6ed5A7Ug" name="processAttributes" visibility="private" concurrency="concurrent">
-      <ownedParameter xmi:id="_BYNpIH5gEdujQd6ed5A7Ug" name="childParser" type="_r7Q00H5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_sA7X8X5eEdujQd6ed5A7Ug" name="startFeedDocument" visibility="private" concurrency="concurrent" raisedException="_r_OHwH5eEdujQd6ed5A7Ug">
-      <ownedParameter xmi:id="_BYLz8H5gEdujQd6ed5A7Ug" name="aDocument" type="_r-0fIH5eEdujQd6ed5A7Ug"/>
-      <ownedParameter xmi:id="_BYLz8X5gEdujQd6ed5A7Ug" type="_r-P3YH5eEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_sA8mEH5eEdujQd6ed5A7Ug" name="buildGOMFeed" visibility="public" concurrency="concurrent" raisedException="_r_OHwH5eEdujQd6ed5A7Ug">
-      <ownedParameter xmi:id="_BYOQMH5gEdujQd6ed5A7Ug" type="_r-0fIH5eEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_sA9NIH5eEdujQd6ed5A7Ug" name="GOMBuilder" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_BYNCEH5gEdujQd6ed5A7Ug" name="arg0" type="_sAodAH5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_sA90MX5eEdujQd6ed5A7Ug" name="buildGOMEntry" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_BYO3QH5gEdujQd6ed5A7Ug" type="_sA-bQH5eEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Interface" xmi:id="_sAodAH5eEdujQd6ed5A7Ug" name="XMLStreamReader" isAbstract="true"/>
-  <packagedElement xmi:type="uml:Interface" xmi:id="_sA-bQH5eEdujQd6ed5A7Ug" name="GOMEntry">
-    <generalization xmi:id="_iK8U0H5fEdujQd6ed5A7Ug" general="_sHIGkH5eEdujQd6ed5A7Ug"/>
-    <generalization xmi:id="_iK9i8H5fEdujQd6ed5A7Ug" general="_r-kngH5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Association" xmi:id="_sBCFoH5eEdujQd6ed5A7Ug" memberEnd="_sAkyoH5eEdujQd6ed5A7Ug _sBCssH5eEdujQd6ed5A7Ug">
-    <name xsi:nil="true"/>
-    <ownedEnd xmi:id="_sBCssH5eEdujQd6ed5A7Ug" name="" type="_sAJ74H5eEdujQd6ed5A7Ug" association="_sBCFoH5eEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_sBCssX5eEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_sBCssn5eEdujQd6ed5A7Ug"/>
-    </ownedEnd>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Interface" xmi:id="_sHIGkH5eEdujQd6ed5A7Ug" name="GOMXmlEntity"/>
-  <packagedElement xmi:type="uml:Class" xmi:id="_iHkQsH5fEdujQd6ed5A7Ug" name="AbstractGOMElement" visibility="package" clientDependency="_iZqtUH5fEdujQd6ed5A7Ug _iZtJkn5fEdujQd6ed5A7Ug _iZu-wn5fEdujQd6ed5A7Ug _iZxbAX5fEdujQd6ed5A7Ug _iZzQMn5fEdujQd6ed5A7Ug _iZ1FYn5fEdujQd6ed5A7Ug _iZ3hoX5fEdujQd6ed5A7Ug _iZ5W0X5fEdujQd6ed5A7Ug _iZ7MAn5fEdujQd6ed5A7Ug" isAbstract="true">
-    <generalization xmi:id="_iYpZoH5fEdujQd6ed5A7Ug" general="_r-kngH5eEdujQd6ed5A7Ug"/>
-    <ownedAttribute xmi:id="_iZZAgH5fEdujQd6ed5A7Ug" name="extensionAttributes" visibility="protected" type="_r9XtoH5eEdujQd6ed5A7Ug" association="_iZnqAH5fEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iZlNwX5fEdujQd6ed5A7Ug" value="*"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iZlNwH5fEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedAttribute xmi:id="_iZZnkH5fEdujQd6ed5A7Ug" name="textValue" visibility="protected" type="_r7dpIX5eEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iZl00n5fEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iZl00X5fEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedAttribute xmi:id="_iZaOoH5fEdujQd6ed5A7Ug" name="qname" visibility="protected" type="_r7h6kH5eEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iZmb4H5fEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iZl0035fEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedAttribute xmi:id="_iZaOoX5fEdujQd6ed5A7Ug" name="localName" visibility="protected" type="_r7dpIX5eEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iZmb4n5fEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iZmb4X5fEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedAttribute xmi:id="_iZa1sH5fEdujQd6ed5A7Ug" name="parent" visibility="protected" type="_r-kngH5eEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iZnC8X5fEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iZnC8H5fEdujQd6ed5A7Ug"/>
-    </ownedAttribute>
-    <ownedOperation xmi:id="_iZbcwH5fEdujQd6ed5A7Ug" name="getAttributes" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iZcD0H5fEdujQd6ed5A7Ug" type="_iKUCsH5fEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iZcD0X5fEdujQd6ed5A7Ug" name="addAttribute" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iZcD0n5fEdujQd6ed5A7Ug" name="aAttribute" type="_r9XtoH5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iZcq4H5fEdujQd6ed5A7Ug" name="getChildParser" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iZdR8H5fEdujQd6ed5A7Ug" name="aName" type="_r7h6kH5eEdujQd6ed5A7Ug"/>
-      <ownedParameter xmi:id="_iZdR8X5fEdujQd6ed5A7Ug" type="_r7Q00H5eEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iZdR8n5fEdujQd6ed5A7Ug" name="getLocalName" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iZegEH5fEdujQd6ed5A7Ug" type="_r7dpIX5eEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iZegEX5fEdujQd6ed5A7Ug" name="setQName" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iZfHIH5fEdujQd6ed5A7Ug" name="aQname" type="_r7h6kH5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iZfHIX5fEdujQd6ed5A7Ug" name="setLocalName" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iZfuMH5fEdujQd6ed5A7Ug" name="aLocalName" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iZgVQH5fEdujQd6ed5A7Ug" name="processElementValue" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iZgVQX5fEdujQd6ed5A7Ug" name="aValue" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iZg8UH5fEdujQd6ed5A7Ug" name="getTextValue" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iZhjYH5fEdujQd6ed5A7Ug" type="_r7dpIX5eEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iZhjYX5fEdujQd6ed5A7Ug" name="processEndElement" visibility="public" concurrency="concurrent"/>
-    <ownedOperation xmi:id="_iZiKcH5fEdujQd6ed5A7Ug" name="getParent" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iZixgH5fEdujQd6ed5A7Ug" type="_r-kngH5eEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iZixgX5fEdujQd6ed5A7Ug" name="getQname" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iZjYkH5fEdujQd6ed5A7Ug" type="_r7h6kH5eEdujQd6ed5A7Ug" direction="return"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iZjYkX5fEdujQd6ed5A7Ug" name="processAttribute" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iZjYkn5fEdujQd6ed5A7Ug" name="aQName" type="_r7h6kH5eEdujQd6ed5A7Ug"/>
-      <ownedParameter xmi:id="_iZj_oH5fEdujQd6ed5A7Ug" name="aValue" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-    <ownedOperation xmi:id="_iZj_oX5fEdujQd6ed5A7Ug" name="setTextValue" visibility="public" concurrency="concurrent">
-      <ownedParameter xmi:id="_iZkmsH5fEdujQd6ed5A7Ug" name="aTextValue" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
-    </ownedOperation>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Interface" xmi:id="_iJxQIH5fEdujQd6ed5A7Ug" name="GOMTitle"/>
-  <packagedElement xmi:type="uml:Interface" xmi:id="_iJx3MX5fEdujQd6ed5A7Ug" name="GOMRights"/>
-  <packagedElement xmi:type="uml:Interface" xmi:id="_iJ06gH5fEdujQd6ed5A7Ug" name="GOMTime"/>
-  <packagedElement xmi:type="uml:Interface" xmi:id="_iJ1hkH5fEdujQd6ed5A7Ug" name="GOMId"/>
-  <packagedElement xmi:type="uml:Interface" xmi:id="_iJ2vsH5fEdujQd6ed5A7Ug" name="GOMLogo"/>
-  <packagedElement xmi:type="uml:Interface" xmi:id="_iJ390H5fEdujQd6ed5A7Ug" name="GOMIcon"/>
-  <packagedElement xmi:type="uml:Interface" xmi:id="_iJ4k4H5fEdujQd6ed5A7Ug" name="GOMGenerator"/>
-  <packagedElement xmi:type="uml:Interface" xmi:id="_iJ5L8X5fEdujQd6ed5A7Ug" name="GOMSubtitle"/>
-  <packagedElement xmi:type="uml:Interface" xmi:id="_iKC88X5fEdujQd6ed5A7Ug" name="GOMContributor">
-    <generalization xmi:id="_iKoy0H5fEdujQd6ed5A7Ug" general="_r-kngH5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Interface" xmi:id="_iKVQ0H5fEdujQd6ed5A7Ug" name="GOMCategory">
-    <generalization xmi:id="_iKx8wH5fEdujQd6ed5A7Ug" general="_r-kngH5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Interface" xmi:id="_iKeawH5fEdujQd6ed5A7Ug" name="GOMAuthor">
-    <generalization xmi:id="_iLGs4H5fEdujQd6ed5A7Ug" general="_r-kngH5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Association" xmi:id="_iKwHkX5fEdujQd6ed5A7Ug" memberEnd="_iJwCAH5fEdujQd6ed5A7Ug _iKwuoH5fEdujQd6ed5A7Ug">
-    <name xsi:nil="true"/>
-    <ownedEnd xmi:id="_iKwuoH5fEdujQd6ed5A7Ug" name="" type="_r-RFgH5eEdujQd6ed5A7Ug" association="_iKwHkX5fEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iKwuoX5fEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iKwuon5fEdujQd6ed5A7Ug"/>
-    </ownedEnd>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Association" xmi:id="_iK5RgH5fEdujQd6ed5A7Ug" memberEnd="_iJyeQH5fEdujQd6ed5A7Ug _iK5RgX5fEdujQd6ed5A7Ug">
-    <name xsi:nil="true"/>
-    <ownedEnd xmi:id="_iK5RgX5fEdujQd6ed5A7Ug" name="" type="_r-RFgH5eEdujQd6ed5A7Ug" association="_iK5RgH5fEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iK5Rgn5fEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iK5Rg35fEdujQd6ed5A7Ug"/>
-    </ownedEnd>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Association" xmi:id="_iK6foH5fEdujQd6ed5A7Ug" memberEnd="_iJzFUH5fEdujQd6ed5A7Ug _iK6foX5fEdujQd6ed5A7Ug">
-    <name xsi:nil="true"/>
-    <ownedEnd xmi:id="_iK6foX5fEdujQd6ed5A7Ug" name="" type="_r-RFgH5eEdujQd6ed5A7Ug" association="_iK6foH5fEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iK6fon5fEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iK6fo35fEdujQd6ed5A7Ug"/>
-    </ownedEnd>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Association" xmi:id="_iLEQoX5fEdujQd6ed5A7Ug" memberEnd="_iJzsYH5fEdujQd6ed5A7Ug _iLE3sH5fEdujQd6ed5A7Ug">
-    <name xsi:nil="true"/>
-    <ownedEnd xmi:id="_iLE3sH5fEdujQd6ed5A7Ug" name="" type="_r-RFgH5eEdujQd6ed5A7Ug" association="_iLEQoX5fEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iLE3sX5fEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iLE3sn5fEdujQd6ed5A7Ug"/>
-    </ownedEnd>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Association" xmi:id="_iLiKsX5fEdujQd6ed5A7Ug" memberEnd="_iJzFUX5fEdujQd6ed5A7Ug _iLixwH5fEdujQd6ed5A7Ug">
-    <name xsi:nil="true"/>
-    <ownedEnd xmi:id="_iLixwH5fEdujQd6ed5A7Ug" name="" type="_r-RFgH5eEdujQd6ed5A7Ug" association="_iLiKsX5fEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iLixwX5fEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iLixwn5fEdujQd6ed5A7Ug"/>
-    </ownedEnd>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Interface" xmi:id="_iLjY0H5fEdujQd6ed5A7Ug" name="GOMLink">
-    <generalization xmi:id="_iLkm8H5fEdujQd6ed5A7Ug" general="_r-kngH5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Association" xmi:id="_iLr7sH5fEdujQd6ed5A7Ug" memberEnd="_iJ2vsX5fEdujQd6ed5A7Ug _iLr7sX5fEdujQd6ed5A7Ug">
-    <name xsi:nil="true"/>
-    <ownedEnd xmi:id="_iLr7sX5fEdujQd6ed5A7Ug" name="" type="_r-RFgH5eEdujQd6ed5A7Ug" association="_iLr7sH5fEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iLr7sn5fEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iLr7s35fEdujQd6ed5A7Ug"/>
-    </ownedEnd>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Class" xmi:id="_iLtw4H5fEdujQd6ed5A7Ug" name="GOMTitleImp"/>
-  <packagedElement xmi:type="uml:Class" xmi:id="_iLu_AH5fEdujQd6ed5A7Ug" name="GOMIdImpl" visibility="package"/>
-  <packagedElement xmi:type="uml:Association" xmi:id="_iZnqAH5fEdujQd6ed5A7Ug" memberEnd="_iZZAgH5fEdujQd6ed5A7Ug _iZoREH5fEdujQd6ed5A7Ug">
-    <name xsi:nil="true"/>
-    <ownedEnd xmi:id="_iZoREH5fEdujQd6ed5A7Ug" name="" type="_iHkQsH5fEdujQd6ed5A7Ug" association="_iZnqAH5fEdujQd6ed5A7Ug">
-      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iZoREX5fEdujQd6ed5A7Ug" value="1"/>
-      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iZoREn5fEdujQd6ed5A7Ug"/>
-    </ownedEnd>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Package" xmi:id="_r7dCEX5eEdujQd6ed5A7Ug" name="java.lang">
-    <packagedElement xmi:type="uml:Class" xmi:id="_r7dpIX5eEdujQd6ed5A7Ug" name="String" isLeaf="true"/>
-    <packagedElement xmi:type="uml:Class" xmi:id="_r89d8H5eEdujQd6ed5A7Ug" name="RuntimeException">
-      <generalization xmi:id="_sEm-EH5eEdujQd6ed5A7Ug" general="_sEmXAH5eEdujQd6ed5A7Ug"/>
-      <ownedAttribute xmi:id="_sGP80H5eEdujQd6ed5A7Ug" name="serialVersionUID" visibility="package" isLeaf="true" isStatic="true" isReadOnly="true">
-        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/JavaPrimitiveTypes.library.uml#long"/>
-      </ownedAttribute>
-      <ownedOperation xmi:id="_sGRyAH5eEdujQd6ed5A7Ug" name="RuntimeException" visibility="public" concurrency="concurrent">
-        <ownedParameter xmi:id="_sGyvYH5eEdujQd6ed5A7Ug" name="arg0" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
-        <ownedParameter xmi:id="_sGyvYX5eEdujQd6ed5A7Ug" name="arg1" type="_r9ELoH5eEdujQd6ed5A7Ug"/>
-      </ownedOperation>
-      <ownedOperation xmi:id="_sGzWcH5eEdujQd6ed5A7Ug" name="RuntimeException" visibility="public" concurrency="concurrent">
-        <ownedParameter xmi:id="_sGz9gH5eEdujQd6ed5A7Ug" name="arg0" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
-      </ownedOperation>
-      <ownedOperation xmi:id="_sGz9gX5eEdujQd6ed5A7Ug" name="RuntimeException" visibility="public" concurrency="concurrent">
-        <ownedParameter xmi:id="_sG0kkH5eEdujQd6ed5A7Ug" name="arg0" type="_r9ELoH5eEdujQd6ed5A7Ug"/>
-      </ownedOperation>
-      <ownedOperation xmi:id="_sG0kkX5eEdujQd6ed5A7Ug" name="RuntimeException" visibility="public" concurrency="concurrent"/>
-    </packagedElement>
-    <packagedElement xmi:type="uml:Class" xmi:id="_r9ELoH5eEdujQd6ed5A7Ug" name="Throwable"/>
-    <packagedElement xmi:type="uml:Class" xmi:id="_sBHlMH5eEdujQd6ed5A7Ug" name="System" isLeaf="true"/>
-    <packagedElement xmi:type="uml:Class" xmi:id="_sEmXAH5eEdujQd6ed5A7Ug" name="Exception"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Package" xmi:id="_sAlZsH5eEdujQd6ed5A7Ug" name="java.util">
-    <packagedElement xmi:type="uml:Class" xmi:id="_sAmAwH5eEdujQd6ed5A7Ug" name="Stack"/>
-    <packagedElement xmi:type="uml:Interface" xmi:id="_sAnO4H5eEdujQd6ed5A7Ug" name="List" isAbstract="true"/>
-    <packagedElement xmi:type="uml:Class" xmi:id="_sBG-IH5eEdujQd6ed5A7Ug" name="LinkedList"/>
-    <packagedElement xmi:type="uml:Interface" xmi:id="_iKUCsH5fEdujQd6ed5A7Ug" name="Iterator" isAbstract="true"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_l_ahcH5eEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l83jwH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l85Y8H5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_mVVuIH5eEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l85Y8H5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_mVYKYH5eEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l85Y8H5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_mVZ_kn5eEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l85Y8H5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_mVcb0H5eEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l85Y8H5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_mVpQIH5eEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l83jwH5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_mVrsYH5eEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l83jwH5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_mVthkX5eEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l83jwH5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_mVv90X5eEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_mVmz4H5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l83jwH5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_mV6V4H5eEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l83jwH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_mV8yIX5eEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l83jwH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_mV_OYH5eEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_mWBDkX5eEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_mWDf0H5eEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_mVmz4H5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_mWHxQH5eEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l83jwH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l8xdIH5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_mWKNgn5eEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l8xdIH5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_mWMCsX5eEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l8xdIH5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_mWOe8X5eEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l8xdIH5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_mWQ7MX5eEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l8xdIH5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_mWXo4H5eEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l81ukH5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_mWZeEn5eEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l81ukH5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_mWb6UX5eEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l81ukH5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_r7sSoH5eEdujQd6ed5A7Ug" supplier="_r7dpIX5eEdujQd6ed5A7Ug" client="_r7Q00H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_r7uu4X5eEdujQd6ed5A7Ug" supplier="_r7h6kH5eEdujQd6ed5A7Ug" client="_r7Q00H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_r72DoH5eEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_r8qjAH5eEdujQd6ed5A7Ug" supplier="_r7dpIX5eEdujQd6ed5A7Ug" client="_r8CQ4H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_r8x3wH5eEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_r9GA0H5eEdujQd6ed5A7Ug" supplier="_r9ELoH5eEdujQd6ed5A7Ug" client="_r8824H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_r9IdEn5eEdujQd6ed5A7Ug" supplier="_r7dpIX5eEdujQd6ed5A7Ug" client="_r8824H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_r9Px0H5eEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_r9lJAH5eEdujQd6ed5A7Ug" supplier="_r7dpIX5eEdujQd6ed5A7Ug" client="_r9WfgH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_r9nlQn5eEdujQd6ed5A7Ug" supplier="_r7h6kH5eEdujQd6ed5A7Ug" client="_r9WfgH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_r9wIIH5eEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_r-RskH5eEdujQd6ed5A7Ug" supplier="_r-P3YH5eEdujQd6ed5A7Ug" client="_r-JwwH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_r-Thwn5eEdujQd6ed5A7Ug" supplier="_r-RFgH5eEdujQd6ed5A7Ug" client="_r-JwwH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_r-cEoH5eEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_r-l1oH5eEdujQd6ed5A7Ug" supplier="_r-kngH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_r-tKYH5eEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_r_vsMH5eEdujQd6ed5A7Ug" supplier="_r7dpIX5eEdujQd6ed5A7Ug" client="_r-yp8H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_r_xhYn5eEdujQd6ed5A7Ug" supplier="_r_MSkH5eEdujQd6ed5A7Ug" client="_r-yp8H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_r_z9on5eEdujQd6ed5A7Ug" supplier="_r-kngH5eEdujQd6ed5A7Ug" client="_r-yp8H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_r_1y0n5eEdujQd6ed5A7Ug" supplier="_r_OHwH5eEdujQd6ed5A7Ug" client="_r-yp8H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_r_3oAX5eEdujQd6ed5A7Ug" supplier="_r_OHwH5eEdujQd6ed5A7Ug" client="_r-yp8H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_sAAK4H5eEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_sBMdsX5eEdujQd6ed5A7Ug" supplier="_sAmAwH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_sBOS4X5eEdujQd6ed5A7Ug" supplier="_sAmAwH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_sBQIEn5eEdujQd6ed5A7Ug" supplier="_sAodAH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_sBSkUX5eEdujQd6ed5A7Ug" supplier="_r_OHwH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_sBUZgX5eEdujQd6ed5A7Ug" supplier="_r_OHwH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_sBWOsn5eEdujQd6ed5A7Ug" supplier="_r-P3YH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_sBYq8n5eEdujQd6ed5A7Ug" supplier="_r7h6kH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_sBagIn5eEdujQd6ed5A7Ug" supplier="_sBG-IH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_sBcVUX5eEdujQd6ed5A7Ug" supplier="_sBHlMH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_sBexkn5eEdujQd6ed5A7Ug" supplier="_r-yp8H5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_sBhN0H5eEdujQd6ed5A7Ug" supplier="_r7Q00H5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_sBjDAn5eEdujQd6ed5A7Ug" supplier="_sA-bQH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_sBmGUH5eEdujQd6ed5A7Ug" supplier="_r-JwwH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_sBn7gn5eEdujQd6ed5A7Ug" supplier="_r-JwwH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_sBqXwX5eEdujQd6ed5A7Ug" supplier="_r8CQ4H5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_sBsM8X5eEdujQd6ed5A7Ug" supplier="_r8CQ4H5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_sBuCIn5eEdujQd6ed5A7Ug" supplier="_r-0fIH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_sB6PYH5eEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_sHONMH5eEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l83jwH5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_sH6wwH5eEdujQd6ed5A7Ug" supplier="_r7dpIX5eEdujQd6ed5A7Ug" client="_r-0fIH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_sH9NAn5eEdujQd6ed5A7Ug" supplier="_r_MSkH5eEdujQd6ed5A7Ug" client="_r-0fIH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_sH_CMn5eEdujQd6ed5A7Ug" supplier="_r-kngH5eEdujQd6ed5A7Ug" client="_r-0fIH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_sIA3Yn5eEdujQd6ed5A7Ug" supplier="_r_OHwH5eEdujQd6ed5A7Ug" client="_r-0fIH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_sIDToX5eEdujQd6ed5A7Ug" supplier="_r_OHwH5eEdujQd6ed5A7Ug" client="_r-0fIH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_sILPcH5eEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l83jwH5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_9V9KEH5eEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_9fSFMH5eEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_-avn4H5eEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iKuSYH5fEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l83jwH5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iK21QH5fEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l83jwH5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iLCbcH5fEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l83jwH5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iLfucH5fEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l83jwH5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iLpfcH5fEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l83jwH5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iL0ekH5fEdujQd6ed5A7Ug" supplier="_iLu_AH5fEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iL2TwX5fEdujQd6ed5A7Ug" supplier="_iKVQ0H5fEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iL4wAH5fEdujQd6ed5A7Ug" supplier="_iJ2vsH5fEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iL6lMn5fEdujQd6ed5A7Ug" supplier="_iJx3MX5fEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iL8aYn5fEdujQd6ed5A7Ug" supplier="_sBG-IH5eEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iL-2oX5fEdujQd6ed5A7Ug" supplier="_iJ06gH5fEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iMAr0n5fEdujQd6ed5A7Ug" supplier="_r7h6kH5eEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iMChAn5fEdujQd6ed5A7Ug" supplier="_iLjY0H5fEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iMEWMn5fEdujQd6ed5A7Ug" supplier="_iJ4k4H5fEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iMGycX5fEdujQd6ed5A7Ug" supplier="_sAnO4H5eEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iMInon5fEdujQd6ed5A7Ug" supplier="_iJxQIH5fEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iMKc0n5fEdujQd6ed5A7Ug" supplier="_iJ1hkH5fEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iMM5En5fEdujQd6ed5A7Ug" supplier="_iKeawH5fEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iMOuQn5fEdujQd6ed5A7Ug" supplier="_sA-bQH5eEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iMQjcn5fEdujQd6ed5A7Ug" supplier="_r_OHwH5eEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iMSYoX5fEdujQd6ed5A7Ug" supplier="_r_OHwH5eEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iMU04X5fEdujQd6ed5A7Ug" supplier="_iKC88X5fEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iMWqEn5fEdujQd6ed5A7Ug" supplier="_iKUCsH5fEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iMYfQn5fEdujQd6ed5A7Ug" supplier="_iLtw4H5fEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iMa7gH5fEdujQd6ed5A7Ug" supplier="_r7Q00H5eEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iMcwsn5fEdujQd6ed5A7Ug" supplier="_r_MSkH5eEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iMel4n5fEdujQd6ed5A7Ug" supplier="_iJ5L8X5fEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iMgbEn5fEdujQd6ed5A7Ug" supplier="_r9XtoH5eEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iMi3Un5fEdujQd6ed5A7Ug" supplier="_iJ390H5fEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iMksgn5fEdujQd6ed5A7Ug" supplier="_r8CQ4H5eEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iMmhsn5fEdujQd6ed5A7Ug" supplier="_r7dpIX5eEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iMo98X5fEdujQd6ed5A7Ug" supplier="_r7dpIX5eEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iMqzIn5fEdujQd6ed5A7Ug" supplier="_r9WfgH5eEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iMsoUX5fEdujQd6ed5A7Ug" supplier="_r9WfgH5eEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iMudgn5fEdujQd6ed5A7Ug" supplier="_r-kngH5eEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iM1LMH5fEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iZqtUH5fEdujQd6ed5A7Ug" supplier="_iKUCsH5fEdujQd6ed5A7Ug" client="_iHkQsH5fEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iZtJkn5fEdujQd6ed5A7Ug" supplier="_r7dpIX5eEdujQd6ed5A7Ug" client="_iHkQsH5fEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iZu-wn5fEdujQd6ed5A7Ug" supplier="_r7dpIX5eEdujQd6ed5A7Ug" client="_iHkQsH5fEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iZxbAX5fEdujQd6ed5A7Ug" supplier="_sAnO4H5eEdujQd6ed5A7Ug" client="_iHkQsH5fEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iZzQMn5fEdujQd6ed5A7Ug" supplier="_r7h6kH5eEdujQd6ed5A7Ug" client="_iHkQsH5fEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iZ1FYn5fEdujQd6ed5A7Ug" supplier="_r-kngH5eEdujQd6ed5A7Ug" client="_iHkQsH5fEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iZ3hoX5fEdujQd6ed5A7Ug" supplier="_sBG-IH5eEdujQd6ed5A7Ug" client="_iHkQsH5fEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iZ5W0X5fEdujQd6ed5A7Ug" supplier="_r7Q00H5eEdujQd6ed5A7Ug" client="_iHkQsH5fEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iZ7MAn5fEdujQd6ed5A7Ug" supplier="_r9XtoH5eEdujQd6ed5A7Ug" client="_iHkQsH5fEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iaDH0H5fEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_ibYkkH5fEdujQd6ed5A7Ug" supplier="_iKVQ0H5fEdujQd6ed5A7Ug" client="_r-P3YH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_ibaZwn5fEdujQd6ed5A7Ug" supplier="_iJx3MX5fEdujQd6ed5A7Ug" client="_r-P3YH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_ibc2AH5fEdujQd6ed5A7Ug" supplier="_iJ390H5fEdujQd6ed5A7Ug" client="_r-P3YH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iberMn5fEdujQd6ed5A7Ug" supplier="_sAnO4H5eEdujQd6ed5A7Ug" client="_r-P3YH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_ibggYn5fEdujQd6ed5A7Ug" supplier="_iKeawH5fEdujQd6ed5A7Ug" client="_r-P3YH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_ibi8oX5fEdujQd6ed5A7Ug" supplier="_iJ1hkH5fEdujQd6ed5A7Ug" client="_r-P3YH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_ibkx0n5fEdujQd6ed5A7Ug" supplier="_iJxQIH5fEdujQd6ed5A7Ug" client="_r-P3YH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_ibmnAn5fEdujQd6ed5A7Ug" supplier="_iJ5L8X5fEdujQd6ed5A7Ug" client="_r-P3YH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_ibpDQH5fEdujQd6ed5A7Ug" supplier="_sA-bQH5eEdujQd6ed5A7Ug" client="_r-P3YH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_ibq4cn5fEdujQd6ed5A7Ug" supplier="_iKC88X5fEdujQd6ed5A7Ug" client="_r-P3YH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_ibston5fEdujQd6ed5A7Ug" supplier="_iJ06gH5fEdujQd6ed5A7Ug" client="_r-P3YH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_ibui0n5fEdujQd6ed5A7Ug" supplier="_iJ2vsH5fEdujQd6ed5A7Ug" client="_r-P3YH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_ibw_EX5fEdujQd6ed5A7Ug" supplier="_r8CQ4H5eEdujQd6ed5A7Ug" client="_r-P3YH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_iby0Qn5fEdujQd6ed5A7Ug" supplier="_iJ4k4H5fEdujQd6ed5A7Ug" client="_r-P3YH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_ib13kH5fEdujQd6ed5A7Ug" supplier="_r7dpIX5eEdujQd6ed5A7Ug" client="_r-P3YH5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_ib7XIH5fEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l83jwH5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_lnc38H5fEdujQd6ed5A7Ug" supplier="_r_OHwH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_lngiUX5fEdujQd6ed5A7Ug" supplier="_sAmAwH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_lni-kH5fEdujQd6ed5A7Ug" supplier="_r-yp8H5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_lnkzwX5fEdujQd6ed5A7Ug" supplier="_r8CQ4H5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_lnsIgH5fEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_ln4VwH5fEdujQd6ed5A7Ug" supplier="_r_OHwH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_ln8AIX5fEdujQd6ed5A7Ug" supplier="_sAmAwH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_ln-cYX5fEdujQd6ed5A7Ug" supplier="_r-yp8H5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_loA4oH5fEdujQd6ed5A7Ug" supplier="_r8CQ4H5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_loG_QH5fEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_9vB78H5fEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_-K0gEH5fEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_-nSZoH5fEdujQd6ed5A7Ug" supplier="_r_OHwH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_-nUO0X5fEdujQd6ed5A7Ug" supplier="_sAmAwH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_-nWrEH5fEdujQd6ed5A7Ug" supplier="_r-yp8H5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_-nYgQX5fEdujQd6ed5A7Ug" supplier="_r8CQ4H5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_-nfN8H5fEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_BYTvwH5gEdujQd6ed5A7Ug" supplier="_r_OHwH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_BYWMAX5gEdujQd6ed5A7Ug" supplier="_sAmAwH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_BYYBMX5gEdujQd6ed5A7Ug" supplier="_r-yp8H5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_BYadcH5gEdujQd6ed5A7Ug" supplier="_r8CQ4H5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
-  <packagedElement xmi:type="uml:Usage" xmi:id="_BYhLIH5gEdujQd6ed5A7Ug">
-    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
-    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
-  </packagedElement>
-</uml:Model>
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/extension/GOMExtensionFactory.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/extension/GOMExtensionFactory.java
deleted file mode 100644
index eddcfdf..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/extension/GOMExtensionFactory.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core.extension;
-
-import java.util.List;
-
-import javax.xml.namespace.QName;
-
-import org.apache.lucene.gdata.gom.GOMExtension;
-import org.apache.lucene.gdata.gom.GOMNamespace;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public interface GOMExtensionFactory {
-
-	public abstract List<GOMNamespace> getNamespaces();
-
-	public abstract GOMExtension canHandleExtensionElement(QName name);
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/utils/AtomParserUtils.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/utils/AtomParserUtils.java
deleted file mode 100644
index 4154942..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/utils/AtomParserUtils.java
+++ /dev/null
@@ -1,174 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core.utils;
-
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.util.regex.Pattern;
-
-import org.apache.lucene.gdata.gom.AtomMediaType;
-import org.apache.lucene.gdata.gom.GOMLink;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class AtomParserUtils {
-	private static final Pattern ATOM_MEDIA_TYPE_PATTERN = Pattern
-			.compile(".+/.+");
-
-	/**
-	 * Replaces all xml character with the corresponding entity.
-	 * 
-	 * <ul>
-	 * <li>&lt;!ENTITY lt &quot;&amp;#38;#60;&quot;&gt;</li>
-	 * <li>&lt;!ENTITY gt &quot;&amp;#62;&quot;&gt;</li>
-	 * <li>&lt;!ENTITY amp &quot;&amp;#38;#38;&quot;&gt;</li>
-	 * <li>&lt;!ENTITY apos &quot;&amp;#39;&quot;&gt;</li>
-	 * <li>&lt;!ENTITY quot &quot;&amp;#34;&quot;&gt;</li>
-	 * </ul>
-	 * 
-	 * see <a
-	 * href="http://www.w3.org/TR/2006/REC-xml-20060816/#intern-replacement">W3C
-	 * specification</a>
-	 * 
-	 * @param aString -
-	 *            a string may container xml characters like '<'
-	 * @return the input string with escaped xml characters
-	 */
-	public static String escapeXMLCharacter(String aString) {
-		StringBuilder builder = new StringBuilder();
-		char[] cs = aString.toCharArray();
-		for (int i = 0; i < cs.length; i++) {
-			switch (cs[i]) {
-			case '<':
-				builder.append("&lt;");
-				break;
-			case '>':
-				builder.append("&gt;");
-				break;
-			case '"':
-				builder.append("&quot;");
-				break;
-			case '\'':
-				builder.append("&apos;");
-				break;
-			case '&':
-				builder.append("&amp;");
-				break;
-			case '\0':
-				// this breaks some xml serializer like soap serializer -->
-				// remove it
-				break;
-			default:
-				builder.append(cs[i]);
-			}
-		}
-
-		return builder.toString();
-
-	}
-
-	/**
-	 * @param aMediaType
-	 * @return
-	 */
-	public static boolean isAtomMediaType(String aMediaType) {
-		return (aMediaType == null || aMediaType.length() < 3) ? false
-				: ATOM_MEDIA_TYPE_PATTERN.matcher(aMediaType).matches();
-	}
-
-	/**
-	 * @param aMediaType
-	 * @return
-	 */
-	public static AtomMediaType getAtomMediaType(String aMediaType) {
-		if (aMediaType == null || !isAtomMediaType(aMediaType))
-			throw new IllegalArgumentException(
-					"aMediaType must be a media type and  not be null ");
-		if (aMediaType.endsWith("+xml") || aMediaType.endsWith("/xml"))
-			return AtomMediaType.XML;
-		if (aMediaType.startsWith("text/"))
-			return AtomMediaType.TEXT;
-		return AtomMediaType.BINARY;
-	}
-
-	/**
-	 * @param xmlBase
-	 * @param atomUri
-	 * @return
-	 * @throws URISyntaxException
-	 */
-	public static String getAbsolutAtomURI(String xmlBase, String atomUri)
-			throws URISyntaxException {
-		if (atomUri == null)
-			throw new IllegalArgumentException("atomUri must not be null");
-		if (atomUri.startsWith("www."))
-			atomUri = "http://" + atomUri;
-		URI aUri = new URI(atomUri);
-
-		if (xmlBase == null || xmlBase.length() == 0) {
-			if (!aUri.isAbsolute()) {
-				throw new URISyntaxException(atomUri,
-						" -- no xml:base specified atom uri must be an absolute url");
-			}
-		}
-
-		return atomUri;
-	}
-
-	/**
-	 * Compares two links with rel attribute "alternate" Checks if href and type
-	 * are equal
-	 * 
-	 * @param left -
-	 *            left link to compare
-	 * @param right -
-	 *            right link to compare
-	 * @return <code>true</code> if and only if href and type are equal,
-	 *         otherwise <code>false</code>
-	 */
-	public static boolean compareAlternateLinks(GOMLink left, GOMLink right) {
-		if ((left.getType() == null) ^ right.getType() == null
-				|| (left.getType() == null && right.getType() == null)) {
-			return false;
-		} else {
-			if (!left.getType().equalsIgnoreCase(right.getType()))
-				return false;
-		}
-
-		if (((left.getHrefLang() == null) ^ right.getHrefLang() == null)
-				|| (left.getHrefLang() == null && right.getHrefLang() == null)) {
-			return false;
-		} else {
-			if (!left.getHrefLang().equalsIgnoreCase(right.getHrefLang()))
-				return false;
-		}
-		return true;
-
-	}
-
-	public static void main(String[] args) {
-		// String s = new String(
-		// "<!ENTITY lt \"&#38;#60;\"><!ENTITY gt \"&#62;\"><!ENTITY amp
-		// \"&#38;#38;\"><!ENTITY apos \"&#39;\"><!ENTITY quot \"&#34;\">");
-		// System.out.println(escapeXMLCharacter(s));
-		//		
-		System.out.println(isAtomMediaType("t/h"));
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/utils/GOMUtils.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/utils/GOMUtils.java
deleted file mode 100644
index 28d374f..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/core/utils/GOMUtils.java
+++ /dev/null
@@ -1,424 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core.utils;
-
-import java.math.BigDecimal;
-import java.util.Calendar;
-import java.util.List;
-import java.util.TimeZone;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-import org.apache.lucene.gdata.gom.ContentType;
-import org.apache.lucene.gdata.gom.GOMAttribute;
-import org.apache.lucene.gdata.gom.GOMLink;
-import org.apache.lucene.gdata.gom.GOMNamespace;
-import org.apache.lucene.gdata.gom.core.GDataParseException;
-import org.apache.lucene.gdata.gom.core.GOMAttributeImpl;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class GOMUtils {
-
-	/*
-	 * Possible values 2003-12-13T18:30:02Z 2003-12-13T18:30:02.25Z
-	 * 2003-12-13T18:30:02+01:00 2003-12-13T18:30:02.25+01:00
-	 */
-	private static final Pattern RFC3339_DATE_PATTERN = Pattern.compile(
-			"(\\d\\d\\d\\d)" + // #YEAR
-					"\\-(\\d\\d)" + // #MONTH
-					"\\-(\\d\\d)[Tt]" + // #DAY
-					"(\\d\\d)" + // #HOURS
-					":(\\d\\d)" + // #MINUTES
-					":(\\d\\d)" + // #SECONDS
-					"(\\.(\\d+))?" + // #MILLISorless
-					"([Zz]|((\\+|\\-)(\\d\\d):(\\d\\d)))?"// #TIMEZONESHIFT
-			, Pattern.COMMENTS);
-
-	static final String ATTRIBUTE_TYPE = "type";
-
-	static final GOMAttribute TEXT_TYPE;
-
-	static final GOMAttribute HTML_TYPE;
-
-	static final GOMAttribute XHTML_TYPE;
-
-	static final GOMAttribute TEXT_TYPE_DEFAULT_NS;
-
-	static final GOMAttribute HTML_TYPE_DEFAULT_NS;
-
-	static final GOMAttribute XHTML_TYPE_DEFAULT_NS;
-
-	static {
-		TEXT_TYPE = new GOMAttributeImpl(GOMNamespace.ATOM_NS_URI,
-				GOMNamespace.ATOM_NS_PREFIX, ATTRIBUTE_TYPE, ContentType.TEXT
-						.name().toLowerCase());
-		HTML_TYPE = new GOMAttributeImpl(GOMNamespace.ATOM_NS_URI,
-				GOMNamespace.ATOM_NS_PREFIX, ATTRIBUTE_TYPE, ContentType.HTML
-						.name().toLowerCase());
-		XHTML_TYPE = new GOMAttributeImpl(GOMNamespace.ATOM_NS_URI,
-				GOMNamespace.ATOM_NS_PREFIX, ATTRIBUTE_TYPE, ContentType.XHTML
-						.name().toLowerCase());
-
-		TEXT_TYPE_DEFAULT_NS = new GOMAttributeImpl(ATTRIBUTE_TYPE,
-				ContentType.TEXT.name().toLowerCase());
-		HTML_TYPE_DEFAULT_NS = new GOMAttributeImpl(ATTRIBUTE_TYPE,
-				ContentType.HTML.name().toLowerCase());
-		XHTML_TYPE_DEFAULT_NS = new GOMAttributeImpl(ATTRIBUTE_TYPE,
-				ContentType.XHTML.name().toLowerCase());
-
-	}
-
-	/**
-	 * @param type
-	 * @return
-	 */
-	public static GOMAttribute getAttributeByContentType(ContentType type) {
-		switch (type) {
-		case HTML:
-			return HTML_TYPE;
-		case XHTML:
-			return XHTML_TYPE;
-
-		default:
-			return TEXT_TYPE;
-		}
-
-	}
-
-	/**
-	 * @param type
-	 * @return
-	 */
-	public static GOMAttribute getAttributeByContentTypeDefaultNs(
-			ContentType type) {
-		if (type == null)
-			return TEXT_TYPE_DEFAULT_NS;
-		switch (type) {
-		case HTML:
-			return HTML_TYPE_DEFAULT_NS;
-		case XHTML:
-			return XHTML_TYPE_DEFAULT_NS;
-
-		default:
-			return TEXT_TYPE_DEFAULT_NS;
-		}
-
-	}
-
-	/**
-	 * Builds a atom namespace attribute
-	 * 
-	 * @param aValue
-	 *            attribute value
-	 * @param aName
-	 *            attribute name
-	 * @return a GOMAttribute
-	 */
-	public static GOMAttribute buildAtomAttribute(String aValue, String aName) {
-		return new GOMAttributeImpl(GOMNamespace.ATOM_NS_URI,
-				GOMNamespace.ATOM_NS_PREFIX, aName, aValue);
-	}
-
-	/**
-	 * @param aValue
-	 * @param aName
-	 * @return
-	 */
-	public static GOMAttribute buildDefaultNamespaceAttribute(String aValue,
-			String aName) {
-		return new GOMAttributeImpl(aName, aValue);
-	}
-
-	/**
-	 * @param aValue
-	 * @param aName
-	 * @return
-	 */
-	public static GOMAttribute buildXMLNamespaceAttribute(String aValue,
-			String aName) {
-		return new GOMAttributeImpl(GOMNamespace.XML_NS_URI,
-				GOMNamespace.XML_NS_PREFIX, aName, aValue);
-	}
-
-	/**
-	 * @param aString
-	 * @return
-	 */
-	public static boolean isRfc3339DateFormat(String aString) {
-		Matcher aMatcher = RFC3339_DATE_PATTERN.matcher(aString);
-		return aMatcher.matches();
-	}
-
-	/**
-	 * @param aString
-	 * @return
-	 */
-	public static long parseRfc3339DateFormat(String aString) {
-		if (aString == null)
-			throw new IllegalArgumentException(
-					"Date-Time String must not be null");
-		Matcher aMatcher = RFC3339_DATE_PATTERN.matcher(aString);
-
-		if (!aMatcher.matches()) {
-			throw new GDataParseException(
-					"Invalid RFC3339 date / time pattern -- " + aString);
-		}
-		int grCount = aMatcher.groupCount();
-		if (grCount > 13)
-			throw new GDataParseException(
-					"Invalid RFC3339 date / time pattern -- " + aString);
-
-		Integer timeZoneShift = null;
-		Calendar dateTime = null;
-		try {
-
-			if (aMatcher.group(9) == null) {
-				// skip time zone
-			} else if (aMatcher.group(9).equalsIgnoreCase("Z")) {
-				timeZoneShift = new Integer(0);
-			} else {
-				timeZoneShift = new Integer((Integer
-						.valueOf(aMatcher.group(12)) * 60 + Integer
-						.valueOf(aMatcher.group(13))));
-				if (aMatcher.group(11).equals("-")) {
-					timeZoneShift = new Integer(-timeZoneShift.intValue());
-				}
-			}
-
-			dateTime = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
-			;
-			dateTime.clear();
-			dateTime.set(Integer.valueOf(aMatcher.group(1)), Integer
-					.valueOf(aMatcher.group(2)) - 1, Integer.valueOf(aMatcher
-					.group(3)), Integer.valueOf(aMatcher.group(4)), Integer
-					.valueOf(aMatcher.group(5)), Integer.valueOf(aMatcher
-					.group(6)));
-			// seconds with milliseconds
-			if (aMatcher.group(8) != null && aMatcher.group(8).length() > 0) {
-
-				dateTime.set(Calendar.MILLISECOND, new BigDecimal("0."/*
-																		 * use
-																		 * big
-																		 * dec
-																		 * this
-																		 * could
-																		 * be
-																		 * big!!
-																		 */
-						+ aMatcher.group(8)).movePointRight(3).intValue());
-			}
-		} catch (NumberFormatException e) {
-			throw new GDataParseException(
-					"Invalid RFC3339 date / time pattern -- " + aString, e);
-		}
-
-		long retVal = dateTime.getTimeInMillis();
-		if (timeZoneShift != null) {
-			retVal -= timeZoneShift.intValue() * 60000;
-		}
-
-		return retVal;
-	}
-
-	/**
-	 * @param aMillisecondLong
-	 * @return
-	 */
-	public static String buildRfc3339DateFormat(long aMillisecondLong) {
-		Calendar instance = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
-		instance.setTimeInMillis(aMillisecondLong);
-
-		StringBuilder builder = new StringBuilder();
-		// 2003-12-13T18:30:02.25+01:00
-		int time = 0;
-		time = instance.get(Calendar.YEAR);
-		if (time < 1000)
-			builder.append("0");
-		if (time < 100)
-			builder.append("0");
-		if (time < 10)
-			builder.append("0");
-		builder.append(time);
-		builder.append('-');
-		time = instance.get(Calendar.MONTH);
-		if (time < 10)
-			builder.append(0);
-		builder.append(time);
-		builder.append('-');
-		time = instance.get(Calendar.DAY_OF_MONTH);
-		if (time < 10)
-			builder.append(0);
-		builder.append(time);
-		builder.append('T');
-		time = instance.get(Calendar.HOUR_OF_DAY);
-		if (time < 10)
-			builder.append(0);
-		builder.append(time);
-		builder.append(':');
-		time = instance.get(Calendar.MINUTE);
-		if (time < 10)
-			builder.append(0);
-		builder.append(time);
-		builder.append(':');
-		time = instance.get(Calendar.SECOND);
-		if (time < 10)
-			builder.append(0);
-		builder.append(time);
-		builder.append('.');
-		builder.append(instance.get(Calendar.MILLISECOND));
-		// this is always GMT offset -> 0
-		builder.append('Z');
-
-		return builder.toString();
-	}
-
-	/**
-	 * @param aMillisecondLong
-	 * @return
-	 */
-	public static String buildRfc822Date(long aMillisecondLong) {
-		/*
-		 * Rather implement it for a special case as use SDF. SDF is very
-		 * expensive to create and not thread safe so it should be synchronized
-		 * of pooled
-		 */
-		Calendar instance = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
-		instance.setTimeInMillis(aMillisecondLong);
-
-		StringBuilder builder = new StringBuilder();
-		// Sun, 06 Aug 2006 00:53:49 +0000
-		// EEE, dd MMM yyyy HH:mm:ss Z
-
-		switch (instance.get(Calendar.DAY_OF_WEEK)) {
-		case Calendar.SUNDAY:
-			builder.append("Sun");
-			break;
-		case Calendar.MONDAY:
-			builder.append("Mon");
-			break;
-		case Calendar.TUESDAY:
-			builder.append("Tue");
-			break;
-		case Calendar.WEDNESDAY:
-			builder.append("Wed");
-			break;
-		case Calendar.THURSDAY:
-			builder.append("Thu");
-			break;
-		case Calendar.FRIDAY:
-			builder.append("Fri");
-			break;
-		case Calendar.SATURDAY:
-			builder.append("Sat");
-			break;
-		default:
-			break;
-		}
-		builder.append(',');
-		builder.append(' ');
-
-		int time = 0;
-		time = instance.get(Calendar.DAY_OF_MONTH);
-		if (time < 10)
-			builder.append(0);
-		builder.append(time);
-		builder.append(' ');
-		switch (instance.get(Calendar.MONTH)) {
-		case Calendar.JANUARY:
-			builder.append("Jan");
-			break;
-		case Calendar.FEBRUARY:
-			builder.append("Feb");
-			break;
-		case Calendar.MARCH:
-			builder.append("Mar");
-			break;
-		case Calendar.APRIL:
-			builder.append("Apr");
-			break;
-		case Calendar.MAY:
-			builder.append("May");
-			break;
-		case Calendar.JUNE:
-			builder.append("Jun");
-			break;
-		case Calendar.JULY:
-			builder.append("Jul");
-			break;
-		case Calendar.AUGUST:
-			builder.append("Aug");
-			break;
-		case Calendar.SEPTEMBER:
-			builder.append("Sep");
-			break;
-		case Calendar.OCTOBER:
-			builder.append("Oct");
-			break;
-		case Calendar.NOVEMBER:
-			builder.append("Nov");
-			break;
-		case Calendar.DECEMBER:
-			builder.append("Dec");
-			break;
-
-		default:
-			break;
-		}
-		builder.append(' ');
-		time = instance.get(Calendar.YEAR);
-		if (time < 1000)
-			builder.append("0");
-		if (time < 100)
-			builder.append("0");
-		if (time < 10)
-			builder.append("0");
-		builder.append(time);
-		builder.append(' ');
-
-		time = instance.get(Calendar.HOUR_OF_DAY);
-		if (time < 10)
-			builder.append(0);
-		builder.append(time);
-		builder.append(':');
-		time = instance.get(Calendar.MINUTE);
-		if (time < 10)
-			builder.append(0);
-		builder.append(time);
-		builder.append(':');
-		time = instance.get(Calendar.SECOND);
-		if (time < 10)
-			builder.append(0);
-		builder.append(time);
-
-		// this is always GMT offset -> 0
-		builder.append(" +0000");
-		return builder.toString();
-	}
-
-	public GOMLink getHtmlLink(List<GOMLink> links) {
-		for (GOMLink link : links) {
-			if ((link.getRel() == null || link.getRel().equals("alternate"))
-					&& (link.getType() == null || link.getType()
-							.equalsIgnoreCase("html")))
-				return link;
-		}
-		return null;
-	}
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/writer/GOMOutputWriter.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/writer/GOMOutputWriter.java
deleted file mode 100644
index ab7a93d..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/writer/GOMOutputWriter.java
+++ /dev/null
@@ -1,199 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.writer;
-
-import java.util.List;
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.GOMAttribute;
-import org.apache.lucene.gdata.gom.GOMNamespace;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public interface GOMOutputWriter {
-
-	/**
-	 * Writes a simple element with full namespace
-	 * 
-	 * @param aName -
-	 *            element QName
-	 * @param aList -
-	 *            attribute list
-	 * @param aValue -
-	 *            character value
-	 * @throws XMLStreamException -
-	 *             if a write exception occurs
-	 */
-	public abstract void writeSimpleXMLElement(QName aName,
-			List<GOMAttribute> aList, String aValue) throws XMLStreamException;
-
-	/**
-	 * Writes a simple element with full namespace
-	 * 
-	 * @param aName -
-	 *            element QName
-	 * @param aAttribute -
-	 *            attribute
-	 * @param aValue -
-	 *            character value
-	 * @throws XMLStreamException -
-	 *             if a write exception occurs
-	 */
-	public abstract void writeSimpleXMLElement(QName aName, String aValue,
-			GOMAttribute aAttribute) throws XMLStreamException;
-
-	/**
-	 * Writes a simple element with full namespace
-	 * 
-	 * @param aName -
-	 *            the local name of the element
-	 * @param aAttribute -
-	 *            attribute
-	 * @param aValue -
-	 *            character value
-	 * @throws XMLStreamException -
-	 *             if a write exception occurs
-	 */
-	public abstract void writeSimpleXMLElement(String aName, String aValue,
-			GOMAttribute aAttribute) throws XMLStreamException;
-
-	/**
-	 * Writes a simple element with default namespace
-	 * 
-	 * @param aName -
-	 *            elements name
-	 * @param aList -
-	 *            attribute list
-	 * @param aValue -
-	 *            character value
-	 * @throws XMLStreamException -
-	 *             if a write exception occurs
-	 */
-	public abstract void writeSimpleXMLElement(String aName,
-			List<GOMAttribute> aList, String aValue) throws XMLStreamException;
-
-	/**
-	 * writes a attribute with the attribute namespace Uri
-	 * 
-	 * @param attribute -
-	 *            the attribute
-	 * @throws XMLStreamException -
-	 *             if a write exception occurs
-	 */
-	public abstract void writeAttribute(GOMAttribute attribute)
-			throws XMLStreamException;
-
-	/**
-	 * @param aName
-	 * @param aList
-	 * @throws XMLStreamException
-	 */
-	public abstract void writeStartElement(String aName,
-			List<GOMAttribute> aList) throws XMLStreamException;
-
-	/**
-	 * @param aName
-	 * @param aAttribute
-	 * @throws XMLStreamException
-	 */
-	public abstract void writeStartElement(String aName, GOMAttribute aAttribute)
-			throws XMLStreamException;
-
-	/**
-	 * @param aName
-	 * @throws XMLStreamException
-	 */
-	public abstract void writeStartElement(String aName)
-			throws XMLStreamException;
-
-	/**
-	 * @param aName
-	 * @param aList
-	 * @throws XMLStreamException
-	 */
-	public abstract void writeStartElement(QName aName, List<GOMAttribute> aList)
-			throws XMLStreamException;
-
-	/**
-	 * @throws XMLStreamException
-	 */
-	public abstract void writeEndElement() throws XMLStreamException;
-
-	/**
-	 * @param aContent
-	 * @throws XMLStreamException
-	 */
-	public abstract void writeContent(String aContent)
-			throws XMLStreamException;
-
-	/**
-	 * @param aContent
-	 * @throws XMLStreamException
-	 */
-	public abstract void writeContentUnescaped(String aContent)
-			throws XMLStreamException;
-
-	/**
-	 * @param aNameSpace
-	 * @throws XMLStreamException
-	 */
-	public abstract void writeDefaultNamespace(GOMNamespace aNameSpace)
-			throws XMLStreamException;
-
-	/**
-	 * @param aNameSpace
-	 * @throws XMLStreamException
-	 */
-	public abstract void writeNamespace(GOMNamespace aNameSpace)
-			throws XMLStreamException;
-
-	/**
-	 * @param aString
-	 * @param aString2
-	 * @throws XMLStreamException
-	 */
-	public abstract void writeStartDocument(String aString, String aString2)
-			throws XMLStreamException;
-
-	/**
-	 * Writes a end element tag according to the start element tag
-	 * 
-	 * @throws XMLStreamException -
-	 *             if no start tag has been written or the element stack points
-	 *             to a different element
-	 */
-	public abstract void writeEndDocument() throws XMLStreamException;
-
-	/**
-	 * Flush the GOMWriter
-	 * 
-	 * @throws XMLStreamException
-	 */
-	public abstract void flush() throws XMLStreamException;
-
-	/**
-	 * Closes the GOM Writer
-	 * 
-	 * @throws XMLStreamException
-	 */
-	public abstract void close() throws XMLStreamException;
-
-}
\ No newline at end of file
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/writer/GOMStaxWriter.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/writer/GOMStaxWriter.java
deleted file mode 100644
index db95f12..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/writer/GOMStaxWriter.java
+++ /dev/null
@@ -1,302 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.writer;
-
-import java.io.OutputStream;
-import java.io.OutputStreamWriter;
-import java.io.UnsupportedEncodingException;
-import java.io.Writer;
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.FactoryConfigurationError;
-import javax.xml.stream.XMLOutputFactory;
-import javax.xml.stream.XMLStreamException;
-import javax.xml.stream.XMLStreamWriter;
-
-import org.apache.lucene.gdata.gom.GOMAttribute;
-import org.apache.lucene.gdata.gom.GOMNamespace;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class GOMStaxWriter implements GOMOutputWriter {
-	private static final String STAX_OUTPUTFACTORY_KEY = "org.apache.lucene.gdata.gom.writer.GOMXmlOutputFactory";
-
-	private final Set<GOMNamespace> namespaceSet = new HashSet<GOMNamespace>(16);
-
-	private final XMLStreamWriter writer;
-	static {
-		/*
-		 * set the system property to make sure the factory will be found
-		 */
-		String property = System.getProperty(STAX_OUTPUTFACTORY_KEY);
-		if (property == null)
-			System.setProperty(STAX_OUTPUTFACTORY_KEY, STAX_OUTPUTFACTORY_KEY);
-	}
-
-	/**
-	 * @param aOutputStream
-	 * @param encoding
-	 * @throws UnsupportedEncodingException
-	 * @throws XMLStreamException
-	 * @throws FactoryConfigurationError
-	 */
-	public GOMStaxWriter(final OutputStream aOutputStream, String encoding)
-			throws UnsupportedEncodingException, XMLStreamException,
-			FactoryConfigurationError {
-		this(new OutputStreamWriter(aOutputStream, encoding));
-	}
-
-	/**
-	 * Class constructor
-	 * 
-	 * 
-	 * @param aOutputStream -
-	 *            a output stream to write the xml stream to.
-	 * @throws XMLStreamException -
-	 *             if a write exception occurs
-	 * @throws FactoryConfigurationError -
-	 *             if XMLOutputFactory throws an exception
-	 * 
-	 */
-	public GOMStaxWriter(final OutputStream aOutputStream)
-			throws XMLStreamException, FactoryConfigurationError {
-		this(new OutputStreamWriter(aOutputStream));
-	}
-
-	/**
-	 * Class constructor
-	 * 
-	 * @param aWriter -
-	 *            a writer to write the xml stream to.
-	 * @throws XMLStreamException -
-	 *             if a write exception occurs
-	 * @throws FactoryConfigurationError -
-	 *             if XMLOutputFactory throws an exception
-	 */
-	public GOMStaxWriter(final Writer aWriter) throws XMLStreamException,
-			FactoryConfigurationError {
-		if (aWriter == null)
-			throw new IllegalArgumentException("Given writer must not be null");
-
-		this.writer = XMLOutputFactory.newInstance(STAX_OUTPUTFACTORY_KEY,
-				GOMStaxWriter.class.getClassLoader()).createXMLStreamWriter(
-				aWriter);
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#writeSimpleXMLElement(javax.xml.namespace.QName,
-	 *      java.util.List, java.lang.String)
-	 */
-	public void writeSimpleXMLElement(QName aName, List<GOMAttribute> aList,
-			String aValue) throws XMLStreamException {
-		writeStartElement(aName, aList);
-		writeContent(aValue);
-		this.writer.writeEndElement();
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#writeSimpleXMLElement(javax.xml.namespace.QName,
-	 *      java.lang.String, org.apache.lucene.gdata.gom.GOMAttribute)
-	 */
-	public void writeSimpleXMLElement(QName aName, String aValue,
-			GOMAttribute aAttribute) throws XMLStreamException {
-		List<GOMAttribute> list = null;
-		if (aAttribute != null) {
-			list = new ArrayList<GOMAttribute>(1);
-			list.add(aAttribute);
-		}
-		writeSimpleXMLElement(aName, list, aValue);
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#writeSimpleXMLElement(java.lang.String,
-	 *      java.lang.String, org.apache.lucene.gdata.gom.GOMAttribute)
-	 */
-	public void writeSimpleXMLElement(String aName, String aValue,
-			GOMAttribute aAttribute) throws XMLStreamException {
-		List<GOMAttribute> list = null;
-		if (aAttribute != null) {
-			list = new ArrayList<GOMAttribute>(1);
-			list.add(aAttribute);
-		}
-		writeSimpleXMLElement(aName, list, aValue);
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#writeSimpleXMLElement(java.lang.String,
-	 *      java.util.List, java.lang.String)
-	 */
-	public void writeSimpleXMLElement(String aName, List<GOMAttribute> aList,
-			String aValue) throws XMLStreamException {
-		writeStartElement(aName, aList);
-		writeContent(aValue);
-		this.writer.writeEndElement();
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#writeAttribute(org.apache.lucene.gdata.gom.GOMAttribute)
-	 */
-	public void writeAttribute(GOMAttribute attribute)
-			throws XMLStreamException {
-		if (attribute.hasDefaultNamespace())
-			this.writer.writeAttribute(attribute.getLocalName(), attribute
-					.getTextValue());
-		else
-			this.writer.writeAttribute(attribute.getQname().getPrefix(),
-					attribute.getQname().getNamespaceURI(), attribute
-							.getLocalName(), attribute.getTextValue());
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#writeStartElement(java.lang.String,
-	 *      java.util.List)
-	 */
-	public void writeStartElement(String aName, List<GOMAttribute> aList)
-			throws XMLStreamException {
-		this.writer.writeStartElement(aName);
-		if (aList != null)
-			for (GOMAttribute attribute : aList) {
-				writeAttribute(attribute);
-			}
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#writeStartElement(java.lang.String,
-	 *      org.apache.lucene.gdata.gom.GOMAttribute)
-	 */
-	public void writeStartElement(String aName, GOMAttribute aAttribute)
-			throws XMLStreamException {
-		this.writer.writeStartElement(aName);
-		writeAttribute(aAttribute);
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#writeStartElement(java.lang.String)
-	 */
-	public void writeStartElement(String aName) throws XMLStreamException {
-		this.writer.writeStartElement(aName);
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#writeStartElement(javax.xml.namespace.QName,
-	 *      java.util.List)
-	 */
-	public void writeStartElement(QName aName, List<GOMAttribute> aList)
-			throws XMLStreamException {
-		this.writer.writeStartElement(aName.getPrefix(), aName.getLocalPart(),
-				aName.getNamespaceURI());
-		if (aList != null)
-			for (GOMAttribute attribute : aList) {
-				writeAttribute(attribute);
-			}
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#writeEndElement()
-	 */
-	public void writeEndElement() throws XMLStreamException {
-		this.writer.writeEndElement();
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#writeContent(java.lang.String)
-	 */
-	public void writeContent(String aContent) throws XMLStreamException {
-		if (aContent != null) {
-			char[] cs = aContent.toCharArray();
-			this.writer.writeCharacters(cs, 0, cs.length);
-		}
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#writeContentUnescaped(java.lang.String)
-	 */
-	public void writeContentUnescaped(String aContent)
-			throws XMLStreamException {
-		if (aContent != null)
-			this.writer.writeCharacters(aContent);
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#writeDefaultNamespace(java.lang.String)
-	 */
-	public void writeDefaultNamespace(String aNsUri) throws XMLStreamException {
-		this.writer.writeDefaultNamespace(aNsUri);
-
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#writeDefaultNamespace(org.apache.lucene.gdata.gom.GOMNamespace)
-	 */
-	public void writeDefaultNamespace(GOMNamespace aNameSpace)
-			throws XMLStreamException {
-		if (aNameSpace != null)
-			writeDefaultNamespace(aNameSpace.getNamespaceUri());
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#writeNamespace(org.apache.lucene.gdata.gom.GOMNamespace)
-	 */
-	public void writeNamespace(GOMNamespace aNameSpace)
-			throws XMLStreamException {
-		if (aNameSpace == null)
-			return;
-		if (this.namespaceSet.contains(aNameSpace))
-			return;
-		this.namespaceSet.add(aNameSpace);
-		this.writer.writeNamespace(aNameSpace.getNamespacePrefix(), aNameSpace
-				.getNamespaceUri());
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#writeStartDocument(java.lang.String,
-	 *      java.lang.String)
-	 */
-	public void writeStartDocument(String aString, String aString2)
-			throws XMLStreamException {
-		this.writer.writeStartDocument(aString, aString2);
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#writeEndDocument()
-	 */
-	public void writeEndDocument() throws XMLStreamException {
-		this.writer.writeEndDocument();
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#flush()
-	 */
-	public void flush() throws XMLStreamException {
-		this.writer.flush();
-	}
-
-	/**
-	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#close()
-	 */
-	public void close() throws XMLStreamException {
-		this.writer.close();
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/writer/GOMXmlOutputFactory.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/writer/GOMXmlOutputFactory.java
deleted file mode 100644
index c2ed474..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/writer/GOMXmlOutputFactory.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.writer;
-
-import java.io.Writer;
-
-import javax.xml.stream.XMLStreamException;
-import javax.xml.stream.XMLStreamWriter;
-
-import com.bea.xml.stream.ConfigurationContextBase;
-import com.bea.xml.stream.XMLOutputFactoryBase;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class GOMXmlOutputFactory extends XMLOutputFactoryBase {
-	protected ConfigurationContextBase config = new ConfigurationContextBase();
-
-	/**
-	 * @see com.bea.xml.stream.XMLOutputFactoryBase#createXMLStreamWriter(java.io.OutputStream,
-	 *      java.lang.String)
-	 */
-	@Override
-	public XMLStreamWriter createXMLStreamWriter(Writer aWriter)
-			throws XMLStreamException {
-		GOMXmlWriter b = new GOMXmlWriter(aWriter);
-		b.setConfigurationContext(config);
-		return b;
-	}
-
-	/**
-	 * @see com.bea.xml.stream.XMLOutputFactoryBase#setProperty(java.lang.String,
-	 *      java.lang.Object)
-	 */
-	public void setProperty(java.lang.String name, Object value) {
-		config.setProperty(name, value);
-	}
-
-	/**
-	 * @see com.bea.xml.stream.XMLOutputFactoryBase#getProperty(java.lang.String)
-	 */
-	public Object getProperty(java.lang.String name) {
-		return config.getProperty(name);
-	}
-
-	/**
-	 * @see com.bea.xml.stream.XMLOutputFactoryBase#isPrefixDefaulting()
-	 */
-	public boolean isPrefixDefaulting() {
-		return config.isPrefixDefaulting();
-	}
-
-	/**
-	 * @see com.bea.xml.stream.XMLOutputFactoryBase#setPrefixDefaulting(boolean)
-	 */
-	public void setPrefixDefaulting(boolean value) {
-		config.setPrefixDefaulting(value);
-	}
-
-	/**
-	 * @see com.bea.xml.stream.XMLOutputFactoryBase#isPropertySupported(java.lang.String)
-	 */
-	public boolean isPropertySupported(String name) {
-		return config.isPropertySupported(name);
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/writer/GOMXmlWriter.java b/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/writer/GOMXmlWriter.java
deleted file mode 100644
index 7557602..0000000
--- a/contrib/gdata-server/src/gom/java/org/apache/lucene/gdata/gom/writer/GOMXmlWriter.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.writer;
-
-import java.io.Writer;
-import java.nio.charset.CharsetEncoder;
-
-import javax.xml.stream.XMLStreamException;
-
-import com.bea.xml.stream.XMLWriterBase;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class GOMXmlWriter extends XMLWriterBase {
-	private CharsetEncoder encoder;
-
-	/**
-	 * 
-	 */
-	public GOMXmlWriter() {
-		super();
-	}
-
-	/**
-	 * @param arg0
-	 */
-	public GOMXmlWriter(Writer arg0) {
-		super(arg0);
-	}
-
-	/**
-	 * @see com.bea.xml.stream.XMLWriterBase#writeCharacters(java.lang.String)
-	 */
-	@Override
-	public void writeCharacters(String aString) throws XMLStreamException {
-		closeStartElement();
-		char[] ch = aString.toCharArray();
-		escapeCharacters(ch, 0, ch.length);
-	}
-
-	/*
-	 * The default implementation escapes all xml chars in the writeCharacters
-	 * method. This is not expected for xhtml blobs. To make it easier to write
-	 * xhtml blobs the writeCharacters(String) mehtod will be reimplemented for
-	 * internal use.
-	 */
-	private void escapeCharacters(char chars[], int start, int length)
-			throws XMLStreamException {
-		for (int i = 0; i < length; i++) {
-			final char c = chars[i + start];
-
-			if (c < 32) {
-				if ((c != '\t' && c != '\n')) {
-					write("&#");
-					write(Integer.toString(c));
-					write(';');
-					continue;
-				}
-			} else if (c > 127 && encoder != null && !encoder.canEncode(c)) {
-				write("&#");
-				write(Integer.toString(c));
-				write(';');
-				continue;
-			}
-
-			write(c);
-		}
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/AtomMediaType.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/AtomMediaType.java
new file mode 100644
index 0000000..a030cfd
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/AtomMediaType.java
@@ -0,0 +1,40 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom;
+
+/**
+ * Describes an abstraction of a mime-type used to define the content of a
+ * atom:content element. This could be every possible mimetype but has to match
+ * this ".+/.+" Pattern.
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public enum AtomMediaType {
+	/**
+	 * A xml media type (mime-type)
+	 */
+	XML, 
+	/**
+	 *A text but no xml media type (mime-type) 
+	 */
+	TEXT,
+	/**
+	 * A binary media type (mime-type)
+	 */
+	BINARY
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/ContentType.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/ContentType.java
new file mode 100644
index 0000000..38101a9
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/ContentType.java
@@ -0,0 +1,45 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom;
+
+/**
+ * Atom e.g. feed element can contain text, html and xhtml content as character
+ * values
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public enum ContentType {
+	/**
+	 * GOM content type text
+	 */
+	TEXT,
+	/**
+	 * GOM content type XHTML
+	 */
+	XHTML,
+	/**
+	 * GOM content type HTML
+	 */
+	HTML,
+
+	/**
+	 * GOM atom media type
+	 * @see AtomMediaType
+	 */
+	ATOM_MEDIA_TYPE
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMAttribute.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMAttribute.java
new file mode 100644
index 0000000..1a0ed0a
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMAttribute.java
@@ -0,0 +1,35 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom;
+
+/**
+ * This class is a object representation of a XML Attribute used in the
+ * GO-Model.
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public interface GOMAttribute extends GOMXmlEntity {
+
+	/**
+	 * 
+	 * @return <code>true</code> if and only if this attribute has the default
+	 *         namespace, otherwise <code>false</code>
+	 */
+	public abstract boolean hasDefaultNamespace();
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMAuthor.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMAuthor.java
new file mode 100644
index 0000000..4473a09
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMAuthor.java
@@ -0,0 +1,36 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom;
+
+/**
+ * GOMAuthor elmement used in feed and entries as a representation of a atom:author element.
+ * The "atom:author" element is a Person construct that indicates the author of the entry or feed.
+ * <pre>
+ * atomAuthor = 
+ * 	element atom:author { atomPersonConstruct }
+ * </pre>
+ * @see org.apache.lucene.gdata.gom.GOMPerson
+ * @author Simon Willnauer
+ * 
+ */
+public interface GOMAuthor extends GOMPerson {
+	/**
+	 * Atom 1.0 local name for the xml element
+	 */
+	public static final String LOCALNAME = "author";
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMCategory.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMCategory.java
new file mode 100644
index 0000000..8057555
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMCategory.java
@@ -0,0 +1,100 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom;
+
+/**
+ * 
+ * GOMCategory type<br>
+ * <p>
+ * The <b>"category"</b> element conveys information about a category
+ * associated with an entry or feed. This specification assigns no meaning to
+ * the content (if any) of this element.
+ * </p>
+ * <p>
+ * RelaxNG Schema:
+ * </p>
+ * 
+ * <pre>
+ *      atomCategory =
+ *      element atom:category {
+ *      	atomCommonAttributes,
+ *      	attribute term { text },
+ *      	attribute scheme { atomUri }?,
+ *      	attribute label { text }?,
+ *      	undefinedContent
+ *      }
+ * </pre>
+ * 
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public interface GOMCategory extends GOMElement {
+	/**
+	 * Atom local name for the xml element
+	 */
+	public static final String LOCALNAME = "category";
+
+	/**
+	 * Attribute name (attribute term { text })
+	 */
+	public static final String TERM_ATTRIBUTE = "term";
+
+	/**
+	 * Attribute name (attribute label { text })
+	 */
+	public static final String LABLE_ATTRIBUTE = "label";
+
+	/**
+	 * Attribute name (attribute scheme { atomUri })
+	 */
+	public static final String SCHEME_ATTRIBUTE = "scheme";
+
+	/**
+	 * @param aTerm -
+	 *            the attribute term { text }
+	 */
+	public abstract void setTerm(String aTerm);
+
+	/**
+	 * @param aLabel -
+	 *            the attribute lable { text }
+	 */
+	public abstract void setLabel(String aLabel);
+
+	/**
+	 * @param aScheme -
+	 *            the attribute scheme { atomUri }
+	 */
+	public abstract void setScheme(String aScheme);
+
+	/**
+	 * @return the attribute term { text }
+	 */
+	public abstract String getTerm();
+
+	/**
+	 * @return the attribute scheme { atomUri }
+	 */
+	public abstract String getScheme();
+
+	/**
+	 * @return the attribute lable { text }
+	 */
+	public abstract String getLabel();
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMContent.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMContent.java
new file mode 100644
index 0000000..8cbbc8f
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMContent.java
@@ -0,0 +1,99 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom;
+
+/**
+ * <p>
+ * GOMContent represents the atom:content element.
+ * </p>
+ * The "atom:content" element either contains or links to the content of the
+ * entry. The content of atom:content is Language-Sensitive.
+ * 
+ * <pre>
+ *   atomInlineTextContent =
+ *   element atom:content {
+ *   atomCommonAttributes,
+ *   attribute type { &quot;text&quot; | &quot;html&quot; }?,
+ *   (text)*
+ *   }
+ *  
+ *   atomInlineXHTMLContent =
+ *   element atom:content {
+ *   atomCommonAttributes,
+ *   attribute type { &quot;xhtml&quot; },
+ *   xhtmlDiv
+ *   }
+ *  
+ *   atomInlineOtherContent =
+ *   element atom:content {
+ *   atomCommonAttributes,
+ *   attribute type { atomMediaType }?,
+ *   (text|anyElement)*
+ *   }
+ *  
+ *  
+ *   atomOutOfLineContent =
+ *   element atom:content {
+ *   atomCommonAttributes,
+ *   attribute type { atomMediaType }?,
+ *   attribute src { atomUri },
+ *   empty
+ *   }
+ *  
+ *   atomContent = atomInlineTextContent
+ *   | atomInlineXHTMLContent
+ *  
+ *   | atomInlineOtherContent
+ *   | atomOutOfLineContent
+ * </pre>
+ * 
+ * @author Simon Willnauer
+ * @see org.apache.lucene.gdata.gom.GOMTextConstruct
+ *
+ * 
+ */
+public interface GOMContent extends GOMTextConstruct {
+	/**
+	 * Atom local name for the xml element
+	 */
+	public static final String LOCALNAME = "content";
+	/**
+	 * RSS local name for the xml element
+	 */
+	public static final String LOCAL_NAME_RSS = "description";
+	/**
+	 * The src attribute value
+	 * @return - the value of the src attribute
+	 */
+	public abstract String getSrc();
+	/**
+	 * The src attribute value
+	 * @param aSrc - the src attribute value to set
+	 */
+	public abstract void setSrc(String aSrc);
+	/**
+	 * The contents abstract media type
+	 * @param aMediaType - 
+	 */
+	public abstract void setAtomMediaType(AtomMediaType aMediaType);
+
+	/**
+	 * @return - the atom media type of the content element
+	 * @see AtomMediaType
+	 */
+	public abstract AtomMediaType getAtomMediaType();
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMContributor.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMContributor.java
new file mode 100644
index 0000000..9eac160
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMContributor.java
@@ -0,0 +1,35 @@
+/**
+ * contributor license agreements.  See the NOTICE file distributed with
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom;
+
+/**
+ * The "atom:contributor" element is a Person construct that indicates a person
+ * or other entity who contributed to the entry or feed.
+ * 
+ * <pre>
+ * atomContributor = element atom:contributor { atomPersonConstruct }
+ * </pre>
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public interface GOMContributor extends GOMPerson {
+	/**
+	 * Atom 1.0 local name for the xml element
+	 */
+	public static final String LOCALNAME = "contributor";
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMDateConstruct.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMDateConstruct.java
new file mode 100644
index 0000000..79875bd
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMDateConstruct.java
@@ -0,0 +1,77 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom;
+
+import java.util.Date;
+
+/**
+ * 
+ * <P>
+ * GOMDateConstruct is a base interface for several concrete DateConstruct
+ * implementations like {@link org.apache.lucene.gdata.gom.GOMUpdated} or
+ * {@link org.apache.lucene.gdata.gom.GOMPublished}
+ * </p>
+ * <p>
+ * A Date construct is an element whose content MUST conform to the "date-time"
+ * production in [RFC3339]. In addition, an uppercase "T" character MUST be used
+ * to separate date and time, and an uppercase "Z" character MUST be present in
+ * the absence of a numeric time zone offset.
+ * 
+ * <pre>
+ *  atomDateConstruct = atomCommonAttributes, xsd:dateTime
+ * </pre>
+ * 
+ * Such date values happen to be compatible with the following specifications:
+ * [ISO.8601.1988], [W3C.NOTE-datetime-19980827], and
+ * [W3C.REC-xmlschema-2-20041028].
+ * </p>
+ * <p>
+ * Example Date constructs:
+ * 
+ * <pre>
+ *    &lt;updated&gt;2003-12-13T18:30:02Z&lt;/updated&gt;
+ *   
+ *    &lt;updated&gt;2003-12-13T18:30:02.25Z&lt;/updated&gt;
+ *    &lt;updated&gt;2003-12-13T18:30:02+01:00&lt;/updated&gt;
+ *    &lt;updated&gt;2003-12-13T18:30:02.25+01:00&lt;/updated&gt;
+ * </pre>
+ * 
+ * Date values SHOULD be as accurate as possible. For example, it would be
+ * generally inappropriate for a publishing system to apply the same timestamp
+ * to several entries that were published during the course of a single day.
+ * </p>
+ * 
+ * @author Simon Willnauer
+ * 
+ * @see org.apache.lucene.gdata.gom.GOMUpdated
+ * @see org.apache.lucene.gdata.gom.GOMPublished
+ */
+public abstract interface GOMDateConstruct extends GOMElement {
+	/**
+	 * 
+	 * @param date -
+	 *            the date to set
+	 */
+	public abstract void setDate(Date date);
+
+	/**
+	 * 
+	 * @return - the date object, if no date has been set this method will
+	 *         return a <code>new Date(0)</code> date object
+	 */
+	public abstract Date getDate();
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMDocument.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMDocument.java
new file mode 100644
index 0000000..e895dc8
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMDocument.java
@@ -0,0 +1,110 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom;
+
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+/**
+ * <p>
+ * GOMDocument acts as a container for GOMElements to render the containing
+ * GOMElement as a valid xml document. This class renderes the
+ * 
+ * <pre>
+ *  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
+ * </pre>
+ * 
+ * header to the outputstream before the containing element will be rendered.
+ * </p>
+ * 
+ * @author Simon Willnauer
+ * 
+ * @param <T>
+ */
+public interface GOMDocument<T extends GOMElement> {
+	/**
+	 * setter for the root element of the xml e.g GOMDocument
+	 * 
+	 * @param aRootElement -
+	 *            the root element to set
+	 */
+	public abstract void setRootElement(T aRootElement);
+
+	/**
+	 * Getter for the root element of the xml e.g GOMDocument
+	 * 
+	 * @return - the root elmenent
+	 */
+	public abstract T getRootElement();
+
+	/**
+	 * Sets the xml version
+	 * 
+	 * @param aVersion -
+	 *            the version string
+	 */
+	public abstract void setVersion(String aVersion);
+
+	/**
+	 * Gets the xml version
+	 * 
+	 * @return - the xml version string
+	 */
+	public abstract String getVersion();
+
+	/**
+	 * Gets the xml charset encoding
+	 * 
+	 * @return - the specified char encoding
+	 */
+	public abstract String getCharacterEncoding();
+
+	/**
+	 * Sets the xml charset encoding
+	 * 
+	 * @param aEncoding -
+	 *            the charset encoding to set
+	 */
+	public abstract void setCharacterEncoding(String aEncoding);
+
+	/**
+	 * Generates a complete xml document starting with the header followed by
+	 * the output of the specified root element in the ATOM 1.0 formate. 
+	 * 
+	 * @param aStreamWriter -
+	 *            the {@link GOMOutputWriter} implementation to write the output
+	 * @throws XMLStreamException -
+	 *             if the {@link GOMOutputWriter} throws an exception
+	 */
+	public abstract void writeAtomOutput(final GOMOutputWriter aStreamWriter)
+			throws XMLStreamException;
+
+	/**
+	 *
+	 * Generates a complete xml document starting with the header followed by
+	 * the output of the specified root element in the RSS 2.0 formate. 
+	 * 
+	 * @param aStreamWriter -
+	 *            the {@link GOMOutputWriter} implementation to write the output
+	 * @throws XMLStreamException -
+	 *             if the {@link GOMOutputWriter} throws an exception
+	 */
+	public abstract void writeRssOutput(final GOMOutputWriter aStreamWriter)
+			throws XMLStreamException;
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMElement.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMElement.java
new file mode 100644
index 0000000..83495ab
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMElement.java
@@ -0,0 +1,92 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom;
+
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.core.AtomParser;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+/**
+ * Abstract interface which should be assignable from all classes representing
+ * xml elements within the GData Object Model.
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public abstract interface GOMElement extends GOMXmlEntity, AtomParser {
+	/**
+	 * <code>xml:lang</code> attribute localpart
+	 */
+	public static final String XML_LANG = "lang";
+
+	/**
+	 * <code>xml:base</code> attribute localpart
+	 */
+	public static final String XML_BASE = "base";
+
+	/**
+	 * 
+	 * @return the xml:base attribute value
+	 */
+	public abstract String getXmlBase();
+
+	/**
+	 * 
+	 * @return the xml:lang attribute value
+	 */
+	public abstract String getXmlLang();
+
+	/**
+	 * Generates the xml element represented by this class in the ATOM 1.0
+	 * formate.
+	 * 
+	 * @param aStreamWriter -
+	 *            the {@link GOMOutputWriter} implementation to write the output
+	 * @throws XMLStreamException -
+	 *             if the {@link GOMOutputWriter} throws an exception
+	 */
+	public abstract void writeAtomOutput(final GOMOutputWriter aStreamWriter)
+			throws XMLStreamException;
+
+	/**
+	 * Generates the xml element represented by this class in the RSS 2.0
+	 * formate.
+	 * 
+	 * @param aStreamWriter -
+	 *            the {@link GOMOutputWriter} implementation to write the output
+	 * @throws XMLStreamException -
+	 *             if the {@link GOMOutputWriter} throws an exception
+	 */
+	public abstract void writeRssOutput(final GOMOutputWriter aStreamWriter)
+			throws XMLStreamException;
+
+	/**
+	 * Generates the xml element represented by this class in the RSS 2.0
+	 * formate using the parameter rssName as the element local name
+	 * 
+	 * @param rssName -
+	 *            the local name to render the element
+	 * @param aStreamWriter -
+	 *            the {@link GOMOutputWriter} implementation to write the output
+	 * @throws XMLStreamException -
+	 *             if the {@link GOMOutputWriter} throws an exception
+	 */
+	public abstract void writeRssOutput(final GOMOutputWriter aStreamWriter,
+			String rssName) throws XMLStreamException;
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMEntry.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMEntry.java
new file mode 100644
index 0000000..56903cb
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMEntry.java
@@ -0,0 +1,255 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom;
+
+import java.util.List;
+
+/**
+ * 
+ * <p>
+ * The GOMEntry class represents a "atom:entry" element in the GData Object
+ * Model.
+ * </p>
+ * <p>
+ * The "atom:entry" element represents an individual entry, acting as a
+ * container for metadata and data associated with the entry. This element can
+ * appear as a child of the atom:feed element, or it can appear as the document
+ * (i.e., top-level) element of a stand-alone Atom Entry Document.
+ * </p>
+ * <p>
+ * RelaxNG Schema:
+ * </p>
+ * 
+ * <pre>
+ *     atomEntry =
+ *     element atom:entry {
+ *     atomCommonAttributes,
+ *     (	atomAuthor*
+ *     	&amp; atomCategory*
+ *     	&amp; atomContent?
+ *     	&amp; atomContributor*
+ *     	&amp; atomId
+ *     	&amp; atomLink*
+ *     	&amp; atomPublished?
+ *   	 	&amp; atomRights?
+ *     	&amp; atomSource?
+ *     	&amp; atomSummary?
+ *     	&amp; atomTitle
+ *     	&amp; atomUpdated
+ *     	&amp; extensionElement*)
+ *     }
+ * </pre>
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public interface GOMEntry extends GOMXmlEntity, GOMElement, GOMExtensible {
+	/**
+	 * Atom 1.0 local name for the xml element
+	 */
+	public static final String LOCALNAME = "entry";
+
+	/**
+	 * RSS 2.0 local name for the xml element
+	 */
+	public static final String LOCALNAME_RSS = "item";
+
+	/**
+	 * @param aAuthor -
+	 *            a author to add
+	 * @see GOMAuthor
+	 */
+	public abstract void addAuthor(GOMAuthor aAuthor);
+
+	/**
+	 * @param aCategory -
+	 *            a category to add
+	 * @see GOMCategory
+	 */
+	public abstract void addCategory(GOMCategory aCategory);
+
+	/**
+	 * @param aContributor -
+	 *            a contributor to add
+	 * @see GOMContributor
+	 */
+	public abstract void addContributor(GOMContributor aContributor);
+
+	/**
+	 * @param aLink -
+	 *            a link to add
+	 * @see GOMLink
+	 */
+	public abstract void addLink(GOMLink aLink);
+
+	/**
+	 * @return - the entry author
+	 * @see GOMAuthor
+	 */
+	public abstract List<GOMAuthor> getAuthors();
+
+	/**
+	 * 
+	 * This method returns all categories and will never return<code>null</code>
+	 * 
+	 * @return - a list of categories
+	 * @see GOMCategory
+	 */
+	public abstract List<GOMCategory> getCategories();
+
+	/**
+	 * 
+	 * This method returns all contributors and will never return<code>null</code>
+	 * 
+	 * @return - a list of contributors
+	 * @see GOMContributor
+	 */
+	public abstract List<GOMContributor> getContributor();
+
+	/**
+	 * @return - the feed id
+	 * @see GOMId
+	 */
+	public abstract GOMId getId();
+
+	/**
+	 * @param aId -
+	 *            the entry id
+	 * @see GOMId
+	 */
+	public abstract void setId(GOMId aId);
+
+	/**
+	 * @return - the entry rights
+	 * @see GOMRights
+	 */
+	public abstract GOMRights getRights();
+
+	/**
+	 * @param aRights -
+	 *            the GOMRights to set
+	 * @see GOMRights
+	 */
+	public abstract void setRights(GOMRights aRights);
+
+	/**
+	 * @return - the entries title
+	 * @see GOMTitle
+	 */
+	public abstract GOMTitle getTitle();
+
+	/**
+	 * @param aTitle -
+	 *            the title to set
+	 * @see GOMTitle
+	 */
+	public abstract void setTitle(GOMTitle aTitle);
+
+	/**
+	 * @return - the last updated element
+	 * @see GOMUpdated
+	 */
+	public abstract GOMUpdated getUpdated();
+
+	/**
+	 * @param aUpdated -
+	 *            the updated element to set
+	 * @see GOMUpdated
+	 */
+	public abstract void setUpdated(GOMUpdated aUpdated);
+
+	/**
+	 * 
+	 * This method returns all links and will never return<code>null</code>
+	 * 
+	 * @return - a list of links
+	 * @see GOMLink
+	 */
+	public abstract List<GOMLink> getLinks();
+
+	/**
+	 * @param aSummary -
+	 *            a summary to set
+	 * @see GOMSummary
+	 */
+	public abstract void setSummary(GOMSummary aSummary);
+
+	/**
+	 * @return - the summary
+	 * @see GOMSummary
+	 */
+	public abstract GOMSummary getSummary();
+
+	/**
+	 * @param aSource -
+	 *            the source to set
+	 * @see GOMSource
+	 */
+	public abstract void setSource(GOMSource aSource);
+
+	/**
+	 * @return - the entry source
+	 * @see GOMSource
+	 */
+	public abstract GOMSource getSource();
+
+	/**
+	 * @param aPublished -
+	 *            the published element to set
+	 * @see GOMPublished
+	 */
+	public abstract void setPublished(GOMPublished aPublished);
+
+	/**
+	 * @return - the published element
+	 * @see GOMPublished
+	 */
+	public abstract GOMPublished getPublished();
+
+	/**
+	 * @return - the content element
+	 * @see GOMContent
+	 */
+	public abstract GOMContent getContent();
+
+	/**
+	 * @param content -
+	 *            the content to set
+	 * @see GOMContent
+	 */
+	public abstract void setContent(GOMContent content);
+
+	/**
+	 * @param aNamespace -
+	 *            a Namespace to add
+	 * @see GOMNamespace
+	 */
+	public abstract void addNamespace(GOMNamespace aNamespace);
+
+	/**
+	 * @return - list of all namespaces - will never be null
+	 * @see GOMNamespace
+	 */
+	public abstract List<GOMNamespace> getNamespaces();
+
+	/**
+	 * @return - the default namespace
+	 * @see GOMNamespace
+	 */
+	public abstract GOMNamespace getDefaultNamespace();
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMExtensible.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMExtensible.java
new file mode 100644
index 0000000..1bd4c38
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMExtensible.java
@@ -0,0 +1,55 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom;
+
+import java.util.List;
+
+import org.apache.lucene.gdata.gom.core.extension.GOMExtensionFactory;
+
+/**
+ * <p>
+ * The Gdata Object Model describes an abstract object model for the gdata
+ * protocol. GData is supposed to be very flexible and extensible. Users should
+ * be able to extend {@link org.apache.lucene.gdata.gom.GOMFeed} and
+ * {@link org.apache.lucene.gdata.gom.GOMEntry} elements to create extensions
+ * and custom classes for their own model.
+ * </p>
+ * 
+ * <p>
+ * This interface describes the extensible GOM entities.
+ * </p>
+ * 
+ * @author Simon Willnauer
+ * @see org.apache.lucene.gdata.gom.GOMFeed
+ * @see org.apache.lucene.gdata.gom.GOMEntry
+ * 
+ */
+public interface GOMExtensible {
+	//TODO add setter!
+	//TODO add how to
+	/**
+	 * @return - a list of all extensions specified to the extended element
+	 */
+	public List<GOMExtension> getExtensions();
+
+	/**
+	 * 
+	 * @param factory - the extension factory to set
+	 */
+	public void setExtensionFactory(GOMExtensionFactory factory);
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMExtension.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMExtension.java
new file mode 100644
index 0000000..dbfc50a
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMExtension.java
@@ -0,0 +1,36 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom;
+
+/**
+ * The GData Object Model is like the Google Data Api highly extensible and
+ * offers a lot of base classes to extend as a {@link GOMExtension}. All
+ * extensions returned by
+ * {@link org.apache.lucene.gdata.gom.core.extension.GOMExtensionFactory#canHandleExtensionElement(QName)}
+ * must implement this interface. <br>
+ * GOM extensions can either be created via the
+ * {@link org.apache.lucene.gdata.gom.core.extension.GOMExtensionFactory} or by
+ * subclassing either {@link org.apache.lucene.gdata.gom.GOMFeed} or
+ * {@link org.apache.lucene.gdata.gom.GOMEntry}.
+ * 
+ * @author Simon Willnauer
+ * @see org.apache.lucene.gdata.gom.GOMExtensible
+ * @see org.apache.lucene.gdata.gom.core.extension.GOMExtensionFactory 
+ */
+public interface GOMExtension extends GOMXmlEntity, GOMElement {
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMFeed.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMFeed.java
new file mode 100644
index 0000000..20733c8
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMFeed.java
@@ -0,0 +1,130 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom;
+
+import java.util.List;
+
+/**
+ * Class representing the "atom:feed" element. The "atom:feed" element is the
+ * document (i.e., top-level) element of an Atom Feed Document, acting as a
+ * container for metadata and data associated with the feed. Its element
+ * children consist of metadata elements followed by zero or more atom:entry
+ * child elements.
+ * 
+ * <pre>
+ *        atom:feed {
+ *        	atomCommonAttributes, 
+ *         	(atomAuthor* &amp; atomCategory* &amp;
+ *        	atomContributor* &amp;
+ *         	atomGenerator? &amp; atomIcon? &amp;
+ *         	atomId &amp; 
+ *         	atomLink* &amp;
+ *        	atomLogo? &amp;
+ *        	atomRights? &amp;
+ *        	atomSubtitle? &amp;
+ *        	atomTitle &amp; 
+ *        	atomUpdated &amp;
+ *        	extensionElement*),
+ *        	 atomEntry* }
+ * </pre>
+ * 
+ * 
+ * @author Simon Willnauer
+ * @see org.apache.lucene.gdata.gom.GOMExtensible
+ * @see org.apache.lucene.gdata.gom.GOMExtension
+ * @see org.apache.lucene.gdata.gom.GOMDocument
+ */
+public interface GOMFeed extends GOMSource, GOMExtensible {
+	/**
+	 * Atom local name for the xml element
+	 */
+	public static final String LOCALNAME = "feed";
+
+	/**
+	 * RSS local name for the xml element
+	 */
+	public static final String LOCALNAME_RSS = "rss";
+
+	/**
+	 * RSS channel localname as Rss starts with
+	 * 
+	 * <pre>
+	 *     &lt;rss&gt;&lt;channel&gt;
+	 * </pre>
+	 */
+	public static final String RSS_CHANNEL_ELEMENT_NAME = "channel";
+
+	/**
+	 * this class can contain namespaces which will be rendered into the start
+	 * element.
+	 * 
+	 * <pre>
+	 *     &lt;feed xmlns:myNs=&quot;someNamespace&quot;&gt;&lt;/feed&gt;
+	 * </pre>
+	 * 
+	 * @param aNamespace -
+	 *            a namespace to add
+	 */
+	public void addNamespace(GOMNamespace aNamespace);
+
+	/**
+	 * @return - all declared namespaces, excluding the default namespace, this
+	 *         method will never return <code>null</code>.
+	 * @see GOMFeed#getDefaultNamespace()
+	 */
+	public List<GOMNamespace> getNamespaces();
+
+	/**
+	 * 
+	 * @return - a list of added entries, this method will never return
+	 *         <code>null</code>.
+	 */
+	public List<GOMEntry> getEntries();
+
+	/**
+	 * @return - the OpenSearch namespace element <i>itemsPerPage</i> text
+	 *         value.
+	 */
+	public int getItemsPerPage();
+
+	/**
+	 * @return - the OpenSearch namespace element <i>startIndex</i> text value.
+	 */
+	public int getStartIndex();
+
+	/**
+	 * @param aIndex -
+	 *            the OpenSearch namespace element <i>startIndex</i> text value
+	 *            as an integer.
+	 */
+	public void setStartIndex(int aIndex);
+
+	/**
+	 * @param aInt -
+	 *            the OpenSearch namespace element <i>itemsPerPage</i> text
+	 *            value as an integer.
+	 */
+	public void setItemsPerPage(int aInt);
+
+	/**
+	 * 
+	 * @return the default namespace - this will always be
+	 *         {@link GOMNamespace#ATOM_NAMESPACE}
+	 */
+	public GOMNamespace getDefaultNamespace();
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMGenerator.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMGenerator.java
new file mode 100644
index 0000000..a8ee0c0
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMGenerator.java
@@ -0,0 +1,70 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom;
+
+/**
+ * Class representing the "atom:generator" element. The "atom:generator"
+ * element's content identifies the agent used to generate a feed, for debugging
+ * and other purposes.
+ * 
+ * <pre>
+ *   atomGenerator = element atom:generator {
+ *   atomCommonAttributes,
+ *   attribute uri { atomUri }?,
+ *   attribute version { text }?,
+ *   text
+ *   }
+ * </pre>
+ * 
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public interface GOMGenerator extends GOMElement {
+	/**
+	 * Atom local name for the xml element
+	 */
+	public static final String LOCALNAME = "generator";
+
+	/**
+	 * Sets the the atom:generator <i>uri</i> attribute value
+	 * 
+	 * @param uri -
+	 *            the generator <i>uri</i> attribute value to set
+	 */
+	public void setUri(String uri);
+
+	/**
+	 * Sets the the atom:generator <i>version</i> attribute value
+	 * 
+	 * @param version -
+	 *            the version value to set
+	 */
+	public void setGeneratorVersion(String version);
+
+	/**
+	 * 
+	 * @return - the atom:generator <i>version</i> attribute value
+	 */
+	public String getGeneratorVersion();
+
+	/**
+	 * 
+	 * @return - the atom:generator <i>uri</i> attribute value
+	 */
+	public String getUri();
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMIcon.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMIcon.java
new file mode 100644
index 0000000..35c58b4
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMIcon.java
@@ -0,0 +1,41 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom;
+
+/**
+ * 
+ * Simple atom:icon element class. The "atom:icon" element's content is an IRI
+ * reference [RFC3987] that identifies an image that provides iconic visual
+ * identification for a feed.
+ * 
+ * <pre>
+ *  atomIcon = element atom:icon {
+ *  atomCommonAttributes,
+ *  (atomUri)
+ *  }
+ * </pre>
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public interface GOMIcon extends GOMElement {
+	/**
+	 * Atom local name for the xml element
+	 */
+	String LOCALNAME = "icon";
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMId.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMId.java
new file mode 100644
index 0000000..840613f
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMId.java
@@ -0,0 +1,45 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom;
+
+/**
+ * 
+ * The "atom:id" element conveys a permanent, universally unique identifier for
+ * an entry or feed.
+ * 
+ * <pre>
+ *  atomId = element atom:id {
+ *  atomCommonAttributes,
+ *  (atomUri)
+ *  }
+ * </pre>
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public interface GOMId extends GOMElement {
+	/**
+	 * Atom local name for the xml element
+	 */
+	public static final String LOCALNAME = "id";
+
+	/**
+	 * RSS local name for the xml element
+	 */
+	public static final String LOCALNAME_RSS = "uid";
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMLink.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMLink.java
new file mode 100644
index 0000000..5c59005
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMLink.java
@@ -0,0 +1,113 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom;
+
+/**
+ * The "atom:link" element defines a reference from an entry or feed to a Web
+ * resource. This specification assigns no meaning to the content (if any) of
+ * this element.
+ * 
+ * <pre>
+ *  atomLink =
+ *  element atom:link {
+ *  atomCommonAttributes,
+ *  attribute href { atomUri },
+ *  attribute rel { atomNCName | atomUri }?,
+ *  attribute type { atomMediaType }?,
+ *  attribute hreflang { atomLanguageTag }?,
+ *  attribute title { text }?,
+ *  attribute length { text }?,
+ *  undefinedContent
+ *  }
+ * </pre>
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public interface GOMLink extends GOMElement {
+	/**
+	 * Atom local name for the xml element
+	 */
+	public static final String LOCALNAME = "link";
+
+	/**
+	 * @return - the href attribute value of the element link
+	 */
+	public String getHref();
+
+	/**
+	 * @param aHref -
+	 *            the href attribute value of the element link to set.
+	 */
+	public void setHref(String aHref);
+
+	/**
+	 * @return the hreflang attribute value of the element link
+	 */
+	public String getHrefLang();
+
+	/**
+	 * @param aHrefLang -
+	 *            the hreflang attribute value of the element link to set.
+	 */
+	public void setHrefLang(String aHrefLang);
+
+	/**
+	 * @return - the length attribute value of the element link.
+	 */
+	public Integer getLength();
+
+	/**
+	 * @param aLength -
+	 *            the length attribute value of the element link to set.
+	 */
+	public void setLength(Integer aLength);
+
+	/**
+	 * @return - the rel attribute value of the element link.
+	 */
+	public String getRel();
+
+	/**
+	 * @param aRel -
+	 *            the rel attribute value of the element link to set
+	 */
+	public void setRel(String aRel);
+
+	/**
+	 * @return - the title attribute value of the element link.
+	 */
+	public String getTitle();
+
+	/**
+	 * @param aTitle -
+	 *            the title attribute value of the element link to set
+	 */
+	public void setTitle(String aTitle);
+
+	/**
+	 * @return - the type attribute value of the element link.
+	 */
+	public String getType();
+
+	/**
+	 * @param aType -
+	 *            the type attribute value of the element link.
+	 */
+	public void setType(String aType);
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMLogo.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMLogo.java
new file mode 100644
index 0000000..440b9af
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMLogo.java
@@ -0,0 +1,42 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom;
+
+import org.apache.lucene.gdata.gom.GOMElement;
+
+// TODO add descrition
+/**
+ * Simple atom:logo element. The "atom:logo" element's content is an IRI
+ * reference [RFC3987] that identifies an image that provides visual
+ * identification for a feed.
+ * 
+ * <pre>
+ *  atomLogo = element atom:logo {
+ *  atomCommonAttributes,
+ *  (atomUri)
+ * </pre>
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public interface GOMLogo extends GOMElement {
+	/**
+	 * Atom local name for the xml element
+	 */
+	public static final String LOCALNAME = "logo";
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMNamespace.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMNamespace.java
new file mode 100644
index 0000000..6cfa41d
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMNamespace.java
@@ -0,0 +1,151 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom;
+
+/**
+ * A simple domain object to represent a xml namespace.
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public final class GOMNamespace {
+
+	/**
+	 * XML namespace uri
+	 */
+	public static final String XML_NS_URI = "http://www.w3.org/XML/1998/namespace";
+
+	/**
+	 * XML namespace prefix
+	 */
+	public static final String XML_NS_PREFIX = "xml";
+
+	/**
+	 * Amazon "opensearch" namespace prefix
+	 */
+	public static final String OPENSEARCH_NS_PREFIX = "openSearch";
+
+	/**
+	 * Amazon "opensearch" namespace uri
+	 */
+	public static final String OPENSEARCH_NS_URI = "http://a9.com/-/spec/opensearchrss/1.0/";
+
+	/**
+	 * ATOM namespace uri
+	 */
+	public static final String ATOM_NS_URI = "http://www.w3.org/2005/Atom";
+
+	/**
+	 * ATOM namespace prefix
+	 */
+	public static final String ATOM_NS_PREFIX = "atom";
+
+	/**
+	 * ATOM namespace
+	 */
+	public static final GOMNamespace ATOM_NAMESPACE = new GOMNamespace(
+			ATOM_NS_URI, ATOM_NS_PREFIX);
+
+	/**
+	 * Amazon "opensearch" namespace
+	 */
+	public static final GOMNamespace OPENSEARCH_NAMESPACE = new GOMNamespace(
+			OPENSEARCH_NS_URI, OPENSEARCH_NS_PREFIX);
+
+	private final String namespaceUri;
+
+	private final String namespacePrefix;
+
+	/**
+	 * Class constructor for GOMNamespace
+	 * 
+	 * @param aNamespaceUri -
+	 *            the namespace uri (must not be null)
+	 * @param aNamespacePrefix -
+	 *            the namespace prefix (if null an empty string will be
+	 *            assigned)
+	 * 
+	 */
+	public GOMNamespace(final String aNamespaceUri,
+			final String aNamespacePrefix) {
+		if (aNamespaceUri == null)
+			throw new IllegalArgumentException("uri must not be null");
+		this.namespacePrefix = aNamespacePrefix == null ? "" : aNamespacePrefix;
+		this.namespaceUri = aNamespaceUri;
+	}
+
+	/**
+	 * @return Returns the namespacePrefix.
+	 */
+	public String getNamespacePrefix() {
+		return this.namespacePrefix;
+	}
+
+	/**
+	 * @return Returns the namespaceUri.
+	 */
+	public String getNamespaceUri() {
+		return this.namespaceUri;
+	}
+
+	/**
+	 * @see java.lang.Object#equals(java.lang.Object)
+	 */
+	@Override
+	public boolean equals(Object arg0) {
+		if (arg0 == null)
+			return false;
+		if (arg0 == this)
+			return true;
+		if (arg0 instanceof GOMNamespace) {
+			GOMNamespace other = (GOMNamespace) arg0;
+			return this.namespacePrefix.equals(other.getNamespacePrefix())
+					&& this.namespaceUri.equals(other.getNamespaceUri());
+		}
+		return false;
+	}
+
+	/**
+	 * @see java.lang.Object#hashCode()
+	 */
+	@Override
+	public int hashCode() {
+		/*
+		 * The multiplier 37 was chosen because it is an odd prime. If it was
+		 * even and the multiplication overflowed, information would be lost
+		 * because multiplication by two is equivalent to shifting The value 17
+		 * is arbitrary. see
+		 * http://java.sun.com/developer/Books/effectivejava/Chapter3.pdf
+		 */
+		int hash = 17;
+		hash = 37 * hash + this.namespacePrefix.hashCode();
+		hash = 37 * hash + this.namespaceUri.hashCode();
+		return hash;
+	}
+
+	/**
+	 * @see java.lang.Object#toString()
+	 */
+	@Override
+	public String toString() {
+		StringBuilder builder = new StringBuilder(this.getClass().getName());
+		builder.append(" uri: ").append(this.namespaceUri);
+		builder.append(" prefix: ").append(this.namespacePrefix);
+		return builder.toString();
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMPerson.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMPerson.java
new file mode 100644
index 0000000..6fedc07
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMPerson.java
@@ -0,0 +1,75 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom;
+
+
+/**
+ * 
+ * GOMPerson type used for feed and entry authors and contributors. It may also
+ * be used by custom elements.
+ * 
+ * <pre>
+ *  
+ *   atomPersonConstruct =
+ *   atomCommonAttributes,
+ *   (element atom:name { text }
+ *   &amp; element atom:uri { atomUri }?
+ *   &amp; element atom:email { atomEmailAddress }?
+ *   &amp; extensionElement*)
+ *   }
+ * </pre>
+ * 
+ * @author Simon Willnauer
+ * @see org.apache.lucene.gdata.gom.GOMAuthor
+ */
+public interface GOMPerson extends GOMElement {
+	/**
+	 *  Atom local name for the xml element
+	 */
+	public static final String LOCALNAME = "person";
+
+	/**
+	 * @param aName - the person name value
+	 */
+	public abstract void setName(String aName);
+
+	/**
+	 * @param aEmail - the person email value
+	 */
+	public abstract void setEmail(String aEmail);
+
+	/**
+	 * @param uri - the person uri value
+	 */
+	public abstract void setUri(String uri);
+
+	/**
+	 * @return - the person name value
+	 */
+	public abstract String getName();
+
+	/**
+	 * @return - the person email value
+	 */
+	public abstract String getEmail();
+
+	/**
+	 * @return - the person uri value
+	 */
+	public abstract String getUri();
+	// TODO needs extension possibility
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMPublished.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMPublished.java
new file mode 100644
index 0000000..55036a8
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMPublished.java
@@ -0,0 +1,38 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom;
+
+/**
+ * 
+ * The "atom:published" element is a Date construct indicating an instant in
+ * time associated with an event early in the life cycle of the entry.
+ * Typically, atom:published will be associated with the initial creation or
+ * first availability of the resource.
+ * 
+ * <pre>
+ *  atomPublished = element atom:published { atomDateConstruct}
+ * </pre>
+ * 
+ * @author Simon Willnauer
+ * @see org.apache.lucene.gdata.gom.GOMDateConstruct
+ */
+public interface GOMPublished extends GOMDateConstruct {
+	/**
+	 * Atom local name for the xml element
+	 */
+	public static final String LOCALNAME = "published";
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMRights.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMRights.java
new file mode 100644
index 0000000..ff794c6
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMRights.java
@@ -0,0 +1,39 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom;
+
+import org.apache.lucene.gdata.gom.GOMElement;
+
+/**
+ * 
+ * The "atom:rights" element is a Text construct that conveys information about
+ * rights held in and over an entry or feed. The atom:rights element SHOULD NOT
+ * be used to convey machine-readable licensing information.
+ * 
+ * <pre>
+ *  atomRights = element atom:rights { atomTextConstruct }
+ * </pre>
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public interface GOMRights extends GOMElement {
+	/**
+	 * Atom local name for the xml element
+	 */
+	public static final String LOCALNAME = "rights";
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMSource.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMSource.java
new file mode 100644
index 0000000..2e17711
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMSource.java
@@ -0,0 +1,120 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom;
+
+import java.util.List;
+
+/**
+ * If an atom:entry is copied from one feed into another feed, then the source
+ * atom:feed's metadata (all child elements of atom:feed other than the
+ * atom:entry elements) MAY be preserved within the copied entry by adding an
+ * atom:source child element, if it is not already present in the entry, and
+ * including some or all of the source feed's Metadata elements as the
+ * atom:source element's children. Such metadata SHOULD be preserved if the
+ * source atom:feed contains any of the child elements atom:author,
+ * atom:contributor, atom:rights, or atom:category and those child elements are
+ * not present in the source atom:entry.
+ * 
+ * <pre>
+ *    atomSource =
+ *    element atom:source {
+ *    atomCommonAttributes,
+ *    (atomAuthor*
+ *    &amp; atomCategory*
+ *    &amp; atomContributor*
+ *    &amp; atomGenerator?
+ *    &amp; atomIcon?
+ *    &amp; atomId?
+ *    &amp; atomLink*
+ *    &amp; atomLogo?
+ *    &amp; atomRights?
+ *    &amp; atomSubtitle?
+ *    &amp; atomTitle?
+ *    &amp; atomUpdated?
+ *    &amp; extensionElement*)
+ *    }
+ * </pre>
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public interface GOMSource extends GOMXmlEntity, GOMElement {
+	public static final String LOCALNAME = "source";
+
+	/**
+	 * @param aAuthor
+	 */
+	public void addAuthor(GOMAuthor aAuthor);
+
+	/**
+	 * @param aCategory
+	 */
+	public void addCategory(GOMCategory aCategory);
+
+	/**
+	 * @param aContributor
+	 */
+	public void addContributor(GOMContributor aContributor);
+
+	/**
+	 * @param aLink
+	 */
+	public void addLink(GOMLink aLink);
+
+	public List<GOMAuthor> getAuthors();
+
+	public List<GOMCategory> getCategories();
+
+	public List<GOMContributor> getContributor();
+
+	public GOMGenerator getGenerator();
+
+	public GOMId getId();
+
+	public void setGenerator(GOMGenerator aGenerator);
+
+	public void setIcon(GOMIcon aIcon);
+
+	public void setId(GOMId aId);
+
+	public GOMLogo getLogo();
+
+	public void setLogo(GOMLogo aLogo);
+
+	public GOMRights getRights();
+
+	public void setRights(GOMRights aRights);
+
+	public GOMSubtitle getSubtitle();
+
+	public void setSubtitle(GOMSubtitle aSubtitle);
+
+	public GOMTitle getTitle();
+
+	public void setTitle(GOMTitle aTitle);
+
+	public GOMUpdated getUpdated();
+
+	public void setUpdated(GOMUpdated aUpdated);
+
+	public GOMIcon getIcon();
+
+	public List<GOMLink> getLinks();
+	
+	//TODO needs extension elements
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMSubtitle.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMSubtitle.java
new file mode 100644
index 0000000..c5116c5
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMSubtitle.java
@@ -0,0 +1,41 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom;
+
+/**
+ * 
+ * The "atom:subtitle" element is a Text construct that conveys a human-readable
+ * description or subtitle for a feed.
+ * 
+ * <pre>
+ *  atomSubtitle = element atom:subtitle { atomTextConstruct }
+ * </pre>
+ * 
+ * @author Simon Willnauer
+ * @see org.apache.lucene.gdata.gom.GOMTextConstruct
+ */
+public interface GOMSubtitle extends GOMTextConstruct {
+	/**
+	 * Atom local name for the xml element
+	 */
+	public static final String LOCALNAME = "subtitle";
+
+	/**
+	 * RSS local name for the xml element
+	 */
+	public static final String RSS_LOCALNAME = "description";
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMSummary.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMSummary.java
new file mode 100644
index 0000000..def9765
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMSummary.java
@@ -0,0 +1,29 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public interface GOMSummary extends GOMTextConstruct {
+
+	/**
+	 * Atom local name for the xml element
+	 */
+	public static final String LOCALNAME = "summary";
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMTextConstruct.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMTextConstruct.java
new file mode 100644
index 0000000..be72991
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMTextConstruct.java
@@ -0,0 +1,25 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public interface GOMTextConstruct extends GOMElement {
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMTime.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMTime.java
new file mode 100644
index 0000000..e2653be
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMTime.java
@@ -0,0 +1,27 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom;
+
+import org.apache.lucene.gdata.gom.GOMElement;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public interface GOMTime extends GOMElement {
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMTitle.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMTitle.java
new file mode 100644
index 0000000..75f8e14
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMTitle.java
@@ -0,0 +1,43 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom;
+
+/**
+ * 
+ * The "atom:title" element is a Text construct that conveys a human-readable
+ * title for an entry or feed.
+ * 
+ * <pre>
+ *  atomTitle = element atom:title { atomTextConstruct }
+ * </pre>
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public interface GOMTitle extends GOMElement {
+
+	/**
+	 * Atom local name for the xml element
+	 */
+	public static final String LOCALNAME = "title";
+
+	/**
+	 * @return - the content type attribute value as a {@link ContentType}
+	 * @see ContentType
+	 */
+	public abstract ContentType getContentType();
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMUpdated.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMUpdated.java
new file mode 100644
index 0000000..e0bd13a
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMUpdated.java
@@ -0,0 +1,38 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom;
+
+/**
+ * 
+ * The "atom:updated" element is a Date construct indicating the most recent
+ * instant in time when an entry or feed was modified in a way the publisher
+ * considers significant. Therefore, not all modifications necessarily result in
+ * a changed atom:updated value.
+ * 
+ * <pre>
+ *  atomUpdated = element atom:updated { atomDateConstruct}
+ * </pre>
+ * 
+ * @author Simon Willnauer
+ * @see org.apache.lucene.gdata.gom.GOMDateConstruct
+ */
+public interface GOMUpdated extends GOMDateConstruct {
+	/**
+	 * Atom local name for the xml element
+	 */
+	public static final String LOCALNAME = "updated";
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMXmlEntity.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMXmlEntity.java
new file mode 100644
index 0000000..b73ed26
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/GOMXmlEntity.java
@@ -0,0 +1,69 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.gom;
+
+import javax.xml.namespace.QName;
+
+/**
+ * GOMXmlEntity is a abstract base interface for all Gdata Object Model
+ * Interfaces to be implemented by any class which is a part of the GOM. This
+ * interface defines a basic interface for xml attributes and elements
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public abstract interface GOMXmlEntity {
+
+	/**
+	 * @return - the entities QName
+	 * @see QName
+	 * 
+	 */
+	public abstract QName getQname();
+
+	/**
+	 * @param aString - the namespace uri to set
+	 */
+	public abstract void setNamespaceUri(String aString);
+
+	/**
+	 * @param aString - the namespace prefix to set
+	 */
+	public abstract void setNamespacePrefix(String aString);
+
+	/**
+	 * @param aLocalName - the localname of the entitiy
+	 */
+	public abstract void setLocalName(String aLocalName);
+
+	/**
+	 * @return - the local name of the entitiy
+	 */
+	public abstract String getLocalName();
+
+	/**
+	 * @return - the text value of the entity
+	 */
+	public abstract String getTextValue();
+
+	/**
+	 * @param aTextValue - the text value of the entity
+	 */
+	public abstract void setTextValue(String aTextValue);
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/AbstractGOMElement.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/AbstractGOMElement.java
new file mode 100644
index 0000000..ab2c694
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/AbstractGOMElement.java
@@ -0,0 +1,232 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import java.util.LinkedList;
+import java.util.List;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.GOMAttribute;
+import org.apache.lucene.gdata.gom.GOMElement;
+import org.apache.lucene.gdata.gom.GOMNamespace;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+/**
+ * @author Simon Willnauer
+ */
+public abstract class AbstractGOMElement implements GOMElement {
+	/**
+	 * atomCommonAttribute <br/> attribute xml:lang { atomLanguageTag }?
+	 */
+	protected String xmlLang;
+
+	/**
+	 * atomCommonAttribute <br/> attribute xml:base { atomUri }?
+	 */
+	protected String xmlBase;
+
+	protected QName qname;
+
+	protected String textValue;
+
+	protected String localName;
+
+	protected String nsUri;
+
+	protected String nsPrefix;
+
+	/**
+	 * atomCommonAttributes <br/> undefinedAttribute*
+	 */
+	protected List<GOMAttribute> extensionAttributes = new LinkedList<GOMAttribute>();
+
+	/**
+	 * {@inheritDoc}
+	 * 
+	 * @see org.apache.lucene.gdata.gom.GOMXmlEntity#getQname()
+	 */
+	public QName getQname() {
+		return this.qname;
+	}
+
+	/**
+	 * {@inheritDoc}
+	 * 
+	 * @see org.apache.lucene.gdata.gom.GOMXmlEntity#getTextValue()
+	 */
+	public String getTextValue() {
+		return this.textValue;
+	}
+
+	/**
+	 * {@inheritDoc}
+	 * 
+	 * @see org.apache.lucene.gdata.gom.GOMXmlEntity#setTextValue(java.lang.String)
+	 */
+	public void setTextValue(String aTextValue) {
+		this.textValue = aTextValue;
+
+	}
+
+	/**
+	 * {@inheritDoc}
+	 * 
+	 * @see org.apache.lucene.gdata.gom.GOMXmlEntity#getLocalName()
+	 */
+	public String getLocalName() {
+		return this.localName;
+	}
+
+	/**
+	 * {@inheritDoc}
+	 * 
+	 * @see org.apache.lucene.gdata.gom.GOMXmlEntity#setLocalName(java.lang.String)
+	 */
+	public void setLocalName(String aLocalName) {
+		// must override
+	}
+
+	protected void addAttribute(GOMAttribute aAttribute) {
+		if (aAttribute != null)
+			this.extensionAttributes.add(aAttribute);
+
+	}
+
+	/**
+	 * {@inheritDoc}
+	 * 
+	 * @see org.apache.lucene.gdata.gom.core.AtomParser#getChildParser(javax.xml.namespace.QName)
+	 */
+	public AtomParser getChildParser(QName aName) {
+		throw new GDataParseException(String.format(UNEXPECTED_ELEMENT_CHILD,
+				this.qname));
+	}
+
+	/**
+	 * {@inheritDoc}
+	 * 
+	 * @see org.apache.lucene.gdata.gom.core.AtomParser#processAttribute(javax.xml.namespace.QName,
+	 *      java.lang.String)
+	 */
+	public void processAttribute(QName aQName, String aValue) {
+		if (aQName == null)
+			throw new GDataParseException("QName must not be null");
+		if (aQName.getNamespaceURI().equals(GOMNamespace.XML_NS_URI)) {
+			if (aQName.getLocalPart().equals(XML_BASE))
+				this.xmlBase = aValue;
+			else if (aQName.getLocalPart().equals(XML_LANG))
+				this.xmlLang = aValue;
+
+		} else {
+			GOMAttributeImpl impl = new GOMAttributeImpl(aQName
+					.getNamespaceURI(), aQName.getPrefix(), aQName
+					.getLocalPart(), aValue);
+			this.addAttribute(impl);
+		}
+
+	}
+
+	/**
+	 * {@inheritDoc}
+	 * 
+	 * @see org.apache.lucene.gdata.gom.core.AtomParser#processElementValue(java.lang.String)
+	 */
+	public void processElementValue(String aValue) {
+		throw new GDataParseException(String.format(UNEXPECTED_ELEMENT_VALUE,
+				this.qname));
+	}
+
+	/**
+	 * {@inheritDoc}
+	 * 
+	 * @see org.apache.lucene.gdata.gom.core.AtomParser#processEndElement()
+	 */
+	public void processEndElement() {
+		// no post processing
+
+	}
+
+	/**
+	 * {@inheritDoc}
+	 * 
+	 * @see org.apache.lucene.gdata.gom.GOMXmlEntity#setNamespaceUri(java.lang.String)
+	 */
+	public void setNamespaceUri(String aString) {
+		this.nsUri = aString;
+
+	}
+
+	/**
+	 * 
+	 * {@inheritDoc}
+	 * 
+	 * @see org.apache.lucene.gdata.gom.GOMXmlEntity#setNamespacePrefix(java.lang.String)
+	 */
+	public void setNamespacePrefix(String aString) {
+		this.nsPrefix = aString;
+	}
+
+	protected List<GOMAttribute> getXmlNamespaceAttributes() {
+		List<GOMAttribute> retVal = new LinkedList<GOMAttribute>();
+		if (this.xmlBase != null)
+			retVal.add(new GOMAttributeImpl(GOMNamespace.XML_NS_URI,
+					GOMNamespace.XML_NS_PREFIX, "base", this.xmlBase));
+		if (this.xmlLang != null)
+			retVal.add(new GOMAttributeImpl(GOMNamespace.XML_NS_URI,
+					GOMNamespace.XML_NS_PREFIX, "lang", this.xmlLang));
+		return retVal;
+
+	}
+
+	/**
+	 * {@inheritDoc}
+	 * 
+	 * @see org.apache.lucene.gdata.gom.GOMElement#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter,
+	 *      java.lang.String)
+	 */
+	public void writeRssOutput(GOMOutputWriter aStreamWriter, String aRssName)
+			throws XMLStreamException {
+
+	}
+
+
+
+
+	/**
+	 * 
+	 * {@inheritDoc}
+	 * 
+	 * @see org.apache.lucene.gdata.gom.GOMElement#getXmlBase()
+	 */
+	public String getXmlBase() {
+		return this.xmlBase;
+	}
+
+	/**
+	 * 
+	 * {@inheritDoc}
+	 * 
+	 * @see org.apache.lucene.gdata.gom.GOMElement#getXmlLang()
+	 */
+	public String getXmlLang() {
+
+		return this.xmlLang;
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/ArbitraryGOMXml.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/ArbitraryGOMXml.java
new file mode 100644
index 0000000..37e2de6
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/ArbitraryGOMXml.java
@@ -0,0 +1,162 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import java.util.LinkedList;
+import java.util.List;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.GOMAttribute;
+import org.apache.lucene.gdata.gom.GOMElement;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+//TODO add java doc
+/**
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class ArbitraryGOMXml extends AbstractGOMElement {
+	private List<GOMElement> children = new LinkedList<GOMElement>();
+
+	private List<GOMAttribute> attributes = new LinkedList<GOMAttribute>();
+
+	/**
+	 * this method will never return <code>null</code>
+	 * 
+	 * @return Returns the attributes of this xml element.
+	 */
+	public List<GOMAttribute> getAttributes() {
+		return this.attributes;
+	}
+
+	/**
+	 * this method will never return <code>null</code>
+	 * 
+	 * @return - the child elements of this xml element
+	 */
+	public List<GOMElement> getChildren() {
+		return this.children;
+	}
+
+	/**
+	 * Class constructor
+	 * 
+	 * @param qname -
+	 *            the elements qname
+	 */
+	public ArbitraryGOMXml(QName qname) {
+		if (qname == null)
+			throw new IllegalArgumentException("QName must not be null");
+
+		this.qname = qname;
+		this.localName = qname.getLocalPart();
+	}
+
+	/**
+	 * {@inheritDoc} 
+	 * 
+	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#getChildParser(javax.xml.namespace.QName)
+	 */
+	@Override
+	public AtomParser getChildParser(QName aName) {
+		if (aName == null)
+			throw new GDataParseException("QName must not be null");
+		/*
+		 * either a text value or a child
+		 */
+		if (this.textValue != null)
+			throw new GDataParseException(String.format(
+					AtomParser.UNEXPECTED_ELEMENT_CHILD, this.localName));
+		GOMElement element = new ArbitraryGOMXml(aName);
+		this.children.add(element);
+		return element;
+	}
+
+	/**
+	 * {@inheritDoc} 
+	 * 
+	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#processAttribute(javax.xml.namespace.QName,
+	 *      java.lang.String)
+	 */
+	@Override
+	public void processAttribute(QName aQName, String aValue) {
+		if (aQName == null)
+			throw new GDataParseException("QName must not be null");
+		GOMAttributeImpl impl = new GOMAttributeImpl(aQName.getNamespaceURI(),
+				aQName.getPrefix(), aQName.getLocalPart(), aValue);
+		this.attributes.add(impl);
+
+	}
+
+	/**
+	 * {@inheritDoc}
+	 * 
+	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#processElementValue(java.lang.String)
+	 */
+	@Override
+	public void processElementValue(String aValue) {
+		if (aValue == null)
+			throw new GDataParseException("Element value must not be null");
+		/*
+		 * either a text value or a child
+		 */
+		if (this.children.size() > 0)
+			throw new GDataParseException(String.format(
+					AtomParser.UNEXPECTED_ELEMENT_VALUE, this.localName));
+		if (this.textValue != null)
+			throw new GDataParseException(String.format(
+					AtomParser.UNEXPECTED_ELEMENT_VALUE, this.localName));
+		this.textValue = aValue;
+
+	}
+
+	/**
+	 * {@inheritDoc}
+	 * 
+	 * @see org.apache.lucene.gdata.gom.GOMElement#writeAtomOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
+	 */
+	public void writeAtomOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+		if (aStreamWriter == null)
+			throw new NullPointerException("StreamWriter is null");
+		aStreamWriter.writeStartElement(this.qname, this.attributes);
+		if (this.textValue == null) {
+			for (GOMElement element : this.children) {
+				element.writeAtomOutput(aStreamWriter);
+			}
+		} else {
+			aStreamWriter.writeContent(this.textValue);
+		}
+		aStreamWriter.writeEndElement();
+
+	}
+
+	/**
+	 * {@inheritDoc}
+	 * 
+	 * @see org.apache.lucene.gdata.gom.GOMElement#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
+	 */
+	public void writeRssOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+		// delegate it by default
+		this.writeAtomOutput(aStreamWriter);
+
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/AtomParser.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/AtomParser.java
new file mode 100644
index 0000000..a0178c9
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/AtomParser.java
@@ -0,0 +1,134 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import javax.xml.namespace.QName;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public interface AtomParser {
+
+	/**
+	 * Error message for an unexpected element
+	 * @see String#format(java.lang.String, java.lang.Object[])
+	 */
+	public static final String UNEXPECTED_ELEMENT = "Expected Element '%s' but was '%s' ";
+
+
+	/**
+	 * Error message for an unexpected element child
+	 * @see String#format(java.lang.String, java.lang.Object[])
+	 */
+	public static final String UNEXPECTED_ELEMENT_CHILD = "Element '%s' can not contain child elements ";
+
+	/**
+	 * Error message for an urecognized element child
+	 * @see String#format(java.lang.String, java.lang.Object[])
+	 */
+	public static final String URECOGNIZED_ELEMENT_CHILD = "Element '%s' can not contain child elements of the type %s";
+
+	/**
+	 * Error message for an unexpected attribute
+	 * @see String#format(java.lang.String, java.lang.Object[])
+	 */
+	public static final String UNEXPECTED_ATTRIBUTE = "Element '%s' can not contain attributes ";
+
+	/**
+	 * Error message for an unexpected element value
+	 * @see String#format(java.lang.String, java.lang.Object[])
+	 */
+	public static final String UNEXPECTED_ELEMENT_VALUE = "Element '%s' can not contain any element value";
+
+	/**
+	 * Error message for a missing element attribute
+	 * @see String#format(java.lang.String, java.lang.Object[])
+	 */
+	public static final String MISSING_ELEMENT_ATTRIBUTE = "Element '%s' requires an '%s' attribute";
+
+	/**
+	 * Error message for a missing element child
+	 * @see String#format(java.lang.String, java.lang.Object[])
+	 */
+	public static final String MISSING_ELEMENT_CHILD = "Element '%s' requires a child of the type '%s'";
+
+	/**
+	 * Error message for a missing element value
+	 * @see String#format(java.lang.String, java.lang.Object[])
+	 */
+	public static final String MISSING_ELEMENT_VALUE = "Element '%s' requires a element value of the type '%s'";
+
+	/**
+	 * Error message for a missing element value 
+	 * @see String#format(java.lang.String, java.lang.Object[])
+	 */
+	public static final String MISSING_ELEMENT_VALUE_PLAIN = "Element '%s' requires a element value'";
+
+	/**
+	 * Error message for a duplicated element
+	 * @see String#format(java.lang.String, java.lang.Object[])
+	 */
+	public static final String DUPLICATE_ELEMENT = "Duplicated Element '%s'";
+
+	/**
+	 * Error message for a duplicated element value
+	 * @see String#format(java.lang.String, java.lang.Object[])
+	 */
+	public static final String DUPLICATE_ELEMENT_VALUE = "Duplicated Element value for element '%s'";
+
+	/**
+	 * Error message for a duplicated attribute
+	 * @see String#format(java.lang.String, java.lang.Object[])
+	 */
+	public static final String DUPLICATE_ATTRIBUTE = "Duplicated Attribute '%s'";
+
+	/**
+	 * Error message for an invalid attribute
+	 * @see String#format(java.lang.String, java.lang.Object[])
+	 */
+	public static final String INVALID_ATTRIBUTE = "The attribute '%s' must be an %s";
+
+	/**
+	 * Error message for an invalid element value
+	 * @see String#format(java.lang.String, java.lang.Object[])
+	 */
+	public static final String INVALID_ELEMENT_VALUE = "The element value '%s' must be an %s";
+
+	/**
+	 * @param aValue
+	 */
+	public abstract void processElementValue(String aValue);
+
+	/**
+	 * @param aQName
+	 * @param aValue
+	 */
+	public abstract void processAttribute(QName aQName, String aValue);
+
+	/**
+	 * 
+	 */
+	public abstract void processEndElement();
+
+	/**
+	 * @param name
+	 * @return
+	 */
+	public abstract AtomParser getChildParser(QName name);
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/AtomUriElement.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/AtomUriElement.java
new file mode 100644
index 0000000..8bade2e
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/AtomUriElement.java
@@ -0,0 +1,45 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import java.net.URISyntaxException;
+
+import org.apache.lucene.gdata.gom.core.utils.AtomParserUtils;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+abstract class AtomUriElement extends SimpleGOMElementImpl {
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.SimpleGOMElementImpl#processEndElement()
+	 */
+	@Override
+	public void processEndElement() {
+		if (this.textValue == null)
+			throw new GDataParseException(String.format(
+					MISSING_ELEMENT_VALUE, this.localName, "atomUri"));
+		try {
+			AtomParserUtils.getAbsolutAtomURI(this.xmlBase, this.textValue);
+		} catch (URISyntaxException e) {
+			throw new GDataParseException(String.format(INVALID_ELEMENT_VALUE,
+					this.localName, "absolute uri"), e);
+		}
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GDataParseException.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GDataParseException.java
new file mode 100644
index 0000000..3978198
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GDataParseException.java
@@ -0,0 +1,58 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class GDataParseException extends RuntimeException {
+
+	/**
+	 * Serial Version ID -- implements {@link java.io.Serializable}
+	 */
+	private static final long serialVersionUID = -3633604155009277238L;
+
+	/**
+	 * 
+	 */
+	public GDataParseException() {
+	}
+
+	/**
+	 * @param arg0
+	 */
+	public GDataParseException(String arg0) {
+		super(arg0);
+	}
+
+	/**
+	 * @param arg0
+	 */
+	public GDataParseException(Throwable arg0) {
+		super(arg0);
+	}
+
+	/**
+	 * @param arg0
+	 * @param arg1
+	 */
+	public GDataParseException(String arg0, Throwable arg1) {
+		super(arg0, arg1);
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMAttributeImpl.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMAttributeImpl.java
new file mode 100644
index 0000000..8e6baab
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMAttributeImpl.java
@@ -0,0 +1,151 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import javax.xml.namespace.QName;
+
+import org.apache.lucene.gdata.gom.GOMAttribute;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class GOMAttributeImpl implements GOMAttribute {
+	private boolean hasDefaultNamespace;
+
+	private QName qName;
+
+	private String localName;
+
+	private String uri;
+
+	private String prefix;
+
+	private String value;
+
+	/**
+	 * 
+	 */
+	public GOMAttributeImpl() {
+		super();
+	}
+
+	/**
+	 * @param localName
+	 * @param value
+	 */
+	public GOMAttributeImpl(String localName, String value) {
+		this.hasDefaultNamespace = true;
+		this.value = value;
+		this.localName = localName;
+	}
+
+	/**
+	 * @param namespaceUri
+	 * @param namespacePrefix
+	 * @param localName
+	 * @param value
+	 */
+	public GOMAttributeImpl(String namespaceUri, String namespacePrefix,
+			String localName, String value) {
+		this.localName = localName;
+		this.uri = namespaceUri;
+		this.prefix = namespacePrefix;
+		this.value = value;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMXmlEntity#getQname()
+	 */
+	public QName getQname() {
+		if (this.qName == null)
+			this.qName = new QName(this.uri, (this.localName == null ? ""
+					: this.localName), (this.prefix == null ? "" : this.prefix));
+		return this.qName;
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMXmlEntity#setLocalName(java.lang.String)
+	 */
+	public void setLocalName(String aLocalName) {
+		if (aLocalName == null)
+			return;
+		this.qName = null;
+		this.localName = aLocalName;
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMXmlEntity#getLocalName()
+	 */
+	public String getLocalName() {
+		return this.localName;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMXmlEntity#getTextValue()
+	 */
+	public String getTextValue() {
+		return this.value == null ? "" : this.value;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMXmlEntity#setTextValue(java.lang.String)
+	 */
+	public void setTextValue(String aTextValue) {
+		this.value = aTextValue;
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMAttribute#hasDefaultNamespace()
+	 */
+	public boolean hasDefaultNamespace() {
+
+		return this.hasDefaultNamespace;
+	}
+
+	void setHasDefaultNamespace(boolean aBoolean) {
+		this.hasDefaultNamespace = aBoolean;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMXmlEntity#setNamespaceUri(java.lang.String)
+	 */
+	public void setNamespaceUri(String aString) {
+		if (aString == null)
+			return;
+		this.qName = null;
+		this.hasDefaultNamespace = false;
+		this.uri = aString;
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMXmlEntity#setNamespacePrefix(java.lang.String)
+	 */
+	public void setNamespacePrefix(String aString) {
+		if (aString == null)
+			return;
+		this.qName = null;
+		this.hasDefaultNamespace = false;
+		this.prefix = aString;
+
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMAuthorImpl.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMAuthorImpl.java
new file mode 100644
index 0000000..4045c1c
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMAuthorImpl.java
@@ -0,0 +1,49 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.GOMAuthor;
+import org.apache.lucene.gdata.gom.GOMNamespace;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class GOMAuthorImpl extends GOMPersonImpl implements GOMAuthor {
+	/**
+	 * 
+	 */
+	public GOMAuthorImpl() {
+		this.localName = GOMAuthor.LOCALNAME;
+		this.qname = new QName(GOMNamespace.ATOM_NS_URI, this.localName);
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.GOMPersonImpl#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
+	 */
+	@Override
+	public void writeRssOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+		writeRssOutput(aStreamWriter, this.localName);
+
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMBuilder.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMBuilder.java
new file mode 100644
index 0000000..e92cfb5
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMBuilder.java
@@ -0,0 +1,154 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import java.util.Stack;
+
+import javax.xml.stream.XMLStreamConstants;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamReader;
+
+import org.apache.lucene.gdata.gom.GOMDocument;
+import org.apache.lucene.gdata.gom.GOMEntry;
+import org.apache.lucene.gdata.gom.GOMFeed;
+import org.apache.lucene.gdata.gom.GOMNamespace;
+
+/**
+ * @author Simon Willnauer
+ */
+public class GOMBuilder {
+
+	private final XMLStreamReader streamReader;
+
+	private final GOMFactory factory;
+
+	private final Stack<AtomParser> parserStack;
+
+	/**
+	 * @param arg0
+	 */
+	public GOMBuilder(XMLStreamReader arg0) {
+		if (arg0 == null)
+			throw new IllegalArgumentException(
+					"XMLStreamReader instance must not be null");
+		this.streamReader = arg0;
+		this.factory = GOMFactory.createInstance();
+		this.parserStack = new Stack<AtomParser>();
+	}
+
+	public GOMDocument<GOMFeed> buildGOMFeed() throws XMLStreamException {
+		GOMDocument<GOMFeed> document = new GOMDocumentImpl<GOMFeed>();
+		GOMFeed element = startFeedDocument(document);
+		document.setRootElement(element);
+		parse(this.streamReader);
+
+		return document;
+	}
+
+	private void parse(XMLStreamReader aReader) throws XMLStreamException {
+
+		int next = 0;
+
+		while ((next = next()) != XMLStreamConstants.END_DOCUMENT) {
+
+			if (next == XMLStreamConstants.START_ELEMENT) {
+				AtomParser childParser = this.parserStack.peek()
+						.getChildParser(this.streamReader.getName());
+				processAttributes(childParser);
+				this.parserStack.push(childParser);
+			} else if (next == XMLStreamConstants.END_ELEMENT) {
+				this.parserStack.pop().processEndElement();
+			} else if (next == XMLStreamConstants.CHARACTERS) {
+				this.parserStack.peek().processElementValue(
+						this.streamReader.getText());
+			} else if (next == XMLStreamConstants.CDATA) {
+				System.out.println("CDdata");
+			}
+			// System.out.println(next);
+		}
+
+	}
+
+	/**
+	 * @param childParser
+	 */
+	private void processAttributes(AtomParser childParser) {
+		int attributeCount = this.streamReader.getAttributeCount();
+		for (int i = 0; i < attributeCount; i++) {
+			childParser.processAttribute(this.streamReader.getAttributeName(i),
+					this.streamReader.getAttributeValue(i));
+		}
+	}
+
+	public GOMDocument<GOMEntry> buildGOMEntry() throws XMLStreamException {
+		GOMDocument<GOMEntry> document = new GOMDocumentImpl<GOMEntry>();
+		GOMEntry element = startEntryDocument(document);
+		document.setRootElement(element);
+		parse(this.streamReader);
+
+		return document;
+
+	}
+
+	private GOMEntry startEntryDocument(GOMDocument aDocument)
+			throws XMLStreamException {
+		aDocument.setVersion(this.streamReader.getVersion());
+		aDocument.setCharacterEncoding(this.streamReader
+				.getCharacterEncodingScheme());
+		GOMEntry entry = this.factory.createEntry();
+		if (next() != XMLStreamConstants.START_ELEMENT)
+			throw new GDataParseException("Expected start of feed element");
+		processAttributes(entry);
+		this.parserStack.push(entry);
+		int count = this.streamReader.getNamespaceCount();
+		for (int i = 0; i < count; i++) {
+			GOMNamespace namespace = new GOMNamespace(this.streamReader
+					.getNamespaceURI(i), this.streamReader
+					.getNamespacePrefix(i));
+			entry.addNamespace(namespace);
+		}
+		return entry;
+	}
+
+	private GOMFeed startFeedDocument(GOMDocument aDocument)
+			throws XMLStreamException {
+		aDocument.setVersion(this.streamReader.getVersion());
+		aDocument.setCharacterEncoding(this.streamReader
+				.getCharacterEncodingScheme());
+		GOMFeed feed = this.factory.createFeed();
+		if (next() != XMLStreamConstants.START_ELEMENT)
+			throw new GDataParseException("Expected start of feed element");
+		processAttributes(feed);
+		this.parserStack.push(feed);
+		int count = this.streamReader.getNamespaceCount();
+		for (int i = 0; i < count; i++) {
+
+			GOMNamespace namespace = new GOMNamespace(this.streamReader
+					.getNamespaceURI(i), this.streamReader
+					.getNamespacePrefix(i));
+			System.out.println(namespace);
+			feed.addNamespace(namespace);
+		}
+		return feed;
+	}
+
+	private int next() throws XMLStreamException {
+		return this.streamReader.next();
+
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMCategoryImpl.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMCategoryImpl.java
new file mode 100644
index 0000000..91b69b6
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMCategoryImpl.java
@@ -0,0 +1,206 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import java.net.URISyntaxException;
+import java.util.LinkedList;
+import java.util.List;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.GOMAttribute;
+import org.apache.lucene.gdata.gom.GOMCategory;
+import org.apache.lucene.gdata.gom.GOMNamespace;
+import org.apache.lucene.gdata.gom.core.utils.AtomParserUtils;
+import org.apache.lucene.gdata.gom.core.utils.GOMUtils;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class GOMCategoryImpl extends AbstractGOMElement implements GOMCategory {
+
+	private static final String DOMAIN = "domain";
+
+	protected String term;
+
+	protected String label;
+
+	protected String scheme;
+
+	/**
+	 * 
+	 */
+	public GOMCategoryImpl() {
+		super();
+		this.localName = LOCALNAME;
+		this.qname = new QName(GOMNamespace.ATOM_NS_URI, this.localName);
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMCategory#setTerm(java.lang.String)
+	 */
+	public void setTerm(String aTerm) {
+
+		this.term = aTerm;
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMCategory#setLabel(java.lang.String)
+	 */
+	public void setLabel(String aLabel) {
+		this.label = aLabel;
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMCategory#setScheme(java.lang.String)
+	 */
+	public void setScheme(String aScheme) {
+		this.scheme = aScheme;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMCategory#getTerm()
+	 */
+	public String getTerm() {
+		return this.term;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMCategory#getScheme()
+	 */
+	public String getScheme() {
+		return this.scheme;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMCategory#getLabel()
+	 */
+	public String getLabel() {
+		return this.label;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#processAttribute(javax.xml.namespace.QName,
+	 *      java.lang.String)
+	 */
+	@Override
+	public void processAttribute(QName aQName, String aValue) {
+		if (aQName == null)
+			throw new GDataParseException("QName must not be null");
+		if (aQName.getNamespaceURI().equals(GOMNamespace.ATOM_NS_URI)
+				|| aQName.getNamespaceURI().equals("")) {
+			String localPart = aQName.getLocalPart();
+			if (localPart.equals(TERM_ATTRIBUTE)) {
+				if (this.term != null)
+					throw new GDataParseException(String.format(
+							AtomParser.DUPLICATE_ATTRIBUTE, TERM_ATTRIBUTE));
+				this.term = aValue;
+			} else if (localPart.equals(LABLE_ATTRIBUTE)) {
+				if (this.label != null)
+					throw new GDataParseException(String.format(
+							AtomParser.DUPLICATE_ATTRIBUTE, LABLE_ATTRIBUTE));
+				this.label = aValue;
+			} else if (localPart.equals(SCHEME_ATTRIBUTE)) {
+				if (this.scheme != null)
+					throw new GDataParseException(String.format(
+							AtomParser.DUPLICATE_ATTRIBUTE, SCHEME_ATTRIBUTE));
+				this.scheme = aValue;
+			} else {
+				super.processAttribute(aQName, aValue);
+			}
+
+		} else {
+			super.processAttribute(aQName, aValue);
+		}
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#processEndElement()
+	 */
+	@Override
+	public void processEndElement() {
+		/*
+		 * ATOM defines "undefinedContent" for this. GData defines this as no
+		 * content containing element
+		 */
+		if (this.term == null)
+			throw new GDataParseException(String.format(
+					AtomParser.MISSING_ELEMENT_ATTRIBUTE, this.localName,
+					TERM_ATTRIBUTE));
+		if (this.scheme != null) {
+			try {
+				AtomParserUtils.getAbsolutAtomURI(this.xmlBase, this.scheme);
+			} catch (URISyntaxException e) {
+				throw new GDataParseException(String.format(
+						AtomParser.INVALID_ATTRIBUTE, this.localName
+								+ " attribute " + GOMCategory.SCHEME_ATTRIBUTE,
+						"absolute uri"), e);
+			}
+		}
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMElement#writeAtomOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
+	 */
+	public void writeAtomOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+		if (aStreamWriter == null)
+			throw new NullPointerException("StreamWriter is null");
+		List<GOMAttribute> list = new LinkedList<GOMAttribute>();
+		/*
+		 * term attribute is requiered for a category. attribute term { text },
+		 */
+		list.add(GOMUtils.buildDefaultNamespaceAttribute(this.term,
+				TERM_ATTRIBUTE));
+		if (this.scheme != null)
+			list.add(GOMUtils.buildDefaultNamespaceAttribute(this.scheme,
+					SCHEME_ATTRIBUTE));
+		if (this.label != null)
+			list.add(GOMUtils.buildDefaultNamespaceAttribute(this.label,
+					LABLE_ATTRIBUTE));
+
+		if (this.xmlLang != null)
+			list.add(GOMUtils
+					.buildXMLNamespaceAttribute(this.xmlLang, XML_LANG));
+		aStreamWriter.writeSimpleXMLElement(this.localName, list, null);
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMElement#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
+	 */
+	public void writeRssOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+		if (aStreamWriter == null)
+			throw new NullPointerException("StreamWriter is null");
+		List<GOMAttribute> list = getXmlNamespaceAttributes();
+		/*
+		 * build this domain attr. even if scheme is null or empty
+		 */
+		list.add(GOMUtils.buildDefaultNamespaceAttribute(this.scheme, DOMAIN));
+
+		aStreamWriter.writeSimpleXMLElement(this.localName, list, this.term);
+
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMContentImpl.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMContentImpl.java
new file mode 100644
index 0000000..4263045
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMContentImpl.java
@@ -0,0 +1,216 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import java.net.URISyntaxException;
+import java.util.List;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.AtomMediaType;
+import org.apache.lucene.gdata.gom.GOMAttribute;
+import org.apache.lucene.gdata.gom.GOMContent;
+import org.apache.lucene.gdata.gom.GOMNamespace;
+import org.apache.lucene.gdata.gom.core.utils.AtomParserUtils;
+import org.apache.lucene.gdata.gom.core.utils.GOMUtils;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class GOMContentImpl extends GOMTextContructImpl implements GOMContent {
+	private String src;
+
+	private String type;
+
+	private AtomMediaType mediaType;
+
+	/**
+	 * 
+	 */
+	public GOMContentImpl() {
+		this.localName = GOMContent.LOCALNAME;
+		this.qname = new QName(GOMNamespace.ATOM_NS_URI, this.localName);
+		this.rssLocalName = GOMContent.LOCAL_NAME_RSS;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMContent#getSrc()
+	 */
+	public String getSrc() {
+		return this.src;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMContent#setSrc(java.lang.String)
+	 */
+	public void setSrc(String aSrc) {
+		this.src = aSrc;
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.GOMTextContructImpl#processAttribute(javax.xml.namespace.QName,
+	 *      java.lang.String)
+	 */
+	@Override
+	public void processAttribute(QName aQName, String aValue) {
+		if (aQName == null)
+			throw new GDataParseException("QName must not be null");
+		if (aValue == null)
+			throw new GDataParseException("Value must not be null");
+		if ("src".equals(aQName.getLocalPart())) {
+			if (this.src != null)
+				throw new GDataParseException(String.format(
+						DUPLICATE_ATTRIBUTE, "src"));
+			this.src = aValue;
+			return;
+		}
+		if ("type".equals(aQName.getLocalPart())) {
+			if (this.contentType != null || this.mediaType != null)
+				throw new GDataParseException(String.format(
+						DUPLICATE_ATTRIBUTE, "type"));
+			if (AtomParserUtils.isAtomMediaType(aValue)) {
+				this.type = aValue;
+				this.mediaType = AtomParserUtils.getAtomMediaType(aValue);
+				return;
+			}
+
+		}
+		super.processAttribute(aQName, aValue);
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.GOMTextContructImpl#processElementValue(java.lang.String)
+	 */
+	@Override
+	public void processElementValue(String aValue) {
+		if (this.src != null)
+			throw new GDataParseException(String.format(
+					AtomParser.UNEXPECTED_ELEMENT_VALUE, this.localName
+							+ " with attribute src set "));
+		super.processElementValue(aValue);
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.GOMTextContructImpl#processEndElement()
+	 */
+	@Override
+	public void processEndElement() {
+		if (this.src != null)
+			try {
+				AtomParserUtils.getAbsolutAtomURI(this.xmlBase, this.src);
+			} catch (URISyntaxException e) {
+				throw new GDataParseException(String.format(INVALID_ATTRIBUTE,
+						"src", "absolute uri"), e);
+			}
+
+		if (this.mediaType == null)
+			super.processEndElement();
+		else if (this.blobParser != null) {
+			this.textValue = this.blobParser.toString();
+			this.blobParser.close();
+			this.blobParser = null;
+		}
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.GOMTextContructImpl#getChildParser(javax.xml.namespace.QName)
+	 */
+	@Override
+	public AtomParser getChildParser(QName aName) {
+		if (aName == null)
+			throw new GDataParseException("QName must not be null");
+		if (this.mediaType == AtomMediaType.XML) {
+			if (this.blobParser != null)
+				throw new GDataParseException(String.format(
+						DUPLICATE_ELEMENT, aName.getLocalPart()));
+			this.blobParser = new XMLBlobContentParser();
+			return this.blobParser.getChildParser(aName);
+		}
+		return super.getChildParser(aName);
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMElement#writeAtomOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
+	 */
+	public void writeAtomOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+
+		if (this.mediaType != null) {
+			List<GOMAttribute> xmlNamespaceAttributes = getXmlNamespaceAttributes();
+			xmlNamespaceAttributes.add(GOMUtils.buildDefaultNamespaceAttribute(
+					this.type, "type"));
+			aStreamWriter.writeStartElement(this.localName,
+					xmlNamespaceAttributes);
+			if (this.src == null)
+				aStreamWriter.writeContentUnescaped(this.textValue);
+			else
+				aStreamWriter.writeAttribute(GOMUtils
+						.buildDefaultNamespaceAttribute(this.src, "src"));
+			aStreamWriter.writeEndElement();
+
+		} else {
+			super.writeAtomOutput(aStreamWriter);
+		}
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.GOMTextContructImpl#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
+	 */
+	@Override
+	public void writeRssOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+		if (this.mediaType != null) {
+			// if content is atomOutOfLineContent (has not textValue) ->
+			// generate a <link> element.
+			if (src != null) {
+				aStreamWriter.writeSimpleXMLElement("link", null, this.src);
+			} else if (this.mediaType == AtomMediaType.TEXT) {
+				aStreamWriter.writeSimpleXMLElement("description", null,
+						this.textValue);
+			} else {
+				// RSS doesn't support non-text content --> write atom type
+				this.writeAtomOutput(aStreamWriter);
+			}
+		} else {
+			super.writeRssOutput(aStreamWriter);
+		}
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMContent#setAtomMediaType(org.apache.lucene.gdata.gom.AtomMediaType)
+	 */
+	public void setAtomMediaType(AtomMediaType aMediaType) {
+
+		this.mediaType = aMediaType;
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMContent#getAtomMediaType()
+	 */
+	public AtomMediaType getAtomMediaType() {
+		return this.mediaType;
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMContributorImpl.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMContributorImpl.java
new file mode 100644
index 0000000..26c2d32
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMContributorImpl.java
@@ -0,0 +1,50 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.GOMAuthor;
+import org.apache.lucene.gdata.gom.GOMContributor;
+import org.apache.lucene.gdata.gom.GOMNamespace;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class GOMContributorImpl extends GOMPersonImpl implements GOMContributor {
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.GOMPersonImpl#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMOutputWriter)
+	 */
+	@Override
+	public void writeRssOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+		writeRssOutput(aStreamWriter, GOMAuthor.LOCALNAME);
+	}
+
+	/**
+	 * 
+	 */
+	public GOMContributorImpl() {
+		this.localName = GOMContributor.LOCALNAME;
+		this.qname = new QName(GOMNamespace.ATOM_NS_URI, this.localName);
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMDateConstructImpl.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMDateConstructImpl.java
new file mode 100644
index 0000000..0a124ea
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMDateConstructImpl.java
@@ -0,0 +1,100 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import java.util.Date;
+
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.GOMDateConstruct;
+import org.apache.lucene.gdata.gom.core.utils.GOMUtils;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+/**
+ * A Date construct is an element whose content MUST conform to the "date-time"
+ * production in [RFC3339]. In addition, an uppercase "T" character MUST be used
+ * to separate date and time, and an uppercase "Z" character MUST be present in
+ * the absence of a numeric time zone offset.
+ * 
+ * @author Simon Willnauer
+ */
+public abstract class GOMDateConstructImpl extends AbstractGOMElement implements
+		GOMDateConstruct {
+	protected long date;
+
+	/*
+	 * save the rfcString to skip the building while rendering the element
+	 */
+	protected String rfc3339String;
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMDateConstruct#setDate(java.util.Date)
+	 */
+	public void setDate(Date aDate) {
+		if (aDate == null)
+			return;
+		this.date = aDate.getTime();
+		this.rfc3339String = GOMUtils.buildRfc3339DateFormat(this.date);
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMDateConstruct#getDate()
+	 */
+	public Date getDate() {
+		return new Date(this.date);
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#processElementValue(java.lang.String)
+	 */
+	@Override
+	public void processElementValue(String aValue) {
+		if (aValue == null)
+			throw new IllegalArgumentException("element value must not be null");
+		this.date = GOMUtils.parseRfc3339DateFormat(aValue);
+		this.rfc3339String = aValue;
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#processEndElement()
+	 */
+	@Override
+	public void processEndElement() {
+		if (this.rfc3339String == null)
+			throw new GDataParseException(String.format(
+					MISSING_ELEMENT_VALUE, this.localName,
+					"RFC3339 Date Time"));
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMElement#writeAtomOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
+	 */
+	public void writeAtomOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+		if (this.rfc3339String == null)
+			this.rfc3339String = GOMUtils
+					.buildRfc3339DateFormat(this.date == 0 ? System
+							.currentTimeMillis() : this.date);
+		aStreamWriter.writeSimpleXMLElement(this.qname,
+				getXmlNamespaceAttributes(), this.rfc3339String);
+
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMDocumentImpl.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMDocumentImpl.java
new file mode 100644
index 0000000..ba0b8bd
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMDocumentImpl.java
@@ -0,0 +1,135 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.GOMDocument;
+import org.apache.lucene.gdata.gom.GOMElement;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+/**
+ * @author Simon Willnauer
+ * @param <T>
+ */
+public class GOMDocumentImpl<T extends GOMElement> implements GOMDocument<T> {
+
+	private static final String DEFAULT_ENCODING = "UTF-8";
+
+	private static final String DEFAULT_VERSION = "1.0";
+
+	private T root;
+
+	private String version;
+
+	private String charEncoding;
+
+	/**
+	 * 
+	 */
+	public GOMDocumentImpl() {
+		super();
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMDocument#setRootElement(org.apache.lucene.gdata.gom.GOMElement)
+	 */
+	public void setRootElement(T aRootElement) {
+		this.root = aRootElement;
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMDocument#getRootElement()
+	 */
+	public T getRootElement() {
+		return this.root;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMDocument#setVersion(java.lang.String)
+	 */
+	public void setVersion(String aVersion) {
+		this.version = aVersion;
+
+	}
+
+	/**
+	 * @return the version
+	 * @uml.property name="version"
+	 */
+	public String getVersion() {
+		return this.version;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMDocument#getCharacterEncoding()
+	 */
+	public String getCharacterEncoding() {
+		return this.charEncoding;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMDocument#setCharacterEncoding(java.lang.String)
+	 */
+	public void setCharacterEncoding(String aEncoding) {
+		this.charEncoding = aEncoding;
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMDocument#writeAtomOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
+	 */
+	public void writeAtomOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+		try {
+			aStreamWriter.writeStartDocument(
+					this.charEncoding == null ? DEFAULT_ENCODING
+							: this.charEncoding,
+					this.version == null ? DEFAULT_VERSION : this.version);
+			if (this.root != null)
+				this.root.writeAtomOutput(aStreamWriter);
+			aStreamWriter.writeEndDocument();
+			aStreamWriter.flush();
+		} finally {
+			aStreamWriter.close();
+		}
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMDocument#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
+	 */
+	public void writeRssOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+		try {
+			aStreamWriter.writeStartDocument(
+					this.charEncoding == null ? DEFAULT_ENCODING
+							: this.charEncoding,
+					this.version == null ? DEFAULT_VERSION : this.version);
+			if (this.root != null) {
+				this.root.writeRssOutput(aStreamWriter);
+			}
+			aStreamWriter.writeEndDocument();
+			aStreamWriter.flush();
+		} finally {
+			aStreamWriter.close();
+		}
+
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMEntryImpl.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMEntryImpl.java
new file mode 100644
index 0000000..3c3e002
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMEntryImpl.java
@@ -0,0 +1,668 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import java.util.LinkedList;
+import java.util.List;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.AtomMediaType;
+import org.apache.lucene.gdata.gom.GOMAuthor;
+import org.apache.lucene.gdata.gom.GOMCategory;
+import org.apache.lucene.gdata.gom.GOMContent;
+import org.apache.lucene.gdata.gom.GOMContributor;
+import org.apache.lucene.gdata.gom.GOMEntry;
+import org.apache.lucene.gdata.gom.GOMExtension;
+import org.apache.lucene.gdata.gom.GOMId;
+import org.apache.lucene.gdata.gom.GOMLink;
+import org.apache.lucene.gdata.gom.GOMNamespace;
+import org.apache.lucene.gdata.gom.GOMPublished;
+import org.apache.lucene.gdata.gom.GOMRights;
+import org.apache.lucene.gdata.gom.GOMSource;
+import org.apache.lucene.gdata.gom.GOMSummary;
+import org.apache.lucene.gdata.gom.GOMTitle;
+import org.apache.lucene.gdata.gom.GOMUpdated;
+import org.apache.lucene.gdata.gom.core.extension.GOMExtensionFactory;
+import org.apache.lucene.gdata.gom.core.utils.AtomParserUtils;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+/**
+ * 
+ * The default implementation of {@link org.apache.lucene.gdata.gom.GOMEntry}
+ * 
+ * <pre>
+ *         atomEntry =
+ *         element atom:entry {
+ *         atomCommonAttributes,
+ *         (	atomAuthor*
+ *         	&amp; atomCategory*
+ *         	&amp; atomContent?
+ *         	&amp; atomContributor*
+ *         	&amp; atomId
+ *         	&amp; atomLink*
+ *         	&amp; atomPublished?
+ *       	 	&amp; atomRights?
+ *         	&amp; atomSource?
+ *         	&amp; atomSummary?
+ *         	&amp; atomTitle
+ *         	&amp; atomUpdated
+ *         	&amp; extensionElement*)
+ *         }
+ * </pre>
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class GOMEntryImpl extends AbstractGOMElement implements GOMEntry {
+
+	protected List<GOMNamespace> namespaces = new LinkedList<GOMNamespace>();
+
+	protected List<GOMExtension> extensions = new LinkedList<GOMExtension>();
+
+	private List<GOMAuthor> authors = new LinkedList<GOMAuthor>();
+
+	private List<GOMCategory> categories = new LinkedList<GOMCategory>();
+
+	private List<GOMContributor> contributors = new LinkedList<GOMContributor>();
+
+	private GOMId id;
+
+	private List<GOMLink> links = new LinkedList<GOMLink>();
+
+	private GOMPublished published;
+
+	private GOMRights rights;
+
+	private GOMSource source;
+
+	private GOMSummary summary;
+
+	private GOMTitle title;
+
+	private GOMUpdated updated;
+
+	private GOMExtensionFactory extensionFactory;
+
+	private GOMContent content;
+
+	private final GOMNamespace defaultNamespace = GOMNamespace.ATOM_NAMESPACE;
+
+	/**
+	 * 
+	 */
+	public GOMEntryImpl() {
+		super();
+		this.localName = GOMEntry.LOCALNAME;
+		this.qname = new QName(GOMNamespace.ATOM_NS_URI, this.localName);
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMEntry#addAuthor(org.apache.lucene.gdata.gom.GOMAuthor)
+	 */
+	public void addAuthor(GOMAuthor aAuthor) {
+		if (aAuthor != null)
+			this.authors.add(aAuthor);
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMEntry#addCategory(org.apache.lucene.gdata.gom.GOMCategory)
+	 */
+	public void addCategory(GOMCategory aCategory) {
+		if (aCategory != null)
+			this.categories.add(aCategory);
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMEntry#addContributor(org.apache.lucene.gdata.gom.GOMContributor)
+	 */
+	public void addContributor(GOMContributor aContributor) {
+		if (aContributor != null)
+			this.contributors.add(aContributor);
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMEntry#addLink(org.apache.lucene.gdata.gom.GOMLink)
+	 */
+	public void addLink(GOMLink aLink) {
+		if (aLink != null)
+			this.links.add(aLink);
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMEntry#getAuthors()
+	 */
+	public List<GOMAuthor> getAuthors() {
+		return this.authors;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMEntry#getCategories()
+	 */
+	public List<GOMCategory> getCategories() {
+		return this.categories;
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMEntry#getContributor()
+	 */
+	public List<GOMContributor> getContributor() {
+		return this.contributors;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMEntry#getId()
+	 */
+	public GOMId getId() {
+		return this.id;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMEntry#getLinks()
+	 */
+	public List<GOMLink> getLinks() {
+		return this.links;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMEntry#getPublished()
+	 */
+	public GOMPublished getPublished() {
+		return this.published;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMEntry#getRights()
+	 */
+	public GOMRights getRights() {
+		return this.rights;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMEntry#getSource()
+	 */
+	public GOMSource getSource() {
+		return this.source;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMEntry#getSummary()
+	 */
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMEntry#getSummary()
+	 */
+	public GOMSummary getSummary() {
+		return this.summary;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMEntry#getTitle()
+	 */
+	public GOMTitle getTitle() {
+		return this.title;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMEntry#getUpdated()
+	 */
+	public GOMUpdated getUpdated() {
+		return this.updated;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMEntry#setId(org.apache.lucene.gdata.gom.GOMId)
+	 */
+	public void setId(GOMId aId) {
+		this.id = aId;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMEntry#setPublished(org.apache.lucene.gdata.gom.GOMPublished)
+	 */
+	public void setPublished(GOMPublished aPublished) {
+		this.published = aPublished;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMEntry#setRights(org.apache.lucene.gdata.gom.GOMRights)
+	 */
+	public void setRights(GOMRights aRights) {
+		this.rights = aRights;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMEntry#setSource(org.apache.lucene.gdata.gom.GOMSource)
+	 */
+	public void setSource(GOMSource aSource) {
+		this.source = aSource;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMEntry#setSummary(org.apache.lucene.gdata.gom.GOMSummary)
+	 */
+	public void setSummary(GOMSummary aSummary) {
+		this.summary = aSummary;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMEntry#setTitle(org.apache.lucene.gdata.gom.GOMTitle)
+	 */
+	public void setTitle(GOMTitle aTitle) {
+		this.title = aTitle;
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMEntry#setUpdated(org.apache.lucene.gdata.gom.GOMUpdated)
+	 */
+	public void setUpdated(GOMUpdated aUpdated) {
+		this.updated = aUpdated;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMEntry#addNamespace(org.apache.lucene.gdata.gom.GOMNamespace)
+	 */
+	public void addNamespace(GOMNamespace aNamespace) {
+		if (aNamespace == null)
+			return;
+		// namespace overrides hash / equals
+		if (this.namespaces.contains(aNamespace))
+			return;
+		if ("".equals(aNamespace.getNamespacePrefix())
+				|| aNamespace.getNamespaceUri()
+						.equals(GOMNamespace.ATOM_NS_URI))
+			return;
+		else
+			this.namespaces.add(aNamespace);
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMEntry#getNamespaces()
+	 */
+	public List<GOMNamespace> getNamespaces() {
+		return this.namespaces;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMEntry#getDefaultNamespace()
+	 */
+	public GOMNamespace getDefaultNamespace() {
+
+		return this.defaultNamespace;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMElement#writeAtomOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
+	 */
+	public void writeAtomOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+		aStreamWriter
+				.writeStartElement(this.qname, getXmlNamespaceAttributes());
+		if (this.defaultNamespace != null)
+			aStreamWriter.writeDefaultNamespace(this.defaultNamespace);
+		for (GOMNamespace namespace : this.namespaces) {
+			aStreamWriter.writeNamespace(namespace);
+		}
+		if (this.id != null)
+			this.id.writeAtomOutput(aStreamWriter);
+		if (this.published != null)
+			this.published.writeAtomOutput(aStreamWriter);
+		if (this.updated != null)
+			this.updated.writeAtomOutput(aStreamWriter);
+		for (GOMCategory category : this.categories) {
+			category.writeAtomOutput(aStreamWriter);
+		}
+		if (this.title != null)
+			this.title.writeAtomOutput(aStreamWriter);
+		if (this.summary != null)
+			this.summary.writeAtomOutput(aStreamWriter);
+		if (this.content != null)
+			this.content.writeAtomOutput(aStreamWriter);
+		for (GOMLink link : this.links) {
+			link.writeAtomOutput(aStreamWriter);
+		}
+		for (GOMAuthor autor : this.authors) {
+			autor.writeAtomOutput(aStreamWriter);
+		}
+		for (GOMContributor contributor : this.contributors) {
+			contributor.writeAtomOutput(aStreamWriter);
+		}
+		if (this.rights != null) {
+			this.rights.writeAtomOutput(aStreamWriter);
+		}
+		if (this.source != null) {
+			this.source.writeAtomOutput(aStreamWriter);
+		}
+
+		for (GOMExtension extension : this.extensions) {
+			extension.writeAtomOutput(aStreamWriter);
+		}
+		aStreamWriter.writeEndElement();
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMElement#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
+	 */
+	public void writeRssOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+		aStreamWriter.writeStartElement(GOMEntry.LOCALNAME_RSS,
+				getXmlNamespaceAttributes());
+		if (this.defaultNamespace != null)
+			aStreamWriter.writeNamespace(this.defaultNamespace);
+		for (GOMNamespace namespace : this.namespaces) {
+			aStreamWriter.writeNamespace(namespace);
+		}
+		if (this.id != null)
+			this.id.writeRssOutput(aStreamWriter, GOMId.LOCALNAME_RSS);
+		String xmlLang = null;
+
+		if (this.content != null) {
+			xmlLang = this.content.getXmlLang();
+		}
+		if (xmlLang == null && this.summary != null) {
+			xmlLang = this.summary.getXmlLang();
+		}
+
+		if (xmlLang == null && this.title != null) {
+			xmlLang = this.title.getXmlLang();
+		}
+
+		if (xmlLang != null) {
+			aStreamWriter.writeSimpleXMLElement("language", xmlLang, null);
+		}
+		if (this.published != null) {
+			this.published.writeRssOutput(aStreamWriter);
+		}
+		if (this.updated != null)
+			this.updated.writeRssOutput(aStreamWriter);
+		for (GOMCategory category : this.categories) {
+			category.writeRssOutput(aStreamWriter);
+		}
+		if (this.title != null)
+			this.title.writeRssOutput(aStreamWriter);
+		if (this.summary != null)
+			this.summary.writeRssOutput(aStreamWriter);
+		if (this.content != null)
+			this.content.writeRssOutput(aStreamWriter);
+		for (GOMLink link : this.links) {
+			link.writeRssOutput(aStreamWriter);
+		}
+		for (GOMAuthor author : this.authors) {
+			author.writeRssOutput(aStreamWriter);
+		}
+
+		for (GOMContributor contributors : this.contributors) {
+			contributors.writeRssOutput(aStreamWriter);
+		}
+
+		for (GOMExtension extension : this.extensions) {
+			extension.writeRssOutput(aStreamWriter);
+		}
+		aStreamWriter.writeEndElement();
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#getChildParser(javax.xml.namespace.QName)
+	 */
+	@Override
+	public AtomParser getChildParser(QName aName) {
+		if (aName.getNamespaceURI().equals(GOMNamespace.ATOM_NS_URI)) {
+			if (aName.getLocalPart().equals(GOMId.LOCALNAME)) {
+				// atom:feed elements MUST contain exactly one atom:id element.
+				if (this.id != null)
+					throw new GDataParseException(String.format(
+							AtomParser.DUPLICATE_ELEMENT, GOMId.LOCALNAME));
+				this.id = new GOMIdImpl();
+				return this.id;
+			}
+			if (aName.getLocalPart().equals(GOMTitle.LOCALNAME)) {
+				// atom:entry elements MUST contain exactly one atom:title
+				// element.
+				if (this.title != null)
+					throw new GDataParseException(String.format(
+							AtomParser.DUPLICATE_ELEMENT, GOMTitle.LOCALNAME));
+				this.title = new GOMTitleImpl();
+				return this.title;
+			}
+			if (aName.getLocalPart().equals(GOMAuthor.LOCALNAME)) {
+				GOMAuthor author = new GOMAuthorImpl();
+				this.authors.add(author);
+				return author;
+			}
+			if (aName.getLocalPart().equals(GOMCategory.LOCALNAME)) {
+				GOMCategory category = new GOMCategoryImpl();
+				this.categories.add(category);
+				return category;
+			}
+			if (aName.getLocalPart().equals(GOMContributor.LOCALNAME)) {
+				GOMContributorImpl impl = new GOMContributorImpl();
+				this.contributors.add(impl);
+				return impl;
+			}
+			if (aName.getLocalPart().equals(GOMLink.LOCALNAME)) {
+				GOMLinkImpl impl = new GOMLinkImpl();
+				this.links.add(impl);
+				return impl;
+			}
+
+			if (aName.getLocalPart().equals(GOMUpdated.LOCALNAME)) {
+				if (this.updated != null)
+					throw new GDataParseException(String.format(
+							AtomParser.DUPLICATE_ELEMENT,
+							GOMUpdated.LOCALNAME));
+				GOMUpdated updatedImpl = new GOMUpdatedImpl();
+				this.updated = updatedImpl;
+				return this.updated;
+
+			}
+			if (aName.getLocalPart().equals(GOMRights.LOCALNAME)) {
+				if (this.rights != null)
+					throw new GDataParseException(String
+							.format(AtomParser.DUPLICATE_ELEMENT,
+									GOMRights.LOCALNAME));
+
+				this.rights = new GOMRightsImpl();
+				return this.rights;
+
+			}
+			if (aName.getLocalPart().equals(GOMSource.LOCALNAME)) {
+				if (this.source != null)
+					throw new GDataParseException(String
+							.format(AtomParser.DUPLICATE_ELEMENT,
+									GOMSource.LOCALNAME));
+				this.source = new GOMSourceImpl();
+
+				return this.source;
+
+			}
+			if (aName.getLocalPart().equals(GOMSummary.LOCALNAME)) {
+				if (this.summary != null)
+					throw new GDataParseException(String.format(
+							AtomParser.DUPLICATE_ELEMENT,
+							GOMSummary.LOCALNAME));
+
+				this.summary = new GOMSummaryImpl();
+				return this.summary;
+
+			}
+			if (aName.getLocalPart().equals(GOMPublished.LOCALNAME)) {
+				if (this.published != null)
+					throw new GDataParseException(String.format(
+							AtomParser.DUPLICATE_ELEMENT,
+							GOMPublished.LOCALNAME));
+
+				this.published = new GOMPublishedImpl();
+				return this.published;
+
+			}
+			if (aName.getLocalPart().endsWith(GOMContent.LOCALNAME)) {
+				if (this.content != null)
+					throw new GDataParseException(String.format(
+							AtomParser.DUPLICATE_ELEMENT,
+							GOMContent.LOCALNAME));
+				this.content = new GOMContentImpl();
+				return this.content;
+
+			}
+
+		}
+		if (this.extensionFactory != null) {
+			GOMExtension extension = this.extensionFactory
+					.canHandleExtensionElement(aName);
+			if (extension != null) {
+				this.extensions.add(extension);
+				return extension;
+			}
+		}
+		return super.getChildParser(aName);
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#processEndElement()
+	 */
+	@Override
+	public void processEndElement() {
+
+		/*
+		 * atom:entry elements MUST contain an atom:summary element in either of
+		 * the following cases:
+		 * 
+		 * the atom:entry contains an atom:content that has a "src" attribute
+		 * (and is thus empty). the atom:entry contains content that is encoded
+		 * in Base64; i.e., the "type" attribute of atom:content is a MIME media
+		 * type [MIMEREG], but is not an XML media type [RFC3023], does not
+		 * begin with "text/", and does not end with "/xml" or "+xml".
+		 * 
+		 * 
+		 */
+		if (this.summary == null && this.content != null) {
+
+			if (this.content.getAtomMediaType() == AtomMediaType.BINARY
+					|| "".equals(this.content.getSrc())) {
+				throw new GDataParseException(String.format(
+						MISSING_ELEMENT_CHILD, this.localName,
+						GOMSummary.LOCALNAME));
+			}
+		}
+
+		/*
+		 * atom:entry elements MUST contain exactly one atom:id element.
+		 */
+		if (this.id == null)
+			throw new GDataParseException(String.format(
+					MISSING_ELEMENT_CHILD, this.localName, GOMId.LOCALNAME));
+		/*
+		 * atom:entry elements MUST contain exactly one atom:title element.
+		 */
+		if (this.title == null)
+			throw new GDataParseException(String
+					.format(MISSING_ELEMENT_CHILD, this.localName,
+							GOMTitle.LOCALNAME));
+		/*
+		 * atom:entry elements MUST contain exactly one atom:updated element.
+		 */
+		if (this.updated == null)
+			throw new GDataParseException(String.format(
+					MISSING_ELEMENT_CHILD, this.localName,
+					GOMUpdated.LOCALNAME));
+
+		/*
+		 * atom:entry elements MUST NOT contain more than one atom:link element
+		 * with a rel attribute value of "alternate" that has the same
+		 * combination of type and hreflang attribute values.
+		 */
+		List<GOMLink> alternateLinks = new LinkedList<GOMLink>();
+		for (GOMLink link : this.links) {
+			/*
+			 * atom:link elements MAY have a "rel" attribute that indicates the
+			 * link relation type. If the "rel" attribute is not present, the
+			 * link element MUST be interpreted as if the link relation type is
+			 * "alternate".
+			 */
+			if (link.getRel() == null
+					|| link.getRel().equalsIgnoreCase("alternate"))
+				alternateLinks.add(link);
+		}
+
+		/*
+		 * atom:entry elements MUST NOT contain more than one atom:link element
+		 * with a rel attribute value of "alternate" that has the same
+		 * combination of type and hreflang attribute values.
+		 */
+		if (alternateLinks.size() > 1) {
+			for (GOMLink link : alternateLinks) {
+				for (GOMLink link2 : alternateLinks) {
+					if (AtomParserUtils.compareAlternateLinks(link, link2))
+						throw new GDataParseException(
+								String
+										.format(DUPLICATE_ELEMENT,
+												"link with rel=\"alternate\" and same href and type attributes"));
+
+				}
+			}
+		} else if (this.content == null && alternateLinks.size() == 0) {
+			throw new GDataParseException(
+					"Element Entry must contain a element link with attribute alternate if no content element is set");
+		}
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMExtensible#getExtensions()
+	 */
+	public List<GOMExtension> getExtensions() {
+		return this.extensions;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMExtensible#setExtensionFactory(org.apache.lucene.gdata.gom.core.extension.GOMExtensionFactory)
+	 */
+	public void setExtensionFactory(GOMExtensionFactory aFactory) {
+		if (extensionFactory != null) {
+			List<GOMNamespace> namespaces2 = extensionFactory.getNamespaces();
+			if (namespaces2 != null)
+				for (GOMNamespace namespace : namespaces2) {
+					this.addNamespace(namespace);
+				}
+
+		}
+		this.extensionFactory = aFactory;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMEntry#getContent()
+	 */
+	public GOMContent getContent() {
+		return this.content;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMEntry#setContent(org.apache.lucene.gdata.gom.GOMContent)
+	 */
+	public void setContent(GOMContent aContent) {
+		this.content = aContent;
+
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMFactory.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMFactory.java
new file mode 100644
index 0000000..c58999b
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMFactory.java
@@ -0,0 +1,47 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import org.apache.lucene.gdata.gom.GOMEntry;
+import org.apache.lucene.gdata.gom.GOMFeed;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class GOMFactory {
+	/**
+	 * 
+	 */
+	private GOMFactory() {
+		super();
+	}
+
+	public static GOMFactory createInstance() {
+		return new GOMFactory();
+	}
+
+	public GOMFeed createFeed() {
+		return new GOMFeedImpl();
+	}
+
+	public GOMEntry createEntry() {
+		return new GOMEntryImpl();
+
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMFeedImpl.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMFeedImpl.java
new file mode 100644
index 0000000..ed3c673
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMFeedImpl.java
@@ -0,0 +1,381 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import java.util.LinkedList;
+import java.util.List;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.GOMAttribute;
+import org.apache.lucene.gdata.gom.GOMAuthor;
+import org.apache.lucene.gdata.gom.GOMCategory;
+import org.apache.lucene.gdata.gom.GOMEntry;
+import org.apache.lucene.gdata.gom.GOMExtension;
+import org.apache.lucene.gdata.gom.GOMFeed;
+import org.apache.lucene.gdata.gom.GOMLink;
+import org.apache.lucene.gdata.gom.GOMNamespace;
+import org.apache.lucene.gdata.gom.core.extension.GOMExtensionFactory;
+import org.apache.lucene.gdata.gom.core.utils.GOMUtils;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+/**
+ * atom:feed { atomCommonAttributes, (atomAuthor* & atomCategory* &
+ * atomContributor* & atomGenerator? & atomIcon? & atomId & atomLink* &
+ * atomLogo? & atomRights? & atomSubtitle? & atomTitle & atomUpdated &
+ * extensionElement*), atomEntry* }
+ * 
+ * @author Simon Willnauer
+ */
+class GOMFeedImpl extends GOMSourceImpl implements GOMFeed {
+	// TODO add totalResults OS namespace
+
+	static final int DEFAULT_START_INDEX = 1;
+
+	static final int DEFAULT_ITEMS_PER_PAGE = 25;
+
+	private static final GOMAttribute RSS_VERSION_ATTRIBUTE = new GOMAttributeImpl(
+			"version", "2.0");
+
+	protected List<GOMEntry> entries = new LinkedList<GOMEntry>();
+
+	protected List<GOMExtension> extensions = new LinkedList<GOMExtension>();
+
+	protected List<GOMNamespace> namespaces = new LinkedList<GOMNamespace>();
+
+	private SimpleGOMElementImpl startIndexElement;
+
+	private SimpleGOMElementImpl itemsPerPageElement;
+
+	private GOMExtensionFactory extensionFactory;
+
+	private GOMNamespace defaultNamespace = GOMNamespace.ATOM_NAMESPACE;
+
+	GOMFeedImpl() {
+		this.localName = GOMFeed.LOCALNAME;
+		this.qname = new QName(GOMNamespace.ATOM_NS_URI, this.localName);
+		startIndexElement = new SimpleGOMElementImpl(
+				SimpleGOMElementImpl.ELEMENT_OS_START_INDEX,
+				GOMNamespace.OPENSEARCH_NAMESPACE);
+		itemsPerPageElement = new SimpleGOMElementImpl(
+				SimpleGOMElementImpl.ELEMENT_OS_ITEMS_PER_PAGE,
+				GOMNamespace.OPENSEARCH_NAMESPACE);
+		itemsPerPageElement.setTextValue(Integer
+				.toString(DEFAULT_ITEMS_PER_PAGE));
+		startIndexElement.setTextValue(Integer.toString(DEFAULT_START_INDEX));
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMSource#addEntry(org.apache.lucene.gdata.gom.GOMEntry)
+	 */
+	public void addEntry(GOMEntry aEntry) {
+		if (aEntry != null)
+			this.entries.add(aEntry);
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMFeed#getEntries()
+	 */
+	public List<GOMEntry> getEntries() {
+		return this.entries;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMFeed#getItemsPerPage()
+	 */
+	public int getItemsPerPage() {
+		return Integer.parseInt(this.itemsPerPageElement.getTextValue());
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMFeed#getStartIndex()
+	 */
+	public int getStartIndex() {
+		return Integer.parseInt(this.startIndexElement.getTextValue());
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMFeed#setStartIndex(int)
+	 */
+	public void setStartIndex(int aIndex) {
+		if (aIndex < 1)
+			return;
+		this.startIndexElement.textValue = Integer.toString(aIndex);
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMFeed#setItemsPerPage(int)
+	 */
+	public void setItemsPerPage(int aInt) {
+		if (aInt < 0)
+			return;
+		this.itemsPerPageElement.textValue = Integer.toString(aInt);
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMFeed#addNamespace(org.apache.lucene.gdata.gom.GOMNamespace)
+	 */
+	public void addNamespace(GOMNamespace aNamespace) {
+		if (aNamespace == null)
+			return;
+		// namespace overrides hash / equals
+		if (this.namespaces.contains(aNamespace))
+			return;
+		if ("".equals(aNamespace.getNamespacePrefix())
+				|| aNamespace.getNamespaceUri()
+						.equals(GOMNamespace.ATOM_NS_URI))
+			return;
+		else
+			this.namespaces.add(aNamespace);
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMFeed#getDefaultNamespace()
+	 */
+	public GOMNamespace getDefaultNamespace() {
+		return this.defaultNamespace;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMFeed#getNamespaces()
+	 * 
+	 */
+	public List<GOMNamespace> getNamespaces() {
+		return this.namespaces;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.AtomParser#getChildParser(javax.xml.namespace.QName)
+	 */
+	public AtomParser getChildParser(QName aName) {
+		if (aName.getNamespaceURI().equals(GOMNamespace.OPENSEARCH_NS_URI)) {
+			if (aName.getLocalPart().equals(
+					SimpleGOMElementImpl.ELEMENT_OS_ITEMS_PER_PAGE)) {
+
+				this.itemsPerPageElement = new SimpleGOMElementImpl(
+						SimpleGOMElementImpl.ELEMENT_OS_ITEMS_PER_PAGE,
+						GOMNamespace.OPENSEARCH_NAMESPACE);
+				this.itemsPerPageElement
+						.setValidator(new PositiveIntegerValidator(
+								SimpleGOMElementImpl.ELEMENT_OS_ITEMS_PER_PAGE));
+				return this.itemsPerPageElement;
+			}
+			if (aName.getLocalPart().equals(
+					SimpleGOMElementImpl.ELEMENT_OS_START_INDEX)) {
+				this.startIndexElement = new SimpleGOMElementImpl(
+						SimpleGOMElementImpl.ELEMENT_OS_START_INDEX,
+						GOMNamespace.OPENSEARCH_NAMESPACE);
+				this.startIndexElement
+						.setValidator(new PositiveIntegerValidator(
+								SimpleGOMElementImpl.ELEMENT_OS_START_INDEX));
+				return this.startIndexElement;
+			}
+
+		}
+		if (aName.getNamespaceURI().equals(GOMNamespace.ATOM_NS_URI)
+				&& aName.getLocalPart().equals(GOMEntry.LOCALNAME)) {
+			GOMEntry entry = new GOMEntryImpl();
+			this.entries.add(entry);
+			return entry;
+
+		}
+		if (this.extensionFactory != null) {
+			GOMExtension extension = this.extensionFactory
+					.canHandleExtensionElement(aName);
+			if (extension != null) {
+				this.extensions.add(extension);
+				return extension;
+			}
+		}
+		return super.getChildParser(aName);
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMElement#writeAtomOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
+	 */
+	public void writeAtomOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+		aStreamWriter.writeStartElement(this.localName,
+				this.extensionAttributes);
+		if (this.defaultNamespace != null)
+			aStreamWriter.writeDefaultNamespace(this.defaultNamespace);
+		for (GOMNamespace namespace : this.namespaces) {
+			aStreamWriter.writeNamespace(namespace);
+		}
+		List<GOMAttribute> xmlNamespaceAttributes = getXmlNamespaceAttributes();
+		for (GOMAttribute attribute : xmlNamespaceAttributes) {
+			aStreamWriter.writeAttribute(attribute);
+		}
+		writeInnerAtomOutput(aStreamWriter);
+		if (this.itemsPerPageElement != null)
+			this.itemsPerPageElement.writeAtomOutput(aStreamWriter);
+		if (this.startIndexElement != null)
+			this.startIndexElement.writeAtomOutput(aStreamWriter);
+		for (GOMExtension extension : this.extensions) {
+			extension.writeAtomOutput(aStreamWriter);
+		}
+		for (GOMEntry entry : this.entries) {
+			entry.writeAtomOutput(aStreamWriter);
+		}
+
+		aStreamWriter.writeEndElement();
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMElement#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
+	 */
+	public void writeRssOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+		aStreamWriter
+				.writeStartElement(LOCALNAME_RSS, this.extensionAttributes);
+		List<GOMAttribute> xmlNamespaceAttributes = getXmlNamespaceAttributes();
+		for (GOMAttribute attribute : xmlNamespaceAttributes) {
+			aStreamWriter.writeAttribute(attribute);
+		}
+		if (this.defaultNamespace != null)
+			aStreamWriter.writeNamespace(this.defaultNamespace);
+		for (GOMNamespace namespace : this.namespaces) {
+			aStreamWriter.writeNamespace(namespace);
+		}
+		aStreamWriter.writeAttribute(RSS_VERSION_ATTRIBUTE);
+
+		aStreamWriter.writeStartElement(RSS_CHANNEL_ELEMENT_NAME);
+
+		if (this.id != null)
+			this.id.writeRssOutput(aStreamWriter);
+		if (this.title != null)
+			this.title.writeRssOutput(aStreamWriter);
+		if (this.subtitle != null)
+			this.subtitle.writeRssOutput(aStreamWriter);
+		if (this.rights != null)
+			this.rights.writeRssOutput(aStreamWriter);
+		for (GOMAuthor authors : this.authors) {
+			authors.writeRssOutput(aStreamWriter, "managingEditor");
+		}
+		for (GOMCategory category : this.categories) {
+			category.writeRssOutput(aStreamWriter);
+		}
+		for (GOMLink link : this.links) {
+			link.writeRssOutput(aStreamWriter);
+		}
+		if (this.updated != null) {
+			// udated.getDate can not be null
+			aStreamWriter.writeSimpleXMLElement("lastBuildDate", GOMUtils
+					.buildRfc822Date(this.updated.getDate().getTime()), null);
+		}
+
+		if (this.logo != null || this.icon != null) {
+			aStreamWriter.writeStartElement("image");
+			if (this.logo != null)
+				this.logo.writeRssOutput(aStreamWriter);
+			else
+				this.icon.writeRssOutput(aStreamWriter);
+			aStreamWriter.writeEndElement();
+
+		}
+
+		if (this.generator != null)
+			this.generator.writeRssOutput(aStreamWriter);
+		if (this.itemsPerPageElement != null)
+			this.itemsPerPageElement.writeRssOutput(aStreamWriter);
+		if (this.startIndexElement != null)
+			this.startIndexElement.writeRssOutput(aStreamWriter);
+		for (GOMExtension extension : this.extensions) {
+			extension.writeRssOutput(aStreamWriter);
+		}
+		for (GOMExtension extension : this.extensions) {
+			extension.writeRssOutput(aStreamWriter);
+		}
+		for (GOMEntry entry : this.entries) {
+			entry.writeRssOutput(aStreamWriter);
+		}
+		// channel
+		aStreamWriter.writeEndElement();
+		// rss
+		aStreamWriter.writeEndElement();
+
+	}
+
+	static class PositiveIntegerValidator extends
+			SimpleGOMElementImpl.SimpleValidator {
+
+		protected PositiveIntegerValidator(String aLocalName) {
+			super(aLocalName);
+
+		}
+
+		/**
+		 * @see org.apache.lucene.gdata.gom.core.SimpleGOMElementImpl.SimpleValidator#validate(java.lang.String)
+		 */
+		@Override
+		protected void validate(String aTextValue) {
+			super.validate(aTextValue);
+			try {
+				int i = Integer.parseInt(aTextValue);
+				if (i < 0)
+					throw new GDataParseException(String.format(
+							AtomParser.INVALID_ELEMENT_VALUE, this.localName,
+							"positive integer value"));
+			} catch (NumberFormatException e) {
+				throw new GDataParseException(String.format(
+						AtomParser.INVALID_ELEMENT_VALUE, this.localName,
+						"positive integer value"));
+			}
+
+		}
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMFeed#getExtensions()
+	 */
+	public List<GOMExtension> getExtensions() {
+		return this.extensions;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMFeed#setExtensionFactory(org.apache.lucene.gdata.gom.core.extension.GOMExtensionFactory)
+	 */
+	public void setExtensionFactory(GOMExtensionFactory aFactory) {
+		if (extensionFactory != null) {
+			List<GOMNamespace> namespaces2 = extensionFactory.getNamespaces();
+			if (namespaces2 != null)
+				for (GOMNamespace namespace : namespaces2) {
+					this.addNamespace(namespace);
+				}
+
+		}
+
+		this.extensionFactory = aFactory;
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMFeed#addLink(org.apache.lucene.gdata.gom.GOMLink)
+	 */
+	public void addLink(GOMLink aLink) {
+		if (aLink == null)
+			return;
+		this.links.add(aLink);
+
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMGeneratorImpl.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMGeneratorImpl.java
new file mode 100644
index 0000000..690fb95
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMGeneratorImpl.java
@@ -0,0 +1,158 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import java.net.URISyntaxException;
+import java.util.List;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.GOMAttribute;
+import org.apache.lucene.gdata.gom.GOMGenerator;
+import org.apache.lucene.gdata.gom.GOMNamespace;
+import org.apache.lucene.gdata.gom.core.utils.AtomParserUtils;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class GOMGeneratorImpl extends AbstractGOMElement implements
+		GOMGenerator {
+
+	private String generatorVersion;
+
+	private String uri;
+
+	/**
+	 * 
+	 */
+	public GOMGeneratorImpl() {
+		super();
+		this.localName = GOMGenerator.LOCALNAME;
+		this.qname = new QName(GOMNamespace.ATOM_NS_URI, this.localName);
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMGenerator#setUri(java.lang.String)
+	 */
+	public void setUri(String aUri) {
+		this.uri = aUri;
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMGenerator#setGeneratorVersion(java.lang.String)
+	 */
+	public void setGeneratorVersion(String aVersion) {
+		this.generatorVersion = aVersion;
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMGenerator#getGeneratorVersion()
+	 */
+	public String getGeneratorVersion() {
+		return this.generatorVersion;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMGenerator#getUri()
+	 */
+	public String getUri() {
+		return this.uri;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#processAttribute(javax.xml.namespace.QName,
+	 *      java.lang.String)
+	 */
+	@Override
+	public void processAttribute(QName aQName, String aValue) {
+		if (aQName == null)
+			throw new IllegalArgumentException("Qname must not be null");
+		if (aValue == null)
+			throw new IllegalArgumentException("Value must not be null");
+		if (aQName.getNamespaceURI().equals(GOMNamespace.ATOM_NS_URI)) {
+			if (aQName.getLocalPart().equals("uri")) {
+				if (this.uri != null)
+					throw new GDataParseException(String.format(
+							AtomParser.DUPLICATE_ATTRIBUTE, "uri"));
+				this.uri = aValue;
+			} else if (aQName.getLocalPart().equals("version")) {
+				if (this.generatorVersion != null)
+					throw new GDataParseException(String.format(
+							AtomParser.DUPLICATE_ATTRIBUTE, "version"));
+				this.generatorVersion = aValue;
+			}
+		}
+		super.processAttribute(aQName, aValue);
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#processElementValue(java.lang.String)
+	 */
+	@Override
+	public void processElementValue(String aValue) {
+		if (this.textValue != null)
+			throw new GDataParseException(String.format(
+					AtomParser.DUPLICATE_ELEMENT_VALUE, this.localName));
+		this.textValue = aValue;
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#processEndElement()
+	 */
+	@Override
+	public void processEndElement() {
+		if (this.uri != null)
+			try {
+				AtomParserUtils.getAbsolutAtomURI(this.xmlBase, this.uri);
+			} catch (URISyntaxException e) {
+				throw new GDataParseException(String.format(
+						AtomParser.INVALID_ELEMENT_VALUE, this.localName,
+						"absolute uri"));
+			}
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMElement#writeAtomOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
+	 */
+	public void writeAtomOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+		List<GOMAttribute> list = getXmlNamespaceAttributes();
+		if (this.uri != null)
+			list.add(new GOMAttributeImpl("uri", this.uri));
+		if (this.generatorVersion != null)
+			list.add(new GOMAttributeImpl("version", this.generatorVersion));
+
+		aStreamWriter.writeSimpleXMLElement(this.qname, list, this.textValue);
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMElement#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
+	 */
+	public void writeRssOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+		aStreamWriter.writeSimpleXMLElement(this.localName,
+				getXmlNamespaceAttributes(), this.textValue);
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMIconImpl.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMIconImpl.java
new file mode 100644
index 0000000..c84c738
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMIconImpl.java
@@ -0,0 +1,51 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.GOMIcon;
+import org.apache.lucene.gdata.gom.GOMNamespace;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class GOMIconImpl extends AtomUriElement implements GOMIcon {
+
+	/**
+	 * 
+	 */
+	public GOMIconImpl() {
+		this.localName = GOMIcon.LOCALNAME;
+		this.qname = new QName(GOMNamespace.ATOM_NS_URI, this.localName);
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.SimpleGOMElementImpl#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
+	 */
+	@Override
+	public void writeRssOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+		aStreamWriter.writeSimpleXMLElement("url", getXmlNamespaceAttributes(),
+				this.textValue);
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMIdImpl.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMIdImpl.java
new file mode 100644
index 0000000..b8a582a
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMIdImpl.java
@@ -0,0 +1,103 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.GOMId;
+import org.apache.lucene.gdata.gom.GOMNamespace;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+class GOMIdImpl extends AbstractGOMElement implements GOMId {
+
+	protected static final QName ATOM_QNAME = new QName(
+			GOMNamespace.ATOM_NS_URI, LOCALNAME, GOMNamespace.ATOM_NS_PREFIX);
+
+	GOMIdImpl() {
+		this.localName = LOCALNAME;
+		this.qname = new QName(GOMNamespace.ATOM_NS_URI, this.localName);
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#getLocalName()
+	 */
+	@Override
+	public String getLocalName() {
+		return this.localName;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.AtomParser#processElementValue(java.lang.String)
+	 */
+	public void processElementValue(String aValue) {
+		this.textValue = aValue;
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.AtomParser#processEndElement()
+	 */
+	public void processEndElement() {
+		if (this.textValue == null)
+			throw new GDataParseException(
+					"Element id must have a unique id value -- is null");
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMElement#writeAtomOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
+	 */
+	public void writeAtomOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+		if (aStreamWriter == null)
+			throw new GDataParseException("GOMWriter must not be null");
+		aStreamWriter.writeSimpleXMLElement(LOCALNAME,
+				getXmlNamespaceAttributes(), this.textValue);
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMElement#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
+	 */
+	public void writeRssOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+		if (aStreamWriter == null)
+			throw new GDataParseException("GOMWriter must not be null");
+		aStreamWriter.writeSimpleXMLElement(ATOM_QNAME,
+				getXmlNamespaceAttributes(), this.textValue);
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMOutputWriter,
+	 *      java.lang.String)
+	 */
+	@Override
+	public void writeRssOutput(GOMOutputWriter aStreamWriter, String aRssName)
+			throws XMLStreamException {
+		if (aStreamWriter == null)
+			throw new GDataParseException("GOMWriter must not be null");
+		aStreamWriter.writeSimpleXMLElement(aRssName,
+				getXmlNamespaceAttributes(), this.textValue);
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMLinkImpl.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMLinkImpl.java
new file mode 100644
index 0000000..3ed47b3
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMLinkImpl.java
@@ -0,0 +1,270 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import java.net.URISyntaxException;
+import java.util.List;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.GOMAttribute;
+import org.apache.lucene.gdata.gom.GOMLink;
+import org.apache.lucene.gdata.gom.GOMNamespace;
+import org.apache.lucene.gdata.gom.core.utils.AtomParserUtils;
+import org.apache.lucene.gdata.gom.core.utils.GOMUtils;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+/**
+ * element atom:link { atomCommonAttributes, attribute href { atomUri },
+ * attribute rel { atomNCName | atomUri }?, attribute type { atomMediaType }?,
+ * attribute hreflang { atomLanguageTag }?, attribute title { text }?, attribute
+ * length { text }?, undefinedContent }
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class GOMLinkImpl extends AbstractGOMElement implements GOMLink {
+	private String href;
+
+	private String rel;
+
+	private String type;
+
+	private String hrefLang;
+
+	private String title;
+
+	private Integer length;
+
+	/**
+	 * 
+	 */
+	public GOMLinkImpl() {
+		super();
+		this.localName = LOCALNAME;
+		this.qname = new QName(this.localName);
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMLink#getHref()
+	 */
+	public String getHref() {
+		return this.href;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMLink#setHref(java.lang.String)
+	 */
+	public void setHref(String aHref) {
+		href = aHref;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMLink#getHrefLang()
+	 */
+	public String getHrefLang() {
+		return this.hrefLang;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMLink#setHrefLang(java.lang.String)
+	 */
+	public void setHrefLang(String aHrefLang) {
+		hrefLang = aHrefLang;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMLink#getLength()
+	 */
+	public Integer getLength() {
+		return this.length;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMLink#setLength(java.lang.String)
+	 */
+	public void setLength(Integer aLength) {
+		length = aLength;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMLink#getRel()
+	 */
+	public String getRel() {
+		return this.rel;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMLink#setRel(java.lang.String)
+	 */
+	public void setRel(String aRel) {
+		rel = aRel;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMLink#getTitle()
+	 */
+	public String getTitle() {
+		return this.title;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMLink#setTitle(java.lang.String)
+	 */
+	public void setTitle(String aTitle) {
+		title = aTitle;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMLink#getType()
+	 */
+	public String getType() {
+		return this.type;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMLink#setType(java.lang.String)
+	 */
+	public void setType(String aType) {
+		type = aType;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#processAttribute(javax.xml.namespace.QName,
+	 *      java.lang.String)
+	 */
+	@Override
+	public void processAttribute(QName aQName, String aValue) {
+		if (aQName == null)
+			throw new IllegalArgumentException("QName must not be null");
+
+		if (aQName.getNamespaceURI().equals(GOMNamespace.ATOM_NS_URI)
+				|| aQName.getNamespaceURI().equals("")) {
+			String localName = aQName.getLocalPart();
+
+			if (localName.equals("href")) {
+				if (this.href != null)
+					throw new GDataParseException(String.format(
+							DUPLICATE_ATTRIBUTE, "href"));
+				this.href = aValue;
+			} else if (localName.equals("type")) {
+				if (this.type != null)
+					throw new GDataParseException(String.format(
+							DUPLICATE_ATTRIBUTE, "type"));
+				this.type = aValue;
+			} else if (localName.equals("rel")) {
+				if (this.rel != null)
+					throw new GDataParseException(String.format(
+							DUPLICATE_ATTRIBUTE, "rel"));
+				this.rel = aValue;
+			} else if (localName.equals("title")) {
+				if (this.title != null)
+					throw new GDataParseException(String.format(
+							DUPLICATE_ATTRIBUTE, "title"));
+				this.title = aValue;
+
+			} else if (localName.equals("hreflang")) {
+				if (this.hrefLang != null)
+					throw new GDataParseException(String.format(
+							DUPLICATE_ATTRIBUTE, "hreflang"));
+				this.hrefLang = aValue;
+			} else if (localName.equals("length")) {
+				if (this.length != null)
+					throw new GDataParseException(String.format(
+							DUPLICATE_ATTRIBUTE, "length"));
+				try {
+					this.length = new Integer(Integer.parseInt(aValue));
+				} catch (NumberFormatException e) {
+					throw new GDataParseException(
+							"attribute lenght must be an integer");
+				}
+			}
+
+		}
+		super.processAttribute(aQName, aValue);
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#processEndElement()
+	 */
+	@Override
+	public void processEndElement() {
+		if (this.href == null)
+			throw new GDataParseException(String.format(
+					MISSING_ELEMENT_ATTRIBUTE, this.localName, "href"));
+		try {
+			AtomParserUtils.getAbsolutAtomURI(this.xmlBase, this.href);
+		} catch (URISyntaxException e) {
+			throw new GDataParseException(String.format(INVALID_ATTRIBUTE,
+					"href", "absolute uri"), e);
+		}
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMElement#writeAtomOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
+	 */
+	public void writeAtomOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+		List<GOMAttribute> attList = getXmlNamespaceAttributes();
+		attList.add(GOMUtils.buildDefaultNamespaceAttribute(
+				this.href == null ? "" : this.href, "href"));
+		if (this.rel != null)
+			attList.add(GOMUtils
+					.buildDefaultNamespaceAttribute(this.rel, "rel"));
+		if (this.title != null)
+			attList.add(GOMUtils.buildDefaultNamespaceAttribute(this.title,
+					"title"));
+		if (this.type != null)
+			attList.add(GOMUtils.buildDefaultNamespaceAttribute(this.type,
+					"type"));
+		if (this.hrefLang != null)
+			attList.add(GOMUtils.buildDefaultNamespaceAttribute(this.hrefLang,
+					"hreflang"));
+		if (this.length != null)
+			attList.add(GOMUtils.buildDefaultNamespaceAttribute(this.length
+					.toString(), "length"));
+
+		aStreamWriter.writeSimpleXMLElement(this.qname, attList, null);
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMElement#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
+	 */
+	public void writeRssOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+		List<GOMAttribute> xmlNamespaceAttributes = getXmlNamespaceAttributes();
+		if (this.rel != null && rel.equalsIgnoreCase("enclosure")) {
+			if (type != null)
+				xmlNamespaceAttributes.add(GOMUtils
+						.buildDefaultNamespaceAttribute(type, "type"));
+			if (href != null)
+				xmlNamespaceAttributes.add(GOMUtils
+						.buildDefaultNamespaceAttribute(href, "href"));
+
+			aStreamWriter.writeSimpleXMLElement("enclosure",
+					xmlNamespaceAttributes, null);
+		} else if ("comments".equalsIgnoreCase(this.rel))
+			aStreamWriter.writeSimpleXMLElement("comments", null, this.href);
+
+		else if ("alternate".equalsIgnoreCase(this.rel))
+			aStreamWriter.writeSimpleXMLElement("link", null, this.href);
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMLogoImpl.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMLogoImpl.java
new file mode 100644
index 0000000..93f9ab6
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMLogoImpl.java
@@ -0,0 +1,51 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.GOMLogo;
+import org.apache.lucene.gdata.gom.GOMNamespace;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class GOMLogoImpl extends AtomUriElement implements GOMLogo {
+
+	/**
+	 * default class constructor
+	 */
+	public GOMLogoImpl() {
+		this.localName = GOMLogo.LOCALNAME;
+		this.qname = new QName(GOMNamespace.ATOM_NS_URI, this.localName);
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.SimpleGOMElementImpl#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
+	 */
+	@Override
+	public void writeRssOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+		aStreamWriter.writeSimpleXMLElement("url", getXmlNamespaceAttributes(),
+				this.textValue);
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMPersonImpl.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMPersonImpl.java
new file mode 100644
index 0000000..6938541
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMPersonImpl.java
@@ -0,0 +1,245 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.GOMAttribute;
+import org.apache.lucene.gdata.gom.GOMNamespace;
+import org.apache.lucene.gdata.gom.core.utils.GOMUtils;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class GOMPersonImpl extends AbstractGOMElement implements
+		org.apache.lucene.gdata.gom.GOMPerson {
+
+	private final static String NAME_LOCAL_NAME = "name";
+
+	private final static String EMAIL_LOCAL_NAME = "email";
+
+	private final static String URI_LOCAL_NAME = "uri";
+
+	protected String uri;
+
+	protected String email;
+
+	protected String name;
+
+	/**
+	 * 
+	 */
+	public GOMPersonImpl() {
+		super();
+		this.localName = LOCALNAME;
+		this.qname = new QName(GOMNamespace.ATOM_NS_URI, this.localName);
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMPerson#setName(java.lang.String)
+	 */
+	public void setName(String aName) {
+		this.name = aName;
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMPerson#setEmail(java.lang.String)
+	 */
+	public void setEmail(String aEmail) {
+		this.email = aEmail;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMPerson#setUri(java.lang.String)
+	 */
+	public void setUri(String aUri) {
+		this.uri = aUri;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMPerson#getName()
+	 */
+	public String getName() {
+
+		return this.name;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMPerson#getEmail()
+	 */
+	public String getEmail() {
+		return this.email;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMPerson#getUri()
+	 */
+	public String getUri() {
+
+		return this.uri;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMElement#writeAtomOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
+	 */
+	public void writeAtomOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+		if (aStreamWriter == null)
+			throw new GDataParseException("GOMWriter must not be null");
+		List<GOMAttribute> list = getXmlNamespaceAttributes();
+		if (this.xmlLang != null) {
+			list = new ArrayList<GOMAttribute>(1);
+			list.add(GOMUtils
+					.buildXMLNamespaceAttribute(this.xmlLang, XML_LANG));
+		}
+		aStreamWriter.writeStartElement(this.qname, list);
+		aStreamWriter.writeSimpleXMLElement(NAME_LOCAL_NAME, this.name, null);
+		if (this.email != null)
+			aStreamWriter.writeSimpleXMLElement(EMAIL_LOCAL_NAME, this.email,
+					null);
+		if (this.uri != null)
+			aStreamWriter.writeSimpleXMLElement(URI_LOCAL_NAME, this.uri, null);
+
+		aStreamWriter.writeEndElement();
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMElement#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
+	 */
+	public void writeRssOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+		//
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#getChildParser(javax.xml.namespace.QName)
+	 */
+	@Override
+	public AtomParser getChildParser(QName aName) {
+		if (aName == null)
+			throw new GDataParseException("QName must not be null");
+		if (aName.getNamespaceURI().equals(GOMNamespace.ATOM_NS_URI)) {
+			if (aName.getLocalPart().equals(NAME_LOCAL_NAME))
+				return this.new NameParser();
+			if (aName.getLocalPart().equals(URI_LOCAL_NAME))
+				return this.new UriParser();
+			if (aName.getLocalPart().equals(EMAIL_LOCAL_NAME))
+				return this.new EmailParser();
+		}
+		return super.getChildParser(aName);
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#processEndElement()
+	 */
+	@Override
+	public void processEndElement() {
+		if (this.name == null)
+			throw new GDataParseException(String.format(
+					AtomParser.MISSING_ELEMENT_CHILD, this.localName,
+					NAME_LOCAL_NAME));
+	}
+
+	class NameParser extends SimpleElementParser {
+
+		NameParser() {
+			this.localname = NAME_LOCAL_NAME;
+		}
+
+		/**
+		 * @see org.apache.lucene.gdata.gom.core.AtomParser#processEndElement()
+		 */
+		public void processEndElement() {
+			if (name != null)
+				throw new GDataParseException(String.format(
+						AtomParser.DUPLICATE_ELEMENT, this.localname));
+			if (this.aString != null)
+				name = this.aString;
+
+		}
+
+	}
+
+	class UriParser extends SimpleElementParser {
+
+		UriParser() {
+			this.localname = URI_LOCAL_NAME;
+		}
+
+		/**
+		 * @see org.apache.lucene.gdata.gom.core.AtomParser#processEndElement()
+		 */
+		public void processEndElement() {
+			if (uri != null)
+				throw new GDataParseException(String.format(
+						AtomParser.DUPLICATE_ELEMENT, this.localname));
+			if (this.aString != null)
+				uri = this.aString;
+
+		}
+
+	}
+
+	class EmailParser extends SimpleElementParser {
+
+		EmailParser() {
+			this.localname = EMAIL_LOCAL_NAME;
+		}
+
+		/**
+		 * @see org.apache.lucene.gdata.gom.core.AtomParser#processEndElement()
+		 */
+		public void processEndElement() {
+			if (email != null)
+				throw new GDataParseException(String.format(
+						AtomParser.DUPLICATE_ELEMENT, this.localname));
+			if (this.aString != null)
+				email = this.aString;
+
+		}
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMOutputWriter,
+	 *      java.lang.String)
+	 */
+	@Override
+	public void writeRssOutput(GOMOutputWriter aStreamWriter, String aRssName)
+			throws XMLStreamException {
+		if (aStreamWriter == null)
+			throw new GDataParseException("GOMWriter must not be null");
+		StringBuilder builder = new StringBuilder("");
+		if (this.email != null)
+			builder.append(this.email);
+		if (this.name != null)
+			builder.append("(").append(this.name).append(")");
+		aStreamWriter.writeSimpleXMLElement(aRssName,
+				getXmlNamespaceAttributes(), builder.toString());
+
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMPublishedImpl.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMPublishedImpl.java
new file mode 100644
index 0000000..274ac90
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMPublishedImpl.java
@@ -0,0 +1,55 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.GOMPublished;
+import org.apache.lucene.gdata.gom.core.utils.GOMUtils;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class GOMPublishedImpl extends GOMDateConstructImpl implements
+		GOMPublished {
+	protected static final QName RSS_QNAME = new QName("pubDate");
+
+	/**
+	 * 
+	 */
+	public GOMPublishedImpl() {
+		this.localName = GOMPublished.LOCALNAME;
+		this.qname = new QName(this.localName);
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMElement#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
+	 */
+	public void writeRssOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+		String rssRFC3339Date = GOMUtils
+				.buildRfc822Date(this.date == 0 ? System.currentTimeMillis()
+						: this.date);
+		aStreamWriter.writeSimpleXMLElement(RSS_QNAME,
+				getXmlNamespaceAttributes(), rssRFC3339Date);
+
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMRightsImpl.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMRightsImpl.java
new file mode 100644
index 0000000..94b9a15
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMRightsImpl.java
@@ -0,0 +1,49 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.GOMNamespace;
+import org.apache.lucene.gdata.gom.GOMRights;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class GOMRightsImpl extends GOMTextContructImpl implements GOMRights {
+
+	/**
+	 * 
+	 */
+	public GOMRightsImpl() {
+		this.localName = GOMRights.LOCALNAME;
+		this.rssLocalName = GOMRights.LOCALNAME;
+		this.qname = new QName(GOMNamespace.ATOM_NS_URI, this.localName);
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.GOMTextContructImpl#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
+	 */
+	@Override
+	public void writeRssOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+		aStreamWriter.writeSimpleXMLElement("copyright", null, this.textValue);
+	}
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMSourceImpl.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMSourceImpl.java
new file mode 100644
index 0000000..6e0ad96
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMSourceImpl.java
@@ -0,0 +1,544 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import java.util.LinkedList;
+import java.util.List;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.GOMAttribute;
+import org.apache.lucene.gdata.gom.GOMAuthor;
+import org.apache.lucene.gdata.gom.GOMCategory;
+import org.apache.lucene.gdata.gom.GOMContributor;
+import org.apache.lucene.gdata.gom.GOMGenerator;
+import org.apache.lucene.gdata.gom.GOMIcon;
+import org.apache.lucene.gdata.gom.GOMId;
+import org.apache.lucene.gdata.gom.GOMLink;
+import org.apache.lucene.gdata.gom.GOMLogo;
+import org.apache.lucene.gdata.gom.GOMNamespace;
+import org.apache.lucene.gdata.gom.GOMRights;
+import org.apache.lucene.gdata.gom.GOMSource;
+import org.apache.lucene.gdata.gom.GOMSubtitle;
+import org.apache.lucene.gdata.gom.GOMTitle;
+import org.apache.lucene.gdata.gom.GOMUpdated;
+import org.apache.lucene.gdata.gom.core.utils.AtomParserUtils;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class GOMSourceImpl extends AbstractGOMElement implements GOMSource {
+
+	protected List<GOMAuthor> authors = new LinkedList<GOMAuthor>();
+
+	protected List<GOMCategory> categories = new LinkedList<GOMCategory>();
+
+	protected List<GOMLink> links = new LinkedList<GOMLink>();
+
+	protected List<GOMContributor> contributors = new LinkedList<GOMContributor>();
+
+	protected GOMGenerator generator;
+
+	protected GOMId id;
+
+	protected GOMLogo logo;
+
+	protected GOMRights rights;
+
+	protected GOMSubtitle subtitle;
+
+	protected GOMTitle title;
+
+	protected GOMUpdated updated;
+
+	protected GOMIcon icon;
+
+	GOMSourceImpl() {
+		this.localName = LOCALNAME;
+		this.qname = new QName(GOMNamespace.ATOM_NS_URI, this.localName);
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#getLocalName()
+	 */
+	@Override
+	public String getLocalName() {
+		return this.localName;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMSource#addAuthor(org.apache.lucene.gdata.gom.GOMAuthor)
+	 */
+	public void addAuthor(GOMAuthor aAuthor) {
+		if (aAuthor != null)
+			this.authors.add(aAuthor);
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMSource#addCategory(org.apache.lucene.gdata.gom.GOMCategory)
+	 */
+	public void addCategory(GOMCategory aCategory) {
+		if (aCategory != null)
+			this.categories.add(aCategory);
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMSource#addContributor(org.apache.lucene.gdata.gom.GOMContributor)
+	 */
+	public void addContributor(GOMContributor aContributor) {
+		if (aContributor != null)
+			this.contributors.add(aContributor);
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMSource#getAuthors()
+	 * 
+	 */
+	public List<GOMAuthor> getAuthors() {
+		return this.authors;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMSource#getCategories()
+	 * 
+	 */
+	public List<GOMCategory> getCategories() {
+		return this.categories;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMSource#getContributor()
+	 */
+	public List<GOMContributor> getContributor() {
+		return this.contributors;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMSource#getGenerator()
+	 * 
+	 */
+	public GOMGenerator getGenerator() {
+		return this.generator;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMSource#getId()
+	 * 
+	 */
+	public GOMId getId() {
+		return this.id;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMSource#setGenerator(org.apache.lucene.gdata.gom.GOMGenerator)
+	 * 
+	 */
+	public void setGenerator(GOMGenerator aGenerator) {
+		this.generator = aGenerator;
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMSource#setIcon(org.apache.lucene.gdata.gom.GOMIcon)
+	 * 
+	 */
+	public void setIcon(GOMIcon aIcon) {
+		this.icon = aIcon;
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMSource#setId(org.apache.lucene.gdata.gom.GOMId)
+	 * 
+	 */
+	public void setId(GOMId aId) {
+		this.id = aId;
+
+	}
+
+	/**
+	 * @return the logo
+	 * 
+	 */
+	public GOMLogo getLogo() {
+		return this.logo;
+	}
+
+	/**
+	 * @param aLogo
+	 *            the logo to set
+	 * 
+	 */
+	public void setLogo(GOMLogo aLogo) {
+		this.logo = aLogo;
+	}
+
+	/**
+	 * @return the rights
+	 * 
+	 */
+	public GOMRights getRights() {
+		return this.rights;
+	}
+
+	/**
+	 * @param aRights
+	 *            the rights to set
+	 * 
+	 */
+	public void setRights(GOMRights aRights) {
+		rights = aRights;
+	}
+
+	/**
+	 * @return the subtitle
+	 * 
+	 */
+	public GOMSubtitle getSubtitle() {
+		return this.subtitle;
+	}
+
+	/**
+	 * @param aSubtitle
+	 *            the subtitle to set
+	 * 
+	 */
+	public void setSubtitle(GOMSubtitle aSubtitle) {
+		this.subtitle = aSubtitle;
+	}
+
+	/**
+	 * @return the title
+	 * 
+	 */
+	public GOMTitle getTitle() {
+		return this.title;
+	}
+
+	/**
+	 * @param aTitle
+	 *            the title to set
+	 * 
+	 */
+	public void setTitle(GOMTitle aTitle) {
+		this.title = aTitle;
+	}
+
+	/**
+	 * @return the updated
+	 * 
+	 */
+	public GOMUpdated getUpdated() {
+		return this.updated;
+	}
+
+	/**
+	 * @param aUpdated
+	 *            the updated to set
+	 * 
+	 */
+	public void setUpdated(GOMUpdated aUpdated) {
+		this.updated = aUpdated;
+	}
+
+	/**
+	 * @return the icon
+	 * 
+	 */
+	public GOMIcon getIcon() {
+		return this.icon;
+	}
+
+	/**
+	 * @return the links
+	 * 
+	 */
+	public List<GOMLink> getLinks() {
+		return this.links;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMSource#addLink(org.apache.lucene.gdata.gom.GOMLink)
+	 */
+	public void addLink(GOMLink aLink) {
+		if (aLink == null)
+			return;
+		this.links.add(aLink);
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.AtomParser#processElementValue(java.lang.String)
+	 */
+	public void processElementValue(String aValue) {
+		throw new GDataParseException(String.format(
+				AtomParser.UNEXPECTED_ELEMENT_VALUE, this.localName));
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.AtomParser#processEndElement()
+	 */
+	public void processEndElement() {
+		/*
+		 * atom:feed elements MUST contain exactly one atom:id element.
+		 */
+		if (this.id == null)
+			throw new GDataParseException(String.format(
+					MISSING_ELEMENT_CHILD, this.localName, GOMId.LOCALNAME));
+		/*
+		 * atom:feed elements MUST contain exactly one atom:title element.
+		 */
+		if (this.title == null)
+			throw new GDataParseException(String
+					.format(MISSING_ELEMENT_CHILD, this.localName,
+							GOMTitle.LOCALNAME));
+		/*
+		 * atom:feed elements MUST contain exactly one atom:updated element.
+		 */
+		if (this.updated == null)
+			throw new GDataParseException(String.format(
+					MISSING_ELEMENT_CHILD, this.localName,
+					GOMUpdated.LOCALNAME));
+		/*
+		 * atom:feed elements MUST contain one or more atom:author elements,
+		 * unless all of the
+		 */
+		if (this.authors.size() < 1)
+			throw new GDataParseException(String.format(
+					MISSING_ELEMENT_CHILD, this.localName,
+					GOMAuthor.LOCALNAME));
+
+		/*
+		 * atom:feed elements MUST NOT contain more than one atom:link element
+		 * with a rel attribute value of "alternate" that has the same
+		 * combination of type and hreflang attribute values.
+		 */
+		List<GOMLink> alternateLinks = new LinkedList<GOMLink>();
+		for (GOMLink link : this.links) {
+			/*
+			 * atom:link elements MAY have a "rel" attribute that indicates the
+			 * link relation type. If the "rel" attribute is not present, the
+			 * link element MUST be interpreted as if the link relation type is
+			 * "alternate".
+			 */
+			if (link.getRel() == null
+					|| link.getRel().equalsIgnoreCase("alternate"))
+				alternateLinks.add(link);
+		}
+
+		/*
+		 * atom:feed elements MUST NOT contain more than one atom:link element
+		 * with a rel attribute value of "alternate" that has the same
+		 * combination of type and hreflang attribute values.
+		 */
+		if (alternateLinks.size() > 1) {
+			for (GOMLink link : alternateLinks) {
+				for (GOMLink link2 : alternateLinks) {
+					if (link != link2)
+						if (AtomParserUtils.compareAlternateLinks(link, link2))
+							throw new GDataParseException(
+									String
+											.format(DUPLICATE_ELEMENT,
+													"link with rel=\"alternate\" and same href and type attributes"));
+
+				}
+			}
+		}
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.AtomParser#getChildParser(javax.xml.namespace.QName)
+	 */
+	public AtomParser getChildParser(QName aName) {
+		if (aName.getNamespaceURI().equals(GOMNamespace.ATOM_NS_URI)) {
+			if (aName.getLocalPart().equals(GOMId.LOCALNAME)) {
+				// atom:feed / atom:source elements MUST contain exactly one
+				// atom:id element.
+				if (this.id != null)
+					throw new GDataParseException(String.format(
+							AtomParser.DUPLICATE_ELEMENT, GOMId.LOCALNAME));
+				this.id = new GOMIdImpl();
+				return this.id;
+			}
+			if (aName.getLocalPart().equals(GOMTitle.LOCALNAME)) {
+				// atom:feed / atom:source elements MUST contain exactly one
+				// atom:title
+				// element.
+				if (this.title != null)
+					throw new GDataParseException(String.format(
+							AtomParser.DUPLICATE_ELEMENT, GOMTitle.LOCALNAME));
+				this.title = new GOMTitleImpl();
+				return this.title;
+			}
+			if (aName.getLocalPart().equals(GOMAuthor.LOCALNAME)) {
+				GOMAuthor author = new GOMAuthorImpl();
+				this.authors.add(author);
+				return author;
+			}
+			if (aName.getLocalPart().equals(GOMCategory.LOCALNAME)) {
+				GOMCategory category = new GOMCategoryImpl();
+				this.categories.add(category);
+				return category;
+			}
+			if (aName.getLocalPart().equals(GOMContributor.LOCALNAME)) {
+				GOMContributorImpl impl = new GOMContributorImpl();
+				this.contributors.add(impl);
+				return impl;
+			}
+			if (aName.getLocalPart().equals(GOMLink.LOCALNAME)) {
+				GOMLinkImpl impl = new GOMLinkImpl();
+				this.links.add(impl);
+				return impl;
+			}
+			if (aName.getLocalPart().equals(GOMSubtitle.LOCALNAME)) {
+				GOMSubtitleImpl impl = new GOMSubtitleImpl();
+				/*
+				 * atom:feed elements MUST NOT contain more than one
+				 * atom:subtitle element.
+				 */
+				if (this.subtitle != null)
+					throw new GDataParseException(String.format(
+							AtomParser.DUPLICATE_ELEMENT,
+							GOMSubtitle.LOCALNAME));
+				this.subtitle = impl;
+				return this.subtitle;
+			}
+			if (aName.getLocalPart().equals(GOMUpdated.LOCALNAME)) {
+				if (this.updated != null)
+					throw new GDataParseException(String.format(
+							AtomParser.DUPLICATE_ELEMENT,
+							GOMUpdated.LOCALNAME));
+				GOMUpdated updatedImpl = new GOMUpdatedImpl();
+				this.updated = updatedImpl;
+				return this.updated;
+
+			}
+			if (aName.getLocalPart().equals(GOMLogo.LOCALNAME)) {
+				if (this.logo != null)
+					throw new GDataParseException(String.format(
+							AtomParser.DUPLICATE_ELEMENT, GOMLogo.LOCALNAME));
+
+				this.logo = new GOMLogoImpl();
+				return this.logo;
+
+			}
+			if (aName.getLocalPart().equals(GOMIcon.LOCALNAME)) {
+				if (this.icon != null)
+					throw new GDataParseException(String.format(
+							AtomParser.DUPLICATE_ELEMENT, GOMIcon.LOCALNAME));
+
+				this.icon = new GOMIconImpl();
+				return this.icon;
+
+			}
+			if (aName.getLocalPart().equals(GOMGenerator.LOCALNAME)) {
+				if (this.generator != null)
+					throw new GDataParseException(String.format(
+							AtomParser.DUPLICATE_ELEMENT,
+							GOMGenerator.LOCALNAME));
+
+				this.generator = new GOMGeneratorImpl();
+				return this.generator;
+
+			}
+			if (aName.getLocalPart().equals(GOMRights.LOCALNAME)) {
+				if (this.rights != null)
+					throw new GDataParseException(String
+							.format(AtomParser.DUPLICATE_ELEMENT,
+									GOMRights.LOCALNAME));
+
+				this.rights = new GOMRightsImpl();
+				return this.rights;
+
+			}
+
+		}
+		throw new GDataParseException(String.format(
+				AtomParser.URECOGNIZED_ELEMENT_CHILD, this.localName, aName
+						.getLocalPart()));
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMElement#writeAtomOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
+	 */
+	public void writeAtomOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+		aStreamWriter.writeStartElement(this.localName,
+				this.extensionAttributes);
+		List<GOMAttribute> xmlNamespaceAttributes = getXmlNamespaceAttributes();
+		for (GOMAttribute attribute : xmlNamespaceAttributes) {
+			aStreamWriter.writeAttribute(attribute);
+		}
+		writeInnerAtomOutput(aStreamWriter);
+		aStreamWriter.writeEndElement();
+
+	}
+
+	/**
+	 * @param aStreamWriter
+	 * @throws XMLStreamException
+	 */
+	protected void writeInnerAtomOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+		if (this.id != null)
+			this.id.writeAtomOutput(aStreamWriter);
+		if (this.title != null)
+			this.title.writeAtomOutput(aStreamWriter);
+		if (this.subtitle != null)
+			this.subtitle.writeAtomOutput(aStreamWriter);
+		for (GOMAuthor authors : this.authors) {
+			authors.writeAtomOutput(aStreamWriter);
+		}
+		for (GOMCategory category : this.categories) {
+			category.writeAtomOutput(aStreamWriter);
+		}
+		for (GOMContributor contributor : this.contributors) {
+			contributor.writeAtomOutput(aStreamWriter);
+		}
+		for (GOMLink link : this.links) {
+			link.writeAtomOutput(aStreamWriter);
+		}
+		if (this.rights != null)
+			this.rights.writeAtomOutput(aStreamWriter);
+		if (this.updated != null)
+			this.updated.writeAtomOutput(aStreamWriter);
+		if (this.logo != null)
+			this.logo.writeAtomOutput(aStreamWriter);
+		if (this.icon != null)
+			this.icon.writeAtomOutput(aStreamWriter);
+		if (this.generator != null)
+			this.generator.writeAtomOutput(aStreamWriter);
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMElement#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
+	 */
+	public void writeRssOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+		// no rss output
+
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMSubtitleImpl.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMSubtitleImpl.java
new file mode 100644
index 0000000..6037595
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMSubtitleImpl.java
@@ -0,0 +1,39 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import javax.xml.namespace.QName;
+
+import org.apache.lucene.gdata.gom.GOMNamespace;
+import org.apache.lucene.gdata.gom.GOMSubtitle;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class GOMSubtitleImpl extends GOMTextContructImpl implements GOMSubtitle {
+
+	/**
+	 * 
+	 */
+	public GOMSubtitleImpl() {
+		this.localName = GOMSubtitle.LOCALNAME;
+		this.rssLocalName = GOMSubtitle.RSS_LOCALNAME;
+		this.qname = new QName(GOMNamespace.ATOM_NS_URI, this.localName);
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMSummaryImpl.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMSummaryImpl.java
new file mode 100644
index 0000000..dd5e249
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMSummaryImpl.java
@@ -0,0 +1,57 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.GOMNamespace;
+import org.apache.lucene.gdata.gom.GOMSummary;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class GOMSummaryImpl extends GOMTextContructImpl implements GOMSummary {
+	protected static final QName ATOM_QNAME = new QName(
+			GOMNamespace.ATOM_NS_URI, LOCALNAME, GOMNamespace.ATOM_NS_PREFIX);
+
+	/**
+	 * 
+	 */
+	public GOMSummaryImpl() {
+		this.localName = GOMSummary.LOCALNAME;
+		this.qname = new QName(GOMNamespace.ATOM_NS_URI, this.localName);
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.GOMTextContructImpl#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
+	 */
+	@Override
+	public void writeRssOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+		/*
+		 * RSS does not support markup as child elements StaX Writer will encode
+		 * all containing markup into valid xml entities
+		 */
+		aStreamWriter.writeSimpleXMLElement(ATOM_QNAME,
+				getXmlNamespaceAttributes(), this.textValue);
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMTextContructImpl.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMTextContructImpl.java
new file mode 100644
index 0000000..564f313
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMTextContructImpl.java
@@ -0,0 +1,270 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import java.io.StringWriter;
+import java.util.List;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLOutputFactory;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamWriter;
+
+import org.apache.lucene.gdata.gom.ContentType;
+import org.apache.lucene.gdata.gom.GOMAttribute;
+import org.apache.lucene.gdata.gom.GOMTextConstruct;
+import org.apache.lucene.gdata.gom.core.utils.GOMUtils;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public abstract class GOMTextContructImpl extends AbstractGOMElement implements
+		GOMTextConstruct {
+
+	protected ContentType contentType;
+
+	protected String rssLocalName;
+
+	/*
+	 * parses the xhtml content
+	 */
+	protected transient XMLBlobContentParser blobParser = null;
+
+	/*
+	 * this string builder contains the html while parsing the incoming text
+	 * contruct. process element value will be called multiple times
+	 */
+	protected transient StringBuilder htmlBuilder = null;
+
+	/**
+	 * @return the contentType
+	 * 
+	 */
+	public ContentType getContentType() {
+		return this.contentType;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.AtomParser#processElementValue(java.lang.String)
+	 */
+	public void processElementValue(String aValue) {
+		if (this.htmlBuilder != null)
+			this.htmlBuilder.append(aValue);
+		else {
+			this.textValue = aValue;
+		}
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.AtomParser#processAttribute(javax.xml.namespace.QName,
+	 *      java.lang.String)
+	 */
+	public void processAttribute(QName aQName, String aValue) {
+		if (aQName == null)
+			throw new GDataParseException("QName must not be null");
+		if ("type".equals(aQName.getLocalPart()) && aValue != null) {
+			if (this.contentType != null)
+				throw new GDataParseException(String.format(
+						DUPLICATE_ATTRIBUTE, "type"));
+			this.contentType = ContentType.valueOf(aValue.toUpperCase());
+			if (this.contentType == ContentType.HTML)
+				this.htmlBuilder = new StringBuilder();
+		}
+		super.processAttribute(aQName, aValue);
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.AtomParser#processEndElement()
+	 */
+	public void processEndElement() {
+		if (this.contentType == null)
+			throw new GDataParseException(String.format(
+					MISSING_ELEMENT_ATTRIBUTE, this.qname, "type"));
+		switch (this.contentType) {
+		case XHTML:
+			if (this.blobParser != null) {
+				this.textValue = this.blobParser.toString();
+				this.blobParser.close();
+				this.blobParser = null;
+			}
+
+			break;
+		case HTML:
+			if (this.htmlBuilder != null) {
+				this.textValue = this.htmlBuilder.toString();
+				this.htmlBuilder = null;
+			}
+
+		default:
+			break;
+		}
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMElement#writeAtomOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
+	 */
+	public void writeAtomOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+		List<GOMAttribute> xmlNamespaceAttributes = getXmlNamespaceAttributes();
+		xmlNamespaceAttributes.add(GOMUtils
+				.getAttributeByContentTypeDefaultNs(this.contentType));
+		if (this.contentType == ContentType.XHTML) {
+			/*
+			 * if the content is xhtml write it unescaped
+			 */
+			aStreamWriter.writeStartElement(this.localName,
+					xmlNamespaceAttributes);
+			aStreamWriter.writeContentUnescaped(this.textValue);
+			aStreamWriter.writeEndElement();
+
+		} else {
+			// html and text will be escaped by stax writer
+			aStreamWriter.writeSimpleXMLElement(this.localName,
+					xmlNamespaceAttributes, this.textValue);
+		}
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMElement#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
+	 */
+	public void writeRssOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+		/*
+		 * RSS does not support markup as child elements StaX Writer will encode
+		 * all containing markup into valid xml entities
+		 */
+		aStreamWriter.writeSimpleXMLElement(this.rssLocalName,
+				getXmlNamespaceAttributes(), this.textValue);
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.AtomParser#getChildParser(javax.xml.namespace.QName)
+	 */
+	@Override
+	public AtomParser getChildParser(QName aName) {
+		if (aName == null)
+			throw new GDataParseException("QName must not be null");
+		if (this.contentType == ContentType.XHTML
+				&& aName.getLocalPart().equals("div")) {
+			if (this.blobParser != null)
+				throw new GDataParseException(String.format(
+						DUPLICATE_ELEMENT, "div"));
+			this.blobParser = new XMLBlobContentParser();
+			return this.blobParser.getChildParser(aName);
+		}
+
+		return super.getChildParser(aName);
+
+	}
+
+	class XMLBlobContentParser implements AtomParser {
+		private StringWriter writer;
+
+		private XMLStreamWriter xmlWriter;
+
+		/**
+		 * 
+		 */
+		public XMLBlobContentParser() {
+			super();
+			this.writer = new StringWriter();
+			try {
+				this.xmlWriter = XMLOutputFactory.newInstance()
+						.createXMLStreamWriter(this.writer);
+			} catch (Exception e) {
+				throw new GDataParseException(e);
+			}
+		}
+
+		/**
+		 * @see org.apache.lucene.gdata.gom.core.AtomParser#processElementValue(java.lang.String)
+		 */
+		public void processElementValue(String aValue) {
+			try {
+				this.xmlWriter.writeCharacters(aValue);
+			} catch (XMLStreamException e) {
+				throw new GDataParseException(e);
+			}
+
+		}
+
+		/**
+		 * @see org.apache.lucene.gdata.gom.core.AtomParser#processAttribute(javax.xml.namespace.QName,
+		 *      java.lang.String)
+		 */
+		public void processAttribute(QName aQName, String aValue) {
+			try {
+				this.xmlWriter.writeAttribute(aQName.getNamespaceURI(), aQName
+						.getLocalPart(), aQName.getPrefix(), aValue);
+			} catch (XMLStreamException e) {
+				throw new GDataParseException(e);
+			}
+
+		}
+
+		/**
+		 * @see org.apache.lucene.gdata.gom.core.AtomParser#processEndElement()
+		 */
+		public void processEndElement() {
+			try {
+				this.xmlWriter.writeEndElement();
+			} catch (XMLStreamException e) {
+				throw new GDataParseException(e);
+			}
+
+		}
+
+		/**
+		 * @see org.apache.lucene.gdata.gom.core.AtomParser#getChildParser(javax.xml.namespace.QName)
+		 */
+		public AtomParser getChildParser(QName aName) {
+			try {
+				this.xmlWriter.writeStartElement(aName.getNamespaceURI(), aName
+						.getLocalPart(), aName.getPrefix());
+			} catch (XMLStreamException e) {
+				throw new GDataParseException(e);
+			}
+			return this;
+		}
+
+		/**
+		 * @see java.lang.Object#toString()
+		 */
+		public String toString() {
+			return this.writer.toString();
+		}
+
+		/**
+		 * 
+		 */
+		public void close() {
+			try {
+				this.xmlWriter.close();
+				this.writer.close();
+			} catch (Exception e) {
+				throw new GDataParseException(e);
+			}
+		}
+
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMTitleImpl.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMTitleImpl.java
new file mode 100644
index 0000000..2db8328
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMTitleImpl.java
@@ -0,0 +1,38 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import javax.xml.namespace.QName;
+
+import org.apache.lucene.gdata.gom.GOMNamespace;
+import org.apache.lucene.gdata.gom.GOMTitle;
+
+/**
+ * @author Simon Willnauer
+ */
+public class GOMTitleImpl extends GOMTextContructImpl implements GOMTitle {
+	/**
+	 * 
+	 */
+	public GOMTitleImpl() {
+		super();
+		this.localName = LOCALNAME;
+		this.rssLocalName = LOCALNAME;
+		this.qname = new QName(GOMNamespace.ATOM_NS_URI, this.localName);
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMUpdatedImpl.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMUpdatedImpl.java
new file mode 100644
index 0000000..7d27ca2
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/GOMUpdatedImpl.java
@@ -0,0 +1,58 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.GOMNamespace;
+import org.apache.lucene.gdata.gom.GOMUpdated;
+import org.apache.lucene.gdata.gom.core.utils.GOMUtils;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class GOMUpdatedImpl extends GOMDateConstructImpl implements GOMUpdated {
+	protected static final QName ATOM_QNAME = new QName(
+			GOMNamespace.ATOM_NS_URI, LOCALNAME, GOMNamespace.ATOM_NS_PREFIX);
+
+	/**
+	 * 
+	 */
+	public GOMUpdatedImpl() {
+		super();
+		this.localName = LOCALNAME;
+		this.qname = new QName(GOMNamespace.ATOM_NS_URI, this.localName);
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMElement#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
+	 */
+	public void writeRssOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+		if (this.rfc3339String == null)
+			this.rfc3339String = GOMUtils
+					.buildRfc3339DateFormat(this.date == 0 ? System
+							.currentTimeMillis() : this.date);
+		aStreamWriter.writeSimpleXMLElement(ATOM_QNAME,
+				getXmlNamespaceAttributes(), this.rfc3339String);
+
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/SimpleElementParser.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/SimpleElementParser.java
new file mode 100644
index 0000000..495b07b
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/SimpleElementParser.java
@@ -0,0 +1,62 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import javax.xml.namespace.QName;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+abstract class SimpleElementParser implements AtomParser {
+	protected String aString = null;
+
+	protected String localname = null;
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.AtomParser#processElementValue(java.lang.String)
+	 */
+	public void processElementValue(String aValue) {
+		this.aString = aValue;
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.AtomParser#processAttribute(javax.xml.namespace.QName,
+	 *      java.lang.String)
+	 */
+	public void processAttribute(QName aQName, String aValue) {
+		//
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.AtomParser#processEndElement()
+	 */
+	public abstract void processEndElement();
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.AtomParser#getChildParser(javax.xml.namespace.QName)
+	 */
+	public AtomParser getChildParser(QName aName) {
+		if (aName == null)
+			throw new GDataParseException("QName must not be null");
+		throw new GDataParseException(String.format(
+				AtomParser.UNEXPECTED_ELEMENT_CHILD, this.localname));
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/SimpleGOMElementImpl.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/SimpleGOMElementImpl.java
new file mode 100644
index 0000000..8c1cc21
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/SimpleGOMElementImpl.java
@@ -0,0 +1,121 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.GOMNamespace;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class SimpleGOMElementImpl extends AbstractGOMElement {
+	public static final String ELEMENT_OS_ITEMS_PER_PAGE = "itemsPerPage";
+
+	public static final String ELEMENT_OS_START_INDEX = "startIndex";
+
+	private SimpleValidator validator;
+
+	/**
+	 * 
+	 */
+	public SimpleGOMElementImpl(String aLocalName, GOMNamespace aNamespace) {
+		super();
+		if (aLocalName == null)
+			throw new IllegalArgumentException("localname must not be null");
+		if (aNamespace == null)
+			throw new IllegalArgumentException("Namespace must not be null");
+		this.localName = aLocalName;
+		this.qname = new QName(aNamespace.getNamespaceUri(), this.localName,
+				aNamespace.getNamespacePrefix());
+	}
+
+	SimpleGOMElementImpl() {
+		// for subclasses
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#processElementValue(java.lang.String)
+	 */
+	@Override
+	public void processElementValue(String aValue) {
+		if (this.textValue != null)
+			throw new GDataParseException(String.format(
+					AtomParser.DUPLICATE_ELEMENT_VALUE, this.localName));
+		this.textValue = aValue;
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.core.AbstractGOMElement#processEndElement()
+	 */
+	@Override
+	public void processEndElement() {
+		if (this.validator != null)
+			this.validator.validate(this.textValue);
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMElement#writeAtomOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
+	 */
+	public void writeAtomOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+		aStreamWriter.writeSimpleXMLElement(this.qname,
+				getXmlNamespaceAttributes(), this.textValue);
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.GOMElement#writeRssOutput(org.apache.lucene.gdata.gom.writer.GOMStaxWriter)
+	 */
+	public void writeRssOutput(GOMOutputWriter aStreamWriter)
+			throws XMLStreamException {
+		writeAtomOutput(aStreamWriter);
+
+	}
+
+	protected abstract static class SimpleValidator {
+		String localName;
+
+		protected SimpleValidator(String aLocalName) {
+			this.localName = aLocalName;
+		}
+
+		/**
+		 * @param aTextValue
+		 */
+		protected void validate(String aTextValue) {
+			if (aTextValue == null)
+				throw new GDataParseException(String.format(
+						AtomParser.MISSING_ELEMENT_VALUE_PLAIN,
+						this.localName));
+		}
+
+	}
+
+	/**
+	 * @param aValidator
+	 *            The validator to set.
+	 */
+	public void setValidator(SimpleValidator aValidator) {
+		validator = aValidator;
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/core-aid.gif b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/core-aid.gif
new file mode 100644
index 0000000..9d42f36
Binary files /dev/null and b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/core-aid.gif differ
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/core-aid.ucd b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/core-aid.ucd
new file mode 100644
index 0000000..01145fb
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/core-aid.ucd
@@ -0,0 +1,257 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<editmodel:ClassDiagramEditModel xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:editmodel="editmodel.xmi" xmlns:options="options.xmi" name="core-aid" description="" id="org.apache.lucene.gdata.gom.core" metadata="uml2-1.0" initialized="true" zoom="1.5" scrolledX="1601" scrolledY="503" tag="1000" key="3230303631303036204764617461556D6C2F73696D6F6E">
+  <children xsi:type="editmodel:ClassEditModel" name="GDataParseException" location="50,1339" size="240,151" id="org.apache.lucene.gdata.gom.core/GDataParseException" runTimeClassModel="GDataParseException(Ljava.lang.String;),GDataParseException(),GDataParseException(Ljava.lang.String;Ljava.lang.Throwable;),GDataParseException(Ljava.lang.Throwable;)">
+    <children xsi:type="editmodel:CompartmentEditModel"/>
+    <children xsi:type="editmodel:CompartmentEditModel" size="217,72">
+      <children xsi:type="editmodel:MethodEditModel" name="GDataParseException" id="org.apache.lucene.gdata.gom.core/GDataParseException#GDataParseException()"/>
+      <children xsi:type="editmodel:MethodEditModel" name="GDataParseException" id="org.apache.lucene.gdata.gom.core/GDataParseException#GDataParseException(Ljava.lang.String;)"/>
+      <children xsi:type="editmodel:MethodEditModel" name="GDataParseException" id="org.apache.lucene.gdata.gom.core/GDataParseException#GDataParseException(Ljava.lang.Throwable;)"/>
+      <children xsi:type="editmodel:MethodEditModel" name="GDataParseException" id="org.apache.lucene.gdata.gom.core/GDataParseException#GDataParseException(Ljava.lang.String;Ljava.lang.Throwable;)"/>
+    </children>
+    <children xsi:type="editmodel:CompartmentEditModel"/>
+    <classifierPreferences xsi:type="editmodel:UMLClassDiagramClassifierPreference" showStereotype="true" showMethodsParameterTypes="true" showMethodsReturnType="true" showMethodsParameterNames="true" showMethodsParameterKinds="true" attributeSorter="Natural" methodSorter="Natural" innerClassSorter="Natural" showPrivateAttributes="true" showProtectedAttributes="true" showPublicAttributes="true" showPackageAttributes="true" showStaticAttributes="true" showProtectedMethods="true" showPublicMethods="true" showPackageMethods="true" showPrivateMethods="true" showStaticMethods="true" showProtectedInnerClasses="true" showPublicInnerClasses="true" showPackageInnerClasses="true" showPrivateInnerClasses="true" showStaticInnerClasses="true" showAssociationMember="true" showMethods="true" showAttributes="true" showLiterals="true"/>
+  </children>
+  <children xsi:type="editmodel:ClassEditModel" targetConnections="//@children.6/@sourceConnections.0" name="GOMFeedImpl" location="220,250" size="233,889" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl" runTimeClassModel="getId(),contributors,getTitle(),getLogo(),namespaces,getIcon(),setIcon(Lorg.apache.lucene.gdata.gom.GOMIcon;),id,logo,links,getNamespaces(),setTitle(Lorg.apache.lucene.gdata.gom.GOMTitle;),getLinks(),rights,entries,setSubtitle(Lorg.apache.lucene.gdata.gom.GOMSubtitle;),getChildren(),setLogo(Lorg.apache.lucene.gdata.gom.GOMLogo;),GOMFeedImpl(),getGenerator(),addCategory(Lorg.apache.lucene.gdata.gom.GOMCategory;),processEndElement(),processAttribute(Ljavax.xml.namespace.QName;Ljava.lang.String;),getContributor(),addAuthor(Lorg.apache.lucene.gdata.gom.GOMAuthor;),addEntry(Lorg.apache.lucene.gdata.gom.GOMEntry;),title,getRights(),categories,setId(Lorg.apache.lucene.gdata.gom.GOMId;),updated,setGenerator(Lorg.apache.lucene.gdata.gom.GOMGenerator;),addChild(Lorg.apache.lucene.gdata.gom.GOMElement;),getChildParser(Ljavax.xml.namespace.QName;),getAuthors(),icon,writeRssOutput(Ljavax.xml.stream.XMLStreamWriter;),setRights(Lorg.apache.lucene.gdata.gom.GOMRights;),writeAtomOutput(Ljavax.xml.stream.XMLStreamWriter;),addContributor(Lorg.apache.lucene.gdata.gom.GOMContributor;),addNamespace(Lorg.apache.lucene.gdata.gom.core.GOMNamespace;),processElementValue(Ljava.lang.String;),authors,getLocalName(),getUpdated(),getSubtitle(),setUpdated(Lorg.apache.lucene.gdata.gom.GOMTime;),generator,getEntries(),subtitle,getCategories()">
+    <children xsi:type="editmodel:CompartmentEditModel" size="109,144">
+      <children xsi:type="editmodel:AttributeEditModel" name="generator" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#generator"/>
+      <children xsi:type="editmodel:AttributeEditModel" name="icon" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#icon"/>
+      <children xsi:type="editmodel:AttributeEditModel" name="id" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#id"/>
+      <children xsi:type="editmodel:AttributeEditModel" name="logo" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#logo"/>
+      <children xsi:type="editmodel:AttributeEditModel" name="rights" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#rights"/>
+      <children xsi:type="editmodel:AttributeEditModel" name="subtitle" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#subtitle"/>
+      <children xsi:type="editmodel:AttributeEditModel" name="title" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#title"/>
+      <children xsi:type="editmodel:AttributeEditModel" name="updated" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#updated"/>
+    </children>
+    <children xsi:type="editmodel:CompartmentEditModel" size="210,666">
+      <children xsi:type="editmodel:MethodEditModel" name="GOMFeedImpl" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#GOMFeedImpl()"/>
+      <children xsi:type="editmodel:MethodEditModel" name="addAuthor" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#addAuthor(Lorg.apache.lucene.gdata.gom.GOMAuthor;)"/>
+      <children xsi:type="editmodel:MethodEditModel" name="addCategory" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#addCategory(Lorg.apache.lucene.gdata.gom.GOMCategory;)"/>
+      <children xsi:type="editmodel:MethodEditModel" name="addChild" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#addChild(Lorg.apache.lucene.gdata.gom.GOMElement;)"/>
+      <children xsi:type="editmodel:MethodEditModel" name="addContributor" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#addContributor(Lorg.apache.lucene.gdata.gom.GOMContributor;)"/>
+      <children xsi:type="editmodel:MethodEditModel" name="addEntry" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#addEntry(Lorg.apache.lucene.gdata.gom.GOMEntry;)"/>
+      <children xsi:type="editmodel:MethodEditModel" name="addNamespace" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#addNamespace(Lorg.apache.lucene.gdata.gom.core.GOMNamespace;)"/>
+      <children xsi:type="editmodel:MethodEditModel" name="getAuthors" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#getAuthors()"/>
+      <children xsi:type="editmodel:MethodEditModel" name="getCategories" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#getCategories()"/>
+      <children xsi:type="editmodel:MethodEditModel" name="getChildParser" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#getChildParser(Ljavax.xml.namespace.QName;)"/>
+      <children xsi:type="editmodel:MethodEditModel" name="getChildren" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#getChildren()"/>
+      <children xsi:type="editmodel:MethodEditModel" name="getContributor" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#getContributor()"/>
+      <children xsi:type="editmodel:MethodEditModel" name="getEntries" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#getEntries()"/>
+      <children xsi:type="editmodel:MethodEditModel" name="getGenerator" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#getGenerator()"/>
+      <children xsi:type="editmodel:MethodEditModel" name="getIcon" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#getIcon()"/>
+      <children xsi:type="editmodel:MethodEditModel" name="getId" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#getId()"/>
+      <children xsi:type="editmodel:MethodEditModel" name="getLinks" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#getLinks()"/>
+      <children xsi:type="editmodel:MethodEditModel" name="getLocalName" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#getLocalName()"/>
+      <children xsi:type="editmodel:MethodEditModel" name="getLogo" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#getLogo()"/>
+      <children xsi:type="editmodel:MethodEditModel" name="getNamespaces" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#getNamespaces()"/>
+      <children xsi:type="editmodel:MethodEditModel" name="getRights" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#getRights()"/>
+      <children xsi:type="editmodel:MethodEditModel" name="getSubtitle" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#getSubtitle()"/>
+      <children xsi:type="editmodel:MethodEditModel" name="getTitle" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#getTitle()"/>
+      <children xsi:type="editmodel:MethodEditModel" name="getUpdated" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#getUpdated()"/>
+      <children xsi:type="editmodel:MethodEditModel" name="processAttribute" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#processAttribute(Ljavax.xml.namespace.QName;Ljava.lang.String;)"/>
+      <children xsi:type="editmodel:MethodEditModel" name="processElementValue" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#processElementValue(Ljava.lang.String;)"/>
+      <children xsi:type="editmodel:MethodEditModel" name="processEndElement" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#processEndElement()"/>
+      <children xsi:type="editmodel:MethodEditModel" name="setGenerator" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#setGenerator(Lorg.apache.lucene.gdata.gom.GOMGenerator;)"/>
+      <children xsi:type="editmodel:MethodEditModel" name="setIcon" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#setIcon(Lorg.apache.lucene.gdata.gom.GOMIcon;)"/>
+      <children xsi:type="editmodel:MethodEditModel" name="setId" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#setId(Lorg.apache.lucene.gdata.gom.GOMId;)"/>
+      <children xsi:type="editmodel:MethodEditModel" name="setLogo" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#setLogo(Lorg.apache.lucene.gdata.gom.GOMLogo;)"/>
+      <children xsi:type="editmodel:MethodEditModel" name="setRights" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#setRights(Lorg.apache.lucene.gdata.gom.GOMRights;)"/>
+      <children xsi:type="editmodel:MethodEditModel" name="setSubtitle" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#setSubtitle(Lorg.apache.lucene.gdata.gom.GOMSubtitle;)"/>
+      <children xsi:type="editmodel:MethodEditModel" name="setTitle" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#setTitle(Lorg.apache.lucene.gdata.gom.GOMTitle;)"/>
+      <children xsi:type="editmodel:MethodEditModel" name="setUpdated" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#setUpdated(Lorg.apache.lucene.gdata.gom.GOMTime;)"/>
+      <children xsi:type="editmodel:MethodEditModel" name="writeAtomOutput" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#writeAtomOutput(Ljavax.xml.stream.XMLStreamWriter;)"/>
+      <children xsi:type="editmodel:MethodEditModel" name="writeRssOutput" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl#writeRssOutput(Ljavax.xml.stream.XMLStreamWriter;)"/>
+    </children>
+    <children xsi:type="editmodel:CompartmentEditModel"/>
+    <sourceConnections xsi:type="editmodel:DependencyEditModel" autoLocated="true" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl->org.apache.lucene.gdata.gom.core/AtomParser" source="//@children.1" target="//@children.3" targetEnd="//@children.1/@sourceConnections.0/@children.2" label="//@children.1/@sourceConnections.0/@children.0" sourceEnd="//@children.1/@sourceConnections.0/@children.1" connectionRouterKind="Manhattan">
+      <children xsi:type="editmodel:WireLabelEditModel" name="import" size="29,10" fontInfo="Arial-8-0" anchorKind="MiddlePart"/>
+      <children xsi:type="editmodel:AssociationEndEditModel" location="233,34" attachSource="true"/>
+      <children xsi:type="editmodel:AssociationEndEditModel" location="0,234"/>
+    </sourceConnections>
+    <sourceConnections xsi:type="editmodel:DependencyEditModel" autoLocated="true" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl->org.apache.lucene.gdata.gom.core/GOMNamespace" source="//@children.1" target="//@children.6" targetEnd="//@children.1/@sourceConnections.1/@children.2" label="//@children.1/@sourceConnections.1/@children.0" sourceEnd="//@children.1/@sourceConnections.1/@children.1" connectionRouterKind="Manhattan">
+      <children xsi:type="editmodel:WireLabelEditModel" name="import" size="29,10" fontInfo="Arial-8-0" anchorKind="MiddlePart"/>
+      <children xsi:type="editmodel:AssociationEndEditModel" location="233,592" attachSource="true"/>
+      <children xsi:type="editmodel:AssociationEndEditModel" location="0,102"/>
+    </sourceConnections>
+    <sourceConnections xsi:type="editmodel:DependencyEditModel" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl->org.apache.lucene.gdata.gom.core/GOMAttributeImpl" source="//@children.1" target="//@children.7" targetEnd="//@children.1/@sourceConnections.2/@children.2" label="//@children.1/@sourceConnections.2/@children.0" sourceEnd="//@children.1/@sourceConnections.2/@children.1" connectionRouterKind="Manhattan">
+      <children xsi:type="editmodel:WireLabelEditModel" size="0,10" fontInfo="Arial-8-0" anchorKind="MiddlePart"/>
+      <children xsi:type="editmodel:AssociationEndEditModel" location="0,12" attachSource="true"/>
+      <children xsi:type="editmodel:AssociationEndEditModel" location="173,193"/>
+    </sourceConnections>
+    <sourceConnections xsi:type="editmodel:DependencyEditModel" autoLocated="true" id="org.apache.lucene.gdata.gom.core/GOMFeedImpl->org.apache.lucene.gdata.gom.core/GOMAttributeImpl" source="//@children.1" target="//@children.7" targetEnd="//@children.1/@sourceConnections.3/@children.2" label="//@children.1/@sourceConnections.3/@children.0" sourceEnd="//@children.1/@sourceConnections.3/@children.1" connectionRouterKind="Manhattan">
+      <children xsi:type="editmodel:WireLabelEditModel" name="import" size="29,10" fontInfo="Arial-8-0" anchorKind="MiddlePart"/>
+      <children xsi:type="editmodel:AssociationEndEditModel" location="233,10" attachSource="true"/>
+      <children xsi:type="editmodel:AssociationEndEditModel" location="10,205"/>
+    </sourceConnections>
+    <classifierPreferences xsi:type="editmodel:UMLClassDiagramClassifierPreference" showStereotype="true" showMethodsParameterTypes="true" showMethodsReturnType="true" showMethodsParameterNames="true" showMethodsParameterKinds="true" attributeSorter="Natural" methodSorter="Natural" innerClassSorter="Natural" showPrivateAttributes="true" showProtectedAttributes="true" showPublicAttributes="true" showPackageAttributes="true" showStaticAttributes="true" showProtectedMethods="true" showPublicMethods="true" showPackageMethods="true" showPrivateMethods="true" showStaticMethods="true" showProtectedInnerClasses="true" showPublicInnerClasses="true" showPackageInnerClasses="true" showPrivateInnerClasses="true" showStaticInnerClasses="true" packageIndication="2" showAssociationMember="true" showMethods="true" showAttributes="true" showLiterals="true"/>
+  </children>
+  <children xsi:type="editmodel:ClassEditModel" targetConnections="//@children.5/@sourceConnections.2 //@children.5/@sourceConnections.4" name="GOMFactory" location="1873,241" size="147,133" id="org.apache.lucene.gdata.gom.core/GOMFactory" runTimeClassModel="createInstance(),createFeed(),GOMFactory()">
+    <children xsi:type="editmodel:CompartmentEditModel"/>
+    <children xsi:type="editmodel:CompartmentEditModel" size="124,54">
+      <children xsi:type="editmodel:MethodEditModel" name="GOMFactory" id="org.apache.lucene.gdata.gom.core/GOMFactory#GOMFactory()"/>
+      <children xsi:type="editmodel:MethodEditModel" name="createInstance" id="org.apache.lucene.gdata.gom.core/GOMFactory#createInstance()"/>
+      <children xsi:type="editmodel:MethodEditModel" name="createFeed" id="org.apache.lucene.gdata.gom.core/GOMFactory#createFeed()"/>
+    </children>
+    <children xsi:type="editmodel:CompartmentEditModel"/>
+    <classifierPreferences xsi:type="editmodel:UMLClassDiagramClassifierPreference" showStereotype="true" showMethodsParameterTypes="true" showMethodsReturnType="true" showMethodsParameterNames="true" showMethodsParameterKinds="true" attributeSorter="Natural" methodSorter="Natural" innerClassSorter="Natural" showPrivateAttributes="true" showProtectedAttributes="true" showPublicAttributes="true" showPackageAttributes="true" showStaticAttributes="true" showProtectedMethods="true" showPublicMethods="true" showPackageMethods="true" showPrivateMethods="true" showStaticMethods="true" showProtectedInnerClasses="true" showPublicInnerClasses="true" showPackageInnerClasses="true" showPrivateInnerClasses="true" showStaticInnerClasses="true" showAssociationMember="true" showMethods="true" showAttributes="true" showLiterals="true"/>
+  </children>
+  <children xsi:type="editmodel:InterfaceEditModel" targetConnections="//@children.5/@sourceConnections.0 //@children.1/@sourceConnections.0" name="AtomParser" location="1051,50" size="233,269" id="org.apache.lucene.gdata.gom.core/AtomParser" runTimeClassModel="uNEXPECTED_ATTRIBUTE,uNEXPECTED_ELEMENENT_VALUE,uNEXPECTED_ELEMENENT_CHILD,getChildParser(Ljavax.xml.namespace.QName;),uNEXPECTED_ELEMENENT,processEndElement(),mISSING_ELEMEMENT_CHILD,processElementValue(Ljava.lang.String;),processAttribute(Ljavax.xml.namespace.QName;Ljava.lang.String;),mISSING_ELEMEMENT_ATTRIBUTE">
+    <children xsi:type="editmodel:CompartmentEditModel" size="179,108">
+      <children xsi:type="editmodel:AttributeEditModel" name="uNEXPECTED_ELEMENENT" id="org.apache.lucene.gdata.gom.core/AtomParser#uNEXPECTED_ELEMENENT"/>
+      <children xsi:type="editmodel:AttributeEditModel" name="uNEXPECTED_ELEMENENT_CHILD" id="org.apache.lucene.gdata.gom.core/AtomParser#uNEXPECTED_ELEMENENT_CHILD"/>
+      <children xsi:type="editmodel:AttributeEditModel" name="uNEXPECTED_ATTRIBUTE" id="org.apache.lucene.gdata.gom.core/AtomParser#uNEXPECTED_ATTRIBUTE"/>
+      <children xsi:type="editmodel:AttributeEditModel" name="uNEXPECTED_ELEMENENT_VALUE" id="org.apache.lucene.gdata.gom.core/AtomParser#uNEXPECTED_ELEMENENT_VALUE"/>
+      <children xsi:type="editmodel:AttributeEditModel" name="mISSING_ELEMEMENT_ATTRIBUTE" id="org.apache.lucene.gdata.gom.core/AtomParser#mISSING_ELEMEMENT_ATTRIBUTE"/>
+      <children xsi:type="editmodel:AttributeEditModel" name="mISSING_ELEMEMENT_CHILD" id="org.apache.lucene.gdata.gom.core/AtomParser#mISSING_ELEMEMENT_CHILD"/>
+    </children>
+    <children xsi:type="editmodel:CompartmentEditModel" size="210,72">
+      <children xsi:type="editmodel:MethodEditModel" name="processElementValue" id="org.apache.lucene.gdata.gom.core/AtomParser#processElementValue(Ljava.lang.String;)"/>
+      <children xsi:type="editmodel:MethodEditModel" name="processAttribute" id="org.apache.lucene.gdata.gom.core/AtomParser#processAttribute(Ljavax.xml.namespace.QName;Ljava.lang.String;)"/>
+      <children xsi:type="editmodel:MethodEditModel" name="processEndElement" id="org.apache.lucene.gdata.gom.core/AtomParser#processEndElement()"/>
+      <children xsi:type="editmodel:MethodEditModel" name="getChildParser" id="org.apache.lucene.gdata.gom.core/AtomParser#getChildParser(Ljavax.xml.namespace.QName;)"/>
+    </children>
+    <children xsi:type="editmodel:CompartmentEditModel"/>
+    <sourceConnections xsi:type="editmodel:AssociationEditModel" autoLocated="true" id="org.apache.lucene.gdata.gom.core/AtomParser@parserStack+org.apache.lucene.gdata.gom.core/GOMBuilder@" source="//@children.3" target="//@children.5" targetEnd="//@children.3/@sourceConnections.0/@children.2" label="//@children.3/@sourceConnections.0/@children.0" sourceEnd="//@children.3/@sourceConnections.0/@children.1" connectionRouterKind="Manhattan">
+      <children xsi:type="editmodel:WireLabelEditModel" size="0,10" fontInfo="Arial-8-0" anchorKind="MiddlePart"/>
+      <children xsi:type="editmodel:AssociationEndEditModel" name="parserStack" location="233,259" id="org.apache.lucene.gdata.gom.core/AtomParser@parserStack+org.apache.lucene.gdata.gom.core/GOMBuilder@|org.apache.lucene.gdata.gom.core/AtomParser#parserStack" attachSource="true" multiplicityLabel="//@children.3/@sourceConnections.0/@children.1/@children.1" roleLabel="//@children.3/@sourceConnections.0/@children.1/@children.0" navigable="true">
+        <children xsi:type="editmodel:LabelEditModel" name=" - parserStack" location="1291,291" size="47,10" fontInfo="Arial-8-0" anchorKind="FirstPart"/>
+        <children xsi:type="editmodel:LabelEditModel" name="*" location="1291,315" size="3,10" fontInfo="Arial-8-0" anchorKind="FirstPart"/>
+      </children>
+      <children xsi:type="editmodel:AssociationEndEditModel" location="10,0" id="org.apache.lucene.gdata.gom.core/AtomParser@parserStack+org.apache.lucene.gdata.gom.core/GOMBuilder@|org.apache.lucene.gdata.gom.core/GOMBuilder#" roleLabel="//@children.3/@sourceConnections.0/@children.2/@children.0">
+        <children xsi:type="editmodel:LabelEditModel" location="1391,481" size="0,10" fontInfo="Arial-8-0" anchorKind="LastPart"/>
+      </children>
+    </sourceConnections>
+    <classifierPreferences xsi:type="editmodel:UMLClassDiagramClassifierPreference" showStereotype="true" showMethodsParameterTypes="true" showMethodsReturnType="true" showMethodsParameterNames="true" showMethodsParameterKinds="true" attributeSorter="Natural" methodSorter="Natural" innerClassSorter="Natural" showPrivateAttributes="true" showProtectedAttributes="true" showPublicAttributes="true" showPackageAttributes="true" showStaticAttributes="true" showProtectedMethods="true" showPublicMethods="true" showPackageMethods="true" showPrivateMethods="true" showStaticMethods="true" showProtectedInnerClasses="true" showPublicInnerClasses="true" showPackageInnerClasses="true" showPrivateInnerClasses="true" showStaticInnerClasses="true" showAssociationMember="true" showMethods="true" showAttributes="true" showLiterals="true"/>
+  </children>
+  <children xsi:type="editmodel:ClassEditModel" targetConnections="//@children.5/@sourceConnections.3 //@children.5/@sourceConnections.6 //@children.5/@sourceConnections.8" name="GOMDocumentImpl" location="1623,994" size="227,295" id="org.apache.lucene.gdata.gom.core/GOMDocumentImpl" runTimeClassModel="setCharacterEncoding(Ljava.lang.String;),charEncoding,GOMDocumentImpl(),setVersion(Ljava.lang.String;),getCharacterEncoding(),writeRssOutput(Ljavax.xml.stream.XMLStreamWriter;),root,getRootElement(),getVersion(),writeAtomOutput(Ljavax.xml.stream.XMLStreamWriter;),setRootElement,version">
+    <children xsi:type="editmodel:CompartmentEditModel" size="91,54">
+      <children xsi:type="editmodel:AttributeEditModel" name="root" id="org.apache.lucene.gdata.gom.core/GOMDocumentImpl#root"/>
+      <children xsi:type="editmodel:AttributeEditModel" name="version" id="org.apache.lucene.gdata.gom.core/GOMDocumentImpl#version"/>
+      <children xsi:type="editmodel:AttributeEditModel" name="charEncoding" id="org.apache.lucene.gdata.gom.core/GOMDocumentImpl#charEncoding"/>
+    </children>
+    <children xsi:type="editmodel:CompartmentEditModel" size="204,162">
+      <children xsi:type="editmodel:MethodEditModel" name="GOMDocumentImpl" id="org.apache.lucene.gdata.gom.core/GOMDocumentImpl#GOMDocumentImpl()"/>
+      <children xsi:type="editmodel:MethodEditModel" name="getRootElement" id="org.apache.lucene.gdata.gom.core/GOMDocumentImpl#getRootElement()"/>
+      <children xsi:type="editmodel:MethodEditModel" name="setVersion" id="org.apache.lucene.gdata.gom.core/GOMDocumentImpl#setVersion(Ljava.lang.String;)"/>
+      <children xsi:type="editmodel:MethodEditModel" name="getVersion" id="org.apache.lucene.gdata.gom.core/GOMDocumentImpl#getVersion()"/>
+      <children xsi:type="editmodel:MethodEditModel" name="getCharacterEncoding" id="org.apache.lucene.gdata.gom.core/GOMDocumentImpl#getCharacterEncoding()"/>
+      <children xsi:type="editmodel:MethodEditModel" name="setCharacterEncoding" id="org.apache.lucene.gdata.gom.core/GOMDocumentImpl#setCharacterEncoding(Ljava.lang.String;)"/>
+      <children xsi:type="editmodel:MethodEditModel" name="writeAtomOutput" id="org.apache.lucene.gdata.gom.core/GOMDocumentImpl#writeAtomOutput(Ljavax.xml.stream.XMLStreamWriter;)"/>
+      <children xsi:type="editmodel:MethodEditModel" name="setRootElement" id="org.apache.lucene.gdata.gom.core/GOMDocumentImpl#setRootElement"/>
+      <children xsi:type="editmodel:MethodEditModel" name="writeRssOutput" id="org.apache.lucene.gdata.gom.core/GOMDocumentImpl#writeRssOutput(Ljavax.xml.stream.XMLStreamWriter;)"/>
+    </children>
+    <children xsi:type="editmodel:CompartmentEditModel"/>
+    <classifierPreferences xsi:type="editmodel:UMLClassDiagramClassifierPreference" showStereotype="true" showMethodsParameterTypes="true" showMethodsReturnType="true" showMethodsParameterNames="true" showMethodsParameterKinds="true" attributeSorter="Natural" methodSorter="Natural" innerClassSorter="Natural" showPrivateAttributes="true" showProtectedAttributes="true" showPublicAttributes="true" showPackageAttributes="true" showStaticAttributes="true" showProtectedMethods="true" showPublicMethods="true" showPackageMethods="true" showPrivateMethods="true" showStaticMethods="true" showProtectedInnerClasses="true" showPublicInnerClasses="true" showPackageInnerClasses="true" showPrivateInnerClasses="true" showStaticInnerClasses="true" showAssociationMember="true" showMethods="true" showAttributes="true" showLiterals="true"/>
+  </children>
+  <children xsi:type="editmodel:ClassEditModel" targetConnections="//@children.3/@sourceConnections.0" name="GOMBuilder" location="1388,498" size="259,295" id="org.apache.lucene.gdata.gom.core/GOMBuilder" runTimeClassModel="parserStack,next(),processAttributes(Lorg.apache.lucene.gdata.gom.core.AtomParser;),buildGOMEntry(),lastLocalName,streamReader,parse(Ljavax.xml.stream.XMLStreamReader;),buildGOMFeed(),GOMBuilder(Ljavax.xml.stream.XMLStreamReader;),startFeedDocument(Lorg.apache.lucene.gdata.gom.GOMDocument;),factory">
+    <children xsi:type="editmodel:CompartmentEditModel" size="136,54">
+      <children xsi:type="editmodel:AttributeEditModel" name="streamReader" id="org.apache.lucene.gdata.gom.core/GOMBuilder#streamReader"/>
+      <children xsi:type="editmodel:AttributeEditModel" name="factory" id="org.apache.lucene.gdata.gom.core/GOMBuilder#factory"/>
+      <children xsi:type="editmodel:AttributeEditModel" name="lastLocalName" id="org.apache.lucene.gdata.gom.core/GOMBuilder#lastLocalName"/>
+      <children xsi:type="editmodel:AttributeEditModel" name="parserStack" id="org.apache.lucene.gdata.gom.core/AtomParser@parserStack+org.apache.lucene.gdata.gom.core/GOMBuilder@|org.apache.lucene.gdata.gom.core/AtomParser#parserStack"/>
+    </children>
+    <children xsi:type="editmodel:CompartmentEditModel" size="236,126">
+      <children xsi:type="editmodel:MethodEditModel" name="GOMBuilder" id="org.apache.lucene.gdata.gom.core/GOMBuilder#GOMBuilder(Ljavax.xml.stream.XMLStreamReader;)"/>
+      <children xsi:type="editmodel:MethodEditModel" name="buildGOMFeed" id="org.apache.lucene.gdata.gom.core/GOMBuilder#buildGOMFeed()"/>
+      <children xsi:type="editmodel:MethodEditModel" name="parse" id="org.apache.lucene.gdata.gom.core/GOMBuilder#parse(Ljavax.xml.stream.XMLStreamReader;)"/>
+      <children xsi:type="editmodel:MethodEditModel" name="processAttributes" id="org.apache.lucene.gdata.gom.core/GOMBuilder#processAttributes(Lorg.apache.lucene.gdata.gom.core.AtomParser;)"/>
+      <children xsi:type="editmodel:MethodEditModel" name="buildGOMEntry" id="org.apache.lucene.gdata.gom.core/GOMBuilder#buildGOMEntry()"/>
+      <children xsi:type="editmodel:MethodEditModel" name="startFeedDocument" id="org.apache.lucene.gdata.gom.core/GOMBuilder#startFeedDocument(Lorg.apache.lucene.gdata.gom.GOMDocument;)"/>
+      <children xsi:type="editmodel:MethodEditModel" name="next" id="org.apache.lucene.gdata.gom.core/GOMBuilder#next()"/>
+    </children>
+    <children xsi:type="editmodel:CompartmentEditModel"/>
+    <sourceConnections xsi:type="editmodel:DependencyEditModel" id="org.apache.lucene.gdata.gom.core/GOMBuilder->org.apache.lucene.gdata.gom.core/AtomParser" source="//@children.5" target="//@children.3" targetEnd="//@children.5/@sourceConnections.0/@children.2" label="//@children.5/@sourceConnections.0/@children.0" sourceEnd="//@children.5/@sourceConnections.0/@children.1" connectionRouterKind="Manhattan">
+      <children xsi:type="editmodel:WireLabelEditModel" name="import" size="29,10" fontInfo="Arial-8-0" anchorKind="MiddlePart"/>
+      <children xsi:type="editmodel:AssociationEndEditModel" location="0,20" attachSource="true"/>
+      <children xsi:type="editmodel:AssociationEndEditModel" location="213,269"/>
+    </sourceConnections>
+    <sourceConnections xsi:type="editmodel:DependencyEditModel" id="org.apache.lucene.gdata.gom.core/GOMBuilder->org.apache.lucene.gdata.gom.core/GOMNamespace" source="//@children.5" target="//@children.6" targetEnd="//@children.5/@sourceConnections.1/@children.2" label="//@children.5/@sourceConnections.1/@children.0" sourceEnd="//@children.5/@sourceConnections.1/@children.1" connectionRouterKind="Manhattan">
+      <children xsi:type="editmodel:WireLabelEditModel" size="0,10" fontInfo="Arial-8-0" anchorKind="MiddlePart"/>
+      <children xsi:type="editmodel:AssociationEndEditModel" location="0,236" attachSource="true"/>
+      <children xsi:type="editmodel:AssociationEndEditModel" location="135,58"/>
+    </sourceConnections>
+    <sourceConnections xsi:type="editmodel:DependencyEditModel" autoLocated="true" id="org.apache.lucene.gdata.gom.core/GOMBuilder->org.apache.lucene.gdata.gom.core/GOMFactory" source="//@children.5" target="//@children.2" targetEnd="//@children.5/@sourceConnections.2/@children.2" label="//@children.5/@sourceConnections.2/@children.0" sourceEnd="//@children.5/@sourceConnections.2/@children.1" connectionRouterKind="Manhattan">
+      <children xsi:type="editmodel:WireLabelEditModel" name="access" size="32,10" fontInfo="Arial-8-0" anchorKind="MiddlePart"/>
+      <children xsi:type="editmodel:AssociationEndEditModel" location="249,0" attachSource="true"/>
+      <children xsi:type="editmodel:AssociationEndEditModel" location="0,123"/>
+    </sourceConnections>
+    <sourceConnections xsi:type="editmodel:DependencyEditModel" id="org.apache.lucene.gdata.gom.core/GOMBuilder->org.apache.lucene.gdata.gom.core/GOMDocumentImpl" source="//@children.5" target="//@children.4" targetEnd="//@children.5/@sourceConnections.3/@children.2" label="//@children.5/@sourceConnections.3/@children.0" sourceEnd="//@children.5/@sourceConnections.3/@children.1" connectionRouterKind="Manhattan">
+      <children xsi:type="editmodel:WireLabelEditModel" size="0,10" fontInfo="Arial-8-0" anchorKind="MiddlePart"/>
+      <children xsi:type="editmodel:AssociationEndEditModel" location="256,295" attachSource="true"/>
+      <children xsi:type="editmodel:AssociationEndEditModel" location="21,0"/>
+    </sourceConnections>
+    <sourceConnections xsi:type="editmodel:DependencyEditModel" id="org.apache.lucene.gdata.gom.core/GOMBuilder->org.apache.lucene.gdata.gom.core/GOMFactory" source="//@children.5" target="//@children.2" targetEnd="//@children.5/@sourceConnections.4/@children.2" label="//@children.5/@sourceConnections.4/@children.0" sourceEnd="//@children.5/@sourceConnections.4/@children.1" connectionRouterKind="Manhattan">
+      <children xsi:type="editmodel:WireLabelEditModel" name="import" size="29,10" fontInfo="Arial-8-0" anchorKind="MiddlePart"/>
+      <children xsi:type="editmodel:AssociationEndEditModel" location="258,0" attachSource="true"/>
+      <children xsi:type="editmodel:AssociationEndEditModel" location="10,143"/>
+    </sourceConnections>
+    <sourceConnections xsi:type="editmodel:DependencyEditModel" id="org.apache.lucene.gdata.gom.core/GOMBuilder->org.apache.lucene.gdata.gom.core/GOMNamespace" source="//@children.5" target="//@children.6" targetEnd="//@children.5/@sourceConnections.5/@children.2" label="//@children.5/@sourceConnections.5/@children.0" sourceEnd="//@children.5/@sourceConnections.5/@children.1" connectionRouterKind="Manhattan">
+      <children xsi:type="editmodel:WireLabelEditModel" name="import" size="29,10" fontInfo="Arial-8-0" anchorKind="MiddlePart"/>
+      <children xsi:type="editmodel:AssociationEndEditModel" location="0,216" attachSource="true"/>
+      <children xsi:type="editmodel:AssociationEndEditModel" location="135,78"/>
+    </sourceConnections>
+    <sourceConnections xsi:type="editmodel:DependencyEditModel" id="org.apache.lucene.gdata.gom.core/GOMBuilder->org.apache.lucene.gdata.gom.core/GOMDocumentImpl" source="//@children.5" target="//@children.4" targetEnd="//@children.5/@sourceConnections.6/@children.2" label="//@children.5/@sourceConnections.6/@children.0" sourceEnd="//@children.5/@sourceConnections.6/@children.1" connectionRouterKind="Manhattan">
+      <children xsi:type="editmodel:WireLabelEditModel" size="0,10" fontInfo="Arial-8-0" anchorKind="MiddlePart"/>
+      <children xsi:type="editmodel:AssociationEndEditModel" location="236,295" attachSource="true"/>
+      <children xsi:type="editmodel:AssociationEndEditModel" location="1,0"/>
+    </sourceConnections>
+    <sourceConnections xsi:type="editmodel:DependencyEditModel" autoLocated="true" id="org.apache.lucene.gdata.gom.core/GOMBuilder->org.apache.lucene.gdata.gom.core/GOMNamespace" source="//@children.5" target="//@children.6" targetEnd="//@children.5/@sourceConnections.7/@children.2" label="//@children.5/@sourceConnections.7/@children.0" sourceEnd="//@children.5/@sourceConnections.7/@children.1" connectionRouterKind="Manhattan">
+      <children xsi:type="editmodel:WireLabelEditModel" size="0,10" fontInfo="Arial-8-0" anchorKind="MiddlePart"/>
+      <children xsi:type="editmodel:AssociationEndEditModel" location="0,268" attachSource="true"/>
+      <children xsi:type="editmodel:AssociationEndEditModel" location="135,26"/>
+    </sourceConnections>
+    <sourceConnections xsi:type="editmodel:DependencyEditModel" autoLocated="true" id="org.apache.lucene.gdata.gom.core/GOMBuilder->org.apache.lucene.gdata.gom.core/GOMDocumentImpl" source="//@children.5" target="//@children.4" targetEnd="//@children.5/@sourceConnections.8/@children.2" label="//@children.5/@sourceConnections.8/@children.0" sourceEnd="//@children.5/@sourceConnections.8/@children.1" connectionRouterKind="Manhattan">
+      <children xsi:type="editmodel:WireLabelEditModel" size="0,10" fontInfo="Arial-8-0" anchorKind="MiddlePart"/>
+      <children xsi:type="editmodel:AssociationEndEditModel" location="246,295" attachSource="true"/>
+      <children xsi:type="editmodel:AssociationEndEditModel" location="11,0"/>
+    </sourceConnections>
+    <sourceConnections xsi:type="editmodel:DependencyEditModel" id="org.apache.lucene.gdata.gom.core/GOMBuilder->org.apache.lucene.gdata.gom.core/GOMNamespace" source="//@children.5" target="//@children.6" targetEnd="//@children.5/@sourceConnections.9/@children.2" label="//@children.5/@sourceConnections.9/@children.0" sourceEnd="//@children.5/@sourceConnections.9/@children.1" connectionRouterKind="Manhattan">
+      <children xsi:type="editmodel:WireLabelEditModel" size="0,10" fontInfo="Arial-8-0" anchorKind="MiddlePart"/>
+      <children xsi:type="editmodel:AssociationEndEditModel" location="0,246" attachSource="true"/>
+      <children xsi:type="editmodel:AssociationEndEditModel" location="135,48"/>
+    </sourceConnections>
+    <classifierPreferences xsi:type="editmodel:UMLClassDiagramClassifierPreference" showStereotype="true" showMethodsParameterTypes="true" showMethodsReturnType="true" showMethodsParameterNames="true" showMethodsParameterKinds="true" attributeSorter="Natural" methodSorter="Natural" innerClassSorter="Natural" showPrivateAttributes="true" showProtectedAttributes="true" showPublicAttributes="true" showPackageAttributes="true" showStaticAttributes="true" showProtectedMethods="true" showPublicMethods="true" showPackageMethods="true" showPrivateMethods="true" showStaticMethods="true" showProtectedInnerClasses="true" showPublicInnerClasses="true" showPackageInnerClasses="true" showPrivateInnerClasses="true" showStaticInnerClasses="true" showAssociationMember="true" showMethods="true" showAttributes="true" showLiterals="true"/>
+  </children>
+  <children xsi:type="editmodel:ClassEditModel" targetConnections="//@children.5/@sourceConnections.1 //@children.5/@sourceConnections.5 //@children.1/@sourceConnections.1 //@children.5/@sourceConnections.7 //@children.5/@sourceConnections.9" name="GOMNamespace" location="590,740" size="135,205" id="org.apache.lucene.gdata.gom.core/GOMNamespace" runTimeClassModel="setUri(Ljava.lang.String;),GOMNamespace(),getUri(),getPrefix(),uri,prefix,setPrefix(Ljava.lang.String;)">
+    <children xsi:type="editmodel:CompartmentEditModel" size="62,36">
+      <children xsi:type="editmodel:AttributeEditModel" name="prefix" id="org.apache.lucene.gdata.gom.core/GOMNamespace#prefix"/>
+      <children xsi:type="editmodel:AttributeEditModel" name="uri" id="org.apache.lucene.gdata.gom.core/GOMNamespace#uri"/>
+    </children>
+    <children xsi:type="editmodel:CompartmentEditModel" size="112,90">
+      <children xsi:type="editmodel:MethodEditModel" name="GOMNamespace" id="org.apache.lucene.gdata.gom.core/GOMNamespace#GOMNamespace()"/>
+      <children xsi:type="editmodel:MethodEditModel" name="getPrefix" id="org.apache.lucene.gdata.gom.core/GOMNamespace#getPrefix()"/>
+      <children xsi:type="editmodel:MethodEditModel" name="setPrefix" id="org.apache.lucene.gdata.gom.core/GOMNamespace#setPrefix(Ljava.lang.String;)"/>
+      <children xsi:type="editmodel:MethodEditModel" name="getUri" id="org.apache.lucene.gdata.gom.core/GOMNamespace#getUri()"/>
+      <children xsi:type="editmodel:MethodEditModel" name="setUri" id="org.apache.lucene.gdata.gom.core/GOMNamespace#setUri(Ljava.lang.String;)"/>
+    </children>
+    <children xsi:type="editmodel:CompartmentEditModel"/>
+    <sourceConnections xsi:type="editmodel:AssociationEditModel" id="org.apache.lucene.gdata.gom.core/GOMNamespace@namespaces+org.apache.lucene.gdata.gom.core/GOMFeedImpl@" source="//@children.6" target="//@children.1" targetEnd="//@children.6/@sourceConnections.0/@children.2" label="//@children.6/@sourceConnections.0/@children.0" sourceEnd="//@children.6/@sourceConnections.0/@children.1" connectionRouterKind="Manhattan">
+      <children xsi:type="editmodel:WireLabelEditModel" size="0,10" fontInfo="Arial-8-0" anchorKind="MiddlePart"/>
+      <children xsi:type="editmodel:AssociationEndEditModel" name="namespaces" location="0,112" id="org.apache.lucene.gdata.gom.core/GOMNamespace@namespaces+org.apache.lucene.gdata.gom.core/GOMFeedImpl@|org.apache.lucene.gdata.gom.core/GOMNamespace#namespaces" attachSource="true" multiplicityLabel="//@children.6/@sourceConnections.0/@children.1/@children.1" roleLabel="//@children.6/@sourceConnections.0/@children.1/@children.0" navigable="true">
+        <children xsi:type="editmodel:LabelEditModel" name=" - namespaces" location="534,859" size="49,10" fontInfo="Arial-8-0" anchorKind="FirstPart"/>
+        <children xsi:type="editmodel:LabelEditModel" name="*" location="580,835" size="3,10" fontInfo="Arial-8-0" anchorKind="FirstPart"/>
+      </children>
+      <children xsi:type="editmodel:AssociationEndEditModel" location="233,532" id="org.apache.lucene.gdata.gom.core/GOMNamespace@namespaces+org.apache.lucene.gdata.gom.core/GOMFeedImpl@|org.apache.lucene.gdata.gom.core/GOMFeedImpl#"/>
+    </sourceConnections>
+    <classifierPreferences xsi:type="editmodel:UMLClassDiagramClassifierPreference" showStereotype="true" showMethodsParameterTypes="true" showMethodsReturnType="true" showMethodsParameterNames="true" showMethodsParameterKinds="true" attributeSorter="Natural" methodSorter="Natural" innerClassSorter="Natural" showPrivateAttributes="true" showProtectedAttributes="true" showPublicAttributes="true" showPackageAttributes="true" showStaticAttributes="true" showProtectedMethods="true" showPublicMethods="true" showPackageMethods="true" showPrivateMethods="true" showStaticMethods="true" showProtectedInnerClasses="true" showPublicInnerClasses="true" showPackageInnerClasses="true" showPrivateInnerClasses="true" showStaticInnerClasses="true" showAssociationMember="true" showMethods="true" showAttributes="true" showLiterals="true"/>
+  </children>
+  <children xsi:type="editmodel:ClassEditModel" targetConnections="//@children.1/@sourceConnections.2 //@children.1/@sourceConnections.3" name="GOMAttributeImpl" location="640,-20" size="173,205" id="org.apache.lucene.gdata.gom.core/GOMAttributeImpl" runTimeClassModel="GOMAttributeImpl(),setLocalName(Ljava.lang.String;),setTextValue(Ljava.lang.String;),setQName(Ljavax.xml.namespace.QName;),getQname(),getTextValue(),getLocalName()">
+    <children xsi:type="editmodel:CompartmentEditModel"/>
+    <children xsi:type="editmodel:CompartmentEditModel" size="150,126">
+      <children xsi:type="editmodel:MethodEditModel" name="GOMAttributeImpl" id="org.apache.lucene.gdata.gom.core/GOMAttributeImpl#GOMAttributeImpl()"/>
+      <children xsi:type="editmodel:MethodEditModel" name="getQname" id="org.apache.lucene.gdata.gom.core/GOMAttributeImpl#getQname()"/>
+      <children xsi:type="editmodel:MethodEditModel" name="setQName" id="org.apache.lucene.gdata.gom.core/GOMAttributeImpl#setQName(Ljavax.xml.namespace.QName;)"/>
+      <children xsi:type="editmodel:MethodEditModel" name="setLocalName" id="org.apache.lucene.gdata.gom.core/GOMAttributeImpl#setLocalName(Ljava.lang.String;)"/>
+      <children xsi:type="editmodel:MethodEditModel" name="getLocalName" id="org.apache.lucene.gdata.gom.core/GOMAttributeImpl#getLocalName()"/>
+      <children xsi:type="editmodel:MethodEditModel" name="getTextValue" id="org.apache.lucene.gdata.gom.core/GOMAttributeImpl#getTextValue()"/>
+      <children xsi:type="editmodel:MethodEditModel" name="setTextValue" id="org.apache.lucene.gdata.gom.core/GOMAttributeImpl#setTextValue(Ljava.lang.String;)"/>
+    </children>
+    <children xsi:type="editmodel:CompartmentEditModel"/>
+    <classifierPreferences xsi:type="editmodel:UMLClassDiagramClassifierPreference" showStereotype="true" showMethodsParameterTypes="true" showMethodsReturnType="true" showMethodsParameterNames="true" showMethodsParameterKinds="true" attributeSorter="Natural" methodSorter="Natural" innerClassSorter="Natural" showPrivateAttributes="true" showProtectedAttributes="true" showPublicAttributes="true" showPackageAttributes="true" showStaticAttributes="true" showProtectedMethods="true" showPublicMethods="true" showPackageMethods="true" showPrivateMethods="true" showStaticMethods="true" showProtectedInnerClasses="true" showPublicInnerClasses="true" showPackageInnerClasses="true" showPrivateInnerClasses="true" showStaticInnerClasses="true" showAssociationMember="true" showMethods="true" showAttributes="true" showLiterals="true"/>
+  </children>
+  <diagramOptions xsi:type="options:ClassDiagramOptions" properties="wireOptions=0"/>
+  <boardSetting snapToGeometry="true" gridEnabled="true" gridSpacing="10,10" gridOrigin="0,0" rulerUnit="pixel">
+    <leftRuler/>
+    <topRuler/>
+  </boardSetting>
+  <classDiagramPreferences xsi:type="editmodel:UMLClassDiagramPreference" showMethodsParameterTypes="true" showMethodsReturnType="true" showMethodsParameterNames="true" showMethodsParameterKinds="true" attributeSorter="Natural" methodSorter="Natural" showClassStereotype="true" showPackageStereotype="true" innerClassSorter="Natural" showPrivateAttributes="true" showProtectedAttributes="true" showPublicAttributes="true" showPackageAttributes="true" showStaticAttributes="true" showProtectedMethods="true" showPublicMethods="true" showPackageMethods="true" showPrivateMethods="true" showStaticMethods="true" showProtectedInnerClasses="true" showPublicInnerClasses="true" showPackageInnerClasses="true" showPrivateInnerClasses="true" showStaticInnerClasses="true" packageIndication="2" showInterfaceStereotype="true" showAssociationMember="true" showMethods="true" showAttributes="true" showLiterlas="true"/>
+</editmodel:ClassDiagramEditModel>
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/core-aid.uml b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/core-aid.uml
new file mode 100644
index 0000000..7bce9e6
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/core-aid.uml
@@ -0,0 +1,968 @@
+<?xml version="1.0" encoding="ASCII"?>
+<uml:Model xmi:version="2.1" xmlns:xmi="http://schema.omg.org/spec/XMI/2.1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:uml="http://www.eclipse.org/uml2/2.0.0/UML" xmi:id="_B7TvIH5gEdujQd6ed5A7Ug" name="core">
+  <packagedElement xmi:type="uml:Interface" xmi:id="_r7Q00H5eEdujQd6ed5A7Ug" name="AtomParser" clientDependency="_r7sSoH5eEdujQd6ed5A7Ug _r7uu4X5eEdujQd6ed5A7Ug">
+    <ownedAttribute xmi:id="_r7dCEH5eEdujQd6ed5A7Ug" name="uNEXPECTED_ELEMENENT_VALUE" visibility="public" isLeaf="true" isStatic="true" type="_r7dpIX5eEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_r7lk8H5eEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_r7k94X5eEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedAttribute xmi:id="_r7eQMH5eEdujQd6ed5A7Ug" name="uNEXPECTED_ATTRIBUTE" visibility="public" isLeaf="true" isStatic="true" type="_r7dpIX5eEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_r7pPUX5eEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_r7pPUH5eEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedAttribute xmi:id="_r7e3QH5eEdujQd6ed5A7Ug" name="uNEXPECTED_ELEMENENT_CHILD" visibility="public" isLeaf="true" isStatic="true" type="_r7dpIX5eEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_r7p2YH5eEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_r7pPUn5eEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedAttribute xmi:id="_r7e3QX5eEdujQd6ed5A7Ug" name="uNEXPECTED_ELEMENENT" visibility="public" isLeaf="true" isStatic="true" type="_r7dpIX5eEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_r7p2Yn5eEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_r7p2YX5eEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedAttribute xmi:id="_r7feUH5eEdujQd6ed5A7Ug" name="mISSING_ELEMEMENT_CHILD" visibility="public" isLeaf="true" isStatic="true" type="_r7dpIX5eEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_r7qdcH5eEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_r7p2Y35eEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedAttribute xmi:id="_r7gFYH5eEdujQd6ed5A7Ug" name="mISSING_ELEMEMENT_ATTRIBUTE" visibility="public" isLeaf="true" isStatic="true" type="_r7dpIX5eEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_r7qdcn5eEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_r7qdcX5eEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedOperation xmi:id="_r7gscH5eEdujQd6ed5A7Ug" name="processAttribute" visibility="public" isAbstract="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_-KrWIH5fEdujQd6ed5A7Ug" name="aQName" type="_r7h6kH5eEdujQd6ed5A7Ug"/>
+      <ownedParameter xmi:id="_-KrWIX5fEdujQd6ed5A7Ug" name="aValue" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_r7jIsH5eEdujQd6ed5A7Ug" name="getChildParser" visibility="public" isAbstract="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_-Kr9MH5fEdujQd6ed5A7Ug" name="name" type="_r7h6kH5eEdujQd6ed5A7Ug"/>
+      <ownedParameter xmi:id="_-KskQH5fEdujQd6ed5A7Ug" type="_r7Q00H5eEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_r7jvwX5eEdujQd6ed5A7Ug" name="processEndElement" visibility="public" isAbstract="true" concurrency="concurrent"/>
+    <ownedOperation xmi:id="_r7kW0H5eEdujQd6ed5A7Ug" name="processElementValue" visibility="public" isAbstract="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_-KtLUH5fEdujQd6ed5A7Ug" name="aValue" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Class" xmi:id="_r7h6kH5eEdujQd6ed5A7Ug" name="QName"/>
+  <packagedElement xmi:type="uml:Class" xmi:id="_r8CQ4H5eEdujQd6ed5A7Ug" name="GOMNamespace" clientDependency="_r8qjAH5eEdujQd6ed5A7Ug">
+    <ownedAttribute xmi:id="_r8kcYH5eEdujQd6ed5A7Ug" name="uri" visibility="private" type="_r7dpIX5eEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_r8ot0X5eEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_r8ot0H5eEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedAttribute xmi:id="_r8lDcH5eEdujQd6ed5A7Ug" name="prefix" visibility="private" type="_r7dpIX5eEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_r8pU4X5eEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_r8pU4H5eEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedOperation xmi:id="_r8lqgH5eEdujQd6ed5A7Ug" name="setUri" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_r8mRkH5eEdujQd6ed5A7Ug" name="aUri" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_r8mRkX5eEdujQd6ed5A7Ug" name="getPrefix" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_r8m4oH5eEdujQd6ed5A7Ug" type="_r7dpIX5eEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_r8m4oX5eEdujQd6ed5A7Ug" name="setPrefix" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_r8nfsH5eEdujQd6ed5A7Ug" name="aPrefix" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_r8nfsX5eEdujQd6ed5A7Ug" name="getUri" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_r8oGwH5eEdujQd6ed5A7Ug" type="_r7dpIX5eEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_r8oGwX5eEdujQd6ed5A7Ug" name="GOMNamespace" visibility="public" concurrency="concurrent"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Class" xmi:id="_r8824H5eEdujQd6ed5A7Ug" name="GDataParseException" clientDependency="_r9GA0H5eEdujQd6ed5A7Ug _r9IdEn5eEdujQd6ed5A7Ug">
+    <generalization xmi:id="_r8-FAH5eEdujQd6ed5A7Ug" general="_r89d8H5eEdujQd6ed5A7Ug"/>
+    <ownedOperation xmi:id="_r9AhQH5eEdujQd6ed5A7Ug" name="GDataParseException" visibility="public" concurrency="concurrent"/>
+    <ownedOperation xmi:id="_r9BIUH5eEdujQd6ed5A7Ug" name="GDataParseException" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_r9CWcH5eEdujQd6ed5A7Ug" name="arg0" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_r9CWcX5eEdujQd6ed5A7Ug" name="GDataParseException" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_r9C9gH5eEdujQd6ed5A7Ug" name="arg0" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
+      <ownedParameter xmi:id="_r9ELoX5eEdujQd6ed5A7Ug" name="arg1" type="_r9ELoH5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_r9EysH5eEdujQd6ed5A7Ug" name="GDataParseException" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_r9EysX5eEdujQd6ed5A7Ug" name="arg0" type="_r9ELoH5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Class" xmi:id="_r9WfgH5eEdujQd6ed5A7Ug" name="GOMAttributeImpl" clientDependency="_r9lJAH5eEdujQd6ed5A7Ug _r9nlQn5eEdujQd6ed5A7Ug">
+    <generalization xmi:id="_r9YUsH5eEdujQd6ed5A7Ug" general="_r9XtoH5eEdujQd6ed5A7Ug"/>
+    <ownedOperation xmi:id="_r9fCYH5eEdujQd6ed5A7Ug" name="setQName" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_r9fpcH5eEdujQd6ed5A7Ug" name="aQname" type="_r7h6kH5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_r9fpcX5eEdujQd6ed5A7Ug" name="getTextValue" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_r9gQgH5eEdujQd6ed5A7Ug" type="_r7dpIX5eEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_r9gQgX5eEdujQd6ed5A7Ug" name="setTextValue" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_r9g3kH5eEdujQd6ed5A7Ug" name="aTextValue" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_r9g3kX5eEdujQd6ed5A7Ug" name="setLocalName" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_r9heoH5eEdujQd6ed5A7Ug" name="aLocalName" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_r9iFsH5eEdujQd6ed5A7Ug" name="getLocalName" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_r9iFsX5eEdujQd6ed5A7Ug" type="_r7dpIX5eEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_r9iswH5eEdujQd6ed5A7Ug" name="GOMAttributeImpl" visibility="public" concurrency="concurrent"/>
+    <ownedOperation xmi:id="_r9iswX5eEdujQd6ed5A7Ug" name="getQname" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_r9j64H5eEdujQd6ed5A7Ug" type="_r7h6kH5eEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Interface" xmi:id="_r9XtoH5eEdujQd6ed5A7Ug" name="GOMAttribute">
+    <generalization xmi:id="_sHItoH5eEdujQd6ed5A7Ug" general="_sHIGkH5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Class" xmi:id="_r-JwwH5eEdujQd6ed5A7Ug" name="GOMFactory" clientDependency="_r-RskH5eEdujQd6ed5A7Ug _r-Thwn5eEdujQd6ed5A7Ug">
+    <ownedOperation xmi:id="_r-OpQH5eEdujQd6ed5A7Ug" name="GOMFactory" visibility="private" concurrency="concurrent"/>
+    <ownedOperation xmi:id="_r-OpQX5eEdujQd6ed5A7Ug" name="createInstance" visibility="public" isStatic="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_r-PQUH5eEdujQd6ed5A7Ug" type="_r-JwwH5eEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_r-PQUX5eEdujQd6ed5A7Ug" name="createFeed" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_r-QecH5eEdujQd6ed5A7Ug" type="_r-P3YH5eEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Interface" xmi:id="_r-P3YH5eEdujQd6ed5A7Ug" name="GOMFeed" clientDependency="_ibYkkH5fEdujQd6ed5A7Ug _ibaZwn5fEdujQd6ed5A7Ug _ibc2AH5fEdujQd6ed5A7Ug _iberMn5fEdujQd6ed5A7Ug _ibggYn5fEdujQd6ed5A7Ug _ibi8oX5fEdujQd6ed5A7Ug _ibkx0n5fEdujQd6ed5A7Ug _ibmnAn5fEdujQd6ed5A7Ug _ibpDQH5fEdujQd6ed5A7Ug _ibq4cn5fEdujQd6ed5A7Ug _ibston5fEdujQd6ed5A7Ug _ibui0n5fEdujQd6ed5A7Ug _ibw_EX5fEdujQd6ed5A7Ug _iby0Qn5fEdujQd6ed5A7Ug _ib13kH5fEdujQd6ed5A7Ug">
+    <generalization xmi:id="_iaGyMH5fEdujQd6ed5A7Ug" general="_sHIGkH5eEdujQd6ed5A7Ug"/>
+    <generalization xmi:id="_iaIAUH5fEdujQd6ed5A7Ug" general="_r-kngH5eEdujQd6ed5A7Ug"/>
+    <ownedAttribute xmi:id="_ia3AIH5fEdujQd6ed5A7Ug" name="oPENSEARCH_NS_PREFIX" visibility="public" isLeaf="true" isStatic="true" type="_r7dpIX5eEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_ibR24X5fEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_ibR24H5fEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedAttribute xmi:id="_ia3AIX5fEdujQd6ed5A7Ug" name="lOCALNAME_RSS" visibility="public" isLeaf="true" isStatic="true" type="_r7dpIX5eEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_ibSd8X5fEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_ibSd8H5fEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedAttribute xmi:id="_ia3nMH5fEdujQd6ed5A7Ug" name="oPENSEARCH_NS_URI" visibility="public" isLeaf="true" isStatic="true" type="_r7dpIX5eEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_ibSd835fEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_ibSd8n5fEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedAttribute xmi:id="_ia4OQH5fEdujQd6ed5A7Ug" name="lOCALNAME" visibility="public" isLeaf="true" isStatic="true" type="_r7dpIX5eEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_ibTFAX5fEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_ibTFAH5fEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedOperation xmi:id="_ia41UH5fEdujQd6ed5A7Ug" name="getAuthors" visibility="public" isAbstract="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_ia6DcH5fEdujQd6ed5A7Ug" type="_sAnO4H5eEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_ia6DcX5fEdujQd6ed5A7Ug" name="addAuthor" visibility="public" isAbstract="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_ia6qgH5fEdujQd6ed5A7Ug" name="aAuthor" type="_iKeawH5fEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_ia6qgX5fEdujQd6ed5A7Ug" name="setRights" visibility="public" isAbstract="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_ia7RkH5fEdujQd6ed5A7Ug" name="aRights" type="_iJx3MX5fEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_ia74oH5fEdujQd6ed5A7Ug" name="getSubtitle" visibility="public" isAbstract="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_ia8fsH5fEdujQd6ed5A7Ug" type="_iJ5L8X5fEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_ia8fsX5fEdujQd6ed5A7Ug" name="getNamespaces" visibility="public" isAbstract="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_ia9t0H5fEdujQd6ed5A7Ug" type="_sAnO4H5eEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_ia-U4H5fEdujQd6ed5A7Ug" name="getCategories" visibility="public" isAbstract="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_ia_jAH5fEdujQd6ed5A7Ug" type="_sAnO4H5eEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_ia_jAX5fEdujQd6ed5A7Ug" name="setLogo" visibility="public" isAbstract="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_ibAKEH5fEdujQd6ed5A7Ug" name="aLogo" type="_iJ2vsH5fEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_ibAxIH5fEdujQd6ed5A7Ug" name="addEntry" visibility="public" isAbstract="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_ibB_QH5fEdujQd6ed5A7Ug" name="aEntry" type="_sA-bQH5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_ibCmUH5fEdujQd6ed5A7Ug" name="getTitle" visibility="public" isAbstract="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_ibDNYH5fEdujQd6ed5A7Ug" type="_iJxQIH5fEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_ibDNYX5fEdujQd6ed5A7Ug" name="addCategory" visibility="public" isAbstract="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_ibD0cH5fEdujQd6ed5A7Ug" name="aCategory" type="_iKVQ0H5fEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_ibD0cX5fEdujQd6ed5A7Ug" name="setSubtitle" visibility="public" isAbstract="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_ibEbgH5fEdujQd6ed5A7Ug" name="aSubtitle" type="_iJ5L8X5fEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_ibEbgX5fEdujQd6ed5A7Ug" name="getContributor" visibility="public" isAbstract="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_ibGQsH5fEdujQd6ed5A7Ug" type="_sAnO4H5eEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_ibGQsX5fEdujQd6ed5A7Ug" name="getRights" visibility="public" isAbstract="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_ibG3wH5fEdujQd6ed5A7Ug" type="_iJx3MX5fEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_ibG3wX5fEdujQd6ed5A7Ug" name="getEntries" visibility="public" isAbstract="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_ibHe0H5fEdujQd6ed5A7Ug" type="_sAnO4H5eEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_ibHe0X5fEdujQd6ed5A7Ug" name="addContributor" visibility="public" isAbstract="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_ibIF4H5fEdujQd6ed5A7Ug" name="aContributor" type="_iKC88X5fEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_ibIF4X5fEdujQd6ed5A7Ug" name="getIcon" visibility="public" isAbstract="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_ibIs8H5fEdujQd6ed5A7Ug" type="_iJ390H5fEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_ibIs8X5fEdujQd6ed5A7Ug" name="addNamespace" visibility="public" isAbstract="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_ibJUAH5fEdujQd6ed5A7Ug" name="aNamespace" type="_r8CQ4H5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_ibJUAX5fEdujQd6ed5A7Ug" name="setIcon" visibility="public" isAbstract="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_ibJ7EH5fEdujQd6ed5A7Ug" name="aIcon" type="_iJ390H5fEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_ibKiIH5fEdujQd6ed5A7Ug" name="getId" visibility="public" isAbstract="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_ibKiIX5fEdujQd6ed5A7Ug" type="_iJ1hkH5fEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_ibLJMH5fEdujQd6ed5A7Ug" name="getGenerator" visibility="public" isAbstract="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_ibLJMX5fEdujQd6ed5A7Ug" type="_iJ4k4H5fEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_ibLwQH5fEdujQd6ed5A7Ug" name="setId" visibility="public" isAbstract="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_ibLwQX5fEdujQd6ed5A7Ug" name="aId" type="_iJ1hkH5fEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_ibMXUH5fEdujQd6ed5A7Ug" name="getUpdated" visibility="public" isAbstract="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_ibM-YH5fEdujQd6ed5A7Ug" type="_iJ06gH5fEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_ibM-YX5fEdujQd6ed5A7Ug" name="getLogo" visibility="public" isAbstract="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_ibNlcH5fEdujQd6ed5A7Ug" type="_iJ2vsH5fEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_ibNlcX5fEdujQd6ed5A7Ug" name="setGenerator" visibility="public" isAbstract="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_ibOMgH5fEdujQd6ed5A7Ug" name="aGenerator" type="_iJ4k4H5fEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_ibOMgX5fEdujQd6ed5A7Ug" name="getLinks" visibility="public" isAbstract="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_ibPaoH5fEdujQd6ed5A7Ug" type="_sAnO4H5eEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_ibQBsH5fEdujQd6ed5A7Ug" name="setUpdated" visibility="public" isAbstract="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_ibQowH5fEdujQd6ed5A7Ug" name="aUpdated" type="_iJ06gH5fEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_ibQowX5fEdujQd6ed5A7Ug" name="setTitle" visibility="public" isAbstract="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_ibRP0H5fEdujQd6ed5A7Ug" name="aTitle" type="_iJxQIH5fEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Class" xmi:id="_r-RFgH5eEdujQd6ed5A7Ug" name="GOMFeedImpl" visibility="package" clientDependency="_iL0ekH5fEdujQd6ed5A7Ug _iL2TwX5fEdujQd6ed5A7Ug _iL4wAH5fEdujQd6ed5A7Ug _iL6lMn5fEdujQd6ed5A7Ug _iL8aYn5fEdujQd6ed5A7Ug _iL-2oX5fEdujQd6ed5A7Ug _iMAr0n5fEdujQd6ed5A7Ug _iMChAn5fEdujQd6ed5A7Ug _iMEWMn5fEdujQd6ed5A7Ug _iMGycX5fEdujQd6ed5A7Ug _iMInon5fEdujQd6ed5A7Ug _iMKc0n5fEdujQd6ed5A7Ug _iMM5En5fEdujQd6ed5A7Ug _iMOuQn5fEdujQd6ed5A7Ug _iMQjcn5fEdujQd6ed5A7Ug _iMSYoX5fEdujQd6ed5A7Ug _iMU04X5fEdujQd6ed5A7Ug _iMWqEn5fEdujQd6ed5A7Ug _iMYfQn5fEdujQd6ed5A7Ug _iMa7gH5fEdujQd6ed5A7Ug _iMcwsn5fEdujQd6ed5A7Ug _iMel4n5fEdujQd6ed5A7Ug _iMgbEn5fEdujQd6ed5A7Ug _iMi3Un5fEdujQd6ed5A7Ug _iMksgn5fEdujQd6ed5A7Ug _iMmhsn5fEdujQd6ed5A7Ug _iMo98X5fEdujQd6ed5A7Ug _iMqzIn5fEdujQd6ed5A7Ug _iMsoUX5fEdujQd6ed5A7Ug _iMudgn5fEdujQd6ed5A7Ug">
+    <generalization xmi:id="_iHk3wH5fEdujQd6ed5A7Ug" general="_iHkQsH5fEdujQd6ed5A7Ug"/>
+    <generalization xmi:id="_iHnUAH5fEdujQd6ed5A7Ug" general="_r-P3YH5eEdujQd6ed5A7Ug"/>
+    <ownedAttribute xmi:id="_iJwCAH5fEdujQd6ed5A7Ug" name="contributors" visibility="private" type="_iKC88X5fEdujQd6ed5A7Ug" association="_iKwHkX5fEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iKfo4H5fEdujQd6ed5A7Ug" value="*"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iKfB0X5fEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedAttribute xmi:id="_iJwpEH5fEdujQd6ed5A7Ug" name="title" visibility="private" type="_iJxQIH5fEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iKfo435fEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iKfo4n5fEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedAttribute xmi:id="_iJx3MH5fEdujQd6ed5A7Ug" name="rights" visibility="private" type="_iJx3MX5fEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iKgP8X5fEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iKgP8H5fEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedAttribute xmi:id="_iJyeQH5fEdujQd6ed5A7Ug" name="categories" visibility="private" type="_iKVQ0H5fEdujQd6ed5A7Ug" association="_iK5RgH5fEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iKgP835fEdujQd6ed5A7Ug" value="*"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iKgP8n5fEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedAttribute xmi:id="_iJzFUH5fEdujQd6ed5A7Ug" name="namespaces" visibility="private" type="_r8CQ4H5eEdujQd6ed5A7Ug" association="_iK6foH5fEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iKg3An5fEdujQd6ed5A7Ug" value="*"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iKg3AX5fEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedAttribute xmi:id="_iJzFUX5fEdujQd6ed5A7Ug" name="authors" visibility="private" type="_iKeawH5fEdujQd6ed5A7Ug" association="_iLiKsX5fEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iKheEH5fEdujQd6ed5A7Ug" value="*"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iKg3BH5fEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedAttribute xmi:id="_iJzsYH5fEdujQd6ed5A7Ug" name="entries" visibility="private" type="_sA-bQH5eEdujQd6ed5A7Ug" association="_iLEQoX5fEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iKheE35fEdujQd6ed5A7Ug" value="*"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iKheEn5fEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedAttribute xmi:id="_iJ0TcH5fEdujQd6ed5A7Ug" name="updated" visibility="private" type="_iJ06gH5fEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iKjTQX5fEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iKjTQH5fEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedAttribute xmi:id="_iJ06gX5fEdujQd6ed5A7Ug" name="id" visibility="private" type="_iJ1hkH5fEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iKj6UX5fEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iKj6UH5fEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedAttribute xmi:id="_iJ2IoH5fEdujQd6ed5A7Ug" name="logo" visibility="private" type="_iJ2vsH5fEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iKkhYH5fEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iKj6Un5fEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedAttribute xmi:id="_iJ2vsX5fEdujQd6ed5A7Ug" name="links" visibility="private" type="_iLjY0H5fEdujQd6ed5A7Ug" association="_iLr7sH5fEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iKkhYn5fEdujQd6ed5A7Ug" value="*"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iKkhYX5fEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedAttribute xmi:id="_iJ3WwH5fEdujQd6ed5A7Ug" name="icon" visibility="private" type="_iJ390H5fEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iKlIcX5fEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iKlIcH5fEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedAttribute xmi:id="_iJ390X5fEdujQd6ed5A7Ug" name="generator" visibility="private" type="_iJ4k4H5fEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iKlIc35fEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iKlIcn5fEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedAttribute xmi:id="_iJ5L8H5fEdujQd6ed5A7Ug" name="subtitle" visibility="private" type="_iJ5L8X5fEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iKlvgX5fEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iKlvgH5fEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedOperation xmi:id="_iJ5zAH5fEdujQd6ed5A7Ug" name="getAuthors" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iJ6aEH5fEdujQd6ed5A7Ug" type="_sAnO4H5eEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iJ6aEX5fEdujQd6ed5A7Ug" name="setLogo" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iJ7BIH5fEdujQd6ed5A7Ug" name="aLogo" type="_iJ2vsH5fEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iJ7BIX5fEdujQd6ed5A7Ug" name="processEndElement" visibility="public" concurrency="concurrent"/>
+    <ownedOperation xmi:id="_iJ7oMH5fEdujQd6ed5A7Ug" name="getRights" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iJ8PQH5fEdujQd6ed5A7Ug" type="_iJx3MX5fEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iJ8PQX5fEdujQd6ed5A7Ug" name="setIcon" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iJ82UH5fEdujQd6ed5A7Ug" name="aIcon" type="_iJ390H5fEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iJ82UX5fEdujQd6ed5A7Ug" name="getUpdated" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iJ9dYH5fEdujQd6ed5A7Ug" type="_iJ06gH5fEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iJ9dYX5fEdujQd6ed5A7Ug" name="setId" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iJ-rgH5fEdujQd6ed5A7Ug" name="aId" type="_iJ1hkH5fEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iJ-rgX5fEdujQd6ed5A7Ug" name="getIcon" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iJ_SkH5fEdujQd6ed5A7Ug" type="_iJ390H5fEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iJ_SkX5fEdujQd6ed5A7Ug" name="getId" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iJ_5oH5fEdujQd6ed5A7Ug" type="_iJ1hkH5fEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iJ_5oX5fEdujQd6ed5A7Ug" name="getGenerator" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iKAgsH5fEdujQd6ed5A7Ug" type="_iJ4k4H5fEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iKAgsX5fEdujQd6ed5A7Ug" name="getEntries" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iKBHwH5fEdujQd6ed5A7Ug" type="_sAnO4H5eEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iKBHwX5fEdujQd6ed5A7Ug" name="getNamespaces" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iKBu0H5fEdujQd6ed5A7Ug" type="_sAnO4H5eEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iKBu0X5fEdujQd6ed5A7Ug" name="GOMFeedImpl" visibility="package" concurrency="concurrent"/>
+    <ownedOperation xmi:id="_iKCV4H5fEdujQd6ed5A7Ug" name="getLocalName" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iKCV4X5fEdujQd6ed5A7Ug" type="_r7dpIX5eEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iKC88H5fEdujQd6ed5A7Ug" name="addContributor" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iKDkAH5fEdujQd6ed5A7Ug" name="aContributor" type="_iKC88X5fEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iKELEH5fEdujQd6ed5A7Ug" name="getLinks" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iKEyIH5fEdujQd6ed5A7Ug" type="_sAnO4H5eEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iKEyIX5fEdujQd6ed5A7Ug" name="getTitle" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iKFZMH5fEdujQd6ed5A7Ug" type="_iJxQIH5fEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iKFZMX5fEdujQd6ed5A7Ug" name="setSubtitle" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iKFZMn5fEdujQd6ed5A7Ug" name="aSubtitle" type="_iJ5L8X5fEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iKGAQH5fEdujQd6ed5A7Ug" name="addNamespace" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iKGnUH5fEdujQd6ed5A7Ug" name="aNamespace" type="_r8CQ4H5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iKGnUX5fEdujQd6ed5A7Ug" name="addChild" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iKJDkH5fEdujQd6ed5A7Ug" name="aElement" type="_r-kngH5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iKJqoH5fEdujQd6ed5A7Ug" name="setRights" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iKKRsH5fEdujQd6ed5A7Ug" name="aRights" type="_iJx3MX5fEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iKKRsX5fEdujQd6ed5A7Ug" name="getSubtitle" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iKK4wH5fEdujQd6ed5A7Ug" type="_iJ5L8X5fEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iKK4wX5fEdujQd6ed5A7Ug" name="addEntry" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iKLf0H5fEdujQd6ed5A7Ug" name="aEntry" type="_sA-bQH5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iKMG4H5fEdujQd6ed5A7Ug" name="setTitle" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iKMt8H5fEdujQd6ed5A7Ug" name="aTitle" type="_iJxQIH5fEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iKMt8X5fEdujQd6ed5A7Ug" name="setGenerator" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iKNVAH5fEdujQd6ed5A7Ug" name="aGenerator" type="_iJ4k4H5fEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iKNVAX5fEdujQd6ed5A7Ug" name="getCategories" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iKN8EH5fEdujQd6ed5A7Ug" type="_sAnO4H5eEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iKOjIH5fEdujQd6ed5A7Ug" name="processAttribute" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iKQYUH5fEdujQd6ed5A7Ug" name="aQName" type="_r7h6kH5eEdujQd6ed5A7Ug"/>
+      <ownedParameter xmi:id="_iKQ_YH5fEdujQd6ed5A7Ug" name="aValue" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iKQ_YX5fEdujQd6ed5A7Ug" name="setUpdated" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iKRmcH5fEdujQd6ed5A7Ug" name="aUpdated" type="_iJ06gH5fEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iKSNgH5fEdujQd6ed5A7Ug" name="getContributor" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iKS0kH5fEdujQd6ed5A7Ug" type="_sAnO4H5eEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iKS0kX5fEdujQd6ed5A7Ug" name="processElementValue" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iKTboH5fEdujQd6ed5A7Ug" name="aValue" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iKTboX5fEdujQd6ed5A7Ug" name="getChildren" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iKUpwH5fEdujQd6ed5A7Ug" type="_iKUCsH5fEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iKUpwX5fEdujQd6ed5A7Ug" name="addCategory" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iKVQ0X5fEdujQd6ed5A7Ug" name="aCategory" type="_iKVQ0H5fEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iKV34H5fEdujQd6ed5A7Ug" name="writeAtomOutput" visibility="public" concurrency="concurrent" raisedException="_r_OHwH5eEdujQd6ed5A7Ug">
+      <ownedParameter xmi:id="_iKYUIH5fEdujQd6ed5A7Ug" name="aStreamWriter" type="_r_MSkH5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iKawYH5fEdujQd6ed5A7Ug" name="getChildParser" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iKbXcH5fEdujQd6ed5A7Ug" name="aName" type="_r7h6kH5eEdujQd6ed5A7Ug"/>
+      <ownedParameter xmi:id="_iKb-gH5fEdujQd6ed5A7Ug" type="_r7Q00H5eEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iKb-gX5fEdujQd6ed5A7Ug" name="getLogo" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iKclkH5fEdujQd6ed5A7Ug" type="_iJ2vsH5fEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iKclkX5fEdujQd6ed5A7Ug" name="writeRssOutput" visibility="public" concurrency="concurrent" raisedException="_r_OHwH5eEdujQd6ed5A7Ug">
+      <ownedParameter xmi:id="_iKdMoH5fEdujQd6ed5A7Ug" name="aStreamWriter" type="_r_MSkH5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iKdzsH5fEdujQd6ed5A7Ug" name="addAuthor" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iKfB0H5fEdujQd6ed5A7Ug" name="aAuthor" type="_iKeawH5fEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Interface" xmi:id="_r-kngH5eEdujQd6ed5A7Ug" name="GOMElement"/>
+  <packagedElement xmi:type="uml:Class" xmi:id="_r-yp8H5eEdujQd6ed5A7Ug" name="GOMDocumentImpl" clientDependency="_r_vsMH5eEdujQd6ed5A7Ug _r_xhYn5eEdujQd6ed5A7Ug _r_z9on5eEdujQd6ed5A7Ug _r_1y0n5eEdujQd6ed5A7Ug _r_3oAX5eEdujQd6ed5A7Ug">
+    <generalization xmi:id="_r-1GMH5eEdujQd6ed5A7Ug" general="_r-0fIH5eEdujQd6ed5A7Ug"/>
+    <ownedAttribute xmi:id="_r_HaEH5eEdujQd6ed5A7Ug" name="charEncoding" visibility="private" type="_r7dpIX5eEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_r_l7MX5eEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_r_l7MH5eEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedAttribute xmi:id="_r_HaEX5eEdujQd6ed5A7Ug" name="root" visibility="private">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_r_miQX5eEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_r_miQH5eEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedAttribute xmi:id="_r_KdYH5eEdujQd6ed5A7Ug" name="version" visibility="private" type="_r7dpIX5eEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_r_nJUH5eEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_r_miQn5eEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedOperation xmi:id="_r_LEcH5eEdujQd6ed5A7Ug" name="writeRssOutput" visibility="public" concurrency="concurrent" raisedException="_r_OHwH5eEdujQd6ed5A7Ug">
+      <ownedParameter xmi:id="_r_M5oH5eEdujQd6ed5A7Ug" name="aStreamWriter" type="_r_MSkH5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_r_Ou0H5eEdujQd6ed5A7Ug" name="getRootElement" visibility="public" concurrency="concurrent"/>
+    <ownedOperation xmi:id="_r_RyIH5eEdujQd6ed5A7Ug" name="writeAtomOutput" visibility="public" concurrency="concurrent" raisedException="_r_OHwH5eEdujQd6ed5A7Ug">
+      <ownedParameter xmi:id="_r_SZMH5eEdujQd6ed5A7Ug" name="aStreamWriter" type="_r_MSkH5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_r_SZMX5eEdujQd6ed5A7Ug" name="setVersion" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_r_TAQH5eEdujQd6ed5A7Ug" name="aVersion" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_r_TnUH5eEdujQd6ed5A7Ug" name="getCharacterEncoding" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_r_hCsH5eEdujQd6ed5A7Ug" type="_r7dpIX5eEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_r_hCsX5eEdujQd6ed5A7Ug" name="setCharacterEncoding" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_r_hpwH5eEdujQd6ed5A7Ug" name="aEncoding" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_r_iQ0H5eEdujQd6ed5A7Ug" name="getVersion" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_r_iQ0X5eEdujQd6ed5A7Ug" type="_r7dpIX5eEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_r_i34H5eEdujQd6ed5A7Ug" name="GOMDocumentImpl" visibility="public" concurrency="concurrent"/>
+    <ownedOperation xmi:id="_r_i34X5eEdujQd6ed5A7Ug" name="setRootElement" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_r_lUIH5eEdujQd6ed5A7Ug" name="aRootElement"/>
+    </ownedOperation>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Interface" xmi:id="_r-0fIH5eEdujQd6ed5A7Ug" name="GOMDocument" clientDependency="_sH6wwH5eEdujQd6ed5A7Ug _sH9NAn5eEdujQd6ed5A7Ug _sH_CMn5eEdujQd6ed5A7Ug _sIA3Yn5eEdujQd6ed5A7Ug _sIDToX5eEdujQd6ed5A7Ug">
+    <ownedOperation xmi:id="_sHmAoH5eEdujQd6ed5A7Ug" name="writeAtomOutput" visibility="public" isAbstract="true" concurrency="concurrent" raisedException="_r_OHwH5eEdujQd6ed5A7Ug">
+      <ownedParameter xmi:id="_sHnOwH5eEdujQd6ed5A7Ug" name="aStreamWriter" type="_r_MSkH5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_sHoc4H5eEdujQd6ed5A7Ug" name="writeRssOutput" visibility="public" isAbstract="true" concurrency="concurrent" raisedException="_r_OHwH5eEdujQd6ed5A7Ug">
+      <ownedParameter xmi:id="_sHpD8H5eEdujQd6ed5A7Ug" name="aStreamWriter" type="_r_MSkH5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_sHprAH5eEdujQd6ed5A7Ug" name="getVersion" visibility="public" isAbstract="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_sHqSEH5eEdujQd6ed5A7Ug" type="_r7dpIX5eEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_sHqSEX5eEdujQd6ed5A7Ug" name="getCharacterEncoding" visibility="public" isAbstract="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_sHq5IH5eEdujQd6ed5A7Ug" type="_r7dpIX5eEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_sHq5IX5eEdujQd6ed5A7Ug" name="getRootElement" visibility="public" isAbstract="true" concurrency="concurrent"/>
+    <ownedOperation xmi:id="_sHwYsH5eEdujQd6ed5A7Ug" name="setCharacterEncoding" visibility="public" isAbstract="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_sHw_wH5eEdujQd6ed5A7Ug" name="aEncoding" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_sHxm0H5eEdujQd6ed5A7Ug" name="setVersion" visibility="public" isAbstract="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_sHxm0X5eEdujQd6ed5A7Ug" name="aVersion" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_sHyN4H5eEdujQd6ed5A7Ug" name="setRootElement" visibility="public" isAbstract="true" concurrency="concurrent">
+      <ownedParameter xmi:id="_sH0qIH5eEdujQd6ed5A7Ug" name="aRootElement"/>
+    </ownedOperation>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Interface" xmi:id="_r_MSkH5eEdujQd6ed5A7Ug" name="XMLStreamWriter" isAbstract="true"/>
+  <packagedElement xmi:type="uml:Class" xmi:id="_r_OHwH5eEdujQd6ed5A7Ug" name="XMLStreamException"/>
+  <packagedElement xmi:type="uml:Class" xmi:id="_sAJ74H5eEdujQd6ed5A7Ug" name="GOMBuilder" clientDependency="_sBMdsX5eEdujQd6ed5A7Ug _sBOS4X5eEdujQd6ed5A7Ug _sBQIEn5eEdujQd6ed5A7Ug _sBSkUX5eEdujQd6ed5A7Ug _sBUZgX5eEdujQd6ed5A7Ug _sBWOsn5eEdujQd6ed5A7Ug _sBYq8n5eEdujQd6ed5A7Ug _sBagIn5eEdujQd6ed5A7Ug _sBcVUX5eEdujQd6ed5A7Ug _sBexkn5eEdujQd6ed5A7Ug _sBhN0H5eEdujQd6ed5A7Ug _sBjDAn5eEdujQd6ed5A7Ug _sBmGUH5eEdujQd6ed5A7Ug _sBn7gn5eEdujQd6ed5A7Ug _sBqXwX5eEdujQd6ed5A7Ug _sBsM8X5eEdujQd6ed5A7Ug _sBuCIn5eEdujQd6ed5A7Ug _lnc38H5fEdujQd6ed5A7Ug _lngiUX5fEdujQd6ed5A7Ug _lni-kH5fEdujQd6ed5A7Ug _lnkzwX5fEdujQd6ed5A7Ug _ln4VwH5fEdujQd6ed5A7Ug _ln8AIX5fEdujQd6ed5A7Ug _ln-cYX5fEdujQd6ed5A7Ug _loA4oH5fEdujQd6ed5A7Ug _-nSZoH5fEdujQd6ed5A7Ug _-nUO0X5fEdujQd6ed5A7Ug _-nWrEH5fEdujQd6ed5A7Ug _-nYgQX5fEdujQd6ed5A7Ug _BYTvwH5gEdujQd6ed5A7Ug _BYWMAX5gEdujQd6ed5A7Ug _BYYBMX5gEdujQd6ed5A7Ug _BYadcH5gEdujQd6ed5A7Ug">
+    <ownedAttribute xmi:id="_sAkyoH5eEdujQd6ed5A7Ug" name="parserStack" visibility="private" isLeaf="true" type="_r7Q00H5eEdujQd6ed5A7Ug" association="_sBCFoH5eEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_sA_CUX5eEdujQd6ed5A7Ug" value="*"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_sA_CUH5eEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedAttribute xmi:id="_sAnO4X5eEdujQd6ed5A7Ug" name="lastLocalName" visibility="private" type="_r7h6kH5eEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_sBAQcn5eEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_sBAQcX5eEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedAttribute xmi:id="_sAn18H5eEdujQd6ed5A7Ug" name="streamReader" visibility="private" isLeaf="true" type="_sAodAH5eEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_sBAQdH5eEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_sBAQc35eEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedAttribute xmi:id="_sAodAX5eEdujQd6ed5A7Ug" name="factory" visibility="private" isLeaf="true" type="_r-JwwH5eEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_sBA3gX5eEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_sBA3gH5eEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedOperation xmi:id="_sApEEH5eEdujQd6ed5A7Ug" name="next" visibility="private" concurrency="concurrent" raisedException="_r_OHwH5eEdujQd6ed5A7Ug">
+      <ownedParameter xmi:id="_BYLM4H5gEdujQd6ed5A7Ug" direction="return">
+        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/JavaPrimitiveTypes.library.uml#int"/>
+      </ownedParameter>
+    </ownedOperation>
+    <ownedOperation xmi:id="_sArgUH5eEdujQd6ed5A7Ug" name="parse" visibility="private" concurrency="concurrent" raisedException="_r_OHwH5eEdujQd6ed5A7Ug">
+      <ownedParameter xmi:id="_BYMbAH5gEdujQd6ed5A7Ug" name="aReader" type="_sAodAH5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_sA6w4H5eEdujQd6ed5A7Ug" name="processAttributes" visibility="private" concurrency="concurrent">
+      <ownedParameter xmi:id="_BYNpIH5gEdujQd6ed5A7Ug" name="childParser" type="_r7Q00H5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_sA7X8X5eEdujQd6ed5A7Ug" name="startFeedDocument" visibility="private" concurrency="concurrent" raisedException="_r_OHwH5eEdujQd6ed5A7Ug">
+      <ownedParameter xmi:id="_BYLz8H5gEdujQd6ed5A7Ug" name="aDocument" type="_r-0fIH5eEdujQd6ed5A7Ug"/>
+      <ownedParameter xmi:id="_BYLz8X5gEdujQd6ed5A7Ug" type="_r-P3YH5eEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_sA8mEH5eEdujQd6ed5A7Ug" name="buildGOMFeed" visibility="public" concurrency="concurrent" raisedException="_r_OHwH5eEdujQd6ed5A7Ug">
+      <ownedParameter xmi:id="_BYOQMH5gEdujQd6ed5A7Ug" type="_r-0fIH5eEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_sA9NIH5eEdujQd6ed5A7Ug" name="GOMBuilder" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_BYNCEH5gEdujQd6ed5A7Ug" name="arg0" type="_sAodAH5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_sA90MX5eEdujQd6ed5A7Ug" name="buildGOMEntry" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_BYO3QH5gEdujQd6ed5A7Ug" type="_sA-bQH5eEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Interface" xmi:id="_sAodAH5eEdujQd6ed5A7Ug" name="XMLStreamReader" isAbstract="true"/>
+  <packagedElement xmi:type="uml:Interface" xmi:id="_sA-bQH5eEdujQd6ed5A7Ug" name="GOMEntry">
+    <generalization xmi:id="_iK8U0H5fEdujQd6ed5A7Ug" general="_sHIGkH5eEdujQd6ed5A7Ug"/>
+    <generalization xmi:id="_iK9i8H5fEdujQd6ed5A7Ug" general="_r-kngH5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Association" xmi:id="_sBCFoH5eEdujQd6ed5A7Ug" memberEnd="_sAkyoH5eEdujQd6ed5A7Ug _sBCssH5eEdujQd6ed5A7Ug">
+    <name xsi:nil="true"/>
+    <ownedEnd xmi:id="_sBCssH5eEdujQd6ed5A7Ug" name="" type="_sAJ74H5eEdujQd6ed5A7Ug" association="_sBCFoH5eEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_sBCssX5eEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_sBCssn5eEdujQd6ed5A7Ug"/>
+    </ownedEnd>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Interface" xmi:id="_sHIGkH5eEdujQd6ed5A7Ug" name="GOMXmlEntity"/>
+  <packagedElement xmi:type="uml:Class" xmi:id="_iHkQsH5fEdujQd6ed5A7Ug" name="AbstractGOMElement" visibility="package" clientDependency="_iZqtUH5fEdujQd6ed5A7Ug _iZtJkn5fEdujQd6ed5A7Ug _iZu-wn5fEdujQd6ed5A7Ug _iZxbAX5fEdujQd6ed5A7Ug _iZzQMn5fEdujQd6ed5A7Ug _iZ1FYn5fEdujQd6ed5A7Ug _iZ3hoX5fEdujQd6ed5A7Ug _iZ5W0X5fEdujQd6ed5A7Ug _iZ7MAn5fEdujQd6ed5A7Ug" isAbstract="true">
+    <generalization xmi:id="_iYpZoH5fEdujQd6ed5A7Ug" general="_r-kngH5eEdujQd6ed5A7Ug"/>
+    <ownedAttribute xmi:id="_iZZAgH5fEdujQd6ed5A7Ug" name="extensionAttributes" visibility="protected" type="_r9XtoH5eEdujQd6ed5A7Ug" association="_iZnqAH5fEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iZlNwX5fEdujQd6ed5A7Ug" value="*"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iZlNwH5fEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedAttribute xmi:id="_iZZnkH5fEdujQd6ed5A7Ug" name="textValue" visibility="protected" type="_r7dpIX5eEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iZl00n5fEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iZl00X5fEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedAttribute xmi:id="_iZaOoH5fEdujQd6ed5A7Ug" name="qname" visibility="protected" type="_r7h6kH5eEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iZmb4H5fEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iZl0035fEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedAttribute xmi:id="_iZaOoX5fEdujQd6ed5A7Ug" name="localName" visibility="protected" type="_r7dpIX5eEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iZmb4n5fEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iZmb4X5fEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedAttribute xmi:id="_iZa1sH5fEdujQd6ed5A7Ug" name="parent" visibility="protected" type="_r-kngH5eEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iZnC8X5fEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iZnC8H5fEdujQd6ed5A7Ug"/>
+    </ownedAttribute>
+    <ownedOperation xmi:id="_iZbcwH5fEdujQd6ed5A7Ug" name="getAttributes" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iZcD0H5fEdujQd6ed5A7Ug" type="_iKUCsH5fEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iZcD0X5fEdujQd6ed5A7Ug" name="addAttribute" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iZcD0n5fEdujQd6ed5A7Ug" name="aAttribute" type="_r9XtoH5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iZcq4H5fEdujQd6ed5A7Ug" name="getChildParser" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iZdR8H5fEdujQd6ed5A7Ug" name="aName" type="_r7h6kH5eEdujQd6ed5A7Ug"/>
+      <ownedParameter xmi:id="_iZdR8X5fEdujQd6ed5A7Ug" type="_r7Q00H5eEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iZdR8n5fEdujQd6ed5A7Ug" name="getLocalName" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iZegEH5fEdujQd6ed5A7Ug" type="_r7dpIX5eEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iZegEX5fEdujQd6ed5A7Ug" name="setQName" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iZfHIH5fEdujQd6ed5A7Ug" name="aQname" type="_r7h6kH5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iZfHIX5fEdujQd6ed5A7Ug" name="setLocalName" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iZfuMH5fEdujQd6ed5A7Ug" name="aLocalName" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iZgVQH5fEdujQd6ed5A7Ug" name="processElementValue" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iZgVQX5fEdujQd6ed5A7Ug" name="aValue" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iZg8UH5fEdujQd6ed5A7Ug" name="getTextValue" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iZhjYH5fEdujQd6ed5A7Ug" type="_r7dpIX5eEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iZhjYX5fEdujQd6ed5A7Ug" name="processEndElement" visibility="public" concurrency="concurrent"/>
+    <ownedOperation xmi:id="_iZiKcH5fEdujQd6ed5A7Ug" name="getParent" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iZixgH5fEdujQd6ed5A7Ug" type="_r-kngH5eEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iZixgX5fEdujQd6ed5A7Ug" name="getQname" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iZjYkH5fEdujQd6ed5A7Ug" type="_r7h6kH5eEdujQd6ed5A7Ug" direction="return"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iZjYkX5fEdujQd6ed5A7Ug" name="processAttribute" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iZjYkn5fEdujQd6ed5A7Ug" name="aQName" type="_r7h6kH5eEdujQd6ed5A7Ug"/>
+      <ownedParameter xmi:id="_iZj_oH5fEdujQd6ed5A7Ug" name="aValue" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+    <ownedOperation xmi:id="_iZj_oX5fEdujQd6ed5A7Ug" name="setTextValue" visibility="public" concurrency="concurrent">
+      <ownedParameter xmi:id="_iZkmsH5fEdujQd6ed5A7Ug" name="aTextValue" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
+    </ownedOperation>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Interface" xmi:id="_iJxQIH5fEdujQd6ed5A7Ug" name="GOMTitle"/>
+  <packagedElement xmi:type="uml:Interface" xmi:id="_iJx3MX5fEdujQd6ed5A7Ug" name="GOMRights"/>
+  <packagedElement xmi:type="uml:Interface" xmi:id="_iJ06gH5fEdujQd6ed5A7Ug" name="GOMTime"/>
+  <packagedElement xmi:type="uml:Interface" xmi:id="_iJ1hkH5fEdujQd6ed5A7Ug" name="GOMId"/>
+  <packagedElement xmi:type="uml:Interface" xmi:id="_iJ2vsH5fEdujQd6ed5A7Ug" name="GOMLogo"/>
+  <packagedElement xmi:type="uml:Interface" xmi:id="_iJ390H5fEdujQd6ed5A7Ug" name="GOMIcon"/>
+  <packagedElement xmi:type="uml:Interface" xmi:id="_iJ4k4H5fEdujQd6ed5A7Ug" name="GOMGenerator"/>
+  <packagedElement xmi:type="uml:Interface" xmi:id="_iJ5L8X5fEdujQd6ed5A7Ug" name="GOMSubtitle"/>
+  <packagedElement xmi:type="uml:Interface" xmi:id="_iKC88X5fEdujQd6ed5A7Ug" name="GOMContributor">
+    <generalization xmi:id="_iKoy0H5fEdujQd6ed5A7Ug" general="_r-kngH5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Interface" xmi:id="_iKVQ0H5fEdujQd6ed5A7Ug" name="GOMCategory">
+    <generalization xmi:id="_iKx8wH5fEdujQd6ed5A7Ug" general="_r-kngH5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Interface" xmi:id="_iKeawH5fEdujQd6ed5A7Ug" name="GOMAuthor">
+    <generalization xmi:id="_iLGs4H5fEdujQd6ed5A7Ug" general="_r-kngH5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Association" xmi:id="_iKwHkX5fEdujQd6ed5A7Ug" memberEnd="_iJwCAH5fEdujQd6ed5A7Ug _iKwuoH5fEdujQd6ed5A7Ug">
+    <name xsi:nil="true"/>
+    <ownedEnd xmi:id="_iKwuoH5fEdujQd6ed5A7Ug" name="" type="_r-RFgH5eEdujQd6ed5A7Ug" association="_iKwHkX5fEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iKwuoX5fEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iKwuon5fEdujQd6ed5A7Ug"/>
+    </ownedEnd>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Association" xmi:id="_iK5RgH5fEdujQd6ed5A7Ug" memberEnd="_iJyeQH5fEdujQd6ed5A7Ug _iK5RgX5fEdujQd6ed5A7Ug">
+    <name xsi:nil="true"/>
+    <ownedEnd xmi:id="_iK5RgX5fEdujQd6ed5A7Ug" name="" type="_r-RFgH5eEdujQd6ed5A7Ug" association="_iK5RgH5fEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iK5Rgn5fEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iK5Rg35fEdujQd6ed5A7Ug"/>
+    </ownedEnd>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Association" xmi:id="_iK6foH5fEdujQd6ed5A7Ug" memberEnd="_iJzFUH5fEdujQd6ed5A7Ug _iK6foX5fEdujQd6ed5A7Ug">
+    <name xsi:nil="true"/>
+    <ownedEnd xmi:id="_iK6foX5fEdujQd6ed5A7Ug" name="" type="_r-RFgH5eEdujQd6ed5A7Ug" association="_iK6foH5fEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iK6fon5fEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iK6fo35fEdujQd6ed5A7Ug"/>
+    </ownedEnd>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Association" xmi:id="_iLEQoX5fEdujQd6ed5A7Ug" memberEnd="_iJzsYH5fEdujQd6ed5A7Ug _iLE3sH5fEdujQd6ed5A7Ug">
+    <name xsi:nil="true"/>
+    <ownedEnd xmi:id="_iLE3sH5fEdujQd6ed5A7Ug" name="" type="_r-RFgH5eEdujQd6ed5A7Ug" association="_iLEQoX5fEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iLE3sX5fEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iLE3sn5fEdujQd6ed5A7Ug"/>
+    </ownedEnd>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Association" xmi:id="_iLiKsX5fEdujQd6ed5A7Ug" memberEnd="_iJzFUX5fEdujQd6ed5A7Ug _iLixwH5fEdujQd6ed5A7Ug">
+    <name xsi:nil="true"/>
+    <ownedEnd xmi:id="_iLixwH5fEdujQd6ed5A7Ug" name="" type="_r-RFgH5eEdujQd6ed5A7Ug" association="_iLiKsX5fEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iLixwX5fEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iLixwn5fEdujQd6ed5A7Ug"/>
+    </ownedEnd>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Interface" xmi:id="_iLjY0H5fEdujQd6ed5A7Ug" name="GOMLink">
+    <generalization xmi:id="_iLkm8H5fEdujQd6ed5A7Ug" general="_r-kngH5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Association" xmi:id="_iLr7sH5fEdujQd6ed5A7Ug" memberEnd="_iJ2vsX5fEdujQd6ed5A7Ug _iLr7sX5fEdujQd6ed5A7Ug">
+    <name xsi:nil="true"/>
+    <ownedEnd xmi:id="_iLr7sX5fEdujQd6ed5A7Ug" name="" type="_r-RFgH5eEdujQd6ed5A7Ug" association="_iLr7sH5fEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iLr7sn5fEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iLr7s35fEdujQd6ed5A7Ug"/>
+    </ownedEnd>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Class" xmi:id="_iLtw4H5fEdujQd6ed5A7Ug" name="GOMTitleImp"/>
+  <packagedElement xmi:type="uml:Class" xmi:id="_iLu_AH5fEdujQd6ed5A7Ug" name="GOMIdImpl" visibility="package"/>
+  <packagedElement xmi:type="uml:Association" xmi:id="_iZnqAH5fEdujQd6ed5A7Ug" memberEnd="_iZZAgH5fEdujQd6ed5A7Ug _iZoREH5fEdujQd6ed5A7Ug">
+    <name xsi:nil="true"/>
+    <ownedEnd xmi:id="_iZoREH5fEdujQd6ed5A7Ug" name="" type="_iHkQsH5fEdujQd6ed5A7Ug" association="_iZnqAH5fEdujQd6ed5A7Ug">
+      <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_iZoREX5fEdujQd6ed5A7Ug" value="1"/>
+      <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_iZoREn5fEdujQd6ed5A7Ug"/>
+    </ownedEnd>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Package" xmi:id="_r7dCEX5eEdujQd6ed5A7Ug" name="java.lang">
+    <packagedElement xmi:type="uml:Class" xmi:id="_r7dpIX5eEdujQd6ed5A7Ug" name="String" isLeaf="true"/>
+    <packagedElement xmi:type="uml:Class" xmi:id="_r89d8H5eEdujQd6ed5A7Ug" name="RuntimeException">
+      <generalization xmi:id="_sEm-EH5eEdujQd6ed5A7Ug" general="_sEmXAH5eEdujQd6ed5A7Ug"/>
+      <ownedAttribute xmi:id="_sGP80H5eEdujQd6ed5A7Ug" name="serialVersionUID" visibility="package" isLeaf="true" isStatic="true" isReadOnly="true">
+        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/JavaPrimitiveTypes.library.uml#long"/>
+      </ownedAttribute>
+      <ownedOperation xmi:id="_sGRyAH5eEdujQd6ed5A7Ug" name="RuntimeException" visibility="public" concurrency="concurrent">
+        <ownedParameter xmi:id="_sGyvYH5eEdujQd6ed5A7Ug" name="arg0" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
+        <ownedParameter xmi:id="_sGyvYX5eEdujQd6ed5A7Ug" name="arg1" type="_r9ELoH5eEdujQd6ed5A7Ug"/>
+      </ownedOperation>
+      <ownedOperation xmi:id="_sGzWcH5eEdujQd6ed5A7Ug" name="RuntimeException" visibility="public" concurrency="concurrent">
+        <ownedParameter xmi:id="_sGz9gH5eEdujQd6ed5A7Ug" name="arg0" type="_r7dpIX5eEdujQd6ed5A7Ug"/>
+      </ownedOperation>
+      <ownedOperation xmi:id="_sGz9gX5eEdujQd6ed5A7Ug" name="RuntimeException" visibility="public" concurrency="concurrent">
+        <ownedParameter xmi:id="_sG0kkH5eEdujQd6ed5A7Ug" name="arg0" type="_r9ELoH5eEdujQd6ed5A7Ug"/>
+      </ownedOperation>
+      <ownedOperation xmi:id="_sG0kkX5eEdujQd6ed5A7Ug" name="RuntimeException" visibility="public" concurrency="concurrent"/>
+    </packagedElement>
+    <packagedElement xmi:type="uml:Class" xmi:id="_r9ELoH5eEdujQd6ed5A7Ug" name="Throwable"/>
+    <packagedElement xmi:type="uml:Class" xmi:id="_sBHlMH5eEdujQd6ed5A7Ug" name="System" isLeaf="true"/>
+    <packagedElement xmi:type="uml:Class" xmi:id="_sEmXAH5eEdujQd6ed5A7Ug" name="Exception"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Package" xmi:id="_sAlZsH5eEdujQd6ed5A7Ug" name="java.util">
+    <packagedElement xmi:type="uml:Class" xmi:id="_sAmAwH5eEdujQd6ed5A7Ug" name="Stack"/>
+    <packagedElement xmi:type="uml:Interface" xmi:id="_sAnO4H5eEdujQd6ed5A7Ug" name="List" isAbstract="true"/>
+    <packagedElement xmi:type="uml:Class" xmi:id="_sBG-IH5eEdujQd6ed5A7Ug" name="LinkedList"/>
+    <packagedElement xmi:type="uml:Interface" xmi:id="_iKUCsH5fEdujQd6ed5A7Ug" name="Iterator" isAbstract="true"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_l_ahcH5eEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l83jwH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l85Y8H5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_mVVuIH5eEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l85Y8H5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_mVYKYH5eEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l85Y8H5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_mVZ_kn5eEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l85Y8H5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_mVcb0H5eEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l85Y8H5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_mVpQIH5eEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l83jwH5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_mVrsYH5eEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l83jwH5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_mVthkX5eEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l83jwH5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_mVv90X5eEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_mVmz4H5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l83jwH5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_mV6V4H5eEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l83jwH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_mV8yIX5eEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l83jwH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_mV_OYH5eEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_mWBDkX5eEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_mWDf0H5eEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_mVmz4H5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_mWHxQH5eEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l83jwH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l8xdIH5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_mWKNgn5eEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l8xdIH5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_mWMCsX5eEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l8xdIH5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_mWOe8X5eEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l8xdIH5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_mWQ7MX5eEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l8xdIH5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_mWXo4H5eEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l81ukH5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_mWZeEn5eEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l81ukH5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_mWb6UX5eEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l81ukH5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_r7sSoH5eEdujQd6ed5A7Ug" supplier="_r7dpIX5eEdujQd6ed5A7Ug" client="_r7Q00H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_r7uu4X5eEdujQd6ed5A7Ug" supplier="_r7h6kH5eEdujQd6ed5A7Ug" client="_r7Q00H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_r72DoH5eEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_r8qjAH5eEdujQd6ed5A7Ug" supplier="_r7dpIX5eEdujQd6ed5A7Ug" client="_r8CQ4H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_r8x3wH5eEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_r9GA0H5eEdujQd6ed5A7Ug" supplier="_r9ELoH5eEdujQd6ed5A7Ug" client="_r8824H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_r9IdEn5eEdujQd6ed5A7Ug" supplier="_r7dpIX5eEdujQd6ed5A7Ug" client="_r8824H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_r9Px0H5eEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_r9lJAH5eEdujQd6ed5A7Ug" supplier="_r7dpIX5eEdujQd6ed5A7Ug" client="_r9WfgH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_r9nlQn5eEdujQd6ed5A7Ug" supplier="_r7h6kH5eEdujQd6ed5A7Ug" client="_r9WfgH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_r9wIIH5eEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_r-RskH5eEdujQd6ed5A7Ug" supplier="_r-P3YH5eEdujQd6ed5A7Ug" client="_r-JwwH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_r-Thwn5eEdujQd6ed5A7Ug" supplier="_r-RFgH5eEdujQd6ed5A7Ug" client="_r-JwwH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_r-cEoH5eEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_r-l1oH5eEdujQd6ed5A7Ug" supplier="_r-kngH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_r-tKYH5eEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_r_vsMH5eEdujQd6ed5A7Ug" supplier="_r7dpIX5eEdujQd6ed5A7Ug" client="_r-yp8H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_r_xhYn5eEdujQd6ed5A7Ug" supplier="_r_MSkH5eEdujQd6ed5A7Ug" client="_r-yp8H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_r_z9on5eEdujQd6ed5A7Ug" supplier="_r-kngH5eEdujQd6ed5A7Ug" client="_r-yp8H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_r_1y0n5eEdujQd6ed5A7Ug" supplier="_r_OHwH5eEdujQd6ed5A7Ug" client="_r-yp8H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_r_3oAX5eEdujQd6ed5A7Ug" supplier="_r_OHwH5eEdujQd6ed5A7Ug" client="_r-yp8H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_sAAK4H5eEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_sBMdsX5eEdujQd6ed5A7Ug" supplier="_sAmAwH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_sBOS4X5eEdujQd6ed5A7Ug" supplier="_sAmAwH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_sBQIEn5eEdujQd6ed5A7Ug" supplier="_sAodAH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_sBSkUX5eEdujQd6ed5A7Ug" supplier="_r_OHwH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_sBUZgX5eEdujQd6ed5A7Ug" supplier="_r_OHwH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_sBWOsn5eEdujQd6ed5A7Ug" supplier="_r-P3YH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_sBYq8n5eEdujQd6ed5A7Ug" supplier="_r7h6kH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_sBagIn5eEdujQd6ed5A7Ug" supplier="_sBG-IH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_sBcVUX5eEdujQd6ed5A7Ug" supplier="_sBHlMH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_sBexkn5eEdujQd6ed5A7Ug" supplier="_r-yp8H5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_sBhN0H5eEdujQd6ed5A7Ug" supplier="_r7Q00H5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_sBjDAn5eEdujQd6ed5A7Ug" supplier="_sA-bQH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_sBmGUH5eEdujQd6ed5A7Ug" supplier="_r-JwwH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_sBn7gn5eEdujQd6ed5A7Ug" supplier="_r-JwwH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_sBqXwX5eEdujQd6ed5A7Ug" supplier="_r8CQ4H5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_sBsM8X5eEdujQd6ed5A7Ug" supplier="_r8CQ4H5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_sBuCIn5eEdujQd6ed5A7Ug" supplier="_r-0fIH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_sB6PYH5eEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_sHONMH5eEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l83jwH5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_sH6wwH5eEdujQd6ed5A7Ug" supplier="_r7dpIX5eEdujQd6ed5A7Ug" client="_r-0fIH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_sH9NAn5eEdujQd6ed5A7Ug" supplier="_r_MSkH5eEdujQd6ed5A7Ug" client="_r-0fIH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_sH_CMn5eEdujQd6ed5A7Ug" supplier="_r-kngH5eEdujQd6ed5A7Ug" client="_r-0fIH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_sIA3Yn5eEdujQd6ed5A7Ug" supplier="_r_OHwH5eEdujQd6ed5A7Ug" client="_r-0fIH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_sIDToX5eEdujQd6ed5A7Ug" supplier="_r_OHwH5eEdujQd6ed5A7Ug" client="_r-0fIH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_sILPcH5eEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l83jwH5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_9V9KEH5eEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_9fSFMH5eEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_-avn4H5eEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iKuSYH5fEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l83jwH5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iK21QH5fEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l83jwH5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iLCbcH5fEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l83jwH5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iLfucH5fEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l83jwH5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iLpfcH5fEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l83jwH5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iL0ekH5fEdujQd6ed5A7Ug" supplier="_iLu_AH5fEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iL2TwX5fEdujQd6ed5A7Ug" supplier="_iKVQ0H5fEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iL4wAH5fEdujQd6ed5A7Ug" supplier="_iJ2vsH5fEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iL6lMn5fEdujQd6ed5A7Ug" supplier="_iJx3MX5fEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iL8aYn5fEdujQd6ed5A7Ug" supplier="_sBG-IH5eEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iL-2oX5fEdujQd6ed5A7Ug" supplier="_iJ06gH5fEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iMAr0n5fEdujQd6ed5A7Ug" supplier="_r7h6kH5eEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iMChAn5fEdujQd6ed5A7Ug" supplier="_iLjY0H5fEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iMEWMn5fEdujQd6ed5A7Ug" supplier="_iJ4k4H5fEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iMGycX5fEdujQd6ed5A7Ug" supplier="_sAnO4H5eEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iMInon5fEdujQd6ed5A7Ug" supplier="_iJxQIH5fEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iMKc0n5fEdujQd6ed5A7Ug" supplier="_iJ1hkH5fEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iMM5En5fEdujQd6ed5A7Ug" supplier="_iKeawH5fEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iMOuQn5fEdujQd6ed5A7Ug" supplier="_sA-bQH5eEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iMQjcn5fEdujQd6ed5A7Ug" supplier="_r_OHwH5eEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iMSYoX5fEdujQd6ed5A7Ug" supplier="_r_OHwH5eEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iMU04X5fEdujQd6ed5A7Ug" supplier="_iKC88X5fEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iMWqEn5fEdujQd6ed5A7Ug" supplier="_iKUCsH5fEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iMYfQn5fEdujQd6ed5A7Ug" supplier="_iLtw4H5fEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iMa7gH5fEdujQd6ed5A7Ug" supplier="_r7Q00H5eEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iMcwsn5fEdujQd6ed5A7Ug" supplier="_r_MSkH5eEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iMel4n5fEdujQd6ed5A7Ug" supplier="_iJ5L8X5fEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iMgbEn5fEdujQd6ed5A7Ug" supplier="_r9XtoH5eEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iMi3Un5fEdujQd6ed5A7Ug" supplier="_iJ390H5fEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iMksgn5fEdujQd6ed5A7Ug" supplier="_r8CQ4H5eEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iMmhsn5fEdujQd6ed5A7Ug" supplier="_r7dpIX5eEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iMo98X5fEdujQd6ed5A7Ug" supplier="_r7dpIX5eEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iMqzIn5fEdujQd6ed5A7Ug" supplier="_r9WfgH5eEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iMsoUX5fEdujQd6ed5A7Ug" supplier="_r9WfgH5eEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iMudgn5fEdujQd6ed5A7Ug" supplier="_r-kngH5eEdujQd6ed5A7Ug" client="_r-RFgH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iM1LMH5fEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iZqtUH5fEdujQd6ed5A7Ug" supplier="_iKUCsH5fEdujQd6ed5A7Ug" client="_iHkQsH5fEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iZtJkn5fEdujQd6ed5A7Ug" supplier="_r7dpIX5eEdujQd6ed5A7Ug" client="_iHkQsH5fEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iZu-wn5fEdujQd6ed5A7Ug" supplier="_r7dpIX5eEdujQd6ed5A7Ug" client="_iHkQsH5fEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iZxbAX5fEdujQd6ed5A7Ug" supplier="_sAnO4H5eEdujQd6ed5A7Ug" client="_iHkQsH5fEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iZzQMn5fEdujQd6ed5A7Ug" supplier="_r7h6kH5eEdujQd6ed5A7Ug" client="_iHkQsH5fEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iZ1FYn5fEdujQd6ed5A7Ug" supplier="_r-kngH5eEdujQd6ed5A7Ug" client="_iHkQsH5fEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iZ3hoX5fEdujQd6ed5A7Ug" supplier="_sBG-IH5eEdujQd6ed5A7Ug" client="_iHkQsH5fEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iZ5W0X5fEdujQd6ed5A7Ug" supplier="_r7Q00H5eEdujQd6ed5A7Ug" client="_iHkQsH5fEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iZ7MAn5fEdujQd6ed5A7Ug" supplier="_r9XtoH5eEdujQd6ed5A7Ug" client="_iHkQsH5fEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iaDH0H5fEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_ibYkkH5fEdujQd6ed5A7Ug" supplier="_iKVQ0H5fEdujQd6ed5A7Ug" client="_r-P3YH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_ibaZwn5fEdujQd6ed5A7Ug" supplier="_iJx3MX5fEdujQd6ed5A7Ug" client="_r-P3YH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_ibc2AH5fEdujQd6ed5A7Ug" supplier="_iJ390H5fEdujQd6ed5A7Ug" client="_r-P3YH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iberMn5fEdujQd6ed5A7Ug" supplier="_sAnO4H5eEdujQd6ed5A7Ug" client="_r-P3YH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_ibggYn5fEdujQd6ed5A7Ug" supplier="_iKeawH5fEdujQd6ed5A7Ug" client="_r-P3YH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_ibi8oX5fEdujQd6ed5A7Ug" supplier="_iJ1hkH5fEdujQd6ed5A7Ug" client="_r-P3YH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_ibkx0n5fEdujQd6ed5A7Ug" supplier="_iJxQIH5fEdujQd6ed5A7Ug" client="_r-P3YH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_ibmnAn5fEdujQd6ed5A7Ug" supplier="_iJ5L8X5fEdujQd6ed5A7Ug" client="_r-P3YH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_ibpDQH5fEdujQd6ed5A7Ug" supplier="_sA-bQH5eEdujQd6ed5A7Ug" client="_r-P3YH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_ibq4cn5fEdujQd6ed5A7Ug" supplier="_iKC88X5fEdujQd6ed5A7Ug" client="_r-P3YH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_ibston5fEdujQd6ed5A7Ug" supplier="_iJ06gH5fEdujQd6ed5A7Ug" client="_r-P3YH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_ibui0n5fEdujQd6ed5A7Ug" supplier="_iJ2vsH5fEdujQd6ed5A7Ug" client="_r-P3YH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_ibw_EX5fEdujQd6ed5A7Ug" supplier="_r8CQ4H5eEdujQd6ed5A7Ug" client="_r-P3YH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_iby0Qn5fEdujQd6ed5A7Ug" supplier="_iJ4k4H5fEdujQd6ed5A7Ug" client="_r-P3YH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_ib13kH5fEdujQd6ed5A7Ug" supplier="_r7dpIX5eEdujQd6ed5A7Ug" client="_r-P3YH5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_ib7XIH5fEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l83jwH5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_lnc38H5fEdujQd6ed5A7Ug" supplier="_r_OHwH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_lngiUX5fEdujQd6ed5A7Ug" supplier="_sAmAwH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_lni-kH5fEdujQd6ed5A7Ug" supplier="_r-yp8H5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_lnkzwX5fEdujQd6ed5A7Ug" supplier="_r8CQ4H5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_lnsIgH5fEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_ln4VwH5fEdujQd6ed5A7Ug" supplier="_r_OHwH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_ln8AIX5fEdujQd6ed5A7Ug" supplier="_sAmAwH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_ln-cYX5fEdujQd6ed5A7Ug" supplier="_r-yp8H5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_loA4oH5fEdujQd6ed5A7Ug" supplier="_r8CQ4H5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_loG_QH5fEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_9vB78H5fEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_-K0gEH5fEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_-nSZoH5fEdujQd6ed5A7Ug" supplier="_r_OHwH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_-nUO0X5fEdujQd6ed5A7Ug" supplier="_sAmAwH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_-nWrEH5fEdujQd6ed5A7Ug" supplier="_r-yp8H5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_-nYgQX5fEdujQd6ed5A7Ug" supplier="_r8CQ4H5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_-nfN8H5fEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_BYTvwH5gEdujQd6ed5A7Ug" supplier="_r_OHwH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_BYWMAX5gEdujQd6ed5A7Ug" supplier="_sAmAwH5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_BYYBMX5gEdujQd6ed5A7Ug" supplier="_r-yp8H5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_BYadcH5gEdujQd6ed5A7Ug" supplier="_r8CQ4H5eEdujQd6ed5A7Ug" client="_sAJ74H5eEdujQd6ed5A7Ug"/>
+  <packagedElement xmi:type="uml:Usage" xmi:id="_BYhLIH5gEdujQd6ed5A7Ug">
+    <supplier xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l_Z6YH5eEdujQd6ed5A7Ug"/>
+    <client xmi:type="uml:Package" href="platform:/resource/GdataUml/.repository.uml2#_l84K0H5eEdujQd6ed5A7Ug"/>
+  </packagedElement>
+</uml:Model>
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/extension/GOMExtensionFactory.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/extension/GOMExtensionFactory.java
new file mode 100644
index 0000000..eddcfdf
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/extension/GOMExtensionFactory.java
@@ -0,0 +1,35 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core.extension;
+
+import java.util.List;
+
+import javax.xml.namespace.QName;
+
+import org.apache.lucene.gdata.gom.GOMExtension;
+import org.apache.lucene.gdata.gom.GOMNamespace;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public interface GOMExtensionFactory {
+
+	public abstract List<GOMNamespace> getNamespaces();
+
+	public abstract GOMExtension canHandleExtensionElement(QName name);
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/utils/AtomParserUtils.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/utils/AtomParserUtils.java
new file mode 100644
index 0000000..4154942
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/utils/AtomParserUtils.java
@@ -0,0 +1,174 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core.utils;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.util.regex.Pattern;
+
+import org.apache.lucene.gdata.gom.AtomMediaType;
+import org.apache.lucene.gdata.gom.GOMLink;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class AtomParserUtils {
+	private static final Pattern ATOM_MEDIA_TYPE_PATTERN = Pattern
+			.compile(".+/.+");
+
+	/**
+	 * Replaces all xml character with the corresponding entity.
+	 * 
+	 * <ul>
+	 * <li>&lt;!ENTITY lt &quot;&amp;#38;#60;&quot;&gt;</li>
+	 * <li>&lt;!ENTITY gt &quot;&amp;#62;&quot;&gt;</li>
+	 * <li>&lt;!ENTITY amp &quot;&amp;#38;#38;&quot;&gt;</li>
+	 * <li>&lt;!ENTITY apos &quot;&amp;#39;&quot;&gt;</li>
+	 * <li>&lt;!ENTITY quot &quot;&amp;#34;&quot;&gt;</li>
+	 * </ul>
+	 * 
+	 * see <a
+	 * href="http://www.w3.org/TR/2006/REC-xml-20060816/#intern-replacement">W3C
+	 * specification</a>
+	 * 
+	 * @param aString -
+	 *            a string may container xml characters like '<'
+	 * @return the input string with escaped xml characters
+	 */
+	public static String escapeXMLCharacter(String aString) {
+		StringBuilder builder = new StringBuilder();
+		char[] cs = aString.toCharArray();
+		for (int i = 0; i < cs.length; i++) {
+			switch (cs[i]) {
+			case '<':
+				builder.append("&lt;");
+				break;
+			case '>':
+				builder.append("&gt;");
+				break;
+			case '"':
+				builder.append("&quot;");
+				break;
+			case '\'':
+				builder.append("&apos;");
+				break;
+			case '&':
+				builder.append("&amp;");
+				break;
+			case '\0':
+				// this breaks some xml serializer like soap serializer -->
+				// remove it
+				break;
+			default:
+				builder.append(cs[i]);
+			}
+		}
+
+		return builder.toString();
+
+	}
+
+	/**
+	 * @param aMediaType
+	 * @return
+	 */
+	public static boolean isAtomMediaType(String aMediaType) {
+		return (aMediaType == null || aMediaType.length() < 3) ? false
+				: ATOM_MEDIA_TYPE_PATTERN.matcher(aMediaType).matches();
+	}
+
+	/**
+	 * @param aMediaType
+	 * @return
+	 */
+	public static AtomMediaType getAtomMediaType(String aMediaType) {
+		if (aMediaType == null || !isAtomMediaType(aMediaType))
+			throw new IllegalArgumentException(
+					"aMediaType must be a media type and  not be null ");
+		if (aMediaType.endsWith("+xml") || aMediaType.endsWith("/xml"))
+			return AtomMediaType.XML;
+		if (aMediaType.startsWith("text/"))
+			return AtomMediaType.TEXT;
+		return AtomMediaType.BINARY;
+	}
+
+	/**
+	 * @param xmlBase
+	 * @param atomUri
+	 * @return
+	 * @throws URISyntaxException
+	 */
+	public static String getAbsolutAtomURI(String xmlBase, String atomUri)
+			throws URISyntaxException {
+		if (atomUri == null)
+			throw new IllegalArgumentException("atomUri must not be null");
+		if (atomUri.startsWith("www."))
+			atomUri = "http://" + atomUri;
+		URI aUri = new URI(atomUri);
+
+		if (xmlBase == null || xmlBase.length() == 0) {
+			if (!aUri.isAbsolute()) {
+				throw new URISyntaxException(atomUri,
+						" -- no xml:base specified atom uri must be an absolute url");
+			}
+		}
+
+		return atomUri;
+	}
+
+	/**
+	 * Compares two links with rel attribute "alternate" Checks if href and type
+	 * are equal
+	 * 
+	 * @param left -
+	 *            left link to compare
+	 * @param right -
+	 *            right link to compare
+	 * @return <code>true</code> if and only if href and type are equal,
+	 *         otherwise <code>false</code>
+	 */
+	public static boolean compareAlternateLinks(GOMLink left, GOMLink right) {
+		if ((left.getType() == null) ^ right.getType() == null
+				|| (left.getType() == null && right.getType() == null)) {
+			return false;
+		} else {
+			if (!left.getType().equalsIgnoreCase(right.getType()))
+				return false;
+		}
+
+		if (((left.getHrefLang() == null) ^ right.getHrefLang() == null)
+				|| (left.getHrefLang() == null && right.getHrefLang() == null)) {
+			return false;
+		} else {
+			if (!left.getHrefLang().equalsIgnoreCase(right.getHrefLang()))
+				return false;
+		}
+		return true;
+
+	}
+
+	public static void main(String[] args) {
+		// String s = new String(
+		// "<!ENTITY lt \"&#38;#60;\"><!ENTITY gt \"&#62;\"><!ENTITY amp
+		// \"&#38;#38;\"><!ENTITY apos \"&#39;\"><!ENTITY quot \"&#34;\">");
+		// System.out.println(escapeXMLCharacter(s));
+		//		
+		System.out.println(isAtomMediaType("t/h"));
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/utils/GOMUtils.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/utils/GOMUtils.java
new file mode 100644
index 0000000..28d374f
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/core/utils/GOMUtils.java
@@ -0,0 +1,424 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core.utils;
+
+import java.math.BigDecimal;
+import java.util.Calendar;
+import java.util.List;
+import java.util.TimeZone;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import org.apache.lucene.gdata.gom.ContentType;
+import org.apache.lucene.gdata.gom.GOMAttribute;
+import org.apache.lucene.gdata.gom.GOMLink;
+import org.apache.lucene.gdata.gom.GOMNamespace;
+import org.apache.lucene.gdata.gom.core.GDataParseException;
+import org.apache.lucene.gdata.gom.core.GOMAttributeImpl;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class GOMUtils {
+
+	/*
+	 * Possible values 2003-12-13T18:30:02Z 2003-12-13T18:30:02.25Z
+	 * 2003-12-13T18:30:02+01:00 2003-12-13T18:30:02.25+01:00
+	 */
+	private static final Pattern RFC3339_DATE_PATTERN = Pattern.compile(
+			"(\\d\\d\\d\\d)" + // #YEAR
+					"\\-(\\d\\d)" + // #MONTH
+					"\\-(\\d\\d)[Tt]" + // #DAY
+					"(\\d\\d)" + // #HOURS
+					":(\\d\\d)" + // #MINUTES
+					":(\\d\\d)" + // #SECONDS
+					"(\\.(\\d+))?" + // #MILLISorless
+					"([Zz]|((\\+|\\-)(\\d\\d):(\\d\\d)))?"// #TIMEZONESHIFT
+			, Pattern.COMMENTS);
+
+	static final String ATTRIBUTE_TYPE = "type";
+
+	static final GOMAttribute TEXT_TYPE;
+
+	static final GOMAttribute HTML_TYPE;
+
+	static final GOMAttribute XHTML_TYPE;
+
+	static final GOMAttribute TEXT_TYPE_DEFAULT_NS;
+
+	static final GOMAttribute HTML_TYPE_DEFAULT_NS;
+
+	static final GOMAttribute XHTML_TYPE_DEFAULT_NS;
+
+	static {
+		TEXT_TYPE = new GOMAttributeImpl(GOMNamespace.ATOM_NS_URI,
+				GOMNamespace.ATOM_NS_PREFIX, ATTRIBUTE_TYPE, ContentType.TEXT
+						.name().toLowerCase());
+		HTML_TYPE = new GOMAttributeImpl(GOMNamespace.ATOM_NS_URI,
+				GOMNamespace.ATOM_NS_PREFIX, ATTRIBUTE_TYPE, ContentType.HTML
+						.name().toLowerCase());
+		XHTML_TYPE = new GOMAttributeImpl(GOMNamespace.ATOM_NS_URI,
+				GOMNamespace.ATOM_NS_PREFIX, ATTRIBUTE_TYPE, ContentType.XHTML
+						.name().toLowerCase());
+
+		TEXT_TYPE_DEFAULT_NS = new GOMAttributeImpl(ATTRIBUTE_TYPE,
+				ContentType.TEXT.name().toLowerCase());
+		HTML_TYPE_DEFAULT_NS = new GOMAttributeImpl(ATTRIBUTE_TYPE,
+				ContentType.HTML.name().toLowerCase());
+		XHTML_TYPE_DEFAULT_NS = new GOMAttributeImpl(ATTRIBUTE_TYPE,
+				ContentType.XHTML.name().toLowerCase());
+
+	}
+
+	/**
+	 * @param type
+	 * @return
+	 */
+	public static GOMAttribute getAttributeByContentType(ContentType type) {
+		switch (type) {
+		case HTML:
+			return HTML_TYPE;
+		case XHTML:
+			return XHTML_TYPE;
+
+		default:
+			return TEXT_TYPE;
+		}
+
+	}
+
+	/**
+	 * @param type
+	 * @return
+	 */
+	public static GOMAttribute getAttributeByContentTypeDefaultNs(
+			ContentType type) {
+		if (type == null)
+			return TEXT_TYPE_DEFAULT_NS;
+		switch (type) {
+		case HTML:
+			return HTML_TYPE_DEFAULT_NS;
+		case XHTML:
+			return XHTML_TYPE_DEFAULT_NS;
+
+		default:
+			return TEXT_TYPE_DEFAULT_NS;
+		}
+
+	}
+
+	/**
+	 * Builds a atom namespace attribute
+	 * 
+	 * @param aValue
+	 *            attribute value
+	 * @param aName
+	 *            attribute name
+	 * @return a GOMAttribute
+	 */
+	public static GOMAttribute buildAtomAttribute(String aValue, String aName) {
+		return new GOMAttributeImpl(GOMNamespace.ATOM_NS_URI,
+				GOMNamespace.ATOM_NS_PREFIX, aName, aValue);
+	}
+
+	/**
+	 * @param aValue
+	 * @param aName
+	 * @return
+	 */
+	public static GOMAttribute buildDefaultNamespaceAttribute(String aValue,
+			String aName) {
+		return new GOMAttributeImpl(aName, aValue);
+	}
+
+	/**
+	 * @param aValue
+	 * @param aName
+	 * @return
+	 */
+	public static GOMAttribute buildXMLNamespaceAttribute(String aValue,
+			String aName) {
+		return new GOMAttributeImpl(GOMNamespace.XML_NS_URI,
+				GOMNamespace.XML_NS_PREFIX, aName, aValue);
+	}
+
+	/**
+	 * @param aString
+	 * @return
+	 */
+	public static boolean isRfc3339DateFormat(String aString) {
+		Matcher aMatcher = RFC3339_DATE_PATTERN.matcher(aString);
+		return aMatcher.matches();
+	}
+
+	/**
+	 * @param aString
+	 * @return
+	 */
+	public static long parseRfc3339DateFormat(String aString) {
+		if (aString == null)
+			throw new IllegalArgumentException(
+					"Date-Time String must not be null");
+		Matcher aMatcher = RFC3339_DATE_PATTERN.matcher(aString);
+
+		if (!aMatcher.matches()) {
+			throw new GDataParseException(
+					"Invalid RFC3339 date / time pattern -- " + aString);
+		}
+		int grCount = aMatcher.groupCount();
+		if (grCount > 13)
+			throw new GDataParseException(
+					"Invalid RFC3339 date / time pattern -- " + aString);
+
+		Integer timeZoneShift = null;
+		Calendar dateTime = null;
+		try {
+
+			if (aMatcher.group(9) == null) {
+				// skip time zone
+			} else if (aMatcher.group(9).equalsIgnoreCase("Z")) {
+				timeZoneShift = new Integer(0);
+			} else {
+				timeZoneShift = new Integer((Integer
+						.valueOf(aMatcher.group(12)) * 60 + Integer
+						.valueOf(aMatcher.group(13))));
+				if (aMatcher.group(11).equals("-")) {
+					timeZoneShift = new Integer(-timeZoneShift.intValue());
+				}
+			}
+
+			dateTime = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
+			;
+			dateTime.clear();
+			dateTime.set(Integer.valueOf(aMatcher.group(1)), Integer
+					.valueOf(aMatcher.group(2)) - 1, Integer.valueOf(aMatcher
+					.group(3)), Integer.valueOf(aMatcher.group(4)), Integer
+					.valueOf(aMatcher.group(5)), Integer.valueOf(aMatcher
+					.group(6)));
+			// seconds with milliseconds
+			if (aMatcher.group(8) != null && aMatcher.group(8).length() > 0) {
+
+				dateTime.set(Calendar.MILLISECOND, new BigDecimal("0."/*
+																		 * use
+																		 * big
+																		 * dec
+																		 * this
+																		 * could
+																		 * be
+																		 * big!!
+																		 */
+						+ aMatcher.group(8)).movePointRight(3).intValue());
+			}
+		} catch (NumberFormatException e) {
+			throw new GDataParseException(
+					"Invalid RFC3339 date / time pattern -- " + aString, e);
+		}
+
+		long retVal = dateTime.getTimeInMillis();
+		if (timeZoneShift != null) {
+			retVal -= timeZoneShift.intValue() * 60000;
+		}
+
+		return retVal;
+	}
+
+	/**
+	 * @param aMillisecondLong
+	 * @return
+	 */
+	public static String buildRfc3339DateFormat(long aMillisecondLong) {
+		Calendar instance = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
+		instance.setTimeInMillis(aMillisecondLong);
+
+		StringBuilder builder = new StringBuilder();
+		// 2003-12-13T18:30:02.25+01:00
+		int time = 0;
+		time = instance.get(Calendar.YEAR);
+		if (time < 1000)
+			builder.append("0");
+		if (time < 100)
+			builder.append("0");
+		if (time < 10)
+			builder.append("0");
+		builder.append(time);
+		builder.append('-');
+		time = instance.get(Calendar.MONTH);
+		if (time < 10)
+			builder.append(0);
+		builder.append(time);
+		builder.append('-');
+		time = instance.get(Calendar.DAY_OF_MONTH);
+		if (time < 10)
+			builder.append(0);
+		builder.append(time);
+		builder.append('T');
+		time = instance.get(Calendar.HOUR_OF_DAY);
+		if (time < 10)
+			builder.append(0);
+		builder.append(time);
+		builder.append(':');
+		time = instance.get(Calendar.MINUTE);
+		if (time < 10)
+			builder.append(0);
+		builder.append(time);
+		builder.append(':');
+		time = instance.get(Calendar.SECOND);
+		if (time < 10)
+			builder.append(0);
+		builder.append(time);
+		builder.append('.');
+		builder.append(instance.get(Calendar.MILLISECOND));
+		// this is always GMT offset -> 0
+		builder.append('Z');
+
+		return builder.toString();
+	}
+
+	/**
+	 * @param aMillisecondLong
+	 * @return
+	 */
+	public static String buildRfc822Date(long aMillisecondLong) {
+		/*
+		 * Rather implement it for a special case as use SDF. SDF is very
+		 * expensive to create and not thread safe so it should be synchronized
+		 * of pooled
+		 */
+		Calendar instance = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
+		instance.setTimeInMillis(aMillisecondLong);
+
+		StringBuilder builder = new StringBuilder();
+		// Sun, 06 Aug 2006 00:53:49 +0000
+		// EEE, dd MMM yyyy HH:mm:ss Z
+
+		switch (instance.get(Calendar.DAY_OF_WEEK)) {
+		case Calendar.SUNDAY:
+			builder.append("Sun");
+			break;
+		case Calendar.MONDAY:
+			builder.append("Mon");
+			break;
+		case Calendar.TUESDAY:
+			builder.append("Tue");
+			break;
+		case Calendar.WEDNESDAY:
+			builder.append("Wed");
+			break;
+		case Calendar.THURSDAY:
+			builder.append("Thu");
+			break;
+		case Calendar.FRIDAY:
+			builder.append("Fri");
+			break;
+		case Calendar.SATURDAY:
+			builder.append("Sat");
+			break;
+		default:
+			break;
+		}
+		builder.append(',');
+		builder.append(' ');
+
+		int time = 0;
+		time = instance.get(Calendar.DAY_OF_MONTH);
+		if (time < 10)
+			builder.append(0);
+		builder.append(time);
+		builder.append(' ');
+		switch (instance.get(Calendar.MONTH)) {
+		case Calendar.JANUARY:
+			builder.append("Jan");
+			break;
+		case Calendar.FEBRUARY:
+			builder.append("Feb");
+			break;
+		case Calendar.MARCH:
+			builder.append("Mar");
+			break;
+		case Calendar.APRIL:
+			builder.append("Apr");
+			break;
+		case Calendar.MAY:
+			builder.append("May");
+			break;
+		case Calendar.JUNE:
+			builder.append("Jun");
+			break;
+		case Calendar.JULY:
+			builder.append("Jul");
+			break;
+		case Calendar.AUGUST:
+			builder.append("Aug");
+			break;
+		case Calendar.SEPTEMBER:
+			builder.append("Sep");
+			break;
+		case Calendar.OCTOBER:
+			builder.append("Oct");
+			break;
+		case Calendar.NOVEMBER:
+			builder.append("Nov");
+			break;
+		case Calendar.DECEMBER:
+			builder.append("Dec");
+			break;
+
+		default:
+			break;
+		}
+		builder.append(' ');
+		time = instance.get(Calendar.YEAR);
+		if (time < 1000)
+			builder.append("0");
+		if (time < 100)
+			builder.append("0");
+		if (time < 10)
+			builder.append("0");
+		builder.append(time);
+		builder.append(' ');
+
+		time = instance.get(Calendar.HOUR_OF_DAY);
+		if (time < 10)
+			builder.append(0);
+		builder.append(time);
+		builder.append(':');
+		time = instance.get(Calendar.MINUTE);
+		if (time < 10)
+			builder.append(0);
+		builder.append(time);
+		builder.append(':');
+		time = instance.get(Calendar.SECOND);
+		if (time < 10)
+			builder.append(0);
+		builder.append(time);
+
+		// this is always GMT offset -> 0
+		builder.append(" +0000");
+		return builder.toString();
+	}
+
+	public GOMLink getHtmlLink(List<GOMLink> links) {
+		for (GOMLink link : links) {
+			if ((link.getRel() == null || link.getRel().equals("alternate"))
+					&& (link.getType() == null || link.getType()
+							.equalsIgnoreCase("html")))
+				return link;
+		}
+		return null;
+	}
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/writer/GOMOutputWriter.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/writer/GOMOutputWriter.java
new file mode 100644
index 0000000..ab7a93d
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/writer/GOMOutputWriter.java
@@ -0,0 +1,199 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.writer;
+
+import java.util.List;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.GOMAttribute;
+import org.apache.lucene.gdata.gom.GOMNamespace;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public interface GOMOutputWriter {
+
+	/**
+	 * Writes a simple element with full namespace
+	 * 
+	 * @param aName -
+	 *            element QName
+	 * @param aList -
+	 *            attribute list
+	 * @param aValue -
+	 *            character value
+	 * @throws XMLStreamException -
+	 *             if a write exception occurs
+	 */
+	public abstract void writeSimpleXMLElement(QName aName,
+			List<GOMAttribute> aList, String aValue) throws XMLStreamException;
+
+	/**
+	 * Writes a simple element with full namespace
+	 * 
+	 * @param aName -
+	 *            element QName
+	 * @param aAttribute -
+	 *            attribute
+	 * @param aValue -
+	 *            character value
+	 * @throws XMLStreamException -
+	 *             if a write exception occurs
+	 */
+	public abstract void writeSimpleXMLElement(QName aName, String aValue,
+			GOMAttribute aAttribute) throws XMLStreamException;
+
+	/**
+	 * Writes a simple element with full namespace
+	 * 
+	 * @param aName -
+	 *            the local name of the element
+	 * @param aAttribute -
+	 *            attribute
+	 * @param aValue -
+	 *            character value
+	 * @throws XMLStreamException -
+	 *             if a write exception occurs
+	 */
+	public abstract void writeSimpleXMLElement(String aName, String aValue,
+			GOMAttribute aAttribute) throws XMLStreamException;
+
+	/**
+	 * Writes a simple element with default namespace
+	 * 
+	 * @param aName -
+	 *            elements name
+	 * @param aList -
+	 *            attribute list
+	 * @param aValue -
+	 *            character value
+	 * @throws XMLStreamException -
+	 *             if a write exception occurs
+	 */
+	public abstract void writeSimpleXMLElement(String aName,
+			List<GOMAttribute> aList, String aValue) throws XMLStreamException;
+
+	/**
+	 * writes a attribute with the attribute namespace Uri
+	 * 
+	 * @param attribute -
+	 *            the attribute
+	 * @throws XMLStreamException -
+	 *             if a write exception occurs
+	 */
+	public abstract void writeAttribute(GOMAttribute attribute)
+			throws XMLStreamException;
+
+	/**
+	 * @param aName
+	 * @param aList
+	 * @throws XMLStreamException
+	 */
+	public abstract void writeStartElement(String aName,
+			List<GOMAttribute> aList) throws XMLStreamException;
+
+	/**
+	 * @param aName
+	 * @param aAttribute
+	 * @throws XMLStreamException
+	 */
+	public abstract void writeStartElement(String aName, GOMAttribute aAttribute)
+			throws XMLStreamException;
+
+	/**
+	 * @param aName
+	 * @throws XMLStreamException
+	 */
+	public abstract void writeStartElement(String aName)
+			throws XMLStreamException;
+
+	/**
+	 * @param aName
+	 * @param aList
+	 * @throws XMLStreamException
+	 */
+	public abstract void writeStartElement(QName aName, List<GOMAttribute> aList)
+			throws XMLStreamException;
+
+	/**
+	 * @throws XMLStreamException
+	 */
+	public abstract void writeEndElement() throws XMLStreamException;
+
+	/**
+	 * @param aContent
+	 * @throws XMLStreamException
+	 */
+	public abstract void writeContent(String aContent)
+			throws XMLStreamException;
+
+	/**
+	 * @param aContent
+	 * @throws XMLStreamException
+	 */
+	public abstract void writeContentUnescaped(String aContent)
+			throws XMLStreamException;
+
+	/**
+	 * @param aNameSpace
+	 * @throws XMLStreamException
+	 */
+	public abstract void writeDefaultNamespace(GOMNamespace aNameSpace)
+			throws XMLStreamException;
+
+	/**
+	 * @param aNameSpace
+	 * @throws XMLStreamException
+	 */
+	public abstract void writeNamespace(GOMNamespace aNameSpace)
+			throws XMLStreamException;
+
+	/**
+	 * @param aString
+	 * @param aString2
+	 * @throws XMLStreamException
+	 */
+	public abstract void writeStartDocument(String aString, String aString2)
+			throws XMLStreamException;
+
+	/**
+	 * Writes a end element tag according to the start element tag
+	 * 
+	 * @throws XMLStreamException -
+	 *             if no start tag has been written or the element stack points
+	 *             to a different element
+	 */
+	public abstract void writeEndDocument() throws XMLStreamException;
+
+	/**
+	 * Flush the GOMWriter
+	 * 
+	 * @throws XMLStreamException
+	 */
+	public abstract void flush() throws XMLStreamException;
+
+	/**
+	 * Closes the GOM Writer
+	 * 
+	 * @throws XMLStreamException
+	 */
+	public abstract void close() throws XMLStreamException;
+
+}
\ No newline at end of file
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/writer/GOMStaxWriter.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/writer/GOMStaxWriter.java
new file mode 100644
index 0000000..db95f12
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/writer/GOMStaxWriter.java
@@ -0,0 +1,302 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.writer;
+
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.io.UnsupportedEncodingException;
+import java.io.Writer;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.FactoryConfigurationError;
+import javax.xml.stream.XMLOutputFactory;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamWriter;
+
+import org.apache.lucene.gdata.gom.GOMAttribute;
+import org.apache.lucene.gdata.gom.GOMNamespace;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class GOMStaxWriter implements GOMOutputWriter {
+	private static final String STAX_OUTPUTFACTORY_KEY = "org.apache.lucene.gdata.gom.writer.GOMXmlOutputFactory";
+
+	private final Set<GOMNamespace> namespaceSet = new HashSet<GOMNamespace>(16);
+
+	private final XMLStreamWriter writer;
+	static {
+		/*
+		 * set the system property to make sure the factory will be found
+		 */
+		String property = System.getProperty(STAX_OUTPUTFACTORY_KEY);
+		if (property == null)
+			System.setProperty(STAX_OUTPUTFACTORY_KEY, STAX_OUTPUTFACTORY_KEY);
+	}
+
+	/**
+	 * @param aOutputStream
+	 * @param encoding
+	 * @throws UnsupportedEncodingException
+	 * @throws XMLStreamException
+	 * @throws FactoryConfigurationError
+	 */
+	public GOMStaxWriter(final OutputStream aOutputStream, String encoding)
+			throws UnsupportedEncodingException, XMLStreamException,
+			FactoryConfigurationError {
+		this(new OutputStreamWriter(aOutputStream, encoding));
+	}
+
+	/**
+	 * Class constructor
+	 * 
+	 * 
+	 * @param aOutputStream -
+	 *            a output stream to write the xml stream to.
+	 * @throws XMLStreamException -
+	 *             if a write exception occurs
+	 * @throws FactoryConfigurationError -
+	 *             if XMLOutputFactory throws an exception
+	 * 
+	 */
+	public GOMStaxWriter(final OutputStream aOutputStream)
+			throws XMLStreamException, FactoryConfigurationError {
+		this(new OutputStreamWriter(aOutputStream));
+	}
+
+	/**
+	 * Class constructor
+	 * 
+	 * @param aWriter -
+	 *            a writer to write the xml stream to.
+	 * @throws XMLStreamException -
+	 *             if a write exception occurs
+	 * @throws FactoryConfigurationError -
+	 *             if XMLOutputFactory throws an exception
+	 */
+	public GOMStaxWriter(final Writer aWriter) throws XMLStreamException,
+			FactoryConfigurationError {
+		if (aWriter == null)
+			throw new IllegalArgumentException("Given writer must not be null");
+
+		this.writer = XMLOutputFactory.newInstance(STAX_OUTPUTFACTORY_KEY,
+				GOMStaxWriter.class.getClassLoader()).createXMLStreamWriter(
+				aWriter);
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#writeSimpleXMLElement(javax.xml.namespace.QName,
+	 *      java.util.List, java.lang.String)
+	 */
+	public void writeSimpleXMLElement(QName aName, List<GOMAttribute> aList,
+			String aValue) throws XMLStreamException {
+		writeStartElement(aName, aList);
+		writeContent(aValue);
+		this.writer.writeEndElement();
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#writeSimpleXMLElement(javax.xml.namespace.QName,
+	 *      java.lang.String, org.apache.lucene.gdata.gom.GOMAttribute)
+	 */
+	public void writeSimpleXMLElement(QName aName, String aValue,
+			GOMAttribute aAttribute) throws XMLStreamException {
+		List<GOMAttribute> list = null;
+		if (aAttribute != null) {
+			list = new ArrayList<GOMAttribute>(1);
+			list.add(aAttribute);
+		}
+		writeSimpleXMLElement(aName, list, aValue);
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#writeSimpleXMLElement(java.lang.String,
+	 *      java.lang.String, org.apache.lucene.gdata.gom.GOMAttribute)
+	 */
+	public void writeSimpleXMLElement(String aName, String aValue,
+			GOMAttribute aAttribute) throws XMLStreamException {
+		List<GOMAttribute> list = null;
+		if (aAttribute != null) {
+			list = new ArrayList<GOMAttribute>(1);
+			list.add(aAttribute);
+		}
+		writeSimpleXMLElement(aName, list, aValue);
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#writeSimpleXMLElement(java.lang.String,
+	 *      java.util.List, java.lang.String)
+	 */
+	public void writeSimpleXMLElement(String aName, List<GOMAttribute> aList,
+			String aValue) throws XMLStreamException {
+		writeStartElement(aName, aList);
+		writeContent(aValue);
+		this.writer.writeEndElement();
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#writeAttribute(org.apache.lucene.gdata.gom.GOMAttribute)
+	 */
+	public void writeAttribute(GOMAttribute attribute)
+			throws XMLStreamException {
+		if (attribute.hasDefaultNamespace())
+			this.writer.writeAttribute(attribute.getLocalName(), attribute
+					.getTextValue());
+		else
+			this.writer.writeAttribute(attribute.getQname().getPrefix(),
+					attribute.getQname().getNamespaceURI(), attribute
+							.getLocalName(), attribute.getTextValue());
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#writeStartElement(java.lang.String,
+	 *      java.util.List)
+	 */
+	public void writeStartElement(String aName, List<GOMAttribute> aList)
+			throws XMLStreamException {
+		this.writer.writeStartElement(aName);
+		if (aList != null)
+			for (GOMAttribute attribute : aList) {
+				writeAttribute(attribute);
+			}
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#writeStartElement(java.lang.String,
+	 *      org.apache.lucene.gdata.gom.GOMAttribute)
+	 */
+	public void writeStartElement(String aName, GOMAttribute aAttribute)
+			throws XMLStreamException {
+		this.writer.writeStartElement(aName);
+		writeAttribute(aAttribute);
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#writeStartElement(java.lang.String)
+	 */
+	public void writeStartElement(String aName) throws XMLStreamException {
+		this.writer.writeStartElement(aName);
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#writeStartElement(javax.xml.namespace.QName,
+	 *      java.util.List)
+	 */
+	public void writeStartElement(QName aName, List<GOMAttribute> aList)
+			throws XMLStreamException {
+		this.writer.writeStartElement(aName.getPrefix(), aName.getLocalPart(),
+				aName.getNamespaceURI());
+		if (aList != null)
+			for (GOMAttribute attribute : aList) {
+				writeAttribute(attribute);
+			}
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#writeEndElement()
+	 */
+	public void writeEndElement() throws XMLStreamException {
+		this.writer.writeEndElement();
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#writeContent(java.lang.String)
+	 */
+	public void writeContent(String aContent) throws XMLStreamException {
+		if (aContent != null) {
+			char[] cs = aContent.toCharArray();
+			this.writer.writeCharacters(cs, 0, cs.length);
+		}
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#writeContentUnescaped(java.lang.String)
+	 */
+	public void writeContentUnescaped(String aContent)
+			throws XMLStreamException {
+		if (aContent != null)
+			this.writer.writeCharacters(aContent);
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#writeDefaultNamespace(java.lang.String)
+	 */
+	public void writeDefaultNamespace(String aNsUri) throws XMLStreamException {
+		this.writer.writeDefaultNamespace(aNsUri);
+
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#writeDefaultNamespace(org.apache.lucene.gdata.gom.GOMNamespace)
+	 */
+	public void writeDefaultNamespace(GOMNamespace aNameSpace)
+			throws XMLStreamException {
+		if (aNameSpace != null)
+			writeDefaultNamespace(aNameSpace.getNamespaceUri());
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#writeNamespace(org.apache.lucene.gdata.gom.GOMNamespace)
+	 */
+	public void writeNamespace(GOMNamespace aNameSpace)
+			throws XMLStreamException {
+		if (aNameSpace == null)
+			return;
+		if (this.namespaceSet.contains(aNameSpace))
+			return;
+		this.namespaceSet.add(aNameSpace);
+		this.writer.writeNamespace(aNameSpace.getNamespacePrefix(), aNameSpace
+				.getNamespaceUri());
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#writeStartDocument(java.lang.String,
+	 *      java.lang.String)
+	 */
+	public void writeStartDocument(String aString, String aString2)
+			throws XMLStreamException {
+		this.writer.writeStartDocument(aString, aString2);
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#writeEndDocument()
+	 */
+	public void writeEndDocument() throws XMLStreamException {
+		this.writer.writeEndDocument();
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#flush()
+	 */
+	public void flush() throws XMLStreamException {
+		this.writer.flush();
+	}
+
+	/**
+	 * @see org.apache.lucene.gdata.gom.writer.GOMOutputWriter#close()
+	 */
+	public void close() throws XMLStreamException {
+		this.writer.close();
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/writer/GOMXmlOutputFactory.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/writer/GOMXmlOutputFactory.java
new file mode 100644
index 0000000..c2ed474
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/writer/GOMXmlOutputFactory.java
@@ -0,0 +1,82 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.writer;
+
+import java.io.Writer;
+
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamWriter;
+
+import com.bea.xml.stream.ConfigurationContextBase;
+import com.bea.xml.stream.XMLOutputFactoryBase;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class GOMXmlOutputFactory extends XMLOutputFactoryBase {
+	protected ConfigurationContextBase config = new ConfigurationContextBase();
+
+	/**
+	 * @see com.bea.xml.stream.XMLOutputFactoryBase#createXMLStreamWriter(java.io.OutputStream,
+	 *      java.lang.String)
+	 */
+	@Override
+	public XMLStreamWriter createXMLStreamWriter(Writer aWriter)
+			throws XMLStreamException {
+		GOMXmlWriter b = new GOMXmlWriter(aWriter);
+		b.setConfigurationContext(config);
+		return b;
+	}
+
+	/**
+	 * @see com.bea.xml.stream.XMLOutputFactoryBase#setProperty(java.lang.String,
+	 *      java.lang.Object)
+	 */
+	public void setProperty(java.lang.String name, Object value) {
+		config.setProperty(name, value);
+	}
+
+	/**
+	 * @see com.bea.xml.stream.XMLOutputFactoryBase#getProperty(java.lang.String)
+	 */
+	public Object getProperty(java.lang.String name) {
+		return config.getProperty(name);
+	}
+
+	/**
+	 * @see com.bea.xml.stream.XMLOutputFactoryBase#isPrefixDefaulting()
+	 */
+	public boolean isPrefixDefaulting() {
+		return config.isPrefixDefaulting();
+	}
+
+	/**
+	 * @see com.bea.xml.stream.XMLOutputFactoryBase#setPrefixDefaulting(boolean)
+	 */
+	public void setPrefixDefaulting(boolean value) {
+		config.setPrefixDefaulting(value);
+	}
+
+	/**
+	 * @see com.bea.xml.stream.XMLOutputFactoryBase#isPropertySupported(java.lang.String)
+	 */
+	public boolean isPropertySupported(String name) {
+		return config.isPropertySupported(name);
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/writer/GOMXmlWriter.java b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/writer/GOMXmlWriter.java
new file mode 100644
index 0000000..7557602
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/java/org/apache/lucene/gdata/gom/writer/GOMXmlWriter.java
@@ -0,0 +1,86 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.writer;
+
+import java.io.Writer;
+import java.nio.charset.CharsetEncoder;
+
+import javax.xml.stream.XMLStreamException;
+
+import com.bea.xml.stream.XMLWriterBase;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class GOMXmlWriter extends XMLWriterBase {
+	private CharsetEncoder encoder;
+
+	/**
+	 * 
+	 */
+	public GOMXmlWriter() {
+		super();
+	}
+
+	/**
+	 * @param arg0
+	 */
+	public GOMXmlWriter(Writer arg0) {
+		super(arg0);
+	}
+
+	/**
+	 * @see com.bea.xml.stream.XMLWriterBase#writeCharacters(java.lang.String)
+	 */
+	@Override
+	public void writeCharacters(String aString) throws XMLStreamException {
+		closeStartElement();
+		char[] ch = aString.toCharArray();
+		escapeCharacters(ch, 0, ch.length);
+	}
+
+	/*
+	 * The default implementation escapes all xml chars in the writeCharacters
+	 * method. This is not expected for xhtml blobs. To make it easier to write
+	 * xhtml blobs the writeCharacters(String) mehtod will be reimplemented for
+	 * internal use.
+	 */
+	private void escapeCharacters(char chars[], int start, int length)
+			throws XMLStreamException {
+		for (int i = 0; i < length; i++) {
+			final char c = chars[i + start];
+
+			if (c < 32) {
+				if ((c != '\t' && c != '\n')) {
+					write("&#");
+					write(Integer.toString(c));
+					write(';');
+					continue;
+				}
+			} else if (c > 127 && encoder != null && !encoder.canEncode(c)) {
+				write("&#");
+				write(Integer.toString(c));
+				write(';');
+				continue;
+			}
+
+			write(c);
+		}
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/GOMNamespaceTest.java b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/GOMNamespaceTest.java
new file mode 100644
index 0000000..887d6a2
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/GOMNamespaceTest.java
@@ -0,0 +1,55 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom;
+
+import junit.framework.TestCase;
+
+/**
+ * Testcase for GOMNamespace
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class GOMNamespaceTest extends TestCase {
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.GOMNamespace.GOMNamespace(String, String)'
+	 */
+	public void testGOMNamespace() {
+		try {
+			GOMNamespace namespace = new GOMNamespace(null, "a");
+			fail("uri is null");
+		} catch (IllegalArgumentException e) {
+			//
+		}
+		try {
+			new GOMNamespace("a", null);
+		} catch (Exception e) {
+			fail("unexp. exc");
+		}
+
+		GOMNamespace namespace = new GOMNamespace(GOMNamespace.ATOM_NS_URI,
+				GOMNamespace.ATOM_NS_PREFIX);
+		assertEquals(GOMNamespace.ATOM_NS_PREFIX, namespace
+				.getNamespacePrefix());
+		assertEquals(GOMNamespace.ATOM_NS_URI, namespace.getNamespaceUri());
+		//		
+
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/ArbitraryGOMXmlTest.java b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/ArbitraryGOMXmlTest.java
new file mode 100644
index 0000000..0d0773e
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/ArbitraryGOMXmlTest.java
@@ -0,0 +1,179 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import java.io.StringWriter;
+import java.util.List;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.FactoryConfigurationError;
+import javax.xml.stream.XMLStreamException;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.gdata.gom.GOMAttribute;
+import org.apache.lucene.gdata.gom.writer.GOMStaxWriter;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class ArbitraryGOMXmlTest extends TestCase {
+	private ArbitraryGOMXml arbXML;
+
+	private QName name = new QName("testme");
+
+	protected void setUp() throws Exception {
+		super.setUp();
+
+		arbXML = new ArbitraryGOMXml(name);
+	}
+
+	protected void tearDown() throws Exception {
+		super.tearDown();
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.ArbitraryGOMXml.getChildParser(QName)'
+	 */
+	public void testGetChildParser() {
+
+		try {
+			this.arbXML.getChildParser(null);
+			fail("qname is null");
+		} catch (GDataParseException e) {
+			assertEquals(0, this.arbXML.getChildren().size());
+		}
+		AtomParser childParser = this.arbXML.getChildParser(this.name);
+		assertTrue(childParser instanceof ArbitraryGOMXml);
+
+		assertEquals(name, ((ArbitraryGOMXml) childParser).getQname());
+		assertEquals(name.getLocalPart(), ((ArbitraryGOMXml) childParser)
+				.getLocalName());
+		assertEquals(1, this.arbXML.getChildren().size());
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.ArbitraryGOMXml.processAttribute(QName,
+	 * String)'
+	 */
+	public void testProcessAttribute() {
+		try {
+			this.arbXML.processAttribute(null, "test");
+			fail("qname is null");
+
+		} catch (GDataParseException e) {
+			assertTrue(this.arbXML.getAttributes().size() == 0);
+		}
+		this.arbXML.processAttribute(name, "testme");
+		{
+			List<GOMAttribute> attributes = this.arbXML.getAttributes();
+			assertTrue(attributes.size() == 1);
+			GOMAttribute attribute = attributes.get(0);
+			assertNotNull(attribute);
+			assertEquals(name, attribute.getQname());
+			assertEquals(name.getLocalPart(), attribute.getLocalName());
+			assertEquals("testme", attribute.getTextValue());
+		}
+
+		{
+			this.arbXML.processAttribute(name, null);
+			List<GOMAttribute> attributes = this.arbXML.getAttributes();
+			assertTrue(attributes.size() == 2);
+			GOMAttribute attribute = attributes.get(1);
+			assertNotNull(attribute);
+			assertEquals(name, attribute.getQname());
+			assertEquals(name.getLocalPart(), attribute.getLocalName());
+			assertEquals("", attribute.getTextValue());
+		}
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.ArbitraryGOMXml.processElementValue(String)'
+	 */
+	public void testProcessElementValue() {
+		try {
+			this.arbXML.processElementValue(null);
+			fail("name is null");
+		} catch (GDataParseException e) {
+			// 
+		}
+		this.arbXML.processElementValue("test value");
+
+		try {
+			this.arbXML.processElementValue("test value");
+			fail("value is already set");
+		} catch (GDataParseException e) {
+			//
+		}
+		assertEquals("test value", this.arbXML.getTextValue());
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.ArbitraryGOMXml.ArbitraryGOMXml(QName)'
+	 */
+	public void testArbitraryGOMXml() {
+		try {
+			new ArbitraryGOMXml(null);
+			fail("qname is null");
+		} catch (IllegalArgumentException e) {
+
+		}
+		ArbitraryGOMXml xml = new ArbitraryGOMXml(name);
+		assertEquals(name, xml.getQname());
+		assertEquals(name.getLocalPart(), xml.getLocalName());
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.ArbitraryGOMXml.writeAtomOutput(GOMWriter)'
+	 */
+	public void testWriteAtomOutput() throws XMLStreamException,
+			FactoryConfigurationError {
+		{
+			StringWriter writer = new StringWriter();
+			GOMOutputWriter w = new GOMStaxWriter(writer);
+			this.arbXML.writeAtomOutput(w);
+			assertNotNull(w.toString());
+			assertEquals("<" + this.name.getLocalPart() + "/>", writer
+					.toString());
+		}
+		try {
+			this.arbXML.writeAtomOutput(null);
+			fail("writer is null");
+
+		} catch (NullPointerException e) {
+			// 
+		}
+		{
+			this.arbXML.processAttribute(name, "testme1");
+			this.arbXML.processElementValue("testme2");
+			StringWriter writer = new StringWriter();
+			GOMOutputWriter w = new GOMStaxWriter(writer);
+			this.arbXML.writeAtomOutput(w);
+			assertEquals("<" + this.name.getLocalPart()
+					+ " testme=\"testme1\">" + "testme2" + "</"
+					+ this.name.getLocalPart() + ">", writer.toString());
+		}
+	}
+}
diff --git a/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/AtomUriElementTest.java b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/AtomUriElementTest.java
new file mode 100644
index 0000000..9b44f73
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/AtomUriElementTest.java
@@ -0,0 +1,136 @@
+package org.apache.lucene.gdata.gom.core;
+
+import java.io.StringWriter;
+
+import javax.xml.stream.FactoryConfigurationError;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.GOMIcon;
+import org.apache.lucene.gdata.gom.GOMLogo;
+import org.apache.lucene.gdata.gom.writer.GOMStaxWriter;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+import junit.framework.TestCase;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class AtomUriElementTest extends TestCase {
+	GOMIconImpl iconImpl;
+
+	GOMLogoImpl logoImpl;
+
+	protected void setUp() throws Exception {
+		this.iconImpl = new GOMIconImpl();
+		this.logoImpl = new GOMLogoImpl();
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.AtomUriElement.processEndElement()'
+	 */
+	public void testProcessEndElement() {
+		try {
+			this.iconImpl.processEndElement();
+			fail("no text value");
+		} catch (GDataParseException e) {
+			assertTrue(e.getMessage().indexOf("requires a element value") > 0);
+		}
+
+		try {
+			this.iconImpl.setTextValue("test");
+
+			this.iconImpl.processEndElement();
+			fail("no text value");
+		} catch (GDataParseException e) {
+			assertTrue(e.getMessage().indexOf("must be a") > 0);
+		}
+		try {
+			this.iconImpl.setTextValue("/test");
+
+			this.iconImpl.processEndElement();
+			fail("no text value");
+		} catch (GDataParseException e) {
+			assertTrue(e.getMessage().indexOf("must be a") > 0);
+		}
+		this.iconImpl.xmlBase = "http://www.apache.org";
+		this.iconImpl.setTextValue("/test");
+
+		this.iconImpl.processEndElement();
+
+		this.iconImpl.xmlBase = null;
+		this.iconImpl.setTextValue("http://www.apache.org/test");
+
+	}
+
+	public void testConstructor() {
+		assertEquals(GOMIcon.LOCALNAME, this.iconImpl.getLocalName());
+		assertEquals(GOMIcon.LOCALNAME, this.iconImpl.getQname().getLocalPart());
+		assertEquals(GOMLogo.LOCALNAME, this.logoImpl.getLocalName());
+		assertEquals(GOMLogo.LOCALNAME, this.logoImpl.getQname().getLocalPart());
+	}
+
+	public void testWriteRssOutput() throws XMLStreamException,
+			FactoryConfigurationError {
+
+		{
+			StringWriter stW = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(stW);
+			this.iconImpl.writeRssOutput(writer);
+			assertEquals("<url/>", stW.toString());
+		}
+		{
+			StringWriter stW = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(stW);
+			this.iconImpl.setTextValue("test");
+			this.iconImpl.writeRssOutput(writer);
+			assertEquals("<url>test</url>", stW.toString());
+		}
+
+		{
+			StringWriter stW = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(stW);
+			this.logoImpl.writeRssOutput(writer);
+			assertEquals("<url/>", stW.toString());
+		}
+		{
+			StringWriter stW = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(stW);
+			this.logoImpl.setTextValue("test");
+			this.logoImpl.writeRssOutput(writer);
+			assertEquals("<url>test</url>", stW.toString());
+		}
+	}
+
+	public void testWriteAtomOutput() throws XMLStreamException {
+		{
+			StringWriter stW = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(stW);
+			this.iconImpl.writeAtomOutput(writer);
+			assertEquals("<icon/>", stW.toString());
+		}
+		{
+			StringWriter stW = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(stW);
+			this.iconImpl.setTextValue("test");
+			this.iconImpl.writeAtomOutput(writer);
+			assertEquals("<icon>test</icon>", stW.toString());
+		}
+
+		{
+			StringWriter stW = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(stW);
+			this.logoImpl.writeAtomOutput(writer);
+			assertEquals("<logo/>", stW.toString());
+		}
+		{
+			StringWriter stW = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(stW);
+			this.logoImpl.setTextValue("test");
+			this.logoImpl.writeAtomOutput(writer);
+			assertEquals("<logo>test</logo>", stW.toString());
+		}
+	}
+}
diff --git a/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMAttributeImplTest.java b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMAttributeImplTest.java
new file mode 100644
index 0000000..094b066
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMAttributeImplTest.java
@@ -0,0 +1,76 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.gom.core;
+
+import javax.xml.namespace.QName;
+
+import junit.framework.TestCase;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class GOMAttributeImplTest extends TestCase {
+	protected GOMAttributeImpl gomAttribute;
+
+	protected void setUp() throws Exception {
+		gomAttribute = new GOMAttributeImpl("test", "test");
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMAttributeImpl.GOMAttributeImpl(String,
+	 * String)'
+	 */
+	public void testGOMAttributeImplStringString() {
+		GOMAttributeImpl impl = new GOMAttributeImpl("test", "test");
+		assertTrue(impl.hasDefaultNamespace());
+		assertTrue(impl.getLocalName().equals(impl.getTextValue()));
+		assertEquals("test", impl.getLocalName());
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMAttributeImpl.GOMAttributeImpl(String,
+	 * String, String, String)'
+	 */
+	public void testGOMAttributeImplStringStringStringString() {
+		GOMAttributeImpl impl = new GOMAttributeImpl("www.apache.org", "ap",
+				"test", "test");
+		assertFalse(impl.hasDefaultNamespace());
+		assertTrue(impl.getLocalName().equals(impl.getTextValue()));
+		assertEquals("test", impl.getLocalName());
+		assertEquals("www.apache.org", impl.getQname().getNamespaceURI());
+		assertEquals("ap", impl.getQname().getPrefix());
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMAttributeImpl.getQname()'
+	 */
+	public void testGetQname() {
+		QName qname = gomAttribute.getQname();
+		assertSame(qname, gomAttribute.getQname());
+		assertTrue(gomAttribute.hasDefaultNamespace());
+		gomAttribute.setNamespaceUri("something else");
+		assertNotSame(qname, gomAttribute.getQname());
+		assertFalse(gomAttribute.hasDefaultNamespace());
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMAuthorImplTest.java b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMAuthorImplTest.java
new file mode 100644
index 0000000..04d4888
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMAuthorImplTest.java
@@ -0,0 +1,84 @@
+package org.apache.lucene.gdata.gom.core;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+import java.io.StringWriter;
+
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.GOMAuthor;
+import org.apache.lucene.gdata.gom.writer.GOMStaxWriter;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+import junit.framework.TestCase;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class GOMAuthorImplTest extends TestCase {
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMAuthorImpl.writeRssOutput(GOMWriter)'
+	 */
+	public void testWriteRssOutput() throws XMLStreamException {
+		GOMAuthorImpl impl = new GOMAuthorImpl();
+		try {
+			impl.writeRssOutput(null);
+			fail("writer is null");
+		} catch (GDataParseException e) {
+		}
+		StringWriter writer2 = new StringWriter();
+
+		GOMOutputWriter writer = new GOMStaxWriter(writer2);
+		impl.writeRssOutput(writer, "test");
+		writer.flush();
+		writer2.flush();
+
+		assertEquals("<test></test>", writer2.toString());
+		impl.setEmail("simonw@apache.org");
+		impl.setUri("someuri");
+		writer.close();
+
+		writer2 = new StringWriter();
+		writer = new GOMStaxWriter(writer2);
+		impl.writeRssOutput(writer);
+		writer.flush();
+		writer2.flush();
+		assertTrue(writer2.toString().length() > 0);
+
+		assertEquals("<" + GOMAuthor.LOCALNAME + ">" + impl.getEmail() + "</"
+				+ GOMAuthor.LOCALNAME + ">", writer2.toString());
+
+		writer.close();
+
+		impl.setName("simonw");
+		writer2 = new StringWriter();
+		writer = new GOMStaxWriter(writer2);
+		impl.writeRssOutput(writer);
+		writer.flush();
+		writer2.flush();
+		assertTrue(writer2.toString().length() > 0);
+
+		assertEquals("<" + GOMAuthor.LOCALNAME + ">" + impl.getEmail() + "("
+				+ impl.getName() + ")</" + GOMAuthor.LOCALNAME + ">", writer2
+				.toString());
+
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMCategoryTest.java b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMCategoryTest.java
new file mode 100644
index 0000000..7da016f
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMCategoryTest.java
@@ -0,0 +1,262 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.gom.core;
+
+import java.io.StringWriter;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.GOMNamespace;
+import org.apache.lucene.gdata.gom.writer.GOMStaxWriter;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+import junit.framework.TestCase;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class GOMCategoryTest extends TestCase {
+	private QName qname = new QName(GOMNamespace.ATOM_NS_URI, "testme", "");
+
+	GOMCategoryImpl cat;
+
+	protected void setUp() throws Exception {
+		this.cat = new GOMCategoryImpl();
+	}
+
+	protected void tearDown() throws Exception {
+		super.tearDown();
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMCategoryImpl.writeAtomOutput(GOMWriter)'
+	 */
+	public void testWriteAtomOutput() throws XMLStreamException {
+		try {
+			this.cat.writeAtomOutput(null);
+			fail("wirter is null");
+		} catch (NullPointerException e) {
+			// 
+		}
+		{
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			this.cat.writeAtomOutput(writer);
+			assertEquals("<category term=\"\"/>", strWriter.toString());
+
+		}
+
+		{
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			this.cat.term = "test";
+			this.cat.writeAtomOutput(writer);
+			assertEquals("<category term=\"test\"/>", strWriter.toString());
+
+		}
+
+		{
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			this.cat.label = "python";
+			this.cat.scheme = "monty";
+
+			this.cat.writeAtomOutput(writer);
+			assertEquals(
+					"<category term=\"test\" scheme=\"monty\" label=\"python\"/>",
+					strWriter.toString());
+
+		}
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMCategoryImpl.writeRssOutput(GOMWriter)'
+	 */
+	public void testWriteRssOutput() throws XMLStreamException {
+		try {
+			this.cat.writeRssOutput(null);
+			fail("wirter is null");
+		} catch (NullPointerException e) {
+			// 
+		}
+
+		{
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			this.cat.writeRssOutput(writer);
+			assertEquals("<category domain=\"\"/>", strWriter.toString());
+		}
+
+		{
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			this.cat.scheme = "www.apache.org";
+			this.cat.writeRssOutput(writer);
+			assertEquals("<category domain=\"www.apache.org\"/>", strWriter
+					.toString());
+		}
+
+		{
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			this.cat.scheme = "www.apache.org";
+			this.cat.term = "Goo Data";
+			this.cat.writeRssOutput(writer);
+			assertEquals(
+					"<category domain=\"www.apache.org\">Goo Data</category>",
+					strWriter.toString());
+		}
+
+		{
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			this.cat.scheme = "www.apache.org";
+			this.cat.term = "Goo Data";
+			this.cat.label = "ignore";
+			this.cat.writeRssOutput(writer);
+			assertEquals(
+					"<category domain=\"www.apache.org\">Goo Data</category>",
+					strWriter.toString());
+		}
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.AbstractGOMElement.processAttribute(QName,
+	 * String)'
+	 */
+	public void testProcessAttribute() {
+		try {
+			this.cat.processAttribute(null, "test");
+			fail("qname is null");
+		} catch (GDataParseException e) {
+			// 
+		}
+		{
+			QName name = new QName("term");
+			this.cat.processAttribute(name, "helloworld");
+			assertEquals("helloworld", this.cat.getTerm());
+
+			try {
+				this.cat.processAttribute(name, "helloworld");
+				fail("duplicated attribute");
+			} catch (GDataParseException e) {
+				// 
+			}
+		}
+
+		{
+			QName name = new QName("scheme");
+			this.cat.processAttribute(name, "helloworld1");
+			assertEquals("helloworld1", this.cat.getScheme());
+
+			try {
+				this.cat.processAttribute(name, "helloworld1");
+				fail("duplicated attribute");
+			} catch (GDataParseException e) {
+				// 
+			}
+		}
+
+		{
+			QName name = new QName("label");
+			this.cat.processAttribute(name, "John Cleese");
+			assertEquals("John Cleese", this.cat.getLabel());
+
+			try {
+				this.cat.processAttribute(name, "John Cleese");
+				fail("duplicated attribute");
+			} catch (GDataParseException e) {
+				// 
+			}
+		}
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.AbstractGOMElement.processElementValue(String)'
+	 */
+	public void testProcessElementValue() {
+		try {
+			this.cat.processElementValue(null);
+			fail("element value is null");
+		} catch (GDataParseException e) {
+			// 
+		}
+
+		try {
+			this.cat.processElementValue("and again");
+			fail("can't contain a text value");
+		} catch (GDataParseException e) {
+			//
+			assertNull(this.cat.getTextValue());
+		}
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.AbstractGOMElement.processEndElement()'
+	 */
+	public void testProcessEndElement() {
+		try {
+			this.cat.processEndElement();
+			fail("term is not set");
+		} catch (GDataParseException e) {
+			// 
+		}
+		this.cat.setTerm("my Term");
+		this.cat.processEndElement();
+		this.cat.setScheme("test");
+
+		try {
+			this.cat.processEndElement();
+			fail("scheme is not a absoulte uri");
+		} catch (GDataParseException e) {
+			// 
+		}
+
+		this.cat.setScheme("/test");
+
+		try {
+			this.cat.processEndElement();
+			fail("scheme is not a absoulte uri and no xmlbase is set");
+		} catch (GDataParseException e) {
+			// 
+		}
+		{
+			this.cat.xmlBase = "http://www.apache.org";
+			this.cat.processEndElement();
+		}
+
+		{
+			this.cat.xmlBase = null;
+			this.cat.setScheme("http://www.apache.org/test");
+			this.cat.processEndElement();
+		}
+
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMContentImplTest.java b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMContentImplTest.java
new file mode 100644
index 0000000..e773f60
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMContentImplTest.java
@@ -0,0 +1,275 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.gom.core;
+
+import java.io.StringWriter;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.FactoryConfigurationError;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.AtomMediaType;
+import org.apache.lucene.gdata.gom.ContentType;
+import org.apache.lucene.gdata.gom.GOMContent;
+import org.apache.lucene.gdata.gom.GOMNamespace;
+import org.apache.lucene.gdata.gom.core.GOMTextContructImpl.XMLBlobContentParser;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+import org.apache.lucene.gdata.gom.writer.GOMStaxWriter;
+
+import junit.framework.TestCase;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class GOMContentImplTest extends TestCase {
+
+	private GOMContentImpl impl;
+
+	protected void setUp() throws Exception {
+		super.setUp();
+		this.impl = new GOMContentImpl();
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMContentImpl.getChildParser(QName)'
+	 */
+	public void testGetChildParser() {
+		try {
+			this.impl.getChildParser(new QName("test"));
+			fail("no blob specified");
+		} catch (GDataParseException e) {
+			// 
+		}
+
+		this.impl.setAtomMediaType(AtomMediaType.XML);
+		AtomParser childParser = this.impl.getChildParser(new QName("test"));
+		assertNotNull(childParser);
+		assertTrue(childParser instanceof XMLBlobContentParser);
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMContentImpl.processAttribute(QName,
+	 * String)'
+	 */
+	public void testProcessAttribute() {
+		try {
+			this.impl.processAttribute(null, "test");
+			fail("qname is null");
+		} catch (GDataParseException e) {
+			// 
+		}
+		try {
+			this.impl.processAttribute(new QName("test"), null);
+			fail("value is null");
+		} catch (GDataParseException e) {
+			// 
+		}
+		this.impl.processAttribute(new QName(GOMNamespace.ATOM_NS_URI, "type"),
+				"text/xml");
+		assertSame(AtomMediaType.XML, this.impl.getAtomMediaType());
+		try {
+			this.impl.processAttribute(new QName(GOMNamespace.ATOM_NS_URI,
+					"type"), "text/xml");
+			fail("duplicated attribute");
+		} catch (GDataParseException e) {
+			// 
+		}
+		this.impl.setAtomMediaType(null);
+		this.impl.processAttribute(new QName(GOMNamespace.ATOM_NS_URI, "type"),
+				"text/plain");
+		assertSame(AtomMediaType.TEXT, this.impl.getAtomMediaType());
+
+		this.impl.setAtomMediaType(null);
+		this.impl.processAttribute(new QName(GOMNamespace.ATOM_NS_URI, "type"),
+				"image/jpeg");
+		assertSame(AtomMediaType.BINARY, this.impl.getAtomMediaType());
+
+		// test if super is called
+		this.impl.setAtomMediaType(null);
+		this.impl.processAttribute(new QName(GOMNamespace.ATOM_NS_URI, "type"),
+				"xhtml");
+		assertNull(this.impl.getAtomMediaType());
+		assertSame(ContentType.XHTML, this.impl.getContentType());
+
+		this.impl.processAttribute(new QName(GOMNamespace.ATOM_NS_URI, "src"),
+				"test");
+		assertEquals("test", this.impl.getSrc());
+		try {
+			this.impl.processAttribute(new QName(GOMNamespace.ATOM_NS_URI,
+					"src"), "text/xml");
+			fail("duplicated attribute");
+		} catch (GDataParseException e) {
+			// 
+		}
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMContentImpl.processElementValue(String)'
+	 */
+	public void testProcessElementValue() {
+		assertNull(this.impl.getTextValue());
+		this.impl.processElementValue("test");
+		assertEquals("test", this.impl.getTextValue());
+		this.impl.setSrc("http://www.apache.org");
+		try {
+			this.impl.processElementValue("test");
+			fail("src is set no element value allowed");
+		} catch (GDataParseException e) {
+			// 
+		}
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMContentImpl.processEndElement()'
+	 */
+	public void testProcessEndElement() {
+		try {
+			this.impl.processEndElement();
+			fail("no type attribute");
+		} catch (GDataParseException e) {
+			// 
+		}
+		this.impl.processAttribute(new QName(GOMNamespace.ATOM_NS_URI, "type"),
+				"text/plain");
+		this.impl.processEndElement();
+		this.impl.setSrc("http://www.apache.org");
+		this.impl.processEndElement();
+
+		this.impl.setSrc("/test");
+		try {
+			this.impl.processEndElement();
+			fail("must be absolut uri");
+		} catch (GDataParseException e) {
+			// 
+		}
+		this.impl.xmlBase = "http://www.apache.org";
+		this.impl.processEndElement();
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMContentImpl.writeAtomOutput(GOMOutputWriter)'
+	 */
+	public void testWriteAtomOutput() throws XMLStreamException,
+			FactoryConfigurationError {
+		{
+			StringWriter stW = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(stW);
+			this.impl.writeAtomOutput(writer);
+			assertEquals("<content type=\"text\"/>", stW.toString());
+		}
+
+		{
+			this.impl.processAttribute(new QName(GOMNamespace.ATOM_NS_URI,
+					"type"), "image/jpeg");
+			StringWriter stW = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(stW);
+			this.impl.writeAtomOutput(writer);
+			assertEquals("<content type=\"image/jpeg\"/>", stW.toString());
+		}
+
+		{
+			this.impl.setSrc("http://www.apache.org");
+			this.impl.setTextValue("hello world");
+			StringWriter stW = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(stW);
+			this.impl.writeAtomOutput(writer);
+			assertEquals(
+					"<content type=\"image/jpeg\" src=\"http://www.apache.org\"/>",
+					stW.toString());
+		}
+
+		{
+			this.impl.setSrc(null);
+			this.impl.setTextValue("hello world");
+			StringWriter stW = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(stW);
+			this.impl.writeAtomOutput(writer);
+			assertEquals("<content type=\"image/jpeg\">hello world</content>",
+					stW.toString());
+		}
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMContentImpl.writeRssOutput(GOMOutputWriter)'
+	 */
+	public void testWriteRssOutputGOMOutputWriter() throws XMLStreamException {
+		{
+			StringWriter stW = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(stW);
+			this.impl.writeRssOutput(writer);
+			assertEquals("<description/>", stW.toString());
+		}
+
+		{
+			this.impl.setSrc("http://www.apache.org");
+			this.impl.setAtomMediaType(AtomMediaType.TEXT);
+			StringWriter stW = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(stW);
+			this.impl.writeRssOutput(writer);
+			assertEquals("<link>http://www.apache.org</link>", stW.toString());
+		}
+
+		{
+			this.impl.setSrc(null);
+			this.impl.setAtomMediaType(AtomMediaType.TEXT);
+			this.impl.setTextValue("test");
+			StringWriter stW = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(stW);
+			this.impl.writeRssOutput(writer);
+			assertEquals("<description>test</description>", stW.toString());
+		}
+
+		{
+			this.impl.setAtomMediaType(null);
+
+			this.impl.processAttribute(new QName(GOMNamespace.ATOM_NS_URI,
+					"type"), "image/jpeg");
+			StringWriter stW = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(stW);
+			this.impl.writeRssOutput(writer);
+			assertEquals("<content type=\"image/jpeg\">test</content>", stW
+					.toString());
+		}
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMContentImpl.GOMContentImpl()'
+	 */
+	public void testGOMContentImpl() {
+		GOMContentImpl impl2 = new GOMContentImpl();
+		assertEquals(GOMContent.LOCALNAME, impl2.getLocalName());
+		assertEquals(GOMContent.LOCALNAME, impl2.getQname().getLocalPart());
+		assertEquals(GOMNamespace.ATOM_NS_URI, impl2.getQname()
+				.getNamespaceURI());
+
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMDateConstructImplTest.java b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMDateConstructImplTest.java
new file mode 100644
index 0000000..75c5ff8
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMDateConstructImplTest.java
@@ -0,0 +1,171 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import java.io.StringWriter;
+import java.util.Date;
+
+import javax.xml.stream.FactoryConfigurationError;
+import javax.xml.stream.XMLStreamException;
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.gdata.gom.writer.GOMStaxWriter;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class GOMDateConstructImplTest extends TestCase {
+	private static final String DATE = "2003-12-13T18:30:02+02:00";
+
+	private static final String DATE_RSS = "Sat, 13 Dec 2003 16:30:02 +0000";
+
+	private static final String DATE1 = "2003-12-13T18:30:02.25Z";
+
+	private GOMUpdatedImpl updateImpl;
+
+	private GOMPublishedImpl publishImpl;
+
+	protected void setUp() throws Exception {
+		this.updateImpl = new GOMUpdatedImpl();
+		this.publishImpl = new GOMPublishedImpl();
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMDateConstructImpl.processElementValue(String)'
+	 */
+	public void testProcessElementValue() {
+		try {
+			this.updateImpl.processElementValue(null);
+			fail("must not be null");
+		} catch (IllegalArgumentException e) {
+			// 
+		}
+		try {
+			this.updateImpl.processElementValue("not a date");
+			fail("illegal string");
+		} catch (GDataParseException e) {
+			// 
+		}
+
+		this.updateImpl.processElementValue(DATE);
+		assertNotNull(this.updateImpl.getDate());
+		this.updateImpl.processElementValue(DATE1);
+		assertNotNull(this.updateImpl.getDate());
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMDateConstructImpl.processEndElement()'
+	 */
+	public void testProcessEndElement() {
+		try {
+			this.updateImpl.processEndElement();
+			fail("no element value");
+		} catch (GDataParseException e) {
+			// 
+		}
+		this.updateImpl.setDate(new Date());
+		this.updateImpl.processEndElement();
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMDateConstructImpl.writeAtomOutput(GOMWriter)'
+	 */
+	public void testWriteAtomOutput() throws XMLStreamException,
+			FactoryConfigurationError {
+		{
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			this.updateImpl.writeAtomOutput(writer);
+			assertTrue(strWriter.toString().startsWith("<updated>"));
+			assertTrue(strWriter.toString().endsWith("</updated>"));
+		}
+		{
+			this.updateImpl.processElementValue(DATE);
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			this.updateImpl.writeAtomOutput(writer);
+			assertEquals("<updated>" + DATE + "</updated>", strWriter
+					.toString());
+		}
+
+		{
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			this.publishImpl.writeAtomOutput(writer);
+			assertTrue(strWriter.toString().startsWith("<published>"));
+			assertTrue(strWriter.toString().endsWith("</published>"));
+		}
+		{
+			this.publishImpl.processElementValue(DATE);
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			this.publishImpl.writeAtomOutput(writer);
+			assertEquals("<published>" + DATE + "</published>", strWriter
+					.toString());
+		}
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMDateConstructImpl.writeRssOutput(GOMWriter)'
+	 */
+	public void testWriteRssOutput() throws XMLStreamException,
+			FactoryConfigurationError {
+		{
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			this.updateImpl.writeRssOutput(writer);
+			assertTrue(strWriter.toString().startsWith("<atom:updated>"));
+			assertTrue(strWriter.toString().endsWith("</atom:updated>"));
+		}
+		{
+			this.updateImpl.processElementValue(DATE);
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			this.updateImpl.writeRssOutput(writer);
+			assertEquals("<atom:updated>" + DATE + "</atom:updated>", strWriter
+					.toString());
+		}
+
+		{
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			this.publishImpl.writeRssOutput(writer);
+
+			assertTrue(strWriter.toString().startsWith("<pubDate>"));
+			assertTrue(strWriter.toString().endsWith("</pubDate>"));
+		}
+		{
+			this.publishImpl.processElementValue(DATE);
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			this.publishImpl.writeRssOutput(writer);
+			assertEquals("<pubDate>" + DATE_RSS + "</pubDate>", strWriter
+					.toString());
+		}
+
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMDocumentImplTest.java b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMDocumentImplTest.java
new file mode 100644
index 0000000..29db97d
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMDocumentImplTest.java
@@ -0,0 +1,107 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.gom.core;
+
+import java.io.StringWriter;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.FactoryConfigurationError;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.writer.GOMStaxWriter;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+import junit.framework.TestCase;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class GOMDocumentImplTest extends TestCase {
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMDocumentImpl.writeAtomOutput(GOMWriter)'
+	 */
+	public void testWriteAtomOutput() throws XMLStreamException,
+			FactoryConfigurationError {
+		GOMDocumentImpl<ArbitraryGOMXml> impl = new GOMDocumentImpl<ArbitraryGOMXml>();
+		impl.setRootElement(new ArbitraryGOMXml(new QName("test")));
+		{
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			impl.writeAtomOutput(writer);
+			assertEquals("<?xml version='1.0' encoding='UTF-8'?><test/>",
+					strWriter.toString());
+		}
+		impl.setRootElement(null);
+		{
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			impl.writeAtomOutput(writer);
+			assertEquals("<?xml version='1.0' encoding='UTF-8'?>", strWriter
+					.toString());
+		}
+
+		impl.setVersion("2.0");
+		impl.setCharacterEncoding("ISO-8859-1");
+		{
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			impl.writeAtomOutput(writer);
+			assertEquals("<?xml version='2.0' encoding='ISO-8859-1'?>",
+					strWriter.toString());
+		}
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMDocumentImpl.writeRssOutput(GOMWriter)'
+	 */
+	public void testWriteRssOutput() throws XMLStreamException,
+			FactoryConfigurationError {
+		GOMDocumentImpl<ArbitraryGOMXml> impl = new GOMDocumentImpl<ArbitraryGOMXml>();
+		impl.setRootElement(new ArbitraryGOMXml(new QName("test")));
+		{
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			impl.writeRssOutput(writer);
+			assertEquals("<?xml version='1.0' encoding='UTF-8'?><test/>",
+					strWriter.toString());
+		}
+		impl.setRootElement(null);
+		{
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			impl.writeRssOutput(writer);
+			assertEquals("<?xml version='1.0' encoding='UTF-8'?>", strWriter
+					.toString());
+		}
+
+		impl.setVersion("2.0");
+		impl.setCharacterEncoding("ISO-8859-1");
+		{
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			impl.writeRssOutput(writer);
+			assertEquals("<?xml version='2.0' encoding='ISO-8859-1'?>",
+					strWriter.toString());
+		}
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMEntryImplTest.java b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMEntryImplTest.java
new file mode 100644
index 0000000..4a4601d
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMEntryImplTest.java
@@ -0,0 +1,526 @@
+package org.apache.lucene.gdata.gom.core;
+
+import java.io.StringWriter;
+import java.util.List;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.FactoryConfigurationError;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.AtomMediaType;
+import org.apache.lucene.gdata.gom.GOMAuthor;
+import org.apache.lucene.gdata.gom.GOMCategory;
+import org.apache.lucene.gdata.gom.GOMContent;
+import org.apache.lucene.gdata.gom.GOMContributor;
+import org.apache.lucene.gdata.gom.GOMEntry;
+import org.apache.lucene.gdata.gom.GOMExtension;
+import org.apache.lucene.gdata.gom.GOMGenerator;
+import org.apache.lucene.gdata.gom.GOMIcon;
+import org.apache.lucene.gdata.gom.GOMId;
+import org.apache.lucene.gdata.gom.GOMLink;
+import org.apache.lucene.gdata.gom.GOMLogo;
+import org.apache.lucene.gdata.gom.GOMNamespace;
+import org.apache.lucene.gdata.gom.GOMPublished;
+import org.apache.lucene.gdata.gom.GOMRights;
+import org.apache.lucene.gdata.gom.GOMSource;
+import org.apache.lucene.gdata.gom.GOMSubtitle;
+import org.apache.lucene.gdata.gom.GOMSummary;
+import org.apache.lucene.gdata.gom.GOMTitle;
+import org.apache.lucene.gdata.gom.GOMUpdated;
+import org.apache.lucene.gdata.gom.core.GOMFeedImplTest.TestExtendsionFactory;
+import org.apache.lucene.gdata.gom.core.GOMFeedImplTest.TestExtension;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+import org.apache.lucene.gdata.gom.writer.GOMStaxWriter;
+
+import junit.framework.TestCase;
+
+public class GOMEntryImplTest extends TestCase {
+	private static final String TEST_LOCAL_NAME = GOMFeedImplTest.TEST_LOCAL_NAME;
+
+	private GOMEntryImpl impl;
+
+	protected void setUp() throws Exception {
+		super.setUp();
+		this.impl = new GOMEntryImpl();
+	}
+
+	public void testSetNamespace() {
+		assertEquals(0, this.impl.getNamespaces().size());
+		assertNotNull(this.impl.getDefaultNamespace());
+		this.impl.addNamespace(GOMNamespace.ATOM_NAMESPACE);
+		assertSame(GOMNamespace.ATOM_NAMESPACE, this.impl.getDefaultNamespace());
+		this.impl.addNamespace(GOMNamespace.OPENSEARCH_NAMESPACE);
+		assertEquals(1, this.impl.getNamespaces().size());
+		assertSame(GOMNamespace.OPENSEARCH_NAMESPACE, this.impl.getNamespaces()
+				.get(0));
+
+		// detect defaul ns
+		this.impl.addNamespace(new GOMNamespace(GOMNamespace.ATOM_NS_URI, ""));
+		assertEquals(1, this.impl.getNamespaces().size());
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMEntryImpl.getChildParser(QName)'
+	 */
+	public void testGetChildParser() {
+		{
+			// atomAuthor*
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "author"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMAuthor);
+			assertEquals(1, this.impl.getAuthors().size());
+			this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
+					"author"));
+			assertEquals(2, this.impl.getAuthors().size());
+		}
+
+		{
+			// atomCategory*
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "category"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMCategory);
+			assertEquals(1, this.impl.getCategories().size());
+			this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
+					"category"));
+			assertEquals(2, this.impl.getCategories().size());
+		}
+
+		{
+			// atomContributor*
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "contributor"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMContributor);
+			assertEquals(1, this.impl.getContributor().size());
+			this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
+					"contributor"));
+			assertEquals(2, this.impl.getContributor().size());
+		}
+
+		{
+			// atomId
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "id"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMId);
+			assertSame(parser, this.impl.getId());
+			try {
+				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
+						"id"));
+				fail("exactly one time ");
+			} catch (GDataParseException e) {
+				// 
+			}
+
+		}
+
+		{
+			// atomLink*
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "link"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMLink);
+			assertEquals(1, this.impl.getLinks().size());
+			this.impl
+					.getChildParser(new QName(GOMNamespace.ATOM_NS_URI, "link"));
+			assertEquals(2, this.impl.getLinks().size());
+
+		}
+
+		{
+			// atomRights?
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "rights"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMRights);
+			assertSame(parser, this.impl.getRights());
+			try {
+				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
+						"rights"));
+				fail("zero or one");
+			} catch (GDataParseException e) {
+				// 
+			}
+
+		}
+
+		{
+			// atomTitle
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "title"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMTitle);
+			assertSame(parser, this.impl.getTitle());
+			try {
+				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
+						"title"));
+				fail("exactly one time ");
+			} catch (GDataParseException e) {
+				// 
+			}
+
+		}
+
+		{
+			// atomUpdated
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "updated"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMUpdated);
+			assertSame(parser, this.impl.getUpdated());
+			try {
+				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
+						"updated"));
+				fail("exactly one time ");
+			} catch (GDataParseException e) {
+				// 
+			}
+
+		}
+
+		{
+			// atomSource?
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "source"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMSource);
+			assertEquals(parser, this.impl.getSource());
+			try {
+				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
+						"source"));
+				fail("duplicated element");
+			} catch (GDataParseException e) {
+				//
+			}
+
+		}
+
+		{
+			// atomSummary?
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "summary"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMSummary);
+			assertEquals(parser, this.impl.getSummary());
+			try {
+				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
+						"summary"));
+				fail("duplicated element");
+			} catch (GDataParseException e) {
+				//
+			}
+
+		}
+
+		{
+			// atomContent?
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "content"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMContent);
+			assertEquals(parser, this.impl.getContent());
+			try {
+				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
+						"content"));
+				fail("duplicated element");
+			} catch (GDataParseException e) {
+				//
+			}
+
+		}
+
+		{
+			// atomContent?
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "published"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMPublished);
+			assertEquals(parser, this.impl.getPublished());
+			try {
+				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
+						"published"));
+				fail("duplicated element");
+			} catch (GDataParseException e) {
+				//
+			}
+
+		}
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMEntryImpl.processEndElement()'
+	 */
+	public void testProcessEndElement() {
+		try {
+			this.impl.processEndElement();
+			fail("missing elements");
+		} catch (GDataParseException e) {
+			// 
+		}
+
+		// atom:entry elements MUST contain exactly one atom:id element.
+		this.impl.setId(new GOMIdImpl());
+		/*
+		 * atom:entry elements that contain no child atom:content element MUST
+		 * contain at least one atom:link element with a rel attribute value of
+		 * "alternate".
+		 */
+		GOMLink link = new GOMLinkImpl();
+		link.setRel("alternate");
+		this.impl.addLink(link);
+		/*
+		 * atom:entry elements MUST contain exactly one atom:title element.
+		 */
+		this.impl.setTitle(new GOMTitleImpl());
+		/*
+		 * atom:entry elements MUST contain exactly one atom:updated element.
+		 */
+		this.impl.setUpdated(new GOMUpdatedImpl());
+
+		{
+			this.impl.setId(null);
+			try {
+				this.impl.processEndElement();
+				fail("id is missing");
+			} catch (GDataParseException e) {
+				// 
+			}
+			this.impl.setId(new GOMIdImpl());
+		}
+
+		{
+			this.impl.getLinks().clear();
+			try {
+				this.impl.processEndElement();
+				fail("link alternate is missing");
+			} catch (GDataParseException e) {
+				// 
+			}
+			this.impl.setContent(new GOMContentImpl());
+			this.impl.processEndElement();
+			this.impl.setContent(null);
+			this.impl.addLink(link);
+		}
+
+		{
+			this.impl.setTitle(null);
+			try {
+				this.impl.processEndElement();
+				fail("title is missing");
+			} catch (GDataParseException e) {
+				// 
+			}
+			this.impl.setTitle(new GOMTitleImpl());
+		}
+		{
+			this.impl.setUpdated(null);
+			try {
+				this.impl.processEndElement();
+				fail("Updated is missing");
+			} catch (GDataParseException e) {
+				// 
+			}
+			this.impl.setUpdated(new GOMUpdatedImpl());
+		}
+
+		/*
+		 * atom:entry elements MUST NOT contain more than one atom:link element
+		 * with a rel attribute value of "alternate" that has the same
+		 * combination of type and hreflang attribute values.
+		 */
+		link.setType("test");
+		link.setHrefLang("http://www.apache.org");
+		this.impl.addLink(link);
+		try {
+			this.impl.processEndElement();
+			fail("doulbe alternate link with same type and hreflang");
+
+		} catch (GDataParseException e) {
+			// 
+		}
+		this.impl.getLinks().remove(0);
+		/*
+		 * # atom:entry elements MUST contain an atom:summary element in either
+		 * of the following cases:
+		 * 
+		 * the atom:entry contains an atom:content that has a "src" attribute
+		 * (and is thus empty). the atom:entry contains content that is encoded
+		 * in Base64; i.e., the "type" attribute of atom:content is a MIME media
+		 * type [MIMEREG], but is not an XML media type [RFC3023], does not
+		 * begin with "text/", and does not end with "/xml" or "+xml".
+		 * 
+		 * 
+		 */
+		GOMContent c = new GOMContentImpl();
+		c.setSrc("");
+		this.impl.setContent(c);
+		try {
+			this.impl.processEndElement();
+			fail("no summary");
+		} catch (GDataParseException e) {
+			// 
+		}
+		c.setSrc(null);
+		c.setAtomMediaType(AtomMediaType.BINARY);
+		try {
+			this.impl.processEndElement();
+			fail("no summary");
+		} catch (GDataParseException e) {
+			// 
+		}
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMEntryImpl.GOMEntryImpl()'
+	 */
+	public void testGOMEntryImpl() {
+		GOMEntryImpl impl2 = new GOMEntryImpl();
+		assertNotNull(impl2.getQname());
+		assertEquals(GOMEntry.LOCALNAME, impl.getQname().getLocalPart());
+		assertEquals(GOMEntry.LOCALNAME, this.impl.getLocalName());
+		assertEquals(GOMNamespace.ATOM_NS_URI, impl.getQname()
+				.getNamespaceURI());
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMEntryImpl.writeAtomOutput(GOMOutputWriter)'
+	 */
+	public void testWriteAtomOutput() throws XMLStreamException,
+			FactoryConfigurationError {
+		// write a whole feed and check if all elements are written
+		this.impl.addAuthor(new GOMAuthorImpl());
+		this.impl.addCategory(new GOMCategoryImpl());
+		this.impl.addContributor(new GOMContributorImpl());
+		this.impl.addLink(new GOMLinkImpl());
+		this.impl.setContent(new GOMContentImpl());
+		this.impl.setId(new GOMIdImpl());
+		this.impl.setRights(new GOMRightsImpl());
+		this.impl.setSummary(new GOMSummaryImpl());
+		this.impl.setTitle(new GOMTitleImpl());
+		this.impl.setUpdated(new GOMUpdatedImpl());
+		this.impl.setSource(new GOMSourceImpl());
+		this.impl.setPublished(new GOMPublishedImpl());
+		this.impl.extensions.add(new GOMFeedImplTest.TestExtension());
+		StringWriter stW = new StringWriter();
+		GOMOutputWriter writer = new GOMStaxWriter(stW);
+		this.impl.writeAtomOutput(writer);
+		String string = stW.toString();
+		assertTrue(string.contains("xmlns=\"http://www.w3.org/2005/Atom\""));
+		assertTrue(string.startsWith("<" + GOMEntry.LOCALNAME));
+		assertTrue(string.contains("<" + GOMAuthor.LOCALNAME));
+		assertTrue(string.contains("<" + GOMCategory.LOCALNAME));
+		assertTrue(string.contains("<" + GOMContributor.LOCALNAME));
+		assertTrue(string.contains("<" + GOMLink.LOCALNAME));
+		assertTrue(string.contains("<" + GOMId.LOCALNAME));
+		assertTrue(string.contains("<" + GOMRights.LOCALNAME));
+		assertTrue(string.contains("<" + GOMSummary.LOCALNAME));
+		assertTrue(string.contains("<" + GOMContent.LOCALNAME));
+		assertTrue(string.contains("<" + GOMTitle.LOCALNAME));
+		assertTrue(string.contains("<" + GOMUpdated.LOCALNAME));
+		assertTrue(string.contains("<" + GOMSource.LOCALNAME));
+		assertTrue(string.contains("<" + GOMPublished.LOCALNAME));
+		assertTrue(string.contains("<test"));
+		assertTrue(string.endsWith("</entry>"));
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMEntryImpl.writeRssOutput(GOMOutputWriter)'
+	 */
+	public void testWriteRssOutputGOMOutputWriter() throws XMLStreamException,
+			FactoryConfigurationError {
+		// write a whole feed and check if all elements are written
+		this.impl.addAuthor(new GOMAuthorImpl());
+		this.impl.addCategory(new GOMCategoryImpl());
+		this.impl.addContributor(new GOMContributorImpl());
+		GOMLink link = new GOMLinkImpl();
+		link.setRel("enclosure");
+		link.setHref("test");
+		link.setType("testType");
+		this.impl.addLink(link);
+		this.impl.setContent(new GOMContentImpl());
+		this.impl.setId(new GOMIdImpl());
+		this.impl.setRights(new GOMRightsImpl());
+		GOMSummaryImpl summ = new GOMSummaryImpl();
+		summ.xmlLang = "de";
+		this.impl.setSummary(summ);
+		this.impl.setTitle(new GOMTitleImpl());
+		this.impl.setUpdated(new GOMUpdatedImpl());
+		this.impl.setSource(new GOMSourceImpl());
+		this.impl.setPublished(new GOMPublishedImpl());
+		this.impl.extensions.add(new GOMFeedImplTest.TestExtension());
+		StringWriter stW = new StringWriter();
+		GOMOutputWriter writer = new GOMStaxWriter(stW);
+		this.impl.writeRssOutput(writer);
+		String string = stW.toString();
+		assertTrue(string
+				.contains("xmlns:atom=\"http://www.w3.org/2005/Atom\""));
+		assertTrue(string.startsWith("<" + GOMEntry.LOCALNAME_RSS));
+		assertTrue(string.contains("<" + GOMId.LOCALNAME_RSS));
+		assertTrue(string.contains("<pubDate"));
+		assertTrue(string.contains("<atom:" + GOMUpdated.LOCALNAME));
+		assertTrue(string.contains("<" + GOMId.LOCALNAME_RSS));
+		assertTrue(string.contains("<language"));
+		assertTrue(string.contains("<category domain=\""));
+		assertTrue(string.contains("<title"));
+		assertTrue(string.contains("<atom:summary"));
+		assertTrue(string.contains("<description"));
+		// a link element
+		assertTrue(string.contains("<enclosure"));
+		assertTrue(string.contains("<author"));
+		assertTrue(string.contains("<atom:test"));
+		assertTrue(string.endsWith("</item>"));
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMEntryImpl.getExtensions()'
+	 */
+	public void testGetExtensions() {
+
+		{
+			List<GOMExtension> extensions = this.impl.getExtensions();
+			assertNotNull(extensions);
+			assertEquals(0, extensions.size());
+		}
+		QName name = new QName(TEST_LOCAL_NAME);
+		this.impl.setExtensionFactory(new TestExtendsionFactory());
+
+		AtomParser childParser = this.impl.getChildParser(name);
+		assertTrue(childParser instanceof TestExtension);
+		List<GOMExtension> extensions = this.impl.getExtensions();
+		assertNotNull(extensions);
+		assertEquals(1, extensions.size());
+		assertSame(childParser, extensions.get(0));
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMEntryImpl.setExtensionFactory(GOMExtensionFactory)'
+	 */
+	public void testSetExtensionFactory() {
+		QName name = new QName(TEST_LOCAL_NAME);
+		try {
+			this.impl.getChildParser(name);
+			fail("no child hander for this qname");
+		} catch (GDataParseException e) {
+			// 
+		}
+
+		this.impl.setExtensionFactory(new TestExtendsionFactory());
+
+		AtomParser childParser = this.impl.getChildParser(name);
+		assertTrue(childParser instanceof TestExtension);
+
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMFeedImplTest.java b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMFeedImplTest.java
new file mode 100644
index 0000000..a09d0cb
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMFeedImplTest.java
@@ -0,0 +1,688 @@
+package org.apache.lucene.gdata.gom.core;
+
+import java.io.StringWriter;
+import java.util.LinkedList;
+import java.util.List;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.FactoryConfigurationError;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.GOMAuthor;
+import org.apache.lucene.gdata.gom.GOMCategory;
+import org.apache.lucene.gdata.gom.GOMContributor;
+import org.apache.lucene.gdata.gom.GOMElement;
+import org.apache.lucene.gdata.gom.GOMEntry;
+import org.apache.lucene.gdata.gom.GOMExtension;
+import org.apache.lucene.gdata.gom.GOMFeed;
+import org.apache.lucene.gdata.gom.GOMGenerator;
+import org.apache.lucene.gdata.gom.GOMIcon;
+import org.apache.lucene.gdata.gom.GOMId;
+import org.apache.lucene.gdata.gom.GOMLink;
+import org.apache.lucene.gdata.gom.GOMLogo;
+import org.apache.lucene.gdata.gom.GOMNamespace;
+import org.apache.lucene.gdata.gom.GOMRights;
+import org.apache.lucene.gdata.gom.GOMSubtitle;
+import org.apache.lucene.gdata.gom.GOMTitle;
+import org.apache.lucene.gdata.gom.GOMUpdated;
+import org.apache.lucene.gdata.gom.core.extension.GOMExtensionFactory;
+import org.apache.lucene.gdata.gom.writer.GOMStaxWriter;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+import junit.framework.TestCase;
+
+public class GOMFeedImplTest extends TestCase {
+	static final String TEST_LOCAL_NAME = "testelement";
+
+	GOMFeedImpl impl;
+
+	protected void setUp() throws Exception {
+		this.impl = new GOMFeedImpl();
+	}
+
+	public void testSetNamespace() {
+		assertEquals(0, this.impl.getNamespaces().size());
+		assertNotNull(this.impl.getDefaultNamespace());
+		this.impl.addNamespace(GOMNamespace.ATOM_NAMESPACE);
+		assertSame(GOMNamespace.ATOM_NAMESPACE, this.impl.getDefaultNamespace());
+		this.impl.addNamespace(GOMNamespace.OPENSEARCH_NAMESPACE);
+		assertEquals(1, this.impl.getNamespaces().size());
+		assertSame(GOMNamespace.OPENSEARCH_NAMESPACE, this.impl.getNamespaces()
+				.get(0));
+
+		// detect defaul ns
+		this.impl.addNamespace(new GOMNamespace(GOMNamespace.ATOM_NS_URI, ""));
+		assertEquals(1, this.impl.getNamespaces().size());
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.getChildParser(QName)'
+	 */
+	public void testGetChildParser() {
+
+		{
+			// atomAuthor*
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "author"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMAuthor);
+			assertEquals(1, this.impl.getAuthors().size());
+			this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
+					"author"));
+			assertEquals(2, this.impl.getAuthors().size());
+		}
+
+		{
+			// atomCategory*
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "category"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMCategory);
+			assertEquals(1, this.impl.getCategories().size());
+			this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
+					"category"));
+			assertEquals(2, this.impl.getCategories().size());
+		}
+
+		{
+			// atomContributor*
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "contributor"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMContributor);
+			assertEquals(1, this.impl.getContributor().size());
+			this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
+					"contributor"));
+			assertEquals(2, this.impl.getContributor().size());
+		}
+		{
+			// atomGenerator?
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "generator"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMGenerator);
+			assertSame(parser, this.impl.getGenerator());
+			try {
+				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
+						"generator"));
+				fail("one or zero");
+			} catch (GDataParseException e) {
+				// 
+			}
+		}
+
+		{
+			// atomIcon?
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "icon"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMIcon);
+			assertSame(parser, this.impl.getIcon());
+			try {
+				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
+						"icon"));
+				fail("one or zero");
+			} catch (GDataParseException e) {
+				// 
+			}
+
+		}
+
+		{
+			// atomId
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "id"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMId);
+			assertSame(parser, this.impl.getId());
+			try {
+				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
+						"id"));
+				fail("exactly one time ");
+			} catch (GDataParseException e) {
+				// 
+			}
+
+		}
+
+		{
+			// atomLink*
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "link"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMLink);
+			assertEquals(1, this.impl.getLinks().size());
+			this.impl
+					.getChildParser(new QName(GOMNamespace.ATOM_NS_URI, "link"));
+			assertEquals(2, this.impl.getLinks().size());
+
+		}
+
+		{
+			// atomLogo?
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "logo"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMLogo);
+			assertSame(parser, this.impl.getLogo());
+			try {
+				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
+						"logo"));
+				fail("zero or one");
+			} catch (GDataParseException e) {
+				// 
+			}
+
+		}
+
+		{
+			// atomRights?
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "rights"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMRights);
+			assertSame(parser, this.impl.getRights());
+			try {
+				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
+						"rights"));
+				fail("zero or one");
+			} catch (GDataParseException e) {
+				// 
+			}
+
+		}
+
+		{
+			// atomSubtitle?
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "subtitle"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMSubtitle);
+			assertSame(parser, this.impl.getSubtitle());
+			try {
+				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
+						"subtitle"));
+				fail("zero or one");
+			} catch (GDataParseException e) {
+				// 
+			}
+
+		}
+
+		{
+			// atomTitle
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "title"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMTitle);
+			assertSame(parser, this.impl.getTitle());
+			try {
+				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
+						"title"));
+				fail("exactly one time ");
+			} catch (GDataParseException e) {
+				// 
+			}
+
+		}
+
+		{
+			// atomUpdated
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "updated"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMUpdated);
+			assertSame(parser, this.impl.getUpdated());
+			try {
+				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
+						"updated"));
+				fail("exactly one time ");
+			} catch (GDataParseException e) {
+				// 
+			}
+
+		}
+
+		{
+			// atomEntry*
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "entry"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMEntry);
+			assertEquals(1, this.impl.getEntries().size());
+			this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
+					"entry"));
+			assertEquals(2, this.impl.getEntries().size());
+
+		}
+
+		// openSearch
+		{
+			// startIndex
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.OPENSEARCH_NS_URI, "startIndex"));
+			assertNotNull(parser);
+
+		}
+		{
+			// startIndex
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.OPENSEARCH_NS_URI, "itemsPerPage"));
+			assertNotNull(parser);
+
+		}
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.processElementValue(String)'
+	 */
+	public void testProcessElementValue() {
+		try {
+			this.impl.processElementValue("some");
+			fail("no element text");
+		} catch (GDataParseException e) {
+			//
+		}
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.processEndElement()'
+	 * 
+	 * atomFeed = element atom:feed { atomCommonAttributes, (atomAuthor* &
+	 * atomCategory* & atomContributor* & atomGenerator? & atomIcon? & atomId &
+	 * atomLink* & atomLogo? & atomRights? & atomSubtitle? & atomTitle &
+	 * atomUpdated & extensionElement*), atomEntry* }
+	 */
+	public void testProcessEndElement() {
+		this.impl.addAuthor(new GOMAuthorImpl());
+		this.impl.setId(new GOMIdImpl());
+		this.impl.setUpdated(new GOMUpdatedImpl());
+		this.impl.setTitle(new GOMTitleImpl());
+
+		this.impl.processEndElement();
+		{
+			// author missing
+			this.impl.getAuthors().clear();
+			try {
+				this.impl.processEndElement();
+				fail("missing elements");
+			} catch (GDataParseException e) {
+				// 
+			}
+			this.impl.addAuthor(new GOMAuthorImpl());
+		}
+
+		{
+			// id missing
+			this.impl.setId(null);
+			try {
+				this.impl.processEndElement();
+				fail("missing elements");
+			} catch (GDataParseException e) {
+				// 
+			}
+			this.impl.setId(new GOMIdImpl());
+		}
+
+		{
+			// title missing
+			this.impl.setTitle(null);
+			try {
+				this.impl.processEndElement();
+				fail("missing elements");
+			} catch (GDataParseException e) {
+				// 
+			}
+			this.impl.setTitle(new GOMTitleImpl());
+		}
+		{
+			// updated missing
+			this.impl.setUpdated(null);
+			try {
+				this.impl.processEndElement();
+				fail("missing elements");
+			} catch (GDataParseException e) {
+				// 
+			}
+			this.impl.setUpdated(new GOMUpdatedImpl());
+		}
+
+		/*
+		 * atom:feed elements MUST NOT contain more than one atom:link element
+		 * with a rel attribute value of "alternate" that has the same
+		 * combination of type and hreflang attribute values.
+		 */
+
+		{
+			// two identical alternate links missing
+			GOMLink link = new GOMLinkImpl();
+			link.setRel("alternate");
+			link.setHrefLang("http://www.apache.org");
+			link.setType("text/html");
+			this.impl.addLink(link);
+			// one is allowed
+			this.impl.processEndElement();
+			// add a second link
+			link = new GOMLinkImpl();
+			this.impl.addLink(link);
+			link.setRel("next");
+			link.setHrefLang("http://www.apache.org");
+			link.setType("text/html");
+			// one is alternate the other is next
+			this.impl.processEndElement();
+
+			// a second "identical" alternate link
+			link = new GOMLinkImpl();
+			this.impl.addLink(link);
+			link.setRel("alternate");
+			link.setHrefLang("http://www.apache.org");
+			link.setType("text/html");
+			try {
+				this.impl.processEndElement();
+				fail("missing elements");
+			} catch (GDataParseException e) {
+				// 
+			}
+			this.impl.setUpdated(new GOMUpdatedImpl());
+		}
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.GOMFeedImpl()'
+	 */
+	public void testGOMFeedImpl() {
+		GOMFeedImpl impl2 = new GOMFeedImpl();
+		assertEquals(GOMFeed.LOCALNAME, impl2.getLocalName());
+		assertEquals(GOMFeed.LOCALNAME, impl2.getQname().getLocalPart());
+		assertEquals(GOMNamespace.ATOM_NS_URI, impl2.getQname()
+				.getNamespaceURI());
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.getStartIndex()' and
+	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.setStartIndex(int)'
+	 */
+	public void testGetSetStartIndex() {
+		assertEquals(GOMFeedImpl.DEFAULT_START_INDEX, this.impl.getStartIndex());
+		this.impl.setStartIndex(5);
+		assertEquals(5, this.impl.getStartIndex());
+		this.impl.setStartIndex(-5);
+		assertEquals(5, this.impl.getStartIndex());
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.setItemsPerPage(int)' and
+	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.getNamespaces()'
+	 */
+	public void testGetSetItemsPerPage() {
+		assertEquals(GOMFeedImpl.DEFAULT_ITEMS_PER_PAGE, this.impl
+				.getItemsPerPage());
+		this.impl.setItemsPerPage(5);
+		assertEquals(5, this.impl.getItemsPerPage());
+		this.impl.setItemsPerPage(-5);
+		assertEquals(5, this.impl.getItemsPerPage());
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.writeAtomOutput(GOMWriter)'
+	 */
+	public void testWriteAtomOutput() throws XMLStreamException,
+			FactoryConfigurationError {
+		// write a whole feed and check if all elements are written
+		this.impl.addAuthor(new GOMAuthorImpl());
+		this.impl.addCategory(new GOMCategoryImpl());
+		this.impl.addContributor(new GOMContributorImpl());
+		this.impl.addLink(new GOMLinkImpl());
+		this.impl.addNamespace(GOMNamespace.OPENSEARCH_NAMESPACE);
+		this.impl.setGenerator(new GOMGeneratorImpl());
+		this.impl.setIcon(new GOMIconImpl());
+		this.impl.setId(new GOMIdImpl());
+		this.impl.setLogo(new GOMLogoImpl());
+		this.impl.setRights(new GOMRightsImpl());
+		this.impl.setSubtitle(new GOMSubtitleImpl());
+		this.impl.setTitle(new GOMTitleImpl());
+		this.impl.setUpdated(new GOMUpdatedImpl());
+		this.impl.extensions.add(new TestExtension());
+		this.impl.addNamespace(GOMNamespace.OPENSEARCH_NAMESPACE);
+		StringWriter stW = new StringWriter();
+		GOMOutputWriter writer = new GOMStaxWriter(stW);
+		this.impl.writeAtomOutput(writer);
+		String string = stW.toString();
+		assertTrue(string.contains("xmlns:openSearch"));
+		assertTrue(string.contains("xmlns=\"http://www.w3.org/2005/Atom\""));
+		assertTrue(string.contains("<" + GOMAuthor.LOCALNAME));
+		assertTrue(string.contains("<" + GOMCategory.LOCALNAME));
+		assertTrue(string.contains("<" + GOMContributor.LOCALNAME));
+		assertTrue(string.contains("<" + GOMLink.LOCALNAME));
+		assertTrue(string.contains("<" + GOMGenerator.LOCALNAME));
+		assertTrue(string.contains("<" + GOMIcon.LOCALNAME));
+		assertTrue(string.contains("<" + GOMId.LOCALNAME));
+		assertTrue(string.contains("<" + GOMLogo.LOCALNAME));
+		assertTrue(string.contains("<" + GOMRights.LOCALNAME));
+		assertTrue(string.contains("<" + GOMSubtitle.LOCALNAME));
+		assertTrue(string.contains("<" + GOMTitle.LOCALNAME));
+		assertTrue(string.contains("<" + GOMUpdated.LOCALNAME));
+		assertTrue(string.contains("<openSearch:itemsPerPage>"));
+		assertTrue(string.contains("<openSearch:startIndex>"));
+		assertTrue(string.contains("<test"));
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.writeRssOutput(GOMWriter)'
+	 */
+	public void testWriteRssOutput() throws XMLStreamException,
+			FactoryConfigurationError {
+		// write a whole feed and check if all elements are written
+		this.impl.addAuthor(new GOMAuthorImpl());
+		this.impl.addCategory(new GOMCategoryImpl());
+		this.impl.addContributor(new GOMContributorImpl());
+		GOMLinkImpl impl2 = new GOMLinkImpl();
+		impl2.setHref("test");
+		impl2.setRel("alternate");
+		this.impl.addLink(impl2);
+		this.impl.addNamespace(GOMNamespace.OPENSEARCH_NAMESPACE);
+		this.impl.setGenerator(new GOMGeneratorImpl());
+		this.impl.setIcon(new GOMIconImpl());
+		this.impl.setId(new GOMIdImpl());
+		this.impl.setLogo(new GOMLogoImpl());
+		this.impl.setRights(new GOMRightsImpl());
+		this.impl.setSubtitle(new GOMSubtitleImpl());
+		this.impl.setTitle(new GOMTitleImpl());
+		this.impl.setUpdated(new GOMUpdatedImpl());
+		this.impl.addNamespace(GOMNamespace.ATOM_NAMESPACE);
+		this.impl.addNamespace(GOMNamespace.OPENSEARCH_NAMESPACE);
+		this.impl.extensions.add(new TestExtension());
+		StringWriter stW = new StringWriter();
+		GOMOutputWriter writer = new GOMStaxWriter(stW);
+		this.impl.writeRssOutput(writer);
+
+		String string = stW.toString();
+		assertTrue(string.contains("xmlns:openSearch"));
+		assertTrue(string.contains("xmlns:atom"));
+		// TODO
+		// assertTrue(string.contains("<language"));
+		assertTrue(string.contains("<" + GOMCategory.LOCALNAME));
+		// author
+		assertTrue(string.contains("<managingEditor"));
+		assertTrue(string.contains("<" + GOMLink.LOCALNAME));
+		assertTrue(string.contains("<" + GOMGenerator.LOCALNAME));
+		assertTrue(string.contains("<image><url"));
+		assertTrue(string.contains("<atom:" + GOMId.LOCALNAME));
+
+		assertTrue(string.contains("<copyright"));
+		assertTrue(string.contains("<" + GOMTitle.LOCALNAME));
+		assertTrue(string.contains("<lastBuildDate"));
+		assertTrue(string.contains("<openSearch:itemsPerPage>"));
+		assertTrue(string.contains("<openSearch:startIndex>"));
+		assertTrue(string.contains("<atom:test"));
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.getExtensions()'
+	 */
+	public void testGetExtensions() {
+
+		{
+			List<GOMExtension> extensions = this.impl.getExtensions();
+			assertNotNull(extensions);
+			assertEquals(0, extensions.size());
+		}
+		QName name = new QName(TEST_LOCAL_NAME);
+		this.impl.setExtensionFactory(new TestExtendsionFactory());
+
+		AtomParser childParser = this.impl.getChildParser(name);
+		assertTrue(childParser instanceof TestExtension);
+		List<GOMExtension> extensions = this.impl.getExtensions();
+		assertNotNull(extensions);
+		assertEquals(1, extensions.size());
+		assertSame(childParser, extensions.get(0));
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.setExtensionFactory(GOMExtensionFactory)'
+	 */
+	public void testSetExtensionFactory() {
+		QName name = new QName(TEST_LOCAL_NAME);
+		try {
+			this.impl.getChildParser(name);
+			fail("no child hander for this qname");
+		} catch (GDataParseException e) {
+			// 
+		}
+
+		this.impl.setExtensionFactory(new TestExtendsionFactory());
+
+		AtomParser childParser = this.impl.getChildParser(name);
+		assertTrue(childParser instanceof TestExtension);
+
+	}
+
+	static class TestExtendsionFactory implements GOMExtensionFactory {
+
+		public GOMExtension canHandleExtensionElement(QName aName) {
+			if (aName.getLocalPart().equals(TEST_LOCAL_NAME))
+				return new TestExtension();
+			return null;
+		}
+
+		public List<GOMNamespace> getNamespaces() {
+			LinkedList<GOMNamespace> name = new LinkedList<GOMNamespace>();
+			name.add(GOMNamespace.ATOM_NAMESPACE);
+			return name;
+		}
+
+	}
+
+	static class TestExtension implements GOMExtension {
+
+		public QName getQname() {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		public void setNamespaceUri(String aString) {
+			// TODO Auto-generated method stub
+
+		}
+
+		public void setNamespacePrefix(String aString) {
+			// TODO Auto-generated method stub
+
+		}
+
+		public void setLocalName(String aLocalName) {
+			// TODO Auto-generated method stub
+
+		}
+
+		public String getLocalName() {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		public String getTextValue() {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		public void setTextValue(String aTextValue) {
+			// TODO Auto-generated method stub
+
+		}
+
+		public void addChild(GOMElement aElement) {
+			// TODO Auto-generated method stub
+
+		}
+
+		public GOMElement getParent() {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		public void writeAtomOutput(GOMOutputWriter aStreamWriter)
+				throws XMLStreamException {
+			aStreamWriter.writeSimpleXMLElement("test", null, "helloworld");
+
+		}
+
+		public void writeRssOutput(GOMOutputWriter aStreamWriter)
+				throws XMLStreamException {
+			aStreamWriter.writeSimpleXMLElement(new QName(
+					GOMNamespace.ATOM_NS_URI, "test",
+					GOMNamespace.ATOM_NS_PREFIX), null, "helloworld");
+
+		}
+
+		public void processElementValue(String aValue) {
+			// TODO Auto-generated method stub
+
+		}
+
+		public void processAttribute(QName aQName, String aValue) {
+			// TODO Auto-generated method stub
+
+		}
+
+		public void processEndElement() {
+			// TODO Auto-generated method stub
+
+		}
+
+		public AtomParser getChildParser(QName aName) {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		public void writeRssOutput(GOMOutputWriter aStreamWriter,
+				String aRssName) throws XMLStreamException {
+
+		}
+
+		public String getXmlBase() {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		public String getXmlLang() {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMGenereatorImplTest.java b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMGenereatorImplTest.java
new file mode 100644
index 0000000..98c365b
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMGenereatorImplTest.java
@@ -0,0 +1,204 @@
+package org.apache.lucene.gdata.gom.core;
+
+import java.io.StringWriter;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.FactoryConfigurationError;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.GOMGenerator;
+import org.apache.lucene.gdata.gom.GOMNamespace;
+import org.apache.lucene.gdata.gom.writer.GOMStaxWriter;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+import junit.framework.TestCase;
+
+public class GOMGenereatorImplTest extends TestCase {
+	private GOMGeneratorImpl impl;
+
+	protected void setUp() throws Exception {
+		this.impl = new GOMGeneratorImpl();
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMGeneratorImpl.processAttribute(QName,
+	 * String)'
+	 */
+	public void testProcessAttribute() {
+		this.impl.processAttribute(new QName(GOMNamespace.ATOM_NS_URI, "uri"),
+				"test");
+		assertEquals("test", this.impl.getUri());
+		try {
+			this.impl.processAttribute(new QName(GOMNamespace.ATOM_NS_URI,
+					"uri"), "test");
+			fail("duplicated");
+		} catch (GDataParseException e) {
+
+		}
+		this.impl.processAttribute(new QName(GOMNamespace.ATOM_NS_URI,
+				"version"), "test");
+		assertEquals("test", this.impl.getGeneratorVersion());
+
+		try {
+			this.impl.processAttribute(new QName(GOMNamespace.ATOM_NS_URI,
+					"version"), "test");
+			fail("duplicated");
+		} catch (GDataParseException e) {
+
+		}
+
+		// check call to super.processAttribute
+		this.impl.processAttribute(new QName(GOMNamespace.XML_NS_URI, "base",
+				GOMNamespace.XML_NS_PREFIX), "test");
+		assertEquals("test", this.impl.xmlBase);
+
+		try {
+			this.impl.processAttribute(null, "test");
+			fail("qname is null");
+		} catch (IllegalArgumentException e) {
+			// 
+		}
+		try {
+			this.impl.processAttribute(new QName(GOMNamespace.XML_NS_URI,
+					"base", GOMNamespace.XML_NS_PREFIX), null);
+			fail("value is null");
+		} catch (IllegalArgumentException e) {
+			// 
+		}
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMGeneratorImpl.processElementValue(String)'
+	 */
+	public void testProcessElementValue() {
+		this.impl.processElementValue("myGenerator");
+		assertEquals("myGenerator", this.impl.getTextValue());
+
+		try {
+			this.impl.processElementValue("testme");
+			fail("duplicated");
+
+		} catch (GDataParseException e) {
+			//
+		}
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMGeneratorImpl.processEndElement()'
+	 */
+	public void testProcessEndElement() {
+		this.impl.processEndElement();
+		{
+			this.impl.setUri("some invalid uri");
+			try {
+				this.impl.processEndElement();
+				fail("must be an absolute uri");
+			} catch (GDataParseException e) {
+				// 
+			}
+
+		}
+		{
+			this.impl.setUri("/uri");
+			try {
+				this.impl.processEndElement();
+				fail("must be an absolute uri or xml:base must be set");
+			} catch (GDataParseException e) {
+				// 
+			}
+
+		}
+		this.impl.xmlBase = "http://apache.org";
+		this.impl.processEndElement();
+
+		this.impl.xmlBase = null;
+		this.impl.setUri("http://apache.org/uri");
+		this.impl.processEndElement();
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMGeneratorImpl.GOMGeneratorImpl()'
+	 */
+	public void testGOMGeneratorImpl() {
+		this.impl = new GOMGeneratorImpl();
+		assertEquals(GOMGenerator.LOCALNAME, this.impl.getLocalName());
+		assertEquals(GOMGenerator.LOCALNAME, this.impl.getQname()
+				.getLocalPart());
+		assertEquals(GOMNamespace.ATOM_NS_URI, this.impl.getQname()
+				.getNamespaceURI());
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMGeneratorImpl.writeAtomOutput(GOMWriter)'
+	 */
+	public void testWriteAtomOutput() throws XMLStreamException {
+		{
+			StringWriter stW = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(stW);
+			this.impl.writeAtomOutput(writer);
+			assertEquals("<" + this.impl.getLocalName() + "/>", stW.toString());
+		}
+
+		{
+			StringWriter stW = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(stW);
+			this.impl.setTextValue("Lucene");
+			this.impl.writeAtomOutput(writer);
+			assertEquals("<" + this.impl.getLocalName() + ">Lucene</"
+					+ this.impl.getLocalName() + ">", stW.toString());
+		}
+		{
+			StringWriter stW = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(stW);
+			this.impl.setUri("http://apache.org");
+			this.impl.writeAtomOutput(writer);
+			assertEquals("<" + this.impl.getLocalName()
+					+ " uri=\"http://apache.org\">Lucene</"
+					+ this.impl.getLocalName() + ">", stW.toString());
+		}
+
+		{
+			StringWriter stW = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(stW);
+			this.impl.setGeneratorVersion("1");
+			this.impl.writeAtomOutput(writer);
+			assertEquals("<" + this.impl.getLocalName()
+					+ " uri=\"http://apache.org\" version=\"1\">Lucene</"
+					+ this.impl.getLocalName() + ">", stW.toString());
+		}
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMGeneratorImpl.writeRssOutput(GOMWriter)'
+	 */
+	public void testWriteRssOutput() throws XMLStreamException,
+			FactoryConfigurationError {
+		{
+			StringWriter stW = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(stW);
+			this.impl.setTextValue("Lucene");
+			this.impl.writeRssOutput(writer);
+			assertEquals("<" + this.impl.getLocalName() + ">Lucene</"
+					+ this.impl.getLocalName() + ">", stW.toString());
+		}
+
+		{
+			StringWriter stW = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(stW);
+			this.impl.setUri("http://apache.org");
+			this.impl.setGeneratorVersion("1");
+			this.impl.writeRssOutput(writer);
+			assertEquals("<" + this.impl.getLocalName() + ">Lucene</"
+					+ this.impl.getLocalName() + ">", stW.toString());
+		}
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMIdImplTest.java b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMIdImplTest.java
new file mode 100644
index 0000000..365785d
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMIdImplTest.java
@@ -0,0 +1,115 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import java.io.StringWriter;
+
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+import org.apache.lucene.gdata.gom.writer.GOMStaxWriter;
+
+import junit.framework.TestCase;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class GOMIdImplTest extends TestCase {
+	GOMIdImpl impl;
+
+	protected void setUp() throws Exception {
+		this.impl = new GOMIdImpl();
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMIdImpl.writeAtomOutput(GOMOutputWriter)'
+	 */
+	public void testWriteAtomOutput() throws XMLStreamException {
+		{
+			StringWriter stW = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(stW);
+			this.impl.writeAtomOutput(writer);
+
+			assertEquals("<id/>", stW.toString());
+		}
+
+		{
+			this.impl.setTextValue("testme");
+			StringWriter stW = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(stW);
+			this.impl.writeAtomOutput(writer);
+
+			assertEquals("<id>testme</id>", stW.toString());
+
+		}
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMIdImpl.writeRssOutput(GOMOutputWriter)'
+	 */
+	public void testWriteRssOutputGOMOutputWriter() throws XMLStreamException {
+		{
+			StringWriter stW = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(stW);
+			this.impl.writeRssOutput(writer);
+
+			assertEquals("<atom:id/>", stW.toString());
+		}
+
+		{
+			this.impl.setTextValue("testme");
+			StringWriter stW = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(stW);
+			this.impl.writeRssOutput(writer);
+
+			assertEquals("<atom:id>testme</atom:id>", stW.toString());
+
+		}
+
+		{
+			this.impl.setTextValue("testme");
+			StringWriter stW = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(stW);
+			this.impl.writeRssOutput(writer, "guid");
+
+			assertEquals("<guid>testme</guid>", stW.toString());
+
+		}
+
+	}
+
+	public void testProcessElementValue() {
+		this.impl.processElementValue("test");
+		assertEquals("test", this.impl.getTextValue());
+	}
+
+	public void testProcessEndElement() {
+		try {
+			this.impl.processEndElement();
+			fail("not set");
+		} catch (GDataParseException e) {
+			// 
+		}
+		this.impl.setTextValue("testme");
+		this.impl.processEndElement();
+
+	}
+}
diff --git a/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMLinkImplTest.java b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMLinkImplTest.java
new file mode 100644
index 0000000..a37097e
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMLinkImplTest.java
@@ -0,0 +1,239 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import java.io.StringWriter;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.GOMLink;
+import org.apache.lucene.gdata.gom.writer.GOMStaxWriter;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+import junit.framework.TestCase;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class GOMLinkImplTest extends TestCase {
+
+	private GOMLinkImpl impl;
+
+	/**
+	 * @see junit.framework.TestCase#setUp()
+	 */
+	@Override
+	protected void setUp() throws Exception {
+		impl = new GOMLinkImpl();
+	}
+
+	public void testCommonFields() {
+		assertNotNull(this.impl.getQname());
+		QName qname = this.impl.getQname();
+		assertEquals(qname, new QName(GOMLink.LOCALNAME));
+		assertEquals(qname.getLocalPart(), this.impl.getLocalName());
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMLinkImpl.processAttribute(QName,
+	 * String)'
+	 */
+	public void testProcessAttribute() {
+		// title
+		this.impl.processAttribute(new QName("title"), "title");
+		assertEquals("title", this.impl.getTitle());
+		try {
+			this.impl.processAttribute(new QName("title"), "title");
+			fail("duplicated attribute");
+		} catch (GDataParseException e) {
+			// 
+		}
+
+		// hreflang
+		this.impl.processAttribute(new QName("hreflang"), "hreflang");
+		assertEquals("hreflang", this.impl.getHrefLang());
+		try {
+			this.impl.processAttribute(new QName("hreflang"), "hreflang");
+			fail("duplicated attribute");
+		} catch (GDataParseException e) {
+			// 
+		}
+
+		// href
+		this.impl.processAttribute(new QName("href"), "href");
+		assertEquals("href", this.impl.getHref());
+		try {
+			this.impl.processAttribute(new QName("href"), "href");
+			fail("duplicated attribute");
+		} catch (GDataParseException e) {
+			// 
+		}
+		// type
+		this.impl.processAttribute(new QName("type"), "type");
+		assertEquals("type", this.impl.getType());
+		try {
+			this.impl.processAttribute(new QName("type"), "type");
+			fail("duplicated attribute");
+		} catch (GDataParseException e) {
+			// 
+		}
+
+		// lenght
+		try {
+			this.impl.processAttribute(new QName("length"), "noint");
+			fail("must be an integer");
+		} catch (GDataParseException e) {
+			// 
+		}
+
+		this.impl.processAttribute(new QName("length"), "1");
+		assertEquals(new Integer(1), this.impl.getLength());
+		try {
+			this.impl.processAttribute(new QName("length"), "1");
+			fail("duplicated attribute");
+		} catch (GDataParseException e) {
+			// 
+		}
+
+		// 
+		// rel
+		this.impl.processAttribute(new QName("rel"), "relation");
+		assertEquals("relation", this.impl.getRel());
+		try {
+			this.impl.processAttribute(new QName("rel"), "relation");
+			fail("duplicated attribute");
+		} catch (GDataParseException e) {
+			// 
+		}
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMLinkImpl.processEndElement()'
+	 */
+	public void testProcessEndElement() {
+		try {
+			this.impl.processEndElement();
+			fail("href is requiered but not set");
+		} catch (GDataParseException e) {
+			// 
+		}
+
+		this.impl.setHref("/helloworld");
+		try {
+			this.impl.processEndElement();
+			fail("href is not an absolute url");
+		} catch (GDataParseException e) {
+			// 
+		}
+		this.impl.xmlBase = "http://url";
+		this.impl.processEndElement();
+		this.impl.xmlBase = null;
+		this.impl.setHref("http://www.apache.org");
+		this.impl.processEndElement();
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMLinkImpl.writeAtomOutput(GOMWriter)'
+	 */
+	public void testWriteAtomOutput() throws XMLStreamException {
+		{
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			this.impl.writeAtomOutput(writer);
+			assertEquals("<link href=\"\"/>", strWriter.toString());
+		}
+		{
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			this.impl.setHref("test");
+			this.impl.setHrefLang("test1");
+			this.impl.setLength(2);
+			this.impl.setRel("NEXT");
+			this.impl.setTitle("myTitle");
+			this.impl.setType("myType");
+			this.impl.writeAtomOutput(writer);
+			assertTrue(strWriter.toString().contains("href=\"test\""));
+			assertTrue(strWriter.toString().contains("title=\"myTitle\""));
+			assertTrue(strWriter.toString().contains("hreflang=\"test1\""));
+			assertTrue(strWriter.toString().contains("type=\"myType\""));
+			assertTrue(strWriter.toString().contains("rel=\"NEXT\""));
+			assertTrue(strWriter.toString().contains("length=\"2\""));
+		}
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMLinkImpl.writeRssOutput(GOMWriter)'
+	 */
+	public void testWriteRssOutput() throws XMLStreamException {
+		{
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			this.impl.writeRssOutput(writer);
+			assertEquals("", strWriter.toString());
+		}
+
+		{
+			this.impl.setHref("test");
+			this.impl.setType("testType");
+			this.impl.setRel("enclosure");
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			this.impl.writeRssOutput(writer);
+			assertEquals("<enclosure type=\"testType\" href=\"test\"/>",
+					strWriter.toString());
+		}
+
+		{
+			this.impl.setRel("comments");
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			this.impl.writeRssOutput(writer);
+			assertEquals("<comments>test</comments>", strWriter.toString());
+		}
+
+		{
+			this.impl.setRel("alternate");
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			this.impl.writeRssOutput(writer);
+			assertEquals("<link>test</link>", strWriter.toString());
+		}
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.AbstractGOMElement.processElementValue(String)'
+	 */
+	public void testProcessElementValue() {
+		try {
+			this.impl.processElementValue("hello world");
+			fail("no content");
+		} catch (GDataParseException e) {
+			// TODO: handle exception
+		}
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMPersonImplTest.java b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMPersonImplTest.java
new file mode 100644
index 0000000..70235fa
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMPersonImplTest.java
@@ -0,0 +1,176 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import java.io.StringWriter;
+
+import javax.naming.NameParser;
+import javax.xml.namespace.QName;
+import javax.xml.stream.FactoryConfigurationError;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.GOMNamespace;
+import org.apache.lucene.gdata.gom.writer.GOMStaxWriter;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+import junit.framework.TestCase;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class GOMPersonImplTest extends TestCase {
+
+	/**
+	 * @see junit.framework.TestCase#setUp()
+	 */
+	@Override
+	protected void setUp() throws Exception {
+		// TODO Auto-generated method stub
+		super.setUp();
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMPersonImpl.writeAtomOutput(GOMWriter)'
+	 */
+	public void testWriteAtomOutput() throws XMLStreamException,
+			FactoryConfigurationError {
+		StringWriter stW = new StringWriter();
+		GOMOutputWriter writer = new GOMStaxWriter(stW);
+		GOMPersonImpl impl = new GOMPersonImpl();
+		impl.writeRssOutput(writer);
+		writer.flush();
+		writer.close();
+
+		// test with name
+		stW = new StringWriter();
+		writer = new GOMStaxWriter(stW);
+		impl.setName("test");
+		impl.writeAtomOutput(writer);
+		writer.flush();
+		assertEquals("<person><name>test</name></person>", stW.toString());
+
+		writer.close();
+
+		// test with name
+		stW = new StringWriter();
+		writer = new GOMStaxWriter(stW);
+		impl.setEmail("simonw@apache.org");
+		impl.setUri("http://www.apache.org");
+		impl.writeAtomOutput(writer);
+		writer.flush();
+		assertEquals(
+				"<person><name>test</name><email>simonw@apache.org</email><uri>http://www.apache.org</uri></person>",
+				stW.toString());
+		try {
+			impl.writeAtomOutput(null);
+			fail("must not be null");
+
+		} catch (GDataParseException e) {
+			//
+		}
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMPersonImpl.writeRssOutput(GOMWriter)'
+	 */
+	public void testWriteRssOutput() throws XMLStreamException {
+		StringWriter stW = new StringWriter();
+		GOMOutputWriter writer = new GOMStaxWriter(stW);
+		GOMPersonImpl impl = new GOMPersonImpl();
+		impl.writeRssOutput(writer);
+		writer.flush();
+		assertEquals(0, stW.toString().length());
+	}
+
+	public void testParseAtom() {
+		GOMPersonImpl impl = new GOMPersonImpl();
+		QName name = new QName(GOMNamespace.ATOM_NS_URI, "name");
+		AtomParser childParser = impl.getChildParser(name);
+		String nameValue = "simonw";
+		{
+			assertTrue(childParser instanceof GOMPersonImpl.NameParser);
+
+			childParser.processElementValue(nameValue);
+			childParser.processEndElement();
+			assertEquals(impl.getName(), nameValue);
+			try {
+				childParser.processElementValue(nameValue);
+				childParser.processEndElement();
+				fail("duplicated element");
+
+			} catch (GDataParseException e) {
+				// 
+
+			}
+		}
+		{
+			name = new QName(GOMNamespace.ATOM_NS_URI, "uri");
+			childParser = impl.getChildParser(name);
+			assertTrue(childParser instanceof GOMPersonImpl.UriParser);
+
+			childParser.processElementValue(nameValue);
+			childParser.processEndElement();
+			assertEquals(impl.getUri(), nameValue);
+
+			try {
+				childParser.processElementValue(nameValue);
+				childParser.processEndElement();
+				fail("duplicated element");
+
+			} catch (GDataParseException e) {
+				// 
+
+			}
+
+		}
+		{
+			name = new QName(GOMNamespace.ATOM_NS_URI, "email");
+			childParser = impl.getChildParser(name);
+			assertTrue(childParser instanceof GOMPersonImpl.EmailParser);
+
+			childParser.processElementValue(nameValue);
+			childParser.processEndElement();
+			assertEquals(impl.getEmail(), nameValue);
+
+			try {
+				childParser.processElementValue(nameValue);
+				childParser.processEndElement();
+				fail("duplicated element");
+
+			} catch (GDataParseException e) {
+				// 
+
+			}
+		}
+
+	}
+
+	public void testProcessEndElement() {
+		GOMPersonImpl impl = new GOMPersonImpl();
+		try {
+			impl.processEndElement();
+			fail("name must be set");
+		} catch (GDataParseException e) {
+			// 
+		}
+
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMSourceImplTest.java b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMSourceImplTest.java
new file mode 100644
index 0000000..bf07d66
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMSourceImplTest.java
@@ -0,0 +1,418 @@
+package org.apache.lucene.gdata.gom.core;
+
+import java.io.StringWriter;
+import java.util.List;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.FactoryConfigurationError;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.GOMAuthor;
+import org.apache.lucene.gdata.gom.GOMCategory;
+import org.apache.lucene.gdata.gom.GOMContributor;
+import org.apache.lucene.gdata.gom.GOMElement;
+import org.apache.lucene.gdata.gom.GOMEntry;
+import org.apache.lucene.gdata.gom.GOMExtension;
+import org.apache.lucene.gdata.gom.GOMFeed;
+import org.apache.lucene.gdata.gom.GOMGenerator;
+import org.apache.lucene.gdata.gom.GOMIcon;
+import org.apache.lucene.gdata.gom.GOMId;
+import org.apache.lucene.gdata.gom.GOMLink;
+import org.apache.lucene.gdata.gom.GOMLogo;
+import org.apache.lucene.gdata.gom.GOMNamespace;
+import org.apache.lucene.gdata.gom.GOMRights;
+import org.apache.lucene.gdata.gom.GOMSource;
+import org.apache.lucene.gdata.gom.GOMSubtitle;
+import org.apache.lucene.gdata.gom.GOMTitle;
+import org.apache.lucene.gdata.gom.GOMUpdated;
+import org.apache.lucene.gdata.gom.core.GOMFeedImplTest.TestExtendsionFactory;
+import org.apache.lucene.gdata.gom.core.GOMFeedImplTest.TestExtension;
+import org.apache.lucene.gdata.gom.core.extension.GOMExtensionFactory;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+import org.apache.lucene.gdata.gom.writer.GOMStaxWriter;
+
+import junit.framework.TestCase;
+
+public class GOMSourceImplTest extends TestCase {
+
+	static final String TEST_LOCAL_NAME = "testelement";
+
+	GOMSourceImpl impl;
+
+	protected void setUp() throws Exception {
+		this.impl = new GOMSourceImpl();
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.getChildParser(QName)'
+	 */
+	public void testGetChildParser() {
+
+		{
+			// atomAuthor*
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "author"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMAuthor);
+			assertEquals(1, this.impl.getAuthors().size());
+			this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
+					"author"));
+			assertEquals(2, this.impl.getAuthors().size());
+		}
+
+		{
+			// atomCategory*
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "category"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMCategory);
+			assertEquals(1, this.impl.getCategories().size());
+			this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
+					"category"));
+			assertEquals(2, this.impl.getCategories().size());
+		}
+
+		{
+			// atomContributor*
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "contributor"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMContributor);
+			assertEquals(1, this.impl.getContributor().size());
+			this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
+					"contributor"));
+			assertEquals(2, this.impl.getContributor().size());
+		}
+		{
+			// atomGenerator?
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "generator"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMGenerator);
+			assertSame(parser, this.impl.getGenerator());
+			try {
+				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
+						"generator"));
+				fail("one or zero");
+			} catch (GDataParseException e) {
+				// 
+			}
+		}
+
+		{
+			// atomIcon?
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "icon"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMIcon);
+			assertSame(parser, this.impl.getIcon());
+			try {
+				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
+						"icon"));
+				fail("one or zero");
+			} catch (GDataParseException e) {
+				// 
+			}
+
+		}
+
+		{
+			// atomId
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "id"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMId);
+			assertSame(parser, this.impl.getId());
+			try {
+				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
+						"id"));
+				fail("exactly one time ");
+			} catch (GDataParseException e) {
+				// 
+			}
+
+		}
+
+		{
+			// atomLink*
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "link"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMLink);
+			assertEquals(1, this.impl.getLinks().size());
+			this.impl
+					.getChildParser(new QName(GOMNamespace.ATOM_NS_URI, "link"));
+			assertEquals(2, this.impl.getLinks().size());
+
+		}
+
+		{
+			// atomLogo?
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "logo"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMLogo);
+			assertSame(parser, this.impl.getLogo());
+			try {
+				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
+						"logo"));
+				fail("zero or one");
+			} catch (GDataParseException e) {
+				// 
+			}
+
+		}
+
+		{
+			// atomRights?
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "rights"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMRights);
+			assertSame(parser, this.impl.getRights());
+			try {
+				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
+						"rights"));
+				fail("zero or one");
+			} catch (GDataParseException e) {
+				// 
+			}
+
+		}
+
+		{
+			// atomSubtitle?
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "subtitle"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMSubtitle);
+			assertSame(parser, this.impl.getSubtitle());
+			try {
+				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
+						"subtitle"));
+				fail("zero or one");
+			} catch (GDataParseException e) {
+				// 
+			}
+
+		}
+
+		{
+			// atomTitle
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "title"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMTitle);
+			assertSame(parser, this.impl.getTitle());
+			try {
+				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
+						"title"));
+				fail("exactly one time ");
+			} catch (GDataParseException e) {
+				// 
+			}
+
+		}
+
+		{
+			// atomUpdated
+			AtomParser parser = this.impl.getChildParser(new QName(
+					GOMNamespace.ATOM_NS_URI, "updated"));
+			assertNotNull(parser);
+			assertTrue(parser instanceof GOMUpdated);
+			assertSame(parser, this.impl.getUpdated());
+			try {
+				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
+						"updated"));
+				fail("exactly one time ");
+			} catch (GDataParseException e) {
+				// 
+			}
+
+		}
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.processElementValue(String)'
+	 */
+	public void testProcessElementValue() {
+		try {
+			this.impl.processElementValue("some");
+			fail("no element text");
+		} catch (GDataParseException e) {
+			//
+		}
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.processEndElement()'
+	 * 
+	 * atomFeed = element atom:feed { atomCommonAttributes, (atomAuthor* &
+	 * atomCategory* & atomContributor* & atomGenerator? & atomIcon? & atomId &
+	 * atomLink* & atomLogo? & atomRights? & atomSubtitle? & atomTitle &
+	 * atomUpdated & extensionElement*), atomEntry* }
+	 */
+	public void testProcessEndElement() {
+		this.impl.addAuthor(new GOMAuthorImpl());
+		this.impl.setId(new GOMIdImpl());
+		this.impl.setUpdated(new GOMUpdatedImpl());
+		this.impl.setTitle(new GOMTitleImpl());
+
+		this.impl.processEndElement();
+		{
+			// author missing
+			this.impl.getAuthors().clear();
+			try {
+				this.impl.processEndElement();
+				fail("missing elements");
+			} catch (GDataParseException e) {
+				// 
+			}
+			this.impl.addAuthor(new GOMAuthorImpl());
+		}
+
+		{
+			// id missing
+			this.impl.setId(null);
+			try {
+				this.impl.processEndElement();
+				fail("missing elements");
+			} catch (GDataParseException e) {
+				// 
+			}
+			this.impl.setId(new GOMIdImpl());
+		}
+
+		{
+			// title missing
+			this.impl.setTitle(null);
+			try {
+				this.impl.processEndElement();
+				fail("missing elements");
+			} catch (GDataParseException e) {
+				// 
+			}
+			this.impl.setTitle(new GOMTitleImpl());
+		}
+		{
+			// updated missing
+			this.impl.setUpdated(null);
+			try {
+				this.impl.processEndElement();
+				fail("missing elements");
+			} catch (GDataParseException e) {
+				// 
+			}
+			this.impl.setUpdated(new GOMUpdatedImpl());
+		}
+
+		/*
+		 * atom:feed elements MUST NOT contain more than one atom:link element
+		 * with a rel attribute value of "alternate" that has the same
+		 * combination of type and hreflang attribute values.
+		 */
+
+		{
+			// two identical alternate links missing
+			GOMLink link = new GOMLinkImpl();
+			link.setRel("alternate");
+			link.setHrefLang("http://www.apache.org");
+			link.setType("text/html");
+			this.impl.addLink(link);
+			// one is allowed
+			this.impl.processEndElement();
+			// add a second link
+			link = new GOMLinkImpl();
+			this.impl.addLink(link);
+			link.setRel("next");
+			link.setHrefLang("http://www.apache.org");
+			link.setType("text/html");
+			// one is alternate the other is next
+			this.impl.processEndElement();
+
+			// a second "identical" alternate link
+			link = new GOMLinkImpl();
+			this.impl.addLink(link);
+			link.setRel("alternate");
+			link.setHrefLang("http://www.apache.org");
+			link.setType("text/html");
+			try {
+				this.impl.processEndElement();
+				fail("missing elements");
+			} catch (GDataParseException e) {
+				// 
+			}
+			this.impl.setUpdated(new GOMUpdatedImpl());
+		}
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.GOMFeedImpl()'
+	 */
+	public void testGOMFeedImpl() {
+		GOMFeedImpl impl2 = new GOMFeedImpl();
+		assertEquals(GOMFeed.LOCALNAME, impl2.getLocalName());
+		assertEquals(GOMFeed.LOCALNAME, impl2.getQname().getLocalPart());
+		assertEquals(GOMNamespace.ATOM_NS_URI, impl2.getQname()
+				.getNamespaceURI());
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.writeAtomOutput(GOMWriter)'
+	 */
+	public void testWriteAtomOutput() throws XMLStreamException,
+			FactoryConfigurationError {
+		// write a whole feed and check if all elements are written
+		this.impl.addAuthor(new GOMAuthorImpl());
+		this.impl.addCategory(new GOMCategoryImpl());
+		this.impl.addContributor(new GOMContributorImpl());
+		this.impl.addLink(new GOMLinkImpl());
+		this.impl.setGenerator(new GOMGeneratorImpl());
+		this.impl.setIcon(new GOMIconImpl());
+		this.impl.setId(new GOMIdImpl());
+		this.impl.setLogo(new GOMLogoImpl());
+		this.impl.setRights(new GOMRightsImpl());
+		this.impl.setSubtitle(new GOMSubtitleImpl());
+		this.impl.setTitle(new GOMTitleImpl());
+		this.impl.setUpdated(new GOMUpdatedImpl());
+		StringWriter stW = new StringWriter();
+		GOMOutputWriter writer = new GOMStaxWriter(stW);
+		this.impl.writeAtomOutput(writer);
+		String string = stW.toString();
+		assertTrue(string.startsWith("<" + GOMSource.LOCALNAME));
+		assertTrue(string.contains("<" + GOMAuthor.LOCALNAME));
+		assertTrue(string.contains("<" + GOMCategory.LOCALNAME));
+		assertTrue(string.contains("<" + GOMContributor.LOCALNAME));
+		assertTrue(string.contains("<" + GOMLink.LOCALNAME));
+		assertTrue(string.contains("<" + GOMGenerator.LOCALNAME));
+		assertTrue(string.contains("<" + GOMIcon.LOCALNAME));
+		assertTrue(string.contains("<" + GOMId.LOCALNAME));
+		assertTrue(string.contains("<" + GOMLogo.LOCALNAME));
+		assertTrue(string.contains("<" + GOMRights.LOCALNAME));
+		assertTrue(string.contains("<" + GOMSubtitle.LOCALNAME));
+		assertTrue(string.contains("<" + GOMTitle.LOCALNAME));
+		assertTrue(string.contains("<" + GOMUpdated.LOCALNAME));
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.writeRssOutput(GOMWriter)'
+	 */
+	public void testWriteRssOutput() throws XMLStreamException,
+			FactoryConfigurationError {
+
+		StringWriter stW = new StringWriter();
+		GOMOutputWriter writer = new GOMStaxWriter(stW);
+		this.impl.writeRssOutput(writer);
+		assertEquals("", stW.toString());
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMTextConstructImplTest.java b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMTextConstructImplTest.java
new file mode 100644
index 0000000..7ef47a3
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMTextConstructImplTest.java
@@ -0,0 +1,257 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import java.io.StringWriter;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.FactoryConfigurationError;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.ContentType;
+import org.apache.lucene.gdata.gom.core.GOMTextContructImpl.XMLBlobContentParser;
+import org.apache.lucene.gdata.gom.writer.GOMStaxWriter;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+import junit.framework.TestCase;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class GOMTextConstructImplTest extends TestCase {
+	GOMTitleImpl titleImpl;
+
+	GOMSubtitleImpl subTitleImpl;
+
+	protected void setUp() throws Exception {
+		this.titleImpl = new GOMTitleImpl();
+		this.subTitleImpl = new GOMSubtitleImpl();
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMTextContructImpl.getChildParser(QName)'
+	 */
+	public void testGetChildParser() {
+		try {
+			this.titleImpl.getChildParser(null);
+			fail("qname must not be null");
+		} catch (GDataParseException e) {
+			// 
+		}
+		try {
+			this.titleImpl.getChildParser(new QName("test"));
+			fail("no such child supported");
+		} catch (GDataParseException e) {
+			// 
+		}
+
+		try {
+			this.titleImpl.getChildParser(new QName("div"));
+			fail("content type not set");
+		} catch (GDataParseException e) {
+			// 
+		}
+		this.titleImpl.contentType = ContentType.XHTML;
+		AtomParser childParser = this.titleImpl
+				.getChildParser(new QName("div"));
+		assertNotNull(childParser);
+		assertTrue(childParser instanceof XMLBlobContentParser);
+		try {
+			this.titleImpl.getChildParser(new QName("div"));
+			fail("duplicated element");
+		} catch (GDataParseException e) {
+			// 
+		}
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMTextContructImpl.processAttribute(QName,
+	 * String)' includes Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMTextContructImpl.getContentType()
+	 */
+	public void testProcessAttribute() {
+		try {
+			this.titleImpl.processAttribute(null, "test");
+			fail("qname is null");
+		} catch (GDataParseException e) {
+			// 
+		}
+		this.titleImpl.processAttribute(new QName("type"), "text");
+		assertEquals(ContentType.TEXT, this.titleImpl.getContentType());
+		this.titleImpl.contentType = null;
+		this.titleImpl.processAttribute(new QName("type"), "html");
+		assertEquals(ContentType.HTML, this.titleImpl.getContentType());
+		this.titleImpl.contentType = null;
+		this.titleImpl.processAttribute(new QName("type"), "xhtml");
+		assertEquals(ContentType.XHTML, this.titleImpl.getContentType());
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMTextContructImpl.processElementValue(String)'
+	 */
+	public void testProcessElementValue() {
+		this.titleImpl.processElementValue("test");
+		assertEquals("test", this.titleImpl.getTextValue());
+		assertNull(this.titleImpl.htmlBuilder);
+		this.titleImpl.processAttribute(new QName("type"), "html");
+		assertNotNull(this.titleImpl.htmlBuilder);
+
+		this.titleImpl.processElementValue("test");
+		assertEquals("test", this.titleImpl.getTextValue());
+		assertEquals("test", this.titleImpl.htmlBuilder.toString());
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMTextContructImpl.processEndElement()'
+	 */
+	public void testProcessEndElement() {
+		try {
+			this.titleImpl.processEndElement();
+			fail("no content type");
+		} catch (GDataParseException e) {
+			// 
+		}
+		this.titleImpl.contentType = ContentType.TEXT;
+		this.titleImpl.processEndElement();
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMTextContructImpl.writeAtomOutput(GOMWriter)'
+	 */
+	public void testWriteAtomOutput() throws XMLStreamException,
+			FactoryConfigurationError {
+		{
+			this.titleImpl.contentType = ContentType.TEXT;
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			this.titleImpl.writeAtomOutput(writer);
+			assertEquals("<title type=\"text\"/>", strWriter.toString());
+		}
+		{
+			this.titleImpl.setTextValue("><hello world");
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			this.titleImpl.writeAtomOutput(writer);
+			assertEquals("<title type=\"text\">&gt;&lt;hello world</title>",
+					strWriter.toString());
+		}
+
+		{
+			this.titleImpl.contentType = ContentType.HTML;
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			this.titleImpl.writeAtomOutput(writer);
+			assertEquals("<title type=\"html\">&gt;&lt;hello world</title>",
+					strWriter.toString());
+		}
+
+		{
+			this.titleImpl.contentType = ContentType.XHTML;
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			this.titleImpl.writeAtomOutput(writer);
+			assertEquals("<title type=\"xhtml\">><hello world</title>",
+					strWriter.toString());
+		}
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.GOMTextContructImpl.writeRssOutput(GOMWriter)'
+	 */
+	public void testWriteRssOutput() throws XMLStreamException {
+
+		{
+			this.titleImpl.contentType = ContentType.TEXT;
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			this.titleImpl.writeRssOutput(writer);
+			assertEquals("<title/>", strWriter.toString());
+		}
+		{
+			this.titleImpl.setTextValue("><hello world");
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			this.titleImpl.writeRssOutput(writer);
+			assertEquals("<title>&gt;&lt;hello world</title>", strWriter
+					.toString());
+		}
+
+		{
+			this.titleImpl.contentType = ContentType.HTML;
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			this.titleImpl.writeRssOutput(writer);
+			assertEquals("<title>&gt;&lt;hello world</title>", strWriter
+					.toString());
+		}
+
+		{
+			this.titleImpl.contentType = ContentType.XHTML;
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			this.titleImpl.writeRssOutput(writer);
+			// no markup in rss
+			assertEquals("<title>&gt;&lt;hello world</title>", strWriter
+					.toString());
+		}
+
+		{
+			this.titleImpl.contentType = ContentType.XHTML;
+			this.titleImpl.xmlBase = "http://www.apache.org";
+			this.titleImpl.xmlLang = "en";
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			this.titleImpl.writeRssOutput(writer);
+			// no markup in rss
+			assertEquals(
+					"<title xml:base=\"http://www.apache.org\" xml:lang=\"en\">&gt;&lt;hello world</title>",
+					strWriter.toString());
+		}
+
+		{
+			this.subTitleImpl.contentType = ContentType.XHTML;
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			this.subTitleImpl.writeRssOutput(writer);
+
+			assertEquals("<description/>", strWriter.toString());
+		}
+
+		{
+			this.subTitleImpl.contentType = ContentType.XHTML;
+			this.subTitleImpl.setTextValue("><hello world");
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			this.subTitleImpl.writeRssOutput(writer);
+
+			assertEquals("<description>&gt;&lt;hello world</description>",
+					strWriter.toString());
+		}
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/SimpleGOMElementImplTest.java b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/SimpleGOMElementImplTest.java
new file mode 100644
index 0000000..4dd1c9c
--- /dev/null
+++ b/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/SimpleGOMElementImplTest.java
@@ -0,0 +1,136 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.gom.core;
+
+import java.io.StringWriter;
+
+import javax.xml.stream.FactoryConfigurationError;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.lucene.gdata.gom.GOMNamespace;
+import org.apache.lucene.gdata.gom.writer.GOMStaxWriter;
+import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
+
+import junit.framework.TestCase;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class SimpleGOMElementImplTest extends TestCase {
+	String localName = "test";
+
+	SimpleGOMElementImpl impl;
+
+	/**
+	 * @see junit.framework.TestCase#setUp()
+	 */
+	@Override
+	protected void setUp() throws Exception {
+		this.impl = new SimpleGOMElementImpl(localName,
+				GOMNamespace.ATOM_NAMESPACE);
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.SimpleGOMElementImpl.processElementValue(String)'
+	 */
+	public void testProcessElementValue() {
+		this.impl.processElementValue("myValue");
+		assertEquals("myValue", this.impl.getTextValue());
+
+		try {
+			this.impl.processElementValue("myValue");
+			fail("duplicated");
+
+		} catch (GDataParseException e) {
+			// 
+		}
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.SimpleGOMElementImpl.processEndElement()'
+	 */
+	public void testProcessEndElement() {
+		// depends validator
+		this.impl.processEndElement();
+		this.impl
+				.setValidator(new GOMFeedImpl.PositiveIntegerValidator("test"));
+		try {
+			this.impl.processEndElement();
+			fail("value is null");
+		} catch (GDataParseException e) {
+			assertTrue(e.getMessage().indexOf("requires a element value") > 0);
+		}
+		this.impl.setTextValue("1");
+		this.impl.processEndElement();
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.SimpleGOMElementImpl.SimpleGOMElementImpl(String,
+	 * GOMNamespace)'
+	 */
+	public void testSimpleGOMElementImpl() {
+		try {
+			new SimpleGOMElementImpl(null, GOMNamespace.ATOM_NAMESPACE);
+			fail("localname is null");
+		} catch (IllegalArgumentException e) {
+			// 
+		}
+		try {
+			new SimpleGOMElementImpl("test", null);
+			fail("namespace is null");
+		} catch (IllegalArgumentException e) {
+			// 
+		}
+
+		SimpleGOMElementImpl impl2 = new SimpleGOMElementImpl(this.localName,
+				GOMNamespace.ATOM_NAMESPACE);
+		assertEquals(impl2.getQname().getNamespaceURI(),
+				GOMNamespace.ATOM_NS_URI);
+		assertEquals(impl2.getQname().getPrefix(), GOMNamespace.ATOM_NS_PREFIX);
+		assertEquals(impl2.getQname().getLocalPart(), this.localName);
+		assertEquals(impl2.getLocalName(), this.localName);
+
+	}
+
+	/*
+	 * Test method for
+	 * 'org.apache.lucene.gdata.gom.core.SimpleGOMElementImpl.writeAtomOutput(GOMWriter)'
+	 */
+	public void testWriteAtomOutput() throws XMLStreamException,
+			FactoryConfigurationError {
+		{
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			this.impl.writeAtomOutput(writer);
+			assertEquals("<atom:" + this.localName + "/>", strWriter.toString());
+		}
+		{
+			StringWriter strWriter = new StringWriter();
+			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
+			this.impl.setTextValue("hello world");
+			this.impl.writeAtomOutput(writer);
+			assertEquals("<atom:" + this.localName + ">hello world</atom:"
+					+ this.localName + ">", strWriter.toString());
+		}
+	}
+
+}
diff --git a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/GOMNamespaceTest.java b/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/GOMNamespaceTest.java
deleted file mode 100644
index 887d6a2..0000000
--- a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/GOMNamespaceTest.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom;
-
-import junit.framework.TestCase;
-
-/**
- * Testcase for GOMNamespace
- * 
- * @author Simon Willnauer
- * 
- */
-public class GOMNamespaceTest extends TestCase {
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.GOMNamespace.GOMNamespace(String, String)'
-	 */
-	public void testGOMNamespace() {
-		try {
-			GOMNamespace namespace = new GOMNamespace(null, "a");
-			fail("uri is null");
-		} catch (IllegalArgumentException e) {
-			//
-		}
-		try {
-			new GOMNamespace("a", null);
-		} catch (Exception e) {
-			fail("unexp. exc");
-		}
-
-		GOMNamespace namespace = new GOMNamespace(GOMNamespace.ATOM_NS_URI,
-				GOMNamespace.ATOM_NS_PREFIX);
-		assertEquals(GOMNamespace.ATOM_NS_PREFIX, namespace
-				.getNamespacePrefix());
-		assertEquals(GOMNamespace.ATOM_NS_URI, namespace.getNamespaceUri());
-		//		
-
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/ArbitraryGOMXmlTest.java b/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/ArbitraryGOMXmlTest.java
deleted file mode 100644
index 0d0773e..0000000
--- a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/ArbitraryGOMXmlTest.java
+++ /dev/null
@@ -1,179 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import java.io.StringWriter;
-import java.util.List;
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.FactoryConfigurationError;
-import javax.xml.stream.XMLStreamException;
-
-import junit.framework.TestCase;
-
-import org.apache.lucene.gdata.gom.GOMAttribute;
-import org.apache.lucene.gdata.gom.writer.GOMStaxWriter;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class ArbitraryGOMXmlTest extends TestCase {
-	private ArbitraryGOMXml arbXML;
-
-	private QName name = new QName("testme");
-
-	protected void setUp() throws Exception {
-		super.setUp();
-
-		arbXML = new ArbitraryGOMXml(name);
-	}
-
-	protected void tearDown() throws Exception {
-		super.tearDown();
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.ArbitraryGOMXml.getChildParser(QName)'
-	 */
-	public void testGetChildParser() {
-
-		try {
-			this.arbXML.getChildParser(null);
-			fail("qname is null");
-		} catch (GDataParseException e) {
-			assertEquals(0, this.arbXML.getChildren().size());
-		}
-		AtomParser childParser = this.arbXML.getChildParser(this.name);
-		assertTrue(childParser instanceof ArbitraryGOMXml);
-
-		assertEquals(name, ((ArbitraryGOMXml) childParser).getQname());
-		assertEquals(name.getLocalPart(), ((ArbitraryGOMXml) childParser)
-				.getLocalName());
-		assertEquals(1, this.arbXML.getChildren().size());
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.ArbitraryGOMXml.processAttribute(QName,
-	 * String)'
-	 */
-	public void testProcessAttribute() {
-		try {
-			this.arbXML.processAttribute(null, "test");
-			fail("qname is null");
-
-		} catch (GDataParseException e) {
-			assertTrue(this.arbXML.getAttributes().size() == 0);
-		}
-		this.arbXML.processAttribute(name, "testme");
-		{
-			List<GOMAttribute> attributes = this.arbXML.getAttributes();
-			assertTrue(attributes.size() == 1);
-			GOMAttribute attribute = attributes.get(0);
-			assertNotNull(attribute);
-			assertEquals(name, attribute.getQname());
-			assertEquals(name.getLocalPart(), attribute.getLocalName());
-			assertEquals("testme", attribute.getTextValue());
-		}
-
-		{
-			this.arbXML.processAttribute(name, null);
-			List<GOMAttribute> attributes = this.arbXML.getAttributes();
-			assertTrue(attributes.size() == 2);
-			GOMAttribute attribute = attributes.get(1);
-			assertNotNull(attribute);
-			assertEquals(name, attribute.getQname());
-			assertEquals(name.getLocalPart(), attribute.getLocalName());
-			assertEquals("", attribute.getTextValue());
-		}
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.ArbitraryGOMXml.processElementValue(String)'
-	 */
-	public void testProcessElementValue() {
-		try {
-			this.arbXML.processElementValue(null);
-			fail("name is null");
-		} catch (GDataParseException e) {
-			// 
-		}
-		this.arbXML.processElementValue("test value");
-
-		try {
-			this.arbXML.processElementValue("test value");
-			fail("value is already set");
-		} catch (GDataParseException e) {
-			//
-		}
-		assertEquals("test value", this.arbXML.getTextValue());
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.ArbitraryGOMXml.ArbitraryGOMXml(QName)'
-	 */
-	public void testArbitraryGOMXml() {
-		try {
-			new ArbitraryGOMXml(null);
-			fail("qname is null");
-		} catch (IllegalArgumentException e) {
-
-		}
-		ArbitraryGOMXml xml = new ArbitraryGOMXml(name);
-		assertEquals(name, xml.getQname());
-		assertEquals(name.getLocalPart(), xml.getLocalName());
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.ArbitraryGOMXml.writeAtomOutput(GOMWriter)'
-	 */
-	public void testWriteAtomOutput() throws XMLStreamException,
-			FactoryConfigurationError {
-		{
-			StringWriter writer = new StringWriter();
-			GOMOutputWriter w = new GOMStaxWriter(writer);
-			this.arbXML.writeAtomOutput(w);
-			assertNotNull(w.toString());
-			assertEquals("<" + this.name.getLocalPart() + "/>", writer
-					.toString());
-		}
-		try {
-			this.arbXML.writeAtomOutput(null);
-			fail("writer is null");
-
-		} catch (NullPointerException e) {
-			// 
-		}
-		{
-			this.arbXML.processAttribute(name, "testme1");
-			this.arbXML.processElementValue("testme2");
-			StringWriter writer = new StringWriter();
-			GOMOutputWriter w = new GOMStaxWriter(writer);
-			this.arbXML.writeAtomOutput(w);
-			assertEquals("<" + this.name.getLocalPart()
-					+ " testme=\"testme1\">" + "testme2" + "</"
-					+ this.name.getLocalPart() + ">", writer.toString());
-		}
-	}
-}
diff --git a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/AtomUriElementTest.java b/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/AtomUriElementTest.java
deleted file mode 100644
index 9b44f73..0000000
--- a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/AtomUriElementTest.java
+++ /dev/null
@@ -1,136 +0,0 @@
-package org.apache.lucene.gdata.gom.core;
-
-import java.io.StringWriter;
-
-import javax.xml.stream.FactoryConfigurationError;
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.GOMIcon;
-import org.apache.lucene.gdata.gom.GOMLogo;
-import org.apache.lucene.gdata.gom.writer.GOMStaxWriter;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-import junit.framework.TestCase;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class AtomUriElementTest extends TestCase {
-	GOMIconImpl iconImpl;
-
-	GOMLogoImpl logoImpl;
-
-	protected void setUp() throws Exception {
-		this.iconImpl = new GOMIconImpl();
-		this.logoImpl = new GOMLogoImpl();
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.AtomUriElement.processEndElement()'
-	 */
-	public void testProcessEndElement() {
-		try {
-			this.iconImpl.processEndElement();
-			fail("no text value");
-		} catch (GDataParseException e) {
-			assertTrue(e.getMessage().indexOf("requires a element value") > 0);
-		}
-
-		try {
-			this.iconImpl.setTextValue("test");
-
-			this.iconImpl.processEndElement();
-			fail("no text value");
-		} catch (GDataParseException e) {
-			assertTrue(e.getMessage().indexOf("must be a") > 0);
-		}
-		try {
-			this.iconImpl.setTextValue("/test");
-
-			this.iconImpl.processEndElement();
-			fail("no text value");
-		} catch (GDataParseException e) {
-			assertTrue(e.getMessage().indexOf("must be a") > 0);
-		}
-		this.iconImpl.xmlBase = "http://www.apache.org";
-		this.iconImpl.setTextValue("/test");
-
-		this.iconImpl.processEndElement();
-
-		this.iconImpl.xmlBase = null;
-		this.iconImpl.setTextValue("http://www.apache.org/test");
-
-	}
-
-	public void testConstructor() {
-		assertEquals(GOMIcon.LOCALNAME, this.iconImpl.getLocalName());
-		assertEquals(GOMIcon.LOCALNAME, this.iconImpl.getQname().getLocalPart());
-		assertEquals(GOMLogo.LOCALNAME, this.logoImpl.getLocalName());
-		assertEquals(GOMLogo.LOCALNAME, this.logoImpl.getQname().getLocalPart());
-	}
-
-	public void testWriteRssOutput() throws XMLStreamException,
-			FactoryConfigurationError {
-
-		{
-			StringWriter stW = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(stW);
-			this.iconImpl.writeRssOutput(writer);
-			assertEquals("<url/>", stW.toString());
-		}
-		{
-			StringWriter stW = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(stW);
-			this.iconImpl.setTextValue("test");
-			this.iconImpl.writeRssOutput(writer);
-			assertEquals("<url>test</url>", stW.toString());
-		}
-
-		{
-			StringWriter stW = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(stW);
-			this.logoImpl.writeRssOutput(writer);
-			assertEquals("<url/>", stW.toString());
-		}
-		{
-			StringWriter stW = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(stW);
-			this.logoImpl.setTextValue("test");
-			this.logoImpl.writeRssOutput(writer);
-			assertEquals("<url>test</url>", stW.toString());
-		}
-	}
-
-	public void testWriteAtomOutput() throws XMLStreamException {
-		{
-			StringWriter stW = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(stW);
-			this.iconImpl.writeAtomOutput(writer);
-			assertEquals("<icon/>", stW.toString());
-		}
-		{
-			StringWriter stW = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(stW);
-			this.iconImpl.setTextValue("test");
-			this.iconImpl.writeAtomOutput(writer);
-			assertEquals("<icon>test</icon>", stW.toString());
-		}
-
-		{
-			StringWriter stW = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(stW);
-			this.logoImpl.writeAtomOutput(writer);
-			assertEquals("<logo/>", stW.toString());
-		}
-		{
-			StringWriter stW = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(stW);
-			this.logoImpl.setTextValue("test");
-			this.logoImpl.writeAtomOutput(writer);
-			assertEquals("<logo>test</logo>", stW.toString());
-		}
-	}
-}
diff --git a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMAttributeImplTest.java b/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMAttributeImplTest.java
deleted file mode 100644
index 094b066..0000000
--- a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMAttributeImplTest.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.gom.core;
-
-import javax.xml.namespace.QName;
-
-import junit.framework.TestCase;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class GOMAttributeImplTest extends TestCase {
-	protected GOMAttributeImpl gomAttribute;
-
-	protected void setUp() throws Exception {
-		gomAttribute = new GOMAttributeImpl("test", "test");
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMAttributeImpl.GOMAttributeImpl(String,
-	 * String)'
-	 */
-	public void testGOMAttributeImplStringString() {
-		GOMAttributeImpl impl = new GOMAttributeImpl("test", "test");
-		assertTrue(impl.hasDefaultNamespace());
-		assertTrue(impl.getLocalName().equals(impl.getTextValue()));
-		assertEquals("test", impl.getLocalName());
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMAttributeImpl.GOMAttributeImpl(String,
-	 * String, String, String)'
-	 */
-	public void testGOMAttributeImplStringStringStringString() {
-		GOMAttributeImpl impl = new GOMAttributeImpl("www.apache.org", "ap",
-				"test", "test");
-		assertFalse(impl.hasDefaultNamespace());
-		assertTrue(impl.getLocalName().equals(impl.getTextValue()));
-		assertEquals("test", impl.getLocalName());
-		assertEquals("www.apache.org", impl.getQname().getNamespaceURI());
-		assertEquals("ap", impl.getQname().getPrefix());
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMAttributeImpl.getQname()'
-	 */
-	public void testGetQname() {
-		QName qname = gomAttribute.getQname();
-		assertSame(qname, gomAttribute.getQname());
-		assertTrue(gomAttribute.hasDefaultNamespace());
-		gomAttribute.setNamespaceUri("something else");
-		assertNotSame(qname, gomAttribute.getQname());
-		assertFalse(gomAttribute.hasDefaultNamespace());
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMAuthorImplTest.java b/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMAuthorImplTest.java
deleted file mode 100644
index 04d4888..0000000
--- a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMAuthorImplTest.java
+++ /dev/null
@@ -1,84 +0,0 @@
-package org.apache.lucene.gdata.gom.core;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-import java.io.StringWriter;
-
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.GOMAuthor;
-import org.apache.lucene.gdata.gom.writer.GOMStaxWriter;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-import junit.framework.TestCase;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class GOMAuthorImplTest extends TestCase {
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMAuthorImpl.writeRssOutput(GOMWriter)'
-	 */
-	public void testWriteRssOutput() throws XMLStreamException {
-		GOMAuthorImpl impl = new GOMAuthorImpl();
-		try {
-			impl.writeRssOutput(null);
-			fail("writer is null");
-		} catch (GDataParseException e) {
-		}
-		StringWriter writer2 = new StringWriter();
-
-		GOMOutputWriter writer = new GOMStaxWriter(writer2);
-		impl.writeRssOutput(writer, "test");
-		writer.flush();
-		writer2.flush();
-
-		assertEquals("<test></test>", writer2.toString());
-		impl.setEmail("simonw@apache.org");
-		impl.setUri("someuri");
-		writer.close();
-
-		writer2 = new StringWriter();
-		writer = new GOMStaxWriter(writer2);
-		impl.writeRssOutput(writer);
-		writer.flush();
-		writer2.flush();
-		assertTrue(writer2.toString().length() > 0);
-
-		assertEquals("<" + GOMAuthor.LOCALNAME + ">" + impl.getEmail() + "</"
-				+ GOMAuthor.LOCALNAME + ">", writer2.toString());
-
-		writer.close();
-
-		impl.setName("simonw");
-		writer2 = new StringWriter();
-		writer = new GOMStaxWriter(writer2);
-		impl.writeRssOutput(writer);
-		writer.flush();
-		writer2.flush();
-		assertTrue(writer2.toString().length() > 0);
-
-		assertEquals("<" + GOMAuthor.LOCALNAME + ">" + impl.getEmail() + "("
-				+ impl.getName() + ")</" + GOMAuthor.LOCALNAME + ">", writer2
-				.toString());
-
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMCategoryTest.java b/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMCategoryTest.java
deleted file mode 100644
index 7da016f..0000000
--- a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMCategoryTest.java
+++ /dev/null
@@ -1,262 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.gom.core;
-
-import java.io.StringWriter;
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.GOMNamespace;
-import org.apache.lucene.gdata.gom.writer.GOMStaxWriter;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-import junit.framework.TestCase;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class GOMCategoryTest extends TestCase {
-	private QName qname = new QName(GOMNamespace.ATOM_NS_URI, "testme", "");
-
-	GOMCategoryImpl cat;
-
-	protected void setUp() throws Exception {
-		this.cat = new GOMCategoryImpl();
-	}
-
-	protected void tearDown() throws Exception {
-		super.tearDown();
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMCategoryImpl.writeAtomOutput(GOMWriter)'
-	 */
-	public void testWriteAtomOutput() throws XMLStreamException {
-		try {
-			this.cat.writeAtomOutput(null);
-			fail("wirter is null");
-		} catch (NullPointerException e) {
-			// 
-		}
-		{
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			this.cat.writeAtomOutput(writer);
-			assertEquals("<category term=\"\"/>", strWriter.toString());
-
-		}
-
-		{
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			this.cat.term = "test";
-			this.cat.writeAtomOutput(writer);
-			assertEquals("<category term=\"test\"/>", strWriter.toString());
-
-		}
-
-		{
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			this.cat.label = "python";
-			this.cat.scheme = "monty";
-
-			this.cat.writeAtomOutput(writer);
-			assertEquals(
-					"<category term=\"test\" scheme=\"monty\" label=\"python\"/>",
-					strWriter.toString());
-
-		}
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMCategoryImpl.writeRssOutput(GOMWriter)'
-	 */
-	public void testWriteRssOutput() throws XMLStreamException {
-		try {
-			this.cat.writeRssOutput(null);
-			fail("wirter is null");
-		} catch (NullPointerException e) {
-			// 
-		}
-
-		{
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			this.cat.writeRssOutput(writer);
-			assertEquals("<category domain=\"\"/>", strWriter.toString());
-		}
-
-		{
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			this.cat.scheme = "www.apache.org";
-			this.cat.writeRssOutput(writer);
-			assertEquals("<category domain=\"www.apache.org\"/>", strWriter
-					.toString());
-		}
-
-		{
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			this.cat.scheme = "www.apache.org";
-			this.cat.term = "Goo Data";
-			this.cat.writeRssOutput(writer);
-			assertEquals(
-					"<category domain=\"www.apache.org\">Goo Data</category>",
-					strWriter.toString());
-		}
-
-		{
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			this.cat.scheme = "www.apache.org";
-			this.cat.term = "Goo Data";
-			this.cat.label = "ignore";
-			this.cat.writeRssOutput(writer);
-			assertEquals(
-					"<category domain=\"www.apache.org\">Goo Data</category>",
-					strWriter.toString());
-		}
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.AbstractGOMElement.processAttribute(QName,
-	 * String)'
-	 */
-	public void testProcessAttribute() {
-		try {
-			this.cat.processAttribute(null, "test");
-			fail("qname is null");
-		} catch (GDataParseException e) {
-			// 
-		}
-		{
-			QName name = new QName("term");
-			this.cat.processAttribute(name, "helloworld");
-			assertEquals("helloworld", this.cat.getTerm());
-
-			try {
-				this.cat.processAttribute(name, "helloworld");
-				fail("duplicated attribute");
-			} catch (GDataParseException e) {
-				// 
-			}
-		}
-
-		{
-			QName name = new QName("scheme");
-			this.cat.processAttribute(name, "helloworld1");
-			assertEquals("helloworld1", this.cat.getScheme());
-
-			try {
-				this.cat.processAttribute(name, "helloworld1");
-				fail("duplicated attribute");
-			} catch (GDataParseException e) {
-				// 
-			}
-		}
-
-		{
-			QName name = new QName("label");
-			this.cat.processAttribute(name, "John Cleese");
-			assertEquals("John Cleese", this.cat.getLabel());
-
-			try {
-				this.cat.processAttribute(name, "John Cleese");
-				fail("duplicated attribute");
-			} catch (GDataParseException e) {
-				// 
-			}
-		}
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.AbstractGOMElement.processElementValue(String)'
-	 */
-	public void testProcessElementValue() {
-		try {
-			this.cat.processElementValue(null);
-			fail("element value is null");
-		} catch (GDataParseException e) {
-			// 
-		}
-
-		try {
-			this.cat.processElementValue("and again");
-			fail("can't contain a text value");
-		} catch (GDataParseException e) {
-			//
-			assertNull(this.cat.getTextValue());
-		}
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.AbstractGOMElement.processEndElement()'
-	 */
-	public void testProcessEndElement() {
-		try {
-			this.cat.processEndElement();
-			fail("term is not set");
-		} catch (GDataParseException e) {
-			// 
-		}
-		this.cat.setTerm("my Term");
-		this.cat.processEndElement();
-		this.cat.setScheme("test");
-
-		try {
-			this.cat.processEndElement();
-			fail("scheme is not a absoulte uri");
-		} catch (GDataParseException e) {
-			// 
-		}
-
-		this.cat.setScheme("/test");
-
-		try {
-			this.cat.processEndElement();
-			fail("scheme is not a absoulte uri and no xmlbase is set");
-		} catch (GDataParseException e) {
-			// 
-		}
-		{
-			this.cat.xmlBase = "http://www.apache.org";
-			this.cat.processEndElement();
-		}
-
-		{
-			this.cat.xmlBase = null;
-			this.cat.setScheme("http://www.apache.org/test");
-			this.cat.processEndElement();
-		}
-
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMContentImplTest.java b/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMContentImplTest.java
deleted file mode 100644
index e773f60..0000000
--- a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMContentImplTest.java
+++ /dev/null
@@ -1,275 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.gom.core;
-
-import java.io.StringWriter;
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.FactoryConfigurationError;
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.AtomMediaType;
-import org.apache.lucene.gdata.gom.ContentType;
-import org.apache.lucene.gdata.gom.GOMContent;
-import org.apache.lucene.gdata.gom.GOMNamespace;
-import org.apache.lucene.gdata.gom.core.GOMTextContructImpl.XMLBlobContentParser;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-import org.apache.lucene.gdata.gom.writer.GOMStaxWriter;
-
-import junit.framework.TestCase;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class GOMContentImplTest extends TestCase {
-
-	private GOMContentImpl impl;
-
-	protected void setUp() throws Exception {
-		super.setUp();
-		this.impl = new GOMContentImpl();
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMContentImpl.getChildParser(QName)'
-	 */
-	public void testGetChildParser() {
-		try {
-			this.impl.getChildParser(new QName("test"));
-			fail("no blob specified");
-		} catch (GDataParseException e) {
-			// 
-		}
-
-		this.impl.setAtomMediaType(AtomMediaType.XML);
-		AtomParser childParser = this.impl.getChildParser(new QName("test"));
-		assertNotNull(childParser);
-		assertTrue(childParser instanceof XMLBlobContentParser);
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMContentImpl.processAttribute(QName,
-	 * String)'
-	 */
-	public void testProcessAttribute() {
-		try {
-			this.impl.processAttribute(null, "test");
-			fail("qname is null");
-		} catch (GDataParseException e) {
-			// 
-		}
-		try {
-			this.impl.processAttribute(new QName("test"), null);
-			fail("value is null");
-		} catch (GDataParseException e) {
-			// 
-		}
-		this.impl.processAttribute(new QName(GOMNamespace.ATOM_NS_URI, "type"),
-				"text/xml");
-		assertSame(AtomMediaType.XML, this.impl.getAtomMediaType());
-		try {
-			this.impl.processAttribute(new QName(GOMNamespace.ATOM_NS_URI,
-					"type"), "text/xml");
-			fail("duplicated attribute");
-		} catch (GDataParseException e) {
-			// 
-		}
-		this.impl.setAtomMediaType(null);
-		this.impl.processAttribute(new QName(GOMNamespace.ATOM_NS_URI, "type"),
-				"text/plain");
-		assertSame(AtomMediaType.TEXT, this.impl.getAtomMediaType());
-
-		this.impl.setAtomMediaType(null);
-		this.impl.processAttribute(new QName(GOMNamespace.ATOM_NS_URI, "type"),
-				"image/jpeg");
-		assertSame(AtomMediaType.BINARY, this.impl.getAtomMediaType());
-
-		// test if super is called
-		this.impl.setAtomMediaType(null);
-		this.impl.processAttribute(new QName(GOMNamespace.ATOM_NS_URI, "type"),
-				"xhtml");
-		assertNull(this.impl.getAtomMediaType());
-		assertSame(ContentType.XHTML, this.impl.getContentType());
-
-		this.impl.processAttribute(new QName(GOMNamespace.ATOM_NS_URI, "src"),
-				"test");
-		assertEquals("test", this.impl.getSrc());
-		try {
-			this.impl.processAttribute(new QName(GOMNamespace.ATOM_NS_URI,
-					"src"), "text/xml");
-			fail("duplicated attribute");
-		} catch (GDataParseException e) {
-			// 
-		}
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMContentImpl.processElementValue(String)'
-	 */
-	public void testProcessElementValue() {
-		assertNull(this.impl.getTextValue());
-		this.impl.processElementValue("test");
-		assertEquals("test", this.impl.getTextValue());
-		this.impl.setSrc("http://www.apache.org");
-		try {
-			this.impl.processElementValue("test");
-			fail("src is set no element value allowed");
-		} catch (GDataParseException e) {
-			// 
-		}
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMContentImpl.processEndElement()'
-	 */
-	public void testProcessEndElement() {
-		try {
-			this.impl.processEndElement();
-			fail("no type attribute");
-		} catch (GDataParseException e) {
-			// 
-		}
-		this.impl.processAttribute(new QName(GOMNamespace.ATOM_NS_URI, "type"),
-				"text/plain");
-		this.impl.processEndElement();
-		this.impl.setSrc("http://www.apache.org");
-		this.impl.processEndElement();
-
-		this.impl.setSrc("/test");
-		try {
-			this.impl.processEndElement();
-			fail("must be absolut uri");
-		} catch (GDataParseException e) {
-			// 
-		}
-		this.impl.xmlBase = "http://www.apache.org";
-		this.impl.processEndElement();
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMContentImpl.writeAtomOutput(GOMOutputWriter)'
-	 */
-	public void testWriteAtomOutput() throws XMLStreamException,
-			FactoryConfigurationError {
-		{
-			StringWriter stW = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(stW);
-			this.impl.writeAtomOutput(writer);
-			assertEquals("<content type=\"text\"/>", stW.toString());
-		}
-
-		{
-			this.impl.processAttribute(new QName(GOMNamespace.ATOM_NS_URI,
-					"type"), "image/jpeg");
-			StringWriter stW = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(stW);
-			this.impl.writeAtomOutput(writer);
-			assertEquals("<content type=\"image/jpeg\"/>", stW.toString());
-		}
-
-		{
-			this.impl.setSrc("http://www.apache.org");
-			this.impl.setTextValue("hello world");
-			StringWriter stW = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(stW);
-			this.impl.writeAtomOutput(writer);
-			assertEquals(
-					"<content type=\"image/jpeg\" src=\"http://www.apache.org\"/>",
-					stW.toString());
-		}
-
-		{
-			this.impl.setSrc(null);
-			this.impl.setTextValue("hello world");
-			StringWriter stW = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(stW);
-			this.impl.writeAtomOutput(writer);
-			assertEquals("<content type=\"image/jpeg\">hello world</content>",
-					stW.toString());
-		}
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMContentImpl.writeRssOutput(GOMOutputWriter)'
-	 */
-	public void testWriteRssOutputGOMOutputWriter() throws XMLStreamException {
-		{
-			StringWriter stW = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(stW);
-			this.impl.writeRssOutput(writer);
-			assertEquals("<description/>", stW.toString());
-		}
-
-		{
-			this.impl.setSrc("http://www.apache.org");
-			this.impl.setAtomMediaType(AtomMediaType.TEXT);
-			StringWriter stW = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(stW);
-			this.impl.writeRssOutput(writer);
-			assertEquals("<link>http://www.apache.org</link>", stW.toString());
-		}
-
-		{
-			this.impl.setSrc(null);
-			this.impl.setAtomMediaType(AtomMediaType.TEXT);
-			this.impl.setTextValue("test");
-			StringWriter stW = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(stW);
-			this.impl.writeRssOutput(writer);
-			assertEquals("<description>test</description>", stW.toString());
-		}
-
-		{
-			this.impl.setAtomMediaType(null);
-
-			this.impl.processAttribute(new QName(GOMNamespace.ATOM_NS_URI,
-					"type"), "image/jpeg");
-			StringWriter stW = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(stW);
-			this.impl.writeRssOutput(writer);
-			assertEquals("<content type=\"image/jpeg\">test</content>", stW
-					.toString());
-		}
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMContentImpl.GOMContentImpl()'
-	 */
-	public void testGOMContentImpl() {
-		GOMContentImpl impl2 = new GOMContentImpl();
-		assertEquals(GOMContent.LOCALNAME, impl2.getLocalName());
-		assertEquals(GOMContent.LOCALNAME, impl2.getQname().getLocalPart());
-		assertEquals(GOMNamespace.ATOM_NS_URI, impl2.getQname()
-				.getNamespaceURI());
-
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMDateConstructImplTest.java b/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMDateConstructImplTest.java
deleted file mode 100644
index 75c5ff8..0000000
--- a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMDateConstructImplTest.java
+++ /dev/null
@@ -1,171 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import java.io.StringWriter;
-import java.util.Date;
-
-import javax.xml.stream.FactoryConfigurationError;
-import javax.xml.stream.XMLStreamException;
-
-import junit.framework.TestCase;
-
-import org.apache.lucene.gdata.gom.writer.GOMStaxWriter;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class GOMDateConstructImplTest extends TestCase {
-	private static final String DATE = "2003-12-13T18:30:02+02:00";
-
-	private static final String DATE_RSS = "Sat, 13 Dec 2003 16:30:02 +0000";
-
-	private static final String DATE1 = "2003-12-13T18:30:02.25Z";
-
-	private GOMUpdatedImpl updateImpl;
-
-	private GOMPublishedImpl publishImpl;
-
-	protected void setUp() throws Exception {
-		this.updateImpl = new GOMUpdatedImpl();
-		this.publishImpl = new GOMPublishedImpl();
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMDateConstructImpl.processElementValue(String)'
-	 */
-	public void testProcessElementValue() {
-		try {
-			this.updateImpl.processElementValue(null);
-			fail("must not be null");
-		} catch (IllegalArgumentException e) {
-			// 
-		}
-		try {
-			this.updateImpl.processElementValue("not a date");
-			fail("illegal string");
-		} catch (GDataParseException e) {
-			// 
-		}
-
-		this.updateImpl.processElementValue(DATE);
-		assertNotNull(this.updateImpl.getDate());
-		this.updateImpl.processElementValue(DATE1);
-		assertNotNull(this.updateImpl.getDate());
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMDateConstructImpl.processEndElement()'
-	 */
-	public void testProcessEndElement() {
-		try {
-			this.updateImpl.processEndElement();
-			fail("no element value");
-		} catch (GDataParseException e) {
-			// 
-		}
-		this.updateImpl.setDate(new Date());
-		this.updateImpl.processEndElement();
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMDateConstructImpl.writeAtomOutput(GOMWriter)'
-	 */
-	public void testWriteAtomOutput() throws XMLStreamException,
-			FactoryConfigurationError {
-		{
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			this.updateImpl.writeAtomOutput(writer);
-			assertTrue(strWriter.toString().startsWith("<updated>"));
-			assertTrue(strWriter.toString().endsWith("</updated>"));
-		}
-		{
-			this.updateImpl.processElementValue(DATE);
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			this.updateImpl.writeAtomOutput(writer);
-			assertEquals("<updated>" + DATE + "</updated>", strWriter
-					.toString());
-		}
-
-		{
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			this.publishImpl.writeAtomOutput(writer);
-			assertTrue(strWriter.toString().startsWith("<published>"));
-			assertTrue(strWriter.toString().endsWith("</published>"));
-		}
-		{
-			this.publishImpl.processElementValue(DATE);
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			this.publishImpl.writeAtomOutput(writer);
-			assertEquals("<published>" + DATE + "</published>", strWriter
-					.toString());
-		}
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMDateConstructImpl.writeRssOutput(GOMWriter)'
-	 */
-	public void testWriteRssOutput() throws XMLStreamException,
-			FactoryConfigurationError {
-		{
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			this.updateImpl.writeRssOutput(writer);
-			assertTrue(strWriter.toString().startsWith("<atom:updated>"));
-			assertTrue(strWriter.toString().endsWith("</atom:updated>"));
-		}
-		{
-			this.updateImpl.processElementValue(DATE);
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			this.updateImpl.writeRssOutput(writer);
-			assertEquals("<atom:updated>" + DATE + "</atom:updated>", strWriter
-					.toString());
-		}
-
-		{
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			this.publishImpl.writeRssOutput(writer);
-
-			assertTrue(strWriter.toString().startsWith("<pubDate>"));
-			assertTrue(strWriter.toString().endsWith("</pubDate>"));
-		}
-		{
-			this.publishImpl.processElementValue(DATE);
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			this.publishImpl.writeRssOutput(writer);
-			assertEquals("<pubDate>" + DATE_RSS + "</pubDate>", strWriter
-					.toString());
-		}
-
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMDocumentImplTest.java b/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMDocumentImplTest.java
deleted file mode 100644
index 29db97d..0000000
--- a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMDocumentImplTest.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.gom.core;
-
-import java.io.StringWriter;
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.FactoryConfigurationError;
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.writer.GOMStaxWriter;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-import junit.framework.TestCase;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class GOMDocumentImplTest extends TestCase {
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMDocumentImpl.writeAtomOutput(GOMWriter)'
-	 */
-	public void testWriteAtomOutput() throws XMLStreamException,
-			FactoryConfigurationError {
-		GOMDocumentImpl<ArbitraryGOMXml> impl = new GOMDocumentImpl<ArbitraryGOMXml>();
-		impl.setRootElement(new ArbitraryGOMXml(new QName("test")));
-		{
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			impl.writeAtomOutput(writer);
-			assertEquals("<?xml version='1.0' encoding='UTF-8'?><test/>",
-					strWriter.toString());
-		}
-		impl.setRootElement(null);
-		{
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			impl.writeAtomOutput(writer);
-			assertEquals("<?xml version='1.0' encoding='UTF-8'?>", strWriter
-					.toString());
-		}
-
-		impl.setVersion("2.0");
-		impl.setCharacterEncoding("ISO-8859-1");
-		{
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			impl.writeAtomOutput(writer);
-			assertEquals("<?xml version='2.0' encoding='ISO-8859-1'?>",
-					strWriter.toString());
-		}
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMDocumentImpl.writeRssOutput(GOMWriter)'
-	 */
-	public void testWriteRssOutput() throws XMLStreamException,
-			FactoryConfigurationError {
-		GOMDocumentImpl<ArbitraryGOMXml> impl = new GOMDocumentImpl<ArbitraryGOMXml>();
-		impl.setRootElement(new ArbitraryGOMXml(new QName("test")));
-		{
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			impl.writeRssOutput(writer);
-			assertEquals("<?xml version='1.0' encoding='UTF-8'?><test/>",
-					strWriter.toString());
-		}
-		impl.setRootElement(null);
-		{
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			impl.writeRssOutput(writer);
-			assertEquals("<?xml version='1.0' encoding='UTF-8'?>", strWriter
-					.toString());
-		}
-
-		impl.setVersion("2.0");
-		impl.setCharacterEncoding("ISO-8859-1");
-		{
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			impl.writeRssOutput(writer);
-			assertEquals("<?xml version='2.0' encoding='ISO-8859-1'?>",
-					strWriter.toString());
-		}
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMEntryImplTest.java b/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMEntryImplTest.java
deleted file mode 100644
index 4a4601d..0000000
--- a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMEntryImplTest.java
+++ /dev/null
@@ -1,526 +0,0 @@
-package org.apache.lucene.gdata.gom.core;
-
-import java.io.StringWriter;
-import java.util.List;
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.FactoryConfigurationError;
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.AtomMediaType;
-import org.apache.lucene.gdata.gom.GOMAuthor;
-import org.apache.lucene.gdata.gom.GOMCategory;
-import org.apache.lucene.gdata.gom.GOMContent;
-import org.apache.lucene.gdata.gom.GOMContributor;
-import org.apache.lucene.gdata.gom.GOMEntry;
-import org.apache.lucene.gdata.gom.GOMExtension;
-import org.apache.lucene.gdata.gom.GOMGenerator;
-import org.apache.lucene.gdata.gom.GOMIcon;
-import org.apache.lucene.gdata.gom.GOMId;
-import org.apache.lucene.gdata.gom.GOMLink;
-import org.apache.lucene.gdata.gom.GOMLogo;
-import org.apache.lucene.gdata.gom.GOMNamespace;
-import org.apache.lucene.gdata.gom.GOMPublished;
-import org.apache.lucene.gdata.gom.GOMRights;
-import org.apache.lucene.gdata.gom.GOMSource;
-import org.apache.lucene.gdata.gom.GOMSubtitle;
-import org.apache.lucene.gdata.gom.GOMSummary;
-import org.apache.lucene.gdata.gom.GOMTitle;
-import org.apache.lucene.gdata.gom.GOMUpdated;
-import org.apache.lucene.gdata.gom.core.GOMFeedImplTest.TestExtendsionFactory;
-import org.apache.lucene.gdata.gom.core.GOMFeedImplTest.TestExtension;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-import org.apache.lucene.gdata.gom.writer.GOMStaxWriter;
-
-import junit.framework.TestCase;
-
-public class GOMEntryImplTest extends TestCase {
-	private static final String TEST_LOCAL_NAME = GOMFeedImplTest.TEST_LOCAL_NAME;
-
-	private GOMEntryImpl impl;
-
-	protected void setUp() throws Exception {
-		super.setUp();
-		this.impl = new GOMEntryImpl();
-	}
-
-	public void testSetNamespace() {
-		assertEquals(0, this.impl.getNamespaces().size());
-		assertNotNull(this.impl.getDefaultNamespace());
-		this.impl.addNamespace(GOMNamespace.ATOM_NAMESPACE);
-		assertSame(GOMNamespace.ATOM_NAMESPACE, this.impl.getDefaultNamespace());
-		this.impl.addNamespace(GOMNamespace.OPENSEARCH_NAMESPACE);
-		assertEquals(1, this.impl.getNamespaces().size());
-		assertSame(GOMNamespace.OPENSEARCH_NAMESPACE, this.impl.getNamespaces()
-				.get(0));
-
-		// detect defaul ns
-		this.impl.addNamespace(new GOMNamespace(GOMNamespace.ATOM_NS_URI, ""));
-		assertEquals(1, this.impl.getNamespaces().size());
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMEntryImpl.getChildParser(QName)'
-	 */
-	public void testGetChildParser() {
-		{
-			// atomAuthor*
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "author"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMAuthor);
-			assertEquals(1, this.impl.getAuthors().size());
-			this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
-					"author"));
-			assertEquals(2, this.impl.getAuthors().size());
-		}
-
-		{
-			// atomCategory*
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "category"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMCategory);
-			assertEquals(1, this.impl.getCategories().size());
-			this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
-					"category"));
-			assertEquals(2, this.impl.getCategories().size());
-		}
-
-		{
-			// atomContributor*
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "contributor"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMContributor);
-			assertEquals(1, this.impl.getContributor().size());
-			this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
-					"contributor"));
-			assertEquals(2, this.impl.getContributor().size());
-		}
-
-		{
-			// atomId
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "id"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMId);
-			assertSame(parser, this.impl.getId());
-			try {
-				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
-						"id"));
-				fail("exactly one time ");
-			} catch (GDataParseException e) {
-				// 
-			}
-
-		}
-
-		{
-			// atomLink*
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "link"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMLink);
-			assertEquals(1, this.impl.getLinks().size());
-			this.impl
-					.getChildParser(new QName(GOMNamespace.ATOM_NS_URI, "link"));
-			assertEquals(2, this.impl.getLinks().size());
-
-		}
-
-		{
-			// atomRights?
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "rights"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMRights);
-			assertSame(parser, this.impl.getRights());
-			try {
-				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
-						"rights"));
-				fail("zero or one");
-			} catch (GDataParseException e) {
-				// 
-			}
-
-		}
-
-		{
-			// atomTitle
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "title"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMTitle);
-			assertSame(parser, this.impl.getTitle());
-			try {
-				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
-						"title"));
-				fail("exactly one time ");
-			} catch (GDataParseException e) {
-				// 
-			}
-
-		}
-
-		{
-			// atomUpdated
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "updated"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMUpdated);
-			assertSame(parser, this.impl.getUpdated());
-			try {
-				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
-						"updated"));
-				fail("exactly one time ");
-			} catch (GDataParseException e) {
-				// 
-			}
-
-		}
-
-		{
-			// atomSource?
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "source"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMSource);
-			assertEquals(parser, this.impl.getSource());
-			try {
-				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
-						"source"));
-				fail("duplicated element");
-			} catch (GDataParseException e) {
-				//
-			}
-
-		}
-
-		{
-			// atomSummary?
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "summary"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMSummary);
-			assertEquals(parser, this.impl.getSummary());
-			try {
-				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
-						"summary"));
-				fail("duplicated element");
-			} catch (GDataParseException e) {
-				//
-			}
-
-		}
-
-		{
-			// atomContent?
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "content"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMContent);
-			assertEquals(parser, this.impl.getContent());
-			try {
-				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
-						"content"));
-				fail("duplicated element");
-			} catch (GDataParseException e) {
-				//
-			}
-
-		}
-
-		{
-			// atomContent?
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "published"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMPublished);
-			assertEquals(parser, this.impl.getPublished());
-			try {
-				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
-						"published"));
-				fail("duplicated element");
-			} catch (GDataParseException e) {
-				//
-			}
-
-		}
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMEntryImpl.processEndElement()'
-	 */
-	public void testProcessEndElement() {
-		try {
-			this.impl.processEndElement();
-			fail("missing elements");
-		} catch (GDataParseException e) {
-			// 
-		}
-
-		// atom:entry elements MUST contain exactly one atom:id element.
-		this.impl.setId(new GOMIdImpl());
-		/*
-		 * atom:entry elements that contain no child atom:content element MUST
-		 * contain at least one atom:link element with a rel attribute value of
-		 * "alternate".
-		 */
-		GOMLink link = new GOMLinkImpl();
-		link.setRel("alternate");
-		this.impl.addLink(link);
-		/*
-		 * atom:entry elements MUST contain exactly one atom:title element.
-		 */
-		this.impl.setTitle(new GOMTitleImpl());
-		/*
-		 * atom:entry elements MUST contain exactly one atom:updated element.
-		 */
-		this.impl.setUpdated(new GOMUpdatedImpl());
-
-		{
-			this.impl.setId(null);
-			try {
-				this.impl.processEndElement();
-				fail("id is missing");
-			} catch (GDataParseException e) {
-				// 
-			}
-			this.impl.setId(new GOMIdImpl());
-		}
-
-		{
-			this.impl.getLinks().clear();
-			try {
-				this.impl.processEndElement();
-				fail("link alternate is missing");
-			} catch (GDataParseException e) {
-				// 
-			}
-			this.impl.setContent(new GOMContentImpl());
-			this.impl.processEndElement();
-			this.impl.setContent(null);
-			this.impl.addLink(link);
-		}
-
-		{
-			this.impl.setTitle(null);
-			try {
-				this.impl.processEndElement();
-				fail("title is missing");
-			} catch (GDataParseException e) {
-				// 
-			}
-			this.impl.setTitle(new GOMTitleImpl());
-		}
-		{
-			this.impl.setUpdated(null);
-			try {
-				this.impl.processEndElement();
-				fail("Updated is missing");
-			} catch (GDataParseException e) {
-				// 
-			}
-			this.impl.setUpdated(new GOMUpdatedImpl());
-		}
-
-		/*
-		 * atom:entry elements MUST NOT contain more than one atom:link element
-		 * with a rel attribute value of "alternate" that has the same
-		 * combination of type and hreflang attribute values.
-		 */
-		link.setType("test");
-		link.setHrefLang("http://www.apache.org");
-		this.impl.addLink(link);
-		try {
-			this.impl.processEndElement();
-			fail("doulbe alternate link with same type and hreflang");
-
-		} catch (GDataParseException e) {
-			// 
-		}
-		this.impl.getLinks().remove(0);
-		/*
-		 * # atom:entry elements MUST contain an atom:summary element in either
-		 * of the following cases:
-		 * 
-		 * the atom:entry contains an atom:content that has a "src" attribute
-		 * (and is thus empty). the atom:entry contains content that is encoded
-		 * in Base64; i.e., the "type" attribute of atom:content is a MIME media
-		 * type [MIMEREG], but is not an XML media type [RFC3023], does not
-		 * begin with "text/", and does not end with "/xml" or "+xml".
-		 * 
-		 * 
-		 */
-		GOMContent c = new GOMContentImpl();
-		c.setSrc("");
-		this.impl.setContent(c);
-		try {
-			this.impl.processEndElement();
-			fail("no summary");
-		} catch (GDataParseException e) {
-			// 
-		}
-		c.setSrc(null);
-		c.setAtomMediaType(AtomMediaType.BINARY);
-		try {
-			this.impl.processEndElement();
-			fail("no summary");
-		} catch (GDataParseException e) {
-			// 
-		}
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMEntryImpl.GOMEntryImpl()'
-	 */
-	public void testGOMEntryImpl() {
-		GOMEntryImpl impl2 = new GOMEntryImpl();
-		assertNotNull(impl2.getQname());
-		assertEquals(GOMEntry.LOCALNAME, impl.getQname().getLocalPart());
-		assertEquals(GOMEntry.LOCALNAME, this.impl.getLocalName());
-		assertEquals(GOMNamespace.ATOM_NS_URI, impl.getQname()
-				.getNamespaceURI());
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMEntryImpl.writeAtomOutput(GOMOutputWriter)'
-	 */
-	public void testWriteAtomOutput() throws XMLStreamException,
-			FactoryConfigurationError {
-		// write a whole feed and check if all elements are written
-		this.impl.addAuthor(new GOMAuthorImpl());
-		this.impl.addCategory(new GOMCategoryImpl());
-		this.impl.addContributor(new GOMContributorImpl());
-		this.impl.addLink(new GOMLinkImpl());
-		this.impl.setContent(new GOMContentImpl());
-		this.impl.setId(new GOMIdImpl());
-		this.impl.setRights(new GOMRightsImpl());
-		this.impl.setSummary(new GOMSummaryImpl());
-		this.impl.setTitle(new GOMTitleImpl());
-		this.impl.setUpdated(new GOMUpdatedImpl());
-		this.impl.setSource(new GOMSourceImpl());
-		this.impl.setPublished(new GOMPublishedImpl());
-		this.impl.extensions.add(new GOMFeedImplTest.TestExtension());
-		StringWriter stW = new StringWriter();
-		GOMOutputWriter writer = new GOMStaxWriter(stW);
-		this.impl.writeAtomOutput(writer);
-		String string = stW.toString();
-		assertTrue(string.contains("xmlns=\"http://www.w3.org/2005/Atom\""));
-		assertTrue(string.startsWith("<" + GOMEntry.LOCALNAME));
-		assertTrue(string.contains("<" + GOMAuthor.LOCALNAME));
-		assertTrue(string.contains("<" + GOMCategory.LOCALNAME));
-		assertTrue(string.contains("<" + GOMContributor.LOCALNAME));
-		assertTrue(string.contains("<" + GOMLink.LOCALNAME));
-		assertTrue(string.contains("<" + GOMId.LOCALNAME));
-		assertTrue(string.contains("<" + GOMRights.LOCALNAME));
-		assertTrue(string.contains("<" + GOMSummary.LOCALNAME));
-		assertTrue(string.contains("<" + GOMContent.LOCALNAME));
-		assertTrue(string.contains("<" + GOMTitle.LOCALNAME));
-		assertTrue(string.contains("<" + GOMUpdated.LOCALNAME));
-		assertTrue(string.contains("<" + GOMSource.LOCALNAME));
-		assertTrue(string.contains("<" + GOMPublished.LOCALNAME));
-		assertTrue(string.contains("<test"));
-		assertTrue(string.endsWith("</entry>"));
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMEntryImpl.writeRssOutput(GOMOutputWriter)'
-	 */
-	public void testWriteRssOutputGOMOutputWriter() throws XMLStreamException,
-			FactoryConfigurationError {
-		// write a whole feed and check if all elements are written
-		this.impl.addAuthor(new GOMAuthorImpl());
-		this.impl.addCategory(new GOMCategoryImpl());
-		this.impl.addContributor(new GOMContributorImpl());
-		GOMLink link = new GOMLinkImpl();
-		link.setRel("enclosure");
-		link.setHref("test");
-		link.setType("testType");
-		this.impl.addLink(link);
-		this.impl.setContent(new GOMContentImpl());
-		this.impl.setId(new GOMIdImpl());
-		this.impl.setRights(new GOMRightsImpl());
-		GOMSummaryImpl summ = new GOMSummaryImpl();
-		summ.xmlLang = "de";
-		this.impl.setSummary(summ);
-		this.impl.setTitle(new GOMTitleImpl());
-		this.impl.setUpdated(new GOMUpdatedImpl());
-		this.impl.setSource(new GOMSourceImpl());
-		this.impl.setPublished(new GOMPublishedImpl());
-		this.impl.extensions.add(new GOMFeedImplTest.TestExtension());
-		StringWriter stW = new StringWriter();
-		GOMOutputWriter writer = new GOMStaxWriter(stW);
-		this.impl.writeRssOutput(writer);
-		String string = stW.toString();
-		assertTrue(string
-				.contains("xmlns:atom=\"http://www.w3.org/2005/Atom\""));
-		assertTrue(string.startsWith("<" + GOMEntry.LOCALNAME_RSS));
-		assertTrue(string.contains("<" + GOMId.LOCALNAME_RSS));
-		assertTrue(string.contains("<pubDate"));
-		assertTrue(string.contains("<atom:" + GOMUpdated.LOCALNAME));
-		assertTrue(string.contains("<" + GOMId.LOCALNAME_RSS));
-		assertTrue(string.contains("<language"));
-		assertTrue(string.contains("<category domain=\""));
-		assertTrue(string.contains("<title"));
-		assertTrue(string.contains("<atom:summary"));
-		assertTrue(string.contains("<description"));
-		// a link element
-		assertTrue(string.contains("<enclosure"));
-		assertTrue(string.contains("<author"));
-		assertTrue(string.contains("<atom:test"));
-		assertTrue(string.endsWith("</item>"));
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMEntryImpl.getExtensions()'
-	 */
-	public void testGetExtensions() {
-
-		{
-			List<GOMExtension> extensions = this.impl.getExtensions();
-			assertNotNull(extensions);
-			assertEquals(0, extensions.size());
-		}
-		QName name = new QName(TEST_LOCAL_NAME);
-		this.impl.setExtensionFactory(new TestExtendsionFactory());
-
-		AtomParser childParser = this.impl.getChildParser(name);
-		assertTrue(childParser instanceof TestExtension);
-		List<GOMExtension> extensions = this.impl.getExtensions();
-		assertNotNull(extensions);
-		assertEquals(1, extensions.size());
-		assertSame(childParser, extensions.get(0));
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMEntryImpl.setExtensionFactory(GOMExtensionFactory)'
-	 */
-	public void testSetExtensionFactory() {
-		QName name = new QName(TEST_LOCAL_NAME);
-		try {
-			this.impl.getChildParser(name);
-			fail("no child hander for this qname");
-		} catch (GDataParseException e) {
-			// 
-		}
-
-		this.impl.setExtensionFactory(new TestExtendsionFactory());
-
-		AtomParser childParser = this.impl.getChildParser(name);
-		assertTrue(childParser instanceof TestExtension);
-
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMFeedImplTest.java b/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMFeedImplTest.java
deleted file mode 100644
index a09d0cb..0000000
--- a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMFeedImplTest.java
+++ /dev/null
@@ -1,688 +0,0 @@
-package org.apache.lucene.gdata.gom.core;
-
-import java.io.StringWriter;
-import java.util.LinkedList;
-import java.util.List;
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.FactoryConfigurationError;
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.GOMAuthor;
-import org.apache.lucene.gdata.gom.GOMCategory;
-import org.apache.lucene.gdata.gom.GOMContributor;
-import org.apache.lucene.gdata.gom.GOMElement;
-import org.apache.lucene.gdata.gom.GOMEntry;
-import org.apache.lucene.gdata.gom.GOMExtension;
-import org.apache.lucene.gdata.gom.GOMFeed;
-import org.apache.lucene.gdata.gom.GOMGenerator;
-import org.apache.lucene.gdata.gom.GOMIcon;
-import org.apache.lucene.gdata.gom.GOMId;
-import org.apache.lucene.gdata.gom.GOMLink;
-import org.apache.lucene.gdata.gom.GOMLogo;
-import org.apache.lucene.gdata.gom.GOMNamespace;
-import org.apache.lucene.gdata.gom.GOMRights;
-import org.apache.lucene.gdata.gom.GOMSubtitle;
-import org.apache.lucene.gdata.gom.GOMTitle;
-import org.apache.lucene.gdata.gom.GOMUpdated;
-import org.apache.lucene.gdata.gom.core.extension.GOMExtensionFactory;
-import org.apache.lucene.gdata.gom.writer.GOMStaxWriter;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-import junit.framework.TestCase;
-
-public class GOMFeedImplTest extends TestCase {
-	static final String TEST_LOCAL_NAME = "testelement";
-
-	GOMFeedImpl impl;
-
-	protected void setUp() throws Exception {
-		this.impl = new GOMFeedImpl();
-	}
-
-	public void testSetNamespace() {
-		assertEquals(0, this.impl.getNamespaces().size());
-		assertNotNull(this.impl.getDefaultNamespace());
-		this.impl.addNamespace(GOMNamespace.ATOM_NAMESPACE);
-		assertSame(GOMNamespace.ATOM_NAMESPACE, this.impl.getDefaultNamespace());
-		this.impl.addNamespace(GOMNamespace.OPENSEARCH_NAMESPACE);
-		assertEquals(1, this.impl.getNamespaces().size());
-		assertSame(GOMNamespace.OPENSEARCH_NAMESPACE, this.impl.getNamespaces()
-				.get(0));
-
-		// detect defaul ns
-		this.impl.addNamespace(new GOMNamespace(GOMNamespace.ATOM_NS_URI, ""));
-		assertEquals(1, this.impl.getNamespaces().size());
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.getChildParser(QName)'
-	 */
-	public void testGetChildParser() {
-
-		{
-			// atomAuthor*
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "author"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMAuthor);
-			assertEquals(1, this.impl.getAuthors().size());
-			this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
-					"author"));
-			assertEquals(2, this.impl.getAuthors().size());
-		}
-
-		{
-			// atomCategory*
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "category"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMCategory);
-			assertEquals(1, this.impl.getCategories().size());
-			this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
-					"category"));
-			assertEquals(2, this.impl.getCategories().size());
-		}
-
-		{
-			// atomContributor*
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "contributor"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMContributor);
-			assertEquals(1, this.impl.getContributor().size());
-			this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
-					"contributor"));
-			assertEquals(2, this.impl.getContributor().size());
-		}
-		{
-			// atomGenerator?
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "generator"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMGenerator);
-			assertSame(parser, this.impl.getGenerator());
-			try {
-				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
-						"generator"));
-				fail("one or zero");
-			} catch (GDataParseException e) {
-				// 
-			}
-		}
-
-		{
-			// atomIcon?
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "icon"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMIcon);
-			assertSame(parser, this.impl.getIcon());
-			try {
-				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
-						"icon"));
-				fail("one or zero");
-			} catch (GDataParseException e) {
-				// 
-			}
-
-		}
-
-		{
-			// atomId
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "id"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMId);
-			assertSame(parser, this.impl.getId());
-			try {
-				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
-						"id"));
-				fail("exactly one time ");
-			} catch (GDataParseException e) {
-				// 
-			}
-
-		}
-
-		{
-			// atomLink*
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "link"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMLink);
-			assertEquals(1, this.impl.getLinks().size());
-			this.impl
-					.getChildParser(new QName(GOMNamespace.ATOM_NS_URI, "link"));
-			assertEquals(2, this.impl.getLinks().size());
-
-		}
-
-		{
-			// atomLogo?
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "logo"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMLogo);
-			assertSame(parser, this.impl.getLogo());
-			try {
-				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
-						"logo"));
-				fail("zero or one");
-			} catch (GDataParseException e) {
-				// 
-			}
-
-		}
-
-		{
-			// atomRights?
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "rights"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMRights);
-			assertSame(parser, this.impl.getRights());
-			try {
-				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
-						"rights"));
-				fail("zero or one");
-			} catch (GDataParseException e) {
-				// 
-			}
-
-		}
-
-		{
-			// atomSubtitle?
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "subtitle"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMSubtitle);
-			assertSame(parser, this.impl.getSubtitle());
-			try {
-				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
-						"subtitle"));
-				fail("zero or one");
-			} catch (GDataParseException e) {
-				// 
-			}
-
-		}
-
-		{
-			// atomTitle
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "title"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMTitle);
-			assertSame(parser, this.impl.getTitle());
-			try {
-				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
-						"title"));
-				fail("exactly one time ");
-			} catch (GDataParseException e) {
-				// 
-			}
-
-		}
-
-		{
-			// atomUpdated
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "updated"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMUpdated);
-			assertSame(parser, this.impl.getUpdated());
-			try {
-				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
-						"updated"));
-				fail("exactly one time ");
-			} catch (GDataParseException e) {
-				// 
-			}
-
-		}
-
-		{
-			// atomEntry*
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "entry"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMEntry);
-			assertEquals(1, this.impl.getEntries().size());
-			this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
-					"entry"));
-			assertEquals(2, this.impl.getEntries().size());
-
-		}
-
-		// openSearch
-		{
-			// startIndex
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.OPENSEARCH_NS_URI, "startIndex"));
-			assertNotNull(parser);
-
-		}
-		{
-			// startIndex
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.OPENSEARCH_NS_URI, "itemsPerPage"));
-			assertNotNull(parser);
-
-		}
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.processElementValue(String)'
-	 */
-	public void testProcessElementValue() {
-		try {
-			this.impl.processElementValue("some");
-			fail("no element text");
-		} catch (GDataParseException e) {
-			//
-		}
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.processEndElement()'
-	 * 
-	 * atomFeed = element atom:feed { atomCommonAttributes, (atomAuthor* &
-	 * atomCategory* & atomContributor* & atomGenerator? & atomIcon? & atomId &
-	 * atomLink* & atomLogo? & atomRights? & atomSubtitle? & atomTitle &
-	 * atomUpdated & extensionElement*), atomEntry* }
-	 */
-	public void testProcessEndElement() {
-		this.impl.addAuthor(new GOMAuthorImpl());
-		this.impl.setId(new GOMIdImpl());
-		this.impl.setUpdated(new GOMUpdatedImpl());
-		this.impl.setTitle(new GOMTitleImpl());
-
-		this.impl.processEndElement();
-		{
-			// author missing
-			this.impl.getAuthors().clear();
-			try {
-				this.impl.processEndElement();
-				fail("missing elements");
-			} catch (GDataParseException e) {
-				// 
-			}
-			this.impl.addAuthor(new GOMAuthorImpl());
-		}
-
-		{
-			// id missing
-			this.impl.setId(null);
-			try {
-				this.impl.processEndElement();
-				fail("missing elements");
-			} catch (GDataParseException e) {
-				// 
-			}
-			this.impl.setId(new GOMIdImpl());
-		}
-
-		{
-			// title missing
-			this.impl.setTitle(null);
-			try {
-				this.impl.processEndElement();
-				fail("missing elements");
-			} catch (GDataParseException e) {
-				// 
-			}
-			this.impl.setTitle(new GOMTitleImpl());
-		}
-		{
-			// updated missing
-			this.impl.setUpdated(null);
-			try {
-				this.impl.processEndElement();
-				fail("missing elements");
-			} catch (GDataParseException e) {
-				// 
-			}
-			this.impl.setUpdated(new GOMUpdatedImpl());
-		}
-
-		/*
-		 * atom:feed elements MUST NOT contain more than one atom:link element
-		 * with a rel attribute value of "alternate" that has the same
-		 * combination of type and hreflang attribute values.
-		 */
-
-		{
-			// two identical alternate links missing
-			GOMLink link = new GOMLinkImpl();
-			link.setRel("alternate");
-			link.setHrefLang("http://www.apache.org");
-			link.setType("text/html");
-			this.impl.addLink(link);
-			// one is allowed
-			this.impl.processEndElement();
-			// add a second link
-			link = new GOMLinkImpl();
-			this.impl.addLink(link);
-			link.setRel("next");
-			link.setHrefLang("http://www.apache.org");
-			link.setType("text/html");
-			// one is alternate the other is next
-			this.impl.processEndElement();
-
-			// a second "identical" alternate link
-			link = new GOMLinkImpl();
-			this.impl.addLink(link);
-			link.setRel("alternate");
-			link.setHrefLang("http://www.apache.org");
-			link.setType("text/html");
-			try {
-				this.impl.processEndElement();
-				fail("missing elements");
-			} catch (GDataParseException e) {
-				// 
-			}
-			this.impl.setUpdated(new GOMUpdatedImpl());
-		}
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.GOMFeedImpl()'
-	 */
-	public void testGOMFeedImpl() {
-		GOMFeedImpl impl2 = new GOMFeedImpl();
-		assertEquals(GOMFeed.LOCALNAME, impl2.getLocalName());
-		assertEquals(GOMFeed.LOCALNAME, impl2.getQname().getLocalPart());
-		assertEquals(GOMNamespace.ATOM_NS_URI, impl2.getQname()
-				.getNamespaceURI());
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.getStartIndex()' and
-	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.setStartIndex(int)'
-	 */
-	public void testGetSetStartIndex() {
-		assertEquals(GOMFeedImpl.DEFAULT_START_INDEX, this.impl.getStartIndex());
-		this.impl.setStartIndex(5);
-		assertEquals(5, this.impl.getStartIndex());
-		this.impl.setStartIndex(-5);
-		assertEquals(5, this.impl.getStartIndex());
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.setItemsPerPage(int)' and
-	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.getNamespaces()'
-	 */
-	public void testGetSetItemsPerPage() {
-		assertEquals(GOMFeedImpl.DEFAULT_ITEMS_PER_PAGE, this.impl
-				.getItemsPerPage());
-		this.impl.setItemsPerPage(5);
-		assertEquals(5, this.impl.getItemsPerPage());
-		this.impl.setItemsPerPage(-5);
-		assertEquals(5, this.impl.getItemsPerPage());
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.writeAtomOutput(GOMWriter)'
-	 */
-	public void testWriteAtomOutput() throws XMLStreamException,
-			FactoryConfigurationError {
-		// write a whole feed and check if all elements are written
-		this.impl.addAuthor(new GOMAuthorImpl());
-		this.impl.addCategory(new GOMCategoryImpl());
-		this.impl.addContributor(new GOMContributorImpl());
-		this.impl.addLink(new GOMLinkImpl());
-		this.impl.addNamespace(GOMNamespace.OPENSEARCH_NAMESPACE);
-		this.impl.setGenerator(new GOMGeneratorImpl());
-		this.impl.setIcon(new GOMIconImpl());
-		this.impl.setId(new GOMIdImpl());
-		this.impl.setLogo(new GOMLogoImpl());
-		this.impl.setRights(new GOMRightsImpl());
-		this.impl.setSubtitle(new GOMSubtitleImpl());
-		this.impl.setTitle(new GOMTitleImpl());
-		this.impl.setUpdated(new GOMUpdatedImpl());
-		this.impl.extensions.add(new TestExtension());
-		this.impl.addNamespace(GOMNamespace.OPENSEARCH_NAMESPACE);
-		StringWriter stW = new StringWriter();
-		GOMOutputWriter writer = new GOMStaxWriter(stW);
-		this.impl.writeAtomOutput(writer);
-		String string = stW.toString();
-		assertTrue(string.contains("xmlns:openSearch"));
-		assertTrue(string.contains("xmlns=\"http://www.w3.org/2005/Atom\""));
-		assertTrue(string.contains("<" + GOMAuthor.LOCALNAME));
-		assertTrue(string.contains("<" + GOMCategory.LOCALNAME));
-		assertTrue(string.contains("<" + GOMContributor.LOCALNAME));
-		assertTrue(string.contains("<" + GOMLink.LOCALNAME));
-		assertTrue(string.contains("<" + GOMGenerator.LOCALNAME));
-		assertTrue(string.contains("<" + GOMIcon.LOCALNAME));
-		assertTrue(string.contains("<" + GOMId.LOCALNAME));
-		assertTrue(string.contains("<" + GOMLogo.LOCALNAME));
-		assertTrue(string.contains("<" + GOMRights.LOCALNAME));
-		assertTrue(string.contains("<" + GOMSubtitle.LOCALNAME));
-		assertTrue(string.contains("<" + GOMTitle.LOCALNAME));
-		assertTrue(string.contains("<" + GOMUpdated.LOCALNAME));
-		assertTrue(string.contains("<openSearch:itemsPerPage>"));
-		assertTrue(string.contains("<openSearch:startIndex>"));
-		assertTrue(string.contains("<test"));
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.writeRssOutput(GOMWriter)'
-	 */
-	public void testWriteRssOutput() throws XMLStreamException,
-			FactoryConfigurationError {
-		// write a whole feed and check if all elements are written
-		this.impl.addAuthor(new GOMAuthorImpl());
-		this.impl.addCategory(new GOMCategoryImpl());
-		this.impl.addContributor(new GOMContributorImpl());
-		GOMLinkImpl impl2 = new GOMLinkImpl();
-		impl2.setHref("test");
-		impl2.setRel("alternate");
-		this.impl.addLink(impl2);
-		this.impl.addNamespace(GOMNamespace.OPENSEARCH_NAMESPACE);
-		this.impl.setGenerator(new GOMGeneratorImpl());
-		this.impl.setIcon(new GOMIconImpl());
-		this.impl.setId(new GOMIdImpl());
-		this.impl.setLogo(new GOMLogoImpl());
-		this.impl.setRights(new GOMRightsImpl());
-		this.impl.setSubtitle(new GOMSubtitleImpl());
-		this.impl.setTitle(new GOMTitleImpl());
-		this.impl.setUpdated(new GOMUpdatedImpl());
-		this.impl.addNamespace(GOMNamespace.ATOM_NAMESPACE);
-		this.impl.addNamespace(GOMNamespace.OPENSEARCH_NAMESPACE);
-		this.impl.extensions.add(new TestExtension());
-		StringWriter stW = new StringWriter();
-		GOMOutputWriter writer = new GOMStaxWriter(stW);
-		this.impl.writeRssOutput(writer);
-
-		String string = stW.toString();
-		assertTrue(string.contains("xmlns:openSearch"));
-		assertTrue(string.contains("xmlns:atom"));
-		// TODO
-		// assertTrue(string.contains("<language"));
-		assertTrue(string.contains("<" + GOMCategory.LOCALNAME));
-		// author
-		assertTrue(string.contains("<managingEditor"));
-		assertTrue(string.contains("<" + GOMLink.LOCALNAME));
-		assertTrue(string.contains("<" + GOMGenerator.LOCALNAME));
-		assertTrue(string.contains("<image><url"));
-		assertTrue(string.contains("<atom:" + GOMId.LOCALNAME));
-
-		assertTrue(string.contains("<copyright"));
-		assertTrue(string.contains("<" + GOMTitle.LOCALNAME));
-		assertTrue(string.contains("<lastBuildDate"));
-		assertTrue(string.contains("<openSearch:itemsPerPage>"));
-		assertTrue(string.contains("<openSearch:startIndex>"));
-		assertTrue(string.contains("<atom:test"));
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.getExtensions()'
-	 */
-	public void testGetExtensions() {
-
-		{
-			List<GOMExtension> extensions = this.impl.getExtensions();
-			assertNotNull(extensions);
-			assertEquals(0, extensions.size());
-		}
-		QName name = new QName(TEST_LOCAL_NAME);
-		this.impl.setExtensionFactory(new TestExtendsionFactory());
-
-		AtomParser childParser = this.impl.getChildParser(name);
-		assertTrue(childParser instanceof TestExtension);
-		List<GOMExtension> extensions = this.impl.getExtensions();
-		assertNotNull(extensions);
-		assertEquals(1, extensions.size());
-		assertSame(childParser, extensions.get(0));
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.setExtensionFactory(GOMExtensionFactory)'
-	 */
-	public void testSetExtensionFactory() {
-		QName name = new QName(TEST_LOCAL_NAME);
-		try {
-			this.impl.getChildParser(name);
-			fail("no child hander for this qname");
-		} catch (GDataParseException e) {
-			// 
-		}
-
-		this.impl.setExtensionFactory(new TestExtendsionFactory());
-
-		AtomParser childParser = this.impl.getChildParser(name);
-		assertTrue(childParser instanceof TestExtension);
-
-	}
-
-	static class TestExtendsionFactory implements GOMExtensionFactory {
-
-		public GOMExtension canHandleExtensionElement(QName aName) {
-			if (aName.getLocalPart().equals(TEST_LOCAL_NAME))
-				return new TestExtension();
-			return null;
-		}
-
-		public List<GOMNamespace> getNamespaces() {
-			LinkedList<GOMNamespace> name = new LinkedList<GOMNamespace>();
-			name.add(GOMNamespace.ATOM_NAMESPACE);
-			return name;
-		}
-
-	}
-
-	static class TestExtension implements GOMExtension {
-
-		public QName getQname() {
-			// TODO Auto-generated method stub
-			return null;
-		}
-
-		public void setNamespaceUri(String aString) {
-			// TODO Auto-generated method stub
-
-		}
-
-		public void setNamespacePrefix(String aString) {
-			// TODO Auto-generated method stub
-
-		}
-
-		public void setLocalName(String aLocalName) {
-			// TODO Auto-generated method stub
-
-		}
-
-		public String getLocalName() {
-			// TODO Auto-generated method stub
-			return null;
-		}
-
-		public String getTextValue() {
-			// TODO Auto-generated method stub
-			return null;
-		}
-
-		public void setTextValue(String aTextValue) {
-			// TODO Auto-generated method stub
-
-		}
-
-		public void addChild(GOMElement aElement) {
-			// TODO Auto-generated method stub
-
-		}
-
-		public GOMElement getParent() {
-			// TODO Auto-generated method stub
-			return null;
-		}
-
-		public void writeAtomOutput(GOMOutputWriter aStreamWriter)
-				throws XMLStreamException {
-			aStreamWriter.writeSimpleXMLElement("test", null, "helloworld");
-
-		}
-
-		public void writeRssOutput(GOMOutputWriter aStreamWriter)
-				throws XMLStreamException {
-			aStreamWriter.writeSimpleXMLElement(new QName(
-					GOMNamespace.ATOM_NS_URI, "test",
-					GOMNamespace.ATOM_NS_PREFIX), null, "helloworld");
-
-		}
-
-		public void processElementValue(String aValue) {
-			// TODO Auto-generated method stub
-
-		}
-
-		public void processAttribute(QName aQName, String aValue) {
-			// TODO Auto-generated method stub
-
-		}
-
-		public void processEndElement() {
-			// TODO Auto-generated method stub
-
-		}
-
-		public AtomParser getChildParser(QName aName) {
-			// TODO Auto-generated method stub
-			return null;
-		}
-
-		public void writeRssOutput(GOMOutputWriter aStreamWriter,
-				String aRssName) throws XMLStreamException {
-
-		}
-
-		public String getXmlBase() {
-			// TODO Auto-generated method stub
-			return null;
-		}
-
-		public String getXmlLang() {
-			// TODO Auto-generated method stub
-			return null;
-		}
-
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMGenereatorImplTest.java b/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMGenereatorImplTest.java
deleted file mode 100644
index 98c365b..0000000
--- a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMGenereatorImplTest.java
+++ /dev/null
@@ -1,204 +0,0 @@
-package org.apache.lucene.gdata.gom.core;
-
-import java.io.StringWriter;
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.FactoryConfigurationError;
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.GOMGenerator;
-import org.apache.lucene.gdata.gom.GOMNamespace;
-import org.apache.lucene.gdata.gom.writer.GOMStaxWriter;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-import junit.framework.TestCase;
-
-public class GOMGenereatorImplTest extends TestCase {
-	private GOMGeneratorImpl impl;
-
-	protected void setUp() throws Exception {
-		this.impl = new GOMGeneratorImpl();
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMGeneratorImpl.processAttribute(QName,
-	 * String)'
-	 */
-	public void testProcessAttribute() {
-		this.impl.processAttribute(new QName(GOMNamespace.ATOM_NS_URI, "uri"),
-				"test");
-		assertEquals("test", this.impl.getUri());
-		try {
-			this.impl.processAttribute(new QName(GOMNamespace.ATOM_NS_URI,
-					"uri"), "test");
-			fail("duplicated");
-		} catch (GDataParseException e) {
-
-		}
-		this.impl.processAttribute(new QName(GOMNamespace.ATOM_NS_URI,
-				"version"), "test");
-		assertEquals("test", this.impl.getGeneratorVersion());
-
-		try {
-			this.impl.processAttribute(new QName(GOMNamespace.ATOM_NS_URI,
-					"version"), "test");
-			fail("duplicated");
-		} catch (GDataParseException e) {
-
-		}
-
-		// check call to super.processAttribute
-		this.impl.processAttribute(new QName(GOMNamespace.XML_NS_URI, "base",
-				GOMNamespace.XML_NS_PREFIX), "test");
-		assertEquals("test", this.impl.xmlBase);
-
-		try {
-			this.impl.processAttribute(null, "test");
-			fail("qname is null");
-		} catch (IllegalArgumentException e) {
-			// 
-		}
-		try {
-			this.impl.processAttribute(new QName(GOMNamespace.XML_NS_URI,
-					"base", GOMNamespace.XML_NS_PREFIX), null);
-			fail("value is null");
-		} catch (IllegalArgumentException e) {
-			// 
-		}
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMGeneratorImpl.processElementValue(String)'
-	 */
-	public void testProcessElementValue() {
-		this.impl.processElementValue("myGenerator");
-		assertEquals("myGenerator", this.impl.getTextValue());
-
-		try {
-			this.impl.processElementValue("testme");
-			fail("duplicated");
-
-		} catch (GDataParseException e) {
-			//
-		}
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMGeneratorImpl.processEndElement()'
-	 */
-	public void testProcessEndElement() {
-		this.impl.processEndElement();
-		{
-			this.impl.setUri("some invalid uri");
-			try {
-				this.impl.processEndElement();
-				fail("must be an absolute uri");
-			} catch (GDataParseException e) {
-				// 
-			}
-
-		}
-		{
-			this.impl.setUri("/uri");
-			try {
-				this.impl.processEndElement();
-				fail("must be an absolute uri or xml:base must be set");
-			} catch (GDataParseException e) {
-				// 
-			}
-
-		}
-		this.impl.xmlBase = "http://apache.org";
-		this.impl.processEndElement();
-
-		this.impl.xmlBase = null;
-		this.impl.setUri("http://apache.org/uri");
-		this.impl.processEndElement();
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMGeneratorImpl.GOMGeneratorImpl()'
-	 */
-	public void testGOMGeneratorImpl() {
-		this.impl = new GOMGeneratorImpl();
-		assertEquals(GOMGenerator.LOCALNAME, this.impl.getLocalName());
-		assertEquals(GOMGenerator.LOCALNAME, this.impl.getQname()
-				.getLocalPart());
-		assertEquals(GOMNamespace.ATOM_NS_URI, this.impl.getQname()
-				.getNamespaceURI());
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMGeneratorImpl.writeAtomOutput(GOMWriter)'
-	 */
-	public void testWriteAtomOutput() throws XMLStreamException {
-		{
-			StringWriter stW = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(stW);
-			this.impl.writeAtomOutput(writer);
-			assertEquals("<" + this.impl.getLocalName() + "/>", stW.toString());
-		}
-
-		{
-			StringWriter stW = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(stW);
-			this.impl.setTextValue("Lucene");
-			this.impl.writeAtomOutput(writer);
-			assertEquals("<" + this.impl.getLocalName() + ">Lucene</"
-					+ this.impl.getLocalName() + ">", stW.toString());
-		}
-		{
-			StringWriter stW = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(stW);
-			this.impl.setUri("http://apache.org");
-			this.impl.writeAtomOutput(writer);
-			assertEquals("<" + this.impl.getLocalName()
-					+ " uri=\"http://apache.org\">Lucene</"
-					+ this.impl.getLocalName() + ">", stW.toString());
-		}
-
-		{
-			StringWriter stW = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(stW);
-			this.impl.setGeneratorVersion("1");
-			this.impl.writeAtomOutput(writer);
-			assertEquals("<" + this.impl.getLocalName()
-					+ " uri=\"http://apache.org\" version=\"1\">Lucene</"
-					+ this.impl.getLocalName() + ">", stW.toString());
-		}
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMGeneratorImpl.writeRssOutput(GOMWriter)'
-	 */
-	public void testWriteRssOutput() throws XMLStreamException,
-			FactoryConfigurationError {
-		{
-			StringWriter stW = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(stW);
-			this.impl.setTextValue("Lucene");
-			this.impl.writeRssOutput(writer);
-			assertEquals("<" + this.impl.getLocalName() + ">Lucene</"
-					+ this.impl.getLocalName() + ">", stW.toString());
-		}
-
-		{
-			StringWriter stW = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(stW);
-			this.impl.setUri("http://apache.org");
-			this.impl.setGeneratorVersion("1");
-			this.impl.writeRssOutput(writer);
-			assertEquals("<" + this.impl.getLocalName() + ">Lucene</"
-					+ this.impl.getLocalName() + ">", stW.toString());
-		}
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMIdImplTest.java b/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMIdImplTest.java
deleted file mode 100644
index 365785d..0000000
--- a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMIdImplTest.java
+++ /dev/null
@@ -1,115 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import java.io.StringWriter;
-
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-import org.apache.lucene.gdata.gom.writer.GOMStaxWriter;
-
-import junit.framework.TestCase;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class GOMIdImplTest extends TestCase {
-	GOMIdImpl impl;
-
-	protected void setUp() throws Exception {
-		this.impl = new GOMIdImpl();
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMIdImpl.writeAtomOutput(GOMOutputWriter)'
-	 */
-	public void testWriteAtomOutput() throws XMLStreamException {
-		{
-			StringWriter stW = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(stW);
-			this.impl.writeAtomOutput(writer);
-
-			assertEquals("<id/>", stW.toString());
-		}
-
-		{
-			this.impl.setTextValue("testme");
-			StringWriter stW = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(stW);
-			this.impl.writeAtomOutput(writer);
-
-			assertEquals("<id>testme</id>", stW.toString());
-
-		}
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMIdImpl.writeRssOutput(GOMOutputWriter)'
-	 */
-	public void testWriteRssOutputGOMOutputWriter() throws XMLStreamException {
-		{
-			StringWriter stW = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(stW);
-			this.impl.writeRssOutput(writer);
-
-			assertEquals("<atom:id/>", stW.toString());
-		}
-
-		{
-			this.impl.setTextValue("testme");
-			StringWriter stW = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(stW);
-			this.impl.writeRssOutput(writer);
-
-			assertEquals("<atom:id>testme</atom:id>", stW.toString());
-
-		}
-
-		{
-			this.impl.setTextValue("testme");
-			StringWriter stW = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(stW);
-			this.impl.writeRssOutput(writer, "guid");
-
-			assertEquals("<guid>testme</guid>", stW.toString());
-
-		}
-
-	}
-
-	public void testProcessElementValue() {
-		this.impl.processElementValue("test");
-		assertEquals("test", this.impl.getTextValue());
-	}
-
-	public void testProcessEndElement() {
-		try {
-			this.impl.processEndElement();
-			fail("not set");
-		} catch (GDataParseException e) {
-			// 
-		}
-		this.impl.setTextValue("testme");
-		this.impl.processEndElement();
-
-	}
-}
diff --git a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMLinkImplTest.java b/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMLinkImplTest.java
deleted file mode 100644
index a37097e..0000000
--- a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMLinkImplTest.java
+++ /dev/null
@@ -1,239 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import java.io.StringWriter;
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.GOMLink;
-import org.apache.lucene.gdata.gom.writer.GOMStaxWriter;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-import junit.framework.TestCase;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class GOMLinkImplTest extends TestCase {
-
-	private GOMLinkImpl impl;
-
-	/**
-	 * @see junit.framework.TestCase#setUp()
-	 */
-	@Override
-	protected void setUp() throws Exception {
-		impl = new GOMLinkImpl();
-	}
-
-	public void testCommonFields() {
-		assertNotNull(this.impl.getQname());
-		QName qname = this.impl.getQname();
-		assertEquals(qname, new QName(GOMLink.LOCALNAME));
-		assertEquals(qname.getLocalPart(), this.impl.getLocalName());
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMLinkImpl.processAttribute(QName,
-	 * String)'
-	 */
-	public void testProcessAttribute() {
-		// title
-		this.impl.processAttribute(new QName("title"), "title");
-		assertEquals("title", this.impl.getTitle());
-		try {
-			this.impl.processAttribute(new QName("title"), "title");
-			fail("duplicated attribute");
-		} catch (GDataParseException e) {
-			// 
-		}
-
-		// hreflang
-		this.impl.processAttribute(new QName("hreflang"), "hreflang");
-		assertEquals("hreflang", this.impl.getHrefLang());
-		try {
-			this.impl.processAttribute(new QName("hreflang"), "hreflang");
-			fail("duplicated attribute");
-		} catch (GDataParseException e) {
-			// 
-		}
-
-		// href
-		this.impl.processAttribute(new QName("href"), "href");
-		assertEquals("href", this.impl.getHref());
-		try {
-			this.impl.processAttribute(new QName("href"), "href");
-			fail("duplicated attribute");
-		} catch (GDataParseException e) {
-			// 
-		}
-		// type
-		this.impl.processAttribute(new QName("type"), "type");
-		assertEquals("type", this.impl.getType());
-		try {
-			this.impl.processAttribute(new QName("type"), "type");
-			fail("duplicated attribute");
-		} catch (GDataParseException e) {
-			// 
-		}
-
-		// lenght
-		try {
-			this.impl.processAttribute(new QName("length"), "noint");
-			fail("must be an integer");
-		} catch (GDataParseException e) {
-			// 
-		}
-
-		this.impl.processAttribute(new QName("length"), "1");
-		assertEquals(new Integer(1), this.impl.getLength());
-		try {
-			this.impl.processAttribute(new QName("length"), "1");
-			fail("duplicated attribute");
-		} catch (GDataParseException e) {
-			// 
-		}
-
-		// 
-		// rel
-		this.impl.processAttribute(new QName("rel"), "relation");
-		assertEquals("relation", this.impl.getRel());
-		try {
-			this.impl.processAttribute(new QName("rel"), "relation");
-			fail("duplicated attribute");
-		} catch (GDataParseException e) {
-			// 
-		}
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMLinkImpl.processEndElement()'
-	 */
-	public void testProcessEndElement() {
-		try {
-			this.impl.processEndElement();
-			fail("href is requiered but not set");
-		} catch (GDataParseException e) {
-			// 
-		}
-
-		this.impl.setHref("/helloworld");
-		try {
-			this.impl.processEndElement();
-			fail("href is not an absolute url");
-		} catch (GDataParseException e) {
-			// 
-		}
-		this.impl.xmlBase = "http://url";
-		this.impl.processEndElement();
-		this.impl.xmlBase = null;
-		this.impl.setHref("http://www.apache.org");
-		this.impl.processEndElement();
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMLinkImpl.writeAtomOutput(GOMWriter)'
-	 */
-	public void testWriteAtomOutput() throws XMLStreamException {
-		{
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			this.impl.writeAtomOutput(writer);
-			assertEquals("<link href=\"\"/>", strWriter.toString());
-		}
-		{
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			this.impl.setHref("test");
-			this.impl.setHrefLang("test1");
-			this.impl.setLength(2);
-			this.impl.setRel("NEXT");
-			this.impl.setTitle("myTitle");
-			this.impl.setType("myType");
-			this.impl.writeAtomOutput(writer);
-			assertTrue(strWriter.toString().contains("href=\"test\""));
-			assertTrue(strWriter.toString().contains("title=\"myTitle\""));
-			assertTrue(strWriter.toString().contains("hreflang=\"test1\""));
-			assertTrue(strWriter.toString().contains("type=\"myType\""));
-			assertTrue(strWriter.toString().contains("rel=\"NEXT\""));
-			assertTrue(strWriter.toString().contains("length=\"2\""));
-		}
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMLinkImpl.writeRssOutput(GOMWriter)'
-	 */
-	public void testWriteRssOutput() throws XMLStreamException {
-		{
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			this.impl.writeRssOutput(writer);
-			assertEquals("", strWriter.toString());
-		}
-
-		{
-			this.impl.setHref("test");
-			this.impl.setType("testType");
-			this.impl.setRel("enclosure");
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			this.impl.writeRssOutput(writer);
-			assertEquals("<enclosure type=\"testType\" href=\"test\"/>",
-					strWriter.toString());
-		}
-
-		{
-			this.impl.setRel("comments");
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			this.impl.writeRssOutput(writer);
-			assertEquals("<comments>test</comments>", strWriter.toString());
-		}
-
-		{
-			this.impl.setRel("alternate");
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			this.impl.writeRssOutput(writer);
-			assertEquals("<link>test</link>", strWriter.toString());
-		}
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.AbstractGOMElement.processElementValue(String)'
-	 */
-	public void testProcessElementValue() {
-		try {
-			this.impl.processElementValue("hello world");
-			fail("no content");
-		} catch (GDataParseException e) {
-			// TODO: handle exception
-		}
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMPersonImplTest.java b/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMPersonImplTest.java
deleted file mode 100644
index 70235fa..0000000
--- a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMPersonImplTest.java
+++ /dev/null
@@ -1,176 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import java.io.StringWriter;
-
-import javax.naming.NameParser;
-import javax.xml.namespace.QName;
-import javax.xml.stream.FactoryConfigurationError;
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.GOMNamespace;
-import org.apache.lucene.gdata.gom.writer.GOMStaxWriter;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-import junit.framework.TestCase;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class GOMPersonImplTest extends TestCase {
-
-	/**
-	 * @see junit.framework.TestCase#setUp()
-	 */
-	@Override
-	protected void setUp() throws Exception {
-		// TODO Auto-generated method stub
-		super.setUp();
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMPersonImpl.writeAtomOutput(GOMWriter)'
-	 */
-	public void testWriteAtomOutput() throws XMLStreamException,
-			FactoryConfigurationError {
-		StringWriter stW = new StringWriter();
-		GOMOutputWriter writer = new GOMStaxWriter(stW);
-		GOMPersonImpl impl = new GOMPersonImpl();
-		impl.writeRssOutput(writer);
-		writer.flush();
-		writer.close();
-
-		// test with name
-		stW = new StringWriter();
-		writer = new GOMStaxWriter(stW);
-		impl.setName("test");
-		impl.writeAtomOutput(writer);
-		writer.flush();
-		assertEquals("<person><name>test</name></person>", stW.toString());
-
-		writer.close();
-
-		// test with name
-		stW = new StringWriter();
-		writer = new GOMStaxWriter(stW);
-		impl.setEmail("simonw@apache.org");
-		impl.setUri("http://www.apache.org");
-		impl.writeAtomOutput(writer);
-		writer.flush();
-		assertEquals(
-				"<person><name>test</name><email>simonw@apache.org</email><uri>http://www.apache.org</uri></person>",
-				stW.toString());
-		try {
-			impl.writeAtomOutput(null);
-			fail("must not be null");
-
-		} catch (GDataParseException e) {
-			//
-		}
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMPersonImpl.writeRssOutput(GOMWriter)'
-	 */
-	public void testWriteRssOutput() throws XMLStreamException {
-		StringWriter stW = new StringWriter();
-		GOMOutputWriter writer = new GOMStaxWriter(stW);
-		GOMPersonImpl impl = new GOMPersonImpl();
-		impl.writeRssOutput(writer);
-		writer.flush();
-		assertEquals(0, stW.toString().length());
-	}
-
-	public void testParseAtom() {
-		GOMPersonImpl impl = new GOMPersonImpl();
-		QName name = new QName(GOMNamespace.ATOM_NS_URI, "name");
-		AtomParser childParser = impl.getChildParser(name);
-		String nameValue = "simonw";
-		{
-			assertTrue(childParser instanceof GOMPersonImpl.NameParser);
-
-			childParser.processElementValue(nameValue);
-			childParser.processEndElement();
-			assertEquals(impl.getName(), nameValue);
-			try {
-				childParser.processElementValue(nameValue);
-				childParser.processEndElement();
-				fail("duplicated element");
-
-			} catch (GDataParseException e) {
-				// 
-
-			}
-		}
-		{
-			name = new QName(GOMNamespace.ATOM_NS_URI, "uri");
-			childParser = impl.getChildParser(name);
-			assertTrue(childParser instanceof GOMPersonImpl.UriParser);
-
-			childParser.processElementValue(nameValue);
-			childParser.processEndElement();
-			assertEquals(impl.getUri(), nameValue);
-
-			try {
-				childParser.processElementValue(nameValue);
-				childParser.processEndElement();
-				fail("duplicated element");
-
-			} catch (GDataParseException e) {
-				// 
-
-			}
-
-		}
-		{
-			name = new QName(GOMNamespace.ATOM_NS_URI, "email");
-			childParser = impl.getChildParser(name);
-			assertTrue(childParser instanceof GOMPersonImpl.EmailParser);
-
-			childParser.processElementValue(nameValue);
-			childParser.processEndElement();
-			assertEquals(impl.getEmail(), nameValue);
-
-			try {
-				childParser.processElementValue(nameValue);
-				childParser.processEndElement();
-				fail("duplicated element");
-
-			} catch (GDataParseException e) {
-				// 
-
-			}
-		}
-
-	}
-
-	public void testProcessEndElement() {
-		GOMPersonImpl impl = new GOMPersonImpl();
-		try {
-			impl.processEndElement();
-			fail("name must be set");
-		} catch (GDataParseException e) {
-			// 
-		}
-
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMSourceImplTest.java b/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMSourceImplTest.java
deleted file mode 100644
index bf07d66..0000000
--- a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMSourceImplTest.java
+++ /dev/null
@@ -1,418 +0,0 @@
-package org.apache.lucene.gdata.gom.core;
-
-import java.io.StringWriter;
-import java.util.List;
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.FactoryConfigurationError;
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.GOMAuthor;
-import org.apache.lucene.gdata.gom.GOMCategory;
-import org.apache.lucene.gdata.gom.GOMContributor;
-import org.apache.lucene.gdata.gom.GOMElement;
-import org.apache.lucene.gdata.gom.GOMEntry;
-import org.apache.lucene.gdata.gom.GOMExtension;
-import org.apache.lucene.gdata.gom.GOMFeed;
-import org.apache.lucene.gdata.gom.GOMGenerator;
-import org.apache.lucene.gdata.gom.GOMIcon;
-import org.apache.lucene.gdata.gom.GOMId;
-import org.apache.lucene.gdata.gom.GOMLink;
-import org.apache.lucene.gdata.gom.GOMLogo;
-import org.apache.lucene.gdata.gom.GOMNamespace;
-import org.apache.lucene.gdata.gom.GOMRights;
-import org.apache.lucene.gdata.gom.GOMSource;
-import org.apache.lucene.gdata.gom.GOMSubtitle;
-import org.apache.lucene.gdata.gom.GOMTitle;
-import org.apache.lucene.gdata.gom.GOMUpdated;
-import org.apache.lucene.gdata.gom.core.GOMFeedImplTest.TestExtendsionFactory;
-import org.apache.lucene.gdata.gom.core.GOMFeedImplTest.TestExtension;
-import org.apache.lucene.gdata.gom.core.extension.GOMExtensionFactory;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-import org.apache.lucene.gdata.gom.writer.GOMStaxWriter;
-
-import junit.framework.TestCase;
-
-public class GOMSourceImplTest extends TestCase {
-
-	static final String TEST_LOCAL_NAME = "testelement";
-
-	GOMSourceImpl impl;
-
-	protected void setUp() throws Exception {
-		this.impl = new GOMSourceImpl();
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.getChildParser(QName)'
-	 */
-	public void testGetChildParser() {
-
-		{
-			// atomAuthor*
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "author"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMAuthor);
-			assertEquals(1, this.impl.getAuthors().size());
-			this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
-					"author"));
-			assertEquals(2, this.impl.getAuthors().size());
-		}
-
-		{
-			// atomCategory*
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "category"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMCategory);
-			assertEquals(1, this.impl.getCategories().size());
-			this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
-					"category"));
-			assertEquals(2, this.impl.getCategories().size());
-		}
-
-		{
-			// atomContributor*
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "contributor"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMContributor);
-			assertEquals(1, this.impl.getContributor().size());
-			this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
-					"contributor"));
-			assertEquals(2, this.impl.getContributor().size());
-		}
-		{
-			// atomGenerator?
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "generator"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMGenerator);
-			assertSame(parser, this.impl.getGenerator());
-			try {
-				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
-						"generator"));
-				fail("one or zero");
-			} catch (GDataParseException e) {
-				// 
-			}
-		}
-
-		{
-			// atomIcon?
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "icon"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMIcon);
-			assertSame(parser, this.impl.getIcon());
-			try {
-				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
-						"icon"));
-				fail("one or zero");
-			} catch (GDataParseException e) {
-				// 
-			}
-
-		}
-
-		{
-			// atomId
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "id"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMId);
-			assertSame(parser, this.impl.getId());
-			try {
-				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
-						"id"));
-				fail("exactly one time ");
-			} catch (GDataParseException e) {
-				// 
-			}
-
-		}
-
-		{
-			// atomLink*
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "link"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMLink);
-			assertEquals(1, this.impl.getLinks().size());
-			this.impl
-					.getChildParser(new QName(GOMNamespace.ATOM_NS_URI, "link"));
-			assertEquals(2, this.impl.getLinks().size());
-
-		}
-
-		{
-			// atomLogo?
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "logo"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMLogo);
-			assertSame(parser, this.impl.getLogo());
-			try {
-				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
-						"logo"));
-				fail("zero or one");
-			} catch (GDataParseException e) {
-				// 
-			}
-
-		}
-
-		{
-			// atomRights?
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "rights"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMRights);
-			assertSame(parser, this.impl.getRights());
-			try {
-				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
-						"rights"));
-				fail("zero or one");
-			} catch (GDataParseException e) {
-				// 
-			}
-
-		}
-
-		{
-			// atomSubtitle?
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "subtitle"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMSubtitle);
-			assertSame(parser, this.impl.getSubtitle());
-			try {
-				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
-						"subtitle"));
-				fail("zero or one");
-			} catch (GDataParseException e) {
-				// 
-			}
-
-		}
-
-		{
-			// atomTitle
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "title"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMTitle);
-			assertSame(parser, this.impl.getTitle());
-			try {
-				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
-						"title"));
-				fail("exactly one time ");
-			} catch (GDataParseException e) {
-				// 
-			}
-
-		}
-
-		{
-			// atomUpdated
-			AtomParser parser = this.impl.getChildParser(new QName(
-					GOMNamespace.ATOM_NS_URI, "updated"));
-			assertNotNull(parser);
-			assertTrue(parser instanceof GOMUpdated);
-			assertSame(parser, this.impl.getUpdated());
-			try {
-				this.impl.getChildParser(new QName(GOMNamespace.ATOM_NS_URI,
-						"updated"));
-				fail("exactly one time ");
-			} catch (GDataParseException e) {
-				// 
-			}
-
-		}
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.processElementValue(String)'
-	 */
-	public void testProcessElementValue() {
-		try {
-			this.impl.processElementValue("some");
-			fail("no element text");
-		} catch (GDataParseException e) {
-			//
-		}
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.processEndElement()'
-	 * 
-	 * atomFeed = element atom:feed { atomCommonAttributes, (atomAuthor* &
-	 * atomCategory* & atomContributor* & atomGenerator? & atomIcon? & atomId &
-	 * atomLink* & atomLogo? & atomRights? & atomSubtitle? & atomTitle &
-	 * atomUpdated & extensionElement*), atomEntry* }
-	 */
-	public void testProcessEndElement() {
-		this.impl.addAuthor(new GOMAuthorImpl());
-		this.impl.setId(new GOMIdImpl());
-		this.impl.setUpdated(new GOMUpdatedImpl());
-		this.impl.setTitle(new GOMTitleImpl());
-
-		this.impl.processEndElement();
-		{
-			// author missing
-			this.impl.getAuthors().clear();
-			try {
-				this.impl.processEndElement();
-				fail("missing elements");
-			} catch (GDataParseException e) {
-				// 
-			}
-			this.impl.addAuthor(new GOMAuthorImpl());
-		}
-
-		{
-			// id missing
-			this.impl.setId(null);
-			try {
-				this.impl.processEndElement();
-				fail("missing elements");
-			} catch (GDataParseException e) {
-				// 
-			}
-			this.impl.setId(new GOMIdImpl());
-		}
-
-		{
-			// title missing
-			this.impl.setTitle(null);
-			try {
-				this.impl.processEndElement();
-				fail("missing elements");
-			} catch (GDataParseException e) {
-				// 
-			}
-			this.impl.setTitle(new GOMTitleImpl());
-		}
-		{
-			// updated missing
-			this.impl.setUpdated(null);
-			try {
-				this.impl.processEndElement();
-				fail("missing elements");
-			} catch (GDataParseException e) {
-				// 
-			}
-			this.impl.setUpdated(new GOMUpdatedImpl());
-		}
-
-		/*
-		 * atom:feed elements MUST NOT contain more than one atom:link element
-		 * with a rel attribute value of "alternate" that has the same
-		 * combination of type and hreflang attribute values.
-		 */
-
-		{
-			// two identical alternate links missing
-			GOMLink link = new GOMLinkImpl();
-			link.setRel("alternate");
-			link.setHrefLang("http://www.apache.org");
-			link.setType("text/html");
-			this.impl.addLink(link);
-			// one is allowed
-			this.impl.processEndElement();
-			// add a second link
-			link = new GOMLinkImpl();
-			this.impl.addLink(link);
-			link.setRel("next");
-			link.setHrefLang("http://www.apache.org");
-			link.setType("text/html");
-			// one is alternate the other is next
-			this.impl.processEndElement();
-
-			// a second "identical" alternate link
-			link = new GOMLinkImpl();
-			this.impl.addLink(link);
-			link.setRel("alternate");
-			link.setHrefLang("http://www.apache.org");
-			link.setType("text/html");
-			try {
-				this.impl.processEndElement();
-				fail("missing elements");
-			} catch (GDataParseException e) {
-				// 
-			}
-			this.impl.setUpdated(new GOMUpdatedImpl());
-		}
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.GOMFeedImpl()'
-	 */
-	public void testGOMFeedImpl() {
-		GOMFeedImpl impl2 = new GOMFeedImpl();
-		assertEquals(GOMFeed.LOCALNAME, impl2.getLocalName());
-		assertEquals(GOMFeed.LOCALNAME, impl2.getQname().getLocalPart());
-		assertEquals(GOMNamespace.ATOM_NS_URI, impl2.getQname()
-				.getNamespaceURI());
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.writeAtomOutput(GOMWriter)'
-	 */
-	public void testWriteAtomOutput() throws XMLStreamException,
-			FactoryConfigurationError {
-		// write a whole feed and check if all elements are written
-		this.impl.addAuthor(new GOMAuthorImpl());
-		this.impl.addCategory(new GOMCategoryImpl());
-		this.impl.addContributor(new GOMContributorImpl());
-		this.impl.addLink(new GOMLinkImpl());
-		this.impl.setGenerator(new GOMGeneratorImpl());
-		this.impl.setIcon(new GOMIconImpl());
-		this.impl.setId(new GOMIdImpl());
-		this.impl.setLogo(new GOMLogoImpl());
-		this.impl.setRights(new GOMRightsImpl());
-		this.impl.setSubtitle(new GOMSubtitleImpl());
-		this.impl.setTitle(new GOMTitleImpl());
-		this.impl.setUpdated(new GOMUpdatedImpl());
-		StringWriter stW = new StringWriter();
-		GOMOutputWriter writer = new GOMStaxWriter(stW);
-		this.impl.writeAtomOutput(writer);
-		String string = stW.toString();
-		assertTrue(string.startsWith("<" + GOMSource.LOCALNAME));
-		assertTrue(string.contains("<" + GOMAuthor.LOCALNAME));
-		assertTrue(string.contains("<" + GOMCategory.LOCALNAME));
-		assertTrue(string.contains("<" + GOMContributor.LOCALNAME));
-		assertTrue(string.contains("<" + GOMLink.LOCALNAME));
-		assertTrue(string.contains("<" + GOMGenerator.LOCALNAME));
-		assertTrue(string.contains("<" + GOMIcon.LOCALNAME));
-		assertTrue(string.contains("<" + GOMId.LOCALNAME));
-		assertTrue(string.contains("<" + GOMLogo.LOCALNAME));
-		assertTrue(string.contains("<" + GOMRights.LOCALNAME));
-		assertTrue(string.contains("<" + GOMSubtitle.LOCALNAME));
-		assertTrue(string.contains("<" + GOMTitle.LOCALNAME));
-		assertTrue(string.contains("<" + GOMUpdated.LOCALNAME));
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMFeedImpl.writeRssOutput(GOMWriter)'
-	 */
-	public void testWriteRssOutput() throws XMLStreamException,
-			FactoryConfigurationError {
-
-		StringWriter stW = new StringWriter();
-		GOMOutputWriter writer = new GOMStaxWriter(stW);
-		this.impl.writeRssOutput(writer);
-		assertEquals("", stW.toString());
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMTextConstructImplTest.java b/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMTextConstructImplTest.java
deleted file mode 100644
index 7ef47a3..0000000
--- a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/GOMTextConstructImplTest.java
+++ /dev/null
@@ -1,257 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import java.io.StringWriter;
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.FactoryConfigurationError;
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.ContentType;
-import org.apache.lucene.gdata.gom.core.GOMTextContructImpl.XMLBlobContentParser;
-import org.apache.lucene.gdata.gom.writer.GOMStaxWriter;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-import junit.framework.TestCase;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class GOMTextConstructImplTest extends TestCase {
-	GOMTitleImpl titleImpl;
-
-	GOMSubtitleImpl subTitleImpl;
-
-	protected void setUp() throws Exception {
-		this.titleImpl = new GOMTitleImpl();
-		this.subTitleImpl = new GOMSubtitleImpl();
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMTextContructImpl.getChildParser(QName)'
-	 */
-	public void testGetChildParser() {
-		try {
-			this.titleImpl.getChildParser(null);
-			fail("qname must not be null");
-		} catch (GDataParseException e) {
-			// 
-		}
-		try {
-			this.titleImpl.getChildParser(new QName("test"));
-			fail("no such child supported");
-		} catch (GDataParseException e) {
-			// 
-		}
-
-		try {
-			this.titleImpl.getChildParser(new QName("div"));
-			fail("content type not set");
-		} catch (GDataParseException e) {
-			// 
-		}
-		this.titleImpl.contentType = ContentType.XHTML;
-		AtomParser childParser = this.titleImpl
-				.getChildParser(new QName("div"));
-		assertNotNull(childParser);
-		assertTrue(childParser instanceof XMLBlobContentParser);
-		try {
-			this.titleImpl.getChildParser(new QName("div"));
-			fail("duplicated element");
-		} catch (GDataParseException e) {
-			// 
-		}
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMTextContructImpl.processAttribute(QName,
-	 * String)' includes Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMTextContructImpl.getContentType()
-	 */
-	public void testProcessAttribute() {
-		try {
-			this.titleImpl.processAttribute(null, "test");
-			fail("qname is null");
-		} catch (GDataParseException e) {
-			// 
-		}
-		this.titleImpl.processAttribute(new QName("type"), "text");
-		assertEquals(ContentType.TEXT, this.titleImpl.getContentType());
-		this.titleImpl.contentType = null;
-		this.titleImpl.processAttribute(new QName("type"), "html");
-		assertEquals(ContentType.HTML, this.titleImpl.getContentType());
-		this.titleImpl.contentType = null;
-		this.titleImpl.processAttribute(new QName("type"), "xhtml");
-		assertEquals(ContentType.XHTML, this.titleImpl.getContentType());
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMTextContructImpl.processElementValue(String)'
-	 */
-	public void testProcessElementValue() {
-		this.titleImpl.processElementValue("test");
-		assertEquals("test", this.titleImpl.getTextValue());
-		assertNull(this.titleImpl.htmlBuilder);
-		this.titleImpl.processAttribute(new QName("type"), "html");
-		assertNotNull(this.titleImpl.htmlBuilder);
-
-		this.titleImpl.processElementValue("test");
-		assertEquals("test", this.titleImpl.getTextValue());
-		assertEquals("test", this.titleImpl.htmlBuilder.toString());
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMTextContructImpl.processEndElement()'
-	 */
-	public void testProcessEndElement() {
-		try {
-			this.titleImpl.processEndElement();
-			fail("no content type");
-		} catch (GDataParseException e) {
-			// 
-		}
-		this.titleImpl.contentType = ContentType.TEXT;
-		this.titleImpl.processEndElement();
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMTextContructImpl.writeAtomOutput(GOMWriter)'
-	 */
-	public void testWriteAtomOutput() throws XMLStreamException,
-			FactoryConfigurationError {
-		{
-			this.titleImpl.contentType = ContentType.TEXT;
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			this.titleImpl.writeAtomOutput(writer);
-			assertEquals("<title type=\"text\"/>", strWriter.toString());
-		}
-		{
-			this.titleImpl.setTextValue("><hello world");
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			this.titleImpl.writeAtomOutput(writer);
-			assertEquals("<title type=\"text\">&gt;&lt;hello world</title>",
-					strWriter.toString());
-		}
-
-		{
-			this.titleImpl.contentType = ContentType.HTML;
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			this.titleImpl.writeAtomOutput(writer);
-			assertEquals("<title type=\"html\">&gt;&lt;hello world</title>",
-					strWriter.toString());
-		}
-
-		{
-			this.titleImpl.contentType = ContentType.XHTML;
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			this.titleImpl.writeAtomOutput(writer);
-			assertEquals("<title type=\"xhtml\">><hello world</title>",
-					strWriter.toString());
-		}
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.GOMTextContructImpl.writeRssOutput(GOMWriter)'
-	 */
-	public void testWriteRssOutput() throws XMLStreamException {
-
-		{
-			this.titleImpl.contentType = ContentType.TEXT;
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			this.titleImpl.writeRssOutput(writer);
-			assertEquals("<title/>", strWriter.toString());
-		}
-		{
-			this.titleImpl.setTextValue("><hello world");
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			this.titleImpl.writeRssOutput(writer);
-			assertEquals("<title>&gt;&lt;hello world</title>", strWriter
-					.toString());
-		}
-
-		{
-			this.titleImpl.contentType = ContentType.HTML;
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			this.titleImpl.writeRssOutput(writer);
-			assertEquals("<title>&gt;&lt;hello world</title>", strWriter
-					.toString());
-		}
-
-		{
-			this.titleImpl.contentType = ContentType.XHTML;
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			this.titleImpl.writeRssOutput(writer);
-			// no markup in rss
-			assertEquals("<title>&gt;&lt;hello world</title>", strWriter
-					.toString());
-		}
-
-		{
-			this.titleImpl.contentType = ContentType.XHTML;
-			this.titleImpl.xmlBase = "http://www.apache.org";
-			this.titleImpl.xmlLang = "en";
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			this.titleImpl.writeRssOutput(writer);
-			// no markup in rss
-			assertEquals(
-					"<title xml:base=\"http://www.apache.org\" xml:lang=\"en\">&gt;&lt;hello world</title>",
-					strWriter.toString());
-		}
-
-		{
-			this.subTitleImpl.contentType = ContentType.XHTML;
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			this.subTitleImpl.writeRssOutput(writer);
-
-			assertEquals("<description/>", strWriter.toString());
-		}
-
-		{
-			this.subTitleImpl.contentType = ContentType.XHTML;
-			this.subTitleImpl.setTextValue("><hello world");
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			this.subTitleImpl.writeRssOutput(writer);
-
-			assertEquals("<description>&gt;&lt;hello world</description>",
-					strWriter.toString());
-		}
-	}
-
-}
diff --git a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/SimpleGOMElementImplTest.java b/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/SimpleGOMElementImplTest.java
deleted file mode 100644
index 4dd1c9c..0000000
--- a/contrib/gdata-server/src/gom/test/org/apache/lucene/gdata/gom/core/SimpleGOMElementImplTest.java
+++ /dev/null
@@ -1,136 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.gom.core;
-
-import java.io.StringWriter;
-
-import javax.xml.stream.FactoryConfigurationError;
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.lucene.gdata.gom.GOMNamespace;
-import org.apache.lucene.gdata.gom.writer.GOMStaxWriter;
-import org.apache.lucene.gdata.gom.writer.GOMOutputWriter;
-
-import junit.framework.TestCase;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class SimpleGOMElementImplTest extends TestCase {
-	String localName = "test";
-
-	SimpleGOMElementImpl impl;
-
-	/**
-	 * @see junit.framework.TestCase#setUp()
-	 */
-	@Override
-	protected void setUp() throws Exception {
-		this.impl = new SimpleGOMElementImpl(localName,
-				GOMNamespace.ATOM_NAMESPACE);
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.SimpleGOMElementImpl.processElementValue(String)'
-	 */
-	public void testProcessElementValue() {
-		this.impl.processElementValue("myValue");
-		assertEquals("myValue", this.impl.getTextValue());
-
-		try {
-			this.impl.processElementValue("myValue");
-			fail("duplicated");
-
-		} catch (GDataParseException e) {
-			// 
-		}
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.SimpleGOMElementImpl.processEndElement()'
-	 */
-	public void testProcessEndElement() {
-		// depends validator
-		this.impl.processEndElement();
-		this.impl
-				.setValidator(new GOMFeedImpl.PositiveIntegerValidator("test"));
-		try {
-			this.impl.processEndElement();
-			fail("value is null");
-		} catch (GDataParseException e) {
-			assertTrue(e.getMessage().indexOf("requires a element value") > 0);
-		}
-		this.impl.setTextValue("1");
-		this.impl.processEndElement();
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.SimpleGOMElementImpl.SimpleGOMElementImpl(String,
-	 * GOMNamespace)'
-	 */
-	public void testSimpleGOMElementImpl() {
-		try {
-			new SimpleGOMElementImpl(null, GOMNamespace.ATOM_NAMESPACE);
-			fail("localname is null");
-		} catch (IllegalArgumentException e) {
-			// 
-		}
-		try {
-			new SimpleGOMElementImpl("test", null);
-			fail("namespace is null");
-		} catch (IllegalArgumentException e) {
-			// 
-		}
-
-		SimpleGOMElementImpl impl2 = new SimpleGOMElementImpl(this.localName,
-				GOMNamespace.ATOM_NAMESPACE);
-		assertEquals(impl2.getQname().getNamespaceURI(),
-				GOMNamespace.ATOM_NS_URI);
-		assertEquals(impl2.getQname().getPrefix(), GOMNamespace.ATOM_NS_PREFIX);
-		assertEquals(impl2.getQname().getLocalPart(), this.localName);
-		assertEquals(impl2.getLocalName(), this.localName);
-
-	}
-
-	/*
-	 * Test method for
-	 * 'org.apache.lucene.gdata.gom.core.SimpleGOMElementImpl.writeAtomOutput(GOMWriter)'
-	 */
-	public void testWriteAtomOutput() throws XMLStreamException,
-			FactoryConfigurationError {
-		{
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			this.impl.writeAtomOutput(writer);
-			assertEquals("<atom:" + this.localName + "/>", strWriter.toString());
-		}
-		{
-			StringWriter strWriter = new StringWriter();
-			GOMOutputWriter writer = new GOMStaxWriter(strWriter);
-			this.impl.setTextValue("hello world");
-			this.impl.writeAtomOutput(writer);
-			assertEquals("<atom:" + this.localName + ">hello world</atom:"
-					+ this.localName + ">", strWriter.toString());
-		}
-	}
-
-}
diff --git a/contrib/gdata-server/src/hivemind/build.xml b/contrib/gdata-server/src/hivemind/build.xml
new file mode 100644
index 0000000..27104a9
--- /dev/null
+++ b/contrib/gdata-server/src/hivemind/build.xml
@@ -0,0 +1,42 @@
+<?xml version="1.0"?>
+<!-- 
+  Licensed to the Apache Software Foundation (ASF) under one or more
+  contributor license agreements.  See the NOTICE file distributed with
+  this work for additional information regarding copyright ownership.
+  The ASF licenses this file to You under the Apache License, Version 2.0
+  (the "License"); you may not use this file except in compliance with
+  the License.  You may obtain a copy of the License at
+ 
+      http://www.apache.org/licenses/LICENSE-2.0
+ 
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+ 
+-->
+<project name="hivemind" default="default">
+
+	<description>
+		Lucene gdata server hivemind sources build file
+	</description>
+	<path id="additional.dependencies">
+			<fileset dir="../../${gdata.lib.dir}">
+						<include name="servlet-api.jar" />
+						<include name="commons-logging-1.1.jar" />
+			</fileset>
+			<fileset dir="../../${gdata.external.lib.dir}">
+				<include name="easymock-1.2_Java1.5.jar" />
+				<include name="hivemind-1.1.jar" />
+				<include name="hivemind-lib-1.1.jar" />
+				<include name="hivemind-jmx-1.1.jar" />
+				<include name="hessian-3.0.20.jar" />
+			</fileset>
+		</path>
+	<pathconvert property="project.classpath" targetos="unix" refid="additional.dependencies" />
+	
+	<property name="build.dir" location="../../../build/contrib/gdata-server/hivemind" />
+	<property name="dist.dir" location="../../../dist/contrib/gdata-server/hivemind" />
+	<import file="../../../contrib-build.xml" />
+</project>
diff --git a/contrib/gdata-server/src/hivemind/java/org/apache/lucene/gdata/hivemind/servlet/HessianServiceServlet.java b/contrib/gdata-server/src/hivemind/java/org/apache/lucene/gdata/hivemind/servlet/HessianServiceServlet.java
deleted file mode 100644
index 7d45c7d..0000000
--- a/contrib/gdata-server/src/hivemind/java/org/apache/lucene/gdata/hivemind/servlet/HessianServiceServlet.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.hivemind.servlet;
-
-import java.io.IOException;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServlet;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.apache.hivemind.Registry;
-import org.apache.hivemind.servlet.HiveMindFilter;
-import org.apache.lucene.gdata.hivemind.webservice.HessianServiceSkeletonInvoker;
-import org.apache.lucene.gdata.hivemind.webservice.HessianSkeletonProvider;
-
-/**
- * Central Hessian servlet which provides access to all hessian exposed services
- * via a single servlet.
- * 
- * @author Simon Willnauer
- * 
- */
-public class HessianServiceServlet extends HttpServlet {
-
-    /**
-     * 
-     */
-    private static final long serialVersionUID = 5519783120466089391L;
-
-    /**
-     * @see javax.servlet.http.HttpServlet#doPost(javax.servlet.http.HttpServletRequest,
-     *      javax.servlet.http.HttpServletResponse)
-     */
-    @Override
-    protected void doPost(HttpServletRequest arg0, HttpServletResponse arg1)
-            throws ServletException, IOException {
-        try {
-            HessianSkeletonProvider provider = getSkeletonProvider(arg0);
-            HessianServiceSkeletonInvoker invoker = provider
-                    .getServiceSkeletonInvoker(arg0);
-            invoker.invoke(arg0, arg1);
-        } catch (Throwable e) {
-            throw new ServletException("Nested Exception occured -- Message: "
-                    + e.getMessage(), e);
-        }
-
-    }
-
-    private HessianSkeletonProvider getSkeletonProvider(
-            HttpServletRequest request) {
-        Registry reg = HiveMindFilter.getRegistry(request);
-        return (HessianSkeletonProvider) reg
-                .getService(HessianSkeletonProvider.class);
-    }
-
-}
diff --git a/contrib/gdata-server/src/hivemind/java/org/apache/lucene/gdata/hivemind/webservice/HessianServiceSkeletonInvoker.java b/contrib/gdata-server/src/hivemind/java/org/apache/lucene/gdata/hivemind/webservice/HessianServiceSkeletonInvoker.java
deleted file mode 100644
index 57cd722..0000000
--- a/contrib/gdata-server/src/hivemind/java/org/apache/lucene/gdata/hivemind/webservice/HessianServiceSkeletonInvoker.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.hivemind.webservice;
-
-import java.io.IOException;
-
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-/**
- * Internal invoker interface to support more than one version of the protocol. <b>Currently only Version 3.0.20 is supported.<b>
- * 
- * @author Simon Willnauer
- * 
- */
-public interface HessianServiceSkeletonInvoker {
-
-    /**
-     * @param arg0 - httpServletRequest to access the input stream for processing
-     * @param arg1 - httpServletResponse to access the output stream for processing
-     * @throws IOException - if reading or writeing causes an IOException
-     * @throws Throwable - if the Hessian Impl. causes an error
-     */
-    public abstract void invoke(HttpServletRequest arg0, HttpServletResponse arg1)
-            throws IOException, Throwable;
-
-}
diff --git a/contrib/gdata-server/src/hivemind/java/org/apache/lucene/gdata/hivemind/webservice/HessianServiceSkeletonInvokerImpl.java b/contrib/gdata-server/src/hivemind/java/org/apache/lucene/gdata/hivemind/webservice/HessianServiceSkeletonInvokerImpl.java
deleted file mode 100644
index 189fa75..0000000
--- a/contrib/gdata-server/src/hivemind/java/org/apache/lucene/gdata/hivemind/webservice/HessianServiceSkeletonInvokerImpl.java
+++ /dev/null
@@ -1,116 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.hivemind.webservice;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-
-import com.caucho.hessian.io.AbstractHessianOutput;
-import com.caucho.hessian.io.Hessian2Input;
-import com.caucho.hessian.io.Hessian2Output;
-import com.caucho.hessian.io.HessianOutput;
-import com.caucho.hessian.io.SerializerFactory;
-import com.caucho.hessian.server.HessianSkeleton;
-
-/**
- * Wrapps the hessian skeleton invokation logic.
- * This is based on the protocol description of the hessian protocol
- * @author Simon Willnauer
- *
- */
-class HessianServiceSkeletonInvokerImpl implements
-        HessianServiceSkeletonInvoker {
-    private static final Log LOG = LogFactory.getLog(HessianServiceSkeletonInvokerImpl.class);
-    private SerializerFactory serializerFactory;
-    private final HessianSkeleton skeleton;
-    /**
-     * Creates a new HessianServiceSkeletonInvoker
-     * @param skeleton - The skeleton instance to invoke to process the request
-     * 
-     */
-    HessianServiceSkeletonInvokerImpl(final HessianSkeleton skeleton) {
-        this.skeleton = skeleton;
-       
-    }
-
-    /**
-     * @throws Throwable 
-     * @see org.apache.lucene.gdata.hivemind.webservice.HessianServiceSkeletonInvoker#invoke(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
-     */
-    public void invoke(HttpServletRequest arg0, HttpServletResponse arg1) throws Throwable {
-        InputStream inputStream = arg0.getInputStream();
-        OutputStream outputStream = arg1.getOutputStream();
-        /*
-         *This works only with hessian >= hessian-3.0.20!!
-         *but remember this is not a framework  
-         */
-        Hessian2Input hessianInput = new Hessian2Input(inputStream);
-        if (this.serializerFactory != null) {
-                hessianInput.setSerializerFactory(this.serializerFactory);
-        }
-
-        int code = hessianInput.read();
-        if (code != 'c') {
-                throw new IOException("expected 'c' in hessian input at " + code);
-        }
-
-        AbstractHessianOutput  hessianOutput = null;
-        int major = hessianInput.read();
-        // useless read just get the stream in the right position.
-        int minor = hessianInput.read();
-        if (major >= 2) {
-                hessianOutput = new Hessian2Output(outputStream);
-        }
-        else {
-                hessianOutput = new HessianOutput(outputStream);
-        }
-        if (this.serializerFactory != null) {
-                hessianOutput.setSerializerFactory(this.serializerFactory);
-        }
-
-        try {
-            this.skeleton.invoke(hessianInput, hessianOutput);
-        } catch (Throwable e) {
-            LOG.error("Unexpected Exception thrown -- "+e.getMessage(),e);
-            throw e;
-            
-        }
-
-    }
-
-    /**
-     * @return Returns the serializerFactory.
-     */
-    public SerializerFactory getSerializerFactory() {
-        return this.serializerFactory;
-    }
-
-    /**
-     * @param serializerFactory The serializerFactory to set.
-     */
-    public void setSerializerFactory(SerializerFactory serializerFactory) {
-        this.serializerFactory = serializerFactory;
-    }
-
-}
diff --git a/contrib/gdata-server/src/hivemind/java/org/apache/lucene/gdata/hivemind/webservice/HessianSkeletonProvider.java b/contrib/gdata-server/src/hivemind/java/org/apache/lucene/gdata/hivemind/webservice/HessianSkeletonProvider.java
deleted file mode 100644
index a54400d..0000000
--- a/contrib/gdata-server/src/hivemind/java/org/apache/lucene/gdata/hivemind/webservice/HessianSkeletonProvider.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.hivemind.webservice;
-
-import javax.servlet.http.HttpServletRequest;
-
-/**
- * Serviceprovider for within hivemind configured services to expose as
- * webservices. This SkeletonProvider will return the corresponding service to
- * the given <code>HttpServletRequest</code>.
- * <p>
- * Services exported via this provider will be available via a Hessian service
- * endpoint, accessible via a Hessian proxy
- * </p>
- * <p>
- * Fo information on Hessian see: <a
- * href="http://www.caucho.com/hessian">Hessian protocol</a>
- * </p>
- * 
- * @author Simon Willnauer
- * 
- */
-public interface HessianSkeletonProvider {
-
-    /**
-     * Selects the configured Service according to the given request.
-     * 
-     * @param arg0 -
-     *            the current HttpServletRequest
-     * @return - a corresponding HessianServiceSkeletonInvoker
-     */
-    HessianServiceSkeletonInvoker getServiceSkeletonInvoker(
-            HttpServletRequest arg0);
-
-}
diff --git a/contrib/gdata-server/src/hivemind/java/org/apache/lucene/gdata/hivemind/webservice/HessianSkeletonProviderImpl.java b/contrib/gdata-server/src/hivemind/java/org/apache/lucene/gdata/hivemind/webservice/HessianSkeletonProviderImpl.java
deleted file mode 100644
index 8570126..0000000
--- a/contrib/gdata-server/src/hivemind/java/org/apache/lucene/gdata/hivemind/webservice/HessianSkeletonProviderImpl.java
+++ /dev/null
@@ -1,109 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.hivemind.webservice;
-
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-
-import javax.servlet.http.HttpServletRequest;
-
-import com.caucho.hessian.server.HessianSkeleton;
-
-/**
- * Simple provider implementation.
- * @author Simon Willnauer
- * 
- */
-public class HessianSkeletonProviderImpl implements HessianSkeletonProvider {
-    private Map<String, WebserviceMappingBean> mapping;
-
-    private ConcurrentHashMap<String, HessianSkeleton> skeletonCache = new ConcurrentHashMap<String, HessianSkeleton>();
-
-    /**
-     * Creates a new HessianSkeletonProviderImpl instance
-     */
-    public HessianSkeletonProviderImpl() {
-        super();
-
-    }
-
-    /**
-     * The last part of the request URL is used to identify a configured service
-     * mapping.
-     * 
-     * @param path -
-     *            the servletrequest path info
-     * @return - the corresponding HessianSkeleton
-     */
-    protected HessianSkeleton getMappingFromPath(String path) {
-        if (path.endsWith("/"))
-            path = path.substring(0, path.length() - 1);
-        String requestedService = path.substring(path.lastIndexOf("/") + 1);
-        HessianSkeleton retVal = this.skeletonCache.get(requestedService);
-        if (retVal == null) {
-            WebserviceMappingBean wsBean = this.mapping.get(requestedService);
-            if (wsBean == null)
-                throw new NoSuchServiceException();
-            if (!checkInterface(wsBean))
-                throw new RuntimeException(
-                        "The configured webservice interface is not assignable from the corresponding service");
-            retVal = new HessianSkeleton(wsBean.getServiceImpl(), wsBean
-                    .getServiceInterface());
-            /*
-             * rather create this service twice as synchronize the whole block
-             */
-            this.skeletonCache.putIfAbsent(requestedService, retVal);
-        }
-        return retVal;
-    }
-
-    @SuppressWarnings("unchecked")
-    private boolean checkInterface(WebserviceMappingBean bean) {
-        return bean.getServiceInterface().isAssignableFrom(
-                bean.getServiceImpl().getClass());
-    }
-
-    /**
-     * @see org.apache.lucene.gdata.hivemind.webservice.HessianSkeletonProvider#getServiceSkeletonInvoker(javax.servlet.http.HttpServletRequest)
-     */
-    public HessianServiceSkeletonInvoker getServiceSkeletonInvoker(
-            HttpServletRequest arg0) {
-        if (arg0 == null)
-            throw new IllegalArgumentException(
-                    "HttpServletRequest must not be null");
-        HessianSkeleton mappingFromRequest = getMappingFromPath(arg0
-                .getPathInfo());
-        return new HessianServiceSkeletonInvokerImpl(mappingFromRequest);
-    }
-
-    /**
-     * @return Returns the mapping.
-     */
-    public Map<String, WebserviceMappingBean> getMapping() {
-        return this.mapping;
-    }
-
-    /**
-     * @param mapping
-     *            The mapping to set.
-     */
-    public void setMapping(Map<String, WebserviceMappingBean> mapping) {
-        this.mapping = mapping;
-    }
-
-}
diff --git a/contrib/gdata-server/src/hivemind/java/org/apache/lucene/gdata/hivemind/webservice/NoSuchServiceException.java b/contrib/gdata-server/src/hivemind/java/org/apache/lucene/gdata/hivemind/webservice/NoSuchServiceException.java
deleted file mode 100644
index 05b480a..0000000
--- a/contrib/gdata-server/src/hivemind/java/org/apache/lucene/gdata/hivemind/webservice/NoSuchServiceException.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.hivemind.webservice;
-
-/**
- * Service Exception thrown if the requested service is not registered or not available.
- * @author Simon Willnauer
- *
- */
-public class NoSuchServiceException extends RuntimeException {
-
-    /**
-     * 
-     */
-    private static final long serialVersionUID = -3485216993407631494L;
-
-   
-}
diff --git a/contrib/gdata-server/src/hivemind/java/org/apache/lucene/gdata/hivemind/webservice/WebserviceMappingBean.java b/contrib/gdata-server/src/hivemind/java/org/apache/lucene/gdata/hivemind/webservice/WebserviceMappingBean.java
deleted file mode 100644
index 7560728..0000000
--- a/contrib/gdata-server/src/hivemind/java/org/apache/lucene/gdata/hivemind/webservice/WebserviceMappingBean.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.gdata.hivemind.webservice;
-
-/**
- * This class is a simple configuration bean to expose a certain service via a
- * hessian webservice. The configuration requieres the classtype of the
- * interface and an instance of a subclass to invoke the interface methodes.
- * <p>
- * This bean will be created by Hivemind for each configured service and will be
- * passed to the
- * {@link org.apache.lucene.gdata.hivemind.webservice.HessianSkeletonProvider}
- * as a Map.
- * </p>
- * 
- * @author Simon Willnauer
- * 
- */
-public class WebserviceMappingBean {
-    private Class serviceInterface;
-
-    private Object serviceImpl;
-
-    /**
-     * Bean constructor
-     */
-    public WebserviceMappingBean() {
-        super();
-
-    }
-
-    /**
-     * @return Returns the serviceImpl.
-     */
-    public Object getServiceImpl() {
-        return this.serviceImpl;
-    }
-
-    /**
-     * @param serviceImpl
-     *            The serviceImpl to set.
-     */
-    public void setServiceImpl(Object serviceImpl) {
-        this.serviceImpl = serviceImpl;
-    }
-
-    /**
-     * @return Returns the serviceInterface.
-     */
-    public Class getServiceInterface() {
-        return this.serviceInterface;
-    }
-
-    /**
-     * @param serviceInterface
-     *            The serviceInterface to set.
-     */
-    public void setServiceInterface(Class serviceInterface) {
-        this.serviceInterface = serviceInterface;
-    }
-
-}
diff --git a/contrib/gdata-server/src/hivemind/src/java/org/apache/lucene/gdata/hivemind/servlet/HessianServiceServlet.java b/contrib/gdata-server/src/hivemind/src/java/org/apache/lucene/gdata/hivemind/servlet/HessianServiceServlet.java
new file mode 100644
index 0000000..7d45c7d
--- /dev/null
+++ b/contrib/gdata-server/src/hivemind/src/java/org/apache/lucene/gdata/hivemind/servlet/HessianServiceServlet.java
@@ -0,0 +1,71 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.hivemind.servlet;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.hivemind.Registry;
+import org.apache.hivemind.servlet.HiveMindFilter;
+import org.apache.lucene.gdata.hivemind.webservice.HessianServiceSkeletonInvoker;
+import org.apache.lucene.gdata.hivemind.webservice.HessianSkeletonProvider;
+
+/**
+ * Central Hessian servlet which provides access to all hessian exposed services
+ * via a single servlet.
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class HessianServiceServlet extends HttpServlet {
+
+    /**
+     * 
+     */
+    private static final long serialVersionUID = 5519783120466089391L;
+
+    /**
+     * @see javax.servlet.http.HttpServlet#doPost(javax.servlet.http.HttpServletRequest,
+     *      javax.servlet.http.HttpServletResponse)
+     */
+    @Override
+    protected void doPost(HttpServletRequest arg0, HttpServletResponse arg1)
+            throws ServletException, IOException {
+        try {
+            HessianSkeletonProvider provider = getSkeletonProvider(arg0);
+            HessianServiceSkeletonInvoker invoker = provider
+                    .getServiceSkeletonInvoker(arg0);
+            invoker.invoke(arg0, arg1);
+        } catch (Throwable e) {
+            throw new ServletException("Nested Exception occured -- Message: "
+                    + e.getMessage(), e);
+        }
+
+    }
+
+    private HessianSkeletonProvider getSkeletonProvider(
+            HttpServletRequest request) {
+        Registry reg = HiveMindFilter.getRegistry(request);
+        return (HessianSkeletonProvider) reg
+                .getService(HessianSkeletonProvider.class);
+    }
+
+}
diff --git a/contrib/gdata-server/src/hivemind/src/java/org/apache/lucene/gdata/hivemind/webservice/HessianServiceSkeletonInvoker.java b/contrib/gdata-server/src/hivemind/src/java/org/apache/lucene/gdata/hivemind/webservice/HessianServiceSkeletonInvoker.java
new file mode 100644
index 0000000..57cd722
--- /dev/null
+++ b/contrib/gdata-server/src/hivemind/src/java/org/apache/lucene/gdata/hivemind/webservice/HessianServiceSkeletonInvoker.java
@@ -0,0 +1,41 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.hivemind.webservice;
+
+import java.io.IOException;
+
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+/**
+ * Internal invoker interface to support more than one version of the protocol. <b>Currently only Version 3.0.20 is supported.<b>
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public interface HessianServiceSkeletonInvoker {
+
+    /**
+     * @param arg0 - httpServletRequest to access the input stream for processing
+     * @param arg1 - httpServletResponse to access the output stream for processing
+     * @throws IOException - if reading or writeing causes an IOException
+     * @throws Throwable - if the Hessian Impl. causes an error
+     */
+    public abstract void invoke(HttpServletRequest arg0, HttpServletResponse arg1)
+            throws IOException, Throwable;
+
+}
diff --git a/contrib/gdata-server/src/hivemind/src/java/org/apache/lucene/gdata/hivemind/webservice/HessianServiceSkeletonInvokerImpl.java b/contrib/gdata-server/src/hivemind/src/java/org/apache/lucene/gdata/hivemind/webservice/HessianServiceSkeletonInvokerImpl.java
new file mode 100644
index 0000000..189fa75
--- /dev/null
+++ b/contrib/gdata-server/src/hivemind/src/java/org/apache/lucene/gdata/hivemind/webservice/HessianServiceSkeletonInvokerImpl.java
@@ -0,0 +1,116 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.hivemind.webservice;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import com.caucho.hessian.io.AbstractHessianOutput;
+import com.caucho.hessian.io.Hessian2Input;
+import com.caucho.hessian.io.Hessian2Output;
+import com.caucho.hessian.io.HessianOutput;
+import com.caucho.hessian.io.SerializerFactory;
+import com.caucho.hessian.server.HessianSkeleton;
+
+/**
+ * Wrapps the hessian skeleton invokation logic.
+ * This is based on the protocol description of the hessian protocol
+ * @author Simon Willnauer
+ *
+ */
+class HessianServiceSkeletonInvokerImpl implements
+        HessianServiceSkeletonInvoker {
+    private static final Log LOG = LogFactory.getLog(HessianServiceSkeletonInvokerImpl.class);
+    private SerializerFactory serializerFactory;
+    private final HessianSkeleton skeleton;
+    /**
+     * Creates a new HessianServiceSkeletonInvoker
+     * @param skeleton - The skeleton instance to invoke to process the request
+     * 
+     */
+    HessianServiceSkeletonInvokerImpl(final HessianSkeleton skeleton) {
+        this.skeleton = skeleton;
+       
+    }
+
+    /**
+     * @throws Throwable 
+     * @see org.apache.lucene.gdata.hivemind.webservice.HessianServiceSkeletonInvoker#invoke(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
+     */
+    public void invoke(HttpServletRequest arg0, HttpServletResponse arg1) throws Throwable {
+        InputStream inputStream = arg0.getInputStream();
+        OutputStream outputStream = arg1.getOutputStream();
+        /*
+         *This works only with hessian >= hessian-3.0.20!!
+         *but remember this is not a framework  
+         */
+        Hessian2Input hessianInput = new Hessian2Input(inputStream);
+        if (this.serializerFactory != null) {
+                hessianInput.setSerializerFactory(this.serializerFactory);
+        }
+
+        int code = hessianInput.read();
+        if (code != 'c') {
+                throw new IOException("expected 'c' in hessian input at " + code);
+        }
+
+        AbstractHessianOutput  hessianOutput = null;
+        int major = hessianInput.read();
+        // useless read just get the stream in the right position.
+        int minor = hessianInput.read();
+        if (major >= 2) {
+                hessianOutput = new Hessian2Output(outputStream);
+        }
+        else {
+                hessianOutput = new HessianOutput(outputStream);
+        }
+        if (this.serializerFactory != null) {
+                hessianOutput.setSerializerFactory(this.serializerFactory);
+        }
+
+        try {
+            this.skeleton.invoke(hessianInput, hessianOutput);
+        } catch (Throwable e) {
+            LOG.error("Unexpected Exception thrown -- "+e.getMessage(),e);
+            throw e;
+            
+        }
+
+    }
+
+    /**
+     * @return Returns the serializerFactory.
+     */
+    public SerializerFactory getSerializerFactory() {
+        return this.serializerFactory;
+    }
+
+    /**
+     * @param serializerFactory The serializerFactory to set.
+     */
+    public void setSerializerFactory(SerializerFactory serializerFactory) {
+        this.serializerFactory = serializerFactory;
+    }
+
+}
diff --git a/contrib/gdata-server/src/hivemind/src/java/org/apache/lucene/gdata/hivemind/webservice/HessianSkeletonProvider.java b/contrib/gdata-server/src/hivemind/src/java/org/apache/lucene/gdata/hivemind/webservice/HessianSkeletonProvider.java
new file mode 100644
index 0000000..a54400d
--- /dev/null
+++ b/contrib/gdata-server/src/hivemind/src/java/org/apache/lucene/gdata/hivemind/webservice/HessianSkeletonProvider.java
@@ -0,0 +1,50 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.hivemind.webservice;
+
+import javax.servlet.http.HttpServletRequest;
+
+/**
+ * Serviceprovider for within hivemind configured services to expose as
+ * webservices. This SkeletonProvider will return the corresponding service to
+ * the given <code>HttpServletRequest</code>.
+ * <p>
+ * Services exported via this provider will be available via a Hessian service
+ * endpoint, accessible via a Hessian proxy
+ * </p>
+ * <p>
+ * Fo information on Hessian see: <a
+ * href="http://www.caucho.com/hessian">Hessian protocol</a>
+ * </p>
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public interface HessianSkeletonProvider {
+
+    /**
+     * Selects the configured Service according to the given request.
+     * 
+     * @param arg0 -
+     *            the current HttpServletRequest
+     * @return - a corresponding HessianServiceSkeletonInvoker
+     */
+    HessianServiceSkeletonInvoker getServiceSkeletonInvoker(
+            HttpServletRequest arg0);
+
+}
diff --git a/contrib/gdata-server/src/hivemind/src/java/org/apache/lucene/gdata/hivemind/webservice/HessianSkeletonProviderImpl.java b/contrib/gdata-server/src/hivemind/src/java/org/apache/lucene/gdata/hivemind/webservice/HessianSkeletonProviderImpl.java
new file mode 100644
index 0000000..8570126
--- /dev/null
+++ b/contrib/gdata-server/src/hivemind/src/java/org/apache/lucene/gdata/hivemind/webservice/HessianSkeletonProviderImpl.java
@@ -0,0 +1,109 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.hivemind.webservice;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+import javax.servlet.http.HttpServletRequest;
+
+import com.caucho.hessian.server.HessianSkeleton;
+
+/**
+ * Simple provider implementation.
+ * @author Simon Willnauer
+ * 
+ */
+public class HessianSkeletonProviderImpl implements HessianSkeletonProvider {
+    private Map<String, WebserviceMappingBean> mapping;
+
+    private ConcurrentHashMap<String, HessianSkeleton> skeletonCache = new ConcurrentHashMap<String, HessianSkeleton>();
+
+    /**
+     * Creates a new HessianSkeletonProviderImpl instance
+     */
+    public HessianSkeletonProviderImpl() {
+        super();
+
+    }
+
+    /**
+     * The last part of the request URL is used to identify a configured service
+     * mapping.
+     * 
+     * @param path -
+     *            the servletrequest path info
+     * @return - the corresponding HessianSkeleton
+     */
+    protected HessianSkeleton getMappingFromPath(String path) {
+        if (path.endsWith("/"))
+            path = path.substring(0, path.length() - 1);
+        String requestedService = path.substring(path.lastIndexOf("/") + 1);
+        HessianSkeleton retVal = this.skeletonCache.get(requestedService);
+        if (retVal == null) {
+            WebserviceMappingBean wsBean = this.mapping.get(requestedService);
+            if (wsBean == null)
+                throw new NoSuchServiceException();
+            if (!checkInterface(wsBean))
+                throw new RuntimeException(
+                        "The configured webservice interface is not assignable from the corresponding service");
+            retVal = new HessianSkeleton(wsBean.getServiceImpl(), wsBean
+                    .getServiceInterface());
+            /*
+             * rather create this service twice as synchronize the whole block
+             */
+            this.skeletonCache.putIfAbsent(requestedService, retVal);
+        }
+        return retVal;
+    }
+
+    @SuppressWarnings("unchecked")
+    private boolean checkInterface(WebserviceMappingBean bean) {
+        return bean.getServiceInterface().isAssignableFrom(
+                bean.getServiceImpl().getClass());
+    }
+
+    /**
+     * @see org.apache.lucene.gdata.hivemind.webservice.HessianSkeletonProvider#getServiceSkeletonInvoker(javax.servlet.http.HttpServletRequest)
+     */
+    public HessianServiceSkeletonInvoker getServiceSkeletonInvoker(
+            HttpServletRequest arg0) {
+        if (arg0 == null)
+            throw new IllegalArgumentException(
+                    "HttpServletRequest must not be null");
+        HessianSkeleton mappingFromRequest = getMappingFromPath(arg0
+                .getPathInfo());
+        return new HessianServiceSkeletonInvokerImpl(mappingFromRequest);
+    }
+
+    /**
+     * @return Returns the mapping.
+     */
+    public Map<String, WebserviceMappingBean> getMapping() {
+        return this.mapping;
+    }
+
+    /**
+     * @param mapping
+     *            The mapping to set.
+     */
+    public void setMapping(Map<String, WebserviceMappingBean> mapping) {
+        this.mapping = mapping;
+    }
+
+}
diff --git a/contrib/gdata-server/src/hivemind/src/java/org/apache/lucene/gdata/hivemind/webservice/NoSuchServiceException.java b/contrib/gdata-server/src/hivemind/src/java/org/apache/lucene/gdata/hivemind/webservice/NoSuchServiceException.java
new file mode 100644
index 0000000..05b480a
--- /dev/null
+++ b/contrib/gdata-server/src/hivemind/src/java/org/apache/lucene/gdata/hivemind/webservice/NoSuchServiceException.java
@@ -0,0 +1,33 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.hivemind.webservice;
+
+/**
+ * Service Exception thrown if the requested service is not registered or not available.
+ * @author Simon Willnauer
+ *
+ */
+public class NoSuchServiceException extends RuntimeException {
+
+    /**
+     * 
+     */
+    private static final long serialVersionUID = -3485216993407631494L;
+
+   
+}
diff --git a/contrib/gdata-server/src/hivemind/src/java/org/apache/lucene/gdata/hivemind/webservice/WebserviceMappingBean.java b/contrib/gdata-server/src/hivemind/src/java/org/apache/lucene/gdata/hivemind/webservice/WebserviceMappingBean.java
new file mode 100644
index 0000000..7560728
--- /dev/null
+++ b/contrib/gdata-server/src/hivemind/src/java/org/apache/lucene/gdata/hivemind/webservice/WebserviceMappingBean.java
@@ -0,0 +1,77 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.gdata.hivemind.webservice;
+
+/**
+ * This class is a simple configuration bean to expose a certain service via a
+ * hessian webservice. The configuration requieres the classtype of the
+ * interface and an instance of a subclass to invoke the interface methodes.
+ * <p>
+ * This bean will be created by Hivemind for each configured service and will be
+ * passed to the
+ * {@link org.apache.lucene.gdata.hivemind.webservice.HessianSkeletonProvider}
+ * as a Map.
+ * </p>
+ * 
+ * @author Simon Willnauer
+ * 
+ */
+public class WebserviceMappingBean {
+    private Class serviceInterface;
+
+    private Object serviceImpl;
+
+    /**
+     * Bean constructor
+     */
+    public WebserviceMappingBean() {
+        super();
+
+    }
+
+    /**
+     * @return Returns the serviceImpl.
+     */
+    public Object getServiceImpl() {
+        return this.serviceImpl;
+    }
+
+    /**
+     * @param serviceImpl
+     *            The serviceImpl to set.
+     */
+    public void setServiceImpl(Object serviceImpl) {
+        this.serviceImpl = serviceImpl;
+    }
+
+    /**
+     * @return Returns the serviceInterface.
+     */
+    public Class getServiceInterface() {
+        return this.serviceInterface;
+    }
+
+    /**
+     * @param serviceInterface
+     *            The serviceInterface to set.
+     */
+    public void setServiceInterface(Class serviceInterface) {
+        this.serviceInterface = serviceInterface;
+    }
+
+}
diff --git a/contrib/gdata-server/src/hivemind/src/test/org/apache/lucene/gdata/hivemind/webservice/HessianSkeletonProviderImplTest.java b/contrib/gdata-server/src/hivemind/src/test/org/apache/lucene/gdata/hivemind/webservice/HessianSkeletonProviderImplTest.java
new file mode 100644
index 0000000..da3efcb
--- /dev/null
+++ b/contrib/gdata-server/src/hivemind/src/test/org/apache/lucene/gdata/hivemind/webservice/HessianSkeletonProviderImplTest.java
@@ -0,0 +1,134 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.gdata.hivemind.webservice;
+
+import java.io.Serializable;
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.servlet.http.HttpServletRequest;
+
+import junit.framework.TestCase;
+
+import org.easymock.MockControl;
+
+import com.caucho.hessian.server.HessianSkeleton;
+
+/**
+ * @author Simon Willnauer
+ * 
+ */
+public class HessianSkeletonProviderImplTest extends TestCase {
+    HessianSkeletonProviderImpl provider;
+
+    MockControl<HttpServletRequest> mockControl;
+
+    HttpServletRequest mockedRequest;
+
+    static String mapKey = "test";
+
+    static String testPathSuccess = "/endpoint/" + mapKey;
+
+    static String testPathFail = "/endpoint/fail";
+
+    private Map<String, WebserviceMappingBean> mapping;
+
+    protected void setUp() throws Exception {
+        this.mockControl = MockControl.createControl(HttpServletRequest.class);
+        this.mockedRequest = this.mockControl.getMock();
+        this.provider = new HessianSkeletonProviderImpl();
+        this.mapping = new HashMap<String, WebserviceMappingBean>();
+        WebserviceMappingBean bean = new WebserviceMappingBean();
+
+        bean.setServiceImpl(new TestService());
+        bean.setServiceInterface(Serializable.class);
+        this.mapping.put(mapKey, bean);
+        this.provider.setMapping(this.mapping);
+
+    }
+
+    protected void tearDown() throws Exception {
+        super.tearDown();
+    }
+
+    /*
+     * Test method for
+     * 'org.apache.lucene.gdata.hivemind.webservice.HessianSkeletonProviderImpl.getServiceSkeletonInvoker(HttpServletRequest)'
+     */
+    public void testGetServiceSkeletonInvoker() {
+        this.mockControl.expectAndDefaultReturn(this.mockedRequest
+                .getPathInfo(), testPathSuccess);
+        this.mockControl.replay();
+        assertNotNull(this.provider
+                .getServiceSkeletonInvoker(this.mockedRequest));
+        this.mockControl.verify();
+        this.mockControl.reset();
+
+        this.mockControl.expectAndDefaultReturn(this.mockedRequest
+                .getPathInfo(), testPathFail);
+        this.mockControl.replay();
+        try {
+            assertNotNull(this.provider
+                    .getServiceSkeletonInvoker(this.mockedRequest));
+            fail("Service should not be found");
+        } catch (NoSuchServiceException e) {
+            //
+        }
+        this.mockControl.verify();
+        this.mockControl.reset();
+    }
+
+    /**
+     * 
+     */
+    public void testGetMappingFromPath() {
+        try {
+            this.provider.getMappingFromPath(testPathFail);
+            fail("Service should not be found");
+        } catch (NoSuchServiceException e) {
+            //
+        }
+
+        HessianSkeleton retVal = this.provider
+                .getMappingFromPath(testPathSuccess);
+        assertNotNull(retVal);
+        HessianSkeleton retVal1 = this.provider
+                .getMappingFromPath(testPathSuccess + "/");
+        assertEquals(retVal, retVal1);
+        assertNotNull(retVal);
+        assertEquals(Serializable.class.getName(), retVal.getAPIClassName());
+
+    }
+
+    /**
+     * 
+     */
+    public void testVerifyInterfaceImpl() {
+        this.mapping.get(mapKey).setServiceImpl(new WebserviceMappingBean());
+        try {
+            this.provider.getMappingFromPath(testPathSuccess);
+            fail("Impl is not assignable to Interface");
+        } catch (RuntimeException e) {
+            //
+        }
+    }
+
+    private static class TestService implements Serializable {
+        // just for test case
+    }
+
+}
diff --git a/contrib/gdata-server/src/hivemind/test/org/apache/lucene/gdata/hivemind/webservice/HessianSkeletonProviderImplTest.java b/contrib/gdata-server/src/hivemind/test/org/apache/lucene/gdata/hivemind/webservice/HessianSkeletonProviderImplTest.java
deleted file mode 100644
index da3efcb..0000000
--- a/contrib/gdata-server/src/hivemind/test/org/apache/lucene/gdata/hivemind/webservice/HessianSkeletonProviderImplTest.java
+++ /dev/null
@@ -1,134 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.gdata.hivemind.webservice;
-
-import java.io.Serializable;
-import java.util.HashMap;
-import java.util.Map;
-
-import javax.servlet.http.HttpServletRequest;
-
-import junit.framework.TestCase;
-
-import org.easymock.MockControl;
-
-import com.caucho.hessian.server.HessianSkeleton;
-
-/**
- * @author Simon Willnauer
- * 
- */
-public class HessianSkeletonProviderImplTest extends TestCase {
-    HessianSkeletonProviderImpl provider;
-
-    MockControl<HttpServletRequest> mockControl;
-
-    HttpServletRequest mockedRequest;
-
-    static String mapKey = "test";
-
-    static String testPathSuccess = "/endpoint/" + mapKey;
-
-    static String testPathFail = "/endpoint/fail";
-
-    private Map<String, WebserviceMappingBean> mapping;
-
-    protected void setUp() throws Exception {
-        this.mockControl = MockControl.createControl(HttpServletRequest.class);
-        this.mockedRequest = this.mockControl.getMock();
-        this.provider = new HessianSkeletonProviderImpl();
-        this.mapping = new HashMap<String, WebserviceMappingBean>();
-        WebserviceMappingBean bean = new WebserviceMappingBean();
-
-        bean.setServiceImpl(new TestService());
-        bean.setServiceInterface(Serializable.class);
-        this.mapping.put(mapKey, bean);
-        this.provider.setMapping(this.mapping);
-
-    }
-
-    protected void tearDown() throws Exception {
-        super.tearDown();
-    }
-
-    /*
-     * Test method for
-     * 'org.apache.lucene.gdata.hivemind.webservice.HessianSkeletonProviderImpl.getServiceSkeletonInvoker(HttpServletRequest)'
-     */
-    public void testGetServiceSkeletonInvoker() {
-        this.mockControl.expectAndDefaultReturn(this.mockedRequest
-                .getPathInfo(), testPathSuccess);
-        this.mockControl.replay();
-        assertNotNull(this.provider
-                .getServiceSkeletonInvoker(this.mockedRequest));
-        this.mockControl.verify();
-        this.mockControl.reset();
-
-        this.mockControl.expectAndDefaultReturn(this.mockedRequest
-                .getPathInfo(), testPathFail);
-        this.mockControl.replay();
-        try {
-            assertNotNull(this.provider
-                    .getServiceSkeletonInvoker(this.mockedRequest));
-            fail("Service should not be found");
-        } catch (NoSuchServiceException e) {
-            //
-        }
-        this.mockControl.verify();
-        this.mockControl.reset();
-    }
-
-    /**
-     * 
-     */
-    public void testGetMappingFromPath() {
-        try {
-            this.provider.getMappingFromPath(testPathFail);
-            fail("Service should not be found");
-        } catch (NoSuchServiceException e) {
-            //
-        }
-
-        HessianSkeleton retVal = this.provider
-                .getMappingFromPath(testPathSuccess);
-        assertNotNull(retVal);
-        HessianSkeleton retVal1 = this.provider
-                .getMappingFromPath(testPathSuccess + "/");
-        assertEquals(retVal, retVal1);
-        assertNotNull(retVal);
-        assertEquals(Serializable.class.getName(), retVal.getAPIClassName());
-
-    }
-
-    /**
-     * 
-     */
-    public void testVerifyInterfaceImpl() {
-        this.mapping.get(mapKey).setServiceImpl(new WebserviceMappingBean());
-        try {
-            this.provider.getMappingFromPath(testPathSuccess);
-            fail("Impl is not assignable to Interface");
-        } catch (RuntimeException e) {
-            //
-        }
-    }
-
-    private static class TestService implements Serializable {
-        // just for test case
-    }
-
-}

