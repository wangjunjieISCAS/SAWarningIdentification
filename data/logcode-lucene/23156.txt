GitDiffStart: db238e787fb1a07bc2ee68ab814c017527214ceb | Sat Jan 13 04:08:23 2007 +0000
diff --git a/contrib/benchmark/CHANGES.txt b/contrib/benchmark/CHANGES.txt
new file mode 100644
index 0000000..895d61b
--- /dev/null
+++ b/contrib/benchmark/CHANGES.txt
@@ -0,0 +1,11 @@
+Lucene Benchmark Contrib Change Log
+
+The Benchmark contrib package contains code for benchmarking Lucene in a variety of ways.
+
+$Id:$
+
+01/09/07
+
+1. Committed Doron Cohen's benchmarking contribution, which provides an easily expandable task based approach to benchmarking.  See the javadocs for information. (Doron Cohen via Grant Ingersoll)
+
+2. Added this file.
\ No newline at end of file
diff --git a/contrib/benchmark/build.xml b/contrib/benchmark/build.xml
index ec79de2..05cb621 100644
--- a/contrib/benchmark/build.xml
+++ b/contrib/benchmark/build.xml
@@ -1,119 +1,130 @@
-<?xml version="1.0"?>
-<project name="benchmark" default="default">
-
-    <description>
-        Lucene Benchmarking Contributions
-    </description>
-
-    <import file="../contrib-build.xml"/>
-    <property name="working.dir" value="work"/>
-
-    <target name="check-files">
-
-        <available file="temp/news20.tar.gz" property="news20.exists"/>
-
-        <available file="${working.dir}/20_newsgroup" property="news20.expanded"/>
-
-        <available file="temp/reuters21578.tar.gz" property="reuters.exists"/>
-        <available file="${working.dir}/reuters" property="reuters.expanded"/>
-        <available file="${working.dir}/reuters-out" property="reuters.extracted"/>
-        <available file="temp/20news-18828.tar.gz" property="20news-18828.exists"/>
-        <available file="${working.dir}/20news-18828" property="20news-18828.expanded"/>
-        <available file="${working.dir}/mini_newsgroups" property="mini.expanded"/>
-        
-    </target>
-
-    <target name="get-news-20" unless="20news-18828.exists">
-        <get src="http://www-2.cs.cmu.edu/afs/cs.cmu.edu/project/theo-20/www/data/news20.tar.gz"
-             dest="temp/news20.tar.gz"/>
-
-    </target>
-    <target name="get-reuters" unless="reuters.exists">
-
-        <get src="http://www.daviddlewis.com/resources/testcollections/reuters21578/reuters21578.tar.gz"
-            dest="temp/reuters21578.tar.gz"/>
-    </target>
-
-    <target name="expand-news-20"  unless="news20.expanded">
-        <gunzip src="temp/news20.tar.gz" dest="temp"/>
-        <untar src="temp/news20.tar" dest="${working.dir}"/>
-    </target>
-    <target name="expand-reuters" unless="reuters.expanded">
-        <gunzip src="temp/reuters21578.tar.gz" dest="temp"/>
-        <mkdir dir="${working.dir}/reuters"/>
-        <untar src="temp/reuters21578.tar" dest="${working.dir}/reuters"/>
-        <delete >
-            <fileset dir="${working.dir}/reuters">
-                <include name="*.txt"/>
-            </fileset>
-        </delete>
-
-    </target>
-    <target name="extract-reuters" depends="check-files" unless="reuters.extracted">
-        <mkdir dir="${working.dir}/reuters-out"/>
-        <java classname="org.apache.lucene.benchmark.utils.ExtractReuters" maxmemory="1024M" fork="true">
-            <classpath refid="run.classpath"/>
-            <arg line="${working.dir}/reuters ${working.dir}/reuters-out"/>
-        </java>
-    </target>
-    <target name="get-20news-18828" unless="20news-18828.exists">
-        <get src="http://people.csail.mit.edu/u/j/jrennie/public_html/20Newsgroups/20news-18828.tar.gz"
-             dest="temp/20news-18828.tar.gz"/>
-
-    </target>
-    <target name="expand-20news-18828" unless="20news-18828.expanded">
-        <gunzip src="temp/20news-18828.tar.gz" dest="temp"/>
-        <untar src="temp/20news-18828.tar" dest="${working.dir}"/>
-    </target>
-    <target name="get-mini-news" unless="mini.exists">
-        <get src="http://kdd.ics.uci.edu/databases/20newsgroups/mini_newsgroups.tar.gz"
-             dest="temp/mini_newsgroups.tar.gz"/>
-    </target>
-    <target name="expand-mini-news" unless="mini.expanded">
-        <gunzip src="temp/mini_newsgroups.tar.gz" dest="temp"/>
-        <untar src="temp/mini_newsgroups.tar" dest="${working.dir}"/>
-    </target>
-
-    <target name="get-files" depends="check-files">
-        <mkdir dir="temp"/>
-        <antcall target="get-reuters"/>
-        <antcall target="expand-reuters"/>
-        <antcall target="extract-reuters"/>
-    </target>
-    <property name="digester.jar" value="commons-digester-1.7.jar"/>
-    <property name="collections.jar" value="commons-collections-3.1.jar"/>
-    <property name="logging.jar" value="commons-logging-1.0.4.jar"/>
-    <property name="bean-utils.jar" value="commons-beanutils-1.7.0.jar"/>
-    <path id="classpath">
-        <pathelement path="${lucene.jar}"/>
-        <pathelement path="${basedir}/lib/${digester.jar}"/>
-        <pathelement path="${basedir}/lib/${collections.jar}"/>
-        <pathelement path="${basedir}/lib/${logging.jar}"/>
-        <pathelement path="${basedir}/lib/${bean-utils.jar}"/>
-    </path>
-    <path id="run.classpath">
-        <path refid="classpath"/>
-        <pathelement location="${build.dir}/classes/java"/>
-        <pathelement path="${basedir}/lib/${digester.jar}"/>
-        <pathelement path="${basedir}/lib/${collections.jar}"/>
-        <pathelement path="${basedir}/lib/${logging.jar}"/>
-        <pathelement path="${basedir}/lib/${bean-utils.jar}"/>
-    </path>
-
-    <target name="run-standard" depends="compile,check-files,get-files" description="Run the standard baseline">
-        <echo>Working Directory: ${working.dir}</echo>
-        <java classname="org.apache.lucene.benchmark.Driver"  maxmemory="1024M" fork="true">
-            <classpath refid="run.classpath"/>
-            <arg line="${working.dir} ${basedir}/conf/standard-config.xml"/>
-        </java>
-    </target>
-    <target name="run-micro-standard" depends="compile,check-files,get-files" description="Run the standard baseline">
-        <echo>Working Directory: ${working.dir}</echo>
-        <java classname="org.apache.lucene.benchmark.Driver" maxmemory="1024M" fork="true">
-            <classpath refid="run.classpath"/>
-            <arg line="${working.dir} ${basedir}/conf/micro-standard-config.xml"/>
-        </java>
-    </target>
-
-    <target name="init" depends="common.init,check-files"/>
-</project>
+<?xml version="1.0"?>
+<project name="benchmark" default="default">
+
+    <description>
+        Lucene Benchmarking Contributions
+    </description>
+
+    <import file="../contrib-build.xml"/>
+    <property name="working.dir" value="work"/>
+
+    <target name="check-files">
+
+        <available file="temp/news20.tar.gz" property="news20.exists"/>
+
+        <available file="${working.dir}/20_newsgroup" property="news20.expanded"/>
+
+        <available file="temp/reuters21578.tar.gz" property="reuters.exists"/>
+        <available file="${working.dir}/reuters" property="reuters.expanded"/>
+        <available file="${working.dir}/reuters-out" property="reuters.extracted"/>
+        <available file="temp/20news-18828.tar.gz" property="20news-18828.exists"/>
+        <available file="${working.dir}/20news-18828" property="20news-18828.expanded"/>
+        <available file="${working.dir}/mini_newsgroups" property="mini.expanded"/>
+        
+    </target>
+
+    <target name="get-news-20" unless="20news-18828.exists">
+        <get src="http://www-2.cs.cmu.edu/afs/cs.cmu.edu/project/theo-20/www/data/news20.tar.gz"
+             dest="temp/news20.tar.gz"/>
+
+    </target>
+    <target name="get-reuters" unless="reuters.exists">
+
+        <get src="http://www.daviddlewis.com/resources/testcollections/reuters21578/reuters21578.tar.gz"
+            dest="temp/reuters21578.tar.gz"/>
+    </target>
+
+    <target name="expand-news-20"  unless="news20.expanded">
+        <gunzip src="temp/news20.tar.gz" dest="temp"/>
+        <untar src="temp/news20.tar" dest="${working.dir}"/>
+    </target>
+    <target name="expand-reuters" unless="reuters.expanded">
+        <gunzip src="temp/reuters21578.tar.gz" dest="temp"/>
+        <mkdir dir="${working.dir}/reuters"/>
+        <untar src="temp/reuters21578.tar" dest="${working.dir}/reuters"/>
+        <delete >
+            <fileset dir="${working.dir}/reuters">
+                <include name="*.txt"/>
+            </fileset>
+        </delete>
+
+    </target>
+    <target name="extract-reuters" depends="check-files" unless="reuters.extracted">
+        <mkdir dir="${working.dir}/reuters-out"/>
+        <java classname="org.apache.lucene.benchmark.utils.ExtractReuters" maxmemory="1024M" fork="true">
+            <classpath refid="run.classpath"/>
+            <arg line="${working.dir}/reuters ${working.dir}/reuters-out"/>
+        </java>
+    </target>
+    <target name="get-20news-18828" unless="20news-18828.exists">
+        <get src="http://people.csail.mit.edu/u/j/jrennie/public_html/20Newsgroups/20news-18828.tar.gz"
+             dest="temp/20news-18828.tar.gz"/>
+
+    </target>
+    <target name="expand-20news-18828" unless="20news-18828.expanded">
+        <gunzip src="temp/20news-18828.tar.gz" dest="temp"/>
+        <untar src="temp/20news-18828.tar" dest="${working.dir}"/>
+    </target>
+    <target name="get-mini-news" unless="mini.exists">
+        <get src="http://kdd.ics.uci.edu/databases/20newsgroups/mini_newsgroups.tar.gz"
+             dest="temp/mini_newsgroups.tar.gz"/>
+    </target>
+    <target name="expand-mini-news" unless="mini.expanded">
+        <gunzip src="temp/mini_newsgroups.tar.gz" dest="temp"/>
+        <untar src="temp/mini_newsgroups.tar" dest="${working.dir}"/>
+    </target>
+
+    <target name="get-files" depends="check-files">
+        <mkdir dir="temp"/>
+        <antcall target="get-reuters"/>
+        <antcall target="expand-reuters"/>
+        <antcall target="extract-reuters"/>
+    </target>
+    <property name="digester.jar" value="commons-digester-1.7.jar"/>
+    <property name="collections.jar" value="commons-collections-3.1.jar"/>
+    <property name="logging.jar" value="commons-logging-1.0.4.jar"/>
+    <property name="bean-utils.jar" value="commons-beanutils-1.7.0.jar"/>
+    <path id="classpath">
+        <pathelement path="${lucene.jar}"/>
+        <pathelement path="${basedir}/lib/${digester.jar}"/>
+        <pathelement path="${basedir}/lib/${collections.jar}"/>
+        <pathelement path="${basedir}/lib/${logging.jar}"/>
+        <pathelement path="${basedir}/lib/${bean-utils.jar}"/>
+    </path>
+    <path id="run.classpath">
+        <path refid="classpath"/>
+        <pathelement location="${build.dir}/classes/java"/>
+        <pathelement path="${basedir}/lib/${digester.jar}"/>
+        <pathelement path="${basedir}/lib/${collections.jar}"/>
+        <pathelement path="${basedir}/lib/${logging.jar}"/>
+        <pathelement path="${basedir}/lib/${bean-utils.jar}"/>
+    </path>
+
+    <target name="run-standard" depends="compile,check-files,get-files" description="Run the standard baseline">
+        <echo>Working Directory: ${working.dir}</echo>
+        <java classname="org.apache.lucene.benchmark.Driver"  maxmemory="1024M" fork="true">
+            <classpath refid="run.classpath"/>
+            <arg line="${working.dir} ${basedir}/conf/standard-config.xml"/>
+        </java>
+    </target>
+    <target name="run-micro-standard" depends="compile,check-files,get-files" description="Run the standard baseline">
+        <echo>Working Directory: ${working.dir}</echo>
+        <java classname="org.apache.lucene.benchmark.Driver" maxmemory="1024M" fork="true">
+            <classpath refid="run.classpath"/>
+            <arg line="${working.dir} ${basedir}/conf/micro-standard-config.xml"/>
+        </java>
+    </target>
+
+    <property name="task.alg" value="${basedir}/conf/micro-standard.alg"/>
+    <property name="task.mem" value="140M"/>
+
+    <target name="run-task" depends="compile,check-files,get-files" description="Run compound penalty perf test">
+        <echo>Working Directory: ${working.dir}</echo>
+        <java classname="org.apache.lucene.benchmark.byTask.Benchmark" maxmemory="${task.mem}" fork="true">
+            <classpath refid="run.classpath"/>
+            <arg line="${task.alg}"/>
+        </java>
+    </target>
+
+    <target name="init" depends="common.init,check-files"/>
+</project>
diff --git a/contrib/benchmark/conf/compound-penalty.alg b/contrib/benchmark/conf/compound-penalty.alg
new file mode 100644
index 0000000..c2c8153
--- /dev/null
+++ b/contrib/benchmark/conf/compound-penalty.alg
@@ -0,0 +1,93 @@
+#/**
+# * Licensed to the Apache Software Foundation (ASF) under one or more
+# * contributor license agreements.  See the NOTICE file distributed with
+# * this work for additional information regarding copyright ownership.
+# * The ASF licenses this file to You under the Apache License, Version 2.0
+# * (the "License"); you may not use this file except in compliance with
+# * the License.  You may obtain a copy of the License at
+# *
+# *     http://www.apache.org/licenses/LICENSE-2.0
+# *
+# * Unless required by applicable law or agreed to in writing, software
+# * distributed under the License is distributed on an "AS IS" BASIS,
+# * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# * See the License for the specific language governing permissions and
+# * limitations under the License.
+# */
+
+# --------------------------------------------------------
+# Compound: what is the cost of compound format in indexing?
+# It does twice as much IO, is iyt twice slower? (no)
+# --------------------------------------------------------
+
+# -------------------------------------------------------------------------------------
+# multi val params are iterated by NewRound's, added to reports, start with column name.
+
+merge.factor=mrg:10
+max.buffered=buf:10
+compound=compnd:true:false
+
+analyzer=org.apache.lucene.analysis.standard.StandardAnalyzer
+directory=FSDirectory
+#directory=RamDirectory
+
+doc.stored=stored:true:true:false:false
+doc.tokenized=true
+doc.term.vector=vector:true:true:false:false
+doc.add.log.step=500
+doc.delete.log.step=100
+
+docs.dir=reuters-out
+#docs.dir=reuters-111
+
+#doc.maker=org.apache.lucene.benchmark.byTask.feeds.SimpleDocMaker
+doc.maker=org.apache.lucene.benchmark.byTask.feeds.ReutersDocMaker
+
+#query.maker=org.apache.lucene.benchmark.byTask.feeds.SimpleQueryMaker
+query.maker=org.apache.lucene.benchmark.byTask.feeds.ReutersQueryMaker
+
+# task at this depth or less would print when they start
+task.max.depth.log=1
+
+log.queries=false
+# -------------------------------------------------------------------------------------
+
+ResetSystemErase
+
+{ "Round"
+  CreateIndex
+  { "AddDocs" AddDoc > : 10000
+  CloseIndex
+
+  OpenReader  
+  { "SearchSameRdr" Search > : 500
+  CloseReader 
+              
+  { "WarmNewRdr" Warm > : 50
+              
+  { "SrchNewRdr" Search > : 500
+              
+  { "SrchTrvNewRdr" SearchTrav > : 300
+              
+  { "SrchTrvRetNewRdr" SearchTravRet > : 100
+
+  [ "WarmNewRdr" Warm > : 50
+              
+  [ "SrchNewRdr" Search > : 500
+              
+  [ "SrchTrvNewRdr" SearchTrav > : 300
+              
+  [ "SrchTrvRetNewRdr" SearchTravRet > : 100
+
+  ResetInputs
+  RepSumByName
+  NewRound
+} : 4
+            
+RepSumByName
+RepSumByNameRound
+RepSumByPrefRound AddDocs
+RepSumByPrefRound SearchSameRdr
+RepSumByPrefRound WarmNewRdr
+RepSumByPrefRound SrchTrvNewRdr
+RepSumByPrefRound SrchTrvRetNewRdr
diff --git a/contrib/benchmark/conf/deletes.alg b/contrib/benchmark/conf/deletes.alg
new file mode 100644
index 0000000..4d6a6f2
--- /dev/null
+++ b/contrib/benchmark/conf/deletes.alg
@@ -0,0 +1,70 @@
+#/**
+# * Licensed to the Apache Software Foundation (ASF) under one or more
+# * contributor license agreements.  See the NOTICE file distributed with
+# * this work for additional information regarding copyright ownership.
+# * The ASF licenses this file to You under the Apache License, Version 2.0
+# * (the "License"); you may not use this file except in compliance with
+# * the License.  You may obtain a copy of the License at
+# *
+# *     http://www.apache.org/licenses/LICENSE-2.0
+# *
+# * Unless required by applicable law or agreed to in writing, software
+# * distributed under the License is distributed on an "AS IS" BASIS,
+# * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# * See the License for the specific language governing permissions and
+# * limitations under the License.
+# */
+# --------------------------------------------------------
+# Deletes: what is the cost of deleting documents?
+# --------------------------------------------------------
+
+# -------------------------------------------------------------------------------------
+# multi val params are iterated by NewRound's, added to reports, start with column name.
+
+merge.factor=mrg:10
+max.buffered=buf:100
+compound=true
+
+analyzer=org.apache.lucene.analysis.standard.StandardAnalyzer
+directory=FSDirectory
+#directory=RamDirectory
+
+doc.stored=true
+doc.tokenized=true
+doc.term.vector=false
+doc.add.log.step=10000
+doc.delete.log.step=100
+
+docs.dir=reuters-out
+#docs.dir=reuters-111
+
+doc.maker=org.apache.lucene.benchmark.byTask.feeds.SimpleDocMaker
+#doc.maker=org.apache.lucene.benchmark.byTask.feeds.ReutersDocMaker
+
+query.maker=org.apache.lucene.benchmark.byTask.feeds.SimpleQueryMaker
+#query.maker=org.apache.lucene.benchmark.byTask.feeds.ReutersQueryMaker
+
+# task at this depth or less would print when they start
+task.max.depth.log=1
+
+log.queries=false
+# -------------------------------------------------------------------------------------
+
+ResetSystemErase
+
+CreateIndex
+CloseIndex
+
+{ "Populate"
+    OpenIndex
+    { AddDoc(10) > : 200000
+    Optimize
+    CloseIndex
+> 
+
+{ "Deletions"
+   OpenReader  DeleteDoc   CloseReader
+} : 4000
+
+RepSumByName
+
diff --git a/contrib/benchmark/conf/micro-standard.alg b/contrib/benchmark/conf/micro-standard.alg
new file mode 100644
index 0000000..ef29bf5
--- /dev/null
+++ b/contrib/benchmark/conf/micro-standard.alg
@@ -0,0 +1,76 @@
+#/**
+# * Licensed to the Apache Software Foundation (ASF) under one or more
+# * contributor license agreements.  See the NOTICE file distributed with
+# * this work for additional information regarding copyright ownership.
+# * The ASF licenses this file to You under the Apache License, Version 2.0
+# * (the "License"); you may not use this file except in compliance with
+# * the License.  You may obtain a copy of the License at
+# *
+# *     http://www.apache.org/licenses/LICENSE-2.0
+# *
+# * Unless required by applicable law or agreed to in writing, software
+# * distributed under the License is distributed on an "AS IS" BASIS,
+# * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# * See the License for the specific language governing permissions and
+# * limitations under the License.
+# */
+# -------------------------------------------------------------------------------------
+# multi val params are iterated by NewRound's, added to reports, start with column name.
+
+merge.factor=mrg:10:100:10:100
+max.buffered=buf:10:10:100:100
+compound=true
+
+analyzer=org.apache.lucene.analysis.standard.StandardAnalyzer
+directory=FSDirectory
+#directory=RamDirectory
+
+doc.stored=true
+doc.tokenized=true
+doc.term.vector=false
+doc.add.log.step=500
+
+docs.dir=reuters-out
+#docs.dir=reuters-111
+
+#doc.maker=org.apache.lucene.benchmark.byTask.feeds.SimpleDocMaker
+doc.maker=org.apache.lucene.benchmark.byTask.feeds.ReutersDocMaker
+
+#query.maker=org.apache.lucene.benchmark.byTask.feeds.SimpleQueryMaker
+query.maker=org.apache.lucene.benchmark.byTask.feeds.ReutersQueryMaker
+
+# task at this depth or less would print when they start
+task.max.depth.log=2
+
+log.queries=true
+# -------------------------------------------------------------------------------------
+
+{ "Rounds"
+
+    ResetSystemErase
+
+    { "Populate"
+        CreateIndex
+        { "MAddDocs" AddDoc > : 2000
+        Optimize
+        CloseIndex
+    }
+
+    OpenReader  
+    { "SearchSameRdr" Search > : 5000
+    CloseReader 
+                
+    { "WarmNewRdr" Warm > : 50
+                
+    { "SrchNewRdr" Search > : 500
+                
+    { "SrchTrvNewRdr" SearchTrav > : 300
+                
+    { "SrchTrvRetNewRdr" SearchTravRet > : 100
+                
+    NewRound
+
+} : 4
+
+RepSumByName
+RepSumByPrefRound MAddDocs
diff --git a/contrib/benchmark/conf/sample.alg b/contrib/benchmark/conf/sample.alg
new file mode 100644
index 0000000..e6bc223
--- /dev/null
+++ b/contrib/benchmark/conf/sample.alg
@@ -0,0 +1,85 @@
+#/**
+# * Licensed to the Apache Software Foundation (ASF) under one or more
+# * contributor license agreements.  See the NOTICE file distributed with
+# * this work for additional information regarding copyright ownership.
+# * The ASF licenses this file to You under the Apache License, Version 2.0
+# * (the "License"); you may not use this file except in compliance with
+# * the License.  You may obtain a copy of the License at
+# *
+# *     http://www.apache.org/licenses/LICENSE-2.0
+# *
+# * Unless required by applicable law or agreed to in writing, software
+# * distributed under the License is distributed on an "AS IS" BASIS,
+# * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# * See the License for the specific language governing permissions and
+# * limitations under the License.
+# */
+# --------------------------------------------------------
+# 
+# Sample: what is the effect of doc size on indexing time?
+#
+# There are two parts in this test:
+# - PopulateShort adds 2N documents of length  L
+# - PopulateLong  adds  N documents of length 2L
+# Which one would be faster?
+# The comparison is done twice.
+#
+# --------------------------------------------------------
+
+# -------------------------------------------------------------------------------------
+# multi val params are iterated by NewRound's, added to reports, start with column name.
+
+merge.factor=mrg:10:20
+max.buffered=buf:100:1000
+compound=true
+
+analyzer=org.apache.lucene.analysis.standard.StandardAnalyzer
+directory=FSDirectory
+#directory=RamDirectory
+
+doc.stored=true
+doc.tokenized=true
+doc.term.vector=false
+doc.add.log.step=500
+
+docs.dir=reuters-out
+#docs.dir=reuters-111
+
+doc.maker=org.apache.lucene.benchmark.byTask.feeds.SimpleDocMaker
+#doc.maker=org.apache.lucene.benchmark.byTask.feeds.ReutersDocMaker
+
+query.maker=org.apache.lucene.benchmark.byTask.feeds.SimpleQueryMaker
+#query.maker=org.apache.lucene.benchmark.byTask.feeds.ReutersQueryMaker
+
+# task at this depth or less would print when they start
+task.max.depth.log=2
+
+log.queries=false
+# -------------------------------------------------------------------------------------
+
+{
+
+    { "PopulateShort"
+        CreateIndex
+        { AddDoc(4000) > : 20000
+        Optimize
+        CloseIndex
+    >
+
+    ResetSystemErase
+    
+    { "PopulateLong"
+        CreateIndex
+        { AddDoc(8000) > : 10000
+        Optimize
+        CloseIndex
+    >
+
+    ResetSystemErase
+
+    NewRound
+
+} : 2
+
+RepSumByName
+RepSelectByPref Populate
diff --git a/contrib/benchmark/conf/sloppy-phrase.alg b/contrib/benchmark/conf/sloppy-phrase.alg
new file mode 100644
index 0000000..63f8af7
--- /dev/null
+++ b/contrib/benchmark/conf/sloppy-phrase.alg
@@ -0,0 +1,74 @@
+#/**
+# * Licensed to the Apache Software Foundation (ASF) under one or more
+# * contributor license agreements.  See the NOTICE file distributed with
+# * this work for additional information regarding copyright ownership.
+# * The ASF licenses this file to You under the Apache License, Version 2.0
+# * (the "License"); you may not use this file except in compliance with
+# * the License.  You may obtain a copy of the License at
+# *
+# *     http://www.apache.org/licenses/LICENSE-2.0
+# *
+# * Unless required by applicable law or agreed to in writing, software
+# * distributed under the License is distributed on an "AS IS" BASIS,
+# * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# * See the License for the specific language governing permissions and
+# * limitations under the License.
+# */
+# -------------------------------------------------------------------------------------
+# multi val params are iterated by NewRound's, added to reports, start with column name.
+
+max.buffered=100
+merge.factor=10
+compound=true
+
+analyzer=org.apache.lucene.analysis.standard.StandardAnalyzer
+directory=FSDirectory
+#directory=RamDirectory
+
+doc.stored=false
+doc.tokenized=true
+doc.term.vector=false
+doc.add.log.step=500
+
+docs.dir=reuters-out
+#docs.dir=reuters-111
+
+doc.maker=org.apache.lucene.benchmark.byTask.feeds.SimpleDocMaker
+#doc.maker=org.apache.lucene.benchmark.byTask.feeds.ReutersDocMaker
+
+query.maker=org.apache.lucene.benchmark.byTask.feeds.SimpleSloppyPhraseQueryMaker
+#query.maker=org.apache.lucene.benchmark.byTask.feeds.SimpleQueryMaker
+#query.maker=org.apache.lucene.benchmark.byTask.feeds.ReutersQueryMaker
+
+# task at this depth or less would print when they start
+task.max.depth.log=1
+
+log.queries=false
+# -------------------------------------------------------------------------------------
+
+
+ResetSystemErase
+
+{ "Populate"
+    CreateIndex
+    { "MAddDocs" AddDoc(2000) > : 20000     
+    Optimize
+    CloseIndex
+}
+
+
+{ "Round"
+
+  OpenReader  
+  { "SearchSameRdr" Search > : 6000
+  CloseReader 
+
+  ResetInputs
+  RepSumByName
+  NewRound
+} : 4
+            
+RepSumByPrefRound MAddDocs
+
+RepSumByName
+RepSumByPrefRound Search
diff --git a/contrib/benchmark/conf/standard.alg b/contrib/benchmark/conf/standard.alg
new file mode 100644
index 0000000..c8ffad0
--- /dev/null
+++ b/contrib/benchmark/conf/standard.alg
@@ -0,0 +1,91 @@
+#/**
+# * Licensed to the Apache Software Foundation (ASF) under one or more
+# * contributor license agreements.  See the NOTICE file distributed with
+# * this work for additional information regarding copyright ownership.
+# * The ASF licenses this file to You under the Apache License, Version 2.0
+# * (the "License"); you may not use this file except in compliance with
+# * the License.  You may obtain a copy of the License at
+# *
+# *     http://www.apache.org/licenses/LICENSE-2.0
+# *
+# * Unless required by applicable law or agreed to in writing, software
+# * distributed under the License is distributed on an "AS IS" BASIS,
+# * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# * See the License for the specific language governing permissions and
+# * limitations under the License.
+# */
+# -------------------------------------------------------------------------------------
+# multi val params are iterated by NewRound's, added to reports, start with column name.
+
+merge.factor=mrg:10:100:10:100:10:100:10:100
+max.buffered=buf:10:10:100:100:10:10:100:100
+compound=cmpnd:true:true:true:true:false:false:false:false
+
+analyzer=org.apache.lucene.analysis.standard.StandardAnalyzer
+directory=FSDirectory
+#directory=RamDirectory
+
+doc.stored=true
+doc.tokenized=true
+doc.term.vector=false
+doc.add.log.step=2000
+
+docs.dir=reuters-out
+#docs.dir=reuters-111
+
+#doc.maker=org.apache.lucene.benchmark.byTask.feeds.SimpleDocMaker
+doc.maker=org.apache.lucene.benchmark.byTask.feeds.ReutersDocMaker
+
+#query.maker=org.apache.lucene.benchmark.byTask.feeds.SimpleQueryMaker
+query.maker=org.apache.lucene.benchmark.byTask.feeds.ReutersQueryMaker
+
+# task at this depth or less would print when they start
+task.max.depth.log=2
+
+log.queries=true
+# -------------------------------------------------------------------------------------
+
+{ "Rounds"
+
+    ResetSystemErase
+
+    { "Populate"
+        CreateIndex
+        { "MAddDocs" AddDoc } : 20000
+        Optimize
+        CloseIndex
+    }
+
+    OpenReader  
+    { "SearchSameRdr" Search > : 5000
+    CloseReader 
+                
+    { "WarmNewRdr" Warm > : 50
+                
+    { "SrchNewRdr" Search > : 500
+                
+    { "SrchTrvNewRdr" SearchTrav > : 300
+                
+    { "SrchTrvRetNewRdr" SearchTravRet > : 100
+                
+    OpenReader  
+    [ "SearchSameRdr" Search > : 5000 : 2500
+    CloseReader 
+                
+    [ "WarmNewRdr" Warm > : 50 : 25
+                
+    [ "SrchNewRdr" Search > : 50 : 25
+                
+    [ "SrchTrvNewRdr" SearchTrav > : 300 : 150
+                
+    [ "SrchTrvRetNewRdr" SearchTravRet > : 100 : 50
+
+    RepSumByPref MAddDocs
+
+    NewRound
+
+} : 8
+
+RepSumByNameRound
+RepSumByName
+RepSumByPrefRound MAddDocs
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/Benchmark.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/Benchmark.java
new file mode 100644
index 0000000..28f758d
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/Benchmark.java
@@ -0,0 +1,91 @@
+package org.apache.lucene.benchmark.byTask;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.File;
+
+import org.apache.lucene.benchmark.byTask.utils.Algorithm;
+import org.apache.lucene.benchmark.byTask.utils.Config;
+
+
+/**
+ * Run the benchmark algorithm.
+ * <p>Usage: java Benchmark  algorithm-file
+ * <ol>
+ * <li>Read algorithm.
+ * <li> Run the algorithm.
+ * </ol>
+ */
+public class Benchmark {
+
+  /**
+   * Run the benchmark algorithm.
+   * @param args benchmark config and algorithm files
+   */
+  public static void main(String[] args) {
+    // verify command line args
+    if (args.length < 1) {
+      System.err.println("Usage: java Benchmark <algorithm file>");
+      System.exit(1);
+    }
+    
+    // verify input files 
+    File algFile = new File(args[0]);
+    if (!algFile.exists() || !algFile.isFile() || !algFile.canRead()) {
+      System.err.println("cannot find/read algorithm file: "+algFile.getAbsolutePath()); 
+      System.exit(1);
+    }
+    
+    // last preparations
+    PerfRunData runData = null;
+    try {
+      runData = new PerfRunData(new Config(algFile));
+    } catch (Exception e) {
+      System.err.println("Error: cannot init PerfRunData: "+e.getMessage());
+      e.printStackTrace();
+      System.exit(1);
+    }
+    
+    // parse algorithm
+    Algorithm algorithm = null;
+    try {
+      algorithm = new Algorithm(runData);
+    } catch (Exception e) {
+      System.err.println("Error: cannot understand algorithm from file: "+algFile.getAbsolutePath());
+      e.printStackTrace();
+      System.exit(1);
+    }
+
+    System.out.println("------------> algorithm:");
+    System.out.println(algorithm.toString());
+
+    // execute
+    try {
+      algorithm.execute();
+    } catch (Exception e) {
+      System.err.println("Error: cannot execute the algorithm! "+e.getMessage());
+      e.printStackTrace();
+    }
+
+    System.out.println("####################");
+    System.out.println("###  D O N E !!! ###");
+    System.out.println("####################");
+
+  }
+
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/PerfRunData.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/PerfRunData.java
new file mode 100644
index 0000000..12e37e0
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/PerfRunData.java
@@ -0,0 +1,225 @@
+package org.apache.lucene.benchmark.byTask;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.File;
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.benchmark.byTask.feeds.DocMaker;
+import org.apache.lucene.benchmark.byTask.feeds.QueryMaker;
+import org.apache.lucene.benchmark.byTask.stats.Points;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.FSDirectory;
+import org.apache.lucene.store.RAMDirectory;
+import org.apache.lucene.benchmark.byTask.utils.Config;
+import org.apache.lucene.benchmark.byTask.utils.FileUtils;
+
+
+/**
+ * Data maintained by a performance test run.
+ * <p>
+ * Data includes:
+ * <ul>
+ *  <li>Configuration.
+ *  <li>Directory, Writer, Reader.
+ *  <li>Docmaker and a few instances of QueryMaker.
+ *  <li>Analyzer.
+ *  <li>Statistics data which updated during the run.
+ * </ul>
+ */
+public class PerfRunData {
+
+  private Points points;
+  
+  // objects used during performance test run
+  // directory, analyzer, docMaker - created at startup.
+  // reader, writer, searcher - maintained by basic tasks. 
+  private Directory directory;
+  private Analyzer analyzer;
+  private DocMaker docMaker;
+  private QueryMaker searchQueryMaker;
+  private QueryMaker searchTravQueryMaker;
+  private QueryMaker searchTravRetQueryMaker;
+
+  private IndexReader indexReader;
+  private IndexWriter indexWriter;
+  private Config config;
+  
+  // constructor
+  public PerfRunData (Config config) throws Exception {
+    this.config = config;
+    // analyzer (default is standard analyzer)
+    analyzer = (Analyzer) Class.forName(config.get("analyzer",
+        "org.apache.lucene.analysis.standard.StandardAnalyzer")).newInstance();
+    // doc maker
+    docMaker = (DocMaker) Class.forName(config.get("doc.maker",
+        "org.apache.lucene.benchmark.byTask.utils.SimpleDocMaker")).newInstance();
+    docMaker.setConfig(config);
+    // query makers
+    // we use separate (identical) instances for each "read" task type, so each can iterate the quries separately.
+    Class qmkrClass = Class.forName(config.get("query.maker","org.apache.lucene.benchmark.byTask.utils.SimpleQueryMaker"));
+    searchQueryMaker = (QueryMaker) qmkrClass.newInstance();
+    searchQueryMaker.setConfig(config);
+    searchTravQueryMaker = (QueryMaker) qmkrClass.newInstance();
+    searchTravQueryMaker.setConfig(config);
+    searchTravRetQueryMaker = (QueryMaker) qmkrClass.newInstance();
+    searchTravRetQueryMaker.setConfig(config);
+    // index stuff
+    reinit(false);
+    
+    // statistic points
+    points = new Points(config);
+    
+    if (Boolean.valueOf(config.get("log.queries","false")).booleanValue()) {
+      System.out.println("------------> queries:");
+      System.out.println(getSearchQueryMaker().printQueries());
+    }
+
+  }
+
+  // clean old stuff, reopen 
+  public void reinit(boolean eraseIndex) throws Exception {
+
+    // cleanup index
+    if (indexWriter!=null) {
+      indexWriter.close();
+      indexWriter = null;
+    }
+    if (indexReader!=null) {
+      indexReader.close();
+      indexReader = null;
+    }
+    if (directory!=null) {
+      directory.close();
+    }
+    
+    // directory (default is ram-dir).
+    if ("FSDirectory".equals(config.get("directory","RAMDirectory"))) {
+      File workDir = new File("work");
+      File indexDir = new File(workDir,"index");
+      if (eraseIndex && indexDir.exists()) {
+        FileUtils.fullyDelete(indexDir);
+      }
+      indexDir.mkdirs();
+      directory = FSDirectory.getDirectory(indexDir, eraseIndex);
+    } else {
+      directory = new RAMDirectory();
+    }
+
+    // inputs
+    resetInputs();
+    
+    // release unused stuff
+    System.runFinalization();
+    System.gc();
+  }
+
+  /**
+   * @return Returns the points.
+   */
+  public Points getPoints() {
+    return points;
+  }
+
+  /**
+   * @return Returns the directory.
+   */
+  public Directory getDirectory() {
+    return directory;
+  }
+
+  /**
+   * @param directory The directory to set.
+   */
+  public void setDirectory(Directory directory) {
+    this.directory = directory;
+  }
+
+  /**
+   * @return Returns the indexReader.
+   */
+  public IndexReader getIndexReader() {
+    return indexReader;
+  }
+
+  /**
+   * @param indexReader The indexReader to set.
+   */
+  public void setIndexReader(IndexReader indexReader) {
+    this.indexReader = indexReader;
+  }
+
+  /**
+   * @return Returns the indexWriter.
+   */
+  public IndexWriter getIndexWriter() {
+    return indexWriter;
+  }
+
+  /**
+   * @param indexWriter The indexWriter to set.
+   */
+  public void setIndexWriter(IndexWriter indexWriter) {
+    this.indexWriter = indexWriter;
+  }
+
+  /**
+   * @return Returns the anlyzer.
+   */
+  public Analyzer getAnalyzer() {
+    return analyzer;
+  }
+
+  /**
+   * @return Returns the docMaker.
+   */
+  public DocMaker getDocMaker() {
+    return docMaker;
+  }
+
+  /**
+   * @return Returns the config.
+   */
+  public Config getConfig() {
+    return config;
+  }
+
+  public void resetInputs() {
+    docMaker.resetInputs();
+    searchQueryMaker.resetInputs();
+    searchTravQueryMaker.resetInputs();
+    searchTravRetQueryMaker.resetInputs();
+  }
+
+  /**
+   * @return Returns the searchQueryMaker.
+   */
+  public QueryMaker getSearchQueryMaker() {
+    return searchQueryMaker;
+  }
+
+  public QueryMaker getSearchTravQueryMaker() {
+    return searchTravQueryMaker;
+  }
+
+  public QueryMaker getSearchTravRetQueryMaker() {
+    return searchTravRetQueryMaker;
+  }
+
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/DocMaker.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/DocMaker.java
new file mode 100644
index 0000000..8cb3f7c
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/DocMaker.java
@@ -0,0 +1,64 @@
+package org.apache.lucene.benchmark.byTask.feeds;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.document.Document;
+import org.apache.lucene.benchmark.byTask.utils.Config;
+
+
+/**
+ * Create documents for the test.
+ * <br>Each call to makeDocument would create the next document.
+ * When input is exhausted, the DocMaker iterates over the input again, 
+ * does provifing a source for unlimited number of documents, 
+ * though not all of them are unique. 
+ */
+public interface DocMaker {
+
+  /** 
+   * Create the next document, of the given size by input bytes.
+   * If the implementation does not support control over size, an exception is thrown.
+   * @param size size of document, or 0 if there is no size requirement.
+   * @exception if cannot make the document, or if size>0 was specified but this feature is not supported.
+   */ 
+  public Document makeDocument (int size) throws Exception;
+
+  /** Create the next document. */
+  public Document makeDocument () throws Exception;
+
+  /** Set the properties */
+  public void setConfig (Config config);
+  
+  /** Reset inputs so that the test run would behave, input wise, as if it just started. */
+  public void resetInputs();
+  
+  /** Return how many real unique texts are available, 0 if not applicable. */ 
+  public int numUniqueTexts();
+  
+  /** Return total bytes of all available unique texts, 0 if not applicable */ 
+  public long numUniqueBytes();
+
+  /** Return number of docs made since last reset. */
+  public int getCount();
+
+  /** Return total byte size of docs made since last reset. */
+  public long getByteCount();
+
+  /** Print some statistics on docs available/added/etc. */ 
+  public void printDocStatistics();
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/QueryMaker.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/QueryMaker.java
new file mode 100644
index 0000000..ed8d101
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/QueryMaker.java
@@ -0,0 +1,49 @@
+package org.apache.lucene.benchmark.byTask.feeds;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+import org.apache.lucene.search.Query;
+import org.apache.lucene.benchmark.byTask.utils.Config;
+
+
+/**
+ * Create queries for the test.
+ */
+public interface QueryMaker {
+
+  /** 
+   * Create the next query, of the given size.
+   * @param size the size of the query - number of terms, etc.
+   * @exception if cannot make the query, or if size>0 was specified but this feature is not supported.
+   */ 
+  public Query makeQuery (int size) throws Exception;
+
+  /** Create the next query */ 
+  public Query makeQuery () throws Exception;
+
+  /** Set the properties 
+   * @throws Exception */
+  public void setConfig (Config config) throws Exception;
+  
+  /** Reset inputs so that the test run would behave, input wise, as if it just started. */
+  public void resetInputs();
+  
+  /** Print the queries */
+  public String printQueries();
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/ReutersDocMaker.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/ReutersDocMaker.java
new file mode 100644
index 0000000..bb4c07e
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/ReutersDocMaker.java
@@ -0,0 +1,156 @@
+package org.apache.lucene.benchmark.byTask.feeds;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileReader;
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Date;
+import org.apache.lucene.document.DateTools;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.benchmark.byTask.utils.Config;
+
+
+/**
+ * A DocMaker using the Reuters collection for its input.
+ */
+public class ReutersDocMaker extends SimpleDocMaker {
+
+  private DateFormat dateFormat;
+  private File dataDir = null;
+  private ArrayList txtFiles = new ArrayList();
+  private int nextFile = 0;
+  private int round=0;
+  private int count = 0;
+  
+  /* (non-Javadoc)
+   * @see SimpleDocMaker#setConfig(java.util.Properties)
+   */
+  public void setConfig(Config config) {
+    super.setConfig(config);
+    String d = config.get("docs.dir","reuters-out");
+    dataDir = new File(new File("work"),d);
+    addFiles(dataDir);
+    if (txtFiles.size()==0) {
+      throw new RuntimeException("No txt files in dataDir: "+dataDir.getAbsolutePath());
+    }
+    // date format: 30-MAR-1987 14:22:36.87
+    dateFormat = new SimpleDateFormat("dd-MMM-yyyy kk:mm:ss.SSS");
+    dateFormat.setLenient(true);
+  }
+
+  private void addFiles(File f) {
+    if (!f.canRead()) {
+      return;
+    }
+    if (f.isDirectory()) {
+      File files[] = f.listFiles();
+      for (int i = 0; i < files.length; i++) {
+        addFiles(files[i]);
+      }
+      return;
+    }
+    txtFiles.add(f);
+    addUniqueBytes(f.length());
+  }
+
+  /* (non-Javadoc)
+   * @see SimpleDocMaker#makeDocument()
+   */
+  public Document makeDocument() throws Exception {
+    File f = null;
+    String name = null;
+    synchronized (this) {
+      f = (File) txtFiles.get(nextFile++);
+      name = f.getCanonicalPath()+"_"+round;
+      if (nextFile >= txtFiles.size()) { 
+        // exhausted files, start a new round
+        nextFile = 0;
+        round++;
+      }
+    }
+    
+    Document doc = new Document();
+    doc.add(new Field("name",name,storeVal,indexVal,termVecVal));
+    BufferedReader reader = new BufferedReader(new FileReader(f));
+    String line = null;
+    //First line is the date, 3rd is the title, rest is body
+    String dateStr = reader.readLine();
+    reader.readLine();//skip an empty line
+    String title = reader.readLine();
+    reader.readLine();//skip an empty line
+    StringBuffer body = new StringBuffer(1024);
+    while ((line = reader.readLine()) != null) {
+      body.append(line).append(' ');
+    }
+    Date date = dateFormat.parse(dateStr.trim());
+    doc.add(new Field("date", DateTools.dateToString(date, DateTools.Resolution.SECOND), 
+        Field.Store.YES, Field.Index.UN_TOKENIZED));
+
+    if (title != null) {
+      doc.add(new Field("title", title, storeVal,indexVal,termVecVal));
+    }
+    if (body.length() > 0) {
+        doc.add(new Field("body", body.toString(), storeVal,indexVal,termVecVal));
+    }
+
+    count++;
+    addBytes(f.length());
+
+    return doc;
+  }
+
+  /*
+   *  (non-Javadoc)
+   * @see DocMaker#resetIinputs()
+   */
+  public synchronized void resetInputs() {
+    super.resetInputs();
+    nextFile = 0;
+    round = 0;
+    count = 0;
+  }
+
+  /*
+   *  (non-Javadoc)
+   * @see DocMaker#numUniqueTexts()
+   */
+  public int numUniqueTexts() {
+    return txtFiles.size();
+  }
+
+  /*
+   *  (non-Javadoc)
+   * @see DocMaker#getCount()
+   */
+  public int getCount() {
+    return count;
+  }
+
+  /*
+   *  (non-Javadoc)
+   * @see org.apache.lucene.benchmark.byTask.feeds.DocMaker#makeDocument(int)
+   */
+  public Document makeDocument(int size) throws Exception {
+    throw new Exception(this+".makeDocument (int size) is not supported!");
+  }
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/ReutersQueryMaker.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/ReutersQueryMaker.java
new file mode 100644
index 0000000..eb4527d
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/ReutersQueryMaker.java
@@ -0,0 +1,160 @@
+package org.apache.lucene.benchmark.byTask.feeds;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.queryParser.QueryParser;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.WildcardQuery;
+import org.apache.lucene.search.spans.SpanFirstQuery;
+import org.apache.lucene.search.spans.SpanNearQuery;
+import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.benchmark.byTask.utils.Config;
+import org.apache.lucene.benchmark.byTask.utils.Format;
+
+
+/**
+ * A QueryMaker that makes queries devised manually (by Grant Ingersoll) for
+ * searching in the Reuters collection.
+ */
+public class ReutersQueryMaker implements QueryMaker {
+  
+  private int qnum = 0;
+  private Query queries[];
+  private Config config;
+  
+  private static String [] STANDARD_QUERIES = {
+    //Start with some short queries
+    "Salomon", "Comex", "night trading", "Japan Sony",
+    //Try some Phrase Queries
+    "\"Sony Japan\"", "\"food needs\"~3",
+    "\"World Bank\"^2 AND Nigeria", "\"World Bank\" -Nigeria",
+    "\"Ford Credit\"~5",
+    //Try some longer queries
+    "airline Europe Canada destination",
+    "Long term pressure by trade " +
+    "ministers is necessary if the current Uruguay round of talks on " +
+    "the General Agreement on Trade and Tariffs (GATT) is to " +
+    "succeed"
+  };
+  
+  private static Query[] getPrebuiltQueries(String field) {
+    //  be wary of unanalyzed text
+    return new Query[] {
+        new SpanFirstQuery(new SpanTermQuery(new Term(field, "ford")), 5),
+        new SpanNearQuery(new SpanQuery[]{new SpanTermQuery(new Term(field, "night")), new SpanTermQuery(new Term(field, "trading"))}, 4, false),
+        new SpanNearQuery(new SpanQuery[]{new SpanFirstQuery(new SpanTermQuery(new Term(field, "ford")), 10), new SpanTermQuery(new Term(field, "credit"))}, 10, false),
+        new WildcardQuery(new Term(field, "fo*")),
+    };
+  }
+  
+  /**
+   * Parse the strings containing Lucene queries.
+   *
+   * @param qs array of strings containing query expressions
+   * @param a  analyzer to use when parsing queries
+   * @return array of Lucene queries
+   */
+  private static Query[] createQueries(List qs, Analyzer a) {
+    QueryParser qp = new QueryParser("body", a);
+    List queries = new ArrayList();
+    for (int i = 0; i < qs.size(); i++)  {
+      try {
+        
+        Object query = qs.get(i);
+        Query q = null;
+        if (query instanceof String) {
+          q = qp.parse((String) query);
+          
+        } else if (query instanceof Query) {
+          q = (Query) query;
+          
+        } else {
+          System.err.println("Unsupported Query Type: " + query);
+        }
+        
+        if (q != null) {
+          queries.add(q);
+        }
+        
+      } catch (Exception e)  {
+        e.printStackTrace();
+      }
+    }
+    
+    return (Query[]) queries.toArray(new Query[0]);
+  }
+  
+  private void prepareQueries() throws Exception {
+    // analyzer (default is standard analyzer)
+    Analyzer anlzr= (Analyzer) Class.forName(config.get("analyzer",
+    "org.apache.lucene.analysis.StandardAnalyzer")).newInstance(); 
+    
+    List queryList = new ArrayList(20);
+    queryList.addAll(Arrays.asList(STANDARD_QUERIES));
+    queryList.addAll(Arrays.asList(getPrebuiltQueries("body")));
+    queries = createQueries(queryList, anlzr);
+  }
+  
+  public Query makeQuery() throws Exception {
+    return queries[nextQnum()];
+  }
+  
+  public void setConfig(Config config) throws Exception {
+    this.config = config;
+    prepareQueries();
+  }
+  
+  public void resetInputs() {
+    qnum = 0;
+  }
+  
+  // return next qnum
+  private synchronized int nextQnum() {
+    int res = qnum;
+    qnum = (qnum+1) % queries.length;
+    return res;
+  }
+  
+  public String printQueries() {
+    String newline = System.getProperty("line.separator");
+    StringBuffer sb = new StringBuffer();
+    if (queries != null) {
+      for (int i = 0; i < queries.length; i++) {
+        sb.append(i+". "+Format.simpleName(queries[i].getClass())+" - "+queries[i].toString());
+        sb.append(newline);
+      }
+    }
+    return sb.toString();
+  }
+  
+  /*
+   *  (non-Javadoc)
+   * @see org.apache.lucene.benchmark.byTask.feeds.QueryMaker#makeQuery(int)
+   */
+  public Query makeQuery(int size) throws Exception {
+    throw new Exception(this+".makeQuery(int size) is not supported!");
+  }
+
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/SimpleDocMaker.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/SimpleDocMaker.java
new file mode 100644
index 0000000..f3293ea
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/SimpleDocMaker.java
@@ -0,0 +1,227 @@
+package org.apache.lucene.benchmark.byTask.feeds;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.benchmark.byTask.utils.Config;
+import org.apache.lucene.benchmark.byTask.utils.Format;
+
+
+/**
+ * Create documents for the test
+ */
+public class SimpleDocMaker implements DocMaker {
+  
+  static final String BODY_FIELD = "body";
+  private int docID = 0;
+  private long numBytes = 0;
+  private long numUniqueBytes = 0;
+
+  protected Config config;
+  private int nextDocTextPosition = 0; // for creating docs of fixed size.
+
+  protected Field.Store storeVal = Field.Store.NO;
+  protected Field.Index indexVal = Field.Index.TOKENIZED;
+  protected Field.TermVector termVecVal = Field.TermVector.NO;
+  
+  static final String DOC_TEXT = // from a public first aid info at http://firstaid.ie.eu.org 
+    "Well it may be a little dramatic but sometimes it true. " +
+    "If you call the emergency medical services to an incident, " +
+    "your actions have started the chain of survival. " +
+    "You have acted to help someone you may not even know. " +
+    "First aid is helping, first aid is making that call, " +
+    "putting a Band-Aid on a small wound, controlling bleeding in large " +
+    "wounds or providing CPR for a collapsed person whose not breathing " +
+    "and heart has stopped beating. You can help yourself, your loved " +
+    "ones and the stranger whose life may depend on you being in the " +
+    "right place at the right time with the right knowledge.";
+  
+  private static int DOC_TEXT_LENGTH = DOC_TEXT.length(); 
+
+  /*
+   *  (non-Javadoc)
+   * @see org.apache.lucene.benchmark.byTask.feeds.DocMaker#makeDocument()
+   */
+  public Document makeDocument () throws Exception {
+    return makeDocument(0);
+  }
+
+  /*
+   *  (non-Javadoc)
+   * @see org.apache.lucene.benchmark.byTask.feeds.DocMaker#makeDocument(int)
+   */
+  public Document makeDocument(int size) throws Exception {
+    int docid = newdocid();
+    Document doc = new Document();
+    doc.add(new Field("docid", "doc"+docid, storeVal, indexVal, termVecVal));
+    String docText = createDocText(size);
+    doc.add(new Field(BODY_FIELD, "synthetic body text"+docid+" "+docText, storeVal, indexVal, termVecVal));
+    addBytes(docText.length()); // should multiply by 2 here?
+    return doc;
+  }
+
+  private synchronized int[] nextDocText(int fixedDocSize) {
+    int from = nextDocTextPosition;
+    int to = nextDocTextPosition;
+    int wraps = 0;
+    int size = 0;
+    
+    while (size<fixedDocSize) {
+      int added = DOC_TEXT_LENGTH - to;
+      if (size+added <= fixedDocSize) {
+        to = 0;
+        size += added;
+        wraps ++;
+      } else {
+        added = fixedDocSize - size;
+        size += added;
+        to += added;
+      }
+    }
+    
+    nextDocTextPosition = to;
+    
+    return new int[]{from,to,wraps};
+  }
+  
+  private String createDocText(int fixedDocSize) {
+    if (fixedDocSize<=0) { 
+      //no fixed doc size requirement
+      return DOC_TEXT;
+    } 
+      
+    // create a document wit fixed doc size
+    int fromToWraps[] = nextDocText(fixedDocSize);
+    int from = fromToWraps[0];
+    int to = fromToWraps[1];
+    int wraps = fromToWraps[2];
+    StringBuffer sb = new StringBuffer();
+    while (wraps-- > 0) {
+      sb.append(DOC_TEXT.substring(from));
+      from = 0;
+    }
+    sb.append(DOC_TEXT.substring(from,to));
+    return sb.toString();
+  }
+
+  // return a new docid
+  private synchronized int newdocid() {
+    return docID++;
+  }
+
+  /* (non-Javadoc)
+   * @see DocMaker#setConfig(java.util.Properties)
+   */
+  public void setConfig(Config config) {
+    this.config = config;
+    boolean stored = config.get("doc.stored",false); 
+    boolean tokenized = config.get("doc.tokenized",true);
+    boolean termVec = config.get("doc.term.vector",false);
+    storeVal = (stored ? Field.Store.YES : Field.Store.NO);
+    indexVal = (tokenized ? Field.Index.TOKENIZED : Field.Index.UN_TOKENIZED);
+    termVecVal = (termVec ? Field.TermVector.YES : Field.TermVector.NO);
+  }
+
+  /*
+   *  (non-Javadoc)
+   * @see DocMaker#resetIinputs()
+   */
+  public synchronized void resetInputs() {
+    printDocStatistics();
+    docID = 0;
+    numBytes = 0;
+  }
+
+  /*
+   *  (non-Javadoc)
+   * @see DocMaker#numUniqueTexts()
+   */
+  public int numUniqueTexts() {
+    return 0; // not applicable
+  }
+
+  /*
+   *  (non-Javadoc)
+   * @see org.apache.lucene.benchmark.byTask.feeds.DocMaker#numUniqueBytes()
+   */
+  public long numUniqueBytes() {
+    return numUniqueBytes;
+  }
+
+  /*
+   *  (non-Javadoc)
+   * @see DocMaker#getCount()
+   */
+  public int getCount() {
+    return docID;
+  }
+
+  /*
+   *  (non-Javadoc)
+   * @see DocMaker#getByteCount()
+   */
+  public long getByteCount() {
+    return numBytes;
+  }
+
+  protected void addUniqueBytes (long n) {
+    numUniqueBytes += n;
+  }
+  
+  protected void addBytes (long n) {
+    numBytes += n;
+  }
+
+  /*
+   *  (non-Javadoc)
+   * @see org.apache.lucene.benchmark.byTask.feeds.DocMaker#printDocStatistics()
+   */
+  private int lastPrintedNumUniqueTexts = 0;
+  private long lastPrintedNumUniqueBytes = 0;
+  private int printNum = 0;
+  public void printDocStatistics() {
+    boolean print = false;
+    String col = "                  ";
+    StringBuffer sb = new StringBuffer();
+    String newline = System.getProperty("line.separator");
+    sb.append("------------> ").append(Format.simpleName(getClass())).append(" statistics (").append(printNum).append("): ").append(newline);
+    int nut = numUniqueTexts();
+    if (nut > lastPrintedNumUniqueTexts) {
+      print = true;
+      sb.append("total bytes of unique texts: ").append(Format.format(0,nut,col)).append(newline);
+      lastPrintedNumUniqueTexts = nut;
+    }
+    long nub = numUniqueBytes();
+    if (nub > lastPrintedNumUniqueBytes) {
+      print = true;
+      sb.append("total bytes of unique texts: ").append(Format.format(0,nub,col)).append(newline);
+      lastPrintedNumUniqueBytes = nub;
+    }
+    if (getCount()>0) {
+      print = true;
+      sb.append("num files added since last inputs reset:   ").append(Format.format(0,getCount(),col)).append(newline);
+      sb.append("total bytes added since last inputs reset: ").append(Format.format(0,getByteCount(),col)).append(newline);
+    }
+    if (print) {
+      System.out.println(sb.append(newline).toString());
+      printNum++;
+    }
+  }
+
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/SimpleQueryMaker.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/SimpleQueryMaker.java
new file mode 100644
index 0000000..d0cc328
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/SimpleQueryMaker.java
@@ -0,0 +1,113 @@
+package org.apache.lucene.benchmark.byTask.feeds;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.ArrayList;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.benchmark.byTask.utils.Config;
+import org.apache.lucene.benchmark.byTask.utils.Format;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.queryParser.QueryParser;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.BooleanClause.Occur;
+
+/**
+ * A QueryMaker that makes queries for a collection created 
+ * using {@link org.apache.lucene.benchmark.byTask.feeds.SimpleDocMaker}.
+ */
+public class SimpleQueryMaker implements QueryMaker {
+
+  private int qnum = 0;
+  private Query queries[];
+  private Config config;
+  
+  /**
+   * Prepare the queries for this test.
+   * Extending classes can overide this method for preparing different queries. 
+   * @return prepared queries.
+   * @throws Exception if canot prepare the queries.
+   */
+  protected Query[] prepareQueries() throws Exception {
+    // analyzer (default is standard analyzer)
+    Analyzer anlzr= (Analyzer) Class.forName(config.get("analyzer",
+        "org.apache.lucene.analysis.StandardAnalyzer")).newInstance(); 
+    
+    QueryParser qp = new QueryParser("body",anlzr);
+    ArrayList qq = new ArrayList();
+    Query q1 = new TermQuery(new Term("docid","doc2"));
+    qq.add(q1);
+    Query q2 = new TermQuery(new Term("body","simple"));
+    qq.add(q2);
+    BooleanQuery bq = new BooleanQuery();
+    bq.add(q1,Occur.MUST);
+    bq.add(q2,Occur.MUST);
+    qq.add(bq);
+    qq.add(qp.parse("synthetic body"));
+    qq.add(qp.parse("\"synthetic body\""));
+    qq.add(qp.parse("synthetic text"));
+    qq.add(qp.parse("\"synthetic text\""));
+    qq.add(qp.parse("\"synthetic text\"~3"));
+    qq.add(qp.parse("zoom*"));
+    qq.add(qp.parse("synth*"));
+    return (Query []) qq.toArray(new Query[0]);
+  }
+
+  public Query makeQuery() throws Exception {
+    return queries[nextQnum()];
+  }
+
+  public void setConfig(Config config) throws Exception {
+    this.config = config;
+    queries = prepareQueries();
+  }
+
+  public void resetInputs() {
+    qnum = 0;
+  }
+
+  // return next qnum
+  private synchronized int nextQnum() {
+    int res = qnum;
+    qnum = (qnum+1) % queries.length;
+    return res;
+  }
+
+  public String printQueries() {
+    String newline = System.getProperty("line.separator");
+    StringBuffer sb = new StringBuffer();
+    if (queries != null) {
+      for (int i = 0; i < queries.length; i++) {
+        sb.append(i+". "+Format.simpleName(queries[i].getClass())+" - "+queries[i].toString());
+        sb.append(newline);
+      }
+    }
+    return sb.toString();
+  }
+
+  /*
+   *  (non-Javadoc)
+   * @see org.apache.lucene.benchmark.byTask.feeds.QueryMaker#makeQuery(int)
+   */
+  public Query makeQuery(int size) throws Exception {
+    throw new Exception(this+".makeQuery(int size) is not supported!");
+  }
+
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/SimpleSloppyPhraseQueryMaker.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/SimpleSloppyPhraseQueryMaker.java
new file mode 100644
index 0000000..bfd74e8
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/SimpleSloppyPhraseQueryMaker.java
@@ -0,0 +1,65 @@
+package org.apache.lucene.benchmark.byTask.feeds;
+
+import java.util.ArrayList;
+import java.util.StringTokenizer;
+
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.PhraseQuery;
+import org.apache.lucene.search.Query;
+
+/**
+ * Create sloppy phrase queries for performance test, in an index created using simple doc maker.
+ */
+public class SimpleSloppyPhraseQueryMaker extends SimpleQueryMaker {
+
+  /* (non-Javadoc)
+   * @see org.apache.lucene.benchmark.byTask.feeds.SimpleQueryMaker#prepareQueries()
+   */
+  protected Query[] prepareQueries() throws Exception {
+    // exatract some 100 words from doc text to an array
+    String words[];
+    ArrayList w = new ArrayList();
+    StringTokenizer st = new StringTokenizer(SimpleDocMaker.DOC_TEXT);
+    while (st.hasMoreTokens() && w.size()<100) {
+      w.add(st.nextToken());
+    }
+    words = (String[]) w.toArray(new String[0]);
+
+    // create queries (that would find stuff) with varying slops
+    ArrayList queries = new ArrayList(); 
+    for (int slop=0; slop<8; slop++) {
+      for (int qlen=2; qlen<6; qlen++) {
+        for (int wd=0; wd<words.length-qlen-slop; wd++) {
+          // ordered
+          int remainedSlop = slop;
+          PhraseQuery q = new PhraseQuery();
+          q.setSlop(slop);
+          int wind = wd;
+          for (int i=0; i<qlen; i++) {
+            q.add(new Term(SimpleDocMaker.BODY_FIELD,words[wind++]));
+            if (remainedSlop>0) {
+              remainedSlop--;
+              wind++;
+            }
+          }
+          queries.add(q);
+          // reveresed
+          remainedSlop = slop;
+          q = new PhraseQuery();
+          q.setSlop(slop+2*qlen);
+          wind = wd+qlen+remainedSlop-1;
+          for (int i=0; i<qlen; i++) {
+            q.add(new Term(SimpleDocMaker.BODY_FIELD,words[wind--]));
+            if (remainedSlop>0) {
+              remainedSlop--;
+              wind--;
+            }
+          }
+          queries.add(q);
+        }
+      }
+    }
+    return (Query[]) queries.toArray(new Query[0]);
+  }
+
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/package.html b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/package.html
new file mode 100644
index 0000000..56a43e1
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/package.html
@@ -0,0 +1,6 @@
+<html>
+<body>
+Sources for benchmark inputs: documents and queries.
+</body>
+
+</html>
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/package.html b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/package.html
new file mode 100644
index 0000000..cc1b377
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/package.html
@@ -0,0 +1,480 @@
+<HTML>
+<!--
+* Copyright 2005 The Apache Software Foundation
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*
+-->
+<HEAD>
+    <TITLE>Benchmarking Lucene By Tasks</TITLE>
+</HEAD>
+<BODY>
+<DIV>
+Benchmarking Lucene By Tasks.
+<p>
+This package provides "task based" performance benchmarking of Lucene.
+One can use the predefined benchmarks, or create new ones.
+</p>
+<p>
+Contained packages:
+</p>
+
+<table border=1 cellpadding=4>
+ <tr>
+   <td><b>Package</b></td>
+   <td><b>Description</b></td>
+ </tr>
+ <tr>
+   <td><a href="stats/package-summary.html">stats</a></td>
+   <td>Statistics maintained when running benchmark tasks.</td>
+ </tr>
+ <tr>
+   <td><a href="tasks/package-summary.html">tasks</a></td>
+   <td>Benchmark tasks.</td>
+ </tr>
+ <tr>
+   <td><a href="feeds/package-summary.html">feeds</a></td>
+   <td>Sources foe benchmark inputs: documents and queries.</td>
+ </tr>
+ <tr>
+   <td><a href="utils/package-summary.html">utils</a></td>
+   <td>Utilities used for the benchmark, and for the reports.</td>
+ </tr>
+ <tr>
+   <td><a href="programmatic/package-summary.html">programmatic</a></td>
+   <td>Sample performance test written programatically.</td>
+ </tr>
+</table>
+
+<h2>Table Of Contents</h2>
+<p>
+    <ol>
+        <li><a href="#concept">Benchmarking By Tasks</a></li>
+        <li><a href="#usage">How to use</a></li>
+        <li><a href="#algorithm">Benchmark "algorithm"</a></li>
+        <li><a href="#tasks">Supported tasks/commands</a></li>
+        <li><a href="#properties">Benchmark properties</a></li>
+        <li><a href="#example">Example input algorithm and the result benchmark report.</a></li>
+    </ol>
+</p>
+<a name="concept"></a>
+<h2>Benchmarking By Tasks</h2>
+<p>
+Benchmark Lucene using task primitives.
+</p>
+
+<p>
+A benchmark is composed of some predefined tasks, allowing for creating an index, adding documents,
+optimizing, searching, generating reports, and more. A benchmark run takes an "algorithm" file
+that contains a description of the sequence of tasks making up the run, and some properties defining a few
+additional characteristics of the benchmark run.
+</p>
+
+<a name="usage"></a>
+<h2>How to use</h2>
+<p>
+Easiest way to run a benchmarks is using the predefined ant task:
+<ul>
+ <li>ant run-task
+     <br>- would run the <code>micro-standard.alg</code> "algorithm".
+ </li>
+ <li>ant run-task -Dtask.alg=conf/compound-penalty.alg
+     <br>- would run the <code>compound-penalty.alg</code> "algorithm".
+ </li>
+ <li>ant run-task -Dtask.alg=[full-path-to-your-alg-file]
+     <br>- would run the <code>your perf test</code> "algorithm".
+ </li>
+ <li>java org.apache.lucene.benchmark.byTask.programmatic.Sample
+     <br>- would run a performance test programmatically - without using an alg file.
+     This is less readable, and less convinient, but possible.
+ </li>
+</ul>
+</p>
+
+<p>
+You may find existing tasks sufficient for defining the benchmark <i>you</i> need,
+otherwise, you can extend the framework to meet your needs, as explained herein.
+</p>
+
+<p>
+Each benchmark run has a DocMaker and a QueryMaker. These two should usually match, so
+that "meaningful" queries are used for a certain collection.
+Properties defined at the header of the alg file define which "makers" should be used.
+You can also specify your own makers, implementing the DocMaker and QureyMaker interfaces.
+</p>
+
+<p>
+Benchmark .alg file contains the benchmark "algorithm". The syntax is described below.
+Within the algorithm, you can specify groups of commands, assign them names,
+specify commands that should be repeated,
+do commands in serial or in parallel,
+and also control the speed of "firing" the commands.
+</p>
+
+<p>
+This allows, for instance, to specify
+that an index should be opened for update,
+documents should be added to it one by one but not faster than 20 docs a minute,
+and, in parallel with this,
+some N queries should be searched against that index,
+again, no more than 2 queries a second.
+You can have the searches all share an index searcher,
+or have them each open its own searcher and close it afterwords.
+</p>
+
+<p>
+If the commands available for use in the algorithm do not meet your needs,
+you can add commands by adding a new task under
+org.apache.lucene.benchmark.byTask.tasks -
+you should extend the PerfTask abstract class.
+Make sure that your new task class name is suffixed by Task.
+Assume you added the class "WonderfulTask" - doing so also enables the
+command "Wonderful" to be used in the algorithm.
+</p>
+
+<a name="algorithm"></a>
+<h2>Benchmark "algorithm"</h2>
+
+<p>
+The following is an informal description of the supported syntax.
+</p>
+
+<ol>
+ <li>
+ <b>Measuring</b>: When a command is executed, statistics for the elapsed execution time and memory consumption are collected.
+ At any time, those statistics can be printed, using one of the available ReportTasks.
+ </li>
+ <li>
+ <b>Comments</b> start with '<font color="#FF0066">#</font>'.
+ </li>
+ <li>
+ <b>Serial</b> sequences are enclosed within '<font color="#FF0066">{ }</font>'.
+ </li>
+ <li>
+ <b>Parallel</b> sequences are enclosed within '<font color="#FF0066">[ ]</font>'
+ </li>
+ <li>
+ <b>Sequence naming:</b> To name a sequence, put '<font color="#FF0066">"name"</font>' just after '<font color="#FF0066">{</font>' or '<font color="#FF0066">[</font>'.
+ <br>Example - <font color="#FF0066">{ "ManyAdds" AddDoc } : 1000000</font> - would
+ name the sequence of 1M add docs "ManyAdds", and this name would later appear in statistic reports.
+ If you don't specify a name for a sequence, it is given one: you can see it as the
+ algorithm is printed just before benchmark execution starts.
+ </li>
+ <li>
+ <b>Repeating</b>:
+ To repeat sequence tasks N times, add '<font color="#FF0066">: N</font>' just after the
+ sequence closing tag - '<font color="#FF0066">}</font>' or '<font color="#FF0066">]</font>' or '<font color="#FF0066">></font>'.
+ <br>Example -  <font color="#FF0066">[ AddDoc ] : 4</font>  - would do 4 addDoc in parallel, spawning 4 threads at once.
+ <br>Example -  <font color="#FF0066">[ AddDoc AddDoc ] : 4</font>  - would do 8 addDoc in parallel, spawning 8 threads at once.
+ <br>Example -  <font color="#FF0066">{ AddDoc } : 30</font> - would do addDoc 30 times in a row.
+ <br>Example -  <font color="#FF0066">{ AddDoc AddDoc } : 30</font> - would do addDoc 60 times in a row.
+ </li>
+ <li>
+ <b>Command parameter</b>: a command can take a single parameter.
+ If the certain command does not support a parameter, or if the parameter is of the wrong type,
+ reading the algorithm will fail with an exception and the test would not start.
+ Currently only AddDoc supports a (numeric) parameter, which indicates the required size of added document.
+ If the DocMaker implementation used in the test does not support makeDoc(size), an exception would be thrown and the test would fail.
+ <br>Example - <font color="#FF0066">AddDoc(2000)</font> - would add a document of size 2000 (~bytes).
+ <br>See conf/task-sample.alg for how this can be used, for instance, to check which is faster, adding
+ many smaller documents, or few larger documents.
+ Next candidates for supporting a parameter may be the Search tasks, for controlling the qurey size.
+ </li>
+ <li>
+ <b>Statistic recording elimination</b>: - a sequence can also end with '<font color="#FF0066">></font>',
+ in which case child tasks would not store their statistics.
+ This can be useful to avoid exploding stats data, for adding say 1M docs.
+ <br>Example - <font color="#FF0066">{ "ManyAdds" AddDoc > : 1000000</font> -
+ would add million docs, measure that total, but not save stats for each addDoc.
+ <br>Notice that the granularity of System.currentTimeMillis() (which is used here) is system dependant,
+ and in some systems an operation that takes 5 ms to complete may show 0 ms latency time in performance measurements.
+ Therefore it is sometimes more accurate to look at the elapsed time of a larger sequence, as demonstrated here.
+ </li>
+ <li>
+ <b>Rate</b>:
+ To set a rate (ops/sec or ops/min) for a sequence, add '<font color="#FF0066">: N : R</font>' just after sequence closing tag.
+ This would specify repetition of N with rate of R operations/sec.
+ Use '<font color="#FF0066">R/sec</font>' or '<font color="#FF0066">R/min</font>'
+ to explicitely specify that the rate is per second or per minute.
+ The default is per second,
+ <br>Example -  <font color="#FF0066">[ AddDoc ] : 400 : 3</font> - would do 400 addDoc in parallel, starting up to 3 threads per second.
+ <br>Example -  <font color="#FF0066">{ AddDoc } : 100 : 200/min</font> - would do 100 addDoc serially,
+ waiting before starting next add, if otherwise rate would exceed 200 adds/min.
+ </li>
+ <li>
+ <b>Command names</b>: Each class "AnyNameTask" in the package org.apache.lucene.benchmark.byTask.tasks,
+ that extends PerfTask, is supported as command "AnyName" that can be
+ used in the benchmark "algorithm" description.
+ This allows to add new commands by just adding such classes.
+ </li>
+</ol>
+
+
+<a name="tasks"></a>
+<h2>Supported tasks/commands</h2>
+
+<p>
+Existing tasks can be divided into a few groups:
+regular index/search work tasks, report tasks, and control tasks.
+</p>
+
+<ol>
+
+ <li>
+ <b>Report tasks</b>: There are a few Report commands for generating reports.
+ Only task runs that were completed are reported.
+ (The 'Report tasks' themselves are not measured and not reported.)
+ <ul>
+             <li>
+            <font color="#FF0066">RepAll</font> - all (completed) task runs.
+            </li>
+            <li>
+            <font color="#FF0066">RepSumByName</font> - all statistics, aggregated by name. So, if AddDoc was executed 2000 times,
+            only 1 report line would be created for it, aggregating all those 2000 statistic records.
+            </li>
+            <li>
+            <font color="#FF0066">RepSelectByPref &nbsp; prefixWord</font> - all records for tasks whose name start with <font color="#FF0066">prefixWord</font>.
+            </li>
+            <li>
+            <font color="#FF0066">RepSumByPref &nbsp; prefixWord</font> - all records for tasks whose name start with <font color="#FF0066">prefixWord</font>,
+            aggregated by their full task name.
+            </li>
+            <li>
+            <font color="#FF0066">RepSumByNameRound</font> - all statistics, aggregated by name and by <font color="#FF0066">Round</font>.
+            So, if AddDoc was executed 2000 times in each of 3 <font color="#FF0066">rounds</font>, 3 report lines would be created for it,
+            aggregating all those 2000 statistic records in each round. See more about rounds in the <font color="#FF0066">NewRound</font> command description below.
+            </li>
+            <li>
+            <font color="#FF0066">RepSumByPrefRound &nbsp; prefixWord</font> - similar to <font color="#FF0066">RepSumByNameRound</font>,
+            just that only tasks whose name starts with <font color="#FF0066">prefixWord</font> are included.
+            </li>
+ </ul>
+ If needed, additional reports can be added by extending the abstract class ReportTask, and by
+ manipulating the statistics data in Points and TaskStats.
+ </li>
+
+ <li><b>Control tasks</b>: Few of the tasks control the benchmark algorithm all over:
+ <ul>
+     <li>
+     <font color="#FF0066">ClearStats</font> - clears the entire statistics.
+     Further reports would only include task runs that would start after this call.
+     </li>
+     <li>
+     <font color="#FF0066">NewRound</font> - virtually start a new round of performance test.
+     Although this command can be placed anywhere, it mostly makes sense at the end of an outermost sequence.
+     <br>This increments a global "round counter". All task runs that would start now would
+     record the new, updated round counter as their round number. This would appear in reports.
+     In particular, see <font color="#FF0066">RepSumByNameRound</font> above.
+     <br>An additional effect of NewRound, is that numeric and boolean properties defined in the
+     .properties file as a sequence of values, e.g. <font color="#FF0066">merge.factor=mrg:10:100:10:100</font> would
+     increment (cyclic) to the next value.
+     Note: this would also be reflected in the reports, in this case under a column that would be named "mrg".
+     </li>
+     <li>
+     <font color="#FF0066">ResetInputs</font> - DocMaker and the various QueryMakers
+     would reset their counters to start.
+     The way these Maker interfaces work, each call for makeDocument()
+     or makeQuery() creates the next document or query
+     that it "knows" to create.
+     If that pool is "exhausted", the "maker" start over again. The resetInpus command
+     therefore allows to make the rounds comparable.
+     It is therefore useful to invoke ResetInputs together with NewRound.
+     </li>
+     <li>
+     <font color="#FF0066">ResetSystemErase</font> - reset all index and input data and call gc.
+     Does NOT reset statistics. This contains ResetInputs.
+     All writers/readers are nullified, deleted, closed.
+     Index is erased.
+     Directory is erased.
+     You would have to call CreateIndex once this was called...
+     </li>
+     <li>
+     <font color="#FF0066">ResetSystemSoft</font> -  reset all index and input data and call gc.
+     Does NOT reset statistics. This contains ResetInputs.
+     All writers/readers are nullified, closed.
+     Index is NOT erased.
+     Directory is NOT erased.
+     This is useful for testing performance on an existing index, for instance if the construction of a large index
+     took a very long time and now you would to test its search or update performance.
+     </li>
+ </ul>
+ </li>
+
+ <li>
+ Other existing tasks are quite straightforward and would just be briefly described here.
+ <ul>
+     <li>
+     <font color="#FF0066">CreateIndex</font> and <font color="#FF0066">OpenIndex</font> both leave the index open for later update operations.
+     <font color="#FF0066">CloseIndex</font> would close it.
+     </li>
+     <li>
+     <font color="#FF0066">OpenReader</font>, similarly, would leave an index reader open for later search operations.
+     But this have further semantics.
+     If a Read operation is performed, and an open reader exists, it would be used.
+     Otherwise, the read operation would open its own reader and close it when the read operation is done.
+     This allows testing various scenarios - sharing a reader, searching with "cold" reader, with "warmed" reader, etc.
+     The read operations affected by this are: <font color="#FF0066">Warm</font>,
+     <font color="#FF0066">Search</font>, <font color="#FF0066">SearchTrav</font> (search and traverse),
+     and <font color="#FF0066">SearchTravRet</font> (search and traverse and retrieve).
+     Notice that each of the 3 search task types maintains its own queryMaker instance.
+     </li>
+ </ul
+ </li>
+ </ol>
+
+<a name="properties"></a>
+<h2>Benchmark properties</h2>
+
+<p>
+Properties are read from the header of the .alg file, and
+define several parameters of the performance test.
+As mentioned above for the <font color="#FF0066">NewRound</font> task,
+numeric and boolean properties that are defined as a sequence
+of values, e.g. <font color="#FF0066">merge.factor=mrg:10:100:10:100</font>
+would increment (cyclic) to the next value, when NewRound is called, and would also
+appear as a named column in the reports (column name would be "mrg" in this example).
+</p>
+
+<p>
+Some of the currently defined properties are:
+</p>
+
+<ol>
+    <li>
+    <font color="#FF0066">analyzer</font> - full class name for the analyzer to use.
+    Same analyzer would be used in the entire test.
+    </li>
+
+    <li>
+    <font color="#FF0066">directory</font> - valid values are FSDirectory and RAMDirectory.
+    This tells which directory to use for the performance test.
+    </li>
+
+    <li>
+    <b>Index work parameters</b>:
+    Multi int/boolean values would be iterated with calls to NewRound.
+    There would be also added as columns in the reports, first string in the
+    sequence is the column name.
+    (Make sure it is no shorter than any value in the sequence).
+    <ul>
+        <li><font color="#FF0066">max.buffered</font>
+        <br>Example: buffered=buf.10.10.100.100 -
+        this would define using maxBufferedDocs of 10 in iterations 0 and 1,
+        and 100 in iterations 2 and 3.
+        </li>
+        <li>
+        <font color="#FF0066">merge.factor</font> - which
+        merge factor to use.
+        </li>
+        <li>
+        <font color="#FF0066">compound</font> - whether the index is
+        using the compound format or not. Valid values are "true" and "false".
+        </li>
+    </ul>
+</ol>
+
+<p>
+For additional defined properties see the *.alg files under conf.
+</p>
+
+<a name="example"></a>
+<h2>Example input algorithm and the result benchmark report</h2>
+<p>
+The following example is in conf/sample.alg:
+<pre>
+<font color="#003333"># --------------------------------------------------------
+#
+# Sample: what is the effect of doc size on indexing time?
+#
+# There are two parts in this test:
+# - PopulateShort adds 2N documents of length  L
+# - PopulateLong  adds  N documents of length 2L
+# Which one would be faster?
+# The comparison is done twice.
+#
+# --------------------------------------------------------
+
+<font color="#990066"># -------------------------------------------------------------------------------------
+# multi val params are iterated by NewRound's, added to reports, start with column name.
+merge.factor=mrg:10:20
+max.buffered=buf:100:1000
+compound=true
+
+analyzer=org.apache.lucene.analysis.standard.StandardAnalyzer
+directory=FSDirectory
+
+doc.stored=true
+doc.tokenized=true
+doc.term.vector=false
+doc.add.log.step=500
+
+docs.dir=reuters-out
+
+doc.maker=org.apache.lucene.benchmark.byTask.feeds.SimpleDocMaker
+
+query.maker=org.apache.lucene.benchmark.byTask.feeds.SimpleQueryMaker
+
+# task at this depth or less would print when they start
+task.max.depth.log=2
+
+log.queries=false
+# -------------------------------------------------------------------------------------</font>
+<font color="#3300FF">{
+
+    { "PopulateShort"
+        CreateIndex
+        { AddDoc(4000) > : 20000
+        Optimize
+        CloseIndex
+    >
+
+    ResetSystemErase
+
+    { "PopulateLong"
+        CreateIndex
+        { AddDoc(8000) > : 10000
+        Optimize
+        CloseIndex
+    >
+
+    ResetSystemErase
+
+    NewRound
+
+} : 2
+
+RepSumByName
+RepSelectByPref Populate
+</font>
+</pre>
+</p>
+
+<p>
+The command line for running this sample:
+<br><code>ant run-task -Dtask.alg=conf/sample.alg</code>
+</p>
+
+<p>
+The output report from running this test contains the following:
+<pre>
+Operation     round mrg  buf   runCnt   recsPerRun        rec/s  elapsedSec    avgUsedMem    avgTotalMem
+PopulateShort     0  10  100        1        20003        119.6      167.26    12,959,120     14,241,792
+PopulateLong -  - 0  10  100 -  -   1 -  -   10003 -  -  - 74.3 -  - 134.57 -  17,085,208 -   20,635,648
+PopulateShort     1  20 1000        1        20003        143.5      139.39    63,982,040     94,756,864
+PopulateLong -  - 1  20 1000 -  -   1 -  -   10003 -  -  - 77.0 -  - 129.92 -  87,309,608 -  100,831,232
+</pre>
+</p>
+</DIV>
+<DIV>&nbsp;</DIV>
+</BODY>
+</HTML>
\ No newline at end of file
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/programmatic/Sample.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/programmatic/Sample.java
new file mode 100644
index 0000000..09118e7
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/programmatic/Sample.java
@@ -0,0 +1,81 @@
+package org.apache.lucene.benchmark.byTask.programmatic;
+
+import java.io.IOException;
+import java.util.Properties;
+
+import org.apache.lucene.benchmark.byTask.PerfRunData;
+import org.apache.lucene.benchmark.byTask.tasks.AddDocTask;
+import org.apache.lucene.benchmark.byTask.tasks.CloseIndexTask;
+import org.apache.lucene.benchmark.byTask.tasks.CreateIndexTask;
+import org.apache.lucene.benchmark.byTask.tasks.RepSumByNameTask;
+import org.apache.lucene.benchmark.byTask.tasks.TaskSequence;
+import org.apache.lucene.benchmark.byTask.utils.Config;
+
+/**
+ * Sample performance test written programatically - no algorithm file is needed here.
+ */
+public class Sample {
+
+  /**
+   * @param args
+   * @throws Exception 
+   * @throws IOException 
+   */
+  public static void main(String[] args) throws Exception {
+    Properties p = initProps();
+    Config conf = new Config(p);
+    PerfRunData runData = new PerfRunData(conf);
+    
+    // 1. top sequence
+    TaskSequence top = new TaskSequence(runData,null,null,false); // top level, not parralel
+    
+    // 2. task to create the index
+    CreateIndexTask create = new CreateIndexTask(runData);
+    top.addTask(create);
+    
+    // 3. task seq to add 500 docs (order matters - top to bottom - add seq to top, only then add to seq)
+    TaskSequence seq1 = new TaskSequence(runData,"AddDocs",top,false);
+    seq1.setRepetitions(500);
+    seq1.setNoChildReport();
+    top.addTask(seq1);
+
+    // 4. task to add the doc
+    AddDocTask addDoc = new AddDocTask(runData);
+    //addDoc.setParams("1200"); // doc size limit if supported
+    seq1.addTask(addDoc); // order matters 9see comment above)
+
+    // 5. task to close the index
+    CloseIndexTask close = new CloseIndexTask(runData);
+    top.addTask(close);
+
+    // task to report
+    RepSumByNameTask rep = new RepSumByNameTask(runData);
+    top.addTask(rep);
+    // execute
+    top.doLogic();
+  }
+
+  // Sample programmatic settings. Could also read from file.
+  private static Properties initProps() {
+    Properties p = new Properties();
+    p.setProperty ( "task.max.depth.log"  , "3" );
+    p.setProperty ( "max.buffered"        , "buf:10:10:100:100:10:10:100:100" );
+    p.setProperty ( "doc.maker"           , "org.apache.lucene.benchmark.byTask.feeds.ReutersDocMaker" );
+    p.setProperty ( "doc.add.log.step"    , "2000" );
+    p.setProperty ( "doc.delete.log.step" , "2000" );
+    p.setProperty ( "doc.delete.step"     , "8" );
+    p.setProperty ( "analyzer"            , "org.apache.lucene.analysis.standard.StandardAnalyzer" );
+    p.setProperty ( "doc.term.vector"     , "false" );
+    p.setProperty ( "directory"           , "FSDirectory" );
+    p.setProperty ( "query.maker"         , "org.apache.lucene.benchmark.byTask.feeds.ReutersQueryMaker" );
+    p.setProperty ( "doc.stored"          , "true" );
+    p.setProperty ( "docs.dir"            , "reuters-out" );
+    p.setProperty ( "compound"            , "cmpnd:true:true:true:true:false:false:false:false" );
+    p.setProperty ( "doc.tokenized"       , "true" );
+    p.setProperty ( "merge.factor"        , "mrg:10:100:10:100:10:100:10:100" );
+    return p;
+  }
+  
+  
+
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/programmatic/package.html b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/programmatic/package.html
new file mode 100644
index 0000000..c5b62ed
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/programmatic/package.html
@@ -0,0 +1,5 @@
+<html>
+<body>
+Sample performance test written programatically - no algorithm file is needed here.
+</body>
+</html>
\ No newline at end of file
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/stats/Points.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/stats/Points.java
new file mode 100644
index 0000000..a675956
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/stats/Points.java
@@ -0,0 +1,343 @@
+package org.apache.lucene.benchmark.byTask.stats;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+
+import org.apache.lucene.benchmark.byTask.tasks.PerfTask;
+import org.apache.lucene.benchmark.byTask.utils.Config;
+import org.apache.lucene.benchmark.byTask.utils.Format;
+
+
+/**
+ * Test run data points collected as the test proceeds.
+ */
+public class Points {
+
+  private Config config;
+  
+  private static final String newline = System.getProperty("line.separator");
+  
+  // stat points ordered by their start time. 
+  // for now we collect points as TaskStats objects.
+  // later might optimize to collect only native data.
+  private ArrayList points = new ArrayList();
+
+  private int nextTaskRunNum = 0;
+
+  /**
+   * Get a textual summary of the benchmark results, average from all test runs.
+   */
+  static final String OP =          "Operation  ";
+  static final String ROUND =       " round";
+  static final String RUNCNT =      "   runCnt";
+  static final String RECCNT =      "   recsPerRun";
+  static final String RECSEC =      "        rec/s";
+  static final String ELAPSED =     "  elapsedSec";
+  static final String USEDMEM =     "    avgUsedMem";
+  static final String TOTMEM =      "    avgTotalMem";
+  static final String COLS[] = {
+      RUNCNT,
+      RECCNT,
+      RECSEC,
+      ELAPSED,
+      USEDMEM,
+      TOTMEM
+  };
+
+  /**
+   * Create a Points statistics object. 
+   */
+  public Points (Config config) {
+    this.config = config;
+  }
+
+  private String tableTitle (String longestOp) {
+    StringBuffer sb = new StringBuffer();
+    sb.append(Format.format(OP,longestOp));
+    sb.append(ROUND);
+    sb.append(config.getColsNamesForValsByRound());
+    for (int i = 0; i < COLS.length; i++) {
+      sb.append(COLS[i]);
+    }
+    return sb.toString(); 
+  }
+  
+  /**
+   * Report detailed statistics as a string
+   * @return the report
+   */
+  public Report reportAll() {
+    String longestOp = longestOp(points);
+    boolean first = true;
+    StringBuffer sb = new StringBuffer();
+    sb.append(tableTitle(longestOp));
+    sb.append(newline);
+    int reported = 0;
+    for (Iterator it = points.iterator(); it.hasNext();) {
+      TaskStats stat = (TaskStats) it.next();
+      if (stat.getElapsed()>=0) { // consider only tasks that ended
+        if (!first) {
+          sb.append(newline);
+        }
+        first = false;
+        String line = taskReportLine(longestOp, stat);
+        reported++;
+        if (points.size()>2&& reported%2==0) {
+          line = line.replaceAll("   "," - ");
+        }
+        sb.append(line);
+      }
+    }
+    String reptxt = (reported==0 ? "No Matching Entries Were Found!" : sb.toString());
+    return new Report(reptxt,reported,reported,points.size());
+  }
+
+  /**
+   * Report statistics as a string, aggregate for tasks named the same.
+   * @return the report
+   */
+  public Report reportSumByName() {
+    // aggregate by task name
+    int reported = 0;
+    LinkedHashMap p2 = new LinkedHashMap();
+    for (Iterator it = points.iterator(); it.hasNext();) {
+      TaskStats stat1 = (TaskStats) it.next();
+      if (stat1.getElapsed()>=0) { // consider only tasks that ended
+        reported++;
+        String name = stat1.getTask().getName();
+        TaskStats stat2 = (TaskStats) p2.get(name);
+        if (stat2 == null) {
+          try {
+            stat2 = (TaskStats) stat1.clone();
+          } catch (CloneNotSupportedException e) {
+            throw new RuntimeException(e);
+          }
+          p2.put(name,stat2);
+        } else {
+          stat2.add(stat1);
+        }
+      }
+    }
+    // now generate report from secondary list p2    
+    return genReportFromList(reported, p2);
+  }
+
+  /**
+   * Report statistics as a string, aggregate for tasks named the same, and from the same round.
+   * @return the report
+   */
+  public Report reportSumByNameRound() {
+    // aggregate by task name and round
+    LinkedHashMap p2 = new LinkedHashMap();
+    int reported = 0;
+    for (Iterator it = points.iterator(); it.hasNext();) {
+      TaskStats stat1 = (TaskStats) it.next();
+      if (stat1.getElapsed()>=0) { // consider only tasks that ended
+        reported++;
+        String name = stat1.getTask().getName();
+        String rname = stat1.getRound()+"."+name; // group by round
+        TaskStats stat2 = (TaskStats) p2.get(rname);
+        if (stat2 == null) {
+          try {
+            stat2 = (TaskStats) stat1.clone();
+          } catch (CloneNotSupportedException e) {
+            throw new RuntimeException(e);
+          }
+          p2.put(rname,stat2);
+        } else {
+          stat2.add(stat1);
+        }
+      }
+    }
+    // now generate report from secondary list p2    
+    return genReportFromList(reported, p2);
+  }
+  
+  private String longestOp(Collection c) {
+    String longest = OP;
+    for (Iterator it = c.iterator(); it.hasNext();) {
+      TaskStats stat = (TaskStats) it.next();
+      if (stat.getElapsed()>=0) { // consider only tasks that ended
+        String name = stat.getTask().getName();
+        if (name.length() > longest.length()) {
+          longest = name;
+        }
+      }
+    }
+    return longest;
+  }
+
+  private String taskReportLine(String longestOp, TaskStats stat) {
+    PerfTask task = stat.getTask();
+    StringBuffer sb = new StringBuffer();
+    sb.append(Format.format(task.getName(), longestOp));
+    String round = (stat.getRound()>=0 ? ""+stat.getRound() : "-");
+    sb.append(Format.formatPaddLeft(round, ROUND));
+    sb.append(config.getColsValuesForValsByRound(stat.getRound()));
+    sb.append(Format.format(stat.getNumRuns(), RUNCNT)); 
+    sb.append(Format.format(stat.getCount() / stat.getNumRuns(), RECCNT));
+    long elapsed = (stat.getElapsed()>0 ? stat.getElapsed() : 1); // assume at least 1ms
+    sb.append(Format.format(1,(float) (stat.getCount() * 1000.0 / elapsed), RECSEC));
+    sb.append(Format.format(2, (float) stat.getElapsed() / 1000, ELAPSED));
+    sb.append(Format.format(0, (float) stat.getMaxUsedMem() / stat.getNumRuns(), USEDMEM)); 
+    sb.append(Format.format(0, (float) stat.getMaxTotMem() / stat.getNumRuns(), TOTMEM));
+    return sb.toString();
+  }
+
+  public Report reportSumByPrefix(String prefix) {
+    // aggregate by task name
+    int reported = 0;
+    LinkedHashMap p2 = new LinkedHashMap();
+    for (Iterator it = points.iterator(); it.hasNext();) {
+      TaskStats stat1 = (TaskStats) it.next();
+      if (stat1.getElapsed()>=0 && stat1.getTask().getName().startsWith(prefix)) { // only ended tasks with proper name
+        reported++;
+        String name = stat1.getTask().getName();
+        TaskStats stat2 = (TaskStats) p2.get(name);
+        if (stat2 == null) {
+          try {
+            stat2 = (TaskStats) stat1.clone();
+          } catch (CloneNotSupportedException e) {
+            throw new RuntimeException(e);
+          }
+          p2.put(name,stat2);
+        } else {
+          stat2.add(stat1);
+        }
+      }
+    }
+    // now generate report from secondary list p2    
+    return genReportFromList(reported, p2);
+  }
+  
+  public Report reportSumByPrefixRound(String prefix) {
+    // aggregate by task name and by round
+    int reported = 0;
+    LinkedHashMap p2 = new LinkedHashMap();
+    for (Iterator it = points.iterator(); it.hasNext();) {
+      TaskStats stat1 = (TaskStats) it.next();
+      if (stat1.getElapsed()>=0 && stat1.getTask().getName().startsWith(prefix)) { // only ended tasks with proper name
+        reported++;
+        String name = stat1.getTask().getName();
+        String rname = stat1.getRound()+"."+name; // group by round
+        TaskStats stat2 = (TaskStats) p2.get(rname);
+        if (stat2 == null) {
+          try {
+            stat2 = (TaskStats) stat1.clone();
+          } catch (CloneNotSupportedException e) {
+            throw new RuntimeException(e);
+          }
+          p2.put(rname,stat2);
+        } else {
+          stat2.add(stat1);
+        }
+      }
+    }
+    // now generate report from secondary list p2    
+    return genReportFromList(reported, p2);
+  }
+
+  private Report genReportFromList(int reported, LinkedHashMap p2) {
+    String longetOp = longestOp(p2.values());
+    boolean first = true;
+    StringBuffer sb = new StringBuffer();
+    sb.append(tableTitle(longetOp));
+    sb.append(newline);
+    int lineNum = 0;
+    for (Iterator it = p2.values().iterator(); it.hasNext();) {
+      TaskStats stat = (TaskStats) it.next();
+      if (!first) {
+        sb.append(newline);
+      }
+      first = false;
+      String line = taskReportLine(longetOp,stat);
+      lineNum++;
+      if (p2.size()>2&& lineNum%2==0) {
+        line = line.replaceAll("   "," - ");
+      }
+      sb.append(line);
+    }
+    String reptxt = (reported==0 ? "No Matching Entries Were Found!" : sb.toString());
+    return new Report(reptxt,p2.size(),reported,points.size());
+  }
+
+  public Report reportSelectByPrefix(String prefix) {
+    String longestOp = longestOp(points);
+    boolean first = true;
+    StringBuffer sb = new StringBuffer();
+    sb.append(tableTitle(longestOp));
+    sb.append(newline);
+    int reported = 0;
+    for (Iterator it = points.iterator(); it.hasNext();) {
+      TaskStats stat = (TaskStats) it.next();
+      if (stat.getElapsed()>=0 && stat.getTask().getName().startsWith(prefix)) { // only ended tasks with proper name
+        reported++;
+        if (!first) {
+          sb.append(newline);
+        }
+        first = false;
+        String line = taskReportLine(longestOp,stat);
+        if (points.size()>2&& reported%2==0) {
+          line = line.replaceAll("   "," - ");
+        }
+        sb.append(line);
+      }
+    }
+    String reptxt = (reported==0 ? "No Matching Entries Were Found!" : sb.toString());
+    return new Report(reptxt,reported,reported, points.size());
+  }
+
+  /**
+   * Mark that a task is starting. 
+   * Create a task stats for it and store it as a point.
+   * @param task the starting task.
+   * @return the new task stats created for the starting task.
+   */
+  public synchronized TaskStats markTaskStart (PerfTask task, int round) {
+    TaskStats stats = new TaskStats(task, nextTaskRunNum(), round);
+    points.add(stats);
+    return stats;
+  }
+  
+  // return next task num
+  private synchronized int nextTaskRunNum() {
+    return nextTaskRunNum++;
+  }
+  
+  /**
+   * mark the end of a task
+   */
+  public synchronized void markTaskEnd (TaskStats stats, int count) {
+    int numParallelTasks = nextTaskRunNum - 1 - stats.getTaskRunNum();
+    // note: if the stats were cleared, might be that this stats object is 
+    // no longer in points, but this is just ok.
+    stats.markEnd(numParallelTasks, count);
+  }
+
+  /**
+   * Clear all data, prepare for more tests.
+   */
+  public void clearData() {
+    points.clear();
+  }
+
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/stats/Report.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/stats/Report.java
new file mode 100644
index 0000000..510a34c
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/stats/Report.java
@@ -0,0 +1,64 @@
+package org.apache.lucene.benchmark.byTask.stats;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Textual report of current statistics.
+ */
+public class Report {
+
+  private String text;
+  private int size;
+  private int outOf;
+  private int reported;
+
+  Report (String text, int size, int reported, int outOf) {
+    this.text = text;
+    this.size = size;
+    this.reported = reported;
+    this.outOf = outOf;
+  }
+
+  /**
+   * Returns total number of stats points when this report was created.
+   */
+  public int getOutOf() {
+    return outOf;
+  }
+
+  /**
+   * Returns number of lines in the reoprt.
+   */
+  public int getSize() {
+    return size;
+  }
+
+  /**
+   * Returns the report text.
+   */
+  public String getText() {
+    return text;
+  }
+
+  /**
+   * Returns number of stats points represented in this report.
+   */
+  public int getReported() {
+    return reported;
+  }
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/stats/TaskStats.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/stats/TaskStats.java
new file mode 100644
index 0000000..40d5ef3
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/stats/TaskStats.java
@@ -0,0 +1,192 @@
+package org.apache.lucene.benchmark.byTask.stats;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.benchmark.byTask.tasks.PerfTask;
+
+/**
+ * Statistics for a task run. 
+ * <br>The same task can run more than once, but, if that task records statistics, 
+ * each run would create its own TaskStats.
+ */
+public class TaskStats implements Cloneable {
+
+  /** task for which data was collected */
+  private PerfTask task; 
+
+  /** round in which task run started */
+  private int round;
+
+  /** task start time */
+  private long start;
+  
+  /** task elapsed time.  elapsed >= 0 indicates run completion! */
+  private long elapsed = -1;
+  
+  /** max tot mem during task */
+  private long maxTotMem;
+  
+  /** max used mem during task */
+  private long maxUsedMem;
+  
+  /** serial run number of this task run in the perf run */
+  private int taskRunNum;
+  
+  /** number of other tasks that started to run while this task was still running */ 
+  private int numParallelTasks;
+  
+  /** number of work items done by this task.
+   * For indexing that can be number of docs added.
+   * For warming that can be number of scanned items, etc. 
+   * For repeating tasks, this is a sum over repetitions.
+   */
+  private int count;
+
+  /** Number of similar tasks aggregated into this record.   
+   * Used when summing up on few runs/instances of similar tasks.
+   */
+  private int numRuns = 1;
+  
+  /**
+   * Create a run data for a task that is starting now.
+   * To be called from Points.
+   */
+  TaskStats (PerfTask task, int taskRunNum, int round) {
+    this.task = task;
+    this.taskRunNum = taskRunNum;
+    this.round = round;
+    maxTotMem = Runtime.getRuntime().totalMemory();
+    maxUsedMem = maxTotMem - Runtime.getRuntime().freeMemory();
+    start = System.currentTimeMillis();
+  }
+  
+  /**
+   * mark the end of a task
+   */
+  void markEnd (int numParallelTasks, int count) {
+    elapsed = System.currentTimeMillis() - start;
+    long totMem = Runtime.getRuntime().totalMemory();
+    if (totMem > maxTotMem) {
+      maxTotMem = totMem;
+    }
+    long usedMem = totMem - Runtime.getRuntime().freeMemory();
+    if (usedMem > maxUsedMem) {
+      maxUsedMem = usedMem;
+    }
+    this.numParallelTasks = numParallelTasks;
+    this.count = count;
+  }
+
+  /**
+   * @return the taskRunNum.
+   */
+  public int getTaskRunNum() {
+    return taskRunNum;
+  }
+
+  /* (non-Javadoc)
+   * @see java.lang.Object#toString()
+   */
+  public String toString() {
+    StringBuffer res = new StringBuffer(task.getName());
+    res.append(" ");
+    res.append(count);
+    res.append(" ");
+    res.append(elapsed);
+    return res.toString();
+  }
+
+  /**
+   * @return Returns the count.
+   */
+  public int getCount() {
+    return count;
+  }
+
+  /**
+   * @return elapsed time.
+   */
+  public long getElapsed() {
+    return elapsed;
+  }
+
+  /**
+   * @return Returns the maxTotMem.
+   */
+  public long getMaxTotMem() {
+    return maxTotMem;
+  }
+
+  /**
+   * @return Returns the maxUsedMem.
+   */
+  public long getMaxUsedMem() {
+    return maxUsedMem;
+  }
+
+  /**
+   * @return Returns the numParallelTasks.
+   */
+  public int getNumParallelTasks() {
+    return numParallelTasks;
+  }
+
+  /**
+   * @return Returns the task.
+   */
+  public PerfTask getTask() {
+    return task;
+  }
+
+  /**
+   * @return Returns the numRuns.
+   */
+  public int getNumRuns() {
+    return numRuns;
+  }
+
+  /**
+   * Add data from another stat, for aggregation
+   * @param stat2 the added stat data.
+   */
+  public void add(TaskStats stat2) {
+    numRuns += stat2.getNumRuns();
+    elapsed += stat2.getElapsed();
+    maxTotMem += stat2.getMaxTotMem();
+    maxUsedMem += stat2.getMaxUsedMem();
+    count += stat2.getCount();
+    if (round != stat2.round) {
+      round = -1; // no meaning if agregating tasks of different ruond. 
+    }
+  }
+
+  /* (non-Javadoc)
+   * @see java.lang.Object#clone()
+   */
+  protected Object clone() throws CloneNotSupportedException {
+    return super.clone();
+  }
+
+  /**
+   * @return the round number.
+   */
+  int getRound() {
+    return round;
+  }
+  
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/stats/package.html b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/stats/package.html
new file mode 100644
index 0000000..e9e4c9d
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/stats/package.html
@@ -0,0 +1,5 @@
+<html>
+<body>
+  Statistics maintained when running benchmark tasks.
+</body>
+</html>
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/AddDocTask.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/AddDocTask.java
new file mode 100644
index 0000000..d660a7d
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/AddDocTask.java
@@ -0,0 +1,88 @@
+package org.apache.lucene.benchmark.byTask.tasks;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.benchmark.byTask.PerfRunData;
+import org.apache.lucene.benchmark.byTask.feeds.DocMaker;
+import org.apache.lucene.document.Document;
+
+
+/**
+ * Add a document, optionally with of a cetrain size.
+ * Other side effects: none.
+ */
+public class AddDocTask extends PerfTask {
+
+  public AddDocTask(PerfRunData runData) {
+    super(runData);
+  }
+
+  private static int logStep = -1;
+  private int docSize = 0;
+  
+  // volatile data passed between setup(), doLogic(), tearDown().
+  private Document doc = null;
+  
+  /*
+   *  (non-Javadoc)
+   * @see PerfTask#setup()
+   */
+  public void setup() throws Exception {
+    super.setup();
+    DocMaker docMaker = getRunData().getDocMaker();
+    if (docSize > 0) {
+      doc = docMaker.makeDocument(docSize);
+    } else {
+      doc = docMaker.makeDocument();
+    }
+  }
+
+  /* (non-Javadoc)
+   * @see PerfTask#tearDown()
+   */
+  public void tearDown() throws Exception {
+    DocMaker docMaker = getRunData().getDocMaker();
+    log(docMaker.getCount());
+    doc = null;
+    super.tearDown();
+  }
+
+  public int doLogic() throws Exception {
+    getRunData().getIndexWriter().addDocument(doc);
+    return 1;
+  }
+
+  private void log (int count) {
+    if (logStep<0) {
+      // avoid sync although race possible here
+      logStep = getRunData().getConfig().get("doc.add.log.step",500);
+    }
+    if (logStep>0 && (count%logStep)==0) {
+      System.out.println("--> processed "+count+" docs");
+    }
+  }
+
+  /**
+   * Set the params (docSize only)
+   * @param params docSize, or 0 for no limit.
+   */
+  public void setParams(String params) {
+    super.setParams(params);
+    docSize = (int) Float.parseFloat(params); 
+  }
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ClearStatsTask.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ClearStatsTask.java
new file mode 100644
index 0000000..592f2ef
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ClearStatsTask.java
@@ -0,0 +1,44 @@
+package org.apache.lucene.benchmark.byTask.tasks;
+
+import org.apache.lucene.benchmark.byTask.PerfRunData;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Clear statistics data.
+ * Other side effects: None.
+ */
+public class ClearStatsTask extends PerfTask {
+
+  public ClearStatsTask(PerfRunData runData) {
+    super(runData);
+  }
+
+  public int doLogic() throws Exception {
+    getRunData().getPoints().clearData();
+    return 0;
+  }
+
+  /* (non-Javadoc)
+   * @see PerfTask#shouldNotRecordStats()
+   */
+  protected boolean shouldNotRecordStats() {
+    return true;
+  }
+
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CloseIndexTask.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CloseIndexTask.java
new file mode 100644
index 0000000..3c08434
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CloseIndexTask.java
@@ -0,0 +1,44 @@
+package org.apache.lucene.benchmark.byTask.tasks;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.benchmark.byTask.PerfRunData;
+import org.apache.lucene.index.IndexWriter;
+
+/**
+ * Close index writer.
+ * Other side effects: index writer object in perfRunData is nullified.
+ */
+public class CloseIndexTask extends PerfTask {
+
+  public CloseIndexTask(PerfRunData runData) {
+    super(runData);
+  }
+
+  public int doLogic() throws IOException {
+    IndexWriter iw = getRunData().getIndexWriter();
+    if (iw!=null) {
+      iw.close();
+    }
+    getRunData().setIndexWriter(null);
+    return 1;
+  }
+
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CloseReaderTask.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CloseReaderTask.java
new file mode 100644
index 0000000..b4d1322
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CloseReaderTask.java
@@ -0,0 +1,45 @@
+package org.apache.lucene.benchmark.byTask.tasks;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.benchmark.byTask.PerfRunData;
+import org.apache.lucene.index.IndexReader;
+
+/**
+ * Close index reader.
+ * Other side effects: index reader in perfRunData is nullified.
+ * This would cause read related tasks to reopen their own reader. 
+ */
+public class CloseReaderTask extends PerfTask {
+
+  public CloseReaderTask(PerfRunData runData) {
+    super(runData);
+  }
+
+  public int doLogic() throws IOException {
+    IndexReader reader= getRunData().getIndexReader();
+    if (reader!=null) {
+      reader.close();
+    }
+    getRunData().setIndexReader(null);
+    return 1;
+  }
+
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CreateIndexTask.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CreateIndexTask.java
new file mode 100644
index 0000000..ab59bd2
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CreateIndexTask.java
@@ -0,0 +1,59 @@
+package org.apache.lucene.benchmark.byTask.tasks;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.benchmark.byTask.PerfRunData;
+import org.apache.lucene.benchmark.byTask.utils.Config;
+
+
+/**
+ * Create an index.
+ * Other side effects: index writer object in perfRunData is set.
+ */
+public class CreateIndexTask extends PerfTask {
+
+  public CreateIndexTask(PerfRunData runData) {
+    super(runData);
+  }
+
+  public int doLogic() throws IOException {
+    Directory dir = getRunData().getDirectory();
+    Analyzer analyzer = getRunData().getAnalyzer();
+    
+    IndexWriter iw = new IndexWriter(dir, analyzer, true);
+    
+    Config config = getRunData().getConfig();
+    
+    boolean cmpnd = config.get("compound",true);
+    int mrgf = config.get("merge.factor",10);
+    int mxbf = config.get("max.buffered",10);
+
+    iw.setUseCompoundFile(cmpnd);
+    iw.setMergeFactor(mrgf);
+    iw.setMaxBufferedDocs(mxbf);
+
+    getRunData().setIndexWriter(iw);
+    return 1;
+  }
+
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/DeleteDocTask.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/DeleteDocTask.java
new file mode 100644
index 0000000..8fe3365
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/DeleteDocTask.java
@@ -0,0 +1,86 @@
+package org.apache.lucene.benchmark.byTask.tasks;
+
+import org.apache.lucene.benchmark.byTask.PerfRunData;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Delete a document by docid.
+ * Other side effects: none.
+ */
+public class DeleteDocTask extends PerfTask {
+
+  public DeleteDocTask(PerfRunData runData) {
+    super(runData);
+  }
+
+  private static int logStep = -1;
+  private static int deleteStep = -1;
+  private static int numDeleted = 0;
+  private static int lastDeleted = -1;
+
+  private int docid = -1;
+  private boolean byStep = true;
+  
+  public int doLogic() throws Exception {
+    getRunData().getIndexReader().deleteDocument(docid);
+    lastDeleted = docid;
+    return 1; // one work item done here
+  }
+
+  /* (non-Javadoc)
+   * @see org.apache.lucene.benchmark.byTask.tasks.PerfTask#setup()
+   */
+  public void setup() throws Exception {
+    super.setup();
+    // one time static initializations
+    if (logStep<0) {
+      logStep = getRunData().getConfig().get("doc.delete.log.step",500);
+    }
+    if (deleteStep<0) {
+      deleteStep = getRunData().getConfig().get("doc.delete.step",8);
+    }
+    // set the docid to be deleted
+    docid = (byStep ? lastDeleted + deleteStep : docid);
+  }
+
+  /* (non-Javadoc)
+   * @see PerfTask#tearDown()
+   */
+  public void tearDown() throws Exception {
+    log(++numDeleted);
+    super.tearDown();
+  }
+
+  private void log (int count) {
+    if (logStep>0 && (count%logStep)==0) {
+      System.out.println("--> processed "+count+" docs, last deleted: "+lastDeleted);
+    }
+  }
+  
+  /**
+   * Set the params (docid only)
+   * @param params docid to delete, or -1 for deleting by delete gap settings.
+   */
+  public void setParams(String params) {
+    super.setParams(params);
+    docid = (int) Float.parseFloat(params);
+    byStep = (docid < 0);
+  }
+
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/NewRoundTask.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/NewRoundTask.java
new file mode 100644
index 0000000..c622433
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/NewRoundTask.java
@@ -0,0 +1,44 @@
+package org.apache.lucene.benchmark.byTask.tasks;
+
+import org.apache.lucene.benchmark.byTask.PerfRunData;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+/**
+ * Increment the counter for properties maintained by Round Number.
+ * Other side effects: if there are props by round number, log value change.
+ */
+public class NewRoundTask extends PerfTask {
+
+  public NewRoundTask(PerfRunData runData) {
+    super(runData);
+  }
+
+  public int doLogic() throws Exception {
+    getRunData().getConfig().newRound();
+    return 0;
+  }
+
+  /* (non-Javadoc)
+   * @see PerfTask#shouldNotRecordStats()
+   */
+  protected boolean shouldNotRecordStats() {
+    return true;
+  }
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/OpenIndexTask.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/OpenIndexTask.java
new file mode 100644
index 0000000..efdd3b1
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/OpenIndexTask.java
@@ -0,0 +1,59 @@
+package org.apache.lucene.benchmark.byTask.tasks;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.benchmark.byTask.PerfRunData;
+import org.apache.lucene.benchmark.byTask.utils.Config;
+
+
+/**
+ * Open an index writer.
+ * Other side effects: index writer object in perfRunData is set.
+ */
+public class OpenIndexTask extends PerfTask {
+
+  public OpenIndexTask(PerfRunData runData) {
+    super(runData);
+  }
+
+  public int doLogic() throws IOException {
+    Directory dir = getRunData().getDirectory();
+    Analyzer analyzer = getRunData().getAnalyzer();
+    IndexWriter writer = new IndexWriter(dir, analyzer, false);
+    
+    Config config = getRunData().getConfig();
+    
+    boolean cmpnd = config.get("compound",true);
+    int mrgf = config.get("merge.factor",10);
+    int mxbf = config.get("max.buffered",10);
+
+    // must update params for newly opened writer
+    writer.setMaxBufferedDocs(mxbf);
+    writer.setMergeFactor(mrgf);
+    writer.setUseCompoundFile(cmpnd); // this one redundant?
+    
+    getRunData().setIndexWriter(writer);
+    return 1;
+  }
+
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/OpenReaderTask.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/OpenReaderTask.java
new file mode 100644
index 0000000..2837ee0
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/OpenReaderTask.java
@@ -0,0 +1,43 @@
+package org.apache.lucene.benchmark.byTask.tasks;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.benchmark.byTask.PerfRunData;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.store.Directory;
+
+/**
+ * Open an index reader.
+ * Other side effects: index redaer object in perfRunData is set.
+ */
+public class OpenReaderTask extends PerfTask {
+
+  public OpenReaderTask(PerfRunData runData) {
+    super(runData);
+  }
+
+  public int doLogic() throws IOException {
+    Directory dir = getRunData().getDirectory();
+    IndexReader reader = IndexReader.open(dir);
+    getRunData().setIndexReader(reader);
+    return 1;
+  }
+
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/OptimizeTask.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/OptimizeTask.java
new file mode 100644
index 0000000..70cd836
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/OptimizeTask.java
@@ -0,0 +1,40 @@
+package org.apache.lucene.benchmark.byTask.tasks;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.benchmark.byTask.PerfRunData;
+import org.apache.lucene.index.IndexWriter;
+
+/**
+ * Optimize the index.
+ * Other side effects: none.
+ */
+public class OptimizeTask extends PerfTask {
+
+  public OptimizeTask(PerfRunData runData) {
+    super(runData);
+  }
+
+  public int doLogic() throws Exception {
+    IndexWriter iw = getRunData().getIndexWriter();
+    iw.optimize();
+    //System.out.println("optimize called");
+    return 1;
+  }
+
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/PerfTask.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/PerfTask.java
new file mode 100644
index 0000000..9f8398f
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/PerfTask.java
@@ -0,0 +1,217 @@
+package org.apache.lucene.benchmark.byTask.tasks;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.benchmark.byTask.PerfRunData;
+import org.apache.lucene.benchmark.byTask.stats.Points;
+import org.apache.lucene.benchmark.byTask.stats.TaskStats;
+import org.apache.lucene.benchmark.byTask.utils.Format;
+
+/**
+ * A (abstract)  task to be tested for performance.
+ * <br>
+ * Every performance task extends this class, and provides its own doLogic() method, 
+ * which performss the actual task.
+ * <br>
+ * Tasks performing some work that should be measured for the task, can overide setup() and/or tearDown() and 
+ * placed that work there. 
+ */
+public abstract class PerfTask implements Cloneable {
+
+  private PerfRunData runData;
+  
+  // propeties that all tasks have
+  private String name;
+  private int depth = 0;
+  private int maxDepthLogStart = 0;
+  protected String params = null;
+  
+  protected static final String NEW_LINE = System.getProperty("line.separator");
+
+  /**
+   * Should not be used externally
+   */
+  private PerfTask() {
+    name =  Format.simpleName(getClass());
+    if (name.endsWith("Task")) {
+      name = name.substring(0,name.length()-4);
+    }
+  }
+
+  public PerfTask(PerfRunData runData) {
+    this();
+    this.runData = runData;
+    this.maxDepthLogStart = runData.getConfig().get("task.max.depth.log",0);
+  }
+  
+  /* (non-Javadoc)
+   * @see java.lang.Object#clone()
+   */
+  protected Object clone() throws CloneNotSupportedException {
+    // tasks having non primitive data structures should overide this.
+    // otherwise parallel running of a task sequence might not run crrectly. 
+    return super.clone();
+  }
+
+  /**
+   * Run the task, record statistics.
+   * @return number of work items done by this task.
+   */
+  public final int runAndMaybeStats(boolean reportStats) throws Exception {
+    if (reportStats && depth <= maxDepthLogStart && !shouldNeverLogAtStart()) {
+      System.out.println("------------> starting task: " + getName());
+    }
+    if (shouldNotRecordStats() || !reportStats) {
+      setup();
+      int count = doLogic();
+      tearDown();
+      return count;
+    }
+    setup();
+    Points pnts = runData.getPoints();
+    TaskStats ts = pnts.markTaskStart(this,runData.getConfig().getRoundNumber());
+    int count = doLogic();
+    pnts.markTaskEnd(ts, count);
+    tearDown();
+    return count;
+  }
+
+  /**
+   * Perform the task once (ignoring repetions specification)
+   * Return number of work items done by this task.
+   * For indexing that can be number of docs added.
+   * For warming that can be number of scanned items, etc.
+   * @return number of work items done by this task.
+   */
+  public abstract int doLogic() throws Exception;
+  
+  /**
+   * @return Returns the name.
+   */
+  public String getName() {
+    if (params==null) {
+      return name;
+    } 
+    return new StringBuffer(name).append('(').append(params).append(')').toString();
+  }
+
+  /**
+   * @param name The name to set.
+   */
+  protected void setName(String name) {
+    this.name = name;
+  }
+
+  /**
+   * @return Returns the run data.
+   */
+  public PerfRunData getRunData() {
+    return runData;
+  }
+
+  /**
+   * @return Returns the depth.
+   */
+  public int getDepth() {
+    return depth;
+  }
+
+  /**
+   * @param depth The depth to set.
+   */
+  public void setDepth(int depth) {
+    this.depth = depth;
+  }
+  
+  // compute a blank string padding for printing this task indented by its depth  
+  String getPadding () {
+    char c[] = new char[4*getDepth()];
+    for (int i = 0; i < c.length; i++) c[i] = ' ';
+    return new String(c);
+  }
+  
+  /* (non-Javadoc)
+   * @see java.lang.Object#toString()
+   */
+  public String toString() {
+    String padd = getPadding();
+    StringBuffer sb = new StringBuffer(padd);
+    sb.append(getName());
+    return sb.toString();
+  }
+
+  /**
+   * @return Returns the maxDepthLogStart.
+   */
+  int getMaxDepthLogStart() {
+    return maxDepthLogStart;
+  }
+
+  /**
+   * Tasks that should never log at start can overide this.  
+   * @return true if this task should never log when it start.
+   */
+  protected boolean shouldNeverLogAtStart () {
+    return false;
+  }
+  
+  /**
+   * Tasks that should not record statistics can overide this.  
+   * @return true if this task should never record its statistics.
+   */
+  protected boolean shouldNotRecordStats () {
+    return false;
+  }
+
+  /**
+   * Task setup work that should not be measured for that specific task.
+   * By default it does nothing, but tasks can implement this, moving work from 
+   * doLogic() to this method. Only the work done in doLogicis measured for this task.
+   * Notice that higher level (sequence) tasks containing this task would then 
+   * measure larger time than the sum of their contained tasks.
+   * @throws Exception 
+   */
+  public void setup () throws Exception {
+  }
+  
+  /**
+   * Task tearDown work that should not be measured for that specific task.
+   * By default it does nothing, but tasks can implement this, moving work from 
+   * doLogic() to this method. Only the work done in doLogicis measured for this task.
+   * Notice that higher level (sequence) tasks containing this task would then 
+   * measure larger time than the sum of their contained tasks.
+   */
+  public void tearDown () throws Exception {
+  }
+
+  /**
+   * Set the params of this task.
+   * Sub classes that supports parameters may overide this method for fetching/processing the params.
+   */
+  public void setParams(String params) {
+    this.params = params;
+  }
+
+  /**
+   * @return Returns the Params.
+   */
+  public String getParams() {
+    return params;
+  }
+
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask.java
new file mode 100644
index 0000000..1b4cded
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask.java
@@ -0,0 +1,124 @@
+package org.apache.lucene.benchmark.byTask.tasks;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.benchmark.byTask.PerfRunData;
+import org.apache.lucene.benchmark.byTask.feeds.QueryMaker;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.search.Hits;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.store.Directory;
+
+
+
+/**
+ * Read index (abstract) task.
+ * Sub classes implement withSearch(), withWarm(), withTraverse() and withRetrieve()
+ * methods to configure the actual action.
+ * Other side effects: none.
+ */
+public abstract class ReadTask extends PerfTask {
+
+  public ReadTask(PerfRunData runData) {
+    super(runData);
+  }
+
+  public int doLogic() throws Exception {
+    int res = 0;
+    boolean closeReader = false;
+    
+    // open reader or use existing one
+    IndexReader ir = getRunData().getIndexReader();
+    if (ir == null) {
+      Directory dir = getRunData().getDirectory();
+      ir = IndexReader.open(dir);
+      closeReader = true;
+      //res++; //this is confusing, comment it out
+    }
+    
+    // optionally warm and add num docs traversed to count
+    if (withWarm()) {
+      Document doc = null;
+      for (int m = 0; m < ir.maxDoc(); m++) {
+        if (!ir.isDeleted(m)) {
+          doc = ir.document(m);
+          res += (doc==null ? 0 : 1);
+        }
+      }
+    }
+    
+    if (withSearch()) {
+      res++;
+      IndexSearcher searcher = new IndexSearcher(ir);
+      QueryMaker queryMaker = getQueryMaker();
+      Query q = queryMaker.makeQuery();
+      Hits hits = searcher.search(q);
+      //System.out.println("searched: "+q);
+      
+      if (withTraverse()) {
+        Document doc = null;
+        if (hits != null && hits.length() > 0) {
+          for (int m = 0; m < hits.length(); m++) {
+            int id = hits.id(m);
+            res++;
+
+            if (withRetrieve()) {
+              doc = ir.document(id);
+              res += (doc==null ? 0 : 1);
+            }
+          }
+        }
+      }
+      
+      searcher.close();
+    }
+    
+    if (closeReader) {
+      ir.close();
+    }
+    return res;
+  }
+
+  /**
+   * Return query maker used for this task.
+   */
+  public abstract QueryMaker getQueryMaker();
+
+  /**
+   * Return true if search should be performed.
+   */
+  public abstract boolean withSearch ();
+
+  /**
+   * Return true if warming should be performed.
+   */
+  public abstract boolean withWarm ();
+  
+  /**
+   * Return true if, with search, results should be traversed.
+   */
+  public abstract boolean withTraverse ();
+
+  /**
+   * Return true if, with search & results traversing, docs should be retrieved.
+   */
+  public abstract boolean withRetrieve ();
+
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepAllTask.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepAllTask.java
new file mode 100644
index 0000000..9e96531
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepAllTask.java
@@ -0,0 +1,43 @@
+package org.apache.lucene.benchmark.byTask.tasks;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.benchmark.byTask.PerfRunData;
+import org.apache.lucene.benchmark.byTask.stats.Report;
+
+/**
+ * Report all statistics with no aggregations.
+ * Other side effects: None.
+ */
+public class RepAllTask extends ReportTask {
+
+  public RepAllTask(PerfRunData runData) {
+    super(runData);
+   }
+
+  public int doLogic() throws Exception {
+    Report rp = getRunData().getPoints().reportAll();
+    
+    System.out.println();
+    System.out.println("------------> Report All ("+rp.getSize()+" out of "+rp.getOutOf()+")");
+    System.out.println(rp.getText());
+    System.out.println();
+    return 0;
+  }
+
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSelectByPrefTask.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSelectByPrefTask.java
new file mode 100644
index 0000000..a0f63a0
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSelectByPrefTask.java
@@ -0,0 +1,44 @@
+package org.apache.lucene.benchmark.byTask.tasks;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.benchmark.byTask.PerfRunData;
+import org.apache.lucene.benchmark.byTask.stats.Report;
+
+/**
+ * Report by-name-prefix statistics with no aggregations.
+ * Other side effects: None.
+ */
+public class RepSelectByPrefTask extends RepSumByPrefTask {
+
+  public RepSelectByPrefTask(PerfRunData runData) {
+    super(runData);
+  }
+
+  public int doLogic() throws Exception {
+    Report rp = getRunData().getPoints().reportSelectByPrefix(prefix);
+    
+    System.out.println();
+    System.out.println("------------> Report Select By Prefix ("+prefix+") ("+
+        rp.getSize()+" about "+rp.getReported()+" out of "+rp.getOutOf()+")");
+    System.out.println(rp.getText());
+    System.out.println();
+
+    return 0;
+  }
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByNameRoundTask.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByNameRoundTask.java
new file mode 100644
index 0000000..724ffa3
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByNameRoundTask.java
@@ -0,0 +1,45 @@
+package org.apache.lucene.benchmark.byTask.tasks;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.benchmark.byTask.PerfRunData;
+import org.apache.lucene.benchmark.byTask.stats.Report;
+
+/**
+ * Report all statistics grouped/aggregated by name and round.
+ * Other side effects: None.
+ */
+public class RepSumByNameRoundTask extends ReportTask {
+
+  public RepSumByNameRoundTask(PerfRunData runData) {
+    super(runData);
+  }
+
+  public int doLogic() throws Exception {
+    Report rp = getRunData().getPoints().reportSumByNameRound();
+
+    System.out.println();
+    System.out.println("------------> Report Sum By (any) Name and Round ("+
+        rp.getSize()+" about "+rp.getReported()+" out of "+rp.getOutOf()+")");
+    System.out.println(rp.getText());
+    System.out.println();
+    
+    return 0;
+  }
+
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByNameTask.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByNameTask.java
new file mode 100644
index 0000000..0e332f1
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByNameTask.java
@@ -0,0 +1,45 @@
+package org.apache.lucene.benchmark.byTask.tasks;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.benchmark.byTask.PerfRunData;
+import org.apache.lucene.benchmark.byTask.stats.Report;
+
+/**
+ * Report all statistics aggregated by name.
+ * Other side effects: None.
+ */
+public class RepSumByNameTask extends ReportTask {
+
+  public RepSumByNameTask(PerfRunData runData) {
+    super(runData);
+  }
+
+  public int doLogic() throws Exception {
+    Report rp = getRunData().getPoints().reportSumByName();
+
+    System.out.println();
+    System.out.println("------------> Report Sum By (any) Name ("+
+        rp.getSize()+" about "+rp.getReported()+" out of "+rp.getOutOf()+")");
+    System.out.println(rp.getText());
+    System.out.println();
+
+    return 0;
+  }
+
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByPrefRoundTask.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByPrefRoundTask.java
new file mode 100644
index 0000000..1188a82
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByPrefRoundTask.java
@@ -0,0 +1,45 @@
+package org.apache.lucene.benchmark.byTask.tasks;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.benchmark.byTask.PerfRunData;
+import org.apache.lucene.benchmark.byTask.stats.Report;
+
+/**
+ * Report all prefix matching statistics grouped/aggregated by name and round.
+ * Other side effects: None.
+ */
+public class RepSumByPrefRoundTask extends RepSumByPrefTask {
+
+  public RepSumByPrefRoundTask(PerfRunData runData) {
+    super(runData);
+  }
+
+  public int doLogic() throws Exception {
+    Report rp = getRunData().getPoints().reportSumByPrefixRound(prefix);
+    
+    System.out.println();
+    System.out.println("------------> Report sum by Prefix ("+prefix+") and Round ("+
+        rp.getSize()+" about "+rp.getReported()+" out of "+rp.getOutOf()+")");
+    System.out.println(rp.getText());
+    System.out.println();
+
+    return 0;
+  }
+
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByPrefTask.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByPrefTask.java
new file mode 100644
index 0000000..065be49
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByPrefTask.java
@@ -0,0 +1,58 @@
+package org.apache.lucene.benchmark.byTask.tasks;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.benchmark.byTask.PerfRunData;
+import org.apache.lucene.benchmark.byTask.stats.Report;
+
+/**
+ * Report by-name-prefix statistics aggregated by name.
+ * Other side effects: None.
+ */
+public class RepSumByPrefTask extends ReportTask {
+
+  public RepSumByPrefTask(PerfRunData runData) {
+    super(runData);
+  }
+
+  protected String prefix;
+
+  public int doLogic() throws Exception {
+    Report rp = getRunData().getPoints().reportSumByPrefix(prefix);
+    
+    System.out.println();
+    System.out.println("------------> Report Sum By Prefix ("+prefix+") ("+
+        rp.getSize()+" about "+rp.getReported()+" out of "+rp.getOutOf()+")");
+    System.out.println(rp.getText());
+    System.out.println();
+
+    return 0;
+  }
+
+  public void setPrefix(String prefix) {
+    this.prefix = prefix;
+  }
+
+  /* (non-Javadoc)
+   * @see PerfTask#toString()
+   */
+  public String toString() {
+    return super.toString()+" "+prefix;
+  }
+
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReportTask.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReportTask.java
new file mode 100644
index 0000000..a9a331f
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReportTask.java
@@ -0,0 +1,44 @@
+package org.apache.lucene.benchmark.byTask.tasks;
+
+import org.apache.lucene.benchmark.byTask.PerfRunData;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Report (abstract) task - all report tasks extend this task.
+ */
+public abstract class ReportTask extends PerfTask {
+
+  public ReportTask(PerfRunData runData) {
+    super(runData);
+  }
+
+  /* (non-Javadoc)
+   * @see PerfTask#shouldNeverLogAtStart()
+   */
+  protected boolean shouldNeverLogAtStart() {
+    return true;
+  }
+
+  /* (non-Javadoc)
+   * @see PerfTask#shouldNotRecordStats()
+   */
+  protected boolean shouldNotRecordStats() {
+    return true;
+  }
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ResetInputsTask.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ResetInputsTask.java
new file mode 100644
index 0000000..76e0148
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ResetInputsTask.java
@@ -0,0 +1,48 @@
+package org.apache.lucene.benchmark.byTask.tasks;
+
+import org.apache.lucene.benchmark.byTask.PerfRunData;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+
+/**
+ * Reset inputs so that the test run would behave, input wise, 
+ * as if it just started. This affects e.g. the generation of docs and queries.
+ */
+public class ResetInputsTask extends PerfTask {
+
+  public ResetInputsTask(PerfRunData runData) {
+    super(runData);
+  }
+
+  public int doLogic() throws Exception {
+    getRunData().resetInputs();
+    return 0;
+  }
+  
+  /*
+   * (non-Javadoc)
+   * @see org.apache.lucene.benchmark.byTask.tasks.PerfTask#shouldNotRecordStats()
+   */
+  protected boolean shouldNotRecordStats() {
+    return true;
+  }
+
+
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ResetSystemEraseTask.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ResetSystemEraseTask.java
new file mode 100644
index 0000000..67201b7
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ResetSystemEraseTask.java
@@ -0,0 +1,50 @@
+package org.apache.lucene.benchmark.byTask.tasks;
+
+import org.apache.lucene.benchmark.byTask.PerfRunData;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+
+/**
+ * Reset all index and input data and call gc, erase index and dir, does NOT clear statistics.
+ * This contains ResetInputs.
+ * Other side effects: writers/readers nulified, deleted, closed.
+ * Index is erased.
+ * Directory is erased.
+ */
+public class ResetSystemEraseTask extends PerfTask {
+
+  public ResetSystemEraseTask(PerfRunData runData) {
+    super(runData);
+  }
+
+  public int doLogic() throws Exception {
+    getRunData().reinit(true);
+    return 0;
+  }
+  
+  /*
+   * (non-Javadoc)
+   * @see org.apache.lucene.benchmark.byTask.tasks.PerfTask#shouldNotRecordStats()
+   */
+  protected boolean shouldNotRecordStats() {
+    return true;
+  }
+
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ResetSystemSoftTask.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ResetSystemSoftTask.java
new file mode 100644
index 0000000..ccfb579
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ResetSystemSoftTask.java
@@ -0,0 +1,50 @@
+package org.apache.lucene.benchmark.byTask.tasks;
+
+import org.apache.lucene.benchmark.byTask.PerfRunData;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+
+/**
+ * Reset all index and input data and call gc, does NOT erase index/dir, does NOT clear statistics.
+ * This contains ResetInputs.
+ * Other side effects: writers/readers nulified, closed.
+ * Index is NOT erased.
+ * Directory is NOT erased.
+ */
+public class ResetSystemSoftTask extends PerfTask {
+
+  public ResetSystemSoftTask(PerfRunData runData) {
+    super(runData);
+  }
+
+  public int doLogic() throws Exception {
+    getRunData().reinit(false);
+    return 0;
+  }
+
+  /*
+   * (non-Javadoc)
+   * @see org.apache.lucene.benchmark.byTask.tasks.PerfTask#shouldNotRecordStats()
+   */
+  protected boolean shouldNotRecordStats() {
+    return true;
+  }
+
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchTask.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchTask.java
new file mode 100644
index 0000000..beee752
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchTask.java
@@ -0,0 +1,53 @@
+package org.apache.lucene.benchmark.byTask.tasks;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.benchmark.byTask.PerfRunData;
+import org.apache.lucene.benchmark.byTask.feeds.QueryMaker;
+
+/**
+ * Search task.
+ */
+public class SearchTask extends ReadTask {
+
+  public SearchTask(PerfRunData runData) {
+    super(runData);
+  }
+
+  public boolean withRetrieve() {
+    return false;
+  }
+
+  public boolean withSearch() {
+    return true;
+  }
+
+  public boolean withTraverse() {
+    return false;
+  }
+
+  public boolean withWarm() {
+    return false;
+  }
+
+  public QueryMaker getQueryMaker() {
+    return getRunData().getSearchQueryMaker();
+  }
+
+
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchTravRetTask.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchTravRetTask.java
new file mode 100644
index 0000000..5329546
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchTravRetTask.java
@@ -0,0 +1,53 @@
+package org.apache.lucene.benchmark.byTask.tasks;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.benchmark.byTask.PerfRunData;
+import org.apache.lucene.benchmark.byTask.feeds.QueryMaker;
+
+/**
+ * Search and Travrese and Retrieve docs task.
+ */
+public class SearchTravRetTask extends ReadTask {
+
+  public SearchTravRetTask(PerfRunData runData) {
+    super(runData);
+  }
+
+  public boolean withRetrieve() {
+    return true;
+  }
+
+  public boolean withSearch() {
+    return true;
+  }
+
+  public boolean withTraverse() {
+    return true;
+  }
+
+  public boolean withWarm() {
+    return false;
+  }
+
+  public QueryMaker getQueryMaker() {
+    return getRunData().getSearchTravQueryMaker();
+  }
+
+
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchTravTask.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchTravTask.java
new file mode 100644
index 0000000..c69368b
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchTravTask.java
@@ -0,0 +1,52 @@
+package org.apache.lucene.benchmark.byTask.tasks;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.benchmark.byTask.PerfRunData;
+import org.apache.lucene.benchmark.byTask.feeds.QueryMaker;
+
+/**
+ * Search and Travrese task.
+ */
+public class SearchTravTask extends ReadTask {
+
+  public SearchTravTask(PerfRunData runData) {
+    super(runData);
+  }
+
+  public boolean withRetrieve() {
+    return false;
+  }
+
+  public boolean withSearch() {
+    return true;
+  }
+
+  public boolean withTraverse() {
+    return true;
+  }
+
+  public boolean withWarm() {
+    return false;
+  }
+
+  public QueryMaker getQueryMaker() {
+    return getRunData().getSearchTravRetQueryMaker();
+  }
+
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SetPropTask.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SetPropTask.java
new file mode 100644
index 0000000..c0b0da3
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SetPropTask.java
@@ -0,0 +1,58 @@
+package org.apache.lucene.benchmark.byTask.tasks;
+
+import org.apache.lucene.benchmark.byTask.PerfRunData;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Set a performance test configuration property.
+ * A property may have a single value, or a sequence of values, seprated by ":". 
+ * If a sequence of values is specified, each time a new round starts, 
+ * the next (cyclic) value is taken.  
+ * Other side effects: none.
+ * @see org.apache.lucene.benchmark.byTask.tasks.NewRoundTask
+ */
+public class SetPropTask extends PerfTask {
+
+  public SetPropTask(PerfRunData runData) {
+    super(runData);
+  }
+
+  private String name;
+  private String value;
+  
+  public int doLogic() throws Exception {
+    if (name==null || value==null) {
+      throw new Exception(getName()+" - undefined name or value: name="+name+" value="+value);
+    }
+    getRunData().getConfig().set(name,value);
+    return 0;
+  }
+
+  /**
+   * Set the params (property name and value).
+   * @param params property name and value separated by ','.
+   */
+  public void setParams(String params) {
+    super.setParams(params);
+    int k = params.indexOf(",");
+    name = params.substring(0,k).trim();
+    value = params.substring(k+1).trim();
+  }
+
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/TaskSequence.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/TaskSequence.java
new file mode 100644
index 0000000..dedd68a
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/TaskSequence.java
@@ -0,0 +1,269 @@
+package org.apache.lucene.benchmark.byTask.tasks;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.ArrayList;
+import java.util.Iterator;
+
+import org.apache.lucene.benchmark.byTask.PerfRunData;
+
+/**
+ * Sequence of parallel or sequential tasks.
+ */
+public class TaskSequence extends PerfTask {
+  private ArrayList tasks;
+  private int repetitions = 1;
+  private boolean parallel;
+  private TaskSequence parent;
+  private boolean letChildReport = true;
+  private int rate = 0;
+  private boolean perMin = false; // rate, if set, is, by default, be sec.
+  private String seqName; 
+  
+  public TaskSequence (PerfRunData runData, String name, TaskSequence parent, boolean parallel) {
+    super(runData);
+    name = (name!=null ? name : (parallel ? "Par" : "Seq"));
+    setName(name);
+    setSequenceName();
+    this.parent = parent;
+    this.parallel = parallel;
+    tasks = new ArrayList();
+  }
+
+  /**
+   * @return Returns the parallel.
+   */
+  public boolean isParallel() {
+    return parallel;
+  }
+
+  /**
+   * @return Returns the repetitions.
+   */
+  public int getRepetitions() {
+    return repetitions;
+  }
+
+  /**
+   * @param repetitions The repetitions to set.
+   */
+  public void setRepetitions(int repetitions) {
+    this.repetitions = repetitions;
+    setSequenceName();
+  }
+
+  /**
+   * @return Returns the parent.
+   */
+  public TaskSequence getParent() {
+    return parent;
+  }
+
+  /*
+   * (non-Javadoc)
+   * @see org.apache.lucene.benchmark.byTask.tasks.PerfTask#doLogic()
+   */
+  public int doLogic() throws Exception {
+    return ( parallel ? doParallelTasks() : doSerialTasks());
+  }
+
+  private int doSerialTasks() throws Exception {
+    if (rate > 0) {
+      return doSerialTasksWithRate();
+    }
+    
+    int count = 0;
+    for (int k=0; k<repetitions; k++) {
+      for (Iterator it = tasks.iterator(); it.hasNext();) {
+        PerfTask task = (PerfTask) it.next();
+        count += task.runAndMaybeStats(letChildReport);
+      }
+    }
+    return count;
+  }
+
+  private int doSerialTasksWithRate() throws Exception {
+    long delayStep = (perMin ? 60000 : 1000) /rate;
+    long nextStartTime = System.currentTimeMillis();
+    int count = 0;
+    for (int k=0; k<repetitions; k++) {
+      for (Iterator it = tasks.iterator(); it.hasNext();) {
+        PerfTask task = (PerfTask) it.next();
+        long waitMore = nextStartTime - System.currentTimeMillis();
+        if (waitMore > 0) {
+          //System.out.println("wait: "+waitMore+" for rate: "+ratePerMin+" (delayStep="+delayStep+")");
+          Thread.sleep(waitMore);
+        }
+        nextStartTime += delayStep; // this aims at avarage rate. 
+        count += task.runAndMaybeStats(letChildReport);
+      }
+    }
+    return count;
+  }
+
+  private int doParallelTasks() throws Exception {
+    final int count [] = {0};
+    Thread t[] = new Thread [repetitions * tasks.size()];
+    // prepare threads
+    int indx = 0;
+    for (int k=0; k<repetitions; k++) {
+      for (int i = 0; i < tasks.size(); i++) {
+        final PerfTask task = (PerfTask) ((PerfTask) tasks.get(i)).clone();
+        t[indx++] = new Thread() {
+          public void run() {
+            int n;
+            try {
+              n = task.runAndMaybeStats(letChildReport);
+            } catch (Exception e) {
+              throw new RuntimeException(e);
+            }
+            synchronized (count) {
+              count[0] += n;
+            }
+          }
+        };
+      }
+    }
+    // run threads
+    startThreads(t);
+    // wait for all threads to complete
+    for (int i = 0; i < t.length; i++) {
+      t[i].join();
+    }
+    // return total count
+    return count[0];
+  }
+
+  // run threads
+  private void startThreads(Thread[] t) throws InterruptedException {
+    if (rate > 0) {
+      startlThreadsWithRate(t);
+      return;
+    }
+    for (int i = 0; i < t.length; i++) {
+      t[i].start();
+    }
+  }
+
+  // run threadsm with rate
+  private void startlThreadsWithRate(Thread[] t) throws InterruptedException {
+    long delayStep = (perMin ? 60000 : 1000) /rate;
+    long nextStartTime = System.currentTimeMillis();
+    for (int i = 0; i < t.length; i++) {
+      long waitMore = nextStartTime - System.currentTimeMillis();
+      if (waitMore > 0) {
+        //System.out.println("thread wait: "+waitMore+" for rate: "+ratePerMin+" (delayStep="+delayStep+")");
+        Thread.sleep(waitMore);
+      }
+      nextStartTime += delayStep; // this aims at avarage rate of starting threads. 
+      t[i].start();
+    }
+  }
+
+  public void addTask(PerfTask task) {
+    tasks.add(task);
+    task.setDepth(getDepth()+1);
+  }
+  
+  /* (non-Javadoc)
+   * @see java.lang.Object#toString()
+   */
+  public String toString() {
+    String padd = getPadding();
+    StringBuffer sb = new StringBuffer(super.toString());
+    sb.append(parallel ? " [" : " {");
+    sb.append(NEW_LINE);
+    for (Iterator it = tasks.iterator(); it.hasNext();) {
+      PerfTask task = (PerfTask) it.next();
+      sb.append(task.toString());
+      sb.append(NEW_LINE);
+    }
+    sb.append(padd);
+    sb.append(!letChildReport ? ">" : (parallel ? "]" : "}"));
+    if (repetitions>1) {
+      sb.append(" * " + repetitions);
+    }
+    if (rate>0) {
+      sb.append(",  rate: " + rate+"/"+(perMin?"min":"sec"));
+    }
+    return sb.toString();
+  }
+
+  /**
+   * Execute child tasks in a way that they do not reprt their time separately.
+   * Current implementation if child tasks has child tasks of their own, those are not affected by this call. 
+   */
+  public void setNoChildReport() {
+    letChildReport  = false;
+  }
+
+  /**
+   * Returns the rate per minute: how many operations should be performed in a minute.
+   * If 0 this has no effect.
+   * @return the rate per min: how many operations should be performed in a minute.
+   */
+  public int getRate() {
+    return (perMin ? rate : 60*rate);
+  }
+
+  /**
+   * @param rate The rate to set.
+   */
+  public void setRate(int rate, boolean perMin) {
+    this.rate = rate;
+    this.perMin = perMin;
+    setSequenceName();
+  }
+
+  private void setSequenceName() {
+    seqName = super.getName();
+    if (repetitions>1) {
+      seqName += "_"+repetitions;
+    }
+    if (rate>0) {
+      seqName += "_" + rate + (perMin?"/min":"/sec"); 
+    }
+    if (parallel && seqName.toLowerCase().indexOf("par")<0) {
+      seqName += "_Par";
+    }
+  }
+
+  public String getName() {
+    return seqName; // overide to include more info 
+  }
+
+  /**
+   * @return Returns the tasks.
+   */
+  public ArrayList getTasks() {
+    return tasks;
+  }
+
+  /* (non-Javadoc)
+   * @see java.lang.Object#clone()
+   */
+  protected Object clone() throws CloneNotSupportedException {
+    TaskSequence res = (TaskSequence) super.clone();
+    res.tasks = new ArrayList();
+    for (int i = 0; i < tasks.size(); i++) {
+      res.tasks.add(((PerfTask)tasks.get(i)).clone());
+    }
+    return res;
+  }
+  
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/WarmTask.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/WarmTask.java
new file mode 100644
index 0000000..e915cce
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/WarmTask.java
@@ -0,0 +1,53 @@
+package org.apache.lucene.benchmark.byTask.tasks;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.benchmark.byTask.PerfRunData;
+import org.apache.lucene.benchmark.byTask.feeds.QueryMaker;
+
+/**
+ * Warm reader task.
+ */
+public class WarmTask extends ReadTask {
+
+  public WarmTask(PerfRunData runData) {
+    super(runData);
+  }
+
+  public boolean withRetrieve() {
+    return false;
+  }
+
+  public boolean withSearch() {
+    return false;
+  }
+
+  public boolean withTraverse() {
+    return false;
+  }
+
+  public boolean withWarm() {
+    return true;
+  }
+
+  public QueryMaker getQueryMaker() {
+    return null; // not required for this task.
+  }
+
+
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/package.html b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/package.html
new file mode 100644
index 0000000..0c00e63
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/package.html
@@ -0,0 +1,9 @@
+<html>
+<head>
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
+   <meta name="Author" content="Doron Cohen">
+</head>
+<body>
+Extendable benchmark tasks.
+</body>
+</html>
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm.java
new file mode 100644
index 0000000..3aa32c3
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm.java
@@ -0,0 +1,229 @@
+package org.apache.lucene.benchmark.byTask.utils;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.StreamTokenizer;
+import java.io.StringReader;
+import java.lang.reflect.Constructor;
+import java.util.ArrayList;
+
+import org.apache.lucene.benchmark.byTask.PerfRunData;
+import org.apache.lucene.benchmark.byTask.tasks.PerfTask;
+import org.apache.lucene.benchmark.byTask.tasks.RepSumByPrefTask;
+import org.apache.lucene.benchmark.byTask.tasks.TaskSequence;
+
+/**
+ * Test algorithm, as read from file
+ */
+public class Algorithm {
+  
+  private TaskSequence sequence;
+  
+  /**
+   * Read algorithm from file
+   * @param runData perf-run-data used at running the tasks.
+   * @throws Exception if errors while parsing the algorithm 
+   */
+  public Algorithm (PerfRunData runData) throws Exception {
+    String algTxt = runData.getConfig().getAlgorithmText();
+    sequence = new TaskSequence(runData,null,null,false);
+    TaskSequence currSequence = sequence;
+    PerfTask prevTask = null;
+    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));
+    stok.commentChar('#');
+    stok.eolIsSignificant(false);
+    stok.ordinaryChar('"');
+    stok.ordinaryChar('/');
+    stok.ordinaryChar('(');
+    stok.ordinaryChar(')');
+    boolean colonOk = false; 
+    currSequence.setDepth(0);
+    String taskPackage = PerfTask.class.getPackage().getName() + ".";
+    
+    Class paramClass[] = {PerfRunData.class};
+    PerfRunData paramObj[] = {runData};
+    
+    while (stok.nextToken() != StreamTokenizer.TT_EOF) { 
+      switch(stok.ttype) {
+  
+        case StreamTokenizer.TT_WORD:
+          String s = stok.sval;
+          Constructor cnstr = Class.forName(taskPackage+s+"Task").getConstructor(paramClass);
+          PerfTask task = (PerfTask) cnstr.newInstance(paramObj);
+          currSequence.addTask(task);
+          if (task instanceof RepSumByPrefTask) {
+            stok.nextToken();
+            String prefix = stok.sval;
+            if (prefix==null || prefix.length()==0) { 
+              throw new Exception("named report prefix problem - "+stok.toString()); 
+            }
+            ((RepSumByPrefTask) task).setPrefix(prefix);
+          }
+          // check for task param: '(' someParam ')'
+          stok.nextToken();
+          if (stok.ttype!='(') {
+            stok.pushBack();
+          } else {
+            // get params, for tasks that supports them, - anything until next ')'
+            StringBuffer params = new StringBuffer();
+            stok.nextToken();
+            while (stok.ttype!=')') { 
+              switch (stok.ttype) {
+                case StreamTokenizer.TT_NUMBER:  
+                  params.append(stok.nval);
+                  break;
+                case StreamTokenizer.TT_WORD:    
+                  params.append(stok.sval);             
+                  break;
+                case StreamTokenizer.TT_EOF:     
+                  throw new Exception("unexpexted EOF: - "+stok.toString());
+                default:
+                  params.append((char)stok.ttype);
+              }
+              stok.nextToken();
+            }
+            String prm = params.toString().trim();
+            if (prm.length()>0) {
+              task.setParams(prm);
+            }
+          }
+
+          // ---------------------------------------
+          colonOk = false; prevTask = task;
+          break;
+  
+        default:
+          char c = (char)stok.ttype;
+          
+          switch(c) {
+          
+            case ':' :
+              if (!colonOk) throw new Exception("colon unexpexted: - "+stok.toString());
+              colonOk = false;
+              // get repetitions number
+              stok.nextToken();
+              if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception("expexted repetitions number: - "+stok.toString());
+              ((TaskSequence)prevTask).setRepetitions((int)stok.nval); 
+              // check for rate specification (ops/min)
+              stok.nextToken();
+              if (stok.ttype!=':') {
+                stok.pushBack();
+              } else {
+                // get rate number
+                stok.nextToken();
+                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception("expexted rate number: - "+stok.toString());
+                // check for unit - min or sec, sec is default
+                stok.nextToken();
+                if (stok.ttype!='/') {
+                  stok.pushBack();
+                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec
+                } else {
+                  stok.nextToken();
+                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception("expexted rate unit: 'min' or 'sec' - "+stok.toString());
+                  String unit = stok.sval.toLowerCase();
+                  if ("min".equals(unit)) {
+                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min
+                  } else if ("sec".equals(unit)) {
+                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec
+                  } else {
+                    throw new Exception("expexted rate unit: 'min' or 'sec' - "+stok.toString());
+                  }
+                }
+              }
+              colonOk = false;
+              break;
+    
+            case '{' : 
+            case '[' :  
+              // a sequence
+              // check for sequence name
+              String name = null;
+              stok.nextToken();
+              if (stok.ttype!='"') {
+                stok.pushBack();
+              } else {
+                stok.nextToken();
+                name = stok.sval;
+                stok.nextToken();
+                if (stok.ttype!='"' || name==null || name.length()==0) { 
+                  throw new Exception("sequence name problem - "+stok.toString()); 
+                }
+              }
+              // start the sequence
+              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');
+              currSequence.addTask(seq2);
+              currSequence = seq2;
+              colonOk = false;
+              break;
+    
+            case '>' :
+              currSequence.setNoChildReport();
+            case '}' : 
+            case ']' : 
+              // end sequence
+              colonOk = true; prevTask = currSequence;
+              currSequence = currSequence.getParent();
+              break;
+          
+          } //switch(c)
+          break;
+          
+      } //switch(stok.ttype)
+      
+    }
+    
+    if (sequence != currSequence) {
+      throw new Exception("Unmatched sequences");
+    }
+    
+    // remove redundant top level enclosing sequences
+    while (sequence.getRepetitions()==1 && sequence.getRate()==0) {
+      ArrayList t = sequence.getTasks();
+      if (t!=null && t.size()==1) {
+        PerfTask p = (PerfTask) t.get(0);
+        if (p instanceof TaskSequence) {
+          sequence = (TaskSequence) p;
+          continue;
+        }
+      }
+      break;
+    }
+  }
+
+  /* (non-Javadoc)
+   * @see java.lang.Object#toString()
+   */
+  public String toString() {
+    String newline = System.getProperty("line.separator");
+    StringBuffer sb = new StringBuffer();
+    sb.append(sequence.toString());
+    sb.append(newline);
+    return sb.toString();
+  }
+
+  /**
+   * Execute this algorithm
+   * @throws Exception 
+   */
+  public void execute() throws Exception {
+    sequence.doLogic();
+  }
+  
+  
+}
+
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Config.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Config.java
new file mode 100644
index 0000000..8bb566a
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Config.java
@@ -0,0 +1,325 @@
+package org.apache.lucene.benchmark.byTask.utils;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.BufferedReader;
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.FileReader;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Properties;
+import java.util.StringTokenizer;
+
+/**
+ * Perf run configuration properties.
+ * Numeric peroperty containing ":", e.g. "10:100:5" is interpreted 
+ * as array of numeric values. It is extracted once, on first use, and 
+ * maintain an round number to return the appropriate value.   
+ */
+public class Config {
+
+  private static final String NEW_LINE = System.getProperty("line.separator");
+
+  private int roundNumber = 0;
+  private Properties props;
+  private HashMap valByRound = new HashMap();
+  private HashMap colForValByRound = new HashMap();
+  private String algorithmText;
+
+  /**
+   * Read config from file containing both algorithm and config properties.
+   * @param algFile file containing both algorithm and config properties.
+   * @throws IOException
+   */
+  public Config (File algFile) throws IOException {
+    // read alg file to array of lines
+    ArrayList lines = new ArrayList();
+    BufferedReader r = new BufferedReader(new FileReader(algFile));
+    int lastConfigLine=0;
+    for (String line = r.readLine(); line!=null; line=r.readLine()) {
+      lines.add(line);
+      if (line.indexOf('=')>0) {
+        lastConfigLine = lines.size();
+      }
+    }
+    r.close();
+    // copy props lines to string
+    StringBuffer sb = new StringBuffer();
+    for (int i=0; i<lastConfigLine; i++) {
+      sb.append(lines.get(i));
+      sb.append(NEW_LINE);
+    }
+    // read props from string
+    this.props = new Properties();
+    props.load(new ByteArrayInputStream(sb.toString().getBytes()));
+
+    if (Boolean.valueOf(props.getProperty("print.props","true")).booleanValue()) {
+      printProps();
+    }
+    
+    // copy algorithm lines
+    sb = new StringBuffer();
+    for (int i=lastConfigLine; i<lines.size(); i++) {
+      sb.append(lines.get(i));
+      sb.append(NEW_LINE);
+    }
+    algorithmText = sb.toString();
+  }
+
+  /**
+   * Create config without algorithm - usefull for a programmatic perf test.
+   * @param props - configuration properties.
+   * @throws IOException
+   */
+  public Config (Properties props) {
+    this.props = props;
+    if (Boolean.valueOf(props.getProperty("print.props","true")).booleanValue()) {
+      printProps();
+    }
+  }
+
+  private void printProps() {
+    System.out.println("------------> config properties:");
+    for (Iterator it = props.keySet().iterator(); it.hasNext();) {
+      String propName = (String) it.next();
+      System.out.println(propName + " = " + props.getProperty(propName));
+    }
+    System.out.println("-------------------------------");
+  }
+
+  /**
+   * Return a string property.
+   * @param name name of property.
+   * @param dflt default value.
+   * @return a string property.
+   */
+  public String get (String name, String dflt) {
+    return props.getProperty(name,dflt);
+  }
+
+  /**
+   * Set a property.
+   * Note: once a multiple values property is set, it can no longer be modified.
+   * @param name name of property.
+   * @param value either single or multiple propery value (multple values are separated by ":")
+   * @throws Exception 
+   */
+  public void set (String name, String value) throws Exception {
+    if (valByRound.get(name) != null) {
+      throw new Exception("Cannot modify a multi value property!");
+    }
+    props.setProperty(name,value);
+  }
+
+  /**
+   * Return an int property.
+   * If the property contain ":", e.g. "10:100:5", it is interpreted 
+   * as array of ints. It is extracted once, on first call
+   * to get() it, and a by-round-value is returned. 
+   * @param name name of property
+   * @param dflt default value
+   * @return a int property.
+   */
+  public int get (String name, int dflt) {
+    // use value by round if already parsed
+    int vals[] = (int[]) valByRound.get(name);
+    if (vals != null) {
+      return vals[roundNumber % vals.length];
+    }
+    // done if not by round 
+    String sval = props.getProperty(name,""+dflt);
+    if (sval.indexOf(":")<0) {
+      return Integer.parseInt(sval);
+    }
+    // first time this prop is extracted by round
+    int k = sval.indexOf(":");
+    String colName = sval.substring(0,k);
+    sval = sval.substring(k+1);
+    colForValByRound.put(name,colName);
+    vals = propToIntArray(sval);
+    valByRound.put(name,vals);
+    return vals[roundNumber % vals.length];
+  }
+  
+  /**
+   * Return a boolean property.
+   * If the property contain ":", e.g. "true.true.false", it is interpreted 
+   * as array of boleans. It is extracted once, on first call
+   * to get() it, and a by-round-value is returned. 
+   * @param name name of property
+   * @param dflt default value
+   * @return a int property.
+   */
+  public boolean get (String name, boolean dflt) {
+    // use value by round if already parsed
+    boolean vals[] = (boolean[]) valByRound.get(name);
+    if (vals != null) {
+      return vals[roundNumber % vals.length];
+    }
+    // done if not by round 
+    String sval = props.getProperty(name,""+dflt);
+    if (sval.indexOf(":")<0) {
+      return Boolean.valueOf(sval).booleanValue();
+    }
+    // first time this prop is extracted by round 
+    int k = sval.indexOf(":");
+    String colName = sval.substring(0,k);
+    sval = sval.substring(k+1);
+    colForValByRound.put(name,colName);
+    vals = propToBooleanArray(sval);
+    valByRound.put(name,vals);
+    return vals[roundNumber % vals.length];
+  }
+  
+  /**
+   * Increment the round number, for config values that are extracted by round number. 
+   * @return the new round number.
+   */
+  public int newRound () {
+    roundNumber++;
+    
+    // log changes in values
+    if (valByRound.size()>0) {
+      StringBuffer sb = new StringBuffer("--> Round ").append(roundNumber-1).append("-->").append(roundNumber).append(": ");
+      for (Iterator iter = valByRound.keySet().iterator(); iter.hasNext();) {
+        String name = (String) iter.next();
+        Object a = valByRound.get(name);
+        if (a instanceof int[]) {
+          int ai[] = (int[]) a;
+          int n1 = (roundNumber-1)%ai.length;
+          int n2 = roundNumber%ai.length;
+          sb.append("  ").append(name).append(":").append(ai[n1]).append("-->").append(ai[n2]);
+        } else {
+          boolean ab[] = (boolean[]) a;
+          int n1 = (roundNumber-1)%ab.length;
+          int n2 = roundNumber%ab.length;
+          sb.append("  ").append(name).append(":").append(ab[n1]).append("-->").append(ab[n2]);
+        }
+      }
+      System.out.println();
+      System.out.println(sb.toString());
+      System.out.println();
+    }
+    
+    return roundNumber;
+  }
+  
+  // extract properties to array, e.g. for "10.100.5" return int[]{10,100,5}. 
+  private int[] propToIntArray (String s) {
+    if (s.indexOf(":")<0) {
+      return new int [] { Integer.parseInt(s) };
+    }
+    
+    ArrayList a = new ArrayList();
+    StringTokenizer st = new StringTokenizer(s,":");
+    while (st.hasMoreTokens()) {
+      String t = st.nextToken();
+      a.add(new Integer(t));
+    }
+    int res[] = new int[a.size()]; 
+    for (int i=0; i<a.size(); i++) {
+      res[i] = ((Integer) a.get(i)).intValue();
+    }
+    return res;
+  }
+    
+  // extract properties to array, e.g. for "true.true.false" return booleab[]{true,false,false}. 
+  private boolean[] propToBooleanArray (String s) {
+    if (s.indexOf(":")<0) {
+      return new boolean [] { Boolean.valueOf(s).booleanValue() };
+    }
+    
+    ArrayList a = new ArrayList();
+    StringTokenizer st = new StringTokenizer(s,":");
+    while (st.hasMoreTokens()) {
+      String t = st.nextToken();
+      a.add(new Boolean(t));
+    }
+    boolean res[] = new boolean[a.size()]; 
+    for (int i=0; i<a.size(); i++) {
+      res[i] = ((Boolean) a.get(i)).booleanValue();
+    }
+    return res;
+  }
+
+  /**
+   * @return names of params set by round, for reports title
+   */
+  public String getColsNamesForValsByRound() {
+    if (colForValByRound.size()==0) {
+      return "";
+    }
+    StringBuffer sb = new StringBuffer(); 
+    for (Iterator it = colForValByRound.keySet().iterator(); it.hasNext();) {
+      String name = (String) it.next();
+      String colName = (String) colForValByRound.get(name);
+      sb.append(" ").append(colName);
+    }
+    return sb.toString();
+  }
+
+  /**
+   * @return values of params set by round, for reports lines.
+   */
+  public String getColsValuesForValsByRound(int roundNum) {
+    if (colForValByRound.size()==0) {
+      return "";
+    }
+    StringBuffer sb = new StringBuffer(); 
+    for (Iterator it = colForValByRound.keySet().iterator(); it.hasNext();) {
+      String name = (String) it.next();
+      String colName = (String) colForValByRound.get(name);
+      String template = " "+colName;
+      if (roundNum<0) {
+        // just append blanks
+        sb.append(Format.formatPaddLeft("-",template));
+      } else {
+        // append actual values, for that round
+        Object a = valByRound.get(name);
+        if (a instanceof int[]) {
+          int ai[] = (int[]) a;
+          int n = roundNum % ai.length;
+          sb.append(Format.format(ai[n],template));
+        } else {
+          boolean ab[] = (boolean[]) a;
+          int n = roundNum % ab.length;
+          sb.append(Format.formatPaddLeft(""+ab[n],template));
+        }
+      }
+    }
+    return sb.toString();
+  }
+
+  /**
+   * @return the round number.
+   */
+  public int getRoundNumber() {
+    return roundNumber;
+  }
+
+  /**
+   * @return Returns the algorithmText.
+   */
+  public String getAlgorithmText() {
+    return algorithmText;
+  }
+
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/FileUtils.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/FileUtils.java
new file mode 100644
index 0000000..aa93b15
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/FileUtils.java
@@ -0,0 +1,54 @@
+package org.apache.lucene.benchmark.byTask.utils;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.File;
+import java.io.IOException;
+
+/**
+ * File utilities.
+ */
+public class FileUtils {
+
+  /**
+   * Delete files and directories, even if non-empty.
+   *
+   * @param dir file or directory
+   * @return true on success, false if no or part of files have been deleted
+   * @throws java.io.IOException
+   */
+  public static boolean fullyDelete(File dir) throws IOException {
+    if (dir == null || !dir.exists()) return false;
+    File contents[] = dir.listFiles();
+    if (contents != null) {
+      for (int i = 0; i < contents.length; i++) {
+        if (contents[i].isFile()) {
+          if (!contents[i].delete()) {
+            return false;
+          }
+        } else {
+          if (!fullyDelete(contents[i])) {
+            return false;
+          }
+        }
+      }
+    }
+    return dir.delete();
+  }
+
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Format.java b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Format.java
new file mode 100644
index 0000000..432a033
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Format.java
@@ -0,0 +1,114 @@
+package org.apache.lucene.benchmark.byTask.utils;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.text.NumberFormat;
+
+/**
+ * Formatting utilities (for reports).
+ */
+public class Format {
+
+  private static NumberFormat numFormat [] = { 
+    NumberFormat.getInstance(), 
+    NumberFormat.getInstance(),
+    NumberFormat.getInstance(),
+  };
+  private static final String padd = "                                                 ";
+  
+  static {
+    numFormat[0].setMaximumFractionDigits(0);
+    numFormat[0].setMinimumFractionDigits(0);
+    numFormat[1].setMaximumFractionDigits(1);
+    numFormat[1].setMinimumFractionDigits(1);
+    numFormat[2].setMaximumFractionDigits(2);
+    numFormat[2].setMinimumFractionDigits(2);
+  }
+
+  /**
+   * Padd a number from left.
+   * @param numFracDigits number of digits in fraction part - must be 0 or 1 or 2.
+   * @param f number to be formatted.
+   * @param col column name (used for deciding on length).
+   * @return formatted string.
+   */
+  public static String format(int numFracDigits, float f, String col) {
+    String res = padd + numFormat[numFracDigits].format(f);
+    return res.substring(res.length() - col.length());
+  }
+
+  /**
+   * Padd a number from right.
+   * @param numFracDigits number of digits in fraction part - must be 0 or 1 or 2.
+   * @param f number to be formatted.
+   * @param col column name (used for deciding on length).
+   * @return formatted string.
+   */
+  public static String formatPaddRight(int numFracDigits, float f, String col) {
+    String res = numFormat[numFracDigits].format(f) + padd;
+    return res.substring(0, col.length());
+  }
+
+  /**
+   * Padd a number from left.
+   * @param n number to be formatted.
+   * @param col column name (used for deciding on length).
+   * @return formatted string.
+   */
+  public static String format(int n, String col) {
+    String res = padd + n;
+    return res.substring(res.length() - col.length());
+  }
+
+  /**
+   * Padd a string from right.
+   * @param s string to be formatted.
+   * @param col column name (used for deciding on length).
+   * @return formatted string.
+   */
+  public static String format(String s, String col) {
+    return (s + padd).substring(0, col.length());
+  }
+
+  /**
+   * Padd a string from left.
+   * @param s string to be formatted.
+   * @param col column name (used for deciding on length).
+   * @return formatted string.
+   */
+  public static String formatPaddLeft(String s, String col) {
+    String res = padd + s;
+    return res.substring(res.length() - col.length());
+  }
+
+  /**
+   * Extract simple class name 
+   * @param cls class whose simple name is required 
+   * @return simple class name
+   */
+  public static String simpleName (Class cls) {
+    String c = cls.getName();
+    String p = cls.getPackage().getName();
+    int k = c.lastIndexOf(p+".");
+    if (k<0) {
+      return c;
+    }
+    return c.substring(k+1+p.length());
+  }
+  
+}
diff --git a/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/package.html b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/package.html
new file mode 100644
index 0000000..9228bc1
--- /dev/null
+++ b/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/package.html
@@ -0,0 +1,5 @@
+<html>
+<body>
+Utilities used for the benchmark, and for the reports.
+</body>
+</html>

