GitDiffStart: c3a19e09798767d83c0b130298ca52b92e050f7e | Thu Sep 10 21:45:50 2015 +0000
diff --git a/lucene/CHANGES.txt b/lucene/CHANGES.txt
index 4ff4a83..62a638f 100644
--- a/lucene/CHANGES.txt
+++ b/lucene/CHANGES.txt
@@ -151,6 +151,10 @@ Other
 * LUCENE-6775: Improved MorfologikFilterFactory to allow loading of
   custom dictionaries from ResourceLoader.  (Uwe Schindler)
 
+* LUCENE-6797: Make GeoCircle an interface and use a factory to create
+  it, to eventually handle degenerate cases (Karl Wright via Mike
+  McCandless)
+
 Build
 
 * LUCENE-6732: Improve checker for invalid source patterns to also
diff --git a/lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/Geo3dRptTest.java b/lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/Geo3dRptTest.java
index 8221319..d659534 100644
--- a/lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/Geo3dRptTest.java
+++ b/lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/Geo3dRptTest.java
@@ -34,7 +34,7 @@ import org.apache.lucene.spatial.prefix.tree.SpatialPrefixTree;
 import org.apache.lucene.spatial.query.SpatialOperation;
 import org.apache.lucene.spatial.serialized.SerializedDVStrategy;
 import org.apache.lucene.geo3d.GeoBBoxFactory;
-import org.apache.lucene.geo3d.GeoCircle;
+import org.apache.lucene.geo3d.GeoStandardCircle;
 import org.apache.lucene.geo3d.GeoPath;
 import org.apache.lucene.geo3d.GeoPoint;
 import org.apache.lucene.geo3d.GeoPolygonFactory;
@@ -166,7 +166,7 @@ public class Geo3dRptTest extends RandomSpatialOpStrategyTestCase {
           final int circleRadius = random().nextInt(179) + 1;
           final Point point = randomPoint();
           try {
-            final GeoShape shape = new GeoCircle(PlanetModel.SPHERE, point.getY() * DEGREES_TO_RADIANS, point.getX() * DEGREES_TO_RADIANS,
+            final GeoShape shape = new GeoStandardCircle(PlanetModel.SPHERE, point.getY() * DEGREES_TO_RADIANS, point.getX() * DEGREES_TO_RADIANS,
               circleRadius * DEGREES_TO_RADIANS);
             return new Geo3dShape(shape, ctx);
           } catch (IllegalArgumentException e) {
diff --git a/lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/Geo3dShapeRectRelationTestCase.java b/lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/Geo3dShapeRectRelationTestCase.java
index bd03012..aee459a 100644
--- a/lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/Geo3dShapeRectRelationTestCase.java
+++ b/lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/Geo3dShapeRectRelationTestCase.java
@@ -29,7 +29,7 @@ import com.spatial4j.core.shape.Point;
 import org.apache.lucene.geo3d.LatLonBounds;
 import org.apache.lucene.geo3d.GeoBBox;
 import org.apache.lucene.geo3d.GeoBBoxFactory;
-import org.apache.lucene.geo3d.GeoCircle;
+import org.apache.lucene.geo3d.GeoStandardCircle;
 import org.apache.lucene.geo3d.GeoPath;
 import org.apache.lucene.geo3d.GeoPoint;
 import org.apache.lucene.geo3d.GeoPolygonFactory;
@@ -111,14 +111,14 @@ public abstract class Geo3dShapeRectRelationTestCase extends RandomizedShapeTest
       protected Geo3dShape generateRandomShape(Point nearP) {
         final int circleRadius = 180 - random().nextInt(180);//no 0-radius
         final Point point = nearP;
-        final GeoShape shape = new GeoCircle(planetModel, point.getY() * DEGREES_TO_RADIANS, point.getX() * DEGREES_TO_RADIANS,
+        final GeoShape shape = new GeoStandardCircle(planetModel, point.getY() * DEGREES_TO_RADIANS, point.getX() * DEGREES_TO_RADIANS,
             circleRadius * DEGREES_TO_RADIANS);
         return new Geo3dShape(planetModel, shape, ctx);
       }
 
       @Override
       protected Point randomPointInEmptyShape(Geo3dShape shape) {
-        GeoPoint geoPoint = ((GeoCircle)shape.shape).getCenter();
+        GeoPoint geoPoint = ((GeoStandardCircle)shape.shape).getCenter();
         return geoPointToSpatial4jPoint(geoPoint);
       }
 
diff --git a/lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/Geo3dShapeSphereModelRectRelationTest.java b/lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/Geo3dShapeSphereModelRectRelationTest.java
index 5df5c52..1d01203 100644
--- a/lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/Geo3dShapeSphereModelRectRelationTest.java
+++ b/lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/Geo3dShapeSphereModelRectRelationTest.java
@@ -24,7 +24,7 @@ import com.spatial4j.core.shape.Rectangle;
 import org.apache.lucene.geo3d.GeoArea;
 import org.apache.lucene.geo3d.GeoBBox;
 import org.apache.lucene.geo3d.GeoBBoxFactory;
-import org.apache.lucene.geo3d.GeoCircle;
+import org.apache.lucene.geo3d.GeoStandardCircle;
 import org.apache.lucene.geo3d.GeoPoint;
 import org.apache.lucene.geo3d.GeoPolygonFactory;
 import org.apache.lucene.geo3d.GeoShape;
@@ -61,7 +61,7 @@ public class Geo3dShapeSphereModelRectRelationTest extends Geo3dShapeRectRelatio
 
   @Test
   public void testFailure2_LUCENE6475() {
-    GeoShape geo3dCircle = new GeoCircle(planetModel, 1.6282053147165243E-4 * RADIANS_PER_DEGREE,
+    GeoShape geo3dCircle = new GeoStandardCircle(planetModel, 1.6282053147165243E-4 * RADIANS_PER_DEGREE,
         -70.1600629789353 * RADIANS_PER_DEGREE, 86 * RADIANS_PER_DEGREE);
     Geo3dShape geo3dShape = new Geo3dShape(planetModel, geo3dCircle, ctx);
     Rectangle rect = ctx.makeRectangle(-118, -114, -2.0, 32.0);
diff --git a/lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/Geo3dShapeWGS84ModelRectRelationTest.java b/lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/Geo3dShapeWGS84ModelRectRelationTest.java
index 1821a8b..c063d1b 100644
--- a/lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/Geo3dShapeWGS84ModelRectRelationTest.java
+++ b/lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/Geo3dShapeWGS84ModelRectRelationTest.java
@@ -21,6 +21,7 @@ import org.apache.lucene.geo3d.GeoArea;
 import org.apache.lucene.geo3d.GeoBBox;
 import org.apache.lucene.geo3d.GeoBBoxFactory;
 import org.apache.lucene.geo3d.GeoCircle;
+import org.apache.lucene.geo3d.GeoStandardCircle;
 import org.apache.lucene.geo3d.GeoPath;
 import org.apache.lucene.geo3d.GeoPoint;
 import org.apache.lucene.geo3d.PlanetModel;
@@ -50,7 +51,7 @@ public class Geo3dShapeWGS84ModelRectRelationTest extends Geo3dShapeRectRelation
   public void testFailure2() {
     final GeoBBox rect = GeoBBoxFactory.makeGeoBBox(planetModel, -74 * RADIANS_PER_DEGREE, -90 * RADIANS_PER_DEGREE,
         0 * RADIANS_PER_DEGREE, 26 * RADIANS_PER_DEGREE);
-    final GeoCircle circle = new GeoCircle(planetModel, -87.3647352103 * RADIANS_PER_DEGREE, 52.3769709972 * RADIANS_PER_DEGREE, 1 * RADIANS_PER_DEGREE);
+    final GeoCircle circle = new GeoStandardCircle(planetModel, -87.3647352103 * RADIANS_PER_DEGREE, 52.3769709972 * RADIANS_PER_DEGREE, 1 * RADIANS_PER_DEGREE);
     assertTrue(GeoArea.DISJOINT == rect.getRelationship(circle));
     // This is what the test failure claimed...
     //assertTrue(GeoArea.CONTAINS == rect.getRelationship(circle));
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoBaseCircle.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoBaseCircle.java
new file mode 100644
index 0000000..205d9f5
--- /dev/null
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoBaseCircle.java
@@ -0,0 +1,35 @@
+package org.apache.lucene.geo3d;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * GeoCircles have all the characteristics of GeoBaseDistanceShapes, plus GeoSizeable.
+ *
+ * @lucene.experimental
+ */
+public abstract class GeoBaseCircle extends GeoBaseDistanceShape implements GeoCircle {
+
+  /** Constructor.
+   *@param planetModel is the planet model to use.
+   */
+  public GeoBaseCircle(final PlanetModel planetModel) {
+    super(planetModel);
+  }
+
+}
+
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoBasePolygon.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoBasePolygon.java
new file mode 100644
index 0000000..fb09604
--- /dev/null
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoBasePolygon.java
@@ -0,0 +1,35 @@
+package org.apache.lucene.geo3d;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * GeoBasePolygon objects are the base class of most GeoPolygon objects.
+ *
+ * @lucene.experimental
+ */
+public abstract class GeoBasePolygon extends GeoBaseMembershipShape implements GeoPolygon {
+
+  /** Constructor.
+   *@param planetModel is the planet model to use.
+   */
+  public GeoBasePolygon(final PlanetModel planetModel) {
+    super(planetModel);
+  }
+
+}
+  
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoCircle.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoCircle.java
index 5bee373..f5d8b29 100755
--- a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoCircle.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoCircle.java
@@ -18,152 +18,9 @@ package org.apache.lucene.geo3d;
  */
 
 /**
- * Circular area with a center and radius.
+ * Interface describing circular area with a center and radius.
  *
  * @lucene.experimental
  */
-public class GeoCircle extends GeoBaseDistanceShape implements GeoSizeable {
-  /** Center of circle */
-  protected final GeoPoint center;
-  /** Cutoff angle of circle (not quite the same thing as radius) */
-  protected final double cutoffAngle;
-  /** The plane describing the circle (really an ellipse on a non-spherical world) */
-  protected final SidedPlane circlePlane;
-  /** A point that is on the world and on the circle plane */
-  protected final GeoPoint[] edgePoints;
-  /** Notable points for a circle -- there aren't any */
-  protected static final GeoPoint[] circlePoints = new GeoPoint[0];
-
-  /** Constructor.
-   *@param planetModel is the planet model.
-   *@param lat is the center latitude.
-   *@param lon is the center longitude.
-   *@param cutoffAngle is the cutoff angle for the circle.
-   */
-  public GeoCircle(final PlanetModel planetModel, final double lat, final double lon, final double cutoffAngle) {
-    super(planetModel);
-    if (lat < -Math.PI * 0.5 || lat > Math.PI * 0.5)
-      throw new IllegalArgumentException("Latitude out of bounds");
-    if (lon < -Math.PI || lon > Math.PI)
-      throw new IllegalArgumentException("Longitude out of bounds");
-    if (cutoffAngle < 0.0 || cutoffAngle > Math.PI)
-      throw new IllegalArgumentException("Cutoff angle out of bounds");
-    if (cutoffAngle < Vector.MINIMUM_RESOLUTION)
-      throw new IllegalArgumentException("Cutoff angle cannot be effectively zero");
-    this.center = new GeoPoint(planetModel, lat, lon);
-    // In an ellipsoidal world, cutoff distances make no sense, unfortunately.  Only membership
-    // can be used to make in/out determination.
-    this.cutoffAngle = cutoffAngle;
-    // Compute two points on the circle, with the right angle from the center.  We'll use these
-    // to obtain the perpendicular plane to the circle.
-    double upperLat = lat + cutoffAngle;
-    double upperLon = lon;
-    if (upperLat > Math.PI * 0.5) {
-      upperLon += Math.PI;
-      if (upperLon > Math.PI)
-        upperLon -= 2.0 * Math.PI;
-      upperLat = Math.PI - upperLat;
-    }
-    double lowerLat = lat - cutoffAngle;
-    double lowerLon = lon;
-    if (lowerLat < -Math.PI * 0.5) {
-      lowerLon += Math.PI;
-      if (lowerLon > Math.PI)
-        lowerLon -= 2.0 * Math.PI;
-      lowerLat = -Math.PI - lowerLat;
-    }
-    final GeoPoint upperPoint = new GeoPoint(planetModel, upperLat, upperLon);
-    final GeoPoint lowerPoint = new GeoPoint(planetModel, lowerLat, lowerLon);
-    if (Math.abs(cutoffAngle - Math.PI) < Vector.MINIMUM_RESOLUTION) {
-      // Circle is the whole world
-      this.circlePlane = null;
-      this.edgePoints = new GeoPoint[0];
-    } else {
-      // Construct normal plane
-      final Plane normalPlane = Plane.constructNormalizedZPlane(upperPoint, lowerPoint, center);
-      // Construct a sided plane that goes through the two points and whose normal is in the normalPlane.
-      this.circlePlane = SidedPlane.constructNormalizedPerpendicularSidedPlane(center, normalPlane, upperPoint, lowerPoint);
-      if (circlePlane == null)
-        throw new IllegalArgumentException("Couldn't construct circle plane, probably too small?  Cutoff angle = "+cutoffAngle+"; upperPoint = "+upperPoint+"; lowerPoint = "+lowerPoint);
-      final GeoPoint recomputedIntersectionPoint = circlePlane.getSampleIntersectionPoint(planetModel, normalPlane);
-      if (recomputedIntersectionPoint == null)
-        throw new IllegalArgumentException("Couldn't construct intersection point, probably circle too small?  Plane = "+circlePlane);
-      this.edgePoints = new GeoPoint[]{recomputedIntersectionPoint};
-    }
-  }
-
-  @Override
-  public double getRadius() {
-    return cutoffAngle;
-  }
-
-  @Override
-  public GeoPoint getCenter() {
-    return center;
-  }
-
-  @Override
-  protected double distance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
-    return distanceStyle.computeDistance(this.center, x, y, z);
-  }
-
-  @Override
-  protected double outsideDistance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
-    return distanceStyle.computeDistance(planetModel, circlePlane, x, y, z);
-  }
-
-  @Override
-  public boolean isWithin(final double x, final double y, final double z) {
-    if (circlePlane == null) {
-      return true;
-    }
-    // Fastest way of determining membership
-    return circlePlane.isWithin(x, y, z);
-  }
-
-  @Override
-  public GeoPoint[] getEdgePoints() {
-    return edgePoints;
-  }
-
-  @Override
-  public boolean intersects(final Plane p, final GeoPoint[] notablePoints, final Membership... bounds) {
-    if (circlePlane == null) {
-      return false;
-    }
-    return circlePlane.intersects(planetModel, p, notablePoints, circlePoints, bounds);
-  }
-
-  @Override
-  public void getBounds(Bounds bounds) {
-    super.getBounds(bounds);
-    if (circlePlane == null) {
-      // Entire world; should already be covered
-      return;
-    }
-    bounds.addPoint(center);
-    bounds.addPlane(planetModel, circlePlane);
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (!(o instanceof GeoCircle))
-      return false;
-    GeoCircle other = (GeoCircle) o;
-    return super.equals(other) && other.center.equals(center) && other.cutoffAngle == cutoffAngle;
-  }
-
-  @Override
-  public int hashCode() {
-    int result = super.hashCode();
-    result = 31 * result + center.hashCode();
-    long temp = Double.doubleToLongBits(cutoffAngle);
-    result = 31 * result + (int) (temp ^ (temp >>> 32));
-    return result;
-  }
-
-  @Override
-  public String toString() {
-    return "GeoCircle: {planetmodel=" + planetModel+", center=" + center + ", radius=" + cutoffAngle + "(" + cutoffAngle * 180.0 / Math.PI + ")}";
-  }
+public interface GeoCircle extends GeoDistanceShape, GeoSizeable {
 }
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoCircleFactory.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoCircleFactory.java
new file mode 100644
index 0000000..8114811
--- /dev/null
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoCircleFactory.java
@@ -0,0 +1,46 @@
+package org.apache.lucene.geo3d;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.ArrayList;
+import java.util.BitSet;
+import java.util.List;
+
+/**
+ * Class which constructs a GeoCircle representing an arbitrary circle.
+ *
+ * @lucene.experimental
+ */
+public class GeoCircleFactory {
+  private GeoCircleFactory() {
+  }
+
+  /**
+   * Create a GeoCircle of the right kind given the specified bounds.
+   * @param planetModel is the planet model.
+   * @param latitude is the center latitude.
+   * @param longitude is the center longitude.
+   * @param radius is the radius angle.
+   * @return a GeoCircle corresponding to what was specified.
+   */
+  public static GeoCircle makeGeoCircle(final PlanetModel planetModel, final double latitude, final double longitude, final double radius) {
+    // TODO: MHL for degenerate cases
+    return new GeoStandardCircle(planetModel, latitude, longitude, radius);
+  }
+
+}
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoCompositePolygon.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoCompositePolygon.java
new file mode 100644
index 0000000..0d05951
--- /dev/null
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoCompositePolygon.java
@@ -0,0 +1,32 @@
+package org.apache.lucene.geo3d;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * GeoCompositePolygon is a specific implementation of GeoMembershipShape, which implements GeoPolygon explicitly.
+ *
+ * @lucene.experimental
+ */
+public class GeoCompositePolygon extends GeoCompositeMembershipShape implements GeoPolygon {
+  /** Constructor.
+   */
+  public GeoCompositePolygon() {
+  }
+
+}
+  
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoConvexPolygon.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoConvexPolygon.java
index fc78858..2dc7e02 100755
--- a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoConvexPolygon.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoConvexPolygon.java
@@ -29,7 +29,7 @@ import java.util.List;
  *
  * @lucene.experimental
  */
-public class GeoConvexPolygon extends GeoBaseMembershipShape {
+public class GeoConvexPolygon extends GeoBasePolygon {
   /** The list of polygon points */
   protected final List<GeoPoint> points;
   /** A bitset describing, for each edge, whether it is internal or not */
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoPolygon.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoPolygon.java
new file mode 100644
index 0000000..35fd919
--- /dev/null
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoPolygon.java
@@ -0,0 +1,27 @@
+package org.apache.lucene.geo3d;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * GeoPolygon interface description.
+ *
+ * @lucene.experimental
+ */
+public interface GeoPolygon extends GeoMembershipShape {
+
+}
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoPolygonFactory.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoPolygonFactory.java
index d3ff22d..b63b73e 100755
--- a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoPolygonFactory.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoPolygonFactory.java
@@ -36,9 +36,9 @@ public class GeoPolygonFactory {
    * @param pointList        is a list of the GeoPoints to build an arbitrary polygon out of.
    * @param convexPointIndex is the index of a single convex point whose conformation with
    *                         its neighbors determines inside/outside for the entire polygon.
-   * @return a GeoMembershipShape corresponding to what was specified.
+   * @return a GeoPolygon corresponding to what was specified.
    */
-  public static GeoMembershipShape makeGeoPolygon(final PlanetModel planetModel, final List<GeoPoint> pointList, final int convexPointIndex) {
+  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel, final List<GeoPoint> pointList, final int convexPointIndex) {
     // The basic operation uses a set of points, two points determining one particular edge, and a sided plane
     // describing membership.
     return buildPolygonShape(planetModel, pointList, convexPointIndex, getLegalIndex(convexPointIndex + 1, pointList.size()),
@@ -55,14 +55,14 @@ public class GeoPolygonFactory {
    * @param isInternalEdge is true if the specified edge is an internal one.
    * @return a GeoMembershipShape corresponding to what was specified.
    */
-  public static GeoMembershipShape buildPolygonShape(final PlanetModel planetModel, final List<GeoPoint> pointsList, final int startPointIndex, final int endPointIndex, final SidedPlane startingEdge, final boolean isInternalEdge) {
+  public static GeoPolygon buildPolygonShape(final PlanetModel planetModel, final List<GeoPoint> pointsList, final int startPointIndex, final int endPointIndex, final SidedPlane startingEdge, final boolean isInternalEdge) {
     // Algorithm as follows:
     // Start with sided edge.  Go through all points in some order.  For each new point, determine if the point is within all edges considered so far.
     // If not, put it into a list of points for recursion.  If it is within, add new edge and keep going.
     // Once we detect a point that is within, if there are points put aside for recursion, then call recursively.
 
     // Current composite.  This is what we'll actually be returning.
-    final GeoCompositeMembershipShape rval = new GeoCompositeMembershipShape();
+    final GeoCompositePolygon rval = new GeoCompositePolygon();
 
     final List<GeoPoint> recursionList = new ArrayList<GeoPoint>();
     final List<GeoPoint> currentList = new ArrayList<GeoPoint>();
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoStandardCircle.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoStandardCircle.java
new file mode 100755
index 0000000..d90908e
--- /dev/null
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoStandardCircle.java
@@ -0,0 +1,169 @@
+package org.apache.lucene.geo3d;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Circular area with a center and radius.
+ *
+ * @lucene.experimental
+ */
+public class GeoStandardCircle extends GeoBaseCircle {
+  /** Center of circle */
+  protected final GeoPoint center;
+  /** Cutoff angle of circle (not quite the same thing as radius) */
+  protected final double cutoffAngle;
+  /** The plane describing the circle (really an ellipse on a non-spherical world) */
+  protected final SidedPlane circlePlane;
+  /** A point that is on the world and on the circle plane */
+  protected final GeoPoint[] edgePoints;
+  /** Notable points for a circle -- there aren't any */
+  protected static final GeoPoint[] circlePoints = new GeoPoint[0];
+
+  /** Constructor.
+   *@param planetModel is the planet model.
+   *@param lat is the center latitude.
+   *@param lon is the center longitude.
+   *@param cutoffAngle is the cutoff angle for the circle.
+   */
+  public GeoStandardCircle(final PlanetModel planetModel, final double lat, final double lon, final double cutoffAngle) {
+    super(planetModel);
+    if (lat < -Math.PI * 0.5 || lat > Math.PI * 0.5)
+      throw new IllegalArgumentException("Latitude out of bounds");
+    if (lon < -Math.PI || lon > Math.PI)
+      throw new IllegalArgumentException("Longitude out of bounds");
+    if (cutoffAngle < 0.0 || cutoffAngle > Math.PI)
+      throw new IllegalArgumentException("Cutoff angle out of bounds");
+    if (cutoffAngle < Vector.MINIMUM_RESOLUTION)
+      throw new IllegalArgumentException("Cutoff angle cannot be effectively zero");
+    this.center = new GeoPoint(planetModel, lat, lon);
+    // In an ellipsoidal world, cutoff distances make no sense, unfortunately.  Only membership
+    // can be used to make in/out determination.
+    this.cutoffAngle = cutoffAngle;
+    // Compute two points on the circle, with the right angle from the center.  We'll use these
+    // to obtain the perpendicular plane to the circle.
+    double upperLat = lat + cutoffAngle;
+    double upperLon = lon;
+    if (upperLat > Math.PI * 0.5) {
+      upperLon += Math.PI;
+      if (upperLon > Math.PI)
+        upperLon -= 2.0 * Math.PI;
+      upperLat = Math.PI - upperLat;
+    }
+    double lowerLat = lat - cutoffAngle;
+    double lowerLon = lon;
+    if (lowerLat < -Math.PI * 0.5) {
+      lowerLon += Math.PI;
+      if (lowerLon > Math.PI)
+        lowerLon -= 2.0 * Math.PI;
+      lowerLat = -Math.PI - lowerLat;
+    }
+    final GeoPoint upperPoint = new GeoPoint(planetModel, upperLat, upperLon);
+    final GeoPoint lowerPoint = new GeoPoint(planetModel, lowerLat, lowerLon);
+    if (Math.abs(cutoffAngle - Math.PI) < Vector.MINIMUM_RESOLUTION) {
+      // Circle is the whole world
+      this.circlePlane = null;
+      this.edgePoints = new GeoPoint[0];
+    } else {
+      // Construct normal plane
+      final Plane normalPlane = Plane.constructNormalizedZPlane(upperPoint, lowerPoint, center);
+      // Construct a sided plane that goes through the two points and whose normal is in the normalPlane.
+      this.circlePlane = SidedPlane.constructNormalizedPerpendicularSidedPlane(center, normalPlane, upperPoint, lowerPoint);
+      if (circlePlane == null)
+        throw new IllegalArgumentException("Couldn't construct circle plane, probably too small?  Cutoff angle = "+cutoffAngle+"; upperPoint = "+upperPoint+"; lowerPoint = "+lowerPoint);
+      final GeoPoint recomputedIntersectionPoint = circlePlane.getSampleIntersectionPoint(planetModel, normalPlane);
+      if (recomputedIntersectionPoint == null)
+        throw new IllegalArgumentException("Couldn't construct intersection point, probably circle too small?  Plane = "+circlePlane);
+      this.edgePoints = new GeoPoint[]{recomputedIntersectionPoint};
+    }
+  }
+
+  @Override
+  public double getRadius() {
+    return cutoffAngle;
+  }
+
+  @Override
+  public GeoPoint getCenter() {
+    return center;
+  }
+
+  @Override
+  protected double distance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
+    return distanceStyle.computeDistance(this.center, x, y, z);
+  }
+
+  @Override
+  protected double outsideDistance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
+    return distanceStyle.computeDistance(planetModel, circlePlane, x, y, z);
+  }
+
+  @Override
+  public boolean isWithin(final double x, final double y, final double z) {
+    if (circlePlane == null) {
+      return true;
+    }
+    // Fastest way of determining membership
+    return circlePlane.isWithin(x, y, z);
+  }
+
+  @Override
+  public GeoPoint[] getEdgePoints() {
+    return edgePoints;
+  }
+
+  @Override
+  public boolean intersects(final Plane p, final GeoPoint[] notablePoints, final Membership... bounds) {
+    if (circlePlane == null) {
+      return false;
+    }
+    return circlePlane.intersects(planetModel, p, notablePoints, circlePoints, bounds);
+  }
+
+  @Override
+  public void getBounds(Bounds bounds) {
+    super.getBounds(bounds);
+    if (circlePlane == null) {
+      // Entire world; should already be covered
+      return;
+    }
+    bounds.addPoint(center);
+    bounds.addPlane(planetModel, circlePlane);
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (!(o instanceof GeoStandardCircle))
+      return false;
+    GeoStandardCircle other = (GeoStandardCircle) o;
+    return super.equals(other) && other.center.equals(center) && other.cutoffAngle == cutoffAngle;
+  }
+
+  @Override
+  public int hashCode() {
+    int result = super.hashCode();
+    result = 31 * result + center.hashCode();
+    long temp = Double.doubleToLongBits(cutoffAngle);
+    result = 31 * result + (int) (temp ^ (temp >>> 32));
+    return result;
+  }
+
+  @Override
+  public String toString() {
+    return "GeoStandardCircle: {planetmodel=" + planetModel+", center=" + center + ", radius=" + cutoffAngle + "(" + cutoffAngle * 180.0 / Math.PI + ")}";
+  }
+}
diff --git a/lucene/spatial3d/src/test/org/apache/lucene/bkdtree3d/TestGeo3DPointField.java b/lucene/spatial3d/src/test/org/apache/lucene/bkdtree3d/TestGeo3DPointField.java
index 2ad92ff..12d303d 100644
--- a/lucene/spatial3d/src/test/org/apache/lucene/bkdtree3d/TestGeo3DPointField.java
+++ b/lucene/spatial3d/src/test/org/apache/lucene/bkdtree3d/TestGeo3DPointField.java
@@ -26,7 +26,7 @@ import org.apache.lucene.document.NumericDocValuesField;
 import org.apache.lucene.geo3d.GeoArea;
 import org.apache.lucene.geo3d.GeoAreaFactory;
 import org.apache.lucene.geo3d.GeoBBoxFactory;
-import org.apache.lucene.geo3d.GeoCircle;
+import org.apache.lucene.geo3d.GeoStandardCircle;
 import org.apache.lucene.geo3d.GeoPath;
 import org.apache.lucene.geo3d.GeoPoint;
 import org.apache.lucene.geo3d.GeoPolygonFactory;
@@ -101,7 +101,7 @@ public class TestGeo3DPointField extends LuceneTestCase {
     IndexSearcher s = newSearcher(r, false);
     assertEquals(1, s.search(new PointInGeo3DShapeQuery(PlanetModel.WGS84,
                                                         "field",
-                                                        new GeoCircle(PlanetModel.WGS84, toRadians(50), toRadians(-97), Math.PI/180.)), 1).totalHits);
+                                                        new GeoStandardCircle(PlanetModel.WGS84, toRadians(50), toRadians(-97), Math.PI/180.)), 1).totalHits);
     w.close();
     r.close();
     dir.close();
@@ -122,7 +122,7 @@ public class TestGeo3DPointField extends LuceneTestCase {
     try {
       s.search(new PointInGeo3DShapeQuery(PlanetModel.SPHERE,
                                           "field",
-                                          new GeoCircle(PlanetModel.WGS84, toRadians(50), toRadians(-97), Math.PI/180.)), 1);
+                                          new GeoStandardCircle(PlanetModel.WGS84, toRadians(50), toRadians(-97), Math.PI/180.)), 1);
       fail("did not hit exc");      
     } catch (IllegalStateException ise) {
       // expected
@@ -845,7 +845,7 @@ public class TestGeo3DPointField extends LuceneTestCase {
         }
 
         try {
-          return new GeoCircle(planetModel, lat, lon, angle);
+          return new GeoStandardCircle(planetModel, lat, lon, angle);
         } catch (IllegalArgumentException iae) {
           // angle is too small; try again:
           continue;
diff --git a/lucene/spatial3d/src/test/org/apache/lucene/geo3d/GeoCircleTest.java b/lucene/spatial3d/src/test/org/apache/lucene/geo3d/GeoCircleTest.java
index f99fdc0..97ba899 100755
--- a/lucene/spatial3d/src/test/org/apache/lucene/geo3d/GeoCircleTest.java
+++ b/lucene/spatial3d/src/test/org/apache/lucene/geo3d/GeoCircleTest.java
@@ -31,7 +31,7 @@ public class GeoCircleTest extends LuceneTestCase {
   public void testCircleDistance() {
     GeoCircle c;
     GeoPoint gp;
-    c = new GeoCircle(PlanetModel.SPHERE, 0.0, -0.5, 0.1);
+    c = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, -0.5, 0.1);
     gp = new GeoPoint(PlanetModel.SPHERE, 0.0, 0.0);
     assertEquals(Double.MAX_VALUE, c.computeDistance(DistanceStyle.ARC,gp), 0.0);
     assertEquals(Double.MAX_VALUE, c.computeDistance(DistanceStyle.NORMAL,gp), 0.0);
@@ -50,7 +50,7 @@ public class GeoCircleTest extends LuceneTestCase {
   public void testCircleFullWorld() {
     GeoCircle c;
     GeoPoint gp;
-    c = new GeoCircle(PlanetModel.SPHERE, 0.0, -0.5, Math.PI);
+    c = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, -0.5, Math.PI);
     gp = new GeoPoint(PlanetModel.SPHERE, 0.0, 0.0);
     assertTrue(c.isWithin(gp));
     gp = new GeoPoint(PlanetModel.SPHERE, 0.0, -0.5);
@@ -74,7 +74,7 @@ public class GeoCircleTest extends LuceneTestCase {
   public void testCirclePointWithin() {
     GeoCircle c;
     GeoPoint gp;
-    c = new GeoCircle(PlanetModel.SPHERE, 0.0, -0.5, 0.1);
+    c = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, -0.5, 0.1);
     gp = new GeoPoint(PlanetModel.SPHERE, 0.0, 0.0);
     assertFalse(c.isWithin(gp));
     assertEquals(0.4,c.computeOutsideDistance(DistanceStyle.ARC,gp),1e-12);
@@ -103,7 +103,7 @@ public class GeoCircleTest extends LuceneTestCase {
     int relationship;
 
     // ...
-    c = new GeoCircle(PlanetModel.WGS84, -0.005931145568901605, -0.001942031539653079, 1.2991918568260272E-4);
+    c = new GeoStandardCircle(PlanetModel.WGS84, -0.005931145568901605, -0.001942031539653079, 1.2991918568260272E-4);
     area = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84, 1.001098377143621, 1.001100011578687, -0.00207467080358696, -0.0018136665346280983, -0.006067808248760161, -0.005807683665759485);
     p1 = new GeoPoint(PlanetModel.WGS84, -0.00591253844632244, -0.0020069187259065093);
     p2 = new GeoPoint(1.001099185736782, -0.0020091272069679327, -0.005919118245803968);
@@ -113,7 +113,7 @@ public class GeoCircleTest extends LuceneTestCase {
     assertTrue(relationship != GeoArea.DISJOINT);
 
     // Twelfth BKD discovered failure
-    c = new GeoCircle(PlanetModel.WGS84,-0.00824379317765984,-0.0011677469001838581,0.0011530035396910402);
+    c = new GeoStandardCircle(PlanetModel.WGS84,-0.00824379317765984,-0.0011677469001838581,0.0011530035396910402);
     p1 = new GeoPoint(PlanetModel.WGS84,-0.006505092992723671,0.007654282718327381);
     p2 = new GeoPoint(1.0010681673665647,0.007662608264336381,-0.006512324005914593);
     assertTrue(!c.isWithin(p1));
@@ -130,7 +130,7 @@ public class GeoCircleTest extends LuceneTestCase {
     assertTrue(!area.isWithin(p2));
     
     // Eleventh BKD discovered failure
-    c = new GeoCircle(PlanetModel.SPHERE,-0.004431288600558495,-0.003687846671278374,1.704543429364245E-8);
+    c = new GeoStandardCircle(PlanetModel.SPHERE,-0.004431288600558495,-0.003687846671278374,1.704543429364245E-8);
     xyzb = new XYZBounds();
     c.getBounds(xyzb);
     area = GeoAreaFactory.makeGeoArea(PlanetModel.SPHERE, 
@@ -140,7 +140,7 @@ public class GeoCircleTest extends LuceneTestCase {
     assertTrue(GeoArea.WITHIN == relationship || GeoArea.OVERLAPS == relationship);
 
     // Tenth BKD discovered failure
-    c = new GeoCircle(PlanetModel.WGS84,-0.0018829770647349636,-0.001969499061382591,1.3045439293158305E-5);
+    c = new GeoStandardCircle(PlanetModel.WGS84,-0.0018829770647349636,-0.001969499061382591,1.3045439293158305E-5);
     xyzb = new XYZBounds();
     c.getBounds(xyzb);
     area = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84, 
@@ -150,7 +150,7 @@ public class GeoCircleTest extends LuceneTestCase {
     assertTrue(GeoArea.WITHIN == relationship || GeoArea.OVERLAPS == relationship);
 
     // Ninth BKD discovered failure
-    c = new GeoCircle(PlanetModel.SPHERE,-4.211990380885122E-5,-0.0022958453508173044,1.4318475623498535E-5);
+    c = new GeoStandardCircle(PlanetModel.SPHERE,-4.211990380885122E-5,-0.0022958453508173044,1.4318475623498535E-5);
     xyzb = new XYZBounds();
     c.getBounds(xyzb);
     area = GeoAreaFactory.makeGeoArea(PlanetModel.SPHERE, 
@@ -160,7 +160,7 @@ public class GeoCircleTest extends LuceneTestCase {
     assertTrue(GeoArea.WITHIN == relationship || GeoArea.OVERLAPS == relationship);
     
     // Eighth BKD discovered failure
-    c = new GeoCircle(PlanetModel.SPHERE,0.005321278689117842,-0.00216937368755372,1.5306034422500785E-4);
+    c = new GeoStandardCircle(PlanetModel.SPHERE,0.005321278689117842,-0.00216937368755372,1.5306034422500785E-4);
     xyzb = new XYZBounds();
     c.getBounds(xyzb);
     area = GeoAreaFactory.makeGeoArea(PlanetModel.SPHERE, 
@@ -170,7 +170,7 @@ public class GeoCircleTest extends LuceneTestCase {
     assertTrue(GeoArea.WITHIN == relationship || GeoArea.OVERLAPS == relationship);
 
     // Seventh BKD discovered failure
-    c = new GeoCircle(PlanetModel.SPHERE,-0.0021627146783861745, -0.0017298167021592304,2.0818312293195752E-4);
+    c = new GeoStandardCircle(PlanetModel.SPHERE,-0.0021627146783861745, -0.0017298167021592304,2.0818312293195752E-4);
     xyzb = new XYZBounds();
     c.getBounds(xyzb);
     area = GeoAreaFactory.makeGeoArea(PlanetModel.SPHERE, 
@@ -180,7 +180,7 @@ public class GeoCircleTest extends LuceneTestCase {
     assertTrue(GeoArea.WITHIN == relationship || GeoArea.OVERLAPS == relationship);
 
     // Sixth BKD discovered failure
-    c = new GeoCircle(PlanetModel.WGS84,-0.006450320645814321,0.004660694205115142,0.00489710732634323);
+    c = new GeoStandardCircle(PlanetModel.WGS84,-0.006450320645814321,0.004660694205115142,0.00489710732634323);
     //xyzb = new XYZBounds();
     //c.getBounds(xyzb);
     //System.err.println("xmin="+xyzb.getMinimumX()+", xmax="+xyzb.getMaximumX()+",ymin="+xyzb.getMinimumY()+", ymax="+xyzb.getMaximumY()+",zmin="+xyzb.getMinimumZ()+", zmax="+xyzb.getMaximumZ());
@@ -201,7 +201,7 @@ public class GeoCircleTest extends LuceneTestCase {
     */
     
     // Fifth BKD discovered failure
-    c = new GeoCircle(PlanetModel.SPHERE, -0.004282454525970269, -1.6739831367422277E-4, 1.959639723134033E-6);
+    c = new GeoStandardCircle(PlanetModel.SPHERE, -0.004282454525970269, -1.6739831367422277E-4, 1.959639723134033E-6);
     assertTrue(c.isWithin(c.getEdgePoints()[0]));
     xyzb = new XYZBounds();
     c.getBounds(xyzb);
@@ -210,7 +210,7 @@ public class GeoCircleTest extends LuceneTestCase {
     assertTrue(GeoArea.WITHIN == area.getRelationship(c) || GeoArea.OVERLAPS == area.getRelationship(c));
     
     // Fourth BKD discovered failure
-    c = new GeoCircle(PlanetModel.SPHERE, -0.0048795517261255, 0.004053904306995974, 5.93699764258874E-6);
+    c = new GeoStandardCircle(PlanetModel.SPHERE, -0.0048795517261255, 0.004053904306995974, 5.93699764258874E-6);
     xyzb = new XYZBounds();
     c.getBounds(xyzb);
     area = GeoAreaFactory.makeGeoArea(PlanetModel.SPHERE,
@@ -218,7 +218,7 @@ public class GeoCircleTest extends LuceneTestCase {
     assertTrue(GeoArea.WITHIN == area.getRelationship(c) || GeoArea.OVERLAPS == area.getRelationship(c));
     
     // Yet another test case from BKD
-    c = new GeoCircle(PlanetModel.WGS84, 0.006229478708446979, 0.005570196723795424, 3.840276763694387E-5);
+    c = new GeoStandardCircle(PlanetModel.WGS84, 0.006229478708446979, 0.005570196723795424, 3.840276763694387E-5);
     xyzb = new XYZBounds();
     c.getBounds(xyzb);
     area = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84,
@@ -233,7 +233,7 @@ public class GeoCircleTest extends LuceneTestCase {
     assertTrue(area.isWithin(p2));
     
     // Another test case from BKD
-    c = new GeoCircle(PlanetModel.SPHERE, -0.005955031040627789, -0.0029274772647399153, 1.601488279374338E-5);
+    c = new GeoStandardCircle(PlanetModel.SPHERE, -0.005955031040627789, -0.0029274772647399153, 1.601488279374338E-5);
     xyzb = new XYZBounds();
     c.getBounds(xyzb);
     area = GeoAreaFactory.makeGeoArea(PlanetModel.SPHERE,
@@ -243,7 +243,7 @@ public class GeoCircleTest extends LuceneTestCase {
     assertTrue(relationship == GeoArea.WITHIN || relationship == GeoArea.OVERLAPS);
     
     // Test case from BKD
-    c = new GeoCircle(PlanetModel.SPHERE, -0.765816119338, 0.991848766844, 0.8153163226330487);
+    c = new GeoStandardCircle(PlanetModel.SPHERE, -0.765816119338, 0.991848766844, 0.8153163226330487);
     p1 = new GeoPoint(0.7692262265236023, -0.055089298115534646, -0.6365973465711254);
     assertTrue(c.isWithin(p1));
     xyzb = new XYZBounds();
@@ -253,7 +253,7 @@ public class GeoCircleTest extends LuceneTestCase {
     assertTrue(p1.z >= xyzb.getMinimumZ() && p1.z <= xyzb.getMaximumZ());
     
     // Vertical circle cases
-    c = new GeoCircle(PlanetModel.SPHERE, 0.0, -0.5, 0.1);
+    c = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, -0.5, 0.1);
     b = new LatLonBounds();
     c.getBounds(b);
     assertFalse(b.checkNoLongitudeBound());
@@ -263,7 +263,7 @@ public class GeoCircleTest extends LuceneTestCase {
     assertEquals(-0.4, b.getRightLongitude(), 0.000001);
     assertEquals(-0.1, b.getMinLatitude(), 0.000001);
     assertEquals(0.1, b.getMaxLatitude(), 0.000001);
-    c = new GeoCircle(PlanetModel.SPHERE, 0.0, 0.5, 0.1);
+    c = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, 0.5, 0.1);
     b = new LatLonBounds();
     c.getBounds(b);
     assertFalse(b.checkNoLongitudeBound());
@@ -273,7 +273,7 @@ public class GeoCircleTest extends LuceneTestCase {
     assertEquals(0.6, b.getRightLongitude(), 0.000001);
     assertEquals(-0.1, b.getMinLatitude(), 0.000001);
     assertEquals(0.1, b.getMaxLatitude(), 0.000001);
-    c = new GeoCircle(PlanetModel.SPHERE, 0.0, 0.0, 0.1);
+    c = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, 0.0, 0.1);
     b = new LatLonBounds();
     c.getBounds(b);
     assertFalse(b.checkNoLongitudeBound());
@@ -283,7 +283,7 @@ public class GeoCircleTest extends LuceneTestCase {
     assertEquals(0.1, b.getRightLongitude(), 0.000001);
     assertEquals(-0.1, b.getMinLatitude(), 0.000001);
     assertEquals(0.1, b.getMaxLatitude(), 0.000001);
-    c = new GeoCircle(PlanetModel.SPHERE, 0.0, Math.PI, 0.1);
+    c = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, Math.PI, 0.1);
     b = new LatLonBounds();
     c.getBounds(b);
     assertFalse(b.checkNoLongitudeBound());
@@ -294,14 +294,14 @@ public class GeoCircleTest extends LuceneTestCase {
     assertEquals(-0.1, b.getMinLatitude(), 0.000001);
     assertEquals(0.1, b.getMaxLatitude(), 0.000001);
     // Horizontal circle cases
-    c = new GeoCircle(PlanetModel.SPHERE, Math.PI * 0.5, 0.0, 0.1);
+    c = new GeoStandardCircle(PlanetModel.SPHERE, Math.PI * 0.5, 0.0, 0.1);
     b = new LatLonBounds();
     c.getBounds(b);
     assertTrue(b.checkNoLongitudeBound());
     assertTrue(b.checkNoTopLatitudeBound());
     assertFalse(b.checkNoBottomLatitudeBound());
     assertEquals(Math.PI * 0.5 - 0.1, b.getMinLatitude(), 0.000001);
-    c = new GeoCircle(PlanetModel.SPHERE, -Math.PI * 0.5, 0.0, 0.1);
+    c = new GeoStandardCircle(PlanetModel.SPHERE, -Math.PI * 0.5, 0.0, 0.1);
     b = new LatLonBounds();
     c.getBounds(b);
     assertTrue(b.checkNoLongitudeBound());
@@ -310,7 +310,7 @@ public class GeoCircleTest extends LuceneTestCase {
     assertEquals(-Math.PI * 0.5 + 0.1, b.getMaxLatitude(), 0.000001);
 
     // Now do a somewhat tilted plane, facing different directions.
-    c = new GeoCircle(PlanetModel.SPHERE, 0.01, 0.0, 0.1);
+    c = new GeoStandardCircle(PlanetModel.SPHERE, 0.01, 0.0, 0.1);
     b = new LatLonBounds();
     c.getBounds(b);
     assertFalse(b.checkNoLongitudeBound());
@@ -321,7 +321,7 @@ public class GeoCircleTest extends LuceneTestCase {
     assertEquals(-0.1, b.getLeftLongitude(), 0.00001);
     assertEquals(0.1, b.getRightLongitude(), 0.00001);
 
-    c = new GeoCircle(PlanetModel.SPHERE, 0.01, Math.PI, 0.1);
+    c = new GeoStandardCircle(PlanetModel.SPHERE, 0.01, Math.PI, 0.1);
     b = new LatLonBounds();
     c.getBounds(b);
     assertFalse(b.checkNoLongitudeBound());
@@ -332,7 +332,7 @@ public class GeoCircleTest extends LuceneTestCase {
     assertEquals(Math.PI - 0.1, b.getLeftLongitude(), 0.00001);
     assertEquals(-Math.PI + 0.1, b.getRightLongitude(), 0.00001);
 
-    c = new GeoCircle(PlanetModel.SPHERE, 0.01, Math.PI * 0.5, 0.1);
+    c = new GeoStandardCircle(PlanetModel.SPHERE, 0.01, Math.PI * 0.5, 0.1);
     b = new LatLonBounds();
     c.getBounds(b);
     assertFalse(b.checkNoLongitudeBound());
@@ -343,7 +343,7 @@ public class GeoCircleTest extends LuceneTestCase {
     assertEquals(Math.PI * 0.5 - 0.1, b.getLeftLongitude(), 0.00001);
     assertEquals(Math.PI * 0.5 + 0.1, b.getRightLongitude(), 0.00001);
 
-    c = new GeoCircle(PlanetModel.SPHERE, 0.01, -Math.PI * 0.5, 0.1);
+    c = new GeoStandardCircle(PlanetModel.SPHERE, 0.01, -Math.PI * 0.5, 0.1);
     b = new LatLonBounds();
     c.getBounds(b);
     assertFalse(b.checkNoLongitudeBound());
@@ -355,7 +355,7 @@ public class GeoCircleTest extends LuceneTestCase {
     assertEquals(-Math.PI * 0.5 + 0.1, b.getRightLongitude(), 0.00001);
 
     // Slightly tilted, PI/4 direction.
-    c = new GeoCircle(PlanetModel.SPHERE, 0.01, Math.PI * 0.25, 0.1);
+    c = new GeoStandardCircle(PlanetModel.SPHERE, 0.01, Math.PI * 0.25, 0.1);
     b = new LatLonBounds();
     c.getBounds(b);
     assertFalse(b.checkNoLongitudeBound());
@@ -366,7 +366,7 @@ public class GeoCircleTest extends LuceneTestCase {
     assertEquals(Math.PI * 0.25 - 0.1, b.getLeftLongitude(), 0.00001);
     assertEquals(Math.PI * 0.25 + 0.1, b.getRightLongitude(), 0.00001);
 
-    c = new GeoCircle(PlanetModel.SPHERE, 0.01, -Math.PI * 0.25, 0.1);
+    c = new GeoStandardCircle(PlanetModel.SPHERE, 0.01, -Math.PI * 0.25, 0.1);
     b = new LatLonBounds();
     c.getBounds(b);
     assertFalse(b.checkNoLongitudeBound());
@@ -377,7 +377,7 @@ public class GeoCircleTest extends LuceneTestCase {
     assertEquals(-Math.PI * 0.25 - 0.1, b.getLeftLongitude(), 0.00001);
     assertEquals(-Math.PI * 0.25 + 0.1, b.getRightLongitude(), 0.00001);
 
-    c = new GeoCircle(PlanetModel.SPHERE, -0.01, Math.PI * 0.25, 0.1);
+    c = new GeoStandardCircle(PlanetModel.SPHERE, -0.01, Math.PI * 0.25, 0.1);
     b = new LatLonBounds();
     c.getBounds(b);
     assertFalse(b.checkNoLongitudeBound());
@@ -388,7 +388,7 @@ public class GeoCircleTest extends LuceneTestCase {
     assertEquals(Math.PI * 0.25 - 0.1, b.getLeftLongitude(), 0.00001);
     assertEquals(Math.PI * 0.25 + 0.1, b.getRightLongitude(), 0.00001);
 
-    c = new GeoCircle(PlanetModel.SPHERE, -0.01, -Math.PI * 0.25, 0.1);
+    c = new GeoStandardCircle(PlanetModel.SPHERE, -0.01, -Math.PI * 0.25, 0.1);
     b = new LatLonBounds();
     c.getBounds(b);
     assertFalse(b.checkNoLongitudeBound());
@@ -400,7 +400,7 @@ public class GeoCircleTest extends LuceneTestCase {
     assertEquals(-Math.PI * 0.25 + 0.1, b.getRightLongitude(), 0.00001);
 
     // Now do a somewhat tilted plane.
-    c = new GeoCircle(PlanetModel.SPHERE, 0.01, -0.5, 0.1);
+    c = new GeoStandardCircle(PlanetModel.SPHERE, 0.01, -0.5, 0.1);
     b = new LatLonBounds();
     c.getBounds(b);
     assertFalse(b.checkNoLongitudeBound());
diff --git a/lucene/spatial3d/src/test/org/apache/lucene/geo3d/GeoModelTest.java b/lucene/spatial3d/src/test/org/apache/lucene/geo3d/GeoModelTest.java
index 683441d..7f0be1f 100644
--- a/lucene/spatial3d/src/test/org/apache/lucene/geo3d/GeoModelTest.java
+++ b/lucene/spatial3d/src/test/org/apache/lucene/geo3d/GeoModelTest.java
@@ -39,7 +39,7 @@ public class GeoModelTest {
     final GeoPoint point1 = new GeoPoint(scaledModel, Math.PI * 0.25, 0.0);
     final GeoPoint point2 = new GeoPoint(scaledModel, Math.PI * 0.125, 0.0);
     
-    GeoCircle circle = new GeoCircle(scaledModel, Math.PI * 0.5, 0.0, 0.01);
+    GeoCircle circle = new GeoStandardCircle(scaledModel, Math.PI * 0.5, 0.0, 0.01);
     assertTrue(circle.isWithin(northPole));
     assertFalse(circle.isWithin(southPole));
     assertFalse(circle.isWithin(point1));
@@ -51,7 +51,7 @@ public class GeoModelTest {
     assertFalse(bounds.checkNoBottomLatitudeBound());
     assertEquals(Math.PI * 0.5 - 0.01, bounds.getMinLatitude(), 0.01);
 
-    circle = new GeoCircle(scaledModel, Math.PI * 0.25, 0.0, 0.01);
+    circle = new GeoStandardCircle(scaledModel, Math.PI * 0.25, 0.0, 0.01);
     assertTrue(circle.isWithin(point1));
     assertFalse(circle.isWithin(northPole));
     assertFalse(circle.isWithin(southPole));
@@ -65,7 +65,7 @@ public class GeoModelTest {
     assertEquals(-0.0125, bounds.getLeftLongitude(), 0.0001);
     assertEquals(0.0125, bounds.getRightLongitude(), 0.0001);
 
-    circle = new GeoCircle(scaledModel, Math.PI * 0.125, 0.0, 0.01);
+    circle = new GeoStandardCircle(scaledModel, Math.PI * 0.125, 0.0, 0.01);
     assertTrue(circle.isWithin(point2));
     assertFalse(circle.isWithin(northPole));
     assertFalse(circle.isWithin(southPole));
diff --git a/lucene/spatial3d/src/test/org/apache/lucene/geo3d/XYZSolidTest.java b/lucene/spatial3d/src/test/org/apache/lucene/geo3d/XYZSolidTest.java
index 5a5ef26..5418812 100644
--- a/lucene/spatial3d/src/test/org/apache/lucene/geo3d/XYZSolidTest.java
+++ b/lucene/spatial3d/src/test/org/apache/lucene/geo3d/XYZSolidTest.java
@@ -29,7 +29,7 @@ public class XYZSolidTest extends LuceneTestCase {
     // Something bigger than the world
     s = new XYZSolid(PlanetModel.SPHERE, -2.0, 2.0, -2.0, 2.0, -2.0, 2.0);
     // Any shape, except whole world, should be within.
-    shape = new GeoCircle(PlanetModel.SPHERE, 0.0, 0.0, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, 0.0, 0.1);
     assertEquals(GeoArea.WITHIN, s.getRelationship(shape));
     shape = new GeoWorld(PlanetModel.SPHERE);
     // An XYZSolid represents a surface shape, which when larger than the world is in fact
@@ -39,13 +39,13 @@ public class XYZSolidTest extends LuceneTestCase {
     // Something overlapping the world on only one side
     s = new XYZSolid(PlanetModel.SPHERE, -2.0, 0.0, -2.0, 2.0, -2.0, 2.0);
     // Some things should be disjoint...
-    shape = new GeoCircle(PlanetModel.SPHERE, 0.0, 0.0, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, 0.0, 0.1);
     assertEquals(GeoArea.DISJOINT, s.getRelationship(shape));
     // And, some things should be within... 
-    shape = new GeoCircle(PlanetModel.SPHERE, 0.0, Math.PI, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, Math.PI, 0.1);
     assertEquals(GeoArea.WITHIN, s.getRelationship(shape));
     // And, some things should overlap.
-    shape = new GeoCircle(PlanetModel.SPHERE, 0.0, Math.PI * 0.5, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, Math.PI * 0.5, 0.1);
     assertEquals(GeoArea.OVERLAPS, s.getRelationship(shape));
 
     // Partial world should be contained by GeoWorld object...
@@ -55,7 +55,7 @@ public class XYZSolidTest extends LuceneTestCase {
     // Something inside the world
     s = new XYZSolid(PlanetModel.SPHERE, -0.1, 0.1, -0.1, 0.1, -0.1, 0.1);
     // All shapes should be disjoint
-    shape = new GeoCircle(PlanetModel.SPHERE, 0.0, 0.0, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, 0.0, 0.1);
     assertEquals(GeoArea.DISJOINT, s.getRelationship(shape));
     shape = new GeoWorld(PlanetModel.SPHERE);
     assertEquals(GeoArea.DISJOINT, s.getRelationship(shape));
@@ -70,7 +70,7 @@ public class XYZSolidTest extends LuceneTestCase {
     // Basic test of the factory method - non-degenerate
     solid = GeoAreaFactory.makeGeoArea(PlanetModel.SPHERE, -2.0, 2.0, -2.0, 2.0, -2.0, 2.0);
     // Any shape, except whole world, should be within.
-    shape = new GeoCircle(PlanetModel.SPHERE, 0.0, 0.0, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, 0.0, 0.1);
     assertEquals(GeoArea.WITHIN, solid.getRelationship(shape));
     shape = new GeoWorld(PlanetModel.SPHERE);
     // An XYZSolid represents a surface shape, which when larger than the world is in fact
@@ -80,7 +80,7 @@ public class XYZSolidTest extends LuceneTestCase {
     // Build a degenerate point, not on sphere
     solid = GeoAreaFactory.makeGeoArea(PlanetModel.SPHERE, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
     // disjoint with everything?
-    shape = new GeoCircle(PlanetModel.SPHERE, 0.0, 0.0, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, 0.0, 0.1);
     assertEquals(GeoArea.DISJOINT, solid.getRelationship(shape));
     shape = new GeoWorld(PlanetModel.SPHERE);
     assertEquals(GeoArea.DISJOINT, solid.getRelationship(shape));
@@ -88,17 +88,17 @@ public class XYZSolidTest extends LuceneTestCase {
     // Build a degenerate point that IS on the sphere
     solid = GeoAreaFactory.makeGeoArea(PlanetModel.SPHERE, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0);
     // inside everything that it touches?
-    shape = new GeoCircle(PlanetModel.SPHERE, 0.0, 0.0, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, 0.0, 0.1);
     assertEquals(GeoArea.CONTAINS, solid.getRelationship(shape));
     shape = new GeoWorld(PlanetModel.SPHERE);
     assertEquals(GeoArea.CONTAINS, solid.getRelationship(shape));
-    shape = new GeoCircle(PlanetModel.SPHERE, 0.0, Math.PI, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, Math.PI, 0.1);
     assertEquals(GeoArea.DISJOINT, solid.getRelationship(shape));
 
     // Build a shape degenerate in (x,y), which has no points on sphere
     solid = GeoAreaFactory.makeGeoArea(PlanetModel.SPHERE, 0.0, 0.0, 0.0, 0.0, -0.1, 0.1);
     // disjoint with everything?
-    shape = new GeoCircle(PlanetModel.SPHERE, 0.0, 0.0, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, 0.0, 0.1);
     assertEquals(GeoArea.DISJOINT, solid.getRelationship(shape));
     shape = new GeoWorld(PlanetModel.SPHERE);
     assertEquals(GeoArea.DISJOINT, solid.getRelationship(shape));
@@ -106,31 +106,31 @@ public class XYZSolidTest extends LuceneTestCase {
     // Build a shape degenerate in (x,y) which has one point on sphere
     solid = GeoAreaFactory.makeGeoArea(PlanetModel.SPHERE, 0.0, 0.0, 0.0, 0.0, -0.1, 1.1);
     // inside everything that it touches?
-    shape = new GeoCircle(PlanetModel.SPHERE, 0.0, 0.0, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, 0.0, 0.1);
     assertEquals(GeoArea.DISJOINT, solid.getRelationship(shape));
     shape = new GeoWorld(PlanetModel.SPHERE);
     assertEquals(GeoArea.CONTAINS, solid.getRelationship(shape));
-    shape = new GeoCircle(PlanetModel.SPHERE, Math.PI * 0.5, 0.0, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, Math.PI * 0.5, 0.0, 0.1);
     assertEquals(GeoArea.CONTAINS, solid.getRelationship(shape));
-    shape = new GeoCircle(PlanetModel.SPHERE, -Math.PI * 0.5, 0.0, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, -Math.PI * 0.5, 0.0, 0.1);
     assertEquals(GeoArea.DISJOINT, solid.getRelationship(shape));
 
     // Build a shape degenerate in (x,y) which has two points on sphere
     solid = GeoAreaFactory.makeGeoArea(PlanetModel.SPHERE, 0.0, 0.0, 0.0, 0.0, -1.1, 1.1);
     // inside everything that it touches?
-    shape = new GeoCircle(PlanetModel.SPHERE, 0.0, 0.0, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, 0.0, 0.1);
     assertEquals(GeoArea.DISJOINT, solid.getRelationship(shape));
     shape = new GeoWorld(PlanetModel.SPHERE);
     assertEquals(GeoArea.CONTAINS, solid.getRelationship(shape));
-    shape = new GeoCircle(PlanetModel.SPHERE, Math.PI * 0.5, 0.0, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, Math.PI * 0.5, 0.0, 0.1);
     assertEquals(GeoArea.OVERLAPS, solid.getRelationship(shape));
-    shape = new GeoCircle(PlanetModel.SPHERE, -Math.PI * 0.5, 0.0, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, -Math.PI * 0.5, 0.0, 0.1);
     assertEquals(GeoArea.OVERLAPS, solid.getRelationship(shape));
     
     // Build a shape degenerate in (x,z), which has no points on sphere
     solid = GeoAreaFactory.makeGeoArea(PlanetModel.SPHERE, 0.0, 0.0, -0.1, 0.1, 0.0, 0.0);
     // disjoint with everything?
-    shape = new GeoCircle(PlanetModel.SPHERE, 0.0, 0.0, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, 0.0, 0.1);
     assertEquals(GeoArea.DISJOINT, solid.getRelationship(shape));
     shape = new GeoWorld(PlanetModel.SPHERE);
     assertEquals(GeoArea.DISJOINT, solid.getRelationship(shape));
@@ -138,25 +138,25 @@ public class XYZSolidTest extends LuceneTestCase {
     // Build a shape degenerate in (x,z) which has one point on sphere
     solid = GeoAreaFactory.makeGeoArea(PlanetModel.SPHERE, 0.0, 0.0, -0.1, 1.1, 0.0, 0.0);
     // inside everything that it touches?
-    shape = new GeoCircle(PlanetModel.SPHERE, 0.0, 0.0, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, 0.0, 0.1);
     assertEquals(GeoArea.DISJOINT, solid.getRelationship(shape));
     shape = new GeoWorld(PlanetModel.SPHERE);
     assertEquals(GeoArea.CONTAINS, solid.getRelationship(shape));
-    shape = new GeoCircle(PlanetModel.SPHERE, 0.0, Math.PI * 0.5, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, Math.PI * 0.5, 0.1);
     assertEquals(GeoArea.CONTAINS, solid.getRelationship(shape));
-    shape = new GeoCircle(PlanetModel.SPHERE, 0.0, -Math.PI * 0.5, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, -Math.PI * 0.5, 0.1);
     assertEquals(GeoArea.DISJOINT, solid.getRelationship(shape));
 
     // Build a shape degenerate in (x,y) which has two points on sphere
     solid = GeoAreaFactory.makeGeoArea(PlanetModel.SPHERE, 0.0, 0.0, -1.1, 1.1, 0.0, 0.0);
     // inside everything that it touches?
-    shape = new GeoCircle(PlanetModel.SPHERE, 0.0, 0.0, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, 0.0, 0.1);
     assertEquals(GeoArea.DISJOINT, solid.getRelationship(shape));
     shape = new GeoWorld(PlanetModel.SPHERE);
     assertEquals(GeoArea.CONTAINS, solid.getRelationship(shape));
-    shape = new GeoCircle(PlanetModel.SPHERE, 0.0, Math.PI * 0.5, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, Math.PI * 0.5, 0.1);
     assertEquals(GeoArea.OVERLAPS, solid.getRelationship(shape));
-    shape = new GeoCircle(PlanetModel.SPHERE, 0.0, -Math.PI * 0.5, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, -Math.PI * 0.5, 0.1);
     assertEquals(GeoArea.OVERLAPS, solid.getRelationship(shape));
 
     // MHL for y-z check
@@ -164,7 +164,7 @@ public class XYZSolidTest extends LuceneTestCase {
     // Build a shape that is degenerate in x, which has zero points intersecting sphere
     solid = GeoAreaFactory.makeGeoArea(PlanetModel.SPHERE, 0.0, 0.0, -0.1, 0.1, -0.1, 0.1);
     // disjoint with everything?
-    shape = new GeoCircle(PlanetModel.SPHERE, 0.0, 0.0, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, 0.0, 0.1);
     assertEquals(GeoArea.DISJOINT, solid.getRelationship(shape));
     shape = new GeoWorld(PlanetModel.SPHERE);
     assertEquals(GeoArea.DISJOINT, solid.getRelationship(shape));
@@ -172,7 +172,7 @@ public class XYZSolidTest extends LuceneTestCase {
     // Build a shape that is degenerate in x, which has zero points intersecting sphere, second variation
     solid = GeoAreaFactory.makeGeoArea(PlanetModel.SPHERE, 0.0, 0.0, -0.1, 0.1, 1.1, 1.2);
     // disjoint with everything?
-    shape = new GeoCircle(PlanetModel.SPHERE, 0.0, 0.0, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, 0.0, 0.1);
     assertEquals(GeoArea.DISJOINT, solid.getRelationship(shape));
     shape = new GeoWorld(PlanetModel.SPHERE);
     assertEquals(GeoArea.DISJOINT, solid.getRelationship(shape));
@@ -182,17 +182,17 @@ public class XYZSolidTest extends LuceneTestCase {
     // inside everything that it touches?
     shape = new GeoWorld(PlanetModel.SPHERE);
     assertEquals(GeoArea.CONTAINS, solid.getRelationship(shape));
-    shape = new GeoCircle(PlanetModel.SPHERE, 0.0, 0.0, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, 0.0, 0.1);
     assertEquals(GeoArea.DISJOINT, solid.getRelationship(shape));
-    shape = new GeoCircle(PlanetModel.SPHERE, 0.0, Math.PI, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, Math.PI, 0.1);
     assertEquals(GeoArea.DISJOINT, solid.getRelationship(shape));
-    shape = new GeoCircle(PlanetModel.SPHERE, 0.0, Math.PI * 0.5, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, Math.PI * 0.5, 0.1);
     assertEquals(GeoArea.OVERLAPS, solid.getRelationship(shape));
-    shape = new GeoCircle(PlanetModel.SPHERE, 0.0, -Math.PI * 0.5, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, -Math.PI * 0.5, 0.1);
     assertEquals(GeoArea.OVERLAPS, solid.getRelationship(shape));
-    shape = new GeoCircle(PlanetModel.SPHERE, Math.PI * 0.5, 0.0, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, Math.PI * 0.5, 0.0, 0.1);
     assertEquals(GeoArea.OVERLAPS, solid.getRelationship(shape));
-    shape = new GeoCircle(PlanetModel.SPHERE, -Math.PI * 0.5, 0.0, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, -Math.PI * 0.5, 0.0, 0.1);
     assertEquals(GeoArea.OVERLAPS, solid.getRelationship(shape));
 
     // Build a shape that is disjoint in X but intersects sphere in a half circle in Y
@@ -200,17 +200,17 @@ public class XYZSolidTest extends LuceneTestCase {
     // inside everything that it touches?
     shape = new GeoWorld(PlanetModel.SPHERE);
     assertEquals(GeoArea.CONTAINS, solid.getRelationship(shape));
-    shape = new GeoCircle(PlanetModel.SPHERE, 0.0, 0.0, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, 0.0, 0.1);
     assertEquals(GeoArea.DISJOINT, solid.getRelationship(shape));
-    shape = new GeoCircle(PlanetModel.SPHERE, 0.0, Math.PI, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, Math.PI, 0.1);
     assertEquals(GeoArea.DISJOINT, solid.getRelationship(shape));
-    shape = new GeoCircle(PlanetModel.SPHERE, 0.0, Math.PI * 0.5, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, Math.PI * 0.5, 0.1);
     assertEquals(GeoArea.OVERLAPS, solid.getRelationship(shape));
-    shape = new GeoCircle(PlanetModel.SPHERE, 0.0, -Math.PI * 0.5, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, 0.0, -Math.PI * 0.5, 0.1);
     assertEquals(GeoArea.DISJOINT, solid.getRelationship(shape));
-    shape = new GeoCircle(PlanetModel.SPHERE, Math.PI * 0.5, 0.0, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, Math.PI * 0.5, 0.0, 0.1);
     assertEquals(GeoArea.OVERLAPS, solid.getRelationship(shape));
-    shape = new GeoCircle(PlanetModel.SPHERE, -Math.PI * 0.5, 0.0, 0.1);
+    shape = new GeoStandardCircle(PlanetModel.SPHERE, -Math.PI * 0.5, 0.0, 0.1);
     assertEquals(GeoArea.OVERLAPS, solid.getRelationship(shape));
 
     // MHL for degenerate Y

