GitDiffStart: 1331a57e3d5d0fd1480fafcbe6c66721eacf331a | Tue Aug 11 23:00:39 2015 +0000
diff --git a/build.xml b/build.xml
index da9748c..cdc457b 100644
--- a/build.xml
+++ b/build.xml
@@ -131,8 +131,7 @@
       import org.apache.tools.ant.BuildException;
       
       def extensions = [
-        'java', 'jflex', 'py', 'pl', 'g4', 'jj', 'html'
-        // TODO: js, xml
+        'java', 'jflex', 'py', 'pl', 'g4', 'jj', 'html', 'js', 'xml'
       ];
       def invalidPatterns = [
         (~$/@author\b/$) : '@author javadoc tag',
@@ -170,6 +169,7 @@
             include(name: '*.' + it)
           }
           exclude(name: '**/build/**')
+          exclude(name: 'build.xml') // ourselves :-)
         }
       }.each{ f ->
         def text = f.getText('UTF-8');
diff --git a/dev-tools/idea/.idea/projectCodeStyle.xml b/dev-tools/idea/.idea/projectCodeStyle.xml
index d79b7b4..31093bd 100644
--- a/dev-tools/idea/.idea/projectCodeStyle.xml
+++ b/dev-tools/idea/.idea/projectCodeStyle.xml
@@ -21,7 +21,7 @@
         <option name="PACKAGES_TO_USE_IMPORT_ON_DEMAND">
           <value />
         </option>
-	<option name="IMPORT_LAYOUT_TABLE">
+        <option name="IMPORT_LAYOUT_TABLE">
           <value>
             <package name="javax" withSubpackages="true" static="false" />
             <package name="java" withSubpackages="true" static="false" />
diff --git a/lucene/analysis/build.xml b/lucene/analysis/build.xml
index 0c30841..bc85ad1 100644
--- a/lucene/analysis/build.xml
+++ b/lucene/analysis/build.xml
@@ -21,12 +21,12 @@
 
   <description>
     Additional Analyzers
-      - common:	Additional Analyzers
+      - common: Additional Analyzers
       - icu: Analyzers that use functionality from ICU
-      - kuromoji:       Japanese Morphological Analyzer
-      - morfologik:	Morfologik Stemmer
-      - smartcn:	Smart Analyzer for Simplified Chinese Text
-      - stempel:	Algorithmic Stemmer for Polish
+      - kuromoji: Japanese Morphological Analyzer
+      - morfologik: Morfologik Stemmer
+      - smartcn: Smart Analyzer for Simplified Chinese Text
+      - stempel: Algorithmic Stemmer for Polish
       - uima: UIMA Analysis module
   </description>
 
@@ -120,15 +120,15 @@
 
   <target name="-dist-maven">
     <forall-analyzers target="-dist-maven"/>
-  </target>  	
+  </target>
 
   <target name="-validate-maven-dependencies">
     <forall-analyzers target="-validate-maven-dependencies"/>
-  </target>  	
+  </target>
 
   <target name="javadocs">
     <forall-analyzers target="javadocs"/>
-  </target>  	
+  </target>
 
   <target name="javadocs-index.html">
     <forall-analyzers target="javadocs-index.html"/>
@@ -149,7 +149,7 @@
   <target name="-append-module-dependencies-properties">
     <forall-analyzers target="-append-module-dependencies-properties"/>
   </target>
-	
+  
   <target name="check-forbidden-apis">
     <forall-analyzers target="check-forbidden-apis"/>
   </target>
diff --git a/lucene/analysis/common/build.xml b/lucene/analysis/common/build.xml
index b4459aa..0d9eb78 100644
--- a/lucene/analysis/common/build.xml
+++ b/lucene/analysis/common/build.xml
@@ -28,7 +28,7 @@
   <property name="rat.additional-includes" value="src/tools/**"/>
 
   <import file="../analysis-module-build.xml"/>
-	
+  
   <target name="jflex" depends="-install-jflex,clean-jflex,-jflex-StandardAnalyzer,-jflex-UAX29URLEmailTokenizer,
                                 -jflex-wiki-tokenizer,-jflex-HTMLStripCharFilter"/>
 
@@ -122,7 +122,7 @@
       fork="true"
       failonerror="true">
       <classpath>
-      	<pathelement location="${build.dir}/classes/tools"/>
+        <pathelement location="${build.dir}/classes/tools"/>
       </classpath>
       <arg value="${tld.zones}"/>
       <arg value="${tld.output}"/>
diff --git a/lucene/analysis/icu/build.xml b/lucene/analysis/icu/build.xml
index d947e43..32ab34d 100644
--- a/lucene/analysis/icu/build.xml
+++ b/lucene/analysis/icu/build.xml
@@ -59,7 +59,7 @@
   </target>
 
   <property name="gennorm2.src.files"
-  	value="nfc.txt nfkc.txt nfkc_cf.txt BasicFoldings.txt DiacriticFolding.txt DingbatFolding.txt HanRadicalFolding.txt NativeDigitFolding.txt"/>
+    value="nfc.txt nfkc.txt nfkc_cf.txt BasicFoldings.txt DiacriticFolding.txt DingbatFolding.txt HanRadicalFolding.txt NativeDigitFolding.txt"/>
   <property name="gennorm2.tmp" value="${build.dir}/gennorm2/utr30.tmp"/>
   <property name="gennorm2.dst" value="${resources.dir}/org/apache/lucene/analysis/icu/utr30.nrm"/>
   <target name="gennorm2" depends="gen-utr30-data-files">
@@ -85,7 +85,7 @@ are part of the ICU4C package. See http://site.icu-project.org/ </echo>
   
   <property name="rbbi.src.dir" location="src/data/uax29"/>
   <property name="rbbi.dst.dir" location="${resources.dir}/org/apache/lucene/analysis/icu/segmentation"/>
-		
+  
   <target name="genrbbi" depends="compile-tools">
     <mkdir dir="${rbbi.dst.dir}"/>
     <java
@@ -94,8 +94,8 @@ are part of the ICU4C package. See http://site.icu-project.org/ </echo>
       fork="true"
       failonerror="true">
       <classpath>
-      	<path refid="icujar"/>
-      	<pathelement location="${build.dir}/classes/tools"/>
+        <path refid="icujar"/>
+        <pathelement location="${build.dir}/classes/tools"/>
       </classpath>
       <assertions>
         <enable package="org.apache.lucene"/>
diff --git a/lucene/analysis/stempel/build.xml b/lucene/analysis/stempel/build.xml
index 5aaa1ee..64a823a 100644
--- a/lucene/analysis/stempel/build.xml
+++ b/lucene/analysis/stempel/build.xml
@@ -29,6 +29,6 @@
     <pathelement path="${analyzers-common.jar}"/>
     <path refid="base.classpath"/>
   </path>
-	
+  
   <target name="compile-core" depends="jar-analyzers-common, common.compile-core"/>
 </project>
diff --git a/lucene/analysis/uima/build.xml b/lucene/analysis/uima/build.xml
index 9241857..2c7bd59 100644
--- a/lucene/analysis/uima/build.xml
+++ b/lucene/analysis/uima/build.xml
@@ -22,7 +22,7 @@
   <description>
     Analysis integration with Apache UIMA
   </description>
-	
+  
   <property name="tests.userdir" value="src/test-files"/>
   <!-- TODO: why is this limited to one JVM? -->
   <property name="tests.jvms.override" value="1" />
diff --git a/lucene/benchmark/build.xml b/lucene/benchmark/build.xml
index 320c0d3..cd47287 100644
--- a/lucene/benchmark/build.xml
+++ b/lucene/benchmark/build.xml
@@ -46,9 +46,9 @@
         <available file="temp/enwiki-20070527-pages-articles.xml.bz2" property="enwiki.exists"/>
         <available file="temp/enwiki-20070527-pages-articles.xml" property="enwiki.expanded"/>
         <available file="${working.dir}/enwiki.txt" property="enwiki.extracted"/>
-    	<available file="temp/${top.100k.words.archive.filename}"
+      <available file="temp/${top.100k.words.archive.filename}"
                    property="top.100k.words.archive.present"/>
-    	<available file="${working.dir}/top100k-out" 
+      <available file="${working.dir}/top100k-out" 
                    property="top.100k.word.files.expanded"/>
     </target>
 
@@ -137,27 +137,27 @@
         <untar src="temp/mini_newsgroups.tar" dest="${working.dir}"/>
     </target>
 
-	<property name="top.100k.words.archive.filename" 
-	          value="top.100k.words.de.en.fr.uk.wikipedia.2009-11.tar.bz2"/>
-	<property name="top.100k.words.archive.base.url"
-	          value="http://people.apache.org/~rmuir/wikipedia"/>
-	<target name="get-top-100k-words-archive" unless="top.100k.words.archive.present">
-		<mkdir dir="temp"/>
-	    <get src="${top.100k.words.archive.base.url}/${top.100k.words.archive.filename}"
-	         dest="temp/${top.100k.words.archive.filename}"/>
-	</target>
-	<target name="expand-top-100k-word-files" unless="top.100k.word.files.expanded">
-		<mkdir dir="${working.dir}/top100k-out"/>
-	    <untar src="temp/${top.100k.words.archive.filename}"
-	           overwrite="true" compression="bzip2" dest="${working.dir}/top100k-out"/>
-	</target>
-	
-	<target name="top-100k-wiki-word-files" depends="check-files">
-	  <mkdir dir="${working.dir}"/>
-	  <antcall target="get-top-100k-words-archive"/>
-	  <antcall target="expand-top-100k-word-files"/>
-	</target>
-	
+  <property name="top.100k.words.archive.filename" 
+            value="top.100k.words.de.en.fr.uk.wikipedia.2009-11.tar.bz2"/>
+  <property name="top.100k.words.archive.base.url"
+            value="http://people.apache.org/~rmuir/wikipedia"/>
+  <target name="get-top-100k-words-archive" unless="top.100k.words.archive.present">
+    <mkdir dir="temp"/>
+      <get src="${top.100k.words.archive.base.url}/${top.100k.words.archive.filename}"
+           dest="temp/${top.100k.words.archive.filename}"/>
+  </target>
+  <target name="expand-top-100k-word-files" unless="top.100k.word.files.expanded">
+    <mkdir dir="${working.dir}/top100k-out"/>
+      <untar src="temp/${top.100k.words.archive.filename}"
+             overwrite="true" compression="bzip2" dest="${working.dir}/top100k-out"/>
+  </target>
+  
+  <target name="top-100k-wiki-word-files" depends="check-files">
+    <mkdir dir="${working.dir}"/>
+    <antcall target="get-top-100k-words-archive"/>
+    <antcall target="expand-top-100k-word-files"/>
+  </target>
+  
     <target name="get-files" depends="check-files">
         <mkdir dir="temp"/>
         <antcall target="get-reuters"/>
@@ -222,44 +222,44 @@
         </java>
     </target>
 
-	<property name="collation.alg.file" location="conf/collation.alg"/>
-	<property name="collation.output.file" 
-	          value="${working.dir}/collation.benchmark.output.txt"/>
-	<property name="collation.jira.output.file" 
-	          value="${working.dir}/collation.bm2jira.output.txt"/>
-	
-	<path id="collation.runtime.classpath">
-	  <path refid="run.classpath"/>
+  <property name="collation.alg.file" location="conf/collation.alg"/>
+  <property name="collation.output.file" 
+            value="${working.dir}/collation.benchmark.output.txt"/>
+  <property name="collation.jira.output.file" 
+            value="${working.dir}/collation.bm2jira.output.txt"/>
+  
+  <path id="collation.runtime.classpath">
+    <path refid="run.classpath"/>
       <pathelement path="${analyzers-icu.jar}"/>
-	</path>
-	
-	<target name="collation" depends="compile,jar-analyzers-icu,top-100k-wiki-word-files">
-	    <echo>Running benchmark with alg file: ${collation.alg.file}</echo>
-	    <java fork="true" classname="org.apache.lucene.benchmark.byTask.Benchmark" 
-	          maxmemory="${task.mem}" output="${collation.output.file}">
-	      <classpath refid="collation.runtime.classpath"/>
-	      <arg file="${collation.alg.file}"/>
-	    </java>
-	    <echo>Benchmark output is in file: ${collation.output.file}</echo>
-	    <echo>Converting to JIRA table format...</echo>
-	    <exec executable="${perl.exe}" output="${collation.jira.output.file}" failonerror="true">
+  </path>
+  
+  <target name="collation" depends="compile,jar-analyzers-icu,top-100k-wiki-word-files">
+      <echo>Running benchmark with alg file: ${collation.alg.file}</echo>
+      <java fork="true" classname="org.apache.lucene.benchmark.byTask.Benchmark" 
+            maxmemory="${task.mem}" output="${collation.output.file}">
+        <classpath refid="collation.runtime.classpath"/>
+        <arg file="${collation.alg.file}"/>
+      </java>
+      <echo>Benchmark output is in file: ${collation.output.file}</echo>
+      <echo>Converting to JIRA table format...</echo>
+      <exec executable="${perl.exe}" output="${collation.jira.output.file}" failonerror="true">
         <arg value="-CSD"/>
-	      <arg value="scripts/collation.bm2jira.pl"/>
-	      <arg value="${collation.output.file}"/>
-	    </exec>
-	    <echo>Benchmark output in JIRA table format is in file: ${collation.jira.output.file}</echo>
-	</target>
-	
+        <arg value="scripts/collation.bm2jira.pl"/>
+        <arg value="${collation.output.file}"/>
+      </exec>
+      <echo>Benchmark output in JIRA table format is in file: ${collation.jira.output.file}</echo>
+  </target>
+  
     <property name="shingle.alg.file" location="conf/shingle.alg"/>
     <property name="shingle.output.file" 
               value="${working.dir}/shingle.benchmark.output.txt"/>
     <property name="shingle.jira.output.file" 
               value="${working.dir}/shingle.bm2jira.output.txt"/>
-	
+  
     <path id="shingle.runtime.classpath">
       <path refid="run.classpath"/>
     </path>
-	
+  
     <target name="shingle" depends="compile,get-files">
       <echo>Running benchmark with alg file: ${shingle.alg.file}</echo>
       <java fork="true" classname="org.apache.lucene.benchmark.byTask.Benchmark" 
diff --git a/lucene/build.xml b/lucene/build.xml
index 0d7748a..5348d79 100644
--- a/lucene/build.xml
+++ b/lucene/build.xml
@@ -78,7 +78,7 @@
 
   <!-- Validation here depends on compile-tools: but we want to compile modules' tools too -->
   <target name="compile-tools" depends="common.compile-tools">
-  	<modules-crawl target="compile-tools" failonerror="true"/>
+    <modules-crawl target="compile-tools" failonerror="true"/>
   </target>
 
   <target name="check-licenses" depends="compile-tools,resolve,load-custom-tasks" description="Validate license stuff.">
@@ -97,7 +97,7 @@
     <lib-versions-check-macro dir="${common.dir}/.."
                               centralized.versions.file="${common.dir}/ivy-versions.properties"
                               ivy.settings.file="${common.dir}/ivy-settings.xml"
-    	                      ivy.resolution-cache.dir="${ivy.resolution-cache.dir}"
+                              ivy.resolution-cache.dir="${ivy.resolution-cache.dir}"
                               common.build.dir="${common.build.dir}"
                               ignore.conflicts.file="${common.dir}/ivy-ignore-conflicts.properties"/>
   </target>
@@ -237,7 +237,7 @@
       <fileset dir="site/html"/>
     </copy>
   </target>
-	
+  
   <target name="javadocs-modules" description="Generate javadoc for modules classes">
     <modules-crawl target="javadocs"
                    failonerror="true"/>
@@ -281,7 +281,7 @@
         <patternset refid="binary.build.dist.patterns"/>
       </zipfileset>
     </zip>
-	<make-checksums file="${dist.dir}/lucene-${version}.zip"/>
+    <make-checksums file="${dist.dir}/lucene-${version}.zip"/>
   </target>
 
   <!-- ================================================================== -->
@@ -435,7 +435,7 @@
       <modules-crawl target="-validate-maven-dependencies"/>
     </sequential>
   </target>
-	
+  
   <!-- ================================================================== -->
   <!-- support for signing the artifacts using gpg                        -->
   <!-- ================================================================== -->
diff --git a/lucene/common-build.xml b/lucene/common-build.xml
index 4196eea..856fd94 100644
--- a/lucene/common-build.xml
+++ b/lucene/common-build.xml
@@ -221,7 +221,7 @@
       <include name="**/lib/*.jar"/>
     </fileset>
   </path>
-	
+  
   <property name="changes.src.dir" location="${common.dir}/site/changes"/>
   <property name="changes.target.dir" location="${common.dir}/build/docs/changes"/>
 
@@ -555,7 +555,7 @@
   </pathconvert>
 
   <macrodef name="m2-deploy" description="Builds a Maven artifact">
-  	<element name="artifact-attachments" optional="yes"/>
+    <element name="artifact-attachments" optional="yes"/>
     <element name="parent-poms" optional="yes"/>
     <element name="credentials" optional="yes"/>
     <attribute name="pom.xml"/>
@@ -613,7 +613,7 @@
   </macrodef>
 
   <macrodef name="build-manifest" description="Builds a manifest file">
-  	<attribute name="title"/>
+    <attribute name="title"/>
     <attribute name="implementation.title"/>
     <attribute name="manifest.file" default="${manifest.file}"/>
     <element name="additional-manifest-attributes" optional="true"/>
@@ -666,11 +666,11 @@
       </manifest>
     </sequential>
   </macrodef>
-	
+  
   <macrodef name="jarify" description="Builds a JAR file">
-  	<attribute name="basedir" default="${build.dir}/classes/java"/>
-  	<attribute name="destfile" default="${build.dir}/${final.name}.jar"/>
-  	<attribute name="title" default="Lucene Search Engine: ${ant.project.name}"/>
+    <attribute name="basedir" default="${build.dir}/classes/java"/>
+    <attribute name="destfile" default="${build.dir}/${final.name}.jar"/>
+    <attribute name="title" default="Lucene Search Engine: ${ant.project.name}"/>
     <attribute name="excludes" default="**/pom.xml,**/*.iml"/>
     <attribute name="metainf.source.dir" default="${common.dir}"/>
     <attribute name="implementation.title" default="org.apache.lucene"/>
@@ -685,7 +685,7 @@
           <jarify-additional-manifest-attributes />
         </additional-manifest-attributes>
       </build-manifest>
-    	
+      
       <jar destfile="@{destfile}"
            basedir="@{basedir}"
            manifest="@{manifest.file}"
@@ -703,7 +703,7 @@
     <attribute name="module-src-name" default="@{name}"/>
     <sequential>
       <uptodate property="@{property}" targetfile="@{jarfile}">
-      	<srcfiles dir="${common.dir}/@{module-src-name}/src/java" includes="**/*.java"/>
+        <srcfiles dir="${common.dir}/@{module-src-name}/src/java" includes="**/*.java"/>
       </uptodate>
     </sequential>
   </macrodef>
@@ -711,7 +711,7 @@
   <property name="lucene-core.jar" value="${common.dir}/build/core/lucene-core-${version}.jar"/>
   <target name="check-lucene-core-uptodate" unless="lucene-core.uptodate">
     <uptodate property="lucene-core.uptodate" targetfile="${lucene-core.jar}">
-     	<srcfiles dir="${common.dir}/core/src/java" includes="**/*.java"/>
+       <srcfiles dir="${common.dir}/core/src/java" includes="**/*.java"/>
     </uptodate>
   </target>
   <target name="jar-lucene-core" unless="lucene-core.uptodate" depends="check-lucene-core-uptodate">
@@ -794,12 +794,12 @@
   </target>
 
   <macrodef name="compile-test-macro" description="Compiles junit tests.">
-  	<attribute name="srcdir"/>
-  	<attribute name="destdir"/>
-  	<attribute name="test.classpath"/>
+    <attribute name="srcdir"/>
+    <attribute name="destdir"/>
+    <attribute name="test.classpath"/>
     <attribute name="javac.source" default="${javac.source}"/>
     <attribute name="javac.target" default="${javac.target}"/>
-   	<sequential>
+     <sequential>
       <compile
         srcdir="@{srcdir}" 
         destdir="@{destdir}"
@@ -812,7 +812,7 @@
       <copy todir="@{destdir}">
         <fileset dir="@{srcdir}" excludes="**/*.java"/>
       </copy>
-  	</sequential>
+    </sequential>
   </macrodef>
 
   <target name="test-updatecache" description="Overwrite tests' timings cache for balancing." depends="install-junit4-taskdef">
@@ -1626,7 +1626,7 @@ ${tests-output}/junit4-*.suites     - per-JVM executed suites
 
   <!-- TODO, this is really unintuitive how we depend on a target that does not exist -->
   <target name="javadocs">
-  	<fail message="You must redefine the javadocs task to do something!!!!!"/>
+    <fail message="You must redefine the javadocs task to do something!!!!!"/>
   </target>
 
   <target name="install-maven-tasks" unless="maven-tasks.uptodate" depends="ivy-availability-check,ivy-configure">
@@ -1821,7 +1821,7 @@ ${ant.project.name}.test.dependencies=${test.classpath.list}
   </target>
 
   <target name="rat-sources" depends="rat-sources-typedef"
-	  description="runs the tasks over source and test files">
+    description="runs the tasks over source and test files">
     <!-- create a temp file for the log to go to -->
     <tempfile property="rat.sources.logfile"
               prefix="rat"
@@ -2052,7 +2052,7 @@ ${ant.project.name}.test.dependencies=${test.classpath.list}
   <macrodef name="invoke-javadoc">
     <element name="sources" optional="yes"/>
     <attribute name="destdir"/>
-  	<attribute name="title" default="${Name} ${version} API"/>
+    <attribute name="title" default="${Name} ${version} API"/>
     <attribute name="overview" default="${src.dir}/overview.html"/>
     <attribute name="linksource" default="no"/>
     <sequential>
@@ -2085,7 +2085,7 @@ ${ant.project.name}.test.dependencies=${test.classpath.list}
           description="WARNING: This API is experimental and might change in incompatible ways in the next release."/>
         <tag name="lucene.internal"
         description="NOTE: This API is for internal purposes only and might change in incompatible ways in the next release."/>
-      	<link offline="true" packagelistLoc="${javadoc.dir}"/>
+        <link offline="true" packagelistLoc="${javadoc.dir}"/>
         <link offline="true" href="${javadoc.link}" packagelistLoc="${javadoc.packagelist.dir}/java8"/>
         <bottom><![CDATA[
           <i>Copyright &copy; ${year} Apache Software Foundation.  All Rights Reserved.</i>
@@ -2104,9 +2104,9 @@ ${ant.project.name}.test.dependencies=${test.classpath.list}
             })();
           </script>
         ]]></bottom>
-      	
-      	<sources />
-      	      	
+        
+        <sources />
+                
         <classpath refid="javadoc.classpath"/>
         <arg line="${javadoc.doclint.args}"/>
       </javadoc>
@@ -2429,7 +2429,7 @@ ${ant.project.name}.test.dependencies=${test.classpath.list}
 
       public final class PegDownFilter extends ChainableReaderFilter {
         @Override
-        public String	filter(String markdownSource) {
+        public String filter(String markdownSource) {
           PegDownProcessor processor = new PegDownProcessor(
             Extensions.ABBREVIATIONS | Extensions.AUTOLINKS |
             Extensions.FENCED_CODE_BLOCKS | Extensions.SMARTS
@@ -2479,13 +2479,13 @@ ${ant.project.name}.test.dependencies=${test.classpath.list}
   </macrodef>
 
   <target name="regenerate"/>
-	
+  
   <macrodef name="check-broken-links">
        <attribute name="dir"/>
      <sequential>
        <exec dir="." executable="${python32.exe}" failonerror="true">
-	 <!-- Tell Python not to write any bytecode cache into the filesystem: -->
-	 <arg value="-B"/>
+         <!-- Tell Python not to write any bytecode cache into the filesystem: -->
+         <arg value="-B"/>
          <arg value="${dev-tools.dir}/scripts/checkJavadocLinks.py"/>
          <arg value="@{dir}"/>
        </exec>
@@ -2497,8 +2497,8 @@ ${ant.project.name}.test.dependencies=${test.classpath.list}
        <attribute name="level" default="class"/>
      <sequential>
        <exec dir="." executable="${python32.exe}" failonerror="true">
-	 <!-- Tell Python not to write any bytecode cache into the filesystem: -->
-	 <arg value="-B"/>
+         <!-- Tell Python not to write any bytecode cache into the filesystem: -->
+         <arg value="-B"/>
          <arg value="${dev-tools.dir}/scripts/checkJavaDocs.py"/>
          <arg value="@{dir}"/>
          <arg value="@{level}"/>
diff --git a/lucene/core/build.xml b/lucene/core/build.xml
index 2399669..90da238 100644
--- a/lucene/core/build.xml
+++ b/lucene/core/build.xml
@@ -65,20 +65,20 @@
   <target name="-dist-maven" depends="-dist-maven-src-java"/>
 
   <macrodef name="createLevAutomaton">
-  	<attribute name="n"/>
-  	<sequential>
+      <attribute name="n"/>
+      <sequential>
       <exec dir="src/java/org/apache/lucene/util/automaton"
             executable="${python.exe}" failonerror="true">
-	 <!-- Tell Python not to write any bytecode cache into the filesystem: -->
-	 <arg value="-B"/>
+        <!-- Tell Python not to write any bytecode cache into the filesystem: -->
+        <arg value="-B"/>
         <arg value="createLevAutomata.py"/>
         <arg value="@{n}"/>
         <arg value="True"/>
       </exec>
       <exec dir="src/java/org/apache/lucene/util/automaton"
             executable="${python.exe}" failonerror="true">
-	 <!-- Tell Python not to write any bytecode cache into the filesystem: -->
-	 <arg value="-B"/>
+        <!-- Tell Python not to write any bytecode cache into the filesystem: -->
+        <arg value="-B"/>
         <arg value="createLevAutomata.py"/>
         <arg value="@{n}"/>
         <arg value="False"/>
diff --git a/lucene/demo/build.xml b/lucene/demo/build.xml
index 01d7c6a..1157061 100644
--- a/lucene/demo/build.xml
+++ b/lucene/demo/build.xml
@@ -47,9 +47,9 @@
       <links>
         <link href="../analyzers-common"/>
         <link href="../queryparser"/>
-      	<link href="../queries"/>
-      	<link href="../facet"/>
-      	<link href="../expressions"/>
+        <link href="../queries"/>
+        <link href="../facet"/>
+        <link href="../expressions"/>
       </links>
     </invoke-module-javadoc>
   </target>
diff --git a/lucene/demo/src/resources/org/apache/lucene/demo/xmlparser/WEB-INF/web.xml b/lucene/demo/src/resources/org/apache/lucene/demo/xmlparser/WEB-INF/web.xml
index b0388e0..cc68563 100644
--- a/lucene/demo/src/resources/org/apache/lucene/demo/xmlparser/WEB-INF/web.xml
+++ b/lucene/demo/src/resources/org/apache/lucene/demo/xmlparser/WEB-INF/web.xml
@@ -16,34 +16,34 @@
  limitations under the License.
 -->
 <web-app id="WebApp_ID" version="2.4" xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd">
-	<display-name>
-	LuceneXmlQueryWebDemo</display-name>
-	<servlet>
-		<description>
-		Servlet demonstrating XMLQueryParser</description>
-		<display-name>
-		FormBasedXmlQueryDemo</display-name>
-		<servlet-name>FormBasedXmlQueryDemo</servlet-name>
-		<servlet-class>
-		org.apache.lucene.xmlparser.webdemo.FormBasedXmlQueryDemo</servlet-class>
-		<init-param>
-			<description>
-			Name of query file held in /WEB-INF</description>
-			<param-name>xslFile</param-name>
-			<param-value>query.xsl</param-value>
-		</init-param>
-		<init-param>
-			<description>
-			Default field used in standard Lucene QueryParser used in UserQuery tag</description>
-			<param-name>defaultStandardQueryParserField</param-name>
-			<param-value>jobDescription</param-value>
-		</init-param>
-	</servlet>
-	<servlet-mapping>
-		<servlet-name>FormBasedXmlQueryDemo</servlet-name>
-		<url-pattern>/FormBasedXmlQueryDemo</url-pattern>
-	</servlet-mapping>
-	<welcome-file-list>
-		<welcome-file>index.jsp</welcome-file>
-	</welcome-file-list>
+  <display-name>
+  LuceneXmlQueryWebDemo</display-name>
+  <servlet>
+    <description>
+    Servlet demonstrating XMLQueryParser</description>
+    <display-name>
+    FormBasedXmlQueryDemo</display-name>
+    <servlet-name>FormBasedXmlQueryDemo</servlet-name>
+    <servlet-class>
+    org.apache.lucene.xmlparser.webdemo.FormBasedXmlQueryDemo</servlet-class>
+    <init-param>
+      <description>
+      Name of query file held in /WEB-INF</description>
+      <param-name>xslFile</param-name>
+      <param-value>query.xsl</param-value>
+    </init-param>
+    <init-param>
+      <description>
+      Default field used in standard Lucene QueryParser used in UserQuery tag</description>
+      <param-name>defaultStandardQueryParserField</param-name>
+      <param-value>jobDescription</param-value>
+    </init-param>
+  </servlet>
+  <servlet-mapping>
+    <servlet-name>FormBasedXmlQueryDemo</servlet-name>
+    <url-pattern>/FormBasedXmlQueryDemo</url-pattern>
+  </servlet-mapping>
+  <welcome-file-list>
+    <welcome-file>index.jsp</welcome-file>
+  </welcome-file-list>
 </web-app>
diff --git a/lucene/module-build.xml b/lucene/module-build.xml
index 52232d0..0263101 100644
--- a/lucene/module-build.xml
+++ b/lucene/module-build.xml
@@ -63,7 +63,7 @@
   <target name="javadocs" depends="compile-core,javadocs-lucene-core,check-javadocs-uptodate"
                           unless="javadocs-uptodate-${name}">
     <invoke-module-javadoc/>
-  </target>	
+  </target>
 
   <macrodef name="invoke-module-javadoc">
     <!-- additional links for dependencies to other modules -->
@@ -74,7 +74,7 @@
       <mkdir dir="${javadoc.dir}/${name}"/>
       <invoke-javadoc
          destdir="${javadoc.dir}/${name}"
-       	 title="${Name} ${version} ${name} API"
+         title="${Name} ${version} ${name} API"
          linksource="@{linksource}">
          <sources>
            <link href="../core/"/>
@@ -130,7 +130,7 @@
     </ant>
     <property name="queryparser-javadocs.uptodate" value="true"/>
   </target>
-	
+  
   <property name="join.jar" value="${common.dir}/build/join/lucene-join-${version}.jar"/>
   <target name="check-join-uptodate" unless="join.uptodate">
     <module-uptodate name="join" jarfile="${join.jar}" property="join.uptodate"/>
@@ -138,9 +138,9 @@
   <target name="jar-join" unless="join.uptodate" depends="check-join-uptodate">
     <ant dir="${common.dir}/join" target="jar-core" inheritAll="false">
       <propertyset refid="uptodate.and.compiled.properties"/>
-	</ant>
-	<property name="join.uptodate" value="true"/>
-  </target>	
+    </ant>
+    <property name="join.uptodate" value="true"/>
+  </target>  
   
   <property name="join-javadoc.jar" value="${common.dir}/build/join/lucene-join-${version}-javadoc.jar"/>
   <target name="check-join-javadocs-uptodate" unless="join-javadocs.uptodate">
@@ -180,7 +180,7 @@
     <module-uptodate name="queries" jarfile="${queries.jar}" property="queries.uptodate"/>
   </target>
   <target name="jar-queries" unless="queries.uptodate" depends="check-queries-uptodate">
-  	<ant dir="${common.dir}/queries" target="jar-core" inheritAll="false">
+    <ant dir="${common.dir}/queries" target="jar-core" inheritAll="false">
       <propertyset refid="uptodate.and.compiled.properties"/>
     </ant>
     <property name="queries.uptodate" value="true"/>
@@ -268,7 +268,7 @@
     <module-uptodate name="analysis/icu" jarfile="${analyzers-icu.jar}" property="analyzers-icu.uptodate"/>
   </target>
   <target name="jar-analyzers-icu" unless="analyzers-icu.uptodate" depends="check-analyzers-icu-uptodate">
-  	<ant dir="${common.dir}/analysis/icu" target="jar-core" inheritAll="false">
+    <ant dir="${common.dir}/analysis/icu" target="jar-core" inheritAll="false">
       <propertyset refid="uptodate.and.compiled.properties"/>
     </ant>
     <property name="analyzers-icu.uptodate" value="true"/>
@@ -290,7 +290,7 @@
     <module-uptodate name="analysis/phonetic" jarfile="${analyzers-phonetic.jar}" property="analyzers-phonetic.uptodate"/>
   </target>
   <target name="jar-analyzers-phonetic" unless="analyzers-phonetic.uptodate" depends="check-analyzers-phonetic-uptodate">
-  	<ant dir="${common.dir}/analysis/phonetic" target="jar-core" inheritAll="false">
+    <ant dir="${common.dir}/analysis/phonetic" target="jar-core" inheritAll="false">
       <propertyset refid="uptodate.and.compiled.properties"/>
     </ant>
   </target>
@@ -311,7 +311,7 @@
     <module-uptodate name="analysis/smartcn" jarfile="${analyzers-smartcn.jar}" property="analyzers-smartcn.uptodate"/>
   </target>
   <target name="jar-analyzers-smartcn" unless="analyzers-smartcn.uptodate" depends="check-analyzers-smartcn-uptodate">
-  	<ant dir="${common.dir}/analysis/smartcn" target="jar-core" inheritAll="false">
+    <ant dir="${common.dir}/analysis/smartcn" target="jar-core" inheritAll="false">
       <propertyset refid="uptodate.and.compiled.properties"/>
     </ant>
     <property name="analyzers-smartcn.uptodate" value="true"/>
@@ -333,7 +333,7 @@
     <module-uptodate name="analysis/stempel" jarfile="${analyzers-stempel.jar}" property="analyzers-stempel.uptodate"/>
   </target>
   <target name="jar-analyzers-stempel" unless="analyzers-stempel.uptodate" depends="check-analyzers-stempel-uptodate">
-  	<ant dir="${common.dir}/analysis/stempel" target="jar-core" inheritAll="false">
+    <ant dir="${common.dir}/analysis/stempel" target="jar-core" inheritAll="false">
       <propertyset refid="uptodate.and.compiled.properties"/>
     </ant>
     <property name="analyzers-stempel.uptodate" value="true"/>
@@ -355,7 +355,7 @@
     <module-uptodate name="analysis/kuromoji" jarfile="${analyzers-kuromoji.jar}" property="analyzers-kuromoji.uptodate"/>
   </target>
   <target name="jar-analyzers-kuromoji" unless="analyzers-kuromoji.uptodate" depends="check-analyzers-kuromoji-uptodate">
-  	<ant dir="${common.dir}/analysis/kuromoji" target="jar-core" inheritAll="false">
+    <ant dir="${common.dir}/analysis/kuromoji" target="jar-core" inheritAll="false">
       <propertyset refid="uptodate.and.compiled.properties"/>
     </ant>
     <property name="analyzers-kuromoji.uptodate" value="true"/>
@@ -491,7 +491,7 @@
     <module-uptodate name="grouping" jarfile="${grouping.jar}" property="grouping.uptodate"/>
   </target>
   <target name="jar-grouping" unless="grouping.uptodate" depends="check-grouping-uptodate">
-  	<ant dir="${common.dir}/grouping" target="jar-core" inheritAll="false">
+    <ant dir="${common.dir}/grouping" target="jar-core" inheritAll="false">
       <propertyset refid="uptodate.and.compiled.properties"/>
     </ant>
     <property name="grouping.uptodate" value="true"/>
@@ -557,7 +557,7 @@
     <module-uptodate name="misc" jarfile="${misc.jar}" property="misc.uptodate"/>
   </target>
   <target name="jar-misc" unless="misc.uptodate" depends="check-misc-uptodate">
-  	<ant dir="${common.dir}/misc" target="jar-core" inheritAll="false">
+    <ant dir="${common.dir}/misc" target="jar-core" inheritAll="false">
       <propertyset refid="uptodate.and.compiled.properties"/>
     </ant>
     <property name="misc.uptodate" value="true"/>
@@ -579,7 +579,7 @@
     <module-uptodate name="sandbox" jarfile="${sandbox.jar}" property="sandbox.uptodate"/>
   </target>
   <target name="jar-sandbox" unless="sandbox.uptodate" depends="check-sandbox-uptodate">
-  	<ant dir="${common.dir}/sandbox" target="jar-core" inheritAll="false">
+    <ant dir="${common.dir}/sandbox" target="jar-core" inheritAll="false">
       <propertyset refid="uptodate.and.compiled.properties"/>
     </ant>
     <property name="sandbox.uptodate" value="true"/>
@@ -601,7 +601,7 @@
     <module-uptodate name="spatial3d" jarfile="${spatial3d.jar}" property="spatial3d.uptodate"/>
   </target>
   <target name="jar-spatial3d" unless="spatial3d.uptodate" depends="check-spatial3d-uptodate">
-  	<ant dir="${common.dir}/spatial3d" target="jar-core" inheritAll="false">
+    <ant dir="${common.dir}/spatial3d" target="jar-core" inheritAll="false">
       <propertyset refid="uptodate.and.compiled.properties"/>
     </ant>
     <property name="spatial3d.uptodate" value="true"/>
@@ -623,7 +623,7 @@
     <module-uptodate name="spatial" jarfile="${spatial.jar}" property="spatial.uptodate"/>
   </target>
   <target name="jar-spatial" unless="spatial.uptodate" depends="check-spatial-uptodate">
-  	<ant dir="${common.dir}/spatial" target="jar-core" inheritAll="false">
+    <ant dir="${common.dir}/spatial" target="jar-core" inheritAll="false">
       <propertyset refid="uptodate.and.compiled.properties"/>
     </ant>
     <property name="spatial.uptodate" value="true"/>
@@ -645,7 +645,7 @@
     <module-uptodate name="suggest" jarfile="${suggest.jar}" property="suggest.uptodate"/>
   </target>
   <target name="jar-suggest" unless="suggest.uptodate" depends="check-suggest-uptodate">
-  	<ant dir="${common.dir}/suggest" target="jar-core" inheritAll="false">
+    <ant dir="${common.dir}/suggest" target="jar-core" inheritAll="false">
       <propertyset refid="uptodate.and.compiled.properties"/>
     </ant>
     <property name="suggest.uptodate" value="true"/>
diff --git a/lucene/queryparser/build.xml b/lucene/queryparser/build.xml
index 671e344..682c961 100644
--- a/lucene/queryparser/build.xml
+++ b/lucene/queryparser/build.xml
@@ -63,19 +63,19 @@
 
       <!-- Change the incorrect public ctors for QueryParser to be protected instead -->
       <replaceregexp file="src/java/org/apache/lucene/queryparser/classic/QueryParser.java"
-		     byline="true"
-		     match="public QueryParser\(CharStream "
-		     replace="protected QueryParser(CharStream "/>
+         byline="true"
+         match="public QueryParser\(CharStream "
+         replace="protected QueryParser(CharStream "/>
       <replaceregexp file="src/java/org/apache/lucene/queryparser/classic/QueryParser.java"
-		     byline="true"
-		     match="public QueryParser\(QueryParserTokenManager "
-		     replace="protected QueryParser(QueryParserTokenManager "/>
+         byline="true"
+         match="public QueryParser\(QueryParserTokenManager "
+         replace="protected QueryParser(QueryParserTokenManager "/>
       <generalReplaces dir="src/java/org/apache/lucene/queryparser/classic"/>
     </sequential>
   </target>
 
   <target name="javacc-surround" depends="resolve-javacc" description="generate surround query parser">
-  	<invoke-javacc target="src/java/org/apache/lucene/queryparser/surround/parser/QueryParser.jj"
+    <invoke-javacc target="src/java/org/apache/lucene/queryparser/surround/parser/QueryParser.jj"
                    outputDir="src/java/org/apache/lucene/queryparser/surround/parser"
     />
     <generalReplaces dir="src/java/org/apache/lucene/queryparser/surround/parser"/>
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/BooleanQuery.xml b/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/BooleanQuery.xml
index bba1d34..67c3e08 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/BooleanQuery.xml
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/BooleanQuery.xml
@@ -16,13 +16,13 @@
  limitations under the License.
 -->
 <BooleanQuery fieldName="contents">
-	<Clause occurs="should">
-		<TermQuery>merger</TermQuery>
-	</Clause>
-	<Clause occurs="mustnot">
-		<TermQuery>sumitomo</TermQuery>
-	</Clause>
-	<Clause occurs="must">
-		<TermQuery>bank</TermQuery>
-	</Clause>
+  <Clause occurs="should">
+    <TermQuery>merger</TermQuery>
+  </Clause>
+  <Clause occurs="mustnot">
+    <TermQuery>sumitomo</TermQuery>
+  </Clause>
+  <Clause occurs="must">
+    <TermQuery>bank</TermQuery>
+  </Clause>
 </BooleanQuery>
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/BoostingQuery.xml b/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/BoostingQuery.xml
index 10cfa88..e10ddca 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/BoostingQuery.xml
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/BoostingQuery.xml
@@ -16,18 +16,18 @@
  limitations under the License.
 -->
 <BoostingQuery>
-	<!-- Find docs about banks, preferably merger info and preferably not "World bank" -->
-	<Query>
-		<BooleanQuery fieldName="contents">
-			<Clause occurs="should">
-				<TermQuery>merger</TermQuery>
-			</Clause>
-			<Clause occurs="must">
-				<TermQuery>bank</TermQuery>
-			</Clause>
-		</BooleanQuery>	
-	</Query>
-	<BoostQuery boost="0.01">
-			<UserQuery>"world bank"</UserQuery>
-	</BoostQuery>
+  <!-- Find docs about banks, preferably merger info and preferably not "World bank" -->
+  <Query>
+    <BooleanQuery fieldName="contents">
+      <Clause occurs="should">
+        <TermQuery>merger</TermQuery>
+      </Clause>
+      <Clause occurs="must">
+        <TermQuery>bank</TermQuery>
+      </Clause>
+    </BooleanQuery>  
+  </Query>
+  <BoostQuery boost="0.01">
+      <UserQuery>"world bank"</UserQuery>
+  </BoostQuery>
 </BoostingQuery>
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/CachedQuery.xml b/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/CachedQuery.xml
index 40dc0f7..4db37b0 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/CachedQuery.xml
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/CachedQuery.xml
@@ -16,36 +16,36 @@
  limitations under the License.
 -->
 <BooleanQuery fieldName="contents">
-	<Clause occurs="should">
-		<TermQuery>merger</TermQuery>
-	</Clause>
-	<Clause occurs="mustnot">
-		<TermQuery >sumitomo</TermQuery>		
-	</Clause>
-	<Clause occurs="filter">
-		<!--
-			CachedFilter elements can contain any Query or Filter. 
-			CachedFilters are cached in an LRU Cache keyed on the contained query/filter object. 
-			Using this will speed up overall performance for repeated uses of the same expensive 
-			query/filter. The sorts of queries likely to benefit from caching need not necessarily be 
-			complex - e.g. simple TermQuerys with a large DF (document frequency) can be expensive
-			on large indexes. A good example of this might be a term query on a field with only 2 possible 
-			values - "true" or "false". In a large index, querying or filtering on this field requires 
-			reading millions of document ids from disk which can more usefully be cached as a 
-			QueryFilter bitset.
-			
-			For Queries/Filters to be cached and reused the object must implement hashcode and
-			equals methods correctly so that duplicate queries/filters can be detected in the cache.
-			
-			The CoreParser.maxNumCachedFilters property can be used to control the size
-			of the LRU Cache established during the construction of CoreParser instances.
-			-->
-		<CachedQuery>
-			<!-- Example query to be cached for fast, repeated use -->
-			<TermQuery fieldName="contents">bank</TermQuery> 
-			<!-- Alternatively, a filter object can be cached ....
-				<RangeFilter fieldName="date" lowerTerm="19870409" upperTerm="19870412"/>
-			-->				
-		</CachedQuery>
-	</Clause>
+  <Clause occurs="should">
+    <TermQuery>merger</TermQuery>
+  </Clause>
+  <Clause occurs="mustnot">
+    <TermQuery >sumitomo</TermQuery>    
+  </Clause>
+  <Clause occurs="filter">
+    <!--
+      CachedFilter elements can contain any Query or Filter. 
+      CachedFilters are cached in an LRU Cache keyed on the contained query/filter object. 
+      Using this will speed up overall performance for repeated uses of the same expensive 
+      query/filter. The sorts of queries likely to benefit from caching need not necessarily be 
+      complex - e.g. simple TermQuerys with a large DF (document frequency) can be expensive
+      on large indexes. A good example of this might be a term query on a field with only 2 possible 
+      values - "true" or "false". In a large index, querying or filtering on this field requires 
+      reading millions of document ids from disk which can more usefully be cached as a 
+      QueryFilter bitset.
+      
+      For Queries/Filters to be cached and reused the object must implement hashcode and
+      equals methods correctly so that duplicate queries/filters can be detected in the cache.
+      
+      The CoreParser.maxNumCachedFilters property can be used to control the size
+      of the LRU Cache established during the construction of CoreParser instances.
+      -->
+    <CachedQuery>
+      <!-- Example query to be cached for fast, repeated use -->
+      <TermQuery fieldName="contents">bank</TermQuery> 
+      <!-- Alternatively, a filter object can be cached ....
+        <RangeFilter fieldName="date" lowerTerm="19870409" upperTerm="19870412"/>
+      -->        
+    </CachedQuery>
+  </Clause>
 </BooleanQuery>
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/ConstantScoreQuery.xml b/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/ConstantScoreQuery.xml
index f570cf4..13cbc1b 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/ConstantScoreQuery.xml
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/ConstantScoreQuery.xml
@@ -16,5 +16,5 @@
  limitations under the License.
 -->
 <ConstantScoreQuery>
-	<RangeQuery fieldName="date" lowerTerm="19870409" upperTerm="19870412"/>
+  <RangeQuery fieldName="date" lowerTerm="19870409" upperTerm="19870412"/>
 </ConstantScoreQuery>
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/DisjunctionMaxQuery.xml b/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/DisjunctionMaxQuery.xml
index eb47816..ebf1400 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/DisjunctionMaxQuery.xml
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/DisjunctionMaxQuery.xml
@@ -17,8 +17,8 @@
 -->
 
 <DisjunctionMaxQuery>
-	<TermQuery fieldName="a">merger</TermQuery>
-	<DisjunctionMaxQuery tieBreaker="1.2">
-		<TermQuery fieldName="b">verger</TermQuery>
-	</DisjunctionMaxQuery>
+  <TermQuery fieldName="a">merger</TermQuery>
+  <DisjunctionMaxQuery tieBreaker="1.2">
+    <TermQuery fieldName="b">verger</TermQuery>
+  </DisjunctionMaxQuery>
 </DisjunctionMaxQuery>
\ No newline at end of file
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/FuzzyLikeThisQuery.xml b/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/FuzzyLikeThisQuery.xml
index 2d11b4e..78173d8 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/FuzzyLikeThisQuery.xml
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/FuzzyLikeThisQuery.xml
@@ -16,8 +16,8 @@
  limitations under the License.
 -->
 <FuzzyLikeThisQuery>
-	<!-- Matches on misspelt "Sumitomo" bank -->
-	<Field fieldName="contents">
-		Sumitimo bank 
-	</Field>
+  <!-- Matches on misspelt "Sumitomo" bank -->
+  <Field fieldName="contents">
+    Sumitimo bank 
+  </Field>
 </FuzzyLikeThisQuery>
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/LikeThisQuery.xml b/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/LikeThisQuery.xml
index 3e881fb..6c04de6 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/LikeThisQuery.xml
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/LikeThisQuery.xml
@@ -17,17 +17,17 @@
 -->
 <LikeThisQuery percentTermsToMatch="5" stopWords="Reuter" minDocFreq="2">
 IRAQI TROOPS REPORTED PUSHING BACK IRANIANS Iraq said today its troops were pushing Iranian forces out of 
-	positions they had initially occupied when they launched a new offensive near the southern port of 
-	Basra early yesterday.     A High Command communique said Iraqi troops had won a significant victory 
-	and were continuing to advance.     Iraq said it had foiled a three-pronged thrust some 10 km 
-	(six miles) from Basra, but admitted the Iranians had occupied ground held by the Mohammed al-Qassem 
-	unit, one of three divisions attacked.     The communique said Iranian Revolutionary Guards were under 
-	assault from warplanes, helicopter gunships, heavy artillery and tanks.     "Our forces are continuing 
-	their advance until they purge the last foothold" occupied by the Iranians, it said.     
-	(Iran said its troops had killed or wounded more than 4,000 Iraqis and were stabilising their new positions.)     
-	The Baghdad communique said Iraqi planes also destroyed oil installations at Iran's southwestern Ahvaz field 
-	during a raid today. It denied an Iranian report that an Iraqi jet was shot down.     
-	Iraq also reported a naval battle at the northern tip of the Gulf. Iraqi naval units and forces defending an 
-	offshore terminal sank six Iranian out of 28 Iranian boats attempting to attack an offshore terminal, 
-	the communique said.      Reuter 3;
+  positions they had initially occupied when they launched a new offensive near the southern port of 
+  Basra early yesterday.     A High Command communique said Iraqi troops had won a significant victory 
+  and were continuing to advance.     Iraq said it had foiled a three-pronged thrust some 10 km 
+  (six miles) from Basra, but admitted the Iranians had occupied ground held by the Mohammed al-Qassem 
+  unit, one of three divisions attacked.     The communique said Iranian Revolutionary Guards were under 
+  assault from warplanes, helicopter gunships, heavy artillery and tanks.     "Our forces are continuing 
+  their advance until they purge the last foothold" occupied by the Iranians, it said.     
+  (Iran said its troops had killed or wounded more than 4,000 Iraqis and were stabilising their new positions.)     
+  The Baghdad communique said Iraqi planes also destroyed oil installations at Iran's southwestern Ahvaz field 
+  during a raid today. It denied an Iranian report that an Iraqi jet was shot down.     
+  Iraq also reported a naval battle at the northern tip of the Gulf. Iraqi naval units and forces defending an 
+  offshore terminal sank six Iranian out of 28 Iranian boats attempting to attack an offshore terminal, 
+  the communique said.      Reuter 3;
 </LikeThisQuery>
\ No newline at end of file
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/MatchAllDocsQuery.xml b/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/MatchAllDocsQuery.xml
index 1553502..d258393 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/MatchAllDocsQuery.xml
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/MatchAllDocsQuery.xml
@@ -16,10 +16,10 @@
  limitations under the License.
 -->
 <BooleanQuery>
-	<Clause occurs="must">
-		<MatchAllDocsQuery/>
-	</Clause>
-	<Clause occurs="filter">
-		<RangeQuery fieldName="date" lowerTerm="19870409" upperTerm="19870412"/>
-	</Clause>
+  <Clause occurs="must">
+    <MatchAllDocsQuery/>
+  </Clause>
+  <Clause occurs="filter">
+    <RangeQuery fieldName="date" lowerTerm="19870409" upperTerm="19870412"/>
+  </Clause>
 </BooleanQuery>
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/NestedBooleanQuery.xml b/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/NestedBooleanQuery.xml
index 0cc4c80..aecac7f 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/NestedBooleanQuery.xml
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/NestedBooleanQuery.xml
@@ -16,21 +16,21 @@
  limitations under the License.
 -->
 <!--
-	This query was added to demonstrate nested boolean queries - there
-	was a bug in the XML parser which added ALL child <Clause> tags to 
-	the top level tags ie. took child and grandchild elements instead
-	of just child elements. This was due to the use of the 
-	Element.getElementsByTagName() call in BooleanQueryBuilder
--->	
-<BooleanQuery fieldName="contents">	
-	<Clause occurs="should">
-		<BooleanQuery fieldName="contents">
-			<Clause occurs="must">
-				<TermQuery>doesNotExistButShouldBeOKBecauseOtherClauseExists</TermQuery>
-			</Clause>
-		</BooleanQuery>
-	</Clause>
-	<Clause occurs="should">
-		<TermQuery>bank</TermQuery>
-	</Clause>
+  This query was added to demonstrate nested boolean queries - there
+  was a bug in the XML parser which added ALL child <Clause> tags to 
+  the top level tags ie. took child and grandchild elements instead
+  of just child elements. This was due to the use of the 
+  Element.getElementsByTagName() call in BooleanQueryBuilder
+-->  
+<BooleanQuery fieldName="contents">  
+  <Clause occurs="should">
+    <BooleanQuery fieldName="contents">
+      <Clause occurs="must">
+        <TermQuery>doesNotExistButShouldBeOKBecauseOtherClauseExists</TermQuery>
+      </Clause>
+    </BooleanQuery>
+  </Clause>
+  <Clause occurs="should">
+    <TermQuery>bank</TermQuery>
+  </Clause>
 </BooleanQuery>
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/NumericRangeQueryQuery.xml b/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/NumericRangeQueryQuery.xml
index 416adbd..933ab1e 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/NumericRangeQueryQuery.xml
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/NumericRangeQueryQuery.xml
@@ -16,16 +16,16 @@
  limitations under the License.
 -->
 <BooleanQuery fieldName="contents">
-	<Clause occurs="should">
-		<TermQuery>merger</TermQuery>
-	</Clause>
-	<Clause occurs="mustnot">
-		<TermQuery >sumitomo</TermQuery>		
-	</Clause>
-	<Clause occurs="must">
-		<TermQuery>bank</TermQuery>
-	</Clause>
-	<Clause occurs="must">
-		<NumericRangeQuery fieldName="date2" lowerTerm="19870409" upperTerm="19870412"/>
-	</Clause>
+  <Clause occurs="should">
+    <TermQuery>merger</TermQuery>
+  </Clause>
+  <Clause occurs="mustnot">
+    <TermQuery >sumitomo</TermQuery>    
+  </Clause>
+  <Clause occurs="must">
+    <TermQuery>bank</TermQuery>
+  </Clause>
+  <Clause occurs="must">
+    <NumericRangeQuery fieldName="date2" lowerTerm="19870409" upperTerm="19870412"/>
+  </Clause>
 </BooleanQuery>
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/SpanQuery.xml b/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/SpanQuery.xml
index 6c2df16..fc37d96 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/SpanQuery.xml
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/SpanQuery.xml
@@ -16,40 +16,40 @@
  limitations under the License.
 -->
 <SpanOr fieldName="contents">
-	<SpanNear slop="8" inOrder="false" >		
-			<SpanOr>
-				<SpanTerm>killed</SpanTerm>
-				<SpanTerm>died</SpanTerm>
-				<SpanTerm>dead</SpanTerm>
-			</SpanOr>
-			<SpanOr>
-				<!-- a less verbose way of declaring SpanTerm declarations - these are analyzed
-					into a series of Tokens which are added as SpanTerm elements of a SpanOr
-				-->
-				<SpanOrTerms>miner miners</SpanOrTerms>
-				<!-- finds mine near worker or workers -->
-				<SpanNear slop="6" inOrder="false">		
-					<SpanTerm>mine</SpanTerm>					
-					<SpanOrTerms>worker workers</SpanOrTerms>
+  <SpanNear slop="8" inOrder="false" >    
+      <SpanOr>
+        <SpanTerm>killed</SpanTerm>
+        <SpanTerm>died</SpanTerm>
+        <SpanTerm>dead</SpanTerm>
+      </SpanOr>
+      <SpanOr>
+        <!-- a less verbose way of declaring SpanTerm declarations - these are analyzed
+          into a series of Tokens which are added as SpanTerm elements of a SpanOr
+        -->
+        <SpanOrTerms>miner miners</SpanOrTerms>
+        <!-- finds mine near worker or workers -->
+        <SpanNear slop="6" inOrder="false">    
+          <SpanTerm>mine</SpanTerm>          
+          <SpanOrTerms>worker workers</SpanOrTerms>
           <BoostingTermQuery>heavy</BoostingTermQuery>
         </SpanNear>
-			</SpanOr>
-	</SpanNear>	
-	<SpanFirst end="10">
-		<SpanOrTerms>fire burn</SpanOrTerms>
-	</SpanFirst> 
-	<!-- Other Span examples....
-		
-	<SpanNot>
-		<Include>
-				<SpanNear slop="2" inOrder="2">		
-						<SpanTerm>social</SpanTerm>
-						<SpanTerm>services</SpanTerm>
-				</SpanNear>				
-		</Include>
-		<Exclude>
-				<SpanTerm>public</SpanTerm>
-		</Exclude>
-	</SpanNot>
-		-->
+      </SpanOr>
+  </SpanNear>  
+  <SpanFirst end="10">
+    <SpanOrTerms>fire burn</SpanOrTerms>
+  </SpanFirst> 
+  <!-- Other Span examples....
+    
+  <SpanNot>
+    <Include>
+        <SpanNear slop="2" inOrder="2">    
+            <SpanTerm>social</SpanTerm>
+            <SpanTerm>services</SpanTerm>
+        </SpanNear>        
+    </Include>
+    <Exclude>
+        <SpanTerm>public</SpanTerm>
+    </Exclude>
+  </SpanNot>
+    -->
 </SpanOr>
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/TermsQuery.xml b/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/TermsQuery.xml
index 89f36a9..df93fc2 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/TermsQuery.xml
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/TermsQuery.xml
@@ -15,12 +15,12 @@
  See the License for the specific language governing permissions and
  limitations under the License.
 -->
-		<!-- TermsQuery uses an analyzer to tokenize text and creates a BooleanQuery with nested
-			"should" TermQueries for each of the tokens encountered. This can be used for user input
-			which may include content or characters that would otherwise be illegal query syntax when
-			using the standard lucene query parser. Of course the downside is that none of the query 
-			operators (AND NOT ~ ^ : etc) will have an effect. For some scenarios queries are
-			not formed by people familiar with Lucene query syntax and they can inadvertently type illegal
-			query syntax so in these cases this is an appropriate and simple alternative
-		--> 
+    <!-- TermsQuery uses an analyzer to tokenize text and creates a BooleanQuery with nested
+      "should" TermQueries for each of the tokens encountered. This can be used for user input
+      which may include content or characters that would otherwise be illegal query syntax when
+      using the standard lucene query parser. Of course the downside is that none of the query 
+      operators (AND NOT ~ ^ : etc) will have an effect. For some scenarios queries are
+      not formed by people familiar with Lucene query syntax and they can inadvertently type illegal
+      query syntax so in these cases this is an appropriate and simple alternative
+    --> 
 <TermsQuery fieldName="contents">sumitomo bank</TermsQuery>
\ No newline at end of file
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/UserInputQuery.xml b/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/UserInputQuery.xml
index 62d36ef..f7b6cae8 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/UserInputQuery.xml
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/xml/UserInputQuery.xml
@@ -16,10 +16,10 @@
  limitations under the License.
 -->
 <BooleanQuery>
-	<Clause occurs="must">
-		<UserQuery>"Bank of England"</UserQuery>
-	</Clause>
-	<Clause occurs="filter">
-		<RangeQuery fieldName="date" lowerTerm="19870409" upperTerm="19870412"/>
-	</Clause>
+  <Clause occurs="must">
+    <UserQuery>"Bank of England"</UserQuery>
+  </Clause>
+  <Clause occurs="filter">
+    <RangeQuery fieldName="date" lowerTerm="19870409" upperTerm="19870412"/>
+  </Clause>
 </BooleanQuery>
diff --git a/lucene/queryparser/xmldtddocbuild.xml b/lucene/queryparser/xmldtddocbuild.xml
index daf2080..c36a6ad 100644
--- a/lucene/queryparser/xmldtddocbuild.xml
+++ b/lucene/queryparser/xmldtddocbuild.xml
@@ -19,7 +19,7 @@
 
 <project name="DTDDocAnt" default="main">
 
-	<import file="../../lucene/module-build.xml"/>
+  <import file="../../lucene/module-build.xml"/>
 
     <description>
     This file generates DTDdocumentation
diff --git a/lucene/replicator/build.xml b/lucene/replicator/build.xml
index 32f281e..53d4251 100644
--- a/lucene/replicator/build.xml
+++ b/lucene/replicator/build.xml
@@ -27,17 +27,17 @@
   <import file="../module-build.xml"/>
 
   <path id="classpath">
-  	<fileset dir="lib" />
+    <fileset dir="lib" />
     <pathelement path="${facet.jar}"/>
     <path refid="base.classpath"/>
   </path>
 
-	<target name="resolve" depends="common.resolve">
-		<sequential>
-	    <!-- javax.servlet jar -->
-	    <ivy:retrieve conf="servlet" log="download-only" type="orbit" symlink="${ivy.symlink}"/>
-		</sequential>
-	</target>
+  <target name="resolve" depends="common.resolve">
+    <sequential>
+      <!-- javax.servlet jar -->
+      <ivy:retrieve conf="servlet" log="download-only" type="orbit" symlink="${ivy.symlink}"/>
+    </sequential>
+  </target>
 
   <target name="init" depends="module-build.init,jar-facet"/>
 
diff --git a/lucene/replicator/ivy.xml b/lucene/replicator/ivy.xml
index 645a702..24b053c 100644
--- a/lucene/replicator/ivy.xml
+++ b/lucene/replicator/ivy.xml
@@ -20,7 +20,7 @@
   <info organisation="org.apache.lucene" module="replicator"/>
 
   <configurations defaultconfmapping="http->master;jetty->master;start->master;servlet->master;logging->master">
-  	<conf name="http" description="httpclient jars" transitive="false"/>
+    <conf name="http" description="httpclient jars" transitive="false"/>
     <conf name="jetty" description="jetty jars" transitive="false"/>
     <conf name="start" description="jetty start jar" transitive="false"/>
     <conf name="servlet" description="servlet-api jar" transitive="false"/>
diff --git a/lucene/suggest/build.xml b/lucene/suggest/build.xml
index d12597a..26b316b 100644
--- a/lucene/suggest/build.xml
+++ b/lucene/suggest/build.xml
@@ -22,7 +22,7 @@
   <description>
     Auto-suggest and Spellchecking support
   </description>
-	
+  
   <!-- just a list of words for testing suggesters -->
   <property name="rat.excludes" value="**/Top50KWiki.utf8,**/stop-snowball.txt"/>
 
@@ -40,8 +40,8 @@
     <invoke-module-javadoc>
       <links>
         <link href="../analyzers-common"/>
-      	<link href="../queries"/>
-      	<link href="../misc"/>
+        <link href="../queries"/>
+        <link href="../misc"/>
       </links>
     </invoke-module-javadoc>
   </target>
diff --git a/lucene/tools/custom-tasks.xml b/lucene/tools/custom-tasks.xml
index 53fb7a2..d7344d1 100644
--- a/lucene/tools/custom-tasks.xml
+++ b/lucene/tools/custom-tasks.xml
@@ -89,7 +89,7 @@
     <attribute name="dir"/>
     <attribute name="centralized.versions.file"/>
     <attribute name="ivy.settings.file"/>
-  	<attribute name="ivy.resolution-cache.dir"/>
+    <attribute name="ivy.resolution-cache.dir"/>
     <attribute name="common.build.dir"/>
     <attribute name="ignore.conflicts.file"/>
     <sequential>
@@ -101,7 +101,7 @@
       <echo>Lib versions check under: @{dir}</echo>
       <libversions centralizedVersionsFile="@{centralized.versions.file}"
                    ivySettingsFile="@{ivy.settings.file}"
-      	           ivyResolutionCacheDir="@{ivy.resolution-cache.dir}"
+                   ivyResolutionCacheDir="@{ivy.resolution-cache.dir}"
                    commonBuildDir="@{common.build.dir}"
                    ignoreConflictsFile="@{ignore.conflicts.file}">
         <fileset dir="@{dir}">
diff --git a/solr/build.xml b/solr/build.xml
index 6a21f3f..f79d1af 100644
--- a/solr/build.xml
+++ b/solr/build.xml
@@ -95,7 +95,7 @@
   <!--LUCENE-3286: Luke is incompatible with new XML QP location and target is not flexible
   when it comes to incompatible changes.  Update when Luke has updated.
   <target name="compile-xml-query-parser">
-  	<ant dir="${common.dir}/queryparser" target="compile-core" inheritAll="false">
+    <ant dir="${common.dir}/queryparser" target="compile-core" inheritAll="false">
       <propertyset refid="uptodate.and.compiled.properties"/>
     </ant>
   </target>
@@ -378,7 +378,7 @@
         <include name="webapps" />
         <include name="solr-webapp/**/*" />
         <exclude name="**/.gitignore" />
-      </fileset>    	
+      </fileset>      
     </delete>
   </target>
   
@@ -679,7 +679,7 @@
       <contrib-crawl target="-validate-maven-dependencies"/>
     </sequential>
   </target>
-	 
+   
   <!-- ========================================================================= -->
   <!-- ========================= COMMITTERS' HELPERS =========================== -->
   <!-- ========================================================================= -->
@@ -717,37 +717,37 @@
     <!-- spanish -->
     <copy verbose="true" file="${analysis-common.res.dir}/snowball/spanish_stop.txt"
                          tofile="${analysis.conf.dest}/stopwords_es.txt"/>
-  	<!-- basque -->
+    <!-- basque -->
     <copy verbose="true" file="${analysis-common.res.dir}/eu/stopwords.txt"
                          tofile="${analysis.conf.dest}/stopwords_eu.txt"/>
-  	<!-- persian -->
+    <!-- persian -->
     <copy verbose="true" file="${analysis-common.res.dir}/fa/stopwords.txt"
                          tofile="${analysis.conf.dest}/stopwords_fa.txt"/>
-  	<!-- finnish -->
+    <!-- finnish -->
     <copy verbose="true" file="${analysis-common.res.dir}/snowball/finnish_stop.txt"
                          tofile="${analysis.conf.dest}/stopwords_fi.txt"/>
-  	<!-- french -->
+    <!-- french -->
     <copy verbose="true" file="${analysis-common.res.dir}/snowball/french_stop.txt"
                          tofile="${analysis.conf.dest}/stopwords_fr.txt"/>
         <!-- irish -->
     <copy verbose="true" file="${analysis-common.res.dir}/ga/stopwords.txt"
                          tofile="${analysis.conf.dest}/stopwords_ga.txt"/>
-  	<!-- galician -->
+    <!-- galician -->
     <copy verbose="true" file="${analysis-common.res.dir}/gl/stopwords.txt"
                          tofile="${analysis.conf.dest}/stopwords_gl.txt"/>
-  	<!-- hindi -->
+    <!-- hindi -->
     <copy verbose="true" file="${analysis-common.res.dir}/hi/stopwords.txt"
                          tofile="${analysis.conf.dest}/stopwords_hi.txt"/>
-  	<!-- hungarian -->
+    <!-- hungarian -->
     <copy verbose="true" file="${analysis-common.res.dir}/snowball/hungarian_stop.txt"
                          tofile="${analysis.conf.dest}/stopwords_hu.txt"/>
-  	<!-- armenian -->
+    <!-- armenian -->
     <copy verbose="true" file="${analysis-common.res.dir}/hy/stopwords.txt"
                          tofile="${analysis.conf.dest}/stopwords_hy.txt"/>
-  	<!-- indonesian -->
+    <!-- indonesian -->
     <copy verbose="true" file="${analysis-common.res.dir}/id/stopwords.txt"
                          tofile="${analysis.conf.dest}/stopwords_id.txt"/>
-  	<!-- italian -->
+    <!-- italian -->
     <copy verbose="true" file="${analysis-common.res.dir}/snowball/italian_stop.txt"
                          tofile="${analysis.conf.dest}/stopwords_it.txt"/>
     <!-- japanese -->
@@ -755,31 +755,31 @@
                          tofile="${analysis.conf.dest}/stopwords_ja.txt"/>
     <copy verbose="true" file="${analysis-kuromoji.res.dir}/ja/stoptags.txt"
                          tofile="${analysis.conf.dest}/stoptags_ja.txt"/>
-  	<!-- latvian -->
+    <!-- latvian -->
     <copy verbose="true" file="${analysis-common.res.dir}/lv/stopwords.txt"
                          tofile="${analysis.conf.dest}/stopwords_lv.txt"/>
-  	<!-- dutch -->
+    <!-- dutch -->
     <copy verbose="true" file="${analysis-common.res.dir}/snowball/dutch_stop.txt"
                          tofile="${analysis.conf.dest}/stopwords_nl.txt"/>
-  	<!-- norwegian -->
+    <!-- norwegian -->
     <copy verbose="true" file="${analysis-common.res.dir}/snowball/norwegian_stop.txt"
                          tofile="${analysis.conf.dest}/stopwords_no.txt"/>
-  	<!-- portuguese -->
+    <!-- portuguese -->
     <copy verbose="true" file="${analysis-common.res.dir}/snowball/portuguese_stop.txt"
                          tofile="${analysis.conf.dest}/stopwords_pt.txt"/>
-  	<!-- romanian -->
+    <!-- romanian -->
     <copy verbose="true" file="${analysis-common.res.dir}/ro/stopwords.txt"
                          tofile="${analysis.conf.dest}/stopwords_ro.txt"/>
-  	<!-- russian -->
+    <!-- russian -->
     <copy verbose="true" file="${analysis-common.res.dir}/snowball/russian_stop.txt"
                          tofile="${analysis.conf.dest}/stopwords_ru.txt"/>
-  	<!-- swedish -->
+    <!-- swedish -->
     <copy verbose="true" file="${analysis-common.res.dir}/snowball/swedish_stop.txt"
                          tofile="${analysis.conf.dest}/stopwords_sv.txt"/>
-  	<!-- thai -->
+    <!-- thai -->
     <copy verbose="true" file="${analysis-common.res.dir}/th/stopwords.txt"
                          tofile="${analysis.conf.dest}/stopwords_th.txt"/>
-  	<!-- turkish -->
+    <!-- turkish -->
     <copy verbose="true" file="${analysis-common.res.dir}/tr/stopwords.txt"
                          tofile="${analysis.conf.dest}/stopwords_tr.txt"/>
   </target>
diff --git a/solr/common-build.xml b/solr/common-build.xml
index e3f0913..4dc7b72 100644
--- a/solr/common-build.xml
+++ b/solr/common-build.xml
@@ -76,21 +76,21 @@
   <property name="fullnamever" value="${final.name}"/>
 
   <path id="additional.dependencies">
-  	<fileset dir="${common-solr.dir}/core/lib" excludes="${common.classpath.excludes}"/>
-  	<fileset dir="${common-solr.dir}/solrj/lib" excludes="${common.classpath.excludes}"/>
-  	<fileset dir="${common-solr.dir}/server/lib" excludes="${common.classpath.excludes}"/>
-  	<fileset dir="${common-solr.dir}/example/example-DIH/solr/db/lib" excludes="${common.classpath.excludes}"/>  	
-  	<fileset dir="lib" excludes="${common.classpath.excludes}" erroronmissingdir="false"/>
+    <fileset dir="${common-solr.dir}/core/lib" excludes="${common.classpath.excludes}"/>
+    <fileset dir="${common-solr.dir}/solrj/lib" excludes="${common.classpath.excludes}"/>
+    <fileset dir="${common-solr.dir}/server/lib" excludes="${common.classpath.excludes}"/>
+    <fileset dir="${common-solr.dir}/example/example-DIH/solr/db/lib" excludes="${common.classpath.excludes}"/>    
+    <fileset dir="lib" excludes="${common.classpath.excludes}" erroronmissingdir="false"/>
   </path>
 
   <path id="solr.lucene.libs">
     <!-- List of jars that will be used as the foundation for both
          the base classpath, as well as copied into the lucene-libs dir 
-	 in the release.
+         in the release.
     -->
     <!-- NOTE: lucene-core is explicitly not included because of the 
-	 base.classpath (compilation & tests are done directly against   
-	 the class files w/o needing to build the jar)
+         base.classpath (compilation & tests are done directly against   
+         the class files w/o needing to build the jar)
     -->
     <pathelement location="${analyzers-common.jar}"/>
     <pathelement location="${analyzers-kuromoji.jar}"/>
@@ -128,8 +128,8 @@
       <exclude name="randomizedtesting-runner-*.jar" />
       <exclude name="ant*.jar" />
     </fileset>
-  	<pathelement path="src/test-files"/>
-  	<path refid="test.base.classpath"/>
+    <pathelement path="src/test-files"/>
+    <path refid="test.base.classpath"/>
   </path>
  
   <path id="test.classpath" refid="solr.test.base.classpath"/>
@@ -168,11 +168,11 @@
   </target>
 
   <target name="prep-lucene-jars" 
-  	      depends="jar-lucene-core, jar-backward-codecs, jar-analyzers-phonetic, jar-analyzers-kuromoji, jar-codecs,jar-expressions, jar-suggest, jar-highlighter, jar-memory,
-  	               jar-misc, jar-spatial, jar-grouping, jar-queries, jar-queryparser, jar-join, jar-sandbox">
-  	  <property name="solr.deps.compiled" value="true"/>
+          depends="jar-lucene-core, jar-backward-codecs, jar-analyzers-phonetic, jar-analyzers-kuromoji, jar-codecs,jar-expressions, jar-suggest, jar-highlighter, jar-memory,
+                   jar-misc, jar-spatial, jar-grouping, jar-queries, jar-queryparser, jar-join, jar-sandbox">
+      <property name="solr.deps.compiled" value="true"/>
   </target>
-	
+  
   <target name="lucene-jars-to-solr" 
           depends="-lucene-jars-to-solr-not-for-package,-lucene-jars-to-solr-package"/>
   
@@ -249,7 +249,7 @@
 
   <!-- create javadocs for the current module -->
   <target name="javadocs" depends="compile-core,define-lucene-javadoc-url,lucene-javadocs,javadocs-solr-core,check-javadocs-uptodate" unless="javadocs-uptodate-${name}">
-   	<sequential>
+     <sequential>
       <mkdir dir="${javadoc.dir}/${name}"/>
       <solr-invoke-javadoc>
         <solrsources>
@@ -424,7 +424,7 @@
     <ant dir="${common-solr.dir}/test-framework" target="compile-core" inheritAll="false">
       <propertyset refid="uptodate.and.compiled.properties"/>
     </ant>
-  	<property name="solr.core.compiled" value="true"/>
+    <property name="solr.core.compiled" value="true"/>
     <property name="solr.test.framework.compiled" value="true"/>
   </target>
 
@@ -469,15 +469,15 @@
   </target>
 
   <target name="compile-contrib" description="Compile contrib modules">
-  	<contrib-crawl target="compile-core"/>
+    <contrib-crawl target="compile-core"/>
   </target>
   
   <target name="compile-test-contrib" description="Compile contrib modules' tests">
-  	<contrib-crawl target="compile-test"/>
+    <contrib-crawl target="compile-test"/>
   </target>
 
   <target name="javadocs-contrib" description="Compile contrib modules">
-  	<contrib-crawl target="javadocs"/>
+    <contrib-crawl target="javadocs"/>
   </target>
 
   <target name="jar-contrib" description="Jar contrib modules">
diff --git a/solr/contrib/analytics/src/test-files/analytics/requestXMLFiles/expressions.xml b/solr/contrib/analytics/src/test-files/analytics/requestXMLFiles/expressions.xml
index 511805d..2ce8abf 100644
--- a/solr/contrib/analytics/src/test-files/analytics/requestXMLFiles/expressions.xml
+++ b/solr/contrib/analytics/src/test-files/analytics/requestXMLFiles/expressions.xml
@@ -1,285 +1,285 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <analyticsRequestEnvelope stats="true" olap="true">
- 	<analyticsRequest>
- 		<name>Add Request</name>
- 		
- 		<statistic>
- 			<expression>sum(int(int_id))</expression>
- 			<name>sum</name>
- 		</statistic>
- 		<statistic>
- 			<expression>unique(long(long_ld))</expression>
- 			<name>unique</name>
- 		</statistic>
- 		<statistic>
- 			<expression>add(sum(int(int_id)),unique(long(long_ld)))</expression>
- 			<name>add sum and unique</name>
- 		</statistic>
- 		
- 		<statistic>
- 			<expression>mean(int(int_id))</expression>
- 			<name>mean</name>
- 		</statistic>
- 		<statistic>
- 			<expression>count(long(long_ld))</expression>
- 			<name>count</name>
- 		</statistic>
- 		<statistic>
- 			<expression>median(int(int_id))</expression>
- 			<name>median</name>
- 		</statistic>
- 		<statistic>
- 			<expression>add(mean(int(int_id)),count(long(long_ld)),median(int(int_id)))</expression>
- 			<name>add mean and count and median</name>
- 		</statistic>
- 	</analyticsRequest>
- 	
- 	<analyticsRequest>
- 		<name>Multiply Request</name>
- 		
- 		<statistic>
- 			<expression>sum(int(int_id))</expression>
- 			<name>sum</name>
- 		</statistic>
- 		<statistic>
- 			<expression>unique(long(long_ld))</expression>
- 			<name>unique</name>
- 		</statistic>
- 		<statistic>
- 			<expression>mult(sum(int(int_id)),unique(long(long_ld)))</expression>
- 			<name>multiply sum and unique</name>
- 		</statistic>
- 		
- 		<statistic>
- 			<expression>mean(int(int_id))</expression>
- 			<name>mean</name>
- 		</statistic>
- 		<statistic>
- 			<expression>count(long(long_ld))</expression>
- 			<name>count</name>
- 		</statistic>
- 		<statistic>
- 			<expression>median(int(int_id))</expression>
- 			<name>median</name>
- 		</statistic>
- 		<statistic>
- 			<expression>mult(mean(int(int_id)),count(long(long_ld)),median(int(int_id)))</expression>
- 			<name>multiply mean and count and median</name>
- 		</statistic>
- 	</analyticsRequest>
- 	
- 	<analyticsRequest>
- 		<name>Divide Request</name>
- 		
- 		<statistic>
- 			<expression>sum(int(int_id))</expression>
- 			<name>sum</name>
- 		</statistic>
- 		<statistic>
- 			<expression>unique(long(long_ld))</expression>
- 			<name>unique</name>
- 		</statistic>
- 		<statistic>
- 			<expression>div(sum(int(int_id)),unique(long(long_ld)))</expression>
- 			<name>divide sum by unique</name>
- 		</statistic>
- 		
- 		<statistic>
- 			<expression>mean(int(int_id))</expression>
- 			<name>mean</name>
- 		</statistic>
- 		<statistic>
- 			<expression>count(long(long_ld))</expression>
- 			<name>count</name>
- 		</statistic>
- 		<statistic>
- 			<expression>div(mean(int(int_id)),count(long(long_ld)))</expression>
- 			<name>divide mean by count</name>
- 		</statistic>
- 	</analyticsRequest>
- 	
- 	<analyticsRequest>
- 		<name>Power Request</name>
- 		
- 		<statistic>
- 			<expression>sum(int(int_id))</expression>
- 			<name>sum</name>
- 		</statistic>
- 		<statistic>
- 			<expression>unique(long(long_ld))</expression>
- 			<name>unique</name>
- 		</statistic>
- 		<statistic>
- 			<expression>pow(sum(int(int_id)),unique(long(long_ld)))</expression>
- 			<name>power sum by unique</name>
- 		</statistic>
- 		
- 		<statistic>
- 			<expression>mean(int(int_id))</expression>
- 			<name>mean</name>
- 		</statistic>
- 		<statistic>
- 			<expression>count(long(long_ld))</expression>
- 			<name>count</name>
- 		</statistic>
- 		<statistic>
- 			<expression>pow(mean(int(int_id)),count(long(long_ld)))</expression>
- 			<name>power mean by count</name>
- 		</statistic>
- 	</analyticsRequest>
- 	
- 	<analyticsRequest>
- 		<name>Negate Request</name>
- 		
- 		<statistic>
- 			<expression>sum(int(int_id))</expression>
- 			<name>sum</name>
- 		</statistic>
- 		<statistic>
- 			<expression>neg(sum(int(int_id)))</expression>
- 			<name>negate of sum</name>
- 		</statistic>
- 		
- 		<statistic>
- 			<expression>count(long(long_ld))</expression>
- 			<name>count</name>
- 		</statistic>
- 		<statistic>
- 			<expression>neg(count(long(long_ld)))</expression>
- 			<name>negate of count</name>
- 		</statistic>
- 	</analyticsRequest>
- 	
- 	<analyticsRequest>
- 		<name>Const Num Request</name>
- 		
- 		<statistic>
- 			<expression>const_num(8)</expression>
- 			<name>constant 8</name>
- 		</statistic>
- 		<statistic>
- 			<expression>const_num(10)</expression>
- 			<name>constant 10</name>
- 		</statistic>
- 	</analyticsRequest>
- 	
- 	<analyticsRequest>
- 		<name>Date Math Request</name>
- 		
- 		<statistic>
- 			<expression>median(date(date_dtd))</expression>
- 			<name>median</name>
- 		</statistic>
- 		<statistic>
- 			<expression>const_str(+2YEARS)</expression>
- 			<name>constant str median</name>
- 		</statistic>
- 		<statistic>
- 			<expression>date_math(median(date(date_dtd)),const_str(+2YEARS))</expression>
- 			<name>date math median</name>
- 		</statistic>
- 		
- 		<statistic>
- 			<expression>max(date(date_dtd))</expression>
- 			<name>max</name>
- 		</statistic>
- 		<statistic>
- 			<expression>const_str(+2MONTHS)</expression>
- 			<name>constant str max</name>
- 		</statistic>
- 		<statistic>
- 			<expression>date_math(max(date(date_dtd)),const_str(+2MONTHS))</expression>
- 			<name>date math max</name>
- 		</statistic>
- 	</analyticsRequest>
- 	
- 	<analyticsRequest>
- 		<name>Constant Date Request</name>
- 		
- 		<statistic>
- 			<expression>const_str(1800-12-31T23:59:59Z)</expression>
- 			<name>const str 1</name>
- 		</statistic>
- 		<statistic>
- 			<expression>const_date(1800-12-31T23:59:59Z)</expression>
- 			<name>const date 1</name>
- 		</statistic>
- 		<statistic>
- 			<expression>const_str(1804-06-30T23:59:59Z)</expression>
- 			<name>const str 2</name>
- 		</statistic>
- 		<statistic>
- 			<expression>const_date(1804-06-30T23:59:59Z)</expression>
- 			<name>const date 2</name>
- 		</statistic>
- 	</analyticsRequest>
- 	
- 	<analyticsRequest>
- 		<name>Constant String Request</name>
- 		
- 		<statistic>
- 			<expression>const_str(this is the first)</expression>
- 			<name>const str 1</name>
- 		</statistic>
- 		<statistic>
- 			<expression>const_str(this is the second)</expression>
- 			<name>const str 2</name>
- 		</statistic>
- 		<statistic>
- 			<expression>const_str(this is the third)</expression>
- 			<name>const str 3</name>
- 		</statistic>
- 	</analyticsRequest>
- 	
- 	<analyticsRequest>
- 		<name>Concatenate Request</name>
- 		
- 		<statistic>
- 			<expression>const_str(this is the first)</expression>
- 			<name>const str min</name>
- 		</statistic>
- 		<statistic>
- 			<expression>min(str(string_sd))</expression>
- 			<name>min</name>
- 		</statistic>
- 		<statistic>
- 			<expression>concat(const_str(this is the first),min(str(string_sd)))</expression>
- 			<name>concat const and min</name>
- 		</statistic>
- 		
- 		<statistic>
- 			<expression>const_str(this is the second)</expression>
- 			<name>const str max</name>
- 		</statistic>
- 		<statistic>
- 			<expression>max(str(string_sd))</expression>
- 			<name>max</name>
- 		</statistic>
- 		<statistic>
- 			<expression>concat(const_str(this is the second),max(str(string_sd)))</expression>
- 			<name>concat const and max</name>
- 		</statistic>
- 	</analyticsRequest>
- 	
- 	<analyticsRequest>
- 		<name>Reverse Request</name>
- 		
- 		<statistic>
- 			<expression>min(str(string_sd))</expression>
- 			<name>min</name>
- 		</statistic>
- 		<statistic>
- 			<expression>rev(min(str(string_sd)))</expression>
- 			<name>reverse min</name>
- 		</statistic>
- 		
- 		<statistic>
- 			<expression>max(str(string_sd))</expression>
- 			<name>max</name>
- 		</statistic>
- 		<statistic>
- 			<expression>rev(max(str(string_sd)))</expression>
- 			<name>reverse max</name>
- 		</statistic>
- 	</analyticsRequest>
+   <analyticsRequest>
+     <name>Add Request</name>
+     
+     <statistic>
+       <expression>sum(int(int_id))</expression>
+       <name>sum</name>
+     </statistic>
+     <statistic>
+       <expression>unique(long(long_ld))</expression>
+       <name>unique</name>
+     </statistic>
+     <statistic>
+       <expression>add(sum(int(int_id)),unique(long(long_ld)))</expression>
+       <name>add sum and unique</name>
+     </statistic>
+     
+     <statistic>
+       <expression>mean(int(int_id))</expression>
+       <name>mean</name>
+     </statistic>
+     <statistic>
+       <expression>count(long(long_ld))</expression>
+       <name>count</name>
+     </statistic>
+     <statistic>
+       <expression>median(int(int_id))</expression>
+       <name>median</name>
+     </statistic>
+     <statistic>
+       <expression>add(mean(int(int_id)),count(long(long_ld)),median(int(int_id)))</expression>
+       <name>add mean and count and median</name>
+     </statistic>
+   </analyticsRequest>
+   
+   <analyticsRequest>
+     <name>Multiply Request</name>
+     
+     <statistic>
+       <expression>sum(int(int_id))</expression>
+       <name>sum</name>
+     </statistic>
+     <statistic>
+       <expression>unique(long(long_ld))</expression>
+       <name>unique</name>
+     </statistic>
+     <statistic>
+       <expression>mult(sum(int(int_id)),unique(long(long_ld)))</expression>
+       <name>multiply sum and unique</name>
+     </statistic>
+     
+     <statistic>
+       <expression>mean(int(int_id))</expression>
+       <name>mean</name>
+     </statistic>
+     <statistic>
+       <expression>count(long(long_ld))</expression>
+       <name>count</name>
+     </statistic>
+     <statistic>
+       <expression>median(int(int_id))</expression>
+       <name>median</name>
+     </statistic>
+     <statistic>
+       <expression>mult(mean(int(int_id)),count(long(long_ld)),median(int(int_id)))</expression>
+       <name>multiply mean and count and median</name>
+     </statistic>
+   </analyticsRequest>
+   
+   <analyticsRequest>
+     <name>Divide Request</name>
+     
+     <statistic>
+       <expression>sum(int(int_id))</expression>
+       <name>sum</name>
+     </statistic>
+     <statistic>
+       <expression>unique(long(long_ld))</expression>
+       <name>unique</name>
+     </statistic>
+     <statistic>
+       <expression>div(sum(int(int_id)),unique(long(long_ld)))</expression>
+       <name>divide sum by unique</name>
+     </statistic>
+     
+     <statistic>
+       <expression>mean(int(int_id))</expression>
+       <name>mean</name>
+     </statistic>
+     <statistic>
+       <expression>count(long(long_ld))</expression>
+       <name>count</name>
+     </statistic>
+     <statistic>
+       <expression>div(mean(int(int_id)),count(long(long_ld)))</expression>
+       <name>divide mean by count</name>
+     </statistic>
+   </analyticsRequest>
+   
+   <analyticsRequest>
+     <name>Power Request</name>
+     
+     <statistic>
+       <expression>sum(int(int_id))</expression>
+       <name>sum</name>
+     </statistic>
+     <statistic>
+       <expression>unique(long(long_ld))</expression>
+       <name>unique</name>
+     </statistic>
+     <statistic>
+       <expression>pow(sum(int(int_id)),unique(long(long_ld)))</expression>
+       <name>power sum by unique</name>
+     </statistic>
+     
+     <statistic>
+       <expression>mean(int(int_id))</expression>
+       <name>mean</name>
+     </statistic>
+     <statistic>
+       <expression>count(long(long_ld))</expression>
+       <name>count</name>
+     </statistic>
+     <statistic>
+       <expression>pow(mean(int(int_id)),count(long(long_ld)))</expression>
+       <name>power mean by count</name>
+     </statistic>
+   </analyticsRequest>
+   
+   <analyticsRequest>
+     <name>Negate Request</name>
+     
+     <statistic>
+       <expression>sum(int(int_id))</expression>
+       <name>sum</name>
+     </statistic>
+     <statistic>
+       <expression>neg(sum(int(int_id)))</expression>
+       <name>negate of sum</name>
+     </statistic>
+     
+     <statistic>
+       <expression>count(long(long_ld))</expression>
+       <name>count</name>
+     </statistic>
+     <statistic>
+       <expression>neg(count(long(long_ld)))</expression>
+       <name>negate of count</name>
+     </statistic>
+   </analyticsRequest>
+   
+   <analyticsRequest>
+     <name>Const Num Request</name>
+     
+     <statistic>
+       <expression>const_num(8)</expression>
+       <name>constant 8</name>
+     </statistic>
+     <statistic>
+       <expression>const_num(10)</expression>
+       <name>constant 10</name>
+     </statistic>
+   </analyticsRequest>
+   
+   <analyticsRequest>
+     <name>Date Math Request</name>
+     
+     <statistic>
+       <expression>median(date(date_dtd))</expression>
+       <name>median</name>
+     </statistic>
+     <statistic>
+       <expression>const_str(+2YEARS)</expression>
+       <name>constant str median</name>
+     </statistic>
+     <statistic>
+       <expression>date_math(median(date(date_dtd)),const_str(+2YEARS))</expression>
+       <name>date math median</name>
+     </statistic>
+     
+     <statistic>
+       <expression>max(date(date_dtd))</expression>
+       <name>max</name>
+     </statistic>
+     <statistic>
+       <expression>const_str(+2MONTHS)</expression>
+       <name>constant str max</name>
+     </statistic>
+     <statistic>
+       <expression>date_math(max(date(date_dtd)),const_str(+2MONTHS))</expression>
+       <name>date math max</name>
+     </statistic>
+   </analyticsRequest>
+   
+   <analyticsRequest>
+     <name>Constant Date Request</name>
+     
+     <statistic>
+       <expression>const_str(1800-12-31T23:59:59Z)</expression>
+       <name>const str 1</name>
+     </statistic>
+     <statistic>
+       <expression>const_date(1800-12-31T23:59:59Z)</expression>
+       <name>const date 1</name>
+     </statistic>
+     <statistic>
+       <expression>const_str(1804-06-30T23:59:59Z)</expression>
+       <name>const str 2</name>
+     </statistic>
+     <statistic>
+       <expression>const_date(1804-06-30T23:59:59Z)</expression>
+       <name>const date 2</name>
+     </statistic>
+   </analyticsRequest>
+   
+   <analyticsRequest>
+     <name>Constant String Request</name>
+     
+     <statistic>
+       <expression>const_str(this is the first)</expression>
+       <name>const str 1</name>
+     </statistic>
+     <statistic>
+       <expression>const_str(this is the second)</expression>
+       <name>const str 2</name>
+     </statistic>
+     <statistic>
+       <expression>const_str(this is the third)</expression>
+       <name>const str 3</name>
+     </statistic>
+   </analyticsRequest>
+   
+   <analyticsRequest>
+     <name>Concatenate Request</name>
+     
+     <statistic>
+       <expression>const_str(this is the first)</expression>
+       <name>const str min</name>
+     </statistic>
+     <statistic>
+       <expression>min(str(string_sd))</expression>
+       <name>min</name>
+     </statistic>
+     <statistic>
+       <expression>concat(const_str(this is the first),min(str(string_sd)))</expression>
+       <name>concat const and min</name>
+     </statistic>
+     
+     <statistic>
+       <expression>const_str(this is the second)</expression>
+       <name>const str max</name>
+     </statistic>
+     <statistic>
+       <expression>max(str(string_sd))</expression>
+       <name>max</name>
+     </statistic>
+     <statistic>
+       <expression>concat(const_str(this is the second),max(str(string_sd)))</expression>
+       <name>concat const and max</name>
+     </statistic>
+   </analyticsRequest>
+   
+   <analyticsRequest>
+     <name>Reverse Request</name>
+     
+     <statistic>
+       <expression>min(str(string_sd))</expression>
+       <name>min</name>
+     </statistic>
+     <statistic>
+       <expression>rev(min(str(string_sd)))</expression>
+       <name>reverse min</name>
+     </statistic>
+     
+     <statistic>
+       <expression>max(str(string_sd))</expression>
+       <name>max</name>
+     </statistic>
+     <statistic>
+       <expression>rev(max(str(string_sd)))</expression>
+       <name>reverse max</name>
+     </statistic>
+   </analyticsRequest>
 </analyticsRequestEnvelope> 
diff --git a/solr/contrib/analytics/src/test-files/analytics/requestXMLFiles/fieldFacetExtras.xml b/solr/contrib/analytics/src/test-files/analytics/requestXMLFiles/fieldFacetExtras.xml
index 5d7bf07..68b5be9 100644
--- a/solr/contrib/analytics/src/test-files/analytics/requestXMLFiles/fieldFacetExtras.xml
+++ b/solr/contrib/analytics/src/test-files/analytics/requestXMLFiles/fieldFacetExtras.xml
@@ -1,101 +1,101 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <analyticsRequestEnvelope stats="true" olap="true">
- 	<analyticsRequest>
- 		<name>sort request</name>
- 		
- 		<statistic>
- 			<expression>mean(int(int_id))</expression>
- 			<name>mean</name>
- 		</statistic>
- 		<statistic>
- 			<expression>median(int(int_id))</expression>
- 			<name>median</name>
- 		</statistic>
- 		<statistic>
- 			<expression>count(int(int_id))</expression>
- 			<name>count</name>
- 		</statistic>
- 		<statistic>
- 			<expression>perc(20,int(int_id))</expression>
- 			<name>perc_20</name>
- 		</statistic>
- 		
- 		<fieldFacet>
- 			<field>long_ld</field>
- 			<sortSpecification>
- 				<statName>mean</statName>
- 				<direction>asc</direction>
- 			</sortSpecification>
- 		</fieldFacet>
- 		<fieldFacet>
- 			<field>float_fd</field>
- 			<sortSpecification>
- 				<statName>median</statName>
- 				<direction>desc</direction>
- 			</sortSpecification>
- 		</fieldFacet>
- 		<fieldFacet>
- 			<field>double_dd</field>
- 			<sortSpecification>
- 				<statName>count</statName>
- 				<direction>asc</direction>
- 			</sortSpecification>
- 		</fieldFacet>
- 		<fieldFacet>
- 			<field>string_sd</field>
- 			<sortSpecification>
- 				<statName>perc_20</statName>
- 				<direction>desc</direction>
- 			</sortSpecification>
- 		</fieldFacet>
- 	</analyticsRequest>
- 	<analyticsRequest>
- 		<name>limit request</name>
- 		
- 		<statistic>
- 			<expression>mean(int(int_id))</expression>
- 			<name>mean</name>
- 		</statistic>
- 		<statistic>
- 			<expression>median(int(int_id))</expression>
- 			<name>median</name>
- 		</statistic>
- 		<statistic>
- 			<expression>count(int(int_id))</expression>
- 			<name>count</name>
- 		</statistic>
- 		<statistic>
- 			<expression>perc(20,int(int_id))</expression>
- 			<name>perc_20</name>
- 		</statistic>
- 		
- 		<fieldFacet limit="5">
- 			<field>long_ld</field>
- 			<sortSpecification>
- 				<statName>mean</statName>
- 				<direction>asc</direction>
- 			</sortSpecification>
- 		</fieldFacet>
- 		<fieldFacet limit="3">
- 			<field>float_fd</field>
- 			<sortSpecification>
- 				<statName>median</statName>
- 				<direction>desc</direction>
- 			</sortSpecification>
- 		</fieldFacet>
- 		<fieldFacet limit="7">
- 			<field>double_dd</field>
- 			<sortSpecification>
- 				<statName>count</statName>
- 				<direction>asc</direction>
- 			</sortSpecification>
- 		</fieldFacet>
- 		<fieldFacet limit="1">
- 			<field>string_sd</field>
- 			<sortSpecification>
- 				<statName>perc_20</statName>
- 				<direction>desc</direction>
- 			</sortSpecification>
- 		</fieldFacet>
- 	</analyticsRequest>
+   <analyticsRequest>
+     <name>sort request</name>
+     
+     <statistic>
+       <expression>mean(int(int_id))</expression>
+       <name>mean</name>
+     </statistic>
+     <statistic>
+       <expression>median(int(int_id))</expression>
+       <name>median</name>
+     </statistic>
+     <statistic>
+       <expression>count(int(int_id))</expression>
+       <name>count</name>
+     </statistic>
+     <statistic>
+       <expression>perc(20,int(int_id))</expression>
+       <name>perc_20</name>
+     </statistic>
+     
+     <fieldFacet>
+       <field>long_ld</field>
+       <sortSpecification>
+         <statName>mean</statName>
+         <direction>asc</direction>
+       </sortSpecification>
+     </fieldFacet>
+     <fieldFacet>
+       <field>float_fd</field>
+       <sortSpecification>
+         <statName>median</statName>
+         <direction>desc</direction>
+       </sortSpecification>
+     </fieldFacet>
+     <fieldFacet>
+       <field>double_dd</field>
+       <sortSpecification>
+         <statName>count</statName>
+         <direction>asc</direction>
+       </sortSpecification>
+     </fieldFacet>
+     <fieldFacet>
+       <field>string_sd</field>
+       <sortSpecification>
+         <statName>perc_20</statName>
+         <direction>desc</direction>
+       </sortSpecification>
+     </fieldFacet>
+   </analyticsRequest>
+   <analyticsRequest>
+     <name>limit request</name>
+     
+     <statistic>
+       <expression>mean(int(int_id))</expression>
+       <name>mean</name>
+     </statistic>
+     <statistic>
+       <expression>median(int(int_id))</expression>
+       <name>median</name>
+     </statistic>
+     <statistic>
+       <expression>count(int(int_id))</expression>
+       <name>count</name>
+     </statistic>
+     <statistic>
+       <expression>perc(20,int(int_id))</expression>
+       <name>perc_20</name>
+     </statistic>
+     
+     <fieldFacet limit="5">
+       <field>long_ld</field>
+       <sortSpecification>
+         <statName>mean</statName>
+         <direction>asc</direction>
+       </sortSpecification>
+     </fieldFacet>
+     <fieldFacet limit="3">
+       <field>float_fd</field>
+       <sortSpecification>
+         <statName>median</statName>
+         <direction>desc</direction>
+       </sortSpecification>
+     </fieldFacet>
+     <fieldFacet limit="7">
+       <field>double_dd</field>
+       <sortSpecification>
+         <statName>count</statName>
+         <direction>asc</direction>
+       </sortSpecification>
+     </fieldFacet>
+     <fieldFacet limit="1">
+       <field>string_sd</field>
+       <sortSpecification>
+         <statName>perc_20</statName>
+         <direction>desc</direction>
+       </sortSpecification>
+     </fieldFacet>
+   </analyticsRequest>
 </analyticsRequestEnvelope>
diff --git a/solr/contrib/analytics/src/test-files/analytics/requestXMLFiles/fieldFacets.xml b/solr/contrib/analytics/src/test-files/analytics/requestXMLFiles/fieldFacets.xml
index 53dd2d3..8e84cf1 100644
--- a/solr/contrib/analytics/src/test-files/analytics/requestXMLFiles/fieldFacets.xml
+++ b/solr/contrib/analytics/src/test-files/analytics/requestXMLFiles/fieldFacets.xml
@@ -1,496 +1,496 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <analyticsRequestEnvelope stats="true" olap="true">
- 	<analyticsRequest>
- 		<name>sum</name>
- 		
- 		<statistic>
- 			<expression>sum(int(int_id))</expression>
- 			<name>int</name>
- 		</statistic>
- 		<statistic>
- 			<expression>sum(long(long_ld))</expression>
- 			<name>long</name>
- 		</statistic>
- 		<statistic>
- 			<expression>sum(float(float_fd))</expression>
- 			<name>float</name>
- 		</statistic>
- 		<statistic>
- 			<expression>sum(double(double_dd))</expression>
- 			<name>double</name>
- 		</statistic>
- 		
- 		<fieldFacet>
- 			<field>string_sd</field>
- 		</fieldFacet>
- 		<fieldFacet>
- 			<field>date_dtd</field>
- 		</fieldFacet>
- 	</analyticsRequest>
- 	<analyticsRequest>
- 		<name>mean</name>
- 		
- 		<statistic>
- 			<expression>mean(int(int_id))</expression>
- 			<name>int</name>
- 		</statistic>
- 		<statistic>
- 			<expression>mean(long(long_ld))</expression>
- 			<name>long</name>
- 		</statistic>
- 		<statistic>
- 			<expression>mean(float(float_fd))</expression>
- 			<name>float</name>
- 		</statistic>
- 		<statistic>
- 			<expression>mean(double(double_dd))</expression>
- 			<name>double</name>
- 		</statistic>
- 		
- 		<fieldFacet>
- 			<field>string_sd</field>
- 		</fieldFacet>
- 		<fieldFacet>
- 			<field>date_dtd</field>
- 		</fieldFacet>
- 	</analyticsRequest>
- 	<analyticsRequest>
- 		<name>sumOfSquares</name>
- 		
- 		<statistic>
- 			<expression>sumofsquares(int(int_id))</expression>
- 			<name>int</name>
- 		</statistic>
- 		<statistic>
- 			<expression>sumofsquares(long(long_ld))</expression>
- 			<name>long</name>
- 		</statistic>
- 		<statistic>
- 			<expression>sumofsquares(float(float_fd))</expression>
- 			<name>float</name>
- 		</statistic>
- 		<statistic>
- 			<expression>sumofsquares(double(double_dd))</expression>
- 			<name>double</name>
- 		</statistic>
- 		
- 		<fieldFacet>
- 			<field>string_sd</field>
- 		</fieldFacet>
- 		<fieldFacet>
- 			<field>date_dtd</field>
- 		</fieldFacet>
- 	</analyticsRequest>
- 	<analyticsRequest>
- 		<name>stddev</name>
- 		
- 		<statistic>
- 			<expression>stddev(int(int_id))</expression>
- 			<name>int</name>
- 		</statistic>
- 		<statistic>
- 			<expression>stddev(long(long_ld))</expression>
- 			<name>long</name>
- 		</statistic>
- 		<statistic>
- 			<expression>stddev(float(float_fd))</expression>
- 			<name>float</name>
- 		</statistic>
- 		<statistic>
- 			<expression>stddev(double(double_dd))</expression>
- 			<name>double</name>
- 		</statistic>
- 		
- 		<fieldFacet>
- 			<field>string_sd</field>
- 		</fieldFacet>
- 		<fieldFacet>
- 			<field>date_dtd</field>
- 		</fieldFacet>
- 	</analyticsRequest>
- 	<analyticsRequest>
- 		<name>median</name>
- 		
- 		<statistic>
- 			<expression>median(int(int_id))</expression>
- 			<name>int</name>
- 		</statistic>
- 		<statistic>
- 			<expression>median(long(long_ld))</expression>
- 			<name>long</name>
- 		</statistic>
- 		<statistic>
- 			<expression>median(float(float_fd))</expression>
- 			<name>float</name>
- 		</statistic>
- 		<statistic>
- 			<expression>median(double(double_dd))</expression>
- 			<name>double</name>
- 		</statistic>
- 		
- 		<fieldFacet>
- 			<field>string_sd</field>
- 		</fieldFacet>
- 		<fieldFacet>
- 			<field>date_dtd</field>
- 		</fieldFacet>
- 	</analyticsRequest>
- 	<analyticsRequest>
- 		<name>perc_20 numeric</name>
- 		
- 		<statistic>
- 			<expression>perc(20,int(int_id))</expression>
- 			<name>int</name>
- 		</statistic>
- 		<statistic>
- 			<expression>perc(20,long(long_ld))</expression>
- 			<name>long</name>
- 		</statistic>
- 		<statistic>
- 			<expression>perc(20,float(float_fd))</expression>
- 			<name>float</name>
- 		</statistic>
- 		<statistic>
- 			<expression>perc(20,double(double_dd))</expression>
- 			<name>double</name>
- 		</statistic>
- 		
- 		<fieldFacet>
- 			<field>string_sd</field>
- 		</fieldFacet>
- 		<fieldFacet>
- 			<field>date_dtd</field>
- 		</fieldFacet>
- 	</analyticsRequest>
- 	<analyticsRequest>
- 		<name>perc_20</name>
- 		
- 		<statistic>
- 			<expression>perc(20,str(string_sd))</expression>
- 			<name>str</name>
- 		</statistic>
- 		<statistic>
- 			<expression>perc(20,date(date_dtd))</expression>
- 			<name>date</name>
- 		</statistic>
- 		
- 		<fieldFacet>
- 			<field>int_id</field>
- 		</fieldFacet>
- 		<fieldFacet>
- 			<field>long_ld</field>
- 		</fieldFacet>
- 	</analyticsRequest>
- 	<analyticsRequest>
- 		<name>perc_60 numeric</name>
- 		
- 		<statistic>
- 			<expression>perc(60,int(int_id))</expression>
- 			<name>int</name>
- 		</statistic>
- 		<statistic>
- 			<expression>perc(60,long(long_ld))</expression>
- 			<name>long</name>
- 		</statistic>
- 		<statistic>
- 			<expression>perc(60,float(float_fd))</expression>
- 			<name>float</name>
- 		</statistic>
- 		<statistic>
- 			<expression>perc(60,double(double_dd))</expression>
- 			<name>double</name>
- 		</statistic>
- 		
- 		<fieldFacet>
- 			<field>string_sd</field>
- 		</fieldFacet>
- 		<fieldFacet>
- 			<field>date_dtd</field>
- 		</fieldFacet>
- 	</analyticsRequest>
- 	<analyticsRequest>
- 		<name>perc_60</name>
- 		
- 		<statistic>
- 			<expression>perc(60,str(string_sd))</expression>
- 			<name>str</name>
- 		</statistic>
- 		<statistic>
- 			<expression>perc(60,date(date_dtd))</expression>
- 			<name>date</name>
- 		</statistic>
- 		
- 		<fieldFacet>
- 			<field>int_id</field>
- 		</fieldFacet>
- 		<fieldFacet>
- 			<field>long_ld</field>
- 		</fieldFacet>
- 	</analyticsRequest>
- 	<analyticsRequest>
- 		<name>min numeric</name>
- 		
- 		<statistic>
- 			<expression>min(int(int_id))</expression>
- 			<name>int</name>
- 		</statistic>
- 		<statistic>
- 			<expression>min(long(long_ld))</expression>
- 			<name>long</name>
- 		</statistic>
- 		<statistic>
- 			<expression>min(float(float_fd))</expression>
- 			<name>float</name>
- 		</statistic>
- 		<statistic>
- 			<expression>min(double(double_dd))</expression>
- 			<name>double</name>
- 		</statistic>
- 		
- 		<fieldFacet>
- 			<field>string_sd</field>
- 		</fieldFacet>
- 		<fieldFacet>
- 			<field>date_dtd</field>
- 		</fieldFacet>
- 	</analyticsRequest>
- 	<analyticsRequest>
- 		<name>min</name>
- 		
- 		<statistic>
- 			<expression>min(str(string_sd))</expression>
- 			<name>str</name>
- 		</statistic>
- 		<statistic>
- 			<expression>min(date(date_dtd))</expression>
- 			<name>date</name>
- 		</statistic>
- 		
- 		<fieldFacet>
- 			<field>int_id</field>
- 		</fieldFacet>
- 		<fieldFacet>
- 			<field>long_ld</field>
- 		</fieldFacet>
- 	</analyticsRequest>
- 	<analyticsRequest>
- 		<name>max numeric</name>
- 		
- 		<statistic>
- 			<expression>max(int(int_id))</expression>
- 			<name>int</name>
- 		</statistic>
- 		<statistic>
- 			<expression>max(long(long_ld))</expression>
- 			<name>long</name>
- 		</statistic>
- 		<statistic>
- 			<expression>max(float(float_fd))</expression>
- 			<name>float</name>
- 		</statistic>
- 		<statistic>
- 			<expression>max(double(double_dd))</expression>
- 			<name>double</name>
- 		</statistic>
- 		
- 		<fieldFacet>
- 			<field>string_sd</field>
- 		</fieldFacet>
- 		<fieldFacet>
- 			<field>date_dtd</field>
- 		</fieldFacet>
- 	</analyticsRequest>
- 	<analyticsRequest>
- 		<name>max</name>
- 		
- 		<statistic>
- 			<expression>max(str(string_sd))</expression>
- 			<name>str</name>
- 		</statistic>
- 		<statistic>
- 			<expression>max(date(date_dtd))</expression>
- 			<name>date</name>
- 		</statistic>
- 		
- 		<fieldFacet>
- 			<field>int_id</field>
- 		</fieldFacet>
- 		<fieldFacet>
- 			<field>long_ld</field>
- 		</fieldFacet>
- 	</analyticsRequest>
- 	<analyticsRequest>
- 		<name>count numeric</name>
- 		
- 		<statistic>
- 			<expression>count(int(int_id))</expression>
- 			<name>int</name>
- 		</statistic>
- 		<statistic>
- 			<expression>count(long(long_ld))</expression>
- 			<name>long</name>
- 		</statistic>
- 		<statistic>
- 			<expression>count(float(float_fd))</expression>
- 			<name>float</name>
- 		</statistic>
- 		<statistic>
- 			<expression>count(double(double_dd))</expression>
- 			<name>double</name>
- 		</statistic>
- 		
- 		<fieldFacet>
- 			<field>string_sd</field>
- 		</fieldFacet>
- 		<fieldFacet>
- 			<field>date_dtd</field>
- 		</fieldFacet>
- 	</analyticsRequest>
- 	<analyticsRequest>
- 		<name>count</name>
- 		
- 		<statistic>
- 			<expression>count(str(string_sd))</expression>
- 			<name>str</name>
- 		</statistic>
- 		<statistic>
- 			<expression>count(date(date_dtd))</expression>
- 			<name>date</name>
- 		</statistic>
- 		
- 		<fieldFacet>
- 			<field>int_id</field>
- 		</fieldFacet>
- 		<fieldFacet>
- 			<field>long_ld</field>
- 		</fieldFacet>
- 	</analyticsRequest>
- 	<analyticsRequest>
- 		<name>unique numeric</name>
- 		
- 		<statistic>
- 			<expression>unique(int(int_id))</expression>
- 			<name>int</name>
- 		</statistic>
- 		<statistic>
- 			<expression>unique(long(long_ld))</expression>
- 			<name>long</name>
- 		</statistic>
- 		<statistic>
- 			<expression>unique(float(float_fd))</expression>
- 			<name>float</name>
- 		</statistic>
- 		<statistic>
- 			<expression>unique(double(double_dd))</expression>
- 			<name>double</name>
- 		</statistic>
- 		
- 		<fieldFacet>
- 			<field>string_sd</field>
- 		</fieldFacet>
- 		<fieldFacet>
- 			<field>date_dtd</field>
- 		</fieldFacet>
- 	</analyticsRequest>
- 	<analyticsRequest>
- 		<name>unique</name>
- 		
- 		<statistic>
- 			<expression>unique(str(string_sd))</expression>
- 			<name>str</name>
- 		</statistic>
- 		<statistic>
- 			<expression>unique(date(date_dtd))</expression>
- 			<name>date</name>
- 		</statistic>
- 		
- 		<fieldFacet>
- 			<field>int_id</field>
- 		</fieldFacet>
- 		<fieldFacet>
- 			<field>long_ld</field>
- 		</fieldFacet>
- 	</analyticsRequest>
- 	<analyticsRequest>
- 		<name>missing numeric</name>
- 		
- 		<statistic>
- 			<expression>missing(int{int_id})</expression>
- 			<name>int</name>
- 		</statistic>
- 		<statistic>
- 			<expression>missing(long{long_ld})</expression>
- 			<name>long</name>
- 		</statistic>
- 		<statistic>
- 			<expression>missing(float{float_fd})</expression>
- 			<name>float</name>
- 		</statistic>
- 		<statistic>
- 			<expression>missing(double{double_dd})</expression>
- 			<name>double</name>
- 		</statistic>
- 		
- 		<fieldFacet>
- 			<field>string_sd</field>
- 		</fieldFacet>
- 		<fieldFacet>
- 			<field>date_dtd</field>
- 		</fieldFacet>
- 	</analyticsRequest>
- 	<analyticsRequest>
- 		<name>missing</name>
- 		
- 		<statistic>
- 			<expression>missing(str{string_sd})</expression>
- 			<name>str</name>
- 		</statistic>
- 		<statistic>
- 			<expression>missing(date{date_dtd})</expression>
- 			<name>date</name>
- 		</statistic>
- 		
- 		<fieldFacet>
- 			<field>int_id</field>
- 		</fieldFacet>
- 		<fieldFacet>
- 			<field>long_ld</field>
- 		</fieldFacet>
- 	</analyticsRequest>
- 	<analyticsRequest>
- 		<name>multivalued</name>
- 		
- 		<statistic>
- 			<expression>mean(int(int_id))</expression>
- 			<name>mean</name>
- 		</statistic>
- 		
- 		<fieldFacet>
- 			<field>long_ldm</field>
- 		</fieldFacet>
- 		<fieldFacet>
- 			<field>string_sdm</field>
- 		</fieldFacet>
- 		<fieldFacet>
- 			<field>date_dtdm</field>
- 		</fieldFacet>
- 	</analyticsRequest>
- 	<analyticsRequest>
- 		<name>missing facet</name>
+   <analyticsRequest>
+     <name>sum</name>
+     
+     <statistic>
+       <expression>sum(int(int_id))</expression>
+       <name>int</name>
+     </statistic>
+     <statistic>
+       <expression>sum(long(long_ld))</expression>
+       <name>long</name>
+     </statistic>
+     <statistic>
+       <expression>sum(float(float_fd))</expression>
+       <name>float</name>
+     </statistic>
+     <statistic>
+       <expression>sum(double(double_dd))</expression>
+       <name>double</name>
+     </statistic>
+     
+     <fieldFacet>
+       <field>string_sd</field>
+     </fieldFacet>
+     <fieldFacet>
+       <field>date_dtd</field>
+     </fieldFacet>
+   </analyticsRequest>
+   <analyticsRequest>
+     <name>mean</name>
+     
+     <statistic>
+       <expression>mean(int(int_id))</expression>
+       <name>int</name>
+     </statistic>
+     <statistic>
+       <expression>mean(long(long_ld))</expression>
+       <name>long</name>
+     </statistic>
+     <statistic>
+       <expression>mean(float(float_fd))</expression>
+       <name>float</name>
+     </statistic>
+     <statistic>
+       <expression>mean(double(double_dd))</expression>
+       <name>double</name>
+     </statistic>
+     
+     <fieldFacet>
+       <field>string_sd</field>
+     </fieldFacet>
+     <fieldFacet>
+       <field>date_dtd</field>
+     </fieldFacet>
+   </analyticsRequest>
+   <analyticsRequest>
+     <name>sumOfSquares</name>
+     
+     <statistic>
+       <expression>sumofsquares(int(int_id))</expression>
+       <name>int</name>
+     </statistic>
+     <statistic>
+       <expression>sumofsquares(long(long_ld))</expression>
+       <name>long</name>
+     </statistic>
+     <statistic>
+       <expression>sumofsquares(float(float_fd))</expression>
+       <name>float</name>
+     </statistic>
+     <statistic>
+       <expression>sumofsquares(double(double_dd))</expression>
+       <name>double</name>
+     </statistic>
+     
+     <fieldFacet>
+       <field>string_sd</field>
+     </fieldFacet>
+     <fieldFacet>
+       <field>date_dtd</field>
+     </fieldFacet>
+   </analyticsRequest>
+   <analyticsRequest>
+     <name>stddev</name>
+     
+     <statistic>
+       <expression>stddev(int(int_id))</expression>
+       <name>int</name>
+     </statistic>
+     <statistic>
+       <expression>stddev(long(long_ld))</expression>
+       <name>long</name>
+     </statistic>
+     <statistic>
+       <expression>stddev(float(float_fd))</expression>
+       <name>float</name>
+     </statistic>
+     <statistic>
+       <expression>stddev(double(double_dd))</expression>
+       <name>double</name>
+     </statistic>
+     
+     <fieldFacet>
+       <field>string_sd</field>
+     </fieldFacet>
+     <fieldFacet>
+       <field>date_dtd</field>
+     </fieldFacet>
+   </analyticsRequest>
+   <analyticsRequest>
+     <name>median</name>
+     
+     <statistic>
+       <expression>median(int(int_id))</expression>
+       <name>int</name>
+     </statistic>
+     <statistic>
+       <expression>median(long(long_ld))</expression>
+       <name>long</name>
+     </statistic>
+     <statistic>
+       <expression>median(float(float_fd))</expression>
+       <name>float</name>
+     </statistic>
+     <statistic>
+       <expression>median(double(double_dd))</expression>
+       <name>double</name>
+     </statistic>
+     
+     <fieldFacet>
+       <field>string_sd</field>
+     </fieldFacet>
+     <fieldFacet>
+       <field>date_dtd</field>
+     </fieldFacet>
+   </analyticsRequest>
+   <analyticsRequest>
+     <name>perc_20 numeric</name>
+     
+     <statistic>
+       <expression>perc(20,int(int_id))</expression>
+       <name>int</name>
+     </statistic>
+     <statistic>
+       <expression>perc(20,long(long_ld))</expression>
+       <name>long</name>
+     </statistic>
+     <statistic>
+       <expression>perc(20,float(float_fd))</expression>
+       <name>float</name>
+     </statistic>
+     <statistic>
+       <expression>perc(20,double(double_dd))</expression>
+       <name>double</name>
+     </statistic>
+     
+     <fieldFacet>
+       <field>string_sd</field>
+     </fieldFacet>
+     <fieldFacet>
+       <field>date_dtd</field>
+     </fieldFacet>
+   </analyticsRequest>
+   <analyticsRequest>
+     <name>perc_20</name>
+     
+     <statistic>
+       <expression>perc(20,str(string_sd))</expression>
+       <name>str</name>
+     </statistic>
+     <statistic>
+       <expression>perc(20,date(date_dtd))</expression>
+       <name>date</name>
+     </statistic>
+     
+     <fieldFacet>
+       <field>int_id</field>
+     </fieldFacet>
+     <fieldFacet>
+       <field>long_ld</field>
+     </fieldFacet>
+   </analyticsRequest>
+   <analyticsRequest>
+     <name>perc_60 numeric</name>
+     
+     <statistic>
+       <expression>perc(60,int(int_id))</expression>
+       <name>int</name>
+     </statistic>
+     <statistic>
+       <expression>perc(60,long(long_ld))</expression>
+       <name>long</name>
+     </statistic>
+     <statistic>
+       <expression>perc(60,float(float_fd))</expression>
+       <name>float</name>
+     </statistic>
+     <statistic>
+       <expression>perc(60,double(double_dd))</expression>
+       <name>double</name>
+     </statistic>
+     
+     <fieldFacet>
+       <field>string_sd</field>
+     </fieldFacet>
+     <fieldFacet>
+       <field>date_dtd</field>
+     </fieldFacet>
+   </analyticsRequest>
+   <analyticsRequest>
+     <name>perc_60</name>
+     
+     <statistic>
+       <expression>perc(60,str(string_sd))</expression>
+       <name>str</name>
+     </statistic>
+     <statistic>
+       <expression>perc(60,date(date_dtd))</expression>
+       <name>date</name>
+     </statistic>
+     
+     <fieldFacet>
+       <field>int_id</field>
+     </fieldFacet>
+     <fieldFacet>
+       <field>long_ld</field>
+     </fieldFacet>
+   </analyticsRequest>
+   <analyticsRequest>
+     <name>min numeric</name>
+     
+     <statistic>
+       <expression>min(int(int_id))</expression>
+       <name>int</name>
+     </statistic>
+     <statistic>
+       <expression>min(long(long_ld))</expression>
+       <name>long</name>
+     </statistic>
+     <statistic>
+       <expression>min(float(float_fd))</expression>
+       <name>float</name>
+     </statistic>
+     <statistic>
+       <expression>min(double(double_dd))</expression>
+       <name>double</name>
+     </statistic>
+     
+     <fieldFacet>
+       <field>string_sd</field>
+     </fieldFacet>
+     <fieldFacet>
+       <field>date_dtd</field>
+     </fieldFacet>
+   </analyticsRequest>
+   <analyticsRequest>
+     <name>min</name>
+     
+     <statistic>
+       <expression>min(str(string_sd))</expression>
+       <name>str</name>
+     </statistic>
+     <statistic>
+       <expression>min(date(date_dtd))</expression>
+       <name>date</name>
+     </statistic>
+     
+     <fieldFacet>
+       <field>int_id</field>
+     </fieldFacet>
+     <fieldFacet>
+       <field>long_ld</field>
+     </fieldFacet>
+   </analyticsRequest>
+   <analyticsRequest>
+     <name>max numeric</name>
+     
+     <statistic>
+       <expression>max(int(int_id))</expression>
+       <name>int</name>
+     </statistic>
+     <statistic>
+       <expression>max(long(long_ld))</expression>
+       <name>long</name>
+     </statistic>
+     <statistic>
+       <expression>max(float(float_fd))</expression>
+       <name>float</name>
+     </statistic>
+     <statistic>
+       <expression>max(double(double_dd))</expression>
+       <name>double</name>
+     </statistic>
+     
+     <fieldFacet>
+       <field>string_sd</field>
+     </fieldFacet>
+     <fieldFacet>
+       <field>date_dtd</field>
+     </fieldFacet>
+   </analyticsRequest>
+   <analyticsRequest>
+     <name>max</name>
+     
+     <statistic>
+       <expression>max(str(string_sd))</expression>
+       <name>str</name>
+     </statistic>
+     <statistic>
+       <expression>max(date(date_dtd))</expression>
+       <name>date</name>
+     </statistic>
+     
+     <fieldFacet>
+       <field>int_id</field>
+     </fieldFacet>
+     <fieldFacet>
+       <field>long_ld</field>
+     </fieldFacet>
+   </analyticsRequest>
+   <analyticsRequest>
+     <name>count numeric</name>
+     
+     <statistic>
+       <expression>count(int(int_id))</expression>
+       <name>int</name>
+     </statistic>
+     <statistic>
+       <expression>count(long(long_ld))</expression>
+       <name>long</name>
+     </statistic>
+     <statistic>
+       <expression>count(float(float_fd))</expression>
+       <name>float</name>
+     </statistic>
+     <statistic>
+       <expression>count(double(double_dd))</expression>
+       <name>double</name>
+     </statistic>
+     
+     <fieldFacet>
+       <field>string_sd</field>
+     </fieldFacet>
+     <fieldFacet>
+       <field>date_dtd</field>
+     </fieldFacet>
+   </analyticsRequest>
+   <analyticsRequest>
+     <name>count</name>
+     
+     <statistic>
+       <expression>count(str(string_sd))</expression>
+       <name>str</name>
+     </statistic>
+     <statistic>
+       <expression>count(date(date_dtd))</expression>
+       <name>date</name>
+     </statistic>
+     
+     <fieldFacet>
+       <field>int_id</field>
+     </fieldFacet>
+     <fieldFacet>
+       <field>long_ld</field>
+     </fieldFacet>
+   </analyticsRequest>
+   <analyticsRequest>
+     <name>unique numeric</name>
+     
+     <statistic>
+       <expression>unique(int(int_id))</expression>
+       <name>int</name>
+     </statistic>
+     <statistic>
+       <expression>unique(long(long_ld))</expression>
+       <name>long</name>
+     </statistic>
+     <statistic>
+       <expression>unique(float(float_fd))</expression>
+       <name>float</name>
+     </statistic>
+     <statistic>
+       <expression>unique(double(double_dd))</expression>
+       <name>double</name>
+     </statistic>
+     
+     <fieldFacet>
+       <field>string_sd</field>
+     </fieldFacet>
+     <fieldFacet>
+       <field>date_dtd</field>
+     </fieldFacet>
+   </analyticsRequest>
+   <analyticsRequest>
+     <name>unique</name>
+     
+     <statistic>
+       <expression>unique(str(string_sd))</expression>
+       <name>str</name>
+     </statistic>
+     <statistic>
+       <expression>unique(date(date_dtd))</expression>
+       <name>date</name>
+     </statistic>
+     
+     <fieldFacet>
+       <field>int_id</field>
+     </fieldFacet>
+     <fieldFacet>
+       <field>long_ld</field>
+     </fieldFacet>
+   </analyticsRequest>
+   <analyticsRequest>
+     <name>missing numeric</name>
+     
+     <statistic>
+       <expression>missing(int{int_id})</expression>
+       <name>int</name>
+     </statistic>
+     <statistic>
+       <expression>missing(long{long_ld})</expression>
+       <name>long</name>
+     </statistic>
+     <statistic>
+       <expression>missing(float{float_fd})</expression>
+       <name>float</name>
+     </statistic>
+     <statistic>
+       <expression>missing(double{double_dd})</expression>
+       <name>double</name>
+     </statistic>
+     
+     <fieldFacet>
+       <field>string_sd</field>
+     </fieldFacet>
+     <fieldFacet>
+       <field>date_dtd</field>
+     </fieldFacet>
+   </analyticsRequest>
+   <analyticsRequest>
+     <name>missing</name>
+     
+     <statistic>
+       <expression>missing(str{string_sd})</expression>
+       <name>str</name>
+     </statistic>
+     <statistic>
+       <expression>missing(date{date_dtd})</expression>
+       <name>date</name>
+     </statistic>
+     
+     <fieldFacet>
+       <field>int_id</field>
+     </fieldFacet>
+     <fieldFacet>
+       <field>long_ld</field>
+     </fieldFacet>
+   </analyticsRequest>
+   <analyticsRequest>
+     <name>multivalued</name>
+     
+     <statistic>
+       <expression>mean(int(int_id))</expression>
+       <name>mean</name>
+     </statistic>
+     
+     <fieldFacet>
+       <field>long_ldm</field>
+     </fieldFacet>
+     <fieldFacet>
+       <field>string_sdm</field>
+     </fieldFacet>
+     <fieldFacet>
+       <field>date_dtdm</field>
+     </fieldFacet>
+   </analyticsRequest>
+   <analyticsRequest>
+     <name>missing facet</name>
 
- 		<statistic>
- 			<expression>mean(int(int_id))</expression>
- 			<name>mean</name>
- 		</statistic>
- 		
- 		<fieldFacet>
- 			<field>date_dtd</field>
- 		</fieldFacet>
- 		<fieldFacet showMissing="true">
- 			<field>string_sd</field>
- 		</fieldFacet>
- 		<fieldFacet showMissing="true">
- 			<field>date_dtdm</field>
- 		</fieldFacet>
- 	</analyticsRequest>
+     <statistic>
+       <expression>mean(int(int_id))</expression>
+       <name>mean</name>
+     </statistic>
+     
+     <fieldFacet>
+       <field>date_dtd</field>
+     </fieldFacet>
+     <fieldFacet showMissing="true">
+       <field>string_sd</field>
+     </fieldFacet>
+     <fieldFacet showMissing="true">
+       <field>date_dtdm</field>
+     </fieldFacet>
+   </analyticsRequest>
 </analyticsRequestEnvelope>
diff --git a/solr/contrib/analytics/src/test-files/analytics/requestXMLFiles/functions.xml b/solr/contrib/analytics/src/test-files/analytics/requestXMLFiles/functions.xml
index 40f5ada..8fa92b6 100644
--- a/solr/contrib/analytics/src/test-files/analytics/requestXMLFiles/functions.xml
+++ b/solr/contrib/analytics/src/test-files/analytics/requestXMLFiles/functions.xml
@@ -1,246 +1,246 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <analyticsRequestEnvelope stats="true" olap="true">
- 	<analyticsRequest>
- 		<name>Add Request</name>
- 		
- 		<statistic>
- 			<expression>sum(add(int(int_id),float(float_fd)))</expression>
- 			<name>sum</name>
- 		</statistic>
- 		<statistic>
- 			<expression>sum(double(add_if_dd))</expression>
- 			<name>sum calced</name>
- 		</statistic>
- 		
- 		<statistic>
- 			<expression>mean(add(long(long_ld),double(double_dd),float(float_fd)))</expression>
- 			<name>mean</name>
- 		</statistic>
- 		<statistic>
- 			<expression>mean(double(add_ldf_dd))</expression>
- 			<name>mean calced</name>
- 		</statistic>
- 	</analyticsRequest>
- 	
- 	<analyticsRequest>
- 		<name>Multiply Request</name>
- 		
- 		<statistic>
- 			<expression>sum(mult(int(int_id),float(float_fd)))</expression>
- 			<name>sum</name>
- 		</statistic>
- 		<statistic>
- 			<expression>sum(double(mult_if_dd))</expression>
- 			<name>sum calced</name>
- 		</statistic>
- 		
- 		<statistic>
- 			<expression>mean(mult(long(long_ld),double(double_dd),float(float_fd)))</expression>
- 			<name>mean</name>
- 		</statistic>
- 		<statistic>
- 			<expression>mean(double(mult_ldf_dd))</expression>
- 			<name>mean calced</name>
- 		</statistic>
- 	</analyticsRequest>
- 	
- 	<analyticsRequest>
- 		<name>Divide Request</name>
- 		
- 		<statistic>
- 			<expression>sum(div(int(int_id),float(float_fd)))</expression>
- 			<name>sum</name>
- 		</statistic>
- 		<statistic>
- 			<expression>sum(double(div_if_dd))</expression>
- 			<name>sum calced</name>
- 		</statistic>
- 		
- 		<statistic>
- 			<expression>mean(div(long(long_ld),double(double_dd)))</expression>
- 			<name>mean</name>
- 		</statistic>
- 		
- 		<statistic>
- 			<expression>mean(double(div_ld_dd))</expression>
- 			<name>mean calced</name>
- 		</statistic>
- 	</analyticsRequest>
- 	
- 	<analyticsRequest>
- 		<name>Power Request</name>
- 		
- 		<statistic>
- 			<expression>sum(pow(int(int_id),float(float_fd))</expression>
- 			<name>sum</name>
- 		</statistic>
- 		<statistic>
- 			<expression>sum(double(pow_if_dd))</expression>
- 			<name>sum calced</name>
- 		</statistic>
- 		
- 		<statistic>
- 			<expression>mean(pow(long(long_ld),double(double_dd)))</expression>
- 			<name>mean</name>
- 		</statistic>
- 		
- 		<statistic>
- 			<expression>mean(double(pow_ld_dd))</expression>
- 			<name>mean calced</name>
- 		</statistic>
- 	</analyticsRequest>
- 	
- 	<analyticsRequest>
- 		<name>Negate Request</name>
- 		
- 		<statistic>
- 			<expression>sum(neg(int(int_id)))</expression>
- 			<name>sum</name>
- 		</statistic>
- 		<statistic>
- 			<expression>sum(double(neg_i_dd))</expression>
- 			<name>sum calced</name>
- 		</statistic>
- 		
- 		<statistic>
- 			<expression>mean(neg(long(long_ld)))</expression>
- 			<name>mean</name>
- 		</statistic>
- 		<statistic>
- 			<expression>mean(double(neg_l_dd))</expression>
- 			<name>mean calced</name>
- 		</statistic>
- 	</analyticsRequest>
- 	
- 	<analyticsRequest>
- 		<name>Const Num Request</name>
- 		
- 		<statistic>
- 			<expression>sum(const_num(8))</expression>
- 			<name>sum</name>
- 		</statistic>
- 		<statistic>
- 			<expression>sum(double(const_8_dd))</expression>
- 			<name>sum calced</name>
- 		</statistic>
- 		
- 		<statistic>
- 			<expression>mean(const_num(10))</expression>
- 			<name>mean</name>
- 		</statistic>
- 		<statistic>
- 			<expression>mean(double(const_10_dd))</expression>
- 			<name>mean calced</name>
- 		</statistic>
- 	</analyticsRequest>
- 	
- 	<analyticsRequest>
- 		<name>Date Math Request</name>
- 		
- 		<statistic>
- 			<expression>median(date_math(date(date_dtd),const_str(+2YEARS)))</expression>
- 			<name>median</name>
- 		</statistic>
- 		<statistic>
- 			<expression>median(date(dm_2y_dtd))</expression>
- 			<name>median calced</name>
- 		</statistic>
- 		
- 		<statistic>
- 			<expression>max(date_math(date(date_dtd),const_str(+2MONTHS)))</expression>
- 			<name>max</name>
- 		</statistic>
- 		<statistic>
- 			<expression>max(date(dm_2m_dtd))</expression>
- 			<name>max calced</name>
- 		</statistic>
- 	</analyticsRequest>
- 	
- 	<analyticsRequest>
- 		<name>Constant Date Request</name>
- 		
- 		<statistic>
- 			<expression>median(const_date(1800-06-30T23:59:59Z))</expression>
- 			<name>median</name>
- 		</statistic>
- 		<statistic>
- 			<expression>median(date(const_00_dtd))</expression>
- 			<name>median calced</name>
- 		</statistic>
- 		
- 		<statistic>
- 			<expression>max(const_date(1804-06-30T23:59:59Z))</expression>
- 			<name>max</name>
- 		</statistic>
- 		<statistic>
- 			<expression>max(date(const_04_dtd))</expression>
- 			<name>max calced</name>
- 		</statistic>
- 	</analyticsRequest>
- 	
- 	<analyticsRequest>
- 		<name>Constant String Request</name>
- 		
- 		<statistic>
- 			<expression>min(const_str(this is the first))</expression>
- 			<name>min</name>
- 		</statistic>
- 		<statistic>
- 			<expression>min(str(const_first_sd))</expression>
- 			<name>min calced</name>
- 		</statistic>
- 		
- 		<statistic>
- 			<expression>max(const_str(this is the second))</expression>
- 			<name>max</name>
- 		</statistic>
- 		<statistic>
- 			<expression>max(str(const_second_sd))</expression>
- 			<name>max calced</name>
- 		</statistic>
- 	</analyticsRequest>
- 	
- 	<analyticsRequest>
- 		<name>Concatenate Request</name>
- 		
- 		<statistic>
- 			<expression>min(concat(const_str(this is the first),str(string_sd)))</expression>
- 			<name>min</name>
- 		</statistic>
- 		<statistic>
- 			<expression>min(str(concat_first_sd))</expression>
- 			<name>min calced</name>
- 		</statistic>
- 		
- 		<statistic>
- 			<expression>max(concat(const_str(this is the second),str(string_sd)))</expression>
- 			<name>max</name>
- 		</statistic>
- 		<statistic>
- 			<expression>max(str(concat_second_sd))</expression>
- 			<name>max calced</name>
- 		</statistic>
- 	</analyticsRequest>
- 	
- 	<analyticsRequest>
- 		<name>Reverse Request</name>
- 		
- 		<statistic>
- 			<expression>min(rev(str(string_sd)))</expression>
- 			<name>min</name>
- 		</statistic>
- 		<statistic>
- 			<expression>min(str(rev_sd))</expression>
- 			<name>min calced</name>
- 		</statistic>
- 		
- 		<statistic>
- 			<expression>max(rev(str(string_sd)))</expression>
- 			<name>max</name>
- 		</statistic>
- 		<statistic>
- 			<expression>max(str(rev_sd))</expression>
- 			<name>max calced</name>
- 		</statistic>
- 	</analyticsRequest>
+   <analyticsRequest>
+     <name>Add Request</name>
+     
+     <statistic>
+       <expression>sum(add(int(int_id),float(float_fd)))</expression>
+       <name>sum</name>
+     </statistic>
+     <statistic>
+       <expression>sum(double(add_if_dd))</expression>
+       <name>sum calced</name>
+     </statistic>
+     
+     <statistic>
+       <expression>mean(add(long(long_ld),double(double_dd),float(float_fd)))</expression>
+       <name>mean</name>
+     </statistic>
+     <statistic>
+       <expression>mean(double(add_ldf_dd))</expression>
+       <name>mean calced</name>
+     </statistic>
+   </analyticsRequest>
+   
+   <analyticsRequest>
+     <name>Multiply Request</name>
+     
+     <statistic>
+       <expression>sum(mult(int(int_id),float(float_fd)))</expression>
+       <name>sum</name>
+     </statistic>
+     <statistic>
+       <expression>sum(double(mult_if_dd))</expression>
+       <name>sum calced</name>
+     </statistic>
+     
+     <statistic>
+       <expression>mean(mult(long(long_ld),double(double_dd),float(float_fd)))</expression>
+       <name>mean</name>
+     </statistic>
+     <statistic>
+       <expression>mean(double(mult_ldf_dd))</expression>
+       <name>mean calced</name>
+     </statistic>
+   </analyticsRequest>
+   
+   <analyticsRequest>
+     <name>Divide Request</name>
+     
+     <statistic>
+       <expression>sum(div(int(int_id),float(float_fd)))</expression>
+       <name>sum</name>
+     </statistic>
+     <statistic>
+       <expression>sum(double(div_if_dd))</expression>
+       <name>sum calced</name>
+     </statistic>
+     
+     <statistic>
+       <expression>mean(div(long(long_ld),double(double_dd)))</expression>
+       <name>mean</name>
+     </statistic>
+     
+     <statistic>
+       <expression>mean(double(div_ld_dd))</expression>
+       <name>mean calced</name>
+     </statistic>
+   </analyticsRequest>
+   
+   <analyticsRequest>
+     <name>Power Request</name>
+     
+     <statistic>
+       <expression>sum(pow(int(int_id),float(float_fd))</expression>
+       <name>sum</name>
+     </statistic>
+     <statistic>
+       <expression>sum(double(pow_if_dd))</expression>
+       <name>sum calced</name>
+     </statistic>
+     
+     <statistic>
+       <expression>mean(pow(long(long_ld),double(double_dd)))</expression>
+       <name>mean</name>
+     </statistic>
+     
+     <statistic>
+       <expression>mean(double(pow_ld_dd))</expression>
+       <name>mean calced</name>
+     </statistic>
+   </analyticsRequest>
+   
+   <analyticsRequest>
+     <name>Negate Request</name>
+     
+     <statistic>
+       <expression>sum(neg(int(int_id)))</expression>
+       <name>sum</name>
+     </statistic>
+     <statistic>
+       <expression>sum(double(neg_i_dd))</expression>
+       <name>sum calced</name>
+     </statistic>
+     
+     <statistic>
+       <expression>mean(neg(long(long_ld)))</expression>
+       <name>mean</name>
+     </statistic>
+     <statistic>
+       <expression>mean(double(neg_l_dd))</expression>
+       <name>mean calced</name>
+     </statistic>
+   </analyticsRequest>
+   
+   <analyticsRequest>
+     <name>Const Num Request</name>
+     
+     <statistic>
+       <expression>sum(const_num(8))</expression>
+       <name>sum</name>
+     </statistic>
+     <statistic>
+       <expression>sum(double(const_8_dd))</expression>
+       <name>sum calced</name>
+     </statistic>
+     
+     <statistic>
+       <expression>mean(const_num(10))</expression>
+       <name>mean</name>
+     </statistic>
+     <statistic>
+       <expression>mean(double(const_10_dd))</expression>
+       <name>mean calced</name>
+     </statistic>
+   </analyticsRequest>
+   
+   <analyticsRequest>
+     <name>Date Math Request</name>
+     
+     <statistic>
+       <expression>median(date_math(date(date_dtd),const_str(+2YEARS)))</expression>
+       <name>median</name>
+     </statistic>
+     <statistic>
+       <expression>median(date(dm_2y_dtd))</expression>
+       <name>median calced</name>
+     </statistic>
+     
+     <statistic>
+       <expression>max(date_math(date(date_dtd),const_str(+2MONTHS)))</expression>
+       <name>max</name>
+     </statistic>
+     <statistic>
+       <expression>max(date(dm_2m_dtd))</expression>
+       <name>max calced</name>
+     </statistic>
+   </analyticsRequest>
+   
+   <analyticsRequest>
+     <name>Constant Date Request</name>
+     
+     <statistic>
+       <expression>median(const_date(1800-06-30T23:59:59Z))</expression>
+       <name>median</name>
+     </statistic>
+     <statistic>
+       <expression>median(date(const_00_dtd))</expression>
+       <name>median calced</name>
+     </statistic>
+     
+     <statistic>
+       <expression>max(const_date(1804-06-30T23:59:59Z))</expression>
+       <name>max</name>
+     </statistic>
+     <statistic>
+       <expression>max(date(const_04_dtd))</expression>
+       <name>max calced</name>
+     </statistic>
+   </analyticsRequest>
+   
+   <analyticsRequest>
+     <name>Constant String Request</name>
+     
+     <statistic>
+       <expression>min(const_str(this is the first))</expression>
+       <name>min</name>
+     </statistic>
+     <statistic>
+       <expression>min(str(const_first_sd))</expression>
+       <name>min calced</name>
+     </statistic>
+     
+     <statistic>
+       <expression>max(const_str(this is the second))</expression>
+       <name>max</name>
+     </statistic>
+     <statistic>
+       <expression>max(str(const_second_sd))</expression>
+       <name>max calced</name>
+     </statistic>
+   </analyticsRequest>
+   
+   <analyticsRequest>
+     <name>Concatenate Request</name>
+     
+     <statistic>
+       <expression>min(concat(const_str(this is the first),str(string_sd)))</expression>
+       <name>min</name>
+     </statistic>
+     <statistic>
+       <expression>min(str(concat_first_sd))</expression>
+       <name>min calced</name>
+     </statistic>
+     
+     <statistic>
+       <expression>max(concat(const_str(this is the second),str(string_sd)))</expression>
+       <name>max</name>
+     </statistic>
+     <statistic>
+       <expression>max(str(concat_second_sd))</expression>
+       <name>max calced</name>
+     </statistic>
+   </analyticsRequest>
+   
+   <analyticsRequest>
+     <name>Reverse Request</name>
+     
+     <statistic>
+       <expression>min(rev(str(string_sd)))</expression>
+       <name>min</name>
+     </statistic>
+     <statistic>
+       <expression>min(str(rev_sd))</expression>
+       <name>min calced</name>
+     </statistic>
+     
+     <statistic>
+       <expression>max(rev(str(string_sd)))</expression>
+       <name>max</name>
+     </statistic>
+     <statistic>
+       <expression>max(str(rev_sd))</expression>
+       <name>max calced</name>
+     </statistic>
+   </analyticsRequest>
 </analyticsRequestEnvelope> 
diff --git a/solr/contrib/analytics/src/test-files/analytics/requestXMLFiles/noFacets.xml b/solr/contrib/analytics/src/test-files/analytics/requestXMLFiles/noFacets.xml
index ce00d38..2813d18 100644
--- a/solr/contrib/analytics/src/test-files/analytics/requestXMLFiles/noFacets.xml
+++ b/solr/contrib/analytics/src/test-files/analytics/requestXMLFiles/noFacets.xml
@@ -1,310 +1,310 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <analyticsRequestEnvelope stats="true" olap="true">
- 	<analyticsRequest>
- 		<name>Sum Request</name>
- 		
- 		<statistic>
- 			<expression>sum(int(int_id))</expression>
- 			<name>int_id</name>
- 		</statistic>
- 		<statistic>
- 			<expression>sum(long(long_ld))</expression>
- 			<name>long_ld</name>
- 		</statistic>
- 		<statistic>
- 			<expression>sum(float(float_fd))</expression>
- 			<name>float_fd</name>
- 		</statistic>
- 		<statistic>
- 			<expression>sum(double(double_dd))</expression>
- 			<name>double_dd</name>
- 		</statistic>
- 	</analyticsRequest>
- 	
- 	<analyticsRequest>
- 		<name>SumOfSquares Request</name>
- 		
- 		<statistic>
- 			<expression>sumofsquares(int(int_id))</expression>
- 			<name>int_id</name>
- 		</statistic>
- 		<statistic>
- 			<expression>sumofsquares(long(long_ld))</expression>
- 			<name>long_ld</name>
- 		</statistic>
- 		<statistic>
- 			<expression>sumofsquares(float(float_fd))</expression>
- 			<name>float_fd</name>
- 		</statistic>
- 		<statistic>
- 			<expression>sumofsquares(double(double_dd))</expression>
- 			<name>double_dd</name>
- 		</statistic>
- 	</analyticsRequest>
- 	
- 	<analyticsRequest>
- 		<name>Mean Request</name>
- 		
- 		<statistic>
- 			<expression>mean(int(int_id))</expression>
- 			<name>int_id</name>
- 		</statistic>
- 		<statistic>
- 			<expression>mean(long(long_ld))</expression>
- 			<name>long_ld</name>
- 		</statistic>
- 		<statistic>
- 			<expression>mean(float(float_fd))</expression>
- 			<name>float_fd</name>
- 		</statistic>
- 		<statistic>
- 			<expression>mean(double(double_dd))</expression>
- 			<name>double_dd</name>
- 		</statistic>
- 	</analyticsRequest>
- 	
- 	<analyticsRequest>
- 		<name>Stddev Request</name>
- 		
- 		<statistic>
- 			<expression>stddev(int(int_id))</expression>
- 			<name>int_id</name>
- 		</statistic>
- 		<statistic>
- 			<expression>stddev(long(long_ld))</expression>
- 			<name>long_ld</name>
- 		</statistic>
- 		<statistic>
- 			<expression>stddev(float(float_fd))</expression>
- 			<name>float_fd</name>
- 		</statistic>
- 		<statistic>
- 			<expression>stddev(double(double_dd))</expression>
- 			<name>double_dd</name>
- 		</statistic>
- 	</analyticsRequest>
- 	
- 	<analyticsRequest>
- 		<name>Median Request</name>
- 		
- 		<statistic>
- 			<expression>median(int(int_id))</expression>
- 			<name>int_id</name>
- 		</statistic>
- 		<statistic>
- 			<expression>median(long(long_ld))</expression>
- 			<name>long_ld</name>
- 		</statistic>
- 		<statistic>
- 			<expression>median(float(float_fd))</expression>
- 			<name>float_fd</name>
- 		</statistic>
- 		<statistic>
- 			<expression>median(double(double_dd))</expression>
- 			<name>double_dd</name>
- 		</statistic>
- 	</analyticsRequest>
- 	
- 	<analyticsRequest>
- 		<name>Perc 20 Request</name>
- 		
- 		<statistic>
- 			<expression>perc(20,int(int_id))</expression>
- 			<name>int_id</name>
- 		</statistic>
- 		<statistic>
- 			<expression>perc(20,long(long_ld))</expression>
- 			<name>long_ld</name>
- 		</statistic>
- 		<statistic>
- 			<expression>perc(20,float(float_fd))</expression>
- 			<name>float_fd</name>
- 		</statistic>
- 		<statistic>
- 			<expression>perc(20,double(double_dd))</expression>
- 			<name>double_dd</name>
- 		</statistic>
- 		<statistic>
- 			<expression>perc(20,date(date_dtd))</expression>
- 			<name>date_dtd</name>
- 		</statistic>
- 		<statistic>
- 			<expression>perc(20,str(string_sd))</expression>
- 			<name>string_sd</name>
- 		</statistic>
- 	</analyticsRequest>
- 	
- 	<analyticsRequest>
- 		<name>Perc 60 Request</name>
- 		
- 		<statistic>
- 			<expression>perc(60,int(int_id))</expression>
- 			<name>int_id</name>
- 		</statistic>
- 		<statistic>
- 			<expression>perc(60,long(long_ld))</expression>
- 			<name>long_ld</name>
- 		</statistic>
- 		<statistic>
- 			<expression>perc(60,float(float_fd))</expression>
- 			<name>float_fd</name>
- 		</statistic>
- 		<statistic>
- 			<expression>perc(60,double(double_dd))</expression>
- 			<name>double_dd</name>
- 		</statistic>
- 		<statistic>
- 			<expression>perc(60,date(date_dtd))</expression>
- 			<name>date_dtd</name>
- 		</statistic>
- 		<statistic>
- 			<expression>perc(60,str(string_sd))</expression>
- 			<name>string_sd</name>
- 		</statistic>
- 	</analyticsRequest>
- 	
- 	<analyticsRequest>
- 		<name>Min Request</name>
- 		
- 		<statistic>
- 			<expression>min(int(int_id))</expression>
- 			<name>int_id</name>
- 		</statistic>
- 		<statistic>
- 			<expression>min(long(long_ld))</expression>
- 			<name>long_ld</name>
- 		</statistic>
- 		<statistic>
- 			<expression>min(float(float_fd))</expression>
- 			<name>float_fd</name>
- 		</statistic>
- 		<statistic>
- 			<expression>min(double(double_dd))</expression>
- 			<name>double_dd</name>
- 		</statistic>
- 		<statistic>
- 			<expression>min(date(date_dtd))</expression>
- 			<name>date_dtd</name>
- 		</statistic>
- 		<statistic>
- 			<expression>min(str(string_sd))</expression>
- 			<name>string_sd</name>
- 		</statistic>
- 	</analyticsRequest>
- 	
- 	<analyticsRequest>
- 		<name>Max Request</name>
- 		
- 		<statistic>
- 			<expression>max(int(int_id))</expression>
- 			<name>int_id</name>
- 		</statistic>
- 		<statistic>
- 			<expression>max(long(long_ld))</expression>
- 			<name>long_ld</name>
- 		</statistic>
- 		<statistic>
- 			<expression>max(float(float_fd))</expression>
- 			<name>float_fd</name>
- 		</statistic>
- 		<statistic>
- 			<expression>max(double(double_dd))</expression>
- 			<name>double_dd</name>
- 		</statistic>
- 		<statistic>
- 			<expression>max(date(date_dtd))</expression>
- 			<name>date_dtd</name>
- 		</statistic>
- 		<statistic>
- 			<expression>max(str(string_sd))</expression>
- 			<name>string_sd</name>
- 		</statistic>
- 	</analyticsRequest>
- 	
- 	<analyticsRequest>
- 		<name>Unique Request</name>
- 		
- 		<statistic>
- 			<expression>unique(int(int_id))</expression>
- 			<name>int_id</name>
- 		</statistic>
- 		<statistic>
- 			<expression>unique(long(long_ld))</expression>
- 			<name>long_ld</name>
- 		</statistic>
- 		<statistic>
- 			<expression>unique(float(float_fd))</expression>
- 			<name>float_fd</name>
- 		</statistic>
- 		<statistic>
- 			<expression>unique(double(double_dd))</expression>
- 			<name>double_dd</name>
- 		</statistic>
- 		<statistic>
- 			<expression>unique(date(date_dtd))</expression>
- 			<name>date_dtd</name>
- 		</statistic>
- 		<statistic>
- 			<expression>unique(str(string_sd))</expression>
- 			<name>string_sd</name>
- 		</statistic>
- 	</analyticsRequest>
- 	
- 	<analyticsRequest>
- 		<name>Count Request</name>
- 		
- 		<statistic>
- 			<expression>count(int(int_id))</expression>
- 			<name>int_id</name>
- 		</statistic>
- 		<statistic>
- 			<expression>count(long(long_ld))</expression>
- 			<name>long_ld</name>
- 		</statistic>
- 		<statistic>
- 			<expression>count(float(float_fd))</expression>
- 			<name>float_fd</name>
- 		</statistic>
- 		<statistic>
- 			<expression>count(double(double_dd))</expression>
- 			<name>double_dd</name>
- 		</statistic>
- 		<statistic>
- 			<expression>count(date(date_dtd))</expression>
- 			<name>date_dtd</name>
- 		</statistic>
- 		<statistic>
- 			<expression>count(str(string_sd))</expression>
- 			<name>string_sd</name>
- 		</statistic>
- 	</analyticsRequest>
- 	
- 	<analyticsRequest>
- 		<name>Missing Request</name>
- 		 		
- 		<statistic>
- 			<expression>missing(int{int_id})</expression>
- 			<name>int_id</name>
- 		</statistic>
- 		<statistic>
- 			<expression>missing(long{long_ld})</expression>
- 			<name>long_ld</name>
- 		</statistic>
- 		<statistic>
- 			<expression>missing(float{float_fd})</expression>
- 			<name>float_fd</name>
- 		</statistic>
- 		<statistic>
- 			<expression>missing(double{double_dd})</expression>
- 			<name>double_dd</name>
- 		</statistic>
- 		<statistic>
- 			<expression>missing(date{date_dtd})</expression>
- 			<name>date_dtd</name>
- 		</statistic>
- 		<statistic>
- 			<expression>missing(str{string_sd})</expression>
- 			<name>string_sd</name>
- 		</statistic>
- 	</analyticsRequest>
+   <analyticsRequest>
+     <name>Sum Request</name>
+     
+     <statistic>
+       <expression>sum(int(int_id))</expression>
+       <name>int_id</name>
+     </statistic>
+     <statistic>
+       <expression>sum(long(long_ld))</expression>
+       <name>long_ld</name>
+     </statistic>
+     <statistic>
+       <expression>sum(float(float_fd))</expression>
+       <name>float_fd</name>
+     </statistic>
+     <statistic>
+       <expression>sum(double(double_dd))</expression>
+       <name>double_dd</name>
+     </statistic>
+   </analyticsRequest>
+   
+   <analyticsRequest>
+     <name>SumOfSquares Request</name>
+     
+     <statistic>
+       <expression>sumofsquares(int(int_id))</expression>
+       <name>int_id</name>
+     </statistic>
+     <statistic>
+       <expression>sumofsquares(long(long_ld))</expression>
+       <name>long_ld</name>
+     </statistic>
+     <statistic>
+       <expression>sumofsquares(float(float_fd))</expression>
+       <name>float_fd</name>
+     </statistic>
+     <statistic>
+       <expression>sumofsquares(double(double_dd))</expression>
+       <name>double_dd</name>
+     </statistic>
+   </analyticsRequest>
+   
+   <analyticsRequest>
+     <name>Mean Request</name>
+     
+     <statistic>
+       <expression>mean(int(int_id))</expression>
+       <name>int_id</name>
+     </statistic>
+     <statistic>
+       <expression>mean(long(long_ld))</expression>
+       <name>long_ld</name>
+     </statistic>
+     <statistic>
+       <expression>mean(float(float_fd))</expression>
+       <name>float_fd</name>
+     </statistic>
+     <statistic>
+       <expression>mean(double(double_dd))</expression>
+       <name>double_dd</name>
+     </statistic>
+   </analyticsRequest>
+   
+   <analyticsRequest>
+     <name>Stddev Request</name>
+     
+     <statistic>
+       <expression>stddev(int(int_id))</expression>
+       <name>int_id</name>
+     </statistic>
+     <statistic>
+       <expression>stddev(long(long_ld))</expression>
+       <name>long_ld</name>
+     </statistic>
+     <statistic>
+       <expression>stddev(float(float_fd))</expression>
+       <name>float_fd</name>
+     </statistic>
+     <statistic>
+       <expression>stddev(double(double_dd))</expression>
+       <name>double_dd</name>
+     </statistic>
+   </analyticsRequest>
+   
+   <analyticsRequest>
+     <name>Median Request</name>
+     
+     <statistic>
+       <expression>median(int(int_id))</expression>
+       <name>int_id</name>
+     </statistic>
+     <statistic>
+       <expression>median(long(long_ld))</expression>
+       <name>long_ld</name>
+     </statistic>
+     <statistic>
+       <expression>median(float(float_fd))</expression>
+       <name>float_fd</name>
+     </statistic>
+     <statistic>
+       <expression>median(double(double_dd))</expression>
+       <name>double_dd</name>
+     </statistic>
+   </analyticsRequest>
+   
+   <analyticsRequest>
+     <name>Perc 20 Request</name>
+     
+     <statistic>
+       <expression>perc(20,int(int_id))</expression>
+       <name>int_id</name>
+     </statistic>
+     <statistic>
+       <expression>perc(20,long(long_ld))</expression>
+       <name>long_ld</name>
+     </statistic>
+     <statistic>
+       <expression>perc(20,float(float_fd))</expression>
+       <name>float_fd</name>
+     </statistic>
+     <statistic>
+       <expression>perc(20,double(double_dd))</expression>
+       <name>double_dd</name>
+     </statistic>
+     <statistic>
+       <expression>perc(20,date(date_dtd))</expression>
+       <name>date_dtd</name>
+     </statistic>
+     <statistic>
+       <expression>perc(20,str(string_sd))</expression>
+       <name>string_sd</name>
+     </statistic>
+   </analyticsRequest>
+   
+   <analyticsRequest>
+     <name>Perc 60 Request</name>
+     
+     <statistic>
+       <expression>perc(60,int(int_id))</expression>
+       <name>int_id</name>
+     </statistic>
+     <statistic>
+       <expression>perc(60,long(long_ld))</expression>
+       <name>long_ld</name>
+     </statistic>
+     <statistic>
+       <expression>perc(60,float(float_fd))</expression>
+       <name>float_fd</name>
+     </statistic>
+     <statistic>
+       <expression>perc(60,double(double_dd))</expression>
+       <name>double_dd</name>
+     </statistic>
+     <statistic>
+       <expression>perc(60,date(date_dtd))</expression>
+       <name>date_dtd</name>
+     </statistic>
+     <statistic>
+       <expression>perc(60,str(string_sd))</expression>
+       <name>string_sd</name>
+     </statistic>
+   </analyticsRequest>
+   
+   <analyticsRequest>
+     <name>Min Request</name>
+     
+     <statistic>
+       <expression>min(int(int_id))</expression>
+       <name>int_id</name>
+     </statistic>
+     <statistic>
+       <expression>min(long(long_ld))</expression>
+       <name>long_ld</name>
+     </statistic>
+     <statistic>
+       <expression>min(float(float_fd))</expression>
+       <name>float_fd</name>
+     </statistic>
+     <statistic>
+       <expression>min(double(double_dd))</expression>
+       <name>double_dd</name>
+     </statistic>
+     <statistic>
+       <expression>min(date(date_dtd))</expression>
+       <name>date_dtd</name>
+     </statistic>
+     <statistic>
+       <expression>min(str(string_sd))</expression>
+       <name>string_sd</name>
+     </statistic>
+   </analyticsRequest>
+   
+   <analyticsRequest>
+     <name>Max Request</name>
+     
+     <statistic>
+       <expression>max(int(int_id))</expression>
+       <name>int_id</name>
+     </statistic>
+     <statistic>
+       <expression>max(long(long_ld))</expression>
+       <name>long_ld</name>
+     </statistic>
+     <statistic>
+       <expression>max(float(float_fd))</expression>
+       <name>float_fd</name>
+     </statistic>
+     <statistic>
+       <expression>max(double(double_dd))</expression>
+       <name>double_dd</name>
+     </statistic>
+     <statistic>
+       <expression>max(date(date_dtd))</expression>
+       <name>date_dtd</name>
+     </statistic>
+     <statistic>
+       <expression>max(str(string_sd))</expression>
+       <name>string_sd</name>
+     </statistic>
+   </analyticsRequest>
+   
+   <analyticsRequest>
+     <name>Unique Request</name>
+     
+     <statistic>
+       <expression>unique(int(int_id))</expression>
+       <name>int_id</name>
+     </statistic>
+     <statistic>
+       <expression>unique(long(long_ld))</expression>
+       <name>long_ld</name>
+     </statistic>
+     <statistic>
+       <expression>unique(float(float_fd))</expression>
+       <name>float_fd</name>
+     </statistic>
+     <statistic>
+       <expression>unique(double(double_dd))</expression>
+       <name>double_dd</name>
+     </statistic>
+     <statistic>
+       <expression>unique(date(date_dtd))</expression>
+       <name>date_dtd</name>
+     </statistic>
+     <statistic>
+       <expression>unique(str(string_sd))</expression>
+       <name>string_sd</name>
+     </statistic>
+   </analyticsRequest>
+   
+   <analyticsRequest>
+     <name>Count Request</name>
+     
+     <statistic>
+       <expression>count(int(int_id))</expression>
+       <name>int_id</name>
+     </statistic>
+     <statistic>
+       <expression>count(long(long_ld))</expression>
+       <name>long_ld</name>
+     </statistic>
+     <statistic>
+       <expression>count(float(float_fd))</expression>
+       <name>float_fd</name>
+     </statistic>
+     <statistic>
+       <expression>count(double(double_dd))</expression>
+       <name>double_dd</name>
+     </statistic>
+     <statistic>
+       <expression>count(date(date_dtd))</expression>
+       <name>date_dtd</name>
+     </statistic>
+     <statistic>
+       <expression>count(str(string_sd))</expression>
+       <name>string_sd</name>
+     </statistic>
+   </analyticsRequest>
+   
+   <analyticsRequest>
+     <name>Missing Request</name>
+          
+     <statistic>
+       <expression>missing(int{int_id})</expression>
+       <name>int_id</name>
+     </statistic>
+     <statistic>
+       <expression>missing(long{long_ld})</expression>
+       <name>long_ld</name>
+     </statistic>
+     <statistic>
+       <expression>missing(float{float_fd})</expression>
+       <name>float_fd</name>
+     </statistic>
+     <statistic>
+       <expression>missing(double{double_dd})</expression>
+       <name>double_dd</name>
+     </statistic>
+     <statistic>
+       <expression>missing(date{date_dtd})</expression>
+       <name>date_dtd</name>
+     </statistic>
+     <statistic>
+       <expression>missing(str{string_sd})</expression>
+       <name>string_sd</name>
+     </statistic>
+   </analyticsRequest>
 </analyticsRequestEnvelope> 
diff --git a/solr/contrib/analytics/src/test-files/analytics/requestXMLFiles/queryFacets.xml b/solr/contrib/analytics/src/test-files/analytics/requestXMLFiles/queryFacets.xml
index 73f615b..f5c7191 100644
--- a/solr/contrib/analytics/src/test-files/analytics/requestXMLFiles/queryFacets.xml
+++ b/solr/contrib/analytics/src/test-files/analytics/requestXMLFiles/queryFacets.xml
@@ -1,94 +1,94 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <analyticsRequestEnvelope stats="true" olap="true">
- 	<analyticsRequest>
- 		<name>int request</name>
- 		
- 		<statistic>
- 			<expression>sum(int(int_id))</expression>
- 			<name>sum</name>
- 		</statistic>
- 		
- 		<statistic>
- 			<expression>mean(int(int_id))</expression>
- 			<name>mean</name>
- 		</statistic>
- 		
- 		<statistic>
- 			<expression>median(int(int_id))</expression>
- 			<name>median</name>
- 		</statistic>
- 		
- 		<statistic>
- 			<expression>perc(8,int(int_id))</expression>
- 			<name>perc_8</name>
- 		</statistic>
- 		
- 		<queryFacet>
- 			<name>float1</name>
- 			<query>float_fd:[* TO 50]</query>
- 		</queryFacet>
- 		<queryFacet>
- 			<name>float2</name>
- 			<query>float_fd:[* TO 30]</query>
- 		</queryFacet>
- 	</analyticsRequest>
- 	<analyticsRequest>
- 		<name>long request</name>
- 		
- 		<statistic>
- 			<expression>sum(long(long_ld))</expression>
- 			<name>sum</name>
- 		</statistic>
- 		
- 		<statistic>
- 			<expression>mean(long(long_ld))</expression>
- 			<name>mean</name>
- 		</statistic>
- 		
- 		<statistic>
- 			<expression>median(long(long_ld))</expression>
- 			<name>median</name>
- 		</statistic>
- 		
- 		<statistic>
- 			<expression>perc(8,long(long_ld))</expression>
- 			<name>perc_8</name>
- 		</statistic>
- 		
- 		<queryFacet>
- 			<name>string</name>
- 			<query>string_sd:abc1</query>
- 			<query>string_sd:abc2</query>
- 		</queryFacet>
- 	</analyticsRequest>
- 	<analyticsRequest>
- 		<name>float request</name>
- 		
- 		<statistic>
- 			<expression>sum(float(float_fd))</expression>
- 			<name>sum</name>
- 		</statistic>
- 		
- 		<statistic>
- 			<expression>mean(float(float_fd))</expression>
- 			<name>mean</name>
- 		</statistic>
- 		
- 		<statistic>
- 			<expression>median(float(float_fd))</expression>
- 			<name>median</name>
- 		</statistic>
- 		
- 		<statistic>
- 			<expression>perc(8,float(float_fd))</expression>
- 			<name>perc_8</name>
- 		</statistic>
- 		
- 		<queryFacet>
- 			<name>long and double</name>
- 			<query>long_ld:[20 TO *]</query>
- 			<query>long_ld:[30 TO *]</query>
- 			<query>double_dd:[* TO 50]</query>
- 		</queryFacet>
- 	</analyticsRequest>
+   <analyticsRequest>
+     <name>int request</name>
+     
+     <statistic>
+       <expression>sum(int(int_id))</expression>
+       <name>sum</name>
+     </statistic>
+     
+     <statistic>
+       <expression>mean(int(int_id))</expression>
+       <name>mean</name>
+     </statistic>
+     
+     <statistic>
+       <expression>median(int(int_id))</expression>
+       <name>median</name>
+     </statistic>
+     
+     <statistic>
+       <expression>perc(8,int(int_id))</expression>
+       <name>perc_8</name>
+     </statistic>
+     
+     <queryFacet>
+       <name>float1</name>
+       <query>float_fd:[* TO 50]</query>
+     </queryFacet>
+     <queryFacet>
+       <name>float2</name>
+       <query>float_fd:[* TO 30]</query>
+     </queryFacet>
+   </analyticsRequest>
+   <analyticsRequest>
+     <name>long request</name>
+     
+     <statistic>
+       <expression>sum(long(long_ld))</expression>
+       <name>sum</name>
+     </statistic>
+     
+     <statistic>
+       <expression>mean(long(long_ld))</expression>
+       <name>mean</name>
+     </statistic>
+     
+     <statistic>
+       <expression>median(long(long_ld))</expression>
+       <name>median</name>
+     </statistic>
+     
+     <statistic>
+       <expression>perc(8,long(long_ld))</expression>
+       <name>perc_8</name>
+     </statistic>
+     
+     <queryFacet>
+       <name>string</name>
+       <query>string_sd:abc1</query>
+       <query>string_sd:abc2</query>
+     </queryFacet>
+   </analyticsRequest>
+   <analyticsRequest>
+     <name>float request</name>
+     
+     <statistic>
+       <expression>sum(float(float_fd))</expression>
+       <name>sum</name>
+     </statistic>
+     
+     <statistic>
+       <expression>mean(float(float_fd))</expression>
+       <name>mean</name>
+     </statistic>
+     
+     <statistic>
+       <expression>median(float(float_fd))</expression>
+       <name>median</name>
+     </statistic>
+     
+     <statistic>
+       <expression>perc(8,float(float_fd))</expression>
+       <name>perc_8</name>
+     </statistic>
+     
+     <queryFacet>
+       <name>long and double</name>
+       <query>long_ld:[20 TO *]</query>
+       <query>long_ld:[30 TO *]</query>
+       <query>double_dd:[* TO 50]</query>
+     </queryFacet>
+   </analyticsRequest>
 </analyticsRequestEnvelope>
diff --git a/solr/contrib/analytics/src/test-files/analytics/requestXMLFiles/rangeFacets.xml b/solr/contrib/analytics/src/test-files/analytics/requestXMLFiles/rangeFacets.xml
index 3434d2e..4a596f7 100644
--- a/solr/contrib/analytics/src/test-files/analytics/requestXMLFiles/rangeFacets.xml
+++ b/solr/contrib/analytics/src/test-files/analytics/requestXMLFiles/rangeFacets.xml
@@ -1,319 +1,319 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <analyticsRequestEnvelope stats="true" olap="true">
- 	<analyticsRequest>
- 		<name>regular int</name>
- 		
- 		<statistic>
- 			<expression>mean(int(int_id))</expression>
- 			<name>mean</name>
- 		</statistic>
- 		<statistic>
- 			<expression>sum(int(int_id))</expression>
- 			<name>sum</name>
- 		</statistic>
- 		<statistic>
- 			<expression>median(int(int_id))</expression>
- 			<name>median</name>
- 		</statistic>
- 		<statistic>
- 			<expression>count(int(int_id))</expression>
- 			<name>count</name>
- 		</statistic>
- 		<statistic>
- 			<expression>sumofsquares(int(int_id))</expression>
- 			<name>sumOfSquares</name>
- 		</statistic>
- 		
- 		<rangeFacet hardend="false">
- 			<field>long_ld</field>
- 			<start>5</start>
- 			<end>30</end>
- 			<gap>5</gap>
- 			<includeBoundary>lower</includeBoundary>
- 			<otherRange>all</otherRange>
- 		</rangeFacet>
- 		<rangeFacet hardend="false">
- 			<field>double_dd</field>
- 			<start>3</start>
- 			<end>39</end>
- 			<gap>7</gap>
- 			<includeBoundary>upper</includeBoundary>
- 			<includeBoundary>outer</includeBoundary>
- 			<otherRange>all</otherRange>
- 		</rangeFacet>
- 		<rangeFacet hardend="false">
- 			<field>date_dtd</field>
- 			<start>1007-01-01T23:59:59Z</start>
- 			<end>1044-01-01T23:59:59Z</end>
- 			<gap>+7YEARS</gap>
- 			<includeBoundary>lower</includeBoundary>
- 			<includeBoundary>edge</includeBoundary>
- 			<includeBoundary>outer</includeBoundary>
- 			<otherRange>all</otherRange>
- 		</rangeFacet>
- 	</analyticsRequest>
- 	<analyticsRequest>
- 		<name>regular float</name>
- 		
- 		<statistic>
- 			<expression>mean(float(float_fd))</expression>
- 			<name>mean</name>
- 		</statistic>
- 		<statistic>
- 			<expression>sum(float(float_fd))</expression>
- 			<name>sum</name>
- 		</statistic>
- 		<statistic>
- 			<expression>median(float(float_fd))</expression>
- 			<name>median</name>
- 		</statistic>
- 		<statistic>
- 			<expression>count(float(float_fd))</expression>
- 			<name>count</name>
- 		</statistic>
- 		<statistic>
- 			<expression>sumofsquares(float(float_fd))</expression>
- 			<name>sumOfSquares</name>
- 		</statistic>
- 		
- 		<rangeFacet hardend="false">
- 			<field>long_ld</field>
- 			<start>0</start>
- 			<end>29</end>
- 			<gap>4</gap>
- 			<includeBoundary>all</includeBoundary>
- 			<otherRange>all</otherRange>
- 		</rangeFacet>
- 		<rangeFacet hardend="false">
- 			<field>double_dd</field>
- 			<start>4</start>
- 			<end>47</end>
- 			<gap>11</gap>
- 			<includeBoundary>edge</includeBoundary>
- 			<otherRange>all</otherRange>
- 		</rangeFacet>
- 		<rangeFacet hardend="false">
- 			<field>date_dtd</field>
- 			<start>1004-01-01T23:59:59Z</start>
- 			<end>1046-01-01T23:59:59Z</end>
- 			<gap>+5YEARS</gap>
- 			<includeBoundary>upper</includeBoundary>
- 			<includeBoundary>edge</includeBoundary>
- 			<otherRange>all</otherRange>
- 		</rangeFacet>
- 	</analyticsRequest>
- 	<analyticsRequest>
- 		<name>hardend int</name>
- 		
- 		<statistic>
- 			<expression>mean(int(int_id))</expression>
- 			<name>mean</name>
- 		</statistic>
- 		<statistic>
- 			<expression>sum(int(int_id))</expression>
- 			<name>sum</name>
- 		</statistic>
- 		<statistic>
- 			<expression>median(int(int_id))</expression>
- 			<name>median</name>
- 		</statistic>
- 		<statistic>
- 			<expression>count(int(int_id))</expression>
- 			<name>count</name>
- 		</statistic>
- 		<statistic>
- 			<expression>sumofsquares(int(int_id))</expression>
- 			<name>sumOfSquares</name>
- 		</statistic>
- 		
- 		<rangeFacet hardend="true">
- 			<field>long_ld</field>
- 			<start>5</start>
- 			<end>30</end>
- 			<gap>5</gap>
- 			<includeBoundary>lower</includeBoundary>
- 			<otherRange>all</otherRange>
- 		</rangeFacet>
- 		<rangeFacet hardend="true">
- 			<field>double_dd</field>
- 			<start>3</start>
- 			<end>39</end>
- 			<gap>7</gap>
- 			<includeBoundary>upper</includeBoundary>
- 			<includeBoundary>outer</includeBoundary>
- 			<otherRange>all</otherRange>
- 		</rangeFacet>
- 		<rangeFacet hardend="true">
- 			<field>date_dtd</field>
- 			<start>1007-01-01T23:59:59Z</start>
- 			<end>1044-01-01T23:59:59Z</end>
- 			<gap>+7YEARS</gap>
- 			<includeBoundary>lower</includeBoundary>
- 			<includeBoundary>edge</includeBoundary>
- 			<includeBoundary>outer</includeBoundary>
- 			<otherRange>all</otherRange>
- 		</rangeFacet>
- 	</analyticsRequest>
- 	<analyticsRequest>
- 		<name>hardend float</name>
- 		
- 		<statistic>
- 			<expression>mean(float(float_fd))</expression>
- 			<name>mean</name>
- 		</statistic>
- 		<statistic>
- 			<expression>sum(float(float_fd))</expression>
- 			<name>sum</name>
- 		</statistic>
- 		<statistic>
- 			<expression>median(float(float_fd))</expression>
- 			<name>median</name>
- 		</statistic>
- 		<statistic>
- 			<expression>count(float(float_fd))</expression>
- 			<name>count</name>
- 		</statistic>
- 		<statistic>
- 			<expression>sumofsquares(float(float_fd))</expression>
- 			<name>sumOfSquares</name>
- 		</statistic>
- 		
- 		<rangeFacet hardend="true">
- 			<field>long_ld</field>
- 			<start>0</start>
- 			<end>29</end>
- 			<gap>4</gap>
- 			<includeBoundary>all</includeBoundary>
- 			<otherRange>all</otherRange>
- 		</rangeFacet>
- 		<rangeFacet hardend="true">
- 			<field>double_dd</field>
- 			<start>4</start>
- 			<end>47</end>
- 			<gap>11</gap>
- 			<includeBoundary>edge</includeBoundary>
- 			<otherRange>all</otherRange>
- 		</rangeFacet>
- 		<rangeFacet hardend="true">
- 			<field>date_dtd</field>
- 			<start>1004-01-01T23:59:59Z</start>
- 			<end>1046-01-01T23:59:59Z</end>
- 			<gap>+5YEARS</gap>
- 			<includeBoundary>upper</includeBoundary>
- 			<includeBoundary>edge</includeBoundary>
- 			<otherRange>all</otherRange>
- 		</rangeFacet>
- 	</analyticsRequest>
- 	<analyticsRequest>
- 		<name>multigap int</name>
- 		
- 		<statistic>
- 			<expression>mean(int(int_id))</expression>
- 			<name>mean</name>
- 		</statistic>
- 		<statistic>
- 			<expression>sum(int(int_id))</expression>
- 			<name>sum</name>
- 		</statistic>
- 		<statistic>
- 			<expression>median(int(int_id))</expression>
- 			<name>median</name>
- 		</statistic>
- 		<statistic>
- 			<expression>count(int(int_id))</expression>
- 			<name>count</name>
- 		</statistic>
- 		<statistic>
- 			<expression>sumofsquares(int(int_id))</expression>
- 			<name>sumOfSquares</name>
- 		</statistic>
- 		
- 		<rangeFacet hardend="false">
- 			<field>long_ld</field>
- 			<start>5</start>
- 			<end>30</end>
- 			<gap>4</gap>
- 			<gap>2</gap>
- 			<gap>6</gap>
- 			<gap>3</gap>
- 			<includeBoundary>lower</includeBoundary>
- 			<otherRange>all</otherRange>
- 		</rangeFacet>
- 		<rangeFacet hardend="false">
- 			<field>double_dd</field>
- 			<start>3</start>
- 			<end>39</end>
- 			<gap>3</gap>
- 			<gap>1</gap>
- 			<gap>7</gap>
- 			<includeBoundary>upper</includeBoundary>
- 			<includeBoundary>outer</includeBoundary>
- 			<otherRange>all</otherRange>
- 		</rangeFacet>
- 		<rangeFacet hardend="false">
- 			<field>date_dtd</field>
- 			<start>1007-01-01T23:59:59Z</start>
- 			<end>1044-01-01T23:59:59Z</end>
- 			<gap>+2YEARS</gap>
- 			<gap>+7YEARS</gap>
- 			<includeBoundary>lower</includeBoundary>
- 			<includeBoundary>edge</includeBoundary>
- 			<includeBoundary>outer</includeBoundary>
- 			<otherRange>all</otherRange>
- 		</rangeFacet>
- 	</analyticsRequest>
- 	<analyticsRequest>
- 		<name>multigap float</name>
- 		
- 		<statistic>
- 			<expression>mean(float(float_fd))</expression>
- 			<name>mean</name>
- 		</statistic>
- 		<statistic>
- 			<expression>sum(float(float_fd))</expression>
- 			<name>sum</name>
- 		</statistic>
- 		<statistic>
- 			<expression>median(float(float_fd))</expression>
- 			<name>median</name>
- 		</statistic>
- 		<statistic>
- 			<expression>count(float(float_fd))</expression>
- 			<name>count</name>
- 		</statistic>
- 		<statistic>
- 			<expression>sumofsquares(float(float_fd))</expression>
- 			<name>sumOfSquares</name>
- 		</statistic>
- 		
- 		<rangeFacet hardend="false">
- 			<field>long_ld</field>
- 			<start>0</start>
- 			<end>29</end>
- 			<gap>1</gap>
- 			<gap>4</gap>
- 			<includeBoundary>all</includeBoundary>
- 			<otherRange>all</otherRange>
- 		</rangeFacet>
- 		<rangeFacet hardend="false">
- 			<field>double_dd</field>
- 			<start>4</start>
- 			<end>47</end>
- 			<gap>2</gap>
- 			<gap>3</gap>
- 			<gap>11</gap>
- 			<includeBoundary>edge</includeBoundary>
- 			<otherRange>all</otherRange>
- 		</rangeFacet>
- 		<rangeFacet hardend="false">
- 			<field>date_dtd</field>
- 			<start>1004-01-01T23:59:59Z</start>
- 			<end>1046-01-01T23:59:59Z</end>
- 			<gap>+4YEARS</gap>
- 			<gap>+5YEARS</gap>
- 			<includeBoundary>upper</includeBoundary>
- 			<includeBoundary>edge</includeBoundary>
- 			<otherRange>all</otherRange>
- 		</rangeFacet>
- 	</analyticsRequest>
+   <analyticsRequest>
+     <name>regular int</name>
+     
+     <statistic>
+       <expression>mean(int(int_id))</expression>
+       <name>mean</name>
+     </statistic>
+     <statistic>
+       <expression>sum(int(int_id))</expression>
+       <name>sum</name>
+     </statistic>
+     <statistic>
+       <expression>median(int(int_id))</expression>
+       <name>median</name>
+     </statistic>
+     <statistic>
+       <expression>count(int(int_id))</expression>
+       <name>count</name>
+     </statistic>
+     <statistic>
+       <expression>sumofsquares(int(int_id))</expression>
+       <name>sumOfSquares</name>
+     </statistic>
+     
+     <rangeFacet hardend="false">
+       <field>long_ld</field>
+       <start>5</start>
+       <end>30</end>
+       <gap>5</gap>
+       <includeBoundary>lower</includeBoundary>
+       <otherRange>all</otherRange>
+     </rangeFacet>
+     <rangeFacet hardend="false">
+       <field>double_dd</field>
+       <start>3</start>
+       <end>39</end>
+       <gap>7</gap>
+       <includeBoundary>upper</includeBoundary>
+       <includeBoundary>outer</includeBoundary>
+       <otherRange>all</otherRange>
+     </rangeFacet>
+     <rangeFacet hardend="false">
+       <field>date_dtd</field>
+       <start>1007-01-01T23:59:59Z</start>
+       <end>1044-01-01T23:59:59Z</end>
+       <gap>+7YEARS</gap>
+       <includeBoundary>lower</includeBoundary>
+       <includeBoundary>edge</includeBoundary>
+       <includeBoundary>outer</includeBoundary>
+       <otherRange>all</otherRange>
+     </rangeFacet>
+   </analyticsRequest>
+   <analyticsRequest>
+     <name>regular float</name>
+     
+     <statistic>
+       <expression>mean(float(float_fd))</expression>
+       <name>mean</name>
+     </statistic>
+     <statistic>
+       <expression>sum(float(float_fd))</expression>
+       <name>sum</name>
+     </statistic>
+     <statistic>
+       <expression>median(float(float_fd))</expression>
+       <name>median</name>
+     </statistic>
+     <statistic>
+       <expression>count(float(float_fd))</expression>
+       <name>count</name>
+     </statistic>
+     <statistic>
+       <expression>sumofsquares(float(float_fd))</expression>
+       <name>sumOfSquares</name>
+     </statistic>
+     
+     <rangeFacet hardend="false">
+       <field>long_ld</field>
+       <start>0</start>
+       <end>29</end>
+       <gap>4</gap>
+       <includeBoundary>all</includeBoundary>
+       <otherRange>all</otherRange>
+     </rangeFacet>
+     <rangeFacet hardend="false">
+       <field>double_dd</field>
+       <start>4</start>
+       <end>47</end>
+       <gap>11</gap>
+       <includeBoundary>edge</includeBoundary>
+       <otherRange>all</otherRange>
+     </rangeFacet>
+     <rangeFacet hardend="false">
+       <field>date_dtd</field>
+       <start>1004-01-01T23:59:59Z</start>
+       <end>1046-01-01T23:59:59Z</end>
+       <gap>+5YEARS</gap>
+       <includeBoundary>upper</includeBoundary>
+       <includeBoundary>edge</includeBoundary>
+       <otherRange>all</otherRange>
+     </rangeFacet>
+   </analyticsRequest>
+   <analyticsRequest>
+     <name>hardend int</name>
+     
+     <statistic>
+       <expression>mean(int(int_id))</expression>
+       <name>mean</name>
+     </statistic>
+     <statistic>
+       <expression>sum(int(int_id))</expression>
+       <name>sum</name>
+     </statistic>
+     <statistic>
+       <expression>median(int(int_id))</expression>
+       <name>median</name>
+     </statistic>
+     <statistic>
+       <expression>count(int(int_id))</expression>
+       <name>count</name>
+     </statistic>
+     <statistic>
+       <expression>sumofsquares(int(int_id))</expression>
+       <name>sumOfSquares</name>
+     </statistic>
+     
+     <rangeFacet hardend="true">
+       <field>long_ld</field>
+       <start>5</start>
+       <end>30</end>
+       <gap>5</gap>
+       <includeBoundary>lower</includeBoundary>
+       <otherRange>all</otherRange>
+     </rangeFacet>
+     <rangeFacet hardend="true">
+       <field>double_dd</field>
+       <start>3</start>
+       <end>39</end>
+       <gap>7</gap>
+       <includeBoundary>upper</includeBoundary>
+       <includeBoundary>outer</includeBoundary>
+       <otherRange>all</otherRange>
+     </rangeFacet>
+     <rangeFacet hardend="true">
+       <field>date_dtd</field>
+       <start>1007-01-01T23:59:59Z</start>
+       <end>1044-01-01T23:59:59Z</end>
+       <gap>+7YEARS</gap>
+       <includeBoundary>lower</includeBoundary>
+       <includeBoundary>edge</includeBoundary>
+       <includeBoundary>outer</includeBoundary>
+       <otherRange>all</otherRange>
+     </rangeFacet>
+   </analyticsRequest>
+   <analyticsRequest>
+     <name>hardend float</name>
+     
+     <statistic>
+       <expression>mean(float(float_fd))</expression>
+       <name>mean</name>
+     </statistic>
+     <statistic>
+       <expression>sum(float(float_fd))</expression>
+       <name>sum</name>
+     </statistic>
+     <statistic>
+       <expression>median(float(float_fd))</expression>
+       <name>median</name>
+     </statistic>
+     <statistic>
+       <expression>count(float(float_fd))</expression>
+       <name>count</name>
+     </statistic>
+     <statistic>
+       <expression>sumofsquares(float(float_fd))</expression>
+       <name>sumOfSquares</name>
+     </statistic>
+     
+     <rangeFacet hardend="true">
+       <field>long_ld</field>
+       <start>0</start>
+       <end>29</end>
+       <gap>4</gap>
+       <includeBoundary>all</includeBoundary>
+       <otherRange>all</otherRange>
+     </rangeFacet>
+     <rangeFacet hardend="true">
+       <field>double_dd</field>
+       <start>4</start>
+       <end>47</end>
+       <gap>11</gap>
+       <includeBoundary>edge</includeBoundary>
+       <otherRange>all</otherRange>
+     </rangeFacet>
+     <rangeFacet hardend="true">
+       <field>date_dtd</field>
+       <start>1004-01-01T23:59:59Z</start>
+       <end>1046-01-01T23:59:59Z</end>
+       <gap>+5YEARS</gap>
+       <includeBoundary>upper</includeBoundary>
+       <includeBoundary>edge</includeBoundary>
+       <otherRange>all</otherRange>
+     </rangeFacet>
+   </analyticsRequest>
+   <analyticsRequest>
+     <name>multigap int</name>
+     
+     <statistic>
+       <expression>mean(int(int_id))</expression>
+       <name>mean</name>
+     </statistic>
+     <statistic>
+       <expression>sum(int(int_id))</expression>
+       <name>sum</name>
+     </statistic>
+     <statistic>
+       <expression>median(int(int_id))</expression>
+       <name>median</name>
+     </statistic>
+     <statistic>
+       <expression>count(int(int_id))</expression>
+       <name>count</name>
+     </statistic>
+     <statistic>
+       <expression>sumofsquares(int(int_id))</expression>
+       <name>sumOfSquares</name>
+     </statistic>
+     
+     <rangeFacet hardend="false">
+       <field>long_ld</field>
+       <start>5</start>
+       <end>30</end>
+       <gap>4</gap>
+       <gap>2</gap>
+       <gap>6</gap>
+       <gap>3</gap>
+       <includeBoundary>lower</includeBoundary>
+       <otherRange>all</otherRange>
+     </rangeFacet>
+     <rangeFacet hardend="false">
+       <field>double_dd</field>
+       <start>3</start>
+       <end>39</end>
+       <gap>3</gap>
+       <gap>1</gap>
+       <gap>7</gap>
+       <includeBoundary>upper</includeBoundary>
+       <includeBoundary>outer</includeBoundary>
+       <otherRange>all</otherRange>
+     </rangeFacet>
+     <rangeFacet hardend="false">
+       <field>date_dtd</field>
+       <start>1007-01-01T23:59:59Z</start>
+       <end>1044-01-01T23:59:59Z</end>
+       <gap>+2YEARS</gap>
+       <gap>+7YEARS</gap>
+       <includeBoundary>lower</includeBoundary>
+       <includeBoundary>edge</includeBoundary>
+       <includeBoundary>outer</includeBoundary>
+       <otherRange>all</otherRange>
+     </rangeFacet>
+   </analyticsRequest>
+   <analyticsRequest>
+     <name>multigap float</name>
+     
+     <statistic>
+       <expression>mean(float(float_fd))</expression>
+       <name>mean</name>
+     </statistic>
+     <statistic>
+       <expression>sum(float(float_fd))</expression>
+       <name>sum</name>
+     </statistic>
+     <statistic>
+       <expression>median(float(float_fd))</expression>
+       <name>median</name>
+     </statistic>
+     <statistic>
+       <expression>count(float(float_fd))</expression>
+       <name>count</name>
+     </statistic>
+     <statistic>
+       <expression>sumofsquares(float(float_fd))</expression>
+       <name>sumOfSquares</name>
+     </statistic>
+     
+     <rangeFacet hardend="false">
+       <field>long_ld</field>
+       <start>0</start>
+       <end>29</end>
+       <gap>1</gap>
+       <gap>4</gap>
+       <includeBoundary>all</includeBoundary>
+       <otherRange>all</otherRange>
+     </rangeFacet>
+     <rangeFacet hardend="false">
+       <field>double_dd</field>
+       <start>4</start>
+       <end>47</end>
+       <gap>2</gap>
+       <gap>3</gap>
+       <gap>11</gap>
+       <includeBoundary>edge</includeBoundary>
+       <otherRange>all</otherRange>
+     </rangeFacet>
+     <rangeFacet hardend="false">
+       <field>date_dtd</field>
+       <start>1004-01-01T23:59:59Z</start>
+       <end>1046-01-01T23:59:59Z</end>
+       <gap>+4YEARS</gap>
+       <gap>+5YEARS</gap>
+       <includeBoundary>upper</includeBoundary>
+       <includeBoundary>edge</includeBoundary>
+       <otherRange>all</otherRange>
+     </rangeFacet>
+   </analyticsRequest>
 </analyticsRequestEnvelope>
diff --git a/solr/contrib/clustering/src/test-files/clustering/solr/collection1/conf/solrconfig.xml b/solr/contrib/clustering/src/test-files/clustering/solr/collection1/conf/solrconfig.xml
index 8e2e365..59f314c 100644
--- a/solr/contrib/clustering/src/test-files/clustering/solr/collection1/conf/solrconfig.xml
+++ b/solr/contrib/clustering/src/test-files/clustering/solr/collection1/conf/solrconfig.xml
@@ -31,17 +31,17 @@
     <useCompoundFile>${useCompoundFile:false}</useCompoundFile>
   </indexConfig>
   
-  <!--	Enables JMX if and only if an existing MBeanServer is found, use 
-  		this if you want to configure JMX through JVM parameters. Remove
-  		this to disable exposing Solr configuration and statistics to JMX.
-  		
-		If you want to connect to a particular server, specify the agentId
-		e.g. <jmx agentId="myAgent" />
-		
-		If you want to start a new MBeanServer, specify the serviceUrl
-		e.g <jmx serviceurl="service:jmx:rmi:///jndi/rmi://localhost:9999/solr" />
-		
-		For more details see http://wiki.apache.org/solr/SolrJmx
+  <!--  Enables JMX if and only if an existing MBeanServer is found, use 
+      this if you want to configure JMX through JVM parameters. Remove
+      this to disable exposing Solr configuration and statistics to JMX.
+      
+    If you want to connect to a particular server, specify the agentId
+    e.g. <jmx agentId="myAgent" />
+    
+    If you want to start a new MBeanServer, specify the serviceUrl
+    e.g <jmx serviceurl="service:jmx:rmi:///jndi/rmi://localhost:9999/solr" />
+    
+    For more details see http://wiki.apache.org/solr/SolrJmx
   -->
   <jmx />
 
diff --git a/solr/contrib/dataimporthandler-extras/build.xml b/solr/contrib/dataimporthandler-extras/build.xml
index 8d1ab0d..e0fb692 100644
--- a/solr/contrib/dataimporthandler-extras/build.xml
+++ b/solr/contrib/dataimporthandler-extras/build.xml
@@ -30,7 +30,7 @@
                          classpath.property="solr-dataimporthandler.jar"/>
 
   <target name="compile-solr-dataimporthandler" unless="solr-dataimporthandler.uptodate">
-  	<ant dir="${common-solr.dir}/contrib/dataimporthandler" target="compile-core" inheritAll="false">
+    <ant dir="${common-solr.dir}/contrib/dataimporthandler" target="compile-core" inheritAll="false">
       <propertyset refid="uptodate.and.compiled.properties"/>
     </ant>
   </target>
@@ -40,7 +40,7 @@
        we should probably fix this, the same issue exists in modules
    -->
   <target name="compile-solr-dataimporthandler-tests">
-  	<ant dir="${common-solr.dir}/contrib/dataimporthandler" target="compile-test" inheritAll="false">
+    <ant dir="${common-solr.dir}/contrib/dataimporthandler" target="compile-test" inheritAll="false">
       <propertyset refid="uptodate.and.compiled.properties"/>
     </ant>
   </target>
diff --git a/solr/contrib/dataimporthandler/build.xml b/solr/contrib/dataimporthandler/build.xml
index 80bde36..a07e534 100644
--- a/solr/contrib/dataimporthandler/build.xml
+++ b/solr/contrib/dataimporthandler/build.xml
@@ -18,7 +18,7 @@
  -->
 
 <project name="solr-dataimporthandler" default="default">
-	
+  
   <description>
     Data Import Handler
   </description>
diff --git a/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/data-config-end-to-end.xml b/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/data-config-end-to-end.xml
index 2a5b310..a582112 100644
--- a/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/data-config-end-to-end.xml
+++ b/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/data-config-end-to-end.xml
@@ -25,13 +25,13 @@
         
         query="SELECT CODE, COUNTRY_NAME FROM COUNTRIES"
       >
-      	<field column="CODE" name="DO_NOT_INDEX" />
+        <field column="CODE" name="DO_NOT_INDEX" />
       </entity>
          
       <entity 
         name="Sports"
         processor="SqlEntityProcessor"
-        dataSource="hsqldb"             	
+        dataSource="hsqldb"               
         query="SELECT PERSON_ID, SPORT_NAME FROM PEOPLE_SPORTS WHERE PERSON_ID=${People.ID}"
       />
 
diff --git a/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/data-config-with-datasource.xml b/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/data-config-with-datasource.xml
index 9566a54..46a6603 100644
--- a/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/data-config-with-datasource.xml
+++ b/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/data-config-with-datasource.xml
@@ -1,9 +1,9 @@
 <dataConfig>
-	<dataSource type="MockDataSource" />
-	<document>
-		<entity name="x" query="select * from x">
-			<field column="id" />
-			<field column="desc" />
-		</entity>
-	</document>
+  <dataSource type="MockDataSource" />
+  <document>
+    <entity name="x" query="select * from x">
+      <field column="id" />
+      <field column="desc" />
+    </entity>
+  </document>
 </dataConfig>
diff --git a/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/data-config-with-transformer.xml b/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/data-config-with-transformer.xml
index c58b21d..925e6c2 100644
--- a/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/data-config-with-transformer.xml
+++ b/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/data-config-with-transformer.xml
@@ -1,10 +1,10 @@
 <dataConfig>
-	<dataSource  type="MockDataSource" />
-	<dataSource name="mockDs" type="TestDocBuilder2$MockDataSource2" />
-	<document>
-		<entity name="x" query="select * from x" transformer="TestDocBuilder2$MockTransformer">
-			<field column="id" />
-			<field column="desc" />
-		</entity>
-	</document>
+  <dataSource  type="MockDataSource" />
+  <dataSource name="mockDs" type="TestDocBuilder2$MockDataSource2" />
+  <document>
+    <entity name="x" query="select * from x" transformer="TestDocBuilder2$MockTransformer">
+      <field column="id" />
+      <field column="desc" />
+    </entity>
+  </document>
 </dataConfig>
diff --git a/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/dataimport-solrconfig.xml b/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/dataimport-solrconfig.xml
index 5f379d6..d1bf6e4 100644
--- a/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/dataimport-solrconfig.xml
+++ b/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/dataimport-solrconfig.xml
@@ -240,7 +240,7 @@
   </requestHandler>
   
   <requestHandler name="/dataimport" class="org.apache.solr.handler.dataimport.DataImportHandler">
-  	<lst name="defaults">
+    <lst name="defaults">
       <str name="dots.in.hsqldb.driver">org.hsqldb.jdbcDriver</str>
     </lst>
   </requestHandler>
diff --git a/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/single-entity-data-config.xml b/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/single-entity-data-config.xml
index f9d3523..7375a2c 100644
--- a/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/single-entity-data-config.xml
+++ b/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/single-entity-data-config.xml
@@ -1,9 +1,9 @@
 <dataConfig>
   <dataSource type="MockDataSource"/>
-	<document>
-		<entity name="x" query="select * from x">
-			<field column="id" />
-			<field column="desc" />
-		</entity>
-	</document>
+  <document>
+    <entity name="x" query="select * from x">
+      <field column="id" />
+      <field column="desc" />
+    </entity>
+  </document>
 </dataConfig>
diff --git a/solr/contrib/extraction/src/test-files/extraction/solr/collection1/conf/solrconfig.xml b/solr/contrib/extraction/src/test-files/extraction/solr/collection1/conf/solrconfig.xml
index 58a5a2a..43f1c1d 100644
--- a/solr/contrib/extraction/src/test-files/extraction/solr/collection1/conf/solrconfig.xml
+++ b/solr/contrib/extraction/src/test-files/extraction/solr/collection1/conf/solrconfig.xml
@@ -159,7 +159,7 @@
      is not specified in the request.
   -->
   <requestHandler name="standard" class="solr.StandardRequestHandler">
-  	<bool name="httpCaching">true</bool>
+    <bool name="httpCaching">true</bool>
   </requestHandler>
   <requestHandler name="dismax" class="solr.SearchHandler" >
     <lst name="defaults">
diff --git a/solr/contrib/langid/build.xml b/solr/contrib/langid/build.xml
index bc3cd1b..276fd12 100644
--- a/solr/contrib/langid/build.xml
+++ b/solr/contrib/langid/build.xml
@@ -23,9 +23,9 @@
     Language Identifier contrib for extracting language from a document being indexed
   </description>
 
-	<import file="../contrib-build.xml"/>
+  <import file="../contrib-build.xml"/>
 
-	<path id="classpath">
+  <path id="classpath">
     <fileset dir="../extraction/lib" excludes="${common.classpath.excludes}"/>
     <fileset dir="lib" excludes="${common.classpath.excludes}"/>
     <path refid="solr.base.classpath"/>   
diff --git a/solr/contrib/langid/src/test-files/langid/solr/collection1/conf/solrconfig-languageidentifier.xml b/solr/contrib/langid/src/test-files/langid/solr/collection1/conf/solrconfig-languageidentifier.xml
index 3fc1939..927e2b3 100644
--- a/solr/contrib/langid/src/test-files/langid/solr/collection1/conf/solrconfig-languageidentifier.xml
+++ b/solr/contrib/langid/src/test-files/langid/solr/collection1/conf/solrconfig-languageidentifier.xml
@@ -62,36 +62,36 @@
   </requestHandler>  
 
   <updateRequestProcessorChain name="lang_id">
-		<processor class="org.apache.solr.update.processor.TikaLanguageIdentifierUpdateProcessorFactory">
-	    <!-- Can take defaults, invariants and appends just like req handlers-->
-	    <lst name="defaults">
-	      <bool name="langid">true</bool>
-	      <str name="langid.fl">name,subject</str>
-	      <bool name="langid.map">true</bool>
-	      <str name="langid.langField">language_s</str>
-	      <str name="langid.langsField">language_sm</str>
-	      <str name="langid.map.lcmap">th:thai</str>
-	      <float name="threshold">0.5</float>
-	      <str name="langid.fallback">fallback</str>
-	    </lst>
-		</processor>
+    <processor class="org.apache.solr.update.processor.TikaLanguageIdentifierUpdateProcessorFactory">
+      <!-- Can take defaults, invariants and appends just like req handlers-->
+      <lst name="defaults">
+        <bool name="langid">true</bool>
+        <str name="langid.fl">name,subject</str>
+        <bool name="langid.map">true</bool>
+        <str name="langid.langField">language_s</str>
+        <str name="langid.langsField">language_sm</str>
+        <str name="langid.map.lcmap">th:thai</str>
+        <float name="threshold">0.5</float>
+        <str name="langid.fallback">fallback</str>
+      </lst>
+    </processor>
     <processor class="solr.RunUpdateProcessorFactory" />
   </updateRequestProcessorChain>
   
     <updateRequestProcessorChain name="lang_id_alt">
-		<processor class="org.apache.solr.update.processor.LangDetectLanguageIdentifierUpdateProcessorFactory">
-	    <!-- Can take defaults, invariants and appends just like req handlers-->
-	    <lst name="defaults">
-	      <bool name="langid">true</bool>
-	      <str name="langid.fl">name,subject</str>
-	      <bool name="langid.map">true</bool>
-	      <str name="langid.langField">language_s</str>
-	      <str name="langid.langsField">language_sm</str>
-	      <str name="langid.map.lcmap">th:thai</str>
-	      <float name="threshold">0.5</float>
-	      <str name="langid.fallback">fallback</str>
-	    </lst>
-		</processor>
+    <processor class="org.apache.solr.update.processor.LangDetectLanguageIdentifierUpdateProcessorFactory">
+      <!-- Can take defaults, invariants and appends just like req handlers-->
+      <lst name="defaults">
+        <bool name="langid">true</bool>
+        <str name="langid.fl">name,subject</str>
+        <bool name="langid.map">true</bool>
+        <str name="langid.langField">language_s</str>
+        <str name="langid.langsField">language_sm</str>
+        <str name="langid.map.lcmap">th:thai</str>
+        <float name="threshold">0.5</float>
+        <str name="langid.fallback">fallback</str>
+      </lst>
+    </processor>
     <processor class="solr.RunUpdateProcessorFactory" />
   </updateRequestProcessorChain>
   
diff --git a/solr/contrib/morphlines-core/src/test-files/solr/collection1/conf/schema.xml b/solr/contrib/morphlines-core/src/test-files/solr/collection1/conf/schema.xml
index 224b27a..0d2c295 100644
--- a/solr/contrib/morphlines-core/src/test-files/solr/collection1/conf/schema.xml
+++ b/solr/contrib/morphlines-core/src/test-files/solr/collection1/conf/schema.xml
@@ -184,8 +184,8 @@
     <!-- sortMissingLast and sortMissingFirst attributes are optional attributes are
          currently supported on types that are sorted internally as strings
          and on numeric types.
-	     This includes "string","boolean", and, as of 3.5 (and 4.x),
-	     int, float, long, date, double, including the "Trie" variants.
+       This includes "string","boolean", and, as of 3.5 (and 4.x),
+       int, float, long, date, double, including the "Trie" variants.
        - If sortMissingLast="true", then a sort on this field will cause documents
          without the field to come after documents with the field,
          regardless of the requested sort order (asc or desc).
@@ -293,9 +293,9 @@
 
     <!-- A general text field that has reasonable, generic
          cross-language defaults: it tokenizes with StandardTokenizer,
-	 removes stop words from case-insensitive "stopwords.txt"
-	 (empty by default), and down cases.  At query time only, it
-	 also applies synonyms. -->
+   removes stop words from case-insensitive "stopwords.txt"
+   (empty by default), and down cases.  At query time only, it
+   also applies synonyms. -->
     <fieldType name="text_general" class="solr.TextField" positionIncrementGap="100">
       <analyzer type="index">
         <tokenizer class="solr.StandardTokenizerFactory"/>
@@ -331,11 +331,11 @@
                
                 />
         <filter class="solr.LowerCaseFilterFactory"/>
-	<filter class="solr.EnglishPossessiveFilterFactory"/>
+  <filter class="solr.EnglishPossessiveFilterFactory"/>
         <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-	<!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
         <filter class="solr.EnglishMinimalStemFilterFactory"/>
-	-->
+  -->
         <filter class="solr.PorterStemFilterFactory"/>
       </analyzer>
       <analyzer type="query">
@@ -347,23 +347,23 @@
                
                 />
         <filter class="solr.LowerCaseFilterFactory"/>
-	<filter class="solr.EnglishPossessiveFilterFactory"/>
+  <filter class="solr.EnglishPossessiveFilterFactory"/>
         <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-	<!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
         <filter class="solr.EnglishMinimalStemFilterFactory"/>
-	-->
+  -->
         <filter class="solr.PorterStemFilterFactory"/>
       </analyzer>
     </fieldType>
 
     <!-- A text field with defaults appropriate for English, plus
-	 aggressive word-splitting and autophrase features enabled.
-	 This field is just like text_en, except it adds
-	 WordDelimiterFilter to enable splitting and matching of
-	 words on case-change, alpha numeric boundaries, and
-	 non-alphanumeric chars.  This means certain compound word
-	 cases will work, for example query "wi fi" will match
-	 document "WiFi" or "wi-fi".
+   aggressive word-splitting and autophrase features enabled.
+   This field is just like text_en, except it adds
+   WordDelimiterFilter to enable splitting and matching of
+   words on case-change, alpha numeric boundaries, and
+   non-alphanumeric chars.  This means certain compound word
+   cases will work, for example query "wi fi" will match
+   document "WiFi" or "wi-fi".
         -->
     <fieldType name="text_en_splitting" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true">
       <analyzer type="index">
@@ -415,7 +415,7 @@
     </fieldType>
 
     <!-- Just like text_general except it reverses the characters of
-	 each token, to enable more efficient leading wildcard queries. -->
+   each token, to enable more efficient leading wildcard queries. -->
     <fieldType name="text_general_rev" class="solr.TextField" positionIncrementGap="100">
       <analyzer type="index">
         <tokenizer class="solr.StandardTokenizerFactory"/>
@@ -492,10 +492,10 @@
         a token of "foo|1.4"  would be indexed as "foo" with a payload of 1.4f
         Attributes of the DelimitedPayloadTokenFilterFactory : 
          "delimiter" - a one character delimiter. Default is | (pipe)
-	 "encoder" - how to encode the following value into a playload
-	    float -> org.apache.lucene.analysis.payloads.FloatEncoder,
-	    integer -> o.a.l.a.p.IntegerEncoder
-	    identity -> o.a.l.a.p.IdentityEncoder
+   "encoder" - how to encode the following value into a playload
+      float -> org.apache.lucene.analysis.payloads.FloatEncoder,
+      integer -> o.a.l.a.p.IntegerEncoder
+      identity -> o.a.l.a.p.IdentityEncoder
             Fully Qualified class name implementing PayloadEncoder, Encoder must have a no arg constructor.
          -->
         <filter class="solr.DelimitedPayloadTokenFilterFactory" encoder="float"/>
@@ -516,10 +516,10 @@
     -->
     <fieldType name="descendent_path" class="solr.TextField">
       <analyzer type="index">
-	<tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
+  <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
       </analyzer>
       <analyzer type="query">
-	<tokenizer class="solr.KeywordTokenizerFactory" />
+  <tokenizer class="solr.KeywordTokenizerFactory" />
       </analyzer>
     </fieldType>
     <!-- 
@@ -528,10 +528,10 @@
     -->
     <fieldType name="ancestor_path" class="solr.TextField">
       <analyzer type="index">
-	<tokenizer class="solr.KeywordTokenizerFactory" />
+  <tokenizer class="solr.KeywordTokenizerFactory" />
       </analyzer>
       <analyzer type="query">
-	<tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
+  <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
       </analyzer>
     </fieldType>
 
diff --git a/solr/contrib/morphlines-core/src/test-files/solr/collection1/conf/solrconfig.xml b/solr/contrib/morphlines-core/src/test-files/solr/collection1/conf/solrconfig.xml
index 146e69f..619e917 100644
--- a/solr/contrib/morphlines-core/src/test-files/solr/collection1/conf/solrconfig.xml
+++ b/solr/contrib/morphlines-core/src/test-files/solr/collection1/conf/solrconfig.xml
@@ -955,7 +955,7 @@
       <!-- maximum threshold of documents a query term can appear to be considered for correction -->
       <float name="maxQueryFrequency">0.01</float>
       <!-- uncomment this to require suggestions to occur in 1% of the documents
-      	<float name="thresholdTokenFrequency">.01</float>
+        <float name="thresholdTokenFrequency">.01</float>
       -->
     </lst>
     
diff --git a/solr/contrib/morphlines-core/src/test-files/solr/minimr/conf/schema.xml b/solr/contrib/morphlines-core/src/test-files/solr/minimr/conf/schema.xml
index 6dd9be9..e096c17 100644
--- a/solr/contrib/morphlines-core/src/test-files/solr/minimr/conf/schema.xml
+++ b/solr/contrib/morphlines-core/src/test-files/solr/minimr/conf/schema.xml
@@ -196,8 +196,8 @@
     <!-- sortMissingLast and sortMissingFirst attributes are optional attributes are
          currently supported on types that are sorted internally as strings
          and on numeric types.
-	     This includes "string","boolean", and, as of 3.5 (and 4.x),
-	     int, float, long, date, double, including the "Trie" variants.
+       This includes "string","boolean", and, as of 3.5 (and 4.x),
+       int, float, long, date, double, including the "Trie" variants.
        - If sortMissingLast="true", then a sort on this field will cause documents
          without the field to come after documents with the field,
          regardless of the requested sort order (asc or desc).
@@ -308,9 +308,9 @@
 
     <!-- A general text field that has reasonable, generic
          cross-language defaults: it tokenizes with StandardTokenizer,
-	 removes stop words from case-insensitive "stopwords.txt"
-	 (empty by default), and down cases.  At query time only, it
-	 also applies synonyms. -->
+   removes stop words from case-insensitive "stopwords.txt"
+   (empty by default), and down cases.  At query time only, it
+   also applies synonyms. -->
     <fieldType name="text_general" class="solr.TextField" positionIncrementGap="100">
       <analyzer type="index">
         <tokenizer class="solr.StandardTokenizerFactory"/>
@@ -346,11 +346,11 @@
                
                 />
         <filter class="solr.LowerCaseFilterFactory"/>
-	<filter class="solr.EnglishPossessiveFilterFactory"/>
+  <filter class="solr.EnglishPossessiveFilterFactory"/>
         <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-	<!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
         <filter class="solr.EnglishMinimalStemFilterFactory"/>
-	-->
+  -->
         <filter class="solr.PorterStemFilterFactory"/>
       </analyzer>
       <analyzer type="query">
@@ -362,23 +362,23 @@
                
                 />
         <filter class="solr.LowerCaseFilterFactory"/>
-	<filter class="solr.EnglishPossessiveFilterFactory"/>
+  <filter class="solr.EnglishPossessiveFilterFactory"/>
         <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-	<!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
         <filter class="solr.EnglishMinimalStemFilterFactory"/>
-	-->
+  -->
         <filter class="solr.PorterStemFilterFactory"/>
       </analyzer>
     </fieldType>
 
     <!-- A text field with defaults appropriate for English, plus
-	 aggressive word-splitting and autophrase features enabled.
-	 This field is just like text_en, except it adds
-	 WordDelimiterFilter to enable splitting and matching of
-	 words on case-change, alpha numeric boundaries, and
-	 non-alphanumeric chars.  This means certain compound word
-	 cases will work, for example query "wi fi" will match
-	 document "WiFi" or "wi-fi".
+   aggressive word-splitting and autophrase features enabled.
+   This field is just like text_en, except it adds
+   WordDelimiterFilter to enable splitting and matching of
+   words on case-change, alpha numeric boundaries, and
+   non-alphanumeric chars.  This means certain compound word
+   cases will work, for example query "wi fi" will match
+   document "WiFi" or "wi-fi".
         -->
     <fieldType name="text_en_splitting" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true">
       <analyzer type="index">
@@ -430,7 +430,7 @@
     </fieldType>
 
     <!-- Just like text_general except it reverses the characters of
-	 each token, to enable more efficient leading wildcard queries. -->
+   each token, to enable more efficient leading wildcard queries. -->
     <fieldType name="text_general_rev" class="solr.TextField" positionIncrementGap="100">
       <analyzer type="index">
         <tokenizer class="solr.StandardTokenizerFactory"/>
@@ -505,10 +505,10 @@
         a token of "foo|1.4"  would be indexed as "foo" with a payload of 1.4f
         Attributes of the DelimitedPayloadTokenFilterFactory : 
          "delimiter" - a one character delimiter. Default is | (pipe)
-	 "encoder" - how to encode the following value into a playload
-	    float -> org.apache.lucene.analysis.payloads.FloatEncoder,
-	    integer -> o.a.l.a.p.IntegerEncoder
-	    identity -> o.a.l.a.p.IdentityEncoder
+   "encoder" - how to encode the following value into a playload
+      float -> org.apache.lucene.analysis.payloads.FloatEncoder,
+      integer -> o.a.l.a.p.IntegerEncoder
+      identity -> o.a.l.a.p.IdentityEncoder
             Fully Qualified class name implementing PayloadEncoder, Encoder must have a no arg constructor.
          -->
         <filter class="solr.DelimitedPayloadTokenFilterFactory" encoder="float"/>
@@ -529,10 +529,10 @@
     -->
     <fieldType name="descendent_path" class="solr.TextField">
       <analyzer type="index">
-	<tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
+  <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
       </analyzer>
       <analyzer type="query">
-	<tokenizer class="solr.KeywordTokenizerFactory" />
+  <tokenizer class="solr.KeywordTokenizerFactory" />
       </analyzer>
     </fieldType>
     <!-- 
@@ -541,10 +541,10 @@
     -->
     <fieldType name="ancestor_path" class="solr.TextField">
       <analyzer type="index">
-	<tokenizer class="solr.KeywordTokenizerFactory" />
+  <tokenizer class="solr.KeywordTokenizerFactory" />
       </analyzer>
       <analyzer type="query">
-	<tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
+  <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
       </analyzer>
     </fieldType>
 
diff --git a/solr/contrib/morphlines-core/src/test-files/solr/minimr/conf/solrconfig.xml b/solr/contrib/morphlines-core/src/test-files/solr/minimr/conf/solrconfig.xml
index d019986..a260b9e 100644
--- a/solr/contrib/morphlines-core/src/test-files/solr/minimr/conf/solrconfig.xml
+++ b/solr/contrib/morphlines-core/src/test-files/solr/minimr/conf/solrconfig.xml
@@ -974,7 +974,7 @@
       <!-- maximum threshold of documents a query term can appear to be considered for correction -->
       <float name="maxQueryFrequency">0.01</float>
       <!-- uncomment this to require suggestions to occur in 1% of the documents
-      	<float name="thresholdTokenFrequency">.01</float>
+        <float name="thresholdTokenFrequency">.01</float>
       -->
     </lst>
     
diff --git a/solr/contrib/morphlines-core/src/test-files/solr/mrunit/conf/schema.xml b/solr/contrib/morphlines-core/src/test-files/solr/mrunit/conf/schema.xml
index 49082b0..d18e8ce 100644
--- a/solr/contrib/morphlines-core/src/test-files/solr/mrunit/conf/schema.xml
+++ b/solr/contrib/morphlines-core/src/test-files/solr/mrunit/conf/schema.xml
@@ -196,8 +196,8 @@
     <!-- sortMissingLast and sortMissingFirst attributes are optional attributes are
          currently supported on types that are sorted internally as strings
          and on numeric types.
-	     This includes "string","boolean", and, as of 3.5 (and 4.x),
-	     int, float, long, date, double, including the "Trie" variants.
+       This includes "string","boolean", and, as of 3.5 (and 4.x),
+       int, float, long, date, double, including the "Trie" variants.
        - If sortMissingLast="true", then a sort on this field will cause documents
          without the field to come after documents with the field,
          regardless of the requested sort order (asc or desc).
@@ -308,9 +308,9 @@
 
     <!-- A general text field that has reasonable, generic
          cross-language defaults: it tokenizes with StandardTokenizer,
-	 removes stop words from case-insensitive "stopwords.txt"
-	 (empty by default), and down cases.  At query time only, it
-	 also applies synonyms. -->
+   removes stop words from case-insensitive "stopwords.txt"
+   (empty by default), and down cases.  At query time only, it
+   also applies synonyms. -->
     <fieldType name="text_general" class="solr.TextField" positionIncrementGap="100">
       <analyzer type="index">
         <tokenizer class="solr.StandardTokenizerFactory"/>
@@ -346,11 +346,11 @@
                 
                 />
         <filter class="solr.LowerCaseFilterFactory"/>
-	<filter class="solr.EnglishPossessiveFilterFactory"/>
+  <filter class="solr.EnglishPossessiveFilterFactory"/>
         <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-	<!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
         <filter class="solr.EnglishMinimalStemFilterFactory"/>
-	-->
+  -->
         <filter class="solr.PorterStemFilterFactory"/>
       </analyzer>
       <analyzer type="query">
@@ -362,23 +362,23 @@
                 
                 />
         <filter class="solr.LowerCaseFilterFactory"/>
-	<filter class="solr.EnglishPossessiveFilterFactory"/>
+  <filter class="solr.EnglishPossessiveFilterFactory"/>
         <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-	<!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
         <filter class="solr.EnglishMinimalStemFilterFactory"/>
-	-->
+  -->
         <filter class="solr.PorterStemFilterFactory"/>
       </analyzer>
     </fieldType>
 
     <!-- A text field with defaults appropriate for English, plus
-	 aggressive word-splitting and autophrase features enabled.
-	 This field is just like text_en, except it adds
-	 WordDelimiterFilter to enable splitting and matching of
-	 words on case-change, alpha numeric boundaries, and
-	 non-alphanumeric chars.  This means certain compound word
-	 cases will work, for example query "wi fi" will match
-	 document "WiFi" or "wi-fi".
+   aggressive word-splitting and autophrase features enabled.
+   This field is just like text_en, except it adds
+   WordDelimiterFilter to enable splitting and matching of
+   words on case-change, alpha numeric boundaries, and
+   non-alphanumeric chars.  This means certain compound word
+   cases will work, for example query "wi fi" will match
+   document "WiFi" or "wi-fi".
         -->
     <fieldType name="text_en_splitting" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true">
       <analyzer type="index">
@@ -430,7 +430,7 @@
     </fieldType>
 
     <!-- Just like text_general except it reverses the characters of
-	 each token, to enable more efficient leading wildcard queries. -->
+   each token, to enable more efficient leading wildcard queries. -->
     <fieldType name="text_general_rev" class="solr.TextField" positionIncrementGap="100">
       <analyzer type="index">
         <tokenizer class="solr.StandardTokenizerFactory"/>
@@ -505,10 +505,10 @@
         a token of "foo|1.4"  would be indexed as "foo" with a payload of 1.4f
         Attributes of the DelimitedPayloadTokenFilterFactory : 
          "delimiter" - a one character delimiter. Default is | (pipe)
-	 "encoder" - how to encode the following value into a playload
-	    float -> org.apache.lucene.analysis.payloads.FloatEncoder,
-	    integer -> o.a.l.a.p.IntegerEncoder
-	    identity -> o.a.l.a.p.IdentityEncoder
+   "encoder" - how to encode the following value into a playload
+      float -> org.apache.lucene.analysis.payloads.FloatEncoder,
+      integer -> o.a.l.a.p.IntegerEncoder
+      identity -> o.a.l.a.p.IdentityEncoder
             Fully Qualified class name implementing PayloadEncoder, Encoder must have a no arg constructor.
          -->
         <filter class="solr.DelimitedPayloadTokenFilterFactory" encoder="float"/>
@@ -529,10 +529,10 @@
     -->
     <fieldType name="descendent_path" class="solr.TextField">
       <analyzer type="index">
-	<tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
+  <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
       </analyzer>
       <analyzer type="query">
-	<tokenizer class="solr.KeywordTokenizerFactory" />
+  <tokenizer class="solr.KeywordTokenizerFactory" />
       </analyzer>
     </fieldType>
     <!-- 
@@ -541,10 +541,10 @@
     -->
     <fieldType name="ancestor_path" class="solr.TextField">
       <analyzer type="index">
-	<tokenizer class="solr.KeywordTokenizerFactory" />
+  <tokenizer class="solr.KeywordTokenizerFactory" />
       </analyzer>
       <analyzer type="query">
-	<tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
+  <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
       </analyzer>
     </fieldType>
 
diff --git a/solr/contrib/morphlines-core/src/test-files/solr/mrunit/conf/solrconfig.xml b/solr/contrib/morphlines-core/src/test-files/solr/mrunit/conf/solrconfig.xml
index bd86f30..bc06928 100644
--- a/solr/contrib/morphlines-core/src/test-files/solr/mrunit/conf/solrconfig.xml
+++ b/solr/contrib/morphlines-core/src/test-files/solr/mrunit/conf/solrconfig.xml
@@ -978,7 +978,7 @@
       <!-- maximum threshold of documents a query term can appear to be considered for correction -->
       <float name="maxQueryFrequency">0.01</float>
       <!-- uncomment this to require suggestions to occur in 1% of the documents
-      	<float name="thresholdTokenFrequency">.01</float>
+        <float name="thresholdTokenFrequency">.01</float>
       -->
     </lst>
     
diff --git a/solr/contrib/morphlines-core/src/test-files/solr/solrcelltest/collection1/conf/schema.xml b/solr/contrib/morphlines-core/src/test-files/solr/solrcelltest/collection1/conf/schema.xml
index d896f18..bb71a42 100644
--- a/solr/contrib/morphlines-core/src/test-files/solr/solrcelltest/collection1/conf/schema.xml
+++ b/solr/contrib/morphlines-core/src/test-files/solr/solrcelltest/collection1/conf/schema.xml
@@ -151,8 +151,8 @@
     <!-- sortMissingLast and sortMissingFirst attributes are optional attributes are
          currently supported on types that are sorted internally as strings
          and on numeric types.
-	     This includes "string","boolean", and, as of 3.5 (and 4.x),
-	     int, float, long, date, double, including the "Trie" variants.
+       This includes "string","boolean", and, as of 3.5 (and 4.x),
+       int, float, long, date, double, including the "Trie" variants.
        - If sortMissingLast="true", then a sort on this field will cause documents
          without the field to come after documents with the field,
          regardless of the requested sort order (asc or desc).
@@ -260,9 +260,9 @@
 
     <!-- A general text field that has reasonable, generic
          cross-language defaults: it tokenizes with StandardTokenizer,
-	 removes stop words from case-insensitive "stopwords.txt"
-	 (empty by default), and down cases.  At query time only, it
-	 also applies synonyms. -->
+   removes stop words from case-insensitive "stopwords.txt"
+   (empty by default), and down cases.  At query time only, it
+   also applies synonyms. -->
     <fieldType name="text_general" class="solr.TextField" positionIncrementGap="100">
       <analyzer type="index">
         <tokenizer class="solr.StandardTokenizerFactory"/>
@@ -298,11 +298,11 @@
                
                 />
         <filter class="solr.LowerCaseFilterFactory"/>
-	<filter class="solr.EnglishPossessiveFilterFactory"/>
+  <filter class="solr.EnglishPossessiveFilterFactory"/>
         <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-	<!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
         <filter class="solr.EnglishMinimalStemFilterFactory"/>
-	-->
+  -->
         <filter class="solr.PorterStemFilterFactory"/>
       </analyzer>
       <analyzer type="query">
@@ -314,23 +314,23 @@
                
                 />
         <filter class="solr.LowerCaseFilterFactory"/>
-	<filter class="solr.EnglishPossessiveFilterFactory"/>
+  <filter class="solr.EnglishPossessiveFilterFactory"/>
         <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-	<!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
         <filter class="solr.EnglishMinimalStemFilterFactory"/>
-	-->
+  -->
         <filter class="solr.PorterStemFilterFactory"/>
       </analyzer>
     </fieldType>
 
     <!-- A text field with defaults appropriate for English, plus
-	 aggressive word-splitting and autophrase features enabled.
-	 This field is just like text_en, except it adds
-	 WordDelimiterFilter to enable splitting and matching of
-	 words on case-change, alpha numeric boundaries, and
-	 non-alphanumeric chars.  This means certain compound word
-	 cases will work, for example query "wi fi" will match
-	 document "WiFi" or "wi-fi".
+   aggressive word-splitting and autophrase features enabled.
+   This field is just like text_en, except it adds
+   WordDelimiterFilter to enable splitting and matching of
+   words on case-change, alpha numeric boundaries, and
+   non-alphanumeric chars.  This means certain compound word
+   cases will work, for example query "wi fi" will match
+   document "WiFi" or "wi-fi".
         -->
     <fieldType name="text_en_splitting" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true">
       <analyzer type="index">
@@ -382,7 +382,7 @@
     </fieldType>
 
     <!-- Just like text_general except it reverses the characters of
-	 each token, to enable more efficient leading wildcard queries. -->
+   each token, to enable more efficient leading wildcard queries. -->
     <fieldType name="text_general_rev" class="solr.TextField" positionIncrementGap="100">
       <analyzer type="index">
         <tokenizer class="solr.StandardTokenizerFactory"/>
@@ -459,10 +459,10 @@
         a token of "foo|1.4"  would be indexed as "foo" with a payload of 1.4f
         Attributes of the DelimitedPayloadTokenFilterFactory : 
          "delimiter" - a one character delimiter. Default is | (pipe)
-	 "encoder" - how to encode the following value into a playload
-	    float -> org.apache.lucene.analysis.payloads.FloatEncoder,
-	    integer -> o.a.l.a.p.IntegerEncoder
-	    identity -> o.a.l.a.p.IdentityEncoder
+   "encoder" - how to encode the following value into a playload
+      float -> org.apache.lucene.analysis.payloads.FloatEncoder,
+      integer -> o.a.l.a.p.IntegerEncoder
+      identity -> o.a.l.a.p.IdentityEncoder
             Fully Qualified class name implementing PayloadEncoder, Encoder must have a no arg constructor.
          -->
         <filter class="solr.DelimitedPayloadTokenFilterFactory" encoder="float"/>
@@ -483,10 +483,10 @@
     -->
     <fieldType name="descendent_path" class="solr.TextField">
       <analyzer type="index">
-	<tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
+  <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
       </analyzer>
       <analyzer type="query">
-	<tokenizer class="solr.KeywordTokenizerFactory" />
+  <tokenizer class="solr.KeywordTokenizerFactory" />
       </analyzer>
     </fieldType>
     <!-- 
@@ -495,10 +495,10 @@
     -->
     <fieldType name="ancestor_path" class="solr.TextField">
       <analyzer type="index">
-	<tokenizer class="solr.KeywordTokenizerFactory" />
+  <tokenizer class="solr.KeywordTokenizerFactory" />
       </analyzer>
       <analyzer type="query">
-	<tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
+  <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
       </analyzer>
     </fieldType>
 
diff --git a/solr/contrib/morphlines-core/src/test-files/solr/solrcelltest/collection1/conf/solrconfig.xml b/solr/contrib/morphlines-core/src/test-files/solr/solrcelltest/collection1/conf/solrconfig.xml
index 146e69f..619e917 100644
--- a/solr/contrib/morphlines-core/src/test-files/solr/solrcelltest/collection1/conf/solrconfig.xml
+++ b/solr/contrib/morphlines-core/src/test-files/solr/solrcelltest/collection1/conf/solrconfig.xml
@@ -955,7 +955,7 @@
       <!-- maximum threshold of documents a query term can appear to be considered for correction -->
       <float name="maxQueryFrequency">0.01</float>
       <!-- uncomment this to require suggestions to occur in 1% of the documents
-      	<float name="thresholdTokenFrequency">.01</float>
+        <float name="thresholdTokenFrequency">.01</float>
       -->
     </lst>
     
diff --git a/solr/contrib/morphlines-core/src/test-files/solr/solrcloud/conf/solrconfig.xml b/solr/contrib/morphlines-core/src/test-files/solr/solrcloud/conf/solrconfig.xml
index 12d443d..12ea29b 100644
--- a/solr/contrib/morphlines-core/src/test-files/solr/solrcloud/conf/solrconfig.xml
+++ b/solr/contrib/morphlines-core/src/test-files/solr/solrcloud/conf/solrconfig.xml
@@ -977,7 +977,7 @@
       <!-- maximum threshold of documents a query term can appear to be considered for correction -->
       <float name="maxQueryFrequency">0.01</float>
       <!-- uncomment this to require suggestions to occur in 1% of the documents
-      	<float name="thresholdTokenFrequency">.01</float>
+        <float name="thresholdTokenFrequency">.01</float>
       -->
     </lst>
     
diff --git a/solr/contrib/morphlines-core/src/test-files/test-documents/testXML.xml b/solr/contrib/morphlines-core/src/test-files/test-documents/testXML.xml
index a01a402..dcfbb1c 100644
--- a/solr/contrib/morphlines-core/src/test-files/test-documents/testXML.xml
+++ b/solr/contrib/morphlines-core/src/test-files/test-documents/testXML.xml
@@ -17,32 +17,32 @@
 -->
 <oaidc:dc xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:oaidc="http://www.openarchives.org/OAI/2.0/oai_dc/">
 
-	<dc:title>Tika test document</dc:title>
+  <dc:title>Tika test document</dc:title>
 
-	<dc:creator>Rida Benjelloun</dc:creator>
+  <dc:creator>Rida Benjelloun</dc:creator>
 
-	<dc:subject>Java</dc:subject>
+  <dc:subject>Java</dc:subject>
 
-	<dc:subject>XML</dc:subject>
+  <dc:subject>XML</dc:subject>
 
-	<dc:subject>XSLT</dc:subject>
+  <dc:subject>XSLT</dc:subject>
 
-	<dc:subject>JDOM</dc:subject>
+  <dc:subject>JDOM</dc:subject>
  
-	<dc:subject>Indexation</dc:subject>
+  <dc:subject>Indexation</dc:subject>
 
-	<dc:description>Framework d'indexation des documents XML, HTML, PDF etc.. </dc:description>
+  <dc:description>Framework d'indexation des documents XML, HTML, PDF etc.. </dc:description>
 
-	<dc:identifier>http://www.apache.org</dc:identifier>
+  <dc:identifier>http://www.apache.org</dc:identifier>
 
-	<dc:date>2000-12-01T00:00:00.000Z</dc:date>
+  <dc:date>2000-12-01T00:00:00.000Z</dc:date>
 
-	<dc:type>test</dc:type>
+  <dc:type>test</dc:type>
 
-	<dc:format>application/msword</dc:format>
+  <dc:format>application/msword</dc:format>
 
-	<dc:language>Fr</dc:language>
+  <dc:language>Fr</dc:language>
 
-	<dc:rights>Archimde et Lius ? Chteauneuf testing chars en t</dc:rights>	
+  <dc:rights>Archimde et Lius ? Chteauneuf testing chars en t</dc:rights>  
 
 </oaidc:dc>
\ No newline at end of file
diff --git a/solr/contrib/uima/src/resources/org/apache/uima/desc/HmmTagger.xml b/solr/contrib/uima/src/resources/org/apache/uima/desc/HmmTagger.xml
index 8fe4216..d0f55a4 100644
--- a/solr/contrib/uima/src/resources/org/apache/uima/desc/HmmTagger.xml
+++ b/solr/contrib/uima/src/resources/org/apache/uima/desc/HmmTagger.xml
@@ -1,21 +1,21 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
-	Licensed to the Apache Software Foundation (ASF) under one
-	or more contributor license agreements.  See the NOTICE file
-	distributed with this work for additional information
-	regarding copyright ownership.  The ASF licenses this file
-	to you under the Apache License, Version 2.0 (the
-	"License"); you may not use this file except in compliance
-	with the License.  You may obtain a copy of the License at
-	
-	http://www.apache.org/licenses/LICENSE-2.0
-	
-	Unless required by applicable law or agreed to in writing,
-	software distributed under the License is distributed on an
-	"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-	KIND, either express or implied.  See the License for the
-	specific language governing permissions and limitations
-	under the License.    
+  Licensed to the Apache Software Foundation (ASF) under one
+  or more contributor license agreements.  See the NOTICE file
+  distributed with this work for additional information
+  regarding copyright ownership.  The ASF licenses this file
+  to you under the Apache License, Version 2.0 (the
+  "License"); you may not use this file except in compliance
+  with the License.  You may obtain a copy of the License at
+  
+  http://www.apache.org/licenses/LICENSE-2.0
+  
+  Unless required by applicable law or agreed to in writing,
+  software distributed under the License is distributed on an
+  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+  KIND, either express or implied.  See the License for the
+  specific language governing permissions and limitations
+  under the License.    
 -->
 <analysisEngineDescription xmlns="http://uima.apache.org/resourceSpecifier">
   <frameworkImplementation>org.apache.uima.java</frameworkImplementation>
@@ -24,9 +24,9 @@
   <analysisEngineMetaData>
     <name>Hidden Markov Model - Part of Speech Tagger</name>
     <description>A configuration of the HmmTaggerAnnotator that looks for
-			parts of speech of identified tokens within existing
-			Sentence and Token annotations. See also
-			WhitespaceTokenizer.xml.</description>
+      parts of speech of identified tokens within existing
+      Sentence and Token annotations. See also
+      WhitespaceTokenizer.xml.</description>
     <version>1.0</version>
     <vendor>The Apache Software Foundation</vendor>
     <configurationParameters>
@@ -55,7 +55,7 @@
             <featureDescription>
               <name>posTag</name>
               <description>contains part-of-speech of a
-								corresponding token</description>
+                corresponding token</description>
               <rangeTypeName>uima.cas.String</rangeTypeName>
             </featureDescription>
           </features>
diff --git a/solr/contrib/uima/src/resources/org/apache/uima/desc/TextCategorizationAEDescriptor.xml b/solr/contrib/uima/src/resources/org/apache/uima/desc/TextCategorizationAEDescriptor.xml
index 16aff2b..45b7bef 100644
--- a/solr/contrib/uima/src/resources/org/apache/uima/desc/TextCategorizationAEDescriptor.xml
+++ b/solr/contrib/uima/src/resources/org/apache/uima/desc/TextCategorizationAEDescriptor.xml
@@ -1,22 +1,22 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
 
-    	Licensed to the Apache Software Foundation (ASF) under one
-    	or more contributor license agreements.  See the NOTICE file
-    	distributed with this work for additional information
-    	regarding copyright ownership.  The ASF licenses this file
-    	to you under the Apache License, Version 2.0 (the
-    	"License"); you may not use this file except in compliance
-    	with the License.  You may obtain a copy of the License at
+      Licensed to the Apache Software Foundation (ASF) under one
+      or more contributor license agreements.  See the NOTICE file
+      distributed with this work for additional information
+      regarding copyright ownership.  The ASF licenses this file
+      to you under the Apache License, Version 2.0 (the
+      "License"); you may not use this file except in compliance
+      with the License.  You may obtain a copy of the License at
 
-    	http://www.apache.org/licenses/LICENSE-2.0
+      http://www.apache.org/licenses/LICENSE-2.0
 
-    	Unless required by applicable law or agreed to in writing,
-    	software distributed under the License is distributed on an
-    	"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    	KIND, either express or implied.  See the License for the
-    	specific language governing permissions and limitations
-    	under the License.
+      Unless required by applicable law or agreed to in writing,
+      software distributed under the License is distributed on an
+      "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+      KIND, either express or implied.  See the License for the
+      specific language governing permissions and limitations
+      under the License.
 
 -->
 <analysisEngineDescription xmlns="http://uima.apache.org/resourceSpecifier">
diff --git a/solr/contrib/uima/src/resources/org/apache/uima/desc/WhitespaceTokenizer.xml b/solr/contrib/uima/src/resources/org/apache/uima/desc/WhitespaceTokenizer.xml
index 686dbef..e8ce57d 100644
--- a/solr/contrib/uima/src/resources/org/apache/uima/desc/WhitespaceTokenizer.xml
+++ b/solr/contrib/uima/src/resources/org/apache/uima/desc/WhitespaceTokenizer.xml
@@ -1,115 +1,115 @@
 <?xml version="1.0" encoding="UTF-8" ?>
 
 <!--
-	***************************************************************
-	* Licensed to the Apache Software Foundation (ASF) under one
-	* or more contributor license agreements.  See the NOTICE file
-	* distributed with this work for additional information
-	* regarding copyright ownership.  The ASF licenses this file
-	* to you under the Apache License, Version 2.0 (the
-	* "License"); you may not use this file except in compliance
-	* with the License.  You may obtain a copy of the License at
-	*
-	*   http://www.apache.org/licenses/LICENSE-2.0
-	* 
-	* Unless required by applicable law or agreed to in writing,
-	* software distributed under the License is distributed on an
-	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-	* KIND, either express or implied.  See the License for the
-	* specific language governing permissions and limitations
-	* under the License.
-	***************************************************************
+  ***************************************************************
+  * Licensed to the Apache Software Foundation (ASF) under one
+  * or more contributor license agreements.  See the NOTICE file
+  * distributed with this work for additional information
+  * regarding copyright ownership.  The ASF licenses this file
+  * to you under the Apache License, Version 2.0 (the
+  * "License"); you may not use this file except in compliance
+  * with the License.  You may obtain a copy of the License at
+  *
+  *   http://www.apache.org/licenses/LICENSE-2.0
+  * 
+  * Unless required by applicable law or agreed to in writing,
+  * software distributed under the License is distributed on an
+  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+  * KIND, either express or implied.  See the License for the
+  * specific language governing permissions and limitations
+  * under the License.
+  ***************************************************************
 -->
 
 <analysisEngineDescription
-	xmlns="http://uima.apache.org/resourceSpecifier">
-	<frameworkImplementation>
-		org.apache.uima.java
-	</frameworkImplementation>
-	<primitive>true</primitive>
-	<annotatorImplementationName>
-		org.apache.uima.annotator.WhitespaceTokenizer
-	</annotatorImplementationName>
+  xmlns="http://uima.apache.org/resourceSpecifier">
+  <frameworkImplementation>
+    org.apache.uima.java
+  </frameworkImplementation>
+  <primitive>true</primitive>
+  <annotatorImplementationName>
+    org.apache.uima.annotator.WhitespaceTokenizer
+  </annotatorImplementationName>
 
-	<analysisEngineMetaData>
-		<name>WhitespaceTokenizer</name>
-		<description>
-			creates token and sentence annotations for whitespace
-			separated languages
-		</description>
-		<version>1.0</version>
-		<vendor>The Apache Software Foundation</vendor>
+  <analysisEngineMetaData>
+    <name>WhitespaceTokenizer</name>
+    <description>
+      creates token and sentence annotations for whitespace
+      separated languages
+    </description>
+    <version>1.0</version>
+    <vendor>The Apache Software Foundation</vendor>
 
-		<configurationParameters>
-			<configurationParameter>
-				<name>SofaNames</name>
-				<description>
-					The Sofa names the annotator should work on. If no
-					names are specified, the annotator works on the
-					default sofa.
-				</description>
-				<type>String</type>
-				<multiValued>true</multiValued>
-				<mandatory>false</mandatory>
-			</configurationParameter>
+    <configurationParameters>
+      <configurationParameter>
+        <name>SofaNames</name>
+        <description>
+          The Sofa names the annotator should work on. If no
+          names are specified, the annotator works on the
+          default sofa.
+        </description>
+        <type>String</type>
+        <multiValued>true</multiValued>
+        <mandatory>false</mandatory>
+      </configurationParameter>
 
-		</configurationParameters>
+    </configurationParameters>
 
-		<configurationParameterSettings>
-		<!-- 
-			<nameValuePair>
-				<name>SofaNames</name>
-				<value>
-					<array>
-						<string>sofaName</string>
-					</array>
-				</value>
-			</nameValuePair>
-		-->
-		</configurationParameterSettings>
+    <configurationParameterSettings>
+    <!-- 
+      <nameValuePair>
+        <name>SofaNames</name>
+        <value>
+          <array>
+            <string>sofaName</string>
+          </array>
+        </value>
+      </nameValuePair>
+    -->
+    </configurationParameterSettings>
 
-		<typeSystemDescription>
-			<typeDescription>
-				<name>org.apache.uima.TokenAnnotation</name>
-				<description>Single token annotation</description>
-				<supertypeName>uima.tcas.Annotation</supertypeName>
-				<features>
-					<featureDescription>
-						<name>tokenType</name>
-						<description>token type</description>
-						<rangeTypeName>uima.cas.String</rangeTypeName>
-					</featureDescription>
-				</features>
-			</typeDescription>
+    <typeSystemDescription>
+      <typeDescription>
+        <name>org.apache.uima.TokenAnnotation</name>
+        <description>Single token annotation</description>
+        <supertypeName>uima.tcas.Annotation</supertypeName>
+        <features>
+          <featureDescription>
+            <name>tokenType</name>
+            <description>token type</description>
+            <rangeTypeName>uima.cas.String</rangeTypeName>
+          </featureDescription>
+        </features>
+      </typeDescription>
 
-			<typeDescription>
-				<name>org.apache.uima.SentenceAnnotation</name>
-				<description>sentence annotation</description>
-				<supertypeName>uima.tcas.Annotation</supertypeName>
-				<features>
+      <typeDescription>
+        <name>org.apache.uima.SentenceAnnotation</name>
+        <description>sentence annotation</description>
+        <supertypeName>uima.tcas.Annotation</supertypeName>
+        <features>
 
-				</features>
-			</typeDescription>
-		</typeSystemDescription>
+        </features>
+      </typeDescription>
+    </typeSystemDescription>
 
-		<fsIndexes />
+    <fsIndexes />
 
-		<capabilities>
-			<capability>
-				<inputs />
-				<outputs>
-					<type>org.apache.uima.TokenAnnotation</type>
-					<feature>
-						org.apache.uima.TokenAnnotation:tokentype
-					</feature>
-					<type>org.apache.uima.SentenceAnnotation</type>
-				</outputs>
-				<languagesSupported>
-					<language>x-unspecified</language>
-				</languagesSupported>
-			</capability>
-		</capabilities>
+    <capabilities>
+      <capability>
+        <inputs />
+        <outputs>
+          <type>org.apache.uima.TokenAnnotation</type>
+          <feature>
+            org.apache.uima.TokenAnnotation:tokentype
+          </feature>
+          <type>org.apache.uima.SentenceAnnotation</type>
+        </outputs>
+        <languagesSupported>
+          <language>x-unspecified</language>
+        </languagesSupported>
+      </capability>
+    </capabilities>
 
-	</analysisEngineMetaData>
+  </analysisEngineMetaData>
 </analysisEngineDescription>
 
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-HighlighterMaxOffsetTest.xml b/solr/core/src/test-files/solr/collection1/conf/schema-HighlighterMaxOffsetTest.xml
index 487c87b..d091fa0 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-HighlighterMaxOffsetTest.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-HighlighterMaxOffsetTest.xml
@@ -50,7 +50,7 @@ Test for HighlighterMaxOffsetTest which requires the use of ReversedWildcardFilt
 
 
     <!-- Just like text_general except it reverses the characters of
-	 each token, to enable more efficient leading wildcard queries. -->
+   each token, to enable more efficient leading wildcard queries. -->
     <fieldType name="text_general_rev" class="solr.TextField" positionIncrementGap="100">
       <analyzer type="index">
         <tokenizer class="solr.StandardTokenizerFactory"/>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-phrasesuggest.xml b/solr/core/src/test-files/solr/collection1/conf/schema-phrasesuggest.xml
index 9a1615f..a585502 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-phrasesuggest.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-phrasesuggest.xml
@@ -31,23 +31,23 @@
     </fieldType>
     
     <fieldType name="phrase_suggest" class="solr.TextField">
-	  <analyzer>
-	    <tokenizer class="solr.KeywordTokenizerFactory"/>
-	    <filter class="solr.PatternReplaceFilterFactory"
-	            pattern="([^\p{L}\p{M}\p{N}\p{Cs}]*[\p{L}\p{M}\p{N}\p{Cs}\_]+:)|([^\p{L}\p{M}\p{N}\p{Cs}])+"
-	            replacement=" " replace="all"/>
-	    <filter class="solr.LowerCaseFilterFactory"/>
-	    <filter class="solr.TrimFilterFactory"/>
-	  </analyzer>
-	</fieldType>
-	
-	<fieldType name="ja_suggest" class="solr.TextField">
-	  <analyzer>
-	    <tokenizer class="solr.JapaneseTokenizerFactory" mode="normal"/>
-	    <filter class="solr.CJKWidthFilterFactory"/>
-	    <filter class="solr.JapaneseReadingFormFilterFactory" useRomaji="true"/>
-	  </analyzer>
-	</fieldType>
+    <analyzer>
+      <tokenizer class="solr.KeywordTokenizerFactory"/>
+      <filter class="solr.PatternReplaceFilterFactory"
+              pattern="([^\p{L}\p{M}\p{N}\p{Cs}]*[\p{L}\p{M}\p{N}\p{Cs}\_]+:)|([^\p{L}\p{M}\p{N}\p{Cs}])+"
+              replacement=" " replace="all"/>
+      <filter class="solr.LowerCaseFilterFactory"/>
+      <filter class="solr.TrimFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  
+  <fieldType name="ja_suggest" class="solr.TextField">
+    <analyzer>
+      <tokenizer class="solr.JapaneseTokenizerFactory" mode="normal"/>
+      <filter class="solr.CJKWidthFilterFactory"/>
+      <filter class="solr.JapaneseReadingFormFilterFactory" useRomaji="true"/>
+    </analyzer>
+  </fieldType>
   </types>
 
   <fields>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-spellchecker.xml b/solr/core/src/test-files/solr/collection1/conf/schema-spellchecker.xml
index e8e0935..e145e14 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-spellchecker.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-spellchecker.xml
@@ -46,22 +46,22 @@
       </analyzer>
     </fieldType>
 
-	<fieldType name="spellText" class="solr.TextField" positionIncrementGap="100">
-	  <analyzer type="index">
-	    <tokenizer class="solr.StandardTokenizerFactory"/>
-	    <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
-	    <filter class="solr.StandardFilterFactory"/>
-	    <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
-	  </analyzer>
-	  <analyzer type="query">
-	    <tokenizer class="solr.StandardTokenizerFactory"/>
-	    <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-	    <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
-	    <filter class="solr.StandardFilterFactory"/>
-	    <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
-	  </analyzer>
-	</fieldType>
-	
+  <fieldType name="spellText" class="solr.TextField" positionIncrementGap="100">
+    <analyzer type="index">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+      <filter class="solr.StandardFilterFactory"/>
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+    <analyzer type="query">
+      <tokenizer class="solr.StandardTokenizerFactory"/>
+      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+      <filter class="solr.StandardFilterFactory"/>
+      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+    </analyzer>
+  </fieldType>
+  
  </types>
 
 
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema.xml b/solr/core/src/test-files/solr/collection1/conf/schema.xml
index 6a66cbd..50cfdf4 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema.xml
@@ -508,7 +508,7 @@
    <field name="standardfilt" type="standardfilt" indexed="true" stored="true"/>
    <field name="lowerfilt" type="lowerfilt" indexed="true" stored="true"/>
    <field name="lowerfilt1" type="lowerfilt" indexed="true" stored="true"/>
-	 <field name="lowerfilt1and2" type="lowerfilt" indexed="true" stored="true"/>
+   <field name="lowerfilt1and2" type="lowerfilt" indexed="true" stored="true"/>
    <field name="patterntok" type="patterntok" indexed="true" stored="true"/>
    <field name="patternreplacefilt" type="patternreplacefilt" indexed="true" stored="true"/>
    <field name="porterfilt" type="porterfilt" indexed="true" stored="true"/>
@@ -665,22 +665,22 @@
    <copyField source="title" dest="title_stringNoNorms"/>
 
    <copyField source="title" dest="text"/>
-	 <copyField source="subject" dest="text"/>
-
-	 <copyField source="lowerfilt1" dest="lowerfilt1and2"/>
-	 <copyField source="lowerfilt" dest="lowerfilt1and2"/>
-
-	 <copyField source="*_t" dest="text"/>
-
-	 <copyField source="id"            dest="range_facet_l"/>
-	 <copyField source="range_facet_f" dest="range_facet_d"/>
-	 <copyField source="range_facet_f1" dest="range_facet_f1_dv"/>
-	 
-	 <copyField source="id"            dest="range_facet_l_dv"/>
-	 <copyField source="id"            dest="range_facet_i_dv"/>
-	 <copyField source="range_facet_f" dest="range_facet_f_dv"/>
-	 <copyField source="range_facet_f" dest="range_facet_d_dv"/>
-	 <copyField source="bday" dest="range_facet_dt_dv"/>
+   <copyField source="subject" dest="text"/>
+
+   <copyField source="lowerfilt1" dest="lowerfilt1and2"/>
+   <copyField source="lowerfilt" dest="lowerfilt1and2"/>
+
+   <copyField source="*_t" dest="text"/>
+
+   <copyField source="id"            dest="range_facet_l"/>
+   <copyField source="range_facet_f" dest="range_facet_d"/>
+   <copyField source="range_facet_f1" dest="range_facet_f1_dv"/>
+   
+   <copyField source="id"            dest="range_facet_l_dv"/>
+   <copyField source="id"            dest="range_facet_i_dv"/>
+   <copyField source="range_facet_f" dest="range_facet_f_dv"/>
+   <copyField source="range_facet_f" dest="range_facet_d_dv"/>
+   <copyField source="bday" dest="range_facet_dt_dv"/>
 
    <!-- dynamic destination -->
    <copyField source="*_dynamic" dest="dynamic_*"/>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema11.xml b/solr/core/src/test-files/solr/collection1/conf/schema11.xml
index 7b4e130..c7867da 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema11.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema11.xml
@@ -336,46 +336,46 @@ valued. -->
         EXAMPLE:  name="*_i" will match any field ending in _i (like myid_i, z_i)
         Longer patterns will be matched first.  if equal size patterns
         both match, the first appearing in the schema will be used.  -->
-   <dynamicField name="*_s"  	type="string"  indexed="true"  stored="true"/>
+   <dynamicField name="*_s"    type="string"  indexed="true"  stored="true"/>
    <dynamicField name="*_s_dv"  type="string"  indexed="true"  stored="true" docValues="true"/>
-   <dynamicField name="*_ss"  	type="string"  indexed="true"  stored="true" multiValued="true"/>
-   <dynamicField name="*_sS" 	type="string"  indexed="false" stored="true"/>
-   <dynamicField name="*_i"  	type="int"    indexed="true"  stored="true"/>
-   <dynamicField name="*_ii" 	type="int"    indexed="true"  stored="true" multiValued="true"/>
-   <dynamicField name="*_l"  	type="long"   indexed="true"  stored="true"/>
-   <dynamicField name="*_f"  	type="float"  indexed="true"  stored="true"/>
-   <dynamicField name="*_d"  	type="double" indexed="true"  stored="true"/>
-
-   <dynamicField name="*_ti"  		type="tint"    indexed="true"  stored="true"/>
-   <dynamicField name="*_ti_dv" 	type="int"    indexed="true"  stored="true" docValues="true"/>
-   <dynamicField name="*_ti_ni_dv" 	type="int"    indexed="true"  stored="true" docValues="true"/>
-   <dynamicField name="*_tl"  		type="tlong"   indexed="true"  stored="true"/>
-   <dynamicField name="*_tl_dv"  	type="tlong"   indexed="true"  stored="true" docValues="true"/>
-   <dynamicField name="*_tl_ni_dv" 	type="tlong"   indexed="false"  stored="true" docValues="true"/>
-   <dynamicField name="*_tf"  		type="tfloat"  indexed="true"  stored="true"/>
-   <dynamicField name="*_tf_dv"  	type="tfloat"  indexed="true"  stored="true" docValues="true"/>
-   <dynamicField name="*_tf_ni_dv" 	type="tfloat"  indexed="false"  stored="true" docValues="true"/>
-   <dynamicField name="*_td"  		type="tdouble" indexed="true"  stored="true"/>
-   <dynamicField name="*_td_dv"  	type="tdouble" indexed="true"  stored="true" docValues="true"/>
-   <dynamicField name="*_td_ni_dv" 	type="tdouble" indexed="false"  stored="true" docValues="true"/>
-   <dynamicField name="*_tdt" 		type="tdate"   indexed="true"  stored="true"/>
-   <dynamicField name="*_tdt_dv" 	type="tdate"   indexed="true"  stored="true" docValues="true"/>
-   <dynamicField name="*_tdt_ni_dv"	type="tdate"   indexed="false"  stored="true" docValues="true"/>
-
-   <dynamicField name="*_tis"  		type="tints"    indexed="true"  stored="true"/>
-   <dynamicField name="*_tis_dv"  	type="tints"    indexed="true"  stored="true" docValues="true"/>
-   <dynamicField name="*_tis_ni_dv"	type="tints"    indexed="false"  stored="true" docValues="true"/>
-   <dynamicField name="*_tls"  		type="tlongs"   indexed="true"  stored="true"/>
-   <dynamicField name="*_tls_dv"  	type="tlongs"   indexed="true"  stored="true" docValues="true"/>
-   <dynamicField name="*_tls_ni_dv"	type="tlongs"   indexed="false"  stored="true" docValues="true"/>
-   <dynamicField name="*_tfs"  		type="tfloats"  indexed="true"  stored="true"/>
-   <dynamicField name="*_tfs_dv"  	type="tfloats"  indexed="true"  stored="true" docValues="true"/>
+   <dynamicField name="*_ss"    type="string"  indexed="true"  stored="true" multiValued="true"/>
+   <dynamicField name="*_sS"   type="string"  indexed="false" stored="true"/>
+   <dynamicField name="*_i"    type="int"    indexed="true"  stored="true"/>
+   <dynamicField name="*_ii"   type="int"    indexed="true"  stored="true" multiValued="true"/>
+   <dynamicField name="*_l"    type="long"   indexed="true"  stored="true"/>
+   <dynamicField name="*_f"    type="float"  indexed="true"  stored="true"/>
+   <dynamicField name="*_d"    type="double" indexed="true"  stored="true"/>
+
+   <dynamicField name="*_ti"      type="tint"    indexed="true"  stored="true"/>
+   <dynamicField name="*_ti_dv"   type="int"    indexed="true"  stored="true" docValues="true"/>
+   <dynamicField name="*_ti_ni_dv"   type="int"    indexed="true"  stored="true" docValues="true"/>
+   <dynamicField name="*_tl"      type="tlong"   indexed="true"  stored="true"/>
+   <dynamicField name="*_tl_dv"    type="tlong"   indexed="true"  stored="true" docValues="true"/>
+   <dynamicField name="*_tl_ni_dv"   type="tlong"   indexed="false"  stored="true" docValues="true"/>
+   <dynamicField name="*_tf"      type="tfloat"  indexed="true"  stored="true"/>
+   <dynamicField name="*_tf_dv"    type="tfloat"  indexed="true"  stored="true" docValues="true"/>
+   <dynamicField name="*_tf_ni_dv"   type="tfloat"  indexed="false"  stored="true" docValues="true"/>
+   <dynamicField name="*_td"      type="tdouble" indexed="true"  stored="true"/>
+   <dynamicField name="*_td_dv"    type="tdouble" indexed="true"  stored="true" docValues="true"/>
+   <dynamicField name="*_td_ni_dv"   type="tdouble" indexed="false"  stored="true" docValues="true"/>
+   <dynamicField name="*_tdt"     type="tdate"   indexed="true"  stored="true"/>
+   <dynamicField name="*_tdt_dv"   type="tdate"   indexed="true"  stored="true" docValues="true"/>
+   <dynamicField name="*_tdt_ni_dv"  type="tdate"   indexed="false"  stored="true" docValues="true"/>
+
+   <dynamicField name="*_tis"      type="tints"    indexed="true"  stored="true"/>
+   <dynamicField name="*_tis_dv"    type="tints"    indexed="true"  stored="true" docValues="true"/>
+   <dynamicField name="*_tis_ni_dv"  type="tints"    indexed="false"  stored="true" docValues="true"/>
+   <dynamicField name="*_tls"      type="tlongs"   indexed="true"  stored="true"/>
+   <dynamicField name="*_tls_dv"    type="tlongs"   indexed="true"  stored="true" docValues="true"/>
+   <dynamicField name="*_tls_ni_dv"  type="tlongs"   indexed="false"  stored="true" docValues="true"/>
+   <dynamicField name="*_tfs"      type="tfloats"  indexed="true"  stored="true"/>
+   <dynamicField name="*_tfs_dv"    type="tfloats"  indexed="true"  stored="true" docValues="true"/>
    <dynamicField name="*_tfs_ni_dv" type="tfloats"  indexed="false"  stored="true" docValues="true"/>
-   <dynamicField name="*_tds"  		type="tdoubles" indexed="true"  stored="true"/>
-   <dynamicField name="*_tds_dv"  	type="tdoubles" indexed="true"  stored="true" docValues="true"/>
+   <dynamicField name="*_tds"      type="tdoubles" indexed="true"  stored="true"/>
+   <dynamicField name="*_tds_dv"    type="tdoubles" indexed="true"  stored="true" docValues="true"/>
    <dynamicField name="*_tds_ni_dv" type="tdoubles" indexed="false"  stored="true" docValues="true"/>
-   <dynamicField name="*_tdts" 		type="tdates"   indexed="true"  stored="true"/>
-   <dynamicField name="*_tdts_dv" 	type="tdates"   indexed="true"  stored="true" docValues="true"/>
+   <dynamicField name="*_tdts"     type="tdates"   indexed="true"  stored="true"/>
+   <dynamicField name="*_tdts_dv"   type="tdates"   indexed="true"  stored="true" docValues="true"/>
    <dynamicField name="*_tdts_ni_dv" type="tdates"   indexed="false"  stored="true" docValues="true"/>
 
    <dynamicField name="*_t"  type="text"    indexed="true"  stored="true"/>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema_latest.xml b/solr/core/src/test-files/solr/collection1/conf/schema_latest.xml
index 527b6f3..7cb8c9e 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema_latest.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema_latest.xml
@@ -310,12 +310,12 @@
 
    <!-- Create a string version of author for faceting -->
    <copyField source="author" dest="author_s"/>
-	
+  
    <!-- Above, multiple source fields are copied to the [text] field. 
-	  Another way to map multiple source fields to the same 
-	  destination field is to use the dynamic field syntax. 
-	  copyField also supports a maxChars to copy setting.  -->
-	   
+    Another way to map multiple source fields to the same 
+    destination field is to use the dynamic field syntax. 
+    copyField also supports a maxChars to copy setting.  -->
+     
    <!-- <copyField source="*_t" dest="text" maxChars="3000"/> -->
 
    <!-- copy name to alphaNameSort, a field designed for sorting by name -->
@@ -342,8 +342,8 @@
     <!-- sortMissingLast and sortMissingFirst attributes are optional attributes are
          currently supported on types that are sorted internally as strings
          and on numeric types.
-	     This includes "string","boolean", and, as of 3.5 (and 4.x),
-	     int, float, long, date, double, including the "Trie" variants.
+       This includes "string","boolean", and, as of 3.5 (and 4.x),
+       int, float, long, date, double, including the "Trie" variants.
        - If sortMissingLast="true", then a sort on this field will cause documents
          without the field to come after documents with the field,
          regardless of the requested sort order (asc or desc).
@@ -454,9 +454,9 @@
 
     <!-- A general text field that has reasonable, generic
          cross-language defaults: it tokenizes with StandardTokenizer,
-	 removes stop words from case-insensitive "stopwords.txt"
-	 (empty by default), and down cases.  At query time only, it
-	 also applies synonyms. -->
+   removes stop words from case-insensitive "stopwords.txt"
+   (empty by default), and down cases.  At query time only, it
+   also applies synonyms. -->
     <fieldType name="text_general" class="solr.TextField" positionIncrementGap="100">
       <analyzer type="index">
         <tokenizer class="solr.StandardTokenizerFactory"/>
@@ -492,11 +492,11 @@
                 words="stopwords.txt"
                 />
         <filter class="solr.LowerCaseFilterFactory"/>
-	<filter class="solr.EnglishPossessiveFilterFactory"/>
+  <filter class="solr.EnglishPossessiveFilterFactory"/>
         <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-	<!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
         <filter class="solr.EnglishMinimalStemFilterFactory"/>
-	-->
+  -->
         <filter class="solr.PorterStemFilterFactory"/>
       </analyzer>
       <analyzer type="query">
@@ -507,23 +507,23 @@
                 words="stopwords.txt"
                 />
         <filter class="solr.LowerCaseFilterFactory"/>
-	<filter class="solr.EnglishPossessiveFilterFactory"/>
+  <filter class="solr.EnglishPossessiveFilterFactory"/>
         <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-	<!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
         <filter class="solr.EnglishMinimalStemFilterFactory"/>
-	-->
+  -->
         <filter class="solr.PorterStemFilterFactory"/>
       </analyzer>
     </fieldType>
 
     <!-- A text field with defaults appropriate for English, plus
-	 aggressive word-splitting and autophrase features enabled.
-	 This field is just like text_en, except it adds
-	 WordDelimiterFilter to enable splitting and matching of
-	 words on case-change, alpha numeric boundaries, and
-	 non-alphanumeric chars.  This means certain compound word
-	 cases will work, for example query "wi fi" will match
-	 document "WiFi" or "wi-fi".
+   aggressive word-splitting and autophrase features enabled.
+   This field is just like text_en, except it adds
+   WordDelimiterFilter to enable splitting and matching of
+   words on case-change, alpha numeric boundaries, and
+   non-alphanumeric chars.  This means certain compound word
+   cases will work, for example query "wi fi" will match
+   document "WiFi" or "wi-fi".
         -->
     <fieldType name="text_en_splitting" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true">
       <analyzer type="index">
@@ -574,7 +574,7 @@
     </fieldType>
 
     <!-- Just like text_general except it reverses the characters of
-	 each token, to enable more efficient leading wildcard queries. -->
+   each token, to enable more efficient leading wildcard queries. -->
     <fieldType name="text_general_rev" class="solr.TextField" positionIncrementGap="100">
       <analyzer type="index">
         <tokenizer class="solr.StandardTokenizerFactory"/>
@@ -649,10 +649,10 @@
         a token of "foo|1.4"  would be indexed as "foo" with a payload of 1.4f
         Attributes of the DelimitedPayloadTokenFilterFactory : 
          "delimiter" - a one character delimiter. Default is | (pipe)
-	 "encoder" - how to encode the following value into a playload
-	    float -> org.apache.lucene.analysis.payloads.FloatEncoder,
-	    integer -> o.a.l.a.p.IntegerEncoder
-	    identity -> o.a.l.a.p.IdentityEncoder
+   "encoder" - how to encode the following value into a playload
+      float -> org.apache.lucene.analysis.payloads.FloatEncoder,
+      integer -> o.a.l.a.p.IntegerEncoder
+      identity -> o.a.l.a.p.IdentityEncoder
             Fully Qualified class name implementing PayloadEncoder, Encoder must have a no arg constructor.
          -->
         <filter class="solr.DelimitedPayloadTokenFilterFactory" encoder="float"/>
@@ -673,10 +673,10 @@
     -->
     <fieldType name="descendent_path" class="solr.TextField">
       <analyzer type="index">
-	<tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
+  <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
       </analyzer>
       <analyzer type="query">
-	<tokenizer class="solr.KeywordTokenizerFactory" />
+  <tokenizer class="solr.KeywordTokenizerFactory" />
       </analyzer>
     </fieldType>
     <!-- 
@@ -685,10 +685,10 @@
     -->
     <fieldType name="ancestor_path" class="solr.TextField">
       <analyzer type="index">
-	<tokenizer class="solr.KeywordTokenizerFactory" />
+  <tokenizer class="solr.KeywordTokenizerFactory" />
       </analyzer>
       <analyzer type="query">
-	<tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
+  <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
       </analyzer>
     </fieldType>
 
diff --git a/solr/core/src/test-files/solr/collection1/conf/solrconfig-components-name.xml b/solr/core/src/test-files/solr/collection1/conf/solrconfig-components-name.xml
index cdd3c5d..89f5426 100644
--- a/solr/core/src/test-files/solr/collection1/conf/solrconfig-components-name.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/solrconfig-components-name.xml
@@ -41,8 +41,8 @@
                        class="solr.XMLResponseWriter" />
 
   <requestHandler name="standard" class="solr.StandardRequestHandler">
-  	<bool name="httpCaching">true</bool>
-  	<arr name="first-components">
+    <bool name="httpCaching">true</bool>
+    <arr name="first-components">
       <str>component1</str>
     </arr>
     <arr name="last-components">
diff --git a/solr/core/src/test-files/solr/collection1/conf/solrconfig-delpolicy2.xml b/solr/core/src/test-files/solr/collection1/conf/solrconfig-delpolicy2.xml
index 985c4c1..69735d9 100644
--- a/solr/core/src/test-files/solr/collection1/conf/solrconfig-delpolicy2.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/solrconfig-delpolicy2.xml
@@ -38,8 +38,8 @@
 
     <deletionPolicy class="org.apache.solr.core.FakeDeletionPolicy">
       <str name="var1">value1</str>
-		  <str name="var2">value2</str>
-	  </deletionPolicy>
+      <str name="var2">value2</str>
+    </deletionPolicy>
   </indexConfig>
 
   <requestHandler name="standard" class="solr.StandardRequestHandler"></requestHandler>
diff --git a/solr/core/src/test-files/solr/collection1/conf/solrconfig-headers.xml b/solr/core/src/test-files/solr/collection1/conf/solrconfig-headers.xml
index eb67ef1..4ff8e6e 100644
--- a/solr/core/src/test-files/solr/collection1/conf/solrconfig-headers.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/solrconfig-headers.xml
@@ -24,8 +24,8 @@
   <directoryFactory name="DirectoryFactory" class="${solr.directoryFactory:solr.RAMDirectoryFactory}"/>
   <searchComponent name="componentThatAddsHeader" class="org.apache.solr.servlet.ResponseHeaderTest$ComponentThatAddsHeader"/>
   <requestHandler name="/withHeaders" class="solr.StandardRequestHandler">
-	  <arr name="first-components">
-	  	<str>componentThatAddsHeader</str>
-	  </arr>
+    <arr name="first-components">
+      <str>componentThatAddsHeader</str>
+    </arr>
   </requestHandler>
 </config>
diff --git a/solr/core/src/test-files/solr/collection1/conf/solrconfig-nocache-with-delaying-searchcomponent.xml b/solr/core/src/test-files/solr/collection1/conf/solrconfig-nocache-with-delaying-searchcomponent.xml
index 6523d73..ea10c4a 100644
--- a/solr/core/src/test-files/solr/collection1/conf/solrconfig-nocache-with-delaying-searchcomponent.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/solrconfig-nocache-with-delaying-searchcomponent.xml
@@ -27,9 +27,9 @@
                    class="org.apache.solr.search.DelayingSearchComponent"/>
 
   <requestHandler name="/select" class="solr.SearchHandler">
-	  <arr name="first-components">
-	  	<str>delayingSearchComponent</str>
-	  </arr>
+    <arr name="first-components">
+      <str>delayingSearchComponent</str>
+    </arr>
   </requestHandler>
 
   <requestDispatcher handleSelect="true" >
diff --git a/solr/core/src/test-files/solr/collection1/conf/solrconfig-phrasesuggest.xml b/solr/core/src/test-files/solr/collection1/conf/solrconfig-phrasesuggest.xml
index 706e3c4..043d5f7 100644
--- a/solr/core/src/test-files/solr/collection1/conf/solrconfig-phrasesuggest.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/solrconfig-phrasesuggest.xml
@@ -150,7 +150,7 @@
       <!-- Suggester properties -->
       <str name="separator"> </str>
       <str name="suggestFreeTextAnalyzerFieldType">text</str>
-	  <int name="ngrams">2</int>
+    <int name="ngrams">2</int>
     </lst>
     
   </searchComponent>
diff --git a/solr/core/src/test-files/solr/collection1/conf/solrconfig-response-log-component.xml b/solr/core/src/test-files/solr/collection1/conf/solrconfig-response-log-component.xml
index cfb3a69..62b2d7c 100644
--- a/solr/core/src/test-files/solr/collection1/conf/solrconfig-response-log-component.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/solrconfig-response-log-component.xml
@@ -37,9 +37,9 @@
 
   <!-- Log retrievedDocs -->
   <requestHandler name="withlog" class="org.apache.solr.handler.component.SearchHandler">
-	<lst name="defaults">
-		<str name="defType">dismax</str>
-	</lst>
+  <lst name="defaults">
+    <str name="defType">dismax</str>
+  </lst>
     <arr name="last-components">
       <str>responselog</str>
     </arr>
diff --git a/solr/core/src/test-files/solr/collection1/conf/solrconfig-slave.xml b/solr/core/src/test-files/solr/collection1/conf/solrconfig-slave.xml
index 1782c54..06d0431 100644
--- a/solr/core/src/test-files/solr/collection1/conf/solrconfig-slave.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/solrconfig-slave.xml
@@ -41,9 +41,9 @@
   </requestHandler>
 
   <requestHandler name="/replication" class="solr.ReplicationHandler">
-	<lst name="slave">
-		<str name="masterUrl">http://127.0.0.1:TEST_PORT/solr/collection1</str>
-		<str name="pollInterval">00:00:01</str>
+  <lst name="slave">
+    <str name="masterUrl">http://127.0.0.1:TEST_PORT/solr/collection1</str>
+    <str name="pollInterval">00:00:01</str>
         <str name="compression">COMPRESSION</str>
      </lst>
   </requestHandler>
diff --git a/solr/core/src/test-files/solr/collection1/conf/solrconfig-spellcheckcomponent.xml b/solr/core/src/test-files/solr/collection1/conf/solrconfig-spellcheckcomponent.xml
index 24cef76..58452c6 100644
--- a/solr/core/src/test-files/solr/collection1/conf/solrconfig-spellcheckcomponent.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/solrconfig-spellcheckcomponent.xml
@@ -88,11 +88,11 @@
       <float name="thresholdTokenFrequency">.29</float>
     </lst>
     <lst name="spellchecker">
-			<str name="name">multipleFields</str>
-			<str name="field">lowerfilt1and2</str>
-			<str name="spellcheckIndexDir">spellcheckerMultipleFields</str>
-			<str name="buildOnCommit">true</str>
-   	</lst>
+      <str name="name">multipleFields</str>
+      <str name="field">lowerfilt1and2</str>
+      <str name="spellcheckIndexDir">spellcheckerMultipleFields</str>
+      <str name="buildOnCommit">true</str>
+     </lst>
     <!-- Example of using different distance measure -->
     <lst name="spellchecker">
       <str name="name">jarowinkler</str>
@@ -156,13 +156,13 @@
     </arr>
   </requestHandler>
   <requestHandler name="spellCheckCompRH1" class="org.apache.solr.handler.component.SearchHandler">
-			<lst name="defaults">
-				<str name="defType">dismax</str>
-				<str name="qf">lowerfilt1^1</str>
-			</lst>
-			<arr name="last-components">
-				<str>spellcheck</str>
-			</arr>
+      <lst name="defaults">
+        <str name="defType">dismax</str>
+        <str name="qf">lowerfilt1^1</str>
+      </lst>
+      <arr name="last-components">
+        <str>spellcheck</str>
+      </arr>
  </requestHandler>
  <requestHandler name="spellCheckWithWordbreak" class="org.apache.solr.handler.component.SearchHandler">
     <lst name="defaults">
diff --git a/solr/core/src/test-files/solr/collection1/conf/solrconfig-suggestercomponent.xml b/solr/core/src/test-files/solr/collection1/conf/solrconfig-suggestercomponent.xml
index a26cb46..79e53d3 100644
--- a/solr/core/src/test-files/solr/collection1/conf/solrconfig-suggestercomponent.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/solrconfig-suggestercomponent.xml
@@ -31,7 +31,7 @@
 
   <searchComponent class="solr.SuggestComponent" name="suggest">
     
-  	<!-- Suggest component (default index based dictionary) -->
+    <!-- Suggest component (default index based dictionary) -->
     <lst name="suggester">
       <str name="name">suggest_fuzzy_with_high_freq_dict</str>
       <str name="lookupImpl">FuzzyLookupFactory</str>
@@ -42,8 +42,8 @@
 
       <float name="threshold">0.0</float>
     </lst>
-	
-	<!-- Suggest component (default file based dictionary) -->
+  
+  <!-- Suggest component (default file based dictionary) -->
     <lst name="suggester">
       <str name="name">suggest_fuzzy_file_based</str>
       <str name="lookupImpl">FuzzyLookupFactory</str>
@@ -53,7 +53,7 @@
       <str name="buildOnCommit">true</str>
     </lst>
 
-	<!-- Suggest component (Document Dictionary) -->
+  <!-- Suggest component (Document Dictionary) -->
     <lst name="suggester">
       <str name="name">suggest_fuzzy_doc_dict</str>
       <str name="lookupImpl">FuzzyLookupFactory</str>
@@ -65,7 +65,7 @@
       <str name="buildOnStartup">false</str>
     </lst>
 
-	<!-- Suggest component (Document Expression Dictionary) -->
+  <!-- Suggest component (Document Expression Dictionary) -->
     <lst name="suggester">
       <str name="name">suggest_fuzzy_doc_expr_dict</str>
       <str name="dictionaryImpl">DocumentExpressionDictionaryFactory</str>
diff --git a/solr/core/src/test-files/solr/collection1/conf/solrconfig-tolerant-search.xml b/solr/core/src/test-files/solr/collection1/conf/solrconfig-tolerant-search.xml
index f733be4..4044849 100644
--- a/solr/core/src/test-files/solr/collection1/conf/solrconfig-tolerant-search.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/solrconfig-tolerant-search.xml
@@ -1,52 +1,52 @@
 <?xml version="1.0" ?>
 
 <!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor 
-	license agreements. See the NOTICE file distributed with this work for additional 
-	information regarding copyright ownership. The ASF licenses this file to 
-	You under the Apache License, Version 2.0 (the "License"); you may not use 
-	this file except in compliance with the License. You may obtain a copy of 
-	the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required 
-	by applicable law or agreed to in writing, software distributed under the 
-	License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS 
-	OF ANY KIND, either express or implied. See the License for the specific 
-	language governing permissions and limitations under the License. -->
+  license agreements. See the NOTICE file distributed with this work for additional 
+  information regarding copyright ownership. The ASF licenses this file to 
+  You under the Apache License, Version 2.0 (the "License"); you may not use 
+  this file except in compliance with the License. You may obtain a copy of 
+  the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required 
+  by applicable law or agreed to in writing, software distributed under the 
+  License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS 
+  OF ANY KIND, either express or implied. See the License for the specific 
+  language governing permissions and limitations under the License. -->
 
 <!-- This is a "kitchen sink" config file that tests can use. When writting 
-	a new test, feel free to add *new* items (plugins, config options, etc...) 
-	as long as they don't break any existing tests. if you need to test something 
-	esoteric please add a new "solrconfig-your-esoteric-purpose.xml" config file. 
-	Note in particular that this test is used by MinimalSchemaTest so Anything 
-	added to this file needs to work correctly even if there is now uniqueKey 
-	or defaultSearch Field. -->
+  a new test, feel free to add *new* items (plugins, config options, etc...) 
+  as long as they don't break any existing tests. if you need to test something 
+  esoteric please add a new "solrconfig-your-esoteric-purpose.xml" config file. 
+  Note in particular that this test is used by MinimalSchemaTest so Anything 
+  added to this file needs to work correctly even if there is now uniqueKey 
+  or defaultSearch Field. -->
 
 <config>
 
-	<dataDir>${solr.data.dir:}</dataDir>
+  <dataDir>${solr.data.dir:}</dataDir>
 
-	<directoryFactory name="DirectoryFactory"
-		class="${solr.directoryFactory:solr.NRTCachingDirectoryFactory}" />
+  <directoryFactory name="DirectoryFactory"
+    class="${solr.directoryFactory:solr.NRTCachingDirectoryFactory}" />
 
-	<luceneMatchVersion>${tests.luceneMatchVersion:LATEST}</luceneMatchVersion>
+  <luceneMatchVersion>${tests.luceneMatchVersion:LATEST}</luceneMatchVersion>
 
-	<xi:include href="solrconfig.snippet.randomindexconfig.xml"
-		xmlns:xi="http://www.w3.org/2001/XInclude" />
+  <xi:include href="solrconfig.snippet.randomindexconfig.xml"
+    xmlns:xi="http://www.w3.org/2001/XInclude" />
 
-	<updateHandler class="solr.DirectUpdateHandler2">
-		<commitWithin>
-			<softCommit>${solr.commitwithin.softcommit:true}</softCommit>
-		</commitWithin>
+  <updateHandler class="solr.DirectUpdateHandler2">
+    <commitWithin>
+      <softCommit>${solr.commitwithin.softcommit:true}</softCommit>
+    </commitWithin>
 
-	</updateHandler>
-	<requestHandler name="/select" class="solr.SearchHandler">
-		<lst name="defaults">
-			<str name="echoParams">explicit</str>
-			<str name="indent">true</str>
-			<str name="df">text</str>
-		</lst>
+  </updateHandler>
+  <requestHandler name="/select" class="solr.SearchHandler">
+    <lst name="defaults">
+      <str name="echoParams">explicit</str>
+      <str name="indent">true</str>
+      <str name="df">text</str>
+    </lst>
 
-	</requestHandler>
-	
-	<queryResponseWriter name="javabin"
+  </requestHandler>
+  
+  <queryResponseWriter name="javabin"
                        class="solr.TestTolerantSearch$BadResponseWriter" />
 </config>
 
diff --git a/solr/core/src/test-files/solr/collection1/conf/solrconfig.xml b/solr/core/src/test-files/solr/collection1/conf/solrconfig.xml
index ec12c31..866c1ab 100644
--- a/solr/core/src/test-files/solr/collection1/conf/solrconfig.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/solrconfig.xml
@@ -83,7 +83,7 @@
     -->
     
     <updateLog enable="${enable.update.log:true}">
-  	  <str name="dir">${solr.ulog.dir:}</str>
+      <str name="dir">${solr.ulog.dir:}</str>
     </updateLog> 
     
     <commitWithin>
@@ -198,7 +198,7 @@
      is not specified in the request.
   -->
   <requestHandler name="standard" class="solr.StandardRequestHandler">
-  	<bool name="httpCaching">true</bool>
+    <bool name="httpCaching">true</bool>
   </requestHandler>
 
   <requestHandler name="dismax" class="solr.SearchHandler" >
@@ -269,11 +269,11 @@
       <int name="maxChanges">10</int>
     </lst>
     <lst name="spellchecker">
-			<str name="name">multipleFields</str>
-			<str name="field">lowerfilt1and2</str>
-			<str name="spellcheckIndexDir">spellcheckerMultipleFields</str>
-			<str name="buildOnCommit">false</str>
-   	</lst>
+      <str name="name">multipleFields</str>
+      <str name="field">lowerfilt1and2</str>
+      <str name="spellcheckIndexDir">spellcheckerMultipleFields</str>
+      <str name="buildOnCommit">false</str>
+     </lst>
     <!-- Example of using different distance measure -->
     <lst name="spellchecker">
       <str name="name">jarowinkler</str>
@@ -377,13 +377,13 @@
     </arr>
   </requestHandler>
   <requestHandler name="spellCheckCompRH1" class="org.apache.solr.handler.component.SearchHandler">
-			<lst name="defaults">
-				<str name="defType">dismax</str>
-				<str name="qf">lowerfilt1^1</str>
-			</lst>
-			<arr name="last-components">
-				<str>spellcheck</str>
-			</arr>
+      <lst name="defaults">
+        <str name="defType">dismax</str>
+        <str name="qf">lowerfilt1^1</str>
+      </lst>
+      <arr name="last-components">
+        <str>spellcheck</str>
+      </arr>
  </requestHandler>
  
   <requestHandler name="mltrh" class="org.apache.solr.handler.component.SearchHandler">
diff --git a/solr/example/example-DIH/solr/db/conf/schema.xml b/solr/example/example-DIH/solr/db/conf/schema.xml
index d407c5d..37e37b9 100644
--- a/solr/example/example-DIH/solr/db/conf/schema.xml
+++ b/solr/example/example-DIH/solr/db/conf/schema.xml
@@ -292,9 +292,9 @@
    <copyField source="author" dest="author_s"/>
 
    <!-- Above, multiple source fields are copied to the [text] field.
-	  Another way to map multiple source fields to the same
-	  destination field is to use the dynamic field syntax.
-	  copyField also supports a maxChars to copy setting.  -->
+    Another way to map multiple source fields to the same
+    destination field is to use the dynamic field syntax.
+    copyField also supports a maxChars to copy setting.  -->
 
    <!-- <copyField source="*_t" dest="text" maxChars="3000"/> -->
 
@@ -322,8 +322,8 @@
     <!-- sortMissingLast and sortMissingFirst attributes are optional attributes are
          currently supported on types that are sorted internally as strings
          and on numeric types.
-	     This includes "string","boolean", and, as of 3.5 (and 4.x),
-	     int, float, long, date, double, including the "Trie" variants.
+       This includes "string","boolean", and, as of 3.5 (and 4.x),
+       int, float, long, date, double, including the "Trie" variants.
        - If sortMissingLast="true", then a sort on this field will cause documents
          without the field to come after documents with the field,
          regardless of the requested sort order (asc or desc).
@@ -434,9 +434,9 @@
 
     <!-- A general text field that has reasonable, generic
          cross-language defaults: it tokenizes with StandardTokenizer,
-	 removes stop words from case-insensitive "stopwords.txt"
-	 (empty by default), and down cases.  At query time only, it
-	 also applies synonyms. -->
+   removes stop words from case-insensitive "stopwords.txt"
+   (empty by default), and down cases.  At query time only, it
+   also applies synonyms. -->
     <fieldType name="text_general" class="solr.TextField" positionIncrementGap="100">
       <analyzer type="index">
         <tokenizer class="solr.StandardTokenizerFactory"/>
@@ -472,11 +472,11 @@
                 words="lang/stopwords_en.txt"
                 />
         <filter class="solr.LowerCaseFilterFactory"/>
-	<filter class="solr.EnglishPossessiveFilterFactory"/>
+  <filter class="solr.EnglishPossessiveFilterFactory"/>
         <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-	<!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
         <filter class="solr.EnglishMinimalStemFilterFactory"/>
-	-->
+  -->
         <filter class="solr.PorterStemFilterFactory"/>
       </analyzer>
       <analyzer type="query">
@@ -487,23 +487,23 @@
                 words="lang/stopwords_en.txt"
                 />
         <filter class="solr.LowerCaseFilterFactory"/>
-	<filter class="solr.EnglishPossessiveFilterFactory"/>
+  <filter class="solr.EnglishPossessiveFilterFactory"/>
         <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-	<!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
         <filter class="solr.EnglishMinimalStemFilterFactory"/>
-	-->
+  -->
         <filter class="solr.PorterStemFilterFactory"/>
       </analyzer>
     </fieldType>
 
     <!-- A text field with defaults appropriate for English, plus
-	 aggressive word-splitting and autophrase features enabled.
-	 This field is just like text_en, except it adds
-	 WordDelimiterFilter to enable splitting and matching of
-	 words on case-change, alpha numeric boundaries, and
-	 non-alphanumeric chars.  This means certain compound word
-	 cases will work, for example query "wi fi" will match
-	 document "WiFi" or "wi-fi".
+   aggressive word-splitting and autophrase features enabled.
+   This field is just like text_en, except it adds
+   WordDelimiterFilter to enable splitting and matching of
+   words on case-change, alpha numeric boundaries, and
+   non-alphanumeric chars.  This means certain compound word
+   cases will work, for example query "wi fi" will match
+   document "WiFi" or "wi-fi".
         -->
     <fieldType name="text_en_splitting" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true">
       <analyzer type="index">
@@ -554,7 +554,7 @@
     </fieldType>
 
     <!-- Just like text_general except it reverses the characters of
-	 each token, to enable more efficient leading wildcard queries. -->
+   each token, to enable more efficient leading wildcard queries. -->
     <fieldType name="text_general_rev" class="solr.TextField" positionIncrementGap="100">
       <analyzer type="index">
         <tokenizer class="solr.StandardTokenizerFactory"/>
@@ -629,10 +629,10 @@
         a token of "foo|1.4"  would be indexed as "foo" with a payload of 1.4f
         Attributes of the DelimitedPayloadTokenFilterFactory : 
          "delimiter" - a one character delimiter. Default is | (pipe)
-	 "encoder" - how to encode the following value into a playload
-	    float -> org.apache.lucene.analysis.payloads.FloatEncoder,
-	    integer -> o.a.l.a.p.IntegerEncoder
-	    identity -> o.a.l.a.p.IdentityEncoder
+   "encoder" - how to encode the following value into a playload
+      float -> org.apache.lucene.analysis.payloads.FloatEncoder,
+      integer -> o.a.l.a.p.IntegerEncoder
+      identity -> o.a.l.a.p.IdentityEncoder
             Fully Qualified class name implementing PayloadEncoder, Encoder must have a no arg constructor.
          -->
         <filter class="solr.DelimitedPayloadTokenFilterFactory" encoder="float"/>
@@ -653,10 +653,10 @@
     -->
     <fieldType name="descendent_path" class="solr.TextField">
       <analyzer type="index">
-	<tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
+  <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
       </analyzer>
       <analyzer type="query">
-	<tokenizer class="solr.KeywordTokenizerFactory" />
+  <tokenizer class="solr.KeywordTokenizerFactory" />
       </analyzer>
     </fieldType>
     <!-- 
@@ -665,10 +665,10 @@
     -->
     <fieldType name="ancestor_path" class="solr.TextField">
       <analyzer type="index">
-	<tokenizer class="solr.KeywordTokenizerFactory" />
+  <tokenizer class="solr.KeywordTokenizerFactory" />
       </analyzer>
       <analyzer type="query">
-	<tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
+  <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
       </analyzer>
     </fieldType>
 
diff --git a/solr/example/example-DIH/solr/db/conf/solrconfig.xml b/solr/example/example-DIH/solr/db/conf/solrconfig.xml
index 9eacda9..4aaca4f 100644
--- a/solr/example/example-DIH/solr/db/conf/solrconfig.xml
+++ b/solr/example/example-DIH/solr/db/conf/solrconfig.xml
@@ -1066,7 +1066,7 @@
       <!-- maximum threshold of documents a query term can appear to be considered for correction -->
       <float name="maxQueryFrequency">0.01</float>
       <!-- uncomment this to require suggestions to occur in 1% of the documents
-      	<float name="thresholdTokenFrequency">.01</float>
+        <float name="thresholdTokenFrequency">.01</float>
       -->
     </lst>
     
@@ -1157,7 +1157,7 @@
   </requestHandler>
 
   <searchComponent name="suggest" class="solr.SuggestComponent">
-  	<lst name="suggester">
+    <lst name="suggester">
       <str name="name">mySuggester</str>
       <str name="lookupImpl">FuzzyLookupFactory</str>      <!-- org.apache.solr.spelling.suggest.fst -->
       <str name="dictionaryImpl">DocumentDictionaryFactory</str>     <!-- org.apache.solr.spelling.suggest.HighFrequencyDictionaryFactory --> 
diff --git a/solr/example/example-DIH/solr/mail/conf/schema.xml b/solr/example/example-DIH/solr/mail/conf/schema.xml
index d5c3b82..859d7bb 100644
--- a/solr/example/example-DIH/solr/mail/conf/schema.xml
+++ b/solr/example/example-DIH/solr/mail/conf/schema.xml
@@ -211,10 +211,10 @@
     <copyField source="allTo" dest="text"/>
 
    <!-- Above, multiple source fields are copied to the [text] field. 
-	  Another way to map multiple source fields to the same 
-	  destination field is to use the dynamic field syntax. 
-	  copyField also supports a maxChars to copy setting.  -->
-	   
+    Another way to map multiple source fields to the same 
+    destination field is to use the dynamic field syntax. 
+    copyField also supports a maxChars to copy setting.  -->
+     
    <!-- <copyField source="*_t" dest="text" maxChars="3000"/> -->
 
    <!-- copy name to alphaNameSort, a field designed for sorting by name -->
@@ -241,8 +241,8 @@
     <!-- sortMissingLast and sortMissingFirst attributes are optional attributes are
          currently supported on types that are sorted internally as strings
          and on numeric types.
-	     This includes "string","boolean", and, as of 3.5 (and 4.x),
-	     int, float, long, date, double, including the "Trie" variants.
+       This includes "string","boolean", and, as of 3.5 (and 4.x),
+       int, float, long, date, double, including the "Trie" variants.
        - If sortMissingLast="true", then a sort on this field will cause documents
          without the field to come after documents with the field,
          regardless of the requested sort order (asc or desc).
@@ -353,9 +353,9 @@
 
     <!-- A general text field that has reasonable, generic
          cross-language defaults: it tokenizes with StandardTokenizer,
-	 removes stop words from case-insensitive "stopwords.txt"
-	 (empty by default), and down cases.  At query time only, it
-	 also applies synonyms. -->
+   removes stop words from case-insensitive "stopwords.txt"
+   (empty by default), and down cases.  At query time only, it
+   also applies synonyms. -->
     <fieldType name="text_general" class="solr.TextField" positionIncrementGap="100">
       <analyzer type="index">
         <tokenizer class="solr.StandardTokenizerFactory"/>
@@ -391,11 +391,11 @@
                 words="lang/stopwords_en.txt"
                 />
         <filter class="solr.LowerCaseFilterFactory"/>
-	<filter class="solr.EnglishPossessiveFilterFactory"/>
+  <filter class="solr.EnglishPossessiveFilterFactory"/>
         <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-	<!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
         <filter class="solr.EnglishMinimalStemFilterFactory"/>
-	-->
+  -->
         <filter class="solr.PorterStemFilterFactory"/>
       </analyzer>
       <analyzer type="query">
@@ -406,23 +406,23 @@
                 words="lang/stopwords_en.txt"
                 />
         <filter class="solr.LowerCaseFilterFactory"/>
-	<filter class="solr.EnglishPossessiveFilterFactory"/>
+  <filter class="solr.EnglishPossessiveFilterFactory"/>
         <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-	<!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
         <filter class="solr.EnglishMinimalStemFilterFactory"/>
-	-->
+  -->
         <filter class="solr.PorterStemFilterFactory"/>
       </analyzer>
     </fieldType>
 
     <!-- A text field with defaults appropriate for English, plus
-	 aggressive word-splitting and autophrase features enabled.
-	 This field is just like text_en, except it adds
-	 WordDelimiterFilter to enable splitting and matching of
-	 words on case-change, alpha numeric boundaries, and
-	 non-alphanumeric chars.  This means certain compound word
-	 cases will work, for example query "wi fi" will match
-	 document "WiFi" or "wi-fi".
+   aggressive word-splitting and autophrase features enabled.
+   This field is just like text_en, except it adds
+   WordDelimiterFilter to enable splitting and matching of
+   words on case-change, alpha numeric boundaries, and
+   non-alphanumeric chars.  This means certain compound word
+   cases will work, for example query "wi fi" will match
+   document "WiFi" or "wi-fi".
         -->
     <fieldType name="text_en_splitting" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true">
       <analyzer type="index">
@@ -473,7 +473,7 @@
     </fieldType>
 
     <!-- Just like text_general except it reverses the characters of
-	 each token, to enable more efficient leading wildcard queries. -->
+   each token, to enable more efficient leading wildcard queries. -->
     <fieldType name="text_general_rev" class="solr.TextField" positionIncrementGap="100">
       <analyzer type="index">
         <tokenizer class="solr.StandardTokenizerFactory"/>
@@ -548,10 +548,10 @@
         a token of "foo|1.4"  would be indexed as "foo" with a payload of 1.4f
         Attributes of the DelimitedPayloadTokenFilterFactory : 
          "delimiter" - a one character delimiter. Default is | (pipe)
-	 "encoder" - how to encode the following value into a playload
-	    float -> org.apache.lucene.analysis.payloads.FloatEncoder,
-	    integer -> o.a.l.a.p.IntegerEncoder
-	    identity -> o.a.l.a.p.IdentityEncoder
+   "encoder" - how to encode the following value into a playload
+      float -> org.apache.lucene.analysis.payloads.FloatEncoder,
+      integer -> o.a.l.a.p.IntegerEncoder
+      identity -> o.a.l.a.p.IdentityEncoder
             Fully Qualified class name implementing PayloadEncoder, Encoder must have a no arg constructor.
          -->
         <filter class="solr.DelimitedPayloadTokenFilterFactory" encoder="float"/>
@@ -572,10 +572,10 @@
     -->
     <fieldType name="descendent_path" class="solr.TextField">
       <analyzer type="index">
-	<tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
+  <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
       </analyzer>
       <analyzer type="query">
-	<tokenizer class="solr.KeywordTokenizerFactory" />
+  <tokenizer class="solr.KeywordTokenizerFactory" />
       </analyzer>
     </fieldType>
     <!-- 
@@ -584,10 +584,10 @@
     -->
     <fieldType name="ancestor_path" class="solr.TextField">
       <analyzer type="index">
-	<tokenizer class="solr.KeywordTokenizerFactory" />
+  <tokenizer class="solr.KeywordTokenizerFactory" />
       </analyzer>
       <analyzer type="query">
-	<tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
+  <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
       </analyzer>
     </fieldType>
 
diff --git a/solr/example/example-DIH/solr/mail/conf/solrconfig.xml b/solr/example/example-DIH/solr/mail/conf/solrconfig.xml
index f60907e..b808603 100644
--- a/solr/example/example-DIH/solr/mail/conf/solrconfig.xml
+++ b/solr/example/example-DIH/solr/mail/conf/solrconfig.xml
@@ -1068,7 +1068,7 @@
       <!-- maximum threshold of documents a query term can appear to be considered for correction -->
       <float name="maxQueryFrequency">0.01</float>
       <!-- uncomment this to require suggestions to occur in 1% of the documents
-      	<float name="thresholdTokenFrequency">.01</float>
+        <float name="thresholdTokenFrequency">.01</float>
       -->
     </lst>
     
@@ -1159,7 +1159,7 @@
   </requestHandler>
 
   <searchComponent name="suggest" class="solr.SuggestComponent">
-  	<lst name="suggester">
+    <lst name="suggester">
       <str name="name">mySuggester</str>
       <str name="lookupImpl">FuzzyLookupFactory</str>      <!-- org.apache.solr.spelling.suggest.fst -->
       <str name="dictionaryImpl">DocumentDictionaryFactory</str>     <!-- org.apache.solr.spelling.suggest.HighFrequencyDictionaryFactory --> 
diff --git a/solr/example/example-DIH/solr/rss/conf/rss-data-config.xml b/solr/example/example-DIH/solr/rss/conf/rss-data-config.xml
index 7dd2f67..704325b 100644
--- a/solr/example/example-DIH/solr/rss/conf/rss-data-config.xml
+++ b/solr/example/example-DIH/solr/rss/conf/rss-data-config.xml
@@ -7,11 +7,11 @@
                 processor="XPathEntityProcessor"
                 forEach="/rss/channel/item"
                 transformer="DateFormatTransformer">
-				
+        
             <field column="source" xpath="/rss/channel/title" commonField="true" />
             <field column="source-link" xpath="/rss/channel/link" commonField="true" />
             <field column="subject" xpath="/rss/channel/subject" commonField="true" />
-			
+      
             <field column="title" xpath="/rss/channel/item/title" />
             <field column="link" xpath="/rss/channel/item/link" />
             <field column="description" xpath="/rss/channel/item/description" />
diff --git a/solr/example/example-DIH/solr/rss/conf/schema.xml b/solr/example/example-DIH/solr/rss/conf/schema.xml
index 9d6c8d6..7a0f810 100644
--- a/solr/example/example-DIH/solr/rss/conf/schema.xml
+++ b/solr/example/example-DIH/solr/rss/conf/schema.xml
@@ -215,10 +215,10 @@
     <copyField source="item-subject" dest="text"/>
 
    <!-- Above, multiple source fields are copied to the [text] field. 
-	  Another way to map multiple source fields to the same 
-	  destination field is to use the dynamic field syntax. 
-	  copyField also supports a maxChars to copy setting.  -->
-	   
+    Another way to map multiple source fields to the same 
+    destination field is to use the dynamic field syntax. 
+    copyField also supports a maxChars to copy setting.  -->
+     
    <!-- <copyField source="*_t" dest="text" maxChars="3000"/> -->
 
    <!-- copy name to alphaNameSort, a field designed for sorting by name -->
@@ -272,8 +272,8 @@
     <!-- sortMissingLast and sortMissingFirst attributes are optional attributes are
          currently supported on types that are sorted internally as strings
          and on numeric types.
-	     This includes "string","boolean", and, as of 3.5 (and 4.x),
-	     int, float, long, date, double, including the "Trie" variants.
+       This includes "string","boolean", and, as of 3.5 (and 4.x),
+       int, float, long, date, double, including the "Trie" variants.
        - If sortMissingLast="true", then a sort on this field will cause documents
          without the field to come after documents with the field,
          regardless of the requested sort order (asc or desc).
@@ -384,9 +384,9 @@
 
     <!-- A general text field that has reasonable, generic
          cross-language defaults: it tokenizes with StandardTokenizer,
-	 removes stop words from case-insensitive "stopwords.txt"
-	 (empty by default), and down cases.  At query time only, it
-	 also applies synonyms. -->
+   removes stop words from case-insensitive "stopwords.txt"
+   (empty by default), and down cases.  At query time only, it
+   also applies synonyms. -->
     <fieldType name="text_general" class="solr.TextField" positionIncrementGap="100">
       <analyzer type="index">
         <tokenizer class="solr.StandardTokenizerFactory"/>
@@ -422,11 +422,11 @@
                 words="lang/stopwords_en.txt"
                 />
         <filter class="solr.LowerCaseFilterFactory"/>
-	<filter class="solr.EnglishPossessiveFilterFactory"/>
+  <filter class="solr.EnglishPossessiveFilterFactory"/>
         <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-	<!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
         <filter class="solr.EnglishMinimalStemFilterFactory"/>
-	-->
+  -->
         <filter class="solr.PorterStemFilterFactory"/>
       </analyzer>
       <analyzer type="query">
@@ -437,23 +437,23 @@
                 words="lang/stopwords_en.txt"
                 />
         <filter class="solr.LowerCaseFilterFactory"/>
-	<filter class="solr.EnglishPossessiveFilterFactory"/>
+  <filter class="solr.EnglishPossessiveFilterFactory"/>
         <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-	<!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
         <filter class="solr.EnglishMinimalStemFilterFactory"/>
-	-->
+  -->
         <filter class="solr.PorterStemFilterFactory"/>
       </analyzer>
     </fieldType>
 
     <!-- A text field with defaults appropriate for English, plus
-	 aggressive word-splitting and autophrase features enabled.
-	 This field is just like text_en, except it adds
-	 WordDelimiterFilter to enable splitting and matching of
-	 words on case-change, alpha numeric boundaries, and
-	 non-alphanumeric chars.  This means certain compound word
-	 cases will work, for example query "wi fi" will match
-	 document "WiFi" or "wi-fi".
+   aggressive word-splitting and autophrase features enabled.
+   This field is just like text_en, except it adds
+   WordDelimiterFilter to enable splitting and matching of
+   words on case-change, alpha numeric boundaries, and
+   non-alphanumeric chars.  This means certain compound word
+   cases will work, for example query "wi fi" will match
+   document "WiFi" or "wi-fi".
         -->
     <fieldType name="text_en_splitting" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true">
       <analyzer type="index">
@@ -504,7 +504,7 @@
     </fieldType>
 
     <!-- Just like text_general except it reverses the characters of
-	 each token, to enable more efficient leading wildcard queries. -->
+   each token, to enable more efficient leading wildcard queries. -->
     <fieldType name="text_general_rev" class="solr.TextField" positionIncrementGap="100">
       <analyzer type="index">
         <tokenizer class="solr.StandardTokenizerFactory"/>
@@ -579,10 +579,10 @@
         a token of "foo|1.4"  would be indexed as "foo" with a payload of 1.4f
         Attributes of the DelimitedPayloadTokenFilterFactory : 
          "delimiter" - a one character delimiter. Default is | (pipe)
-	 "encoder" - how to encode the following value into a playload
-	    float -> org.apache.lucene.analysis.payloads.FloatEncoder,
-	    integer -> o.a.l.a.p.IntegerEncoder
-	    identity -> o.a.l.a.p.IdentityEncoder
+   "encoder" - how to encode the following value into a playload
+      float -> org.apache.lucene.analysis.payloads.FloatEncoder,
+      integer -> o.a.l.a.p.IntegerEncoder
+      identity -> o.a.l.a.p.IdentityEncoder
             Fully Qualified class name implementing PayloadEncoder, Encoder must have a no arg constructor.
          -->
         <filter class="solr.DelimitedPayloadTokenFilterFactory" encoder="float"/>
@@ -603,10 +603,10 @@
     -->
     <fieldType name="descendent_path" class="solr.TextField">
       <analyzer type="index">
-	<tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
+  <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
       </analyzer>
       <analyzer type="query">
-	<tokenizer class="solr.KeywordTokenizerFactory" />
+  <tokenizer class="solr.KeywordTokenizerFactory" />
       </analyzer>
     </fieldType>
     <!-- 
@@ -615,10 +615,10 @@
     -->
     <fieldType name="ancestor_path" class="solr.TextField">
       <analyzer type="index">
-	<tokenizer class="solr.KeywordTokenizerFactory" />
+  <tokenizer class="solr.KeywordTokenizerFactory" />
       </analyzer>
       <analyzer type="query">
-	<tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
+  <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
       </analyzer>
     </fieldType>
 
diff --git a/solr/example/example-DIH/solr/rss/conf/solrconfig.xml b/solr/example/example-DIH/solr/rss/conf/solrconfig.xml
index 6322b7e..a706555 100644
--- a/solr/example/example-DIH/solr/rss/conf/solrconfig.xml
+++ b/solr/example/example-DIH/solr/rss/conf/solrconfig.xml
@@ -1065,7 +1065,7 @@
       <!-- maximum threshold of documents a query term can appear to be considered for correction -->
       <float name="maxQueryFrequency">0.01</float>
       <!-- uncomment this to require suggestions to occur in 1% of the documents
-      	<float name="thresholdTokenFrequency">.01</float>
+        <float name="thresholdTokenFrequency">.01</float>
       -->
     </lst>
     
@@ -1156,7 +1156,7 @@
   </requestHandler>
 
   <searchComponent name="suggest" class="solr.SuggestComponent">
-  	<lst name="suggester">
+    <lst name="suggester">
       <str name="name">mySuggester</str>
       <str name="lookupImpl">FuzzyLookupFactory</str>      <!-- org.apache.solr.spelling.suggest.fst -->
       <str name="dictionaryImpl">DocumentDictionaryFactory</str>     <!-- org.apache.solr.spelling.suggest.HighFrequencyDictionaryFactory --> 
diff --git a/solr/example/example-DIH/solr/solr/conf/schema.xml b/solr/example/example-DIH/solr/solr/conf/schema.xml
index 6e6530d..5bd1791 100644
--- a/solr/example/example-DIH/solr/solr/conf/schema.xml
+++ b/solr/example/example-DIH/solr/solr/conf/schema.xml
@@ -290,12 +290,12 @@
 
    <!-- Create a string version of author for faceting -->
    <copyField source="author" dest="author_s"/>
-	
+  
    <!-- Above, multiple source fields are copied to the [text] field. 
-	  Another way to map multiple source fields to the same 
-	  destination field is to use the dynamic field syntax. 
-	  copyField also supports a maxChars to copy setting.  -->
-	   
+    Another way to map multiple source fields to the same 
+    destination field is to use the dynamic field syntax. 
+    copyField also supports a maxChars to copy setting.  -->
+     
    <!-- <copyField source="*_t" dest="text" maxChars="3000"/> -->
 
    <!-- copy name to alphaNameSort, a field designed for sorting by name -->
@@ -322,8 +322,8 @@
     <!-- sortMissingLast and sortMissingFirst attributes are optional attributes are
          currently supported on types that are sorted internally as strings
          and on numeric types.
-	     This includes "string","boolean", and, as of 3.5 (and 4.x),
-	     int, float, long, date, double, including the "Trie" variants.
+       This includes "string","boolean", and, as of 3.5 (and 4.x),
+       int, float, long, date, double, including the "Trie" variants.
        - If sortMissingLast="true", then a sort on this field will cause documents
          without the field to come after documents with the field,
          regardless of the requested sort order (asc or desc).
@@ -434,9 +434,9 @@
 
     <!-- A general text field that has reasonable, generic
          cross-language defaults: it tokenizes with StandardTokenizer,
-	 removes stop words from case-insensitive "stopwords.txt"
-	 (empty by default), and down cases.  At query time only, it
-	 also applies synonyms. -->
+   removes stop words from case-insensitive "stopwords.txt"
+   (empty by default), and down cases.  At query time only, it
+   also applies synonyms. -->
     <fieldType name="text_general" class="solr.TextField" positionIncrementGap="100">
       <analyzer type="index">
         <tokenizer class="solr.StandardTokenizerFactory"/>
@@ -472,11 +472,11 @@
                 words="lang/stopwords_en.txt"
                 />
         <filter class="solr.LowerCaseFilterFactory"/>
-	<filter class="solr.EnglishPossessiveFilterFactory"/>
+  <filter class="solr.EnglishPossessiveFilterFactory"/>
         <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-	<!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
         <filter class="solr.EnglishMinimalStemFilterFactory"/>
-	-->
+  -->
         <filter class="solr.PorterStemFilterFactory"/>
       </analyzer>
       <analyzer type="query">
@@ -487,23 +487,23 @@
                 words="lang/stopwords_en.txt"
                 />
         <filter class="solr.LowerCaseFilterFactory"/>
-	<filter class="solr.EnglishPossessiveFilterFactory"/>
+  <filter class="solr.EnglishPossessiveFilterFactory"/>
         <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-	<!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
         <filter class="solr.EnglishMinimalStemFilterFactory"/>
-	-->
+  -->
         <filter class="solr.PorterStemFilterFactory"/>
       </analyzer>
     </fieldType>
 
     <!-- A text field with defaults appropriate for English, plus
-	 aggressive word-splitting and autophrase features enabled.
-	 This field is just like text_en, except it adds
-	 WordDelimiterFilter to enable splitting and matching of
-	 words on case-change, alpha numeric boundaries, and
-	 non-alphanumeric chars.  This means certain compound word
-	 cases will work, for example query "wi fi" will match
-	 document "WiFi" or "wi-fi".
+   aggressive word-splitting and autophrase features enabled.
+   This field is just like text_en, except it adds
+   WordDelimiterFilter to enable splitting and matching of
+   words on case-change, alpha numeric boundaries, and
+   non-alphanumeric chars.  This means certain compound word
+   cases will work, for example query "wi fi" will match
+   document "WiFi" or "wi-fi".
         -->
     <fieldType name="text_en_splitting" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true">
       <analyzer type="index">
@@ -554,7 +554,7 @@
     </fieldType>
 
     <!-- Just like text_general except it reverses the characters of
-	 each token, to enable more efficient leading wildcard queries. -->
+   each token, to enable more efficient leading wildcard queries. -->
     <fieldType name="text_general_rev" class="solr.TextField" positionIncrementGap="100">
       <analyzer type="index">
         <tokenizer class="solr.StandardTokenizerFactory"/>
@@ -629,10 +629,10 @@
         a token of "foo|1.4"  would be indexed as "foo" with a payload of 1.4f
         Attributes of the DelimitedPayloadTokenFilterFactory : 
          "delimiter" - a one character delimiter. Default is | (pipe)
-	 "encoder" - how to encode the following value into a playload
-	    float -> org.apache.lucene.analysis.payloads.FloatEncoder,
-	    integer -> o.a.l.a.p.IntegerEncoder
-	    identity -> o.a.l.a.p.IdentityEncoder
+   "encoder" - how to encode the following value into a playload
+      float -> org.apache.lucene.analysis.payloads.FloatEncoder,
+      integer -> o.a.l.a.p.IntegerEncoder
+      identity -> o.a.l.a.p.IdentityEncoder
             Fully Qualified class name implementing PayloadEncoder, Encoder must have a no arg constructor.
          -->
         <filter class="solr.DelimitedPayloadTokenFilterFactory" encoder="float"/>
@@ -653,10 +653,10 @@
     -->
     <fieldType name="descendent_path" class="solr.TextField">
       <analyzer type="index">
-	<tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
+  <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
       </analyzer>
       <analyzer type="query">
-	<tokenizer class="solr.KeywordTokenizerFactory" />
+  <tokenizer class="solr.KeywordTokenizerFactory" />
       </analyzer>
     </fieldType>
     <!-- 
@@ -665,10 +665,10 @@
     -->
     <fieldType name="ancestor_path" class="solr.TextField">
       <analyzer type="index">
-	<tokenizer class="solr.KeywordTokenizerFactory" />
+  <tokenizer class="solr.KeywordTokenizerFactory" />
       </analyzer>
       <analyzer type="query">
-	<tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
+  <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
       </analyzer>
     </fieldType>
 
diff --git a/solr/example/example-DIH/solr/solr/conf/solrconfig.xml b/solr/example/example-DIH/solr/solr/conf/solrconfig.xml
index b15e122..dd73227 100644
--- a/solr/example/example-DIH/solr/solr/conf/solrconfig.xml
+++ b/solr/example/example-DIH/solr/solr/conf/solrconfig.xml
@@ -1066,7 +1066,7 @@
       <!-- maximum threshold of documents a query term can appear to be considered for correction -->
       <float name="maxQueryFrequency">0.01</float>
       <!-- uncomment this to require suggestions to occur in 1% of the documents
-      	<float name="thresholdTokenFrequency">.01</float>
+        <float name="thresholdTokenFrequency">.01</float>
       -->
     </lst>
     
@@ -1157,7 +1157,7 @@
   </requestHandler>
 
   <searchComponent name="suggest" class="solr.SuggestComponent">
-  	<lst name="suggester">
+    <lst name="suggester">
       <str name="name">mySuggester</str>
       <str name="lookupImpl">FuzzyLookupFactory</str>      <!-- org.apache.solr.spelling.suggest.fst -->
       <str name="dictionaryImpl">DocumentDictionaryFactory</str>     <!-- org.apache.solr.spelling.suggest.HighFrequencyDictionaryFactory --> 
diff --git a/solr/example/example-DIH/solr/tika/conf/schema.xml b/solr/example/example-DIH/solr/tika/conf/schema.xml
index f4fe0b9..5f5b1e6 100644
--- a/solr/example/example-DIH/solr/tika/conf/schema.xml
+++ b/solr/example/example-DIH/solr/tika/conf/schema.xml
@@ -201,8 +201,8 @@
     <!-- sortMissingLast and sortMissingFirst attributes are optional attributes are
          currently supported on types that are sorted internally as strings
          and on numeric types.
-	     This includes "string","boolean", and, as of 3.5 (and 4.x),
-	     int, float, long, date, double, including the "Trie" variants.
+       This includes "string","boolean", and, as of 3.5 (and 4.x),
+       int, float, long, date, double, including the "Trie" variants.
        - If sortMissingLast="true", then a sort on this field will cause documents
          without the field to come after documents with the field,
          regardless of the requested sort order (asc or desc).
@@ -332,31 +332,31 @@
       <analyzer type="index">
         <tokenizer class="solr.StandardTokenizerFactory"/>
         <filter class="solr.LowerCaseFilterFactory"/>
-	<filter class="solr.EnglishPossessiveFilterFactory"/>
-	<!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+  <filter class="solr.EnglishPossessiveFilterFactory"/>
+  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
         <filter class="solr.EnglishMinimalStemFilterFactory"/>
-	-->
+  -->
         <filter class="solr.PorterStemFilterFactory"/>
       </analyzer>
       <analyzer type="query">
         <tokenizer class="solr.StandardTokenizerFactory"/>
         <filter class="solr.LowerCaseFilterFactory"/>
-	<filter class="solr.EnglishPossessiveFilterFactory"/>
-	<!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+  <filter class="solr.EnglishPossessiveFilterFactory"/>
+  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
         <filter class="solr.EnglishMinimalStemFilterFactory"/>
-	-->
+  -->
         <filter class="solr.PorterStemFilterFactory"/>
       </analyzer>
     </fieldType>
 
     <!-- A text field with defaults appropriate for English, plus
-	 aggressive word-splitting and autophrase features enabled.
-	 This field is just like text_en, except it adds
-	 WordDelimiterFilter to enable splitting and matching of
-	 words on case-change, alpha numeric boundaries, and
-	 non-alphanumeric chars.  This means certain compound word
-	 cases will work, for example query "wi fi" will match
-	 document "WiFi" or "wi-fi".
+   aggressive word-splitting and autophrase features enabled.
+   This field is just like text_en, except it adds
+   WordDelimiterFilter to enable splitting and matching of
+   words on case-change, alpha numeric boundaries, and
+   non-alphanumeric chars.  This means certain compound word
+   cases will work, for example query "wi fi" will match
+   document "WiFi" or "wi-fi".
         -->
     <fieldType name="text_en_splitting" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true">
       <analyzer type="index">
@@ -388,7 +388,7 @@
     </fieldType>
 
     <!-- Just like text_general except it reverses the characters of
-	 each token, to enable more efficient leading wildcard queries. -->
+   each token, to enable more efficient leading wildcard queries. -->
     <fieldType name="text_general_rev" class="solr.TextField" positionIncrementGap="100">
       <analyzer type="index">
         <tokenizer class="solr.StandardTokenizerFactory"/>
@@ -460,10 +460,10 @@
         a token of "foo|1.4"  would be indexed as "foo" with a payload of 1.4f
         Attributes of the DelimitedPayloadTokenFilterFactory : 
          "delimiter" - a one character delimiter. Default is | (pipe)
-	 "encoder" - how to encode the following value into a playload
-	    float -> org.apache.lucene.analysis.payloads.FloatEncoder,
-	    integer -> o.a.l.a.p.IntegerEncoder
-	    identity -> o.a.l.a.p.IdentityEncoder
+   "encoder" - how to encode the following value into a playload
+      float -> org.apache.lucene.analysis.payloads.FloatEncoder,
+      integer -> o.a.l.a.p.IntegerEncoder
+      identity -> o.a.l.a.p.IdentityEncoder
             Fully Qualified class name implementing PayloadEncoder, Encoder must have a no arg constructor.
          -->
         <filter class="solr.DelimitedPayloadTokenFilterFactory" encoder="float"/>
@@ -484,10 +484,10 @@
     -->
     <fieldType name="descendent_path" class="solr.TextField">
       <analyzer type="index">
-	<tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
+  <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
       </analyzer>
       <analyzer type="query">
-	<tokenizer class="solr.KeywordTokenizerFactory" />
+  <tokenizer class="solr.KeywordTokenizerFactory" />
       </analyzer>
     </fieldType>
     <!-- 
@@ -496,10 +496,10 @@
     -->
     <fieldType name="ancestor_path" class="solr.TextField">
       <analyzer type="index">
-	<tokenizer class="solr.KeywordTokenizerFactory" />
+  <tokenizer class="solr.KeywordTokenizerFactory" />
       </analyzer>
       <analyzer type="query">
-	<tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
+  <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
       </analyzer>
     </fieldType>
 
diff --git a/solr/example/example-DIH/solr/tika/conf/solrconfig.xml b/solr/example/example-DIH/solr/tika/conf/solrconfig.xml
index cc6e238..9620285 100644
--- a/solr/example/example-DIH/solr/tika/conf/solrconfig.xml
+++ b/solr/example/example-DIH/solr/tika/conf/solrconfig.xml
@@ -1068,7 +1068,7 @@
       <!-- maximum threshold of documents a query term can appear to be considered for correction -->
       <float name="maxQueryFrequency">0.01</float>
       <!-- uncomment this to require suggestions to occur in 1% of the documents
-      	<float name="thresholdTokenFrequency">.01</float>
+        <float name="thresholdTokenFrequency">.01</float>
       -->
     </lst>
     
@@ -1159,7 +1159,7 @@
   </requestHandler>
 
   <searchComponent name="suggest" class="solr.SuggestComponent">
-  	<lst name="suggester">
+    <lst name="suggester">
       <str name="name">mySuggester</str>
       <str name="lookupImpl">FuzzyLookupFactory</str>      <!-- org.apache.solr.spelling.suggest.fst -->
       <str name="dictionaryImpl">DocumentDictionaryFactory</str>     <!-- org.apache.solr.spelling.suggest.HighFrequencyDictionaryFactory --> 
diff --git a/solr/example/exampledocs/mem.xml b/solr/example/exampledocs/mem.xml
index 41d31a4..48af522 100644
--- a/solr/example/exampledocs/mem.xml
+++ b/solr/example/exampledocs/mem.xml
@@ -24,7 +24,7 @@
   <field name="manu_id_s">corsair</field>
   <field name="cat">electronics</field>
   <field name="cat">memory</field>
-  <field name="features">CAS latency 2,	2-3-3-6 timing, 2.75v, unbuffered, heat-spreader</field>
+  <field name="features">CAS latency 2,  2-3-3-6 timing, 2.75v, unbuffered, heat-spreader</field>
   <field name="price">185.00</field>
   <field name="popularity">5</field>
   <field name="inStock">true</field>
@@ -62,7 +62,7 @@
   <field name="manu_id_s">corsair</field>
   <field name="cat">electronics</field>
   <field name="cat">memory</field>
-  <field name="features">CAS latency 3,	 2.7v</field>
+  <field name="features">CAS latency 3,   2.7v</field>
   <!-- note: price & popularity is missing on this one -->
   <field name="popularity">0</field>
   <field name="inStock">true</field>
diff --git a/solr/example/files/conf/solrconfig.xml b/solr/example/files/conf/solrconfig.xml
index 7565f80..e515c1b 100644
--- a/solr/example/files/conf/solrconfig.xml
+++ b/solr/example/files/conf/solrconfig.xml
@@ -1052,7 +1052,7 @@
       <!-- maximum threshold of documents a query term can appear to be considered for correction -->
       <float name="maxQueryFrequency">0.01</float>
       <!-- uncomment this to require suggestions to occur in 1% of the documents
-      	<float name="thresholdTokenFrequency">.01</float>
+        <float name="thresholdTokenFrequency">.01</float>
       -->
     </lst>
 
diff --git a/solr/example/files/conf/velocity/js/jquery.autocomplete.js b/solr/example/files/conf/velocity/js/jquery.autocomplete.js
index 4a218dc..442f5a0 100644
--- a/solr/example/files/conf/velocity/js/jquery.autocomplete.js
+++ b/solr/example/files/conf/velocity/js/jquery.autocomplete.js
@@ -12,752 +12,752 @@
  */
 
 ;(function($) {
-	
+  
 $.fn.extend({
-	autocomplete: function(urlOrData, options) {
-		var isUrl = typeof urlOrData == "string";
-		options = $.extend({}, $.Autocompleter.defaults, {
-			url: isUrl ? urlOrData : null,
-			data: isUrl ? null : urlOrData,
-			delay: isUrl ? $.Autocompleter.defaults.delay : 10,
-			max: options && !options.scroll ? 10 : 150
-		}, options);
-		
-		// if highlight is set to false, replace it with a do-nothing function
-		options.highlight = options.highlight || function(value) { return value; };
-		
-		// if the formatMatch option is not specified, then use formatItem for backwards compatibility
-		options.formatMatch = options.formatMatch || options.formatItem;
-		
-		return this.each(function() {
-			new $.Autocompleter(this, options);
-		});
-	},
-	result: function(handler) {
-		return this.bind("result", handler);
-	},
-	search: function(handler) {
-		return this.trigger("search", [handler]);
-	},
-	flushCache: function() {
-		return this.trigger("flushCache");
-	},
-	setOptions: function(options){
-		return this.trigger("setOptions", [options]);
-	},
-	unautocomplete: function() {
-		return this.trigger("unautocomplete");
-	}
+  autocomplete: function(urlOrData, options) {
+    var isUrl = typeof urlOrData == "string";
+    options = $.extend({}, $.Autocompleter.defaults, {
+      url: isUrl ? urlOrData : null,
+      data: isUrl ? null : urlOrData,
+      delay: isUrl ? $.Autocompleter.defaults.delay : 10,
+      max: options && !options.scroll ? 10 : 150
+    }, options);
+    
+    // if highlight is set to false, replace it with a do-nothing function
+    options.highlight = options.highlight || function(value) { return value; };
+    
+    // if the formatMatch option is not specified, then use formatItem for backwards compatibility
+    options.formatMatch = options.formatMatch || options.formatItem;
+    
+    return this.each(function() {
+      new $.Autocompleter(this, options);
+    });
+  },
+  result: function(handler) {
+    return this.bind("result", handler);
+  },
+  search: function(handler) {
+    return this.trigger("search", [handler]);
+  },
+  flushCache: function() {
+    return this.trigger("flushCache");
+  },
+  setOptions: function(options){
+    return this.trigger("setOptions", [options]);
+  },
+  unautocomplete: function() {
+    return this.trigger("unautocomplete");
+  }
 });
 
 $.Autocompleter = function(input, options) {
 
-	var KEY = {
-		UP: 38,
-		DOWN: 40,
-		DEL: 46,
-		TAB: 9,
-		RETURN: 13,
-		ESC: 27,
-		COMMA: 188,
-		PAGEUP: 33,
-		PAGEDOWN: 34,
-		BACKSPACE: 8
-	};
+  var KEY = {
+    UP: 38,
+    DOWN: 40,
+    DEL: 46,
+    TAB: 9,
+    RETURN: 13,
+    ESC: 27,
+    COMMA: 188,
+    PAGEUP: 33,
+    PAGEDOWN: 34,
+    BACKSPACE: 8
+  };
 
-	// Create $ object for input element
-	var $input = $(input).attr("autocomplete", "off").addClass(options.inputClass);
+  // Create $ object for input element
+  var $input = $(input).attr("autocomplete", "off").addClass(options.inputClass);
 
-	var timeout;
-	var previousValue = "";
-	var cache = $.Autocompleter.Cache(options);
-	var hasFocus = 0;
-	var lastKeyPressCode;
-	var config = {
-		mouseDownOnSelect: false
-	};
-	var select = $.Autocompleter.Select(options, input, selectCurrent, config);
-	
-	var blockSubmit;
-	
-	// prevent form submit in opera when selecting with return key
-	$.browser.opera && $(input.form).bind("submit.autocomplete", function() {
-		if (blockSubmit) {
-			blockSubmit = false;
-			return false;
-		}
-	});
-	
-	// only opera doesn't trigger keydown multiple times while pressed, others don't work with keypress at all
-	$input.bind(($.browser.opera ? "keypress" : "keydown") + ".autocomplete", function(event) {
-		// track last key pressed
-		lastKeyPressCode = event.keyCode;
-		switch(event.keyCode) {
-		
-			case KEY.UP:
-				event.preventDefault();
-				if ( select.visible() ) {
-					select.prev();
-				} else {
-					onChange(0, true);
-				}
-				break;
-				
-			case KEY.DOWN:
-				event.preventDefault();
-				if ( select.visible() ) {
-					select.next();
-				} else {
-					onChange(0, true);
-				}
-				break;
-				
-			case KEY.PAGEUP:
-				event.preventDefault();
-				if ( select.visible() ) {
-					select.pageUp();
-				} else {
-					onChange(0, true);
-				}
-				break;
-				
-			case KEY.PAGEDOWN:
-				event.preventDefault();
-				if ( select.visible() ) {
-					select.pageDown();
-				} else {
-					onChange(0, true);
-				}
-				break;
-			
-			// matches also semicolon
-			case options.multiple && $.trim(options.multipleSeparator) == "," && KEY.COMMA:
-			case KEY.TAB:
-			case KEY.RETURN:
-				if( selectCurrent() ) {
-					// stop default to prevent a form submit, Opera needs special handling
-					event.preventDefault();
-					blockSubmit = true;
-					return false;
-				}
-				break;
-				
-			case KEY.ESC:
-				select.hide();
-				break;
-				
-			default:
-				clearTimeout(timeout);
-				timeout = setTimeout(onChange, options.delay);
-				break;
-		}
-	}).focus(function(){
-		// track whether the field has focus, we shouldn't process any
-		// results if the field no longer has focus
-		hasFocus++;
-	}).blur(function() {
-		hasFocus = 0;
-		if (!config.mouseDownOnSelect) {
-			hideResults();
-		}
-	}).click(function() {
-		// show select when clicking in a focused field
-		if ( hasFocus++ > 1 && !select.visible() ) {
-			onChange(0, true);
-		}
-	}).bind("search", function() {
-		// TODO why not just specifying both arguments?
-		var fn = (arguments.length > 1) ? arguments[1] : null;
-		function findValueCallback(q, data) {
-			var result;
-			if( data && data.length ) {
-				for (var i=0; i < data.length; i++) {
-					if( data[i].result.toLowerCase() == q.toLowerCase() ) {
-						result = data[i];
-						break;
-					}
-				}
-			}
-			if( typeof fn == "function" ) fn(result);
-			else $input.trigger("result", result && [result.data, result.value]);
-		}
-		$.each(trimWords($input.val()), function(i, value) {
-			request(value, findValueCallback, findValueCallback);
-		});
-	}).bind("flushCache", function() {
-		cache.flush();
-	}).bind("setOptions", function() {
-		$.extend(options, arguments[1]);
-		// if we've updated the data, repopulate
-		if ( "data" in arguments[1] )
-			cache.populate();
-	}).bind("unautocomplete", function() {
-		select.unbind();
-		$input.unbind();
-		$(input.form).unbind(".autocomplete");
-	});
-	
-	
-	function selectCurrent() {
-		var selected = select.selected();
-		if( !selected )
-			return false;
-		
-		var v = selected.result;
-		previousValue = v;
-		
-		if ( options.multiple ) {
-			var words = trimWords($input.val());
-			if ( words.length > 1 ) {
-				v = words.slice(0, words.length - 1).join( options.multipleSeparator ) + options.multipleSeparator + v;
-			}
-			v += options.multipleSeparator;
-		}
-		
-		$input.val(v);
-		hideResultsNow();
-		$input.trigger("result", [selected.data, selected.value]);
-		return true;
-	}
-	
-	function onChange(crap, skipPrevCheck) {
-		if( lastKeyPressCode == KEY.DEL ) {
-			select.hide();
-			return;
-		}
-		
-		var currentValue = $input.val();
-		
-		if ( !skipPrevCheck && currentValue == previousValue )
-			return;
-		
-		previousValue = currentValue;
-		
-		currentValue = lastWord(currentValue);
-		if ( currentValue.length >= options.minChars) {
-			$input.addClass(options.loadingClass);
-			if (!options.matchCase)
-				currentValue = currentValue.toLowerCase();
-			request(currentValue, receiveData, hideResultsNow);
-		} else {
-			stopLoading();
-			select.hide();
-		}
-	};
-	
-	function trimWords(value) {
-		if ( !value ) {
-			return [""];
-		}
-		var words = value.split( options.multipleSeparator );
-		var result = [];
-		$.each(words, function(i, value) {
-			if ( $.trim(value) )
-				result[i] = $.trim(value);
-		});
-		return result;
-	}
-	
-	function lastWord(value) {
-		if ( !options.multiple )
-			return value;
-		var words = trimWords(value);
-		return words[words.length - 1];
-	}
-	
-	// fills in the input box w/the first match (assumed to be the best match)
-	// q: the term entered
-	// sValue: the first matching result
-	function autoFill(q, sValue){
-		// autofill in the complete box w/the first match as long as the user hasn't entered in more data
-		// if the last user key pressed was backspace, don't autofill
-		if( options.autoFill && (lastWord($input.val()).toLowerCase() == q.toLowerCase()) && lastKeyPressCode != KEY.BACKSPACE ) {
-			// fill in the value (keep the case the user has typed)
-			$input.val($input.val() + sValue.substring(lastWord(previousValue).length));
-			// select the portion of the value not typed by the user (so the next character will erase)
-			$.Autocompleter.Selection(input, previousValue.length, previousValue.length + sValue.length);
-		}
-	};
+  var timeout;
+  var previousValue = "";
+  var cache = $.Autocompleter.Cache(options);
+  var hasFocus = 0;
+  var lastKeyPressCode;
+  var config = {
+    mouseDownOnSelect: false
+  };
+  var select = $.Autocompleter.Select(options, input, selectCurrent, config);
+  
+  var blockSubmit;
+  
+  // prevent form submit in opera when selecting with return key
+  $.browser.opera && $(input.form).bind("submit.autocomplete", function() {
+    if (blockSubmit) {
+      blockSubmit = false;
+      return false;
+    }
+  });
+  
+  // only opera doesn't trigger keydown multiple times while pressed, others don't work with keypress at all
+  $input.bind(($.browser.opera ? "keypress" : "keydown") + ".autocomplete", function(event) {
+    // track last key pressed
+    lastKeyPressCode = event.keyCode;
+    switch(event.keyCode) {
+    
+      case KEY.UP:
+        event.preventDefault();
+        if ( select.visible() ) {
+          select.prev();
+        } else {
+          onChange(0, true);
+        }
+        break;
+        
+      case KEY.DOWN:
+        event.preventDefault();
+        if ( select.visible() ) {
+          select.next();
+        } else {
+          onChange(0, true);
+        }
+        break;
+        
+      case KEY.PAGEUP:
+        event.preventDefault();
+        if ( select.visible() ) {
+          select.pageUp();
+        } else {
+          onChange(0, true);
+        }
+        break;
+        
+      case KEY.PAGEDOWN:
+        event.preventDefault();
+        if ( select.visible() ) {
+          select.pageDown();
+        } else {
+          onChange(0, true);
+        }
+        break;
+      
+      // matches also semicolon
+      case options.multiple && $.trim(options.multipleSeparator) == "," && KEY.COMMA:
+      case KEY.TAB:
+      case KEY.RETURN:
+        if( selectCurrent() ) {
+          // stop default to prevent a form submit, Opera needs special handling
+          event.preventDefault();
+          blockSubmit = true;
+          return false;
+        }
+        break;
+        
+      case KEY.ESC:
+        select.hide();
+        break;
+        
+      default:
+        clearTimeout(timeout);
+        timeout = setTimeout(onChange, options.delay);
+        break;
+    }
+  }).focus(function(){
+    // track whether the field has focus, we shouldn't process any
+    // results if the field no longer has focus
+    hasFocus++;
+  }).blur(function() {
+    hasFocus = 0;
+    if (!config.mouseDownOnSelect) {
+      hideResults();
+    }
+  }).click(function() {
+    // show select when clicking in a focused field
+    if ( hasFocus++ > 1 && !select.visible() ) {
+      onChange(0, true);
+    }
+  }).bind("search", function() {
+    // TODO why not just specifying both arguments?
+    var fn = (arguments.length > 1) ? arguments[1] : null;
+    function findValueCallback(q, data) {
+      var result;
+      if( data && data.length ) {
+        for (var i=0; i < data.length; i++) {
+          if( data[i].result.toLowerCase() == q.toLowerCase() ) {
+            result = data[i];
+            break;
+          }
+        }
+      }
+      if( typeof fn == "function" ) fn(result);
+      else $input.trigger("result", result && [result.data, result.value]);
+    }
+    $.each(trimWords($input.val()), function(i, value) {
+      request(value, findValueCallback, findValueCallback);
+    });
+  }).bind("flushCache", function() {
+    cache.flush();
+  }).bind("setOptions", function() {
+    $.extend(options, arguments[1]);
+    // if we've updated the data, repopulate
+    if ( "data" in arguments[1] )
+      cache.populate();
+  }).bind("unautocomplete", function() {
+    select.unbind();
+    $input.unbind();
+    $(input.form).unbind(".autocomplete");
+  });
+  
+  
+  function selectCurrent() {
+    var selected = select.selected();
+    if( !selected )
+      return false;
+    
+    var v = selected.result;
+    previousValue = v;
+    
+    if ( options.multiple ) {
+      var words = trimWords($input.val());
+      if ( words.length > 1 ) {
+        v = words.slice(0, words.length - 1).join( options.multipleSeparator ) + options.multipleSeparator + v;
+      }
+      v += options.multipleSeparator;
+    }
+    
+    $input.val(v);
+    hideResultsNow();
+    $input.trigger("result", [selected.data, selected.value]);
+    return true;
+  }
+  
+  function onChange(crap, skipPrevCheck) {
+    if( lastKeyPressCode == KEY.DEL ) {
+      select.hide();
+      return;
+    }
+    
+    var currentValue = $input.val();
+    
+    if ( !skipPrevCheck && currentValue == previousValue )
+      return;
+    
+    previousValue = currentValue;
+    
+    currentValue = lastWord(currentValue);
+    if ( currentValue.length >= options.minChars) {
+      $input.addClass(options.loadingClass);
+      if (!options.matchCase)
+        currentValue = currentValue.toLowerCase();
+      request(currentValue, receiveData, hideResultsNow);
+    } else {
+      stopLoading();
+      select.hide();
+    }
+  };
+  
+  function trimWords(value) {
+    if ( !value ) {
+      return [""];
+    }
+    var words = value.split( options.multipleSeparator );
+    var result = [];
+    $.each(words, function(i, value) {
+      if ( $.trim(value) )
+        result[i] = $.trim(value);
+    });
+    return result;
+  }
+  
+  function lastWord(value) {
+    if ( !options.multiple )
+      return value;
+    var words = trimWords(value);
+    return words[words.length - 1];
+  }
+  
+  // fills in the input box w/the first match (assumed to be the best match)
+  // q: the term entered
+  // sValue: the first matching result
+  function autoFill(q, sValue){
+    // autofill in the complete box w/the first match as long as the user hasn't entered in more data
+    // if the last user key pressed was backspace, don't autofill
+    if( options.autoFill && (lastWord($input.val()).toLowerCase() == q.toLowerCase()) && lastKeyPressCode != KEY.BACKSPACE ) {
+      // fill in the value (keep the case the user has typed)
+      $input.val($input.val() + sValue.substring(lastWord(previousValue).length));
+      // select the portion of the value not typed by the user (so the next character will erase)
+      $.Autocompleter.Selection(input, previousValue.length, previousValue.length + sValue.length);
+    }
+  };
 
-	function hideResults() {
-		clearTimeout(timeout);
-		timeout = setTimeout(hideResultsNow, 200);
-	};
+  function hideResults() {
+    clearTimeout(timeout);
+    timeout = setTimeout(hideResultsNow, 200);
+  };
 
-	function hideResultsNow() {
-		var wasVisible = select.visible();
-		select.hide();
-		clearTimeout(timeout);
-		stopLoading();
-		if (options.mustMatch) {
-			// call search and run callback
-			$input.search(
-				function (result){
-					// if no value found, clear the input box
-					if( !result ) {
-						if (options.multiple) {
-							var words = trimWords($input.val()).slice(0, -1);
-							$input.val( words.join(options.multipleSeparator) + (words.length ? options.multipleSeparator : "") );
-						}
-						else
-							$input.val( "" );
-					}
-				}
-			);
-		}
-		if (wasVisible)
-			// position cursor at end of input field
-			$.Autocompleter.Selection(input, input.value.length, input.value.length);
-	};
+  function hideResultsNow() {
+    var wasVisible = select.visible();
+    select.hide();
+    clearTimeout(timeout);
+    stopLoading();
+    if (options.mustMatch) {
+      // call search and run callback
+      $input.search(
+        function (result){
+          // if no value found, clear the input box
+          if( !result ) {
+            if (options.multiple) {
+              var words = trimWords($input.val()).slice(0, -1);
+              $input.val( words.join(options.multipleSeparator) + (words.length ? options.multipleSeparator : "") );
+            }
+            else
+              $input.val( "" );
+          }
+        }
+      );
+    }
+    if (wasVisible)
+      // position cursor at end of input field
+      $.Autocompleter.Selection(input, input.value.length, input.value.length);
+  };
 
-	function receiveData(q, data) {
-		if ( data && data.length && hasFocus ) {
-			stopLoading();
-			select.display(data, q);
-			autoFill(q, data[0].value);
-			select.show();
-		} else {
-			hideResultsNow();
-		}
-	};
+  function receiveData(q, data) {
+    if ( data && data.length && hasFocus ) {
+      stopLoading();
+      select.display(data, q);
+      autoFill(q, data[0].value);
+      select.show();
+    } else {
+      hideResultsNow();
+    }
+  };
 
-	function request(term, success, failure) {
-		if (!options.matchCase)
-			term = term.toLowerCase();
-		var data = cache.load(term);
-		data = null; // Avoid buggy cache and go to Solr every time 
-		// recieve the cached data
-		if (data && data.length) {
-			success(term, data);
-		// if an AJAX url has been supplied, try loading the data now
-		} else if( (typeof options.url == "string") && (options.url.length > 0) ){
-			
-			var extraParams = {
-				timestamp: +new Date()
-			};
-			$.each(options.extraParams, function(key, param) {
-				extraParams[key] = typeof param == "function" ? param() : param;
-			});
-			
-			$.ajax({
-				// try to leverage ajaxQueue plugin to abort previous requests
-				mode: "abort",
-				// limit abortion to this input
-				port: "autocomplete" + input.name,
-				dataType: options.dataType,
-				url: options.url,
-				data: $.extend({
-					q: lastWord(term),
-					limit: options.max
-				}, extraParams),
-				success: function(data) {
-					var parsed = options.parse && options.parse(data) || parse(data);
-					cache.add(term, parsed);
-					success(term, parsed);
-				}
-			});
-		} else {
-			// if we have a failure, we need to empty the list -- this prevents the the [TAB] key from selecting the last successful match
-			select.emptyList();
-			failure(term);
-		}
-	};
-	
-	function parse(data) {
-		var parsed = [];
-		var rows = data.split("\n");
-		for (var i=0; i < rows.length; i++) {
-			var row = $.trim(rows[i]);
-			if (row) {
-				row = row.split("|");
-				parsed[parsed.length] = {
-					data: row,
-					value: row[0],
-					result: options.formatResult && options.formatResult(row, row[0]) || row[0]
-				};
-			}
-		}
-		return parsed;
-	};
+  function request(term, success, failure) {
+    if (!options.matchCase)
+      term = term.toLowerCase();
+    var data = cache.load(term);
+    data = null; // Avoid buggy cache and go to Solr every time 
+    // recieve the cached data
+    if (data && data.length) {
+      success(term, data);
+    // if an AJAX url has been supplied, try loading the data now
+    } else if( (typeof options.url == "string") && (options.url.length > 0) ){
+      
+      var extraParams = {
+        timestamp: +new Date()
+      };
+      $.each(options.extraParams, function(key, param) {
+        extraParams[key] = typeof param == "function" ? param() : param;
+      });
+      
+      $.ajax({
+        // try to leverage ajaxQueue plugin to abort previous requests
+        mode: "abort",
+        // limit abortion to this input
+        port: "autocomplete" + input.name,
+        dataType: options.dataType,
+        url: options.url,
+        data: $.extend({
+          q: lastWord(term),
+          limit: options.max
+        }, extraParams),
+        success: function(data) {
+          var parsed = options.parse && options.parse(data) || parse(data);
+          cache.add(term, parsed);
+          success(term, parsed);
+        }
+      });
+    } else {
+      // if we have a failure, we need to empty the list -- this prevents the the [TAB] key from selecting the last successful match
+      select.emptyList();
+      failure(term);
+    }
+  };
+  
+  function parse(data) {
+    var parsed = [];
+    var rows = data.split("\n");
+    for (var i=0; i < rows.length; i++) {
+      var row = $.trim(rows[i]);
+      if (row) {
+        row = row.split("|");
+        parsed[parsed.length] = {
+          data: row,
+          value: row[0],
+          result: options.formatResult && options.formatResult(row, row[0]) || row[0]
+        };
+      }
+    }
+    return parsed;
+  };
 
-	function stopLoading() {
-		$input.removeClass(options.loadingClass);
-	};
+  function stopLoading() {
+    $input.removeClass(options.loadingClass);
+  };
 
 };
 
 $.Autocompleter.defaults = {
-	inputClass: "ac_input",
-	resultsClass: "ac_results",
-	loadingClass: "ac_loading",
-	minChars: 1,
-	delay: 400,
-	matchCase: false,
-	matchSubset: true,
-	matchContains: false,
-	cacheLength: 10,
-	max: 100,
-	mustMatch: false,
-	extraParams: {},
-	selectFirst: false,
-	formatItem: function(row) { return row[0]; },
-	formatMatch: null,
-	autoFill: false,
-	width: 0,
-	multiple: false,
-	multipleSeparator: ", ",
-	highlight: function(value, term) {
-		return value.replace(new RegExp("(?![^&;]+;)(?!<[^<>]*)(" + term.replace(/([\^\$\(\)\[\]\{\}\*\.\+\?\|\\])/gi, "\\$1") + ")(?![^<>]*>)(?![^&;]+;)", "gi"), "<strong>$1</strong>");
-	},
+  inputClass: "ac_input",
+  resultsClass: "ac_results",
+  loadingClass: "ac_loading",
+  minChars: 1,
+  delay: 400,
+  matchCase: false,
+  matchSubset: true,
+  matchContains: false,
+  cacheLength: 10,
+  max: 100,
+  mustMatch: false,
+  extraParams: {},
+  selectFirst: false,
+  formatItem: function(row) { return row[0]; },
+  formatMatch: null,
+  autoFill: false,
+  width: 0,
+  multiple: false,
+  multipleSeparator: ", ",
+  highlight: function(value, term) {
+    return value.replace(new RegExp("(?![^&;]+;)(?!<[^<>]*)(" + term.replace(/([\^\$\(\)\[\]\{\}\*\.\+\?\|\\])/gi, "\\$1") + ")(?![^<>]*>)(?![^&;]+;)", "gi"), "<strong>$1</strong>");
+  },
     scroll: true,
     scrollHeight: 180
 };
 
 $.Autocompleter.Cache = function(options) {
 
-	var data = {};
-	var length = 0;
-	
-	function matchSubset(s, sub) {
-		if (!options.matchCase) 
-			s = s.toLowerCase();
-		var i = s.indexOf(sub);
-		if (options.matchContains == "word"){
-			i = s.toLowerCase().search("\\b" + sub.toLowerCase());
-		}
-		if (i == -1) return false;
-		return i == 0 || options.matchContains;
-	};
-	
-	function add(q, value) {
-		if (length > options.cacheLength){
-			flush();
-		}
-		if (!data[q]){ 
-			length++;
-		}
-		data[q] = value;
-	}
-	
-	function populate(){
-		if( !options.data ) return false;
-		// track the matches
-		var stMatchSets = {},
-			nullData = 0;
+  var data = {};
+  var length = 0;
+  
+  function matchSubset(s, sub) {
+    if (!options.matchCase) 
+      s = s.toLowerCase();
+    var i = s.indexOf(sub);
+    if (options.matchContains == "word"){
+      i = s.toLowerCase().search("\\b" + sub.toLowerCase());
+    }
+    if (i == -1) return false;
+    return i == 0 || options.matchContains;
+  };
+  
+  function add(q, value) {
+    if (length > options.cacheLength){
+      flush();
+    }
+    if (!data[q]){ 
+      length++;
+    }
+    data[q] = value;
+  }
+  
+  function populate(){
+    if( !options.data ) return false;
+    // track the matches
+    var stMatchSets = {},
+      nullData = 0;
 
-		// no url was specified, we need to adjust the cache length to make sure it fits the local data store
-		if( !options.url ) options.cacheLength = 1;
-		
-		// track all options for minChars = 0
-		stMatchSets[""] = [];
-		
-		// loop through the array and create a lookup structure
-		for ( var i = 0, ol = options.data.length; i < ol; i++ ) {
-			var rawValue = options.data[i];
-			// if rawValue is a string, make an array otherwise just reference the array
-			rawValue = (typeof rawValue == "string") ? [rawValue] : rawValue;
-			
-			var value = options.formatMatch(rawValue, i+1, options.data.length);
-			if ( value === false )
-				continue;
-				
-			var firstChar = value.charAt(0).toLowerCase();
-			// if no lookup array for this character exists, look it up now
-			if( !stMatchSets[firstChar] ) 
-				stMatchSets[firstChar] = [];
+    // no url was specified, we need to adjust the cache length to make sure it fits the local data store
+    if( !options.url ) options.cacheLength = 1;
+    
+    // track all options for minChars = 0
+    stMatchSets[""] = [];
+    
+    // loop through the array and create a lookup structure
+    for ( var i = 0, ol = options.data.length; i < ol; i++ ) {
+      var rawValue = options.data[i];
+      // if rawValue is a string, make an array otherwise just reference the array
+      rawValue = (typeof rawValue == "string") ? [rawValue] : rawValue;
+      
+      var value = options.formatMatch(rawValue, i+1, options.data.length);
+      if ( value === false )
+        continue;
+        
+      var firstChar = value.charAt(0).toLowerCase();
+      // if no lookup array for this character exists, look it up now
+      if( !stMatchSets[firstChar] ) 
+        stMatchSets[firstChar] = [];
 
-			// if the match is a string
-			var row = {
-				value: value,
-				data: rawValue,
-				result: options.formatResult && options.formatResult(rawValue) || value
-			};
-			
-			// push the current match into the set list
-			stMatchSets[firstChar].push(row);
+      // if the match is a string
+      var row = {
+        value: value,
+        data: rawValue,
+        result: options.formatResult && options.formatResult(rawValue) || value
+      };
+      
+      // push the current match into the set list
+      stMatchSets[firstChar].push(row);
 
-			// keep track of minChars zero items
-			if ( nullData++ < options.max ) {
-				stMatchSets[""].push(row);
-			}
-		};
+      // keep track of minChars zero items
+      if ( nullData++ < options.max ) {
+        stMatchSets[""].push(row);
+      }
+    };
 
-		// add the data items to the cache
-		$.each(stMatchSets, function(i, value) {
-			// increase the cache size
-			options.cacheLength++;
-			// add to the cache
-			add(i, value);
-		});
-	}
-	
-	// populate any existing data
-	setTimeout(populate, 25);
-	
-	function flush(){
-		data = {};
-		length = 0;
-	}
-	
-	return {
-		flush: flush,
-		add: add,
-		populate: populate,
-		load: function(q) {
-			if (!options.cacheLength || !length)
-				return null;
-			/* 
-			 * if dealing w/local data and matchContains than we must make sure
-			 * to loop through all the data collections looking for matches
-			 */
-			if( !options.url && options.matchContains ){
-				// track all matches
-				var csub = [];
-				// loop through all the data grids for matches
-				for( var k in data ){
-					// don't search through the stMatchSets[""] (minChars: 0) cache
-					// this prevents duplicates
-					if( k.length > 0 ){
-						var c = data[k];
-						$.each(c, function(i, x) {
-							// if we've got a match, add it to the array
-							if (matchSubset(x.value, q)) {
-								csub.push(x);
-							}
-						});
-					}
-				}				
-				return csub;
-			} else 
-			// if the exact item exists, use it
-			if (data[q]){
-				return data[q];
-			} else
-			if (options.matchSubset) {
-				for (var i = q.length - 1; i >= options.minChars; i--) {
-					var c = data[q.substr(0, i)];
-					if (c) {
-						var csub = [];
-						$.each(c, function(i, x) {
-							if (matchSubset(x.value, q)) {
-								csub[csub.length] = x;
-							}
-						});
-						return csub;
-					}
-				}
-			}
-			return null;
-		}
-	};
+    // add the data items to the cache
+    $.each(stMatchSets, function(i, value) {
+      // increase the cache size
+      options.cacheLength++;
+      // add to the cache
+      add(i, value);
+    });
+  }
+  
+  // populate any existing data
+  setTimeout(populate, 25);
+  
+  function flush(){
+    data = {};
+    length = 0;
+  }
+  
+  return {
+    flush: flush,
+    add: add,
+    populate: populate,
+    load: function(q) {
+      if (!options.cacheLength || !length)
+        return null;
+      /* 
+       * if dealing w/local data and matchContains than we must make sure
+       * to loop through all the data collections looking for matches
+       */
+      if( !options.url && options.matchContains ){
+        // track all matches
+        var csub = [];
+        // loop through all the data grids for matches
+        for( var k in data ){
+          // don't search through the stMatchSets[""] (minChars: 0) cache
+          // this prevents duplicates
+          if( k.length > 0 ){
+            var c = data[k];
+            $.each(c, function(i, x) {
+              // if we've got a match, add it to the array
+              if (matchSubset(x.value, q)) {
+                csub.push(x);
+              }
+            });
+          }
+        }        
+        return csub;
+      } else 
+      // if the exact item exists, use it
+      if (data[q]){
+        return data[q];
+      } else
+      if (options.matchSubset) {
+        for (var i = q.length - 1; i >= options.minChars; i--) {
+          var c = data[q.substr(0, i)];
+          if (c) {
+            var csub = [];
+            $.each(c, function(i, x) {
+              if (matchSubset(x.value, q)) {
+                csub[csub.length] = x;
+              }
+            });
+            return csub;
+          }
+        }
+      }
+      return null;
+    }
+  };
 };
 
 $.Autocompleter.Select = function (options, input, select, config) {
-	var CLASSES = {
-		ACTIVE: "ac_over"
-	};
-	
-	var listItems,
-		active = -1,
-		data,
-		term = "",
-		needsInit = true,
-		element,
-		list;
-	
-	// Create results
-	function init() {
-		if (!needsInit)
-			return;
-		element = $("<div/>")
-		.hide()
-		.addClass(options.resultsClass)
-		.css("position", "absolute")
-		.appendTo(document.body);
-	
-		list = $("<ul/>").appendTo(element).mouseover( function(event) {
-			if(target(event).nodeName && target(event).nodeName.toUpperCase() == 'LI') {
-	            active = $("li", list).removeClass(CLASSES.ACTIVE).index(target(event));
-			    $(target(event)).addClass(CLASSES.ACTIVE);            
-	        }
-		}).click(function(event) {
-			$(target(event)).addClass(CLASSES.ACTIVE);
-			select();
-			// TODO provide option to avoid setting focus again after selection? useful for cleanup-on-focus
-			input.focus();
-			return false;
-		}).mousedown(function() {
-			config.mouseDownOnSelect = true;
-		}).mouseup(function() {
-			config.mouseDownOnSelect = false;
-		});
-		
-		if( options.width > 0 )
-			element.css("width", options.width);
-			
-		needsInit = false;
-	} 
-	
-	function target(event) {
-		var element = event.target;
-		while(element && element.tagName != "LI")
-			element = element.parentNode;
-		// more fun with IE, sometimes event.target is empty, just ignore it then
-		if(!element)
-			return [];
-		return element;
-	}
+  var CLASSES = {
+    ACTIVE: "ac_over"
+  };
+  
+  var listItems,
+    active = -1,
+    data,
+    term = "",
+    needsInit = true,
+    element,
+    list;
+  
+  // Create results
+  function init() {
+    if (!needsInit)
+      return;
+    element = $("<div/>")
+    .hide()
+    .addClass(options.resultsClass)
+    .css("position", "absolute")
+    .appendTo(document.body);
+  
+    list = $("<ul/>").appendTo(element).mouseover( function(event) {
+      if(target(event).nodeName && target(event).nodeName.toUpperCase() == 'LI') {
+              active = $("li", list).removeClass(CLASSES.ACTIVE).index(target(event));
+          $(target(event)).addClass(CLASSES.ACTIVE);            
+          }
+    }).click(function(event) {
+      $(target(event)).addClass(CLASSES.ACTIVE);
+      select();
+      // TODO provide option to avoid setting focus again after selection? useful for cleanup-on-focus
+      input.focus();
+      return false;
+    }).mousedown(function() {
+      config.mouseDownOnSelect = true;
+    }).mouseup(function() {
+      config.mouseDownOnSelect = false;
+    });
+    
+    if( options.width > 0 )
+      element.css("width", options.width);
+      
+    needsInit = false;
+  } 
+  
+  function target(event) {
+    var element = event.target;
+    while(element && element.tagName != "LI")
+      element = element.parentNode;
+    // more fun with IE, sometimes event.target is empty, just ignore it then
+    if(!element)
+      return [];
+    return element;
+  }
 
-	function moveSelect(step) {
-		listItems.slice(active, active + 1).removeClass(CLASSES.ACTIVE);
-		movePosition(step);
+  function moveSelect(step) {
+    listItems.slice(active, active + 1).removeClass(CLASSES.ACTIVE);
+    movePosition(step);
         var activeItem = listItems.slice(active, active + 1).addClass(CLASSES.ACTIVE);
         if(options.scroll) {
             var offset = 0;
             listItems.slice(0, active).each(function() {
-				offset += this.offsetHeight;
-			});
+        offset += this.offsetHeight;
+      });
             if((offset + activeItem[0].offsetHeight - list.scrollTop()) > list[0].clientHeight) {
                 list.scrollTop(offset + activeItem[0].offsetHeight - list.innerHeight());
             } else if(offset < list.scrollTop()) {
                 list.scrollTop(offset);
             }
         }
-	};
-	
-	function movePosition(step) {
-		active += step;
-		if (active < 0) {
-			active = listItems.size() - 1;
-		} else if (active >= listItems.size()) {
-			active = 0;
-		}
-	}
-	
-	function limitNumberOfItems(available) {
-		return options.max && options.max < available
-			? options.max
-			: available;
-	}
-	
-	function fillList() {
-		list.empty();
-		var max = limitNumberOfItems(data.length);
-		for (var i=0; i < max; i++) {
-			if (!data[i])
-				continue;
-			var formatted = options.formatItem(data[i].data, i+1, max, data[i].value, term);
-			if ( formatted === false )
-				continue;
-			var li = $("<li/>").html( options.highlight(formatted, term) ).addClass(i%2 == 0 ? "ac_even" : "ac_odd").appendTo(list)[0];
-			$.data(li, "ac_data", data[i]);
-		}
-		listItems = list.find("li");
-		if ( options.selectFirst ) {
-			listItems.slice(0, 1).addClass(CLASSES.ACTIVE);
-			active = 0;
-		}
-		// apply bgiframe if available
-		if ( $.fn.bgiframe )
-			list.bgiframe();
-	}
-	
-	return {
-		display: function(d, q) {
-			init();
-			data = d;
-			term = q;
-			fillList();
-		},
-		next: function() {
-			moveSelect(1);
-		},
-		prev: function() {
-			moveSelect(-1);
-		},
-		pageUp: function() {
-			if (active != 0 && active - 8 < 0) {
-				moveSelect( -active );
-			} else {
-				moveSelect(-8);
-			}
-		},
-		pageDown: function() {
-			if (active != listItems.size() - 1 && active + 8 > listItems.size()) {
-				moveSelect( listItems.size() - 1 - active );
-			} else {
-				moveSelect(8);
-			}
-		},
-		hide: function() {
-			element && element.hide();
-			listItems && listItems.removeClass(CLASSES.ACTIVE);
-			active = -1;
-		},
-		visible : function() {
-			return element && element.is(":visible");
-		},
-		current: function() {
-			return this.visible() && (listItems.filter("." + CLASSES.ACTIVE)[0] || options.selectFirst && listItems[0]);
-		},
-		show: function() {
-			var offset = $(input).offset();
-			element.css({
-				width: typeof options.width == "string" || options.width > 0 ? options.width : $(input).width(),
-				top: offset.top + input.offsetHeight,
-				left: offset.left
-			}).show();
+  };
+  
+  function movePosition(step) {
+    active += step;
+    if (active < 0) {
+      active = listItems.size() - 1;
+    } else if (active >= listItems.size()) {
+      active = 0;
+    }
+  }
+  
+  function limitNumberOfItems(available) {
+    return options.max && options.max < available
+      ? options.max
+      : available;
+  }
+  
+  function fillList() {
+    list.empty();
+    var max = limitNumberOfItems(data.length);
+    for (var i=0; i < max; i++) {
+      if (!data[i])
+        continue;
+      var formatted = options.formatItem(data[i].data, i+1, max, data[i].value, term);
+      if ( formatted === false )
+        continue;
+      var li = $("<li/>").html( options.highlight(formatted, term) ).addClass(i%2 == 0 ? "ac_even" : "ac_odd").appendTo(list)[0];
+      $.data(li, "ac_data", data[i]);
+    }
+    listItems = list.find("li");
+    if ( options.selectFirst ) {
+      listItems.slice(0, 1).addClass(CLASSES.ACTIVE);
+      active = 0;
+    }
+    // apply bgiframe if available
+    if ( $.fn.bgiframe )
+      list.bgiframe();
+  }
+  
+  return {
+    display: function(d, q) {
+      init();
+      data = d;
+      term = q;
+      fillList();
+    },
+    next: function() {
+      moveSelect(1);
+    },
+    prev: function() {
+      moveSelect(-1);
+    },
+    pageUp: function() {
+      if (active != 0 && active - 8 < 0) {
+        moveSelect( -active );
+      } else {
+        moveSelect(-8);
+      }
+    },
+    pageDown: function() {
+      if (active != listItems.size() - 1 && active + 8 > listItems.size()) {
+        moveSelect( listItems.size() - 1 - active );
+      } else {
+        moveSelect(8);
+      }
+    },
+    hide: function() {
+      element && element.hide();
+      listItems && listItems.removeClass(CLASSES.ACTIVE);
+      active = -1;
+    },
+    visible : function() {
+      return element && element.is(":visible");
+    },
+    current: function() {
+      return this.visible() && (listItems.filter("." + CLASSES.ACTIVE)[0] || options.selectFirst && listItems[0]);
+    },
+    show: function() {
+      var offset = $(input).offset();
+      element.css({
+        width: typeof options.width == "string" || options.width > 0 ? options.width : $(input).width(),
+        top: offset.top + input.offsetHeight,
+        left: offset.left
+      }).show();
             if(options.scroll) {
                 list.scrollTop(0);
                 list.css({
-					maxHeight: options.scrollHeight,
-					overflow: 'auto'
-				});
-				
+          maxHeight: options.scrollHeight,
+          overflow: 'auto'
+        });
+        
                 if($.browser.msie && typeof document.body.style.maxHeight === "undefined") {
-					var listHeight = 0;
-					listItems.each(function() {
-						listHeight += this.offsetHeight;
-					});
-					var scrollbarsVisible = listHeight > options.scrollHeight;
+          var listHeight = 0;
+          listItems.each(function() {
+            listHeight += this.offsetHeight;
+          });
+          var scrollbarsVisible = listHeight > options.scrollHeight;
                     list.css('height', scrollbarsVisible ? options.scrollHeight : listHeight );
-					if (!scrollbarsVisible) {
-						// IE doesn't recalculate width when scrollbar disappears
-						listItems.width( list.width() - parseInt(listItems.css("padding-left")) - parseInt(listItems.css("padding-right")) );
-					}
+          if (!scrollbarsVisible) {
+            // IE doesn't recalculate width when scrollbar disappears
+            listItems.width( list.width() - parseInt(listItems.css("padding-left")) - parseInt(listItems.css("padding-right")) );
+          }
                 }
                 
             }
-		},
-		selected: function() {
-			var selected = listItems && listItems.filter("." + CLASSES.ACTIVE).removeClass(CLASSES.ACTIVE);
-			return selected && selected.length && $.data(selected[0], "ac_data");
-		},
-		emptyList: function (){
-			list && list.empty();
-		},
-		unbind: function() {
-			element && element.remove();
-		}
-	};
+    },
+    selected: function() {
+      var selected = listItems && listItems.filter("." + CLASSES.ACTIVE).removeClass(CLASSES.ACTIVE);
+      return selected && selected.length && $.data(selected[0], "ac_data");
+    },
+    emptyList: function (){
+      list && list.empty();
+    },
+    unbind: function() {
+      element && element.remove();
+    }
+  };
 };
 
 $.Autocompleter.Selection = function(field, start, end) {
-	if( field.createTextRange ){
-		var selRange = field.createTextRange();
-		selRange.collapse(true);
-		selRange.moveStart("character", start);
-		selRange.moveEnd("character", end);
-		selRange.select();
-	} else if( field.setSelectionRange ){
-		field.setSelectionRange(start, end);
-	} else {
-		if( field.selectionStart ){
-			field.selectionStart = start;
-			field.selectionEnd = end;
-		}
-	}
-	field.focus();
+  if( field.createTextRange ){
+    var selRange = field.createTextRange();
+    selRange.collapse(true);
+    selRange.moveStart("character", start);
+    selRange.moveEnd("character", end);
+    selRange.select();
+  } else if( field.setSelectionRange ){
+    field.setSelectionRange(start, end);
+  } else {
+    if( field.selectionStart ){
+      field.selectionStart = start;
+      field.selectionEnd = end;
+    }
+  }
+  field.focus();
 };
 
 })(jQuery);
\ No newline at end of file
diff --git a/solr/example/files/conf/velocity/js/jquery.tx3-tag-cloud.js b/solr/example/files/conf/velocity/js/jquery.tx3-tag-cloud.js
index a33104f..3597b4a 100644
--- a/solr/example/files/conf/velocity/js/jquery.tx3-tag-cloud.js
+++ b/solr/example/files/conf/velocity/js/jquery.tx3-tag-cloud.js
@@ -8,25 +8,25 @@
  */
 (function($)
 {
-	var settings;
+  var settings;
     $.fn.tx3TagCloud = function(options)
     {
 
-    	//
-    	// DEFAULT SETTINGS
-    	//
-    	settings = $.extend({
-    		multiplier		: 1
-    	}, options);
-    	main(this);
+      //
+      // DEFAULT SETTINGS
+      //
+      settings = $.extend({
+        multiplier    : 1
+      }, options);
+      main(this);
 
     }
 
     function main(element)
     {
-    	// adding style attr
-    	element.addClass("tx3-tag-cloud");
-    	addListElementFontSize(element);
+      // adding style attr
+      element.addClass("tx3-tag-cloud");
+      addListElementFontSize(element);
     }
 
     /**
@@ -35,36 +35,36 @@
      */
     function addListElementFontSize(element)
     {
-    	var hDataWeight = -9007199254740992;
-    	var lDataWeight = 9007199254740992;
-    	$.each(element.find("li"), function(){
-    		cDataWeight = getDataWeight(this);
-    		if (cDataWeight == undefined)
-    		{
-    			logWarning("No \"data-weight\" attribut defined on <li> element");
-    		}
-    		else
-    		{
-    			hDataWeight = cDataWeight > hDataWeight ? cDataWeight : hDataWeight;
-    			lDataWeight = cDataWeight < lDataWeight ? cDataWeight : lDataWeight;
-    		}
-    	});
-    	$.each(element.find("li"), function(){
-    		var dataWeight = getDataWeight(this);
-    		var percent = Math.abs((dataWeight - lDataWeight)/(lDataWeight - hDataWeight));
-    		$(this).css('font-size', (1 + (percent * settings['multiplier'])) + "em");
-    	});
+      var hDataWeight = -9007199254740992;
+      var lDataWeight = 9007199254740992;
+      $.each(element.find("li"), function(){
+        cDataWeight = getDataWeight(this);
+        if (cDataWeight == undefined)
+        {
+          logWarning("No \"data-weight\" attribut defined on <li> element");
+        }
+        else
+        {
+          hDataWeight = cDataWeight > hDataWeight ? cDataWeight : hDataWeight;
+          lDataWeight = cDataWeight < lDataWeight ? cDataWeight : lDataWeight;
+        }
+      });
+      $.each(element.find("li"), function(){
+        var dataWeight = getDataWeight(this);
+        var percent = Math.abs((dataWeight - lDataWeight)/(lDataWeight - hDataWeight));
+        $(this).css('font-size', (1 + (percent * settings['multiplier'])) + "em");
+      });
 
     }
 
     function getDataWeight(element)
     {
-    	return parseInt($(element).attr("data-weight"));
+      return parseInt($(element).attr("data-weight"));
     }
 
     function logWarning(message)
     {
-    	console.log("[WARNING] " + Date.now() + " : " + message);
+      console.log("[WARNING] " + Date.now() + " : " + message);
     }
 
 }(jQuery));
\ No newline at end of file
diff --git a/solr/server/build.xml b/solr/server/build.xml
index b416235..9a2061f 100644
--- a/solr/server/build.xml
+++ b/solr/server/build.xml
@@ -40,7 +40,7 @@
     <sequential>
     <!-- jetty libs in lib/ -->
     <ivy:retrieve conf="jetty,servlet" type="jar" log="download-only" symlink="${ivy.symlink}"
-    	          pattern="lib/[artifact]-[revision].[ext]" sync="true"/>
+                pattern="lib/[artifact]-[revision].[ext]" sync="true"/>
     <ivy:retrieve conf="logging" type="jar,bundle" log="download-only" symlink="${ivy.symlink}"
                   pattern="lib/ext/[artifact]-[revision].[ext]" sync="true"/>
     <!-- start.jar - we don't use sync=true here, we don't own the dir, but
diff --git a/solr/server/solr/configsets/basic_configs/conf/schema.xml b/solr/server/solr/configsets/basic_configs/conf/schema.xml
index e10373e..23d1997 100644
--- a/solr/server/solr/configsets/basic_configs/conf/schema.xml
+++ b/solr/server/solr/configsets/basic_configs/conf/schema.xml
@@ -194,8 +194,8 @@
     <!-- sortMissingLast and sortMissingFirst attributes are optional attributes are
          currently supported on types that are sorted internally as strings
          and on numeric types.
-	     This includes "string","boolean", and, as of 3.5 (and 4.x),
-	     int, float, long, date, double, including the "Trie" variants.
+       This includes "string","boolean", and, as of 3.5 (and 4.x),
+       int, float, long, date, double, including the "Trie" variants.
        - If sortMissingLast="true", then a sort on this field will cause documents
          without the field to come after documents with the field,
          regardless of the requested sort order (asc or desc).
@@ -306,9 +306,9 @@
 
     <!-- A general text field that has reasonable, generic
          cross-language defaults: it tokenizes with StandardTokenizer,
-	 removes stop words from case-insensitive "stopwords.txt"
-	 (empty by default), and down cases.  At query time only, it
-	 also applies synonyms. -->
+   removes stop words from case-insensitive "stopwords.txt"
+   (empty by default), and down cases.  At query time only, it
+   also applies synonyms. -->
     <fieldType name="text_general" class="solr.TextField" positionIncrementGap="100">
       <analyzer type="index">
         <tokenizer class="solr.StandardTokenizerFactory"/>
@@ -344,11 +344,11 @@
                 words="lang/stopwords_en.txt"
                 />
         <filter class="solr.LowerCaseFilterFactory"/>
-	<filter class="solr.EnglishPossessiveFilterFactory"/>
+  <filter class="solr.EnglishPossessiveFilterFactory"/>
         <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-	<!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
         <filter class="solr.EnglishMinimalStemFilterFactory"/>
-	-->
+  -->
         <filter class="solr.PorterStemFilterFactory"/>
       </analyzer>
       <analyzer type="query">
@@ -359,23 +359,23 @@
                 words="lang/stopwords_en.txt"
                 />
         <filter class="solr.LowerCaseFilterFactory"/>
-	<filter class="solr.EnglishPossessiveFilterFactory"/>
+  <filter class="solr.EnglishPossessiveFilterFactory"/>
         <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-	<!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
         <filter class="solr.EnglishMinimalStemFilterFactory"/>
-	-->
+  -->
         <filter class="solr.PorterStemFilterFactory"/>
       </analyzer>
     </fieldType>
 
     <!-- A text field with defaults appropriate for English, plus
-	 aggressive word-splitting and autophrase features enabled.
-	 This field is just like text_en, except it adds
-	 WordDelimiterFilter to enable splitting and matching of
-	 words on case-change, alpha numeric boundaries, and
-	 non-alphanumeric chars.  This means certain compound word
-	 cases will work, for example query "wi fi" will match
-	 document "WiFi" or "wi-fi".
+   aggressive word-splitting and autophrase features enabled.
+   This field is just like text_en, except it adds
+   WordDelimiterFilter to enable splitting and matching of
+   words on case-change, alpha numeric boundaries, and
+   non-alphanumeric chars.  This means certain compound word
+   cases will work, for example query "wi fi" will match
+   document "WiFi" or "wi-fi".
         -->
     <fieldType name="text_en_splitting" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true">
       <analyzer type="index">
@@ -426,7 +426,7 @@
     </fieldType>
 
     <!-- Just like text_general except it reverses the characters of
-	 each token, to enable more efficient leading wildcard queries. -->
+   each token, to enable more efficient leading wildcard queries. -->
     <fieldType name="text_general_rev" class="solr.TextField" positionIncrementGap="100">
       <analyzer type="index">
         <tokenizer class="solr.StandardTokenizerFactory"/>
diff --git a/solr/server/solr/configsets/data_driven_schema_configs/conf/solrconfig.xml b/solr/server/solr/configsets/data_driven_schema_configs/conf/solrconfig.xml
index c3988ae..8721a66 100644
--- a/solr/server/solr/configsets/data_driven_schema_configs/conf/solrconfig.xml
+++ b/solr/server/solr/configsets/data_driven_schema_configs/conf/solrconfig.xml
@@ -1094,7 +1094,7 @@
       <!-- maximum threshold of documents a query term can appear to be considered for correction -->
       <float name="maxQueryFrequency">0.01</float>
       <!-- uncomment this to require suggestions to occur in 1% of the documents
-      	<float name="thresholdTokenFrequency">.01</float>
+        <float name="thresholdTokenFrequency">.01</float>
       -->
     </lst>
 
diff --git a/solr/server/solr/configsets/sample_techproducts_configs/conf/schema.xml b/solr/server/solr/configsets/sample_techproducts_configs/conf/schema.xml
index 03a9903..3929b8b 100644
--- a/solr/server/solr/configsets/sample_techproducts_configs/conf/schema.xml
+++ b/solr/server/solr/configsets/sample_techproducts_configs/conf/schema.xml
@@ -298,12 +298,12 @@
 
    <!-- Create a string version of author for faceting -->
    <copyField source="author" dest="author_s"/>
-	
+  
    <!-- Above, multiple source fields are copied to the [text] field. 
-	  Another way to map multiple source fields to the same 
-	  destination field is to use the dynamic field syntax. 
-	  copyField also supports a maxChars to copy setting.  -->
-	   
+    Another way to map multiple source fields to the same 
+    destination field is to use the dynamic field syntax. 
+    copyField also supports a maxChars to copy setting.  -->
+     
    <!-- <copyField source="*_t" dest="text" maxChars="3000"/> -->
 
    <!-- copy name to alphaNameSort, a field designed for sorting by name -->
@@ -330,8 +330,8 @@
     <!-- sortMissingLast and sortMissingFirst attributes are optional attributes are
          currently supported on types that are sorted internally as strings
          and on numeric types.
-	     This includes "string","boolean", and, as of 3.5 (and 4.x),
-	     int, float, long, date, double, including the "Trie" variants.
+       This includes "string","boolean", and, as of 3.5 (and 4.x),
+       int, float, long, date, double, including the "Trie" variants.
        - If sortMissingLast="true", then a sort on this field will cause documents
          without the field to come after documents with the field,
          regardless of the requested sort order (asc or desc).
@@ -451,9 +451,9 @@
 
     <!-- A general text field that has reasonable, generic
          cross-language defaults: it tokenizes with StandardTokenizer,
-	 removes stop words from case-insensitive "stopwords.txt"
-	 (empty by default), and down cases.  At query time only, it
-	 also applies synonyms. -->
+   removes stop words from case-insensitive "stopwords.txt"
+   (empty by default), and down cases.  At query time only, it
+   also applies synonyms. -->
     <fieldType name="text_general" class="solr.TextField" positionIncrementGap="100">
       <analyzer type="index">
         <tokenizer class="solr.StandardTokenizerFactory"/>
@@ -489,11 +489,11 @@
                 words="lang/stopwords_en.txt"
                 />
         <filter class="solr.LowerCaseFilterFactory"/>
-	<filter class="solr.EnglishPossessiveFilterFactory"/>
+  <filter class="solr.EnglishPossessiveFilterFactory"/>
         <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-	<!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
         <filter class="solr.EnglishMinimalStemFilterFactory"/>
-	-->
+  -->
         <filter class="solr.PorterStemFilterFactory"/>
       </analyzer>
       <analyzer type="query">
@@ -504,23 +504,23 @@
                 words="lang/stopwords_en.txt"
                 />
         <filter class="solr.LowerCaseFilterFactory"/>
-	<filter class="solr.EnglishPossessiveFilterFactory"/>
+  <filter class="solr.EnglishPossessiveFilterFactory"/>
         <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
-	<!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
+  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
         <filter class="solr.EnglishMinimalStemFilterFactory"/>
-	-->
+  -->
         <filter class="solr.PorterStemFilterFactory"/>
       </analyzer>
     </fieldType>
 
     <!-- A text field with defaults appropriate for English, plus
-	 aggressive word-splitting and autophrase features enabled.
-	 This field is just like text_en, except it adds
-	 WordDelimiterFilter to enable splitting and matching of
-	 words on case-change, alpha numeric boundaries, and
-	 non-alphanumeric chars.  This means certain compound word
-	 cases will work, for example query "wi fi" will match
-	 document "WiFi" or "wi-fi".
+   aggressive word-splitting and autophrase features enabled.
+   This field is just like text_en, except it adds
+   WordDelimiterFilter to enable splitting and matching of
+   words on case-change, alpha numeric boundaries, and
+   non-alphanumeric chars.  This means certain compound word
+   cases will work, for example query "wi fi" will match
+   document "WiFi" or "wi-fi".
         -->
     <fieldType name="text_en_splitting" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true">
       <analyzer type="index">
@@ -571,7 +571,7 @@
     </fieldType>
 
     <!-- Just like text_general except it reverses the characters of
-	 each token, to enable more efficient leading wildcard queries. -->
+   each token, to enable more efficient leading wildcard queries. -->
     <fieldType name="text_general_rev" class="solr.TextField" positionIncrementGap="100">
       <analyzer type="index">
         <tokenizer class="solr.StandardTokenizerFactory"/>
@@ -646,10 +646,10 @@
         a token of "foo|1.4"  would be indexed as "foo" with a payload of 1.4f
         Attributes of the DelimitedPayloadTokenFilterFactory : 
          "delimiter" - a one character delimiter. Default is | (pipe)
-	 "encoder" - how to encode the following value into a playload
-	    float -> org.apache.lucene.analysis.payloads.FloatEncoder,
-	    integer -> o.a.l.a.p.IntegerEncoder
-	    identity -> o.a.l.a.p.IdentityEncoder
+   "encoder" - how to encode the following value into a playload
+      float -> org.apache.lucene.analysis.payloads.FloatEncoder,
+      integer -> o.a.l.a.p.IntegerEncoder
+      identity -> o.a.l.a.p.IdentityEncoder
             Fully Qualified class name implementing PayloadEncoder, Encoder must have a no arg constructor.
          -->
         <filter class="solr.DelimitedPayloadTokenFilterFactory" encoder="float"/>
@@ -670,10 +670,10 @@
     -->
     <fieldType name="descendent_path" class="solr.TextField">
       <analyzer type="index">
-	<tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
+  <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
       </analyzer>
       <analyzer type="query">
-	<tokenizer class="solr.KeywordTokenizerFactory" />
+  <tokenizer class="solr.KeywordTokenizerFactory" />
       </analyzer>
     </fieldType>
     <!-- 
@@ -682,10 +682,10 @@
     -->
     <fieldType name="ancestor_path" class="solr.TextField">
       <analyzer type="index">
-	<tokenizer class="solr.KeywordTokenizerFactory" />
+  <tokenizer class="solr.KeywordTokenizerFactory" />
       </analyzer>
       <analyzer type="query">
-	<tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
+  <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
       </analyzer>
     </fieldType>
 
diff --git a/solr/server/solr/configsets/sample_techproducts_configs/conf/solrconfig.xml b/solr/server/solr/configsets/sample_techproducts_configs/conf/solrconfig.xml
index 02d61f8..a6e2c47 100644
--- a/solr/server/solr/configsets/sample_techproducts_configs/conf/solrconfig.xml
+++ b/solr/server/solr/configsets/sample_techproducts_configs/conf/solrconfig.xml
@@ -1212,7 +1212,7 @@
       <!-- maximum threshold of documents a query term can appear to be considered for correction -->
       <float name="maxQueryFrequency">0.01</float>
       <!-- uncomment this to require suggestions to occur in 1% of the documents
-      	<float name="thresholdTokenFrequency">.01</float>
+        <float name="thresholdTokenFrequency">.01</float>
       -->
     </lst>
     
diff --git a/solr/server/solr/configsets/sample_techproducts_configs/conf/velocity/jquery.autocomplete.js b/solr/server/solr/configsets/sample_techproducts_configs/conf/velocity/jquery.autocomplete.js
index 4a218dc..442f5a0 100644
--- a/solr/server/solr/configsets/sample_techproducts_configs/conf/velocity/jquery.autocomplete.js
+++ b/solr/server/solr/configsets/sample_techproducts_configs/conf/velocity/jquery.autocomplete.js
@@ -12,752 +12,752 @@
  */
 
 ;(function($) {
-	
+  
 $.fn.extend({
-	autocomplete: function(urlOrData, options) {
-		var isUrl = typeof urlOrData == "string";
-		options = $.extend({}, $.Autocompleter.defaults, {
-			url: isUrl ? urlOrData : null,
-			data: isUrl ? null : urlOrData,
-			delay: isUrl ? $.Autocompleter.defaults.delay : 10,
-			max: options && !options.scroll ? 10 : 150
-		}, options);
-		
-		// if highlight is set to false, replace it with a do-nothing function
-		options.highlight = options.highlight || function(value) { return value; };
-		
-		// if the formatMatch option is not specified, then use formatItem for backwards compatibility
-		options.formatMatch = options.formatMatch || options.formatItem;
-		
-		return this.each(function() {
-			new $.Autocompleter(this, options);
-		});
-	},
-	result: function(handler) {
-		return this.bind("result", handler);
-	},
-	search: function(handler) {
-		return this.trigger("search", [handler]);
-	},
-	flushCache: function() {
-		return this.trigger("flushCache");
-	},
-	setOptions: function(options){
-		return this.trigger("setOptions", [options]);
-	},
-	unautocomplete: function() {
-		return this.trigger("unautocomplete");
-	}
+  autocomplete: function(urlOrData, options) {
+    var isUrl = typeof urlOrData == "string";
+    options = $.extend({}, $.Autocompleter.defaults, {
+      url: isUrl ? urlOrData : null,
+      data: isUrl ? null : urlOrData,
+      delay: isUrl ? $.Autocompleter.defaults.delay : 10,
+      max: options && !options.scroll ? 10 : 150
+    }, options);
+    
+    // if highlight is set to false, replace it with a do-nothing function
+    options.highlight = options.highlight || function(value) { return value; };
+    
+    // if the formatMatch option is not specified, then use formatItem for backwards compatibility
+    options.formatMatch = options.formatMatch || options.formatItem;
+    
+    return this.each(function() {
+      new $.Autocompleter(this, options);
+    });
+  },
+  result: function(handler) {
+    return this.bind("result", handler);
+  },
+  search: function(handler) {
+    return this.trigger("search", [handler]);
+  },
+  flushCache: function() {
+    return this.trigger("flushCache");
+  },
+  setOptions: function(options){
+    return this.trigger("setOptions", [options]);
+  },
+  unautocomplete: function() {
+    return this.trigger("unautocomplete");
+  }
 });
 
 $.Autocompleter = function(input, options) {
 
-	var KEY = {
-		UP: 38,
-		DOWN: 40,
-		DEL: 46,
-		TAB: 9,
-		RETURN: 13,
-		ESC: 27,
-		COMMA: 188,
-		PAGEUP: 33,
-		PAGEDOWN: 34,
-		BACKSPACE: 8
-	};
+  var KEY = {
+    UP: 38,
+    DOWN: 40,
+    DEL: 46,
+    TAB: 9,
+    RETURN: 13,
+    ESC: 27,
+    COMMA: 188,
+    PAGEUP: 33,
+    PAGEDOWN: 34,
+    BACKSPACE: 8
+  };
 
-	// Create $ object for input element
-	var $input = $(input).attr("autocomplete", "off").addClass(options.inputClass);
+  // Create $ object for input element
+  var $input = $(input).attr("autocomplete", "off").addClass(options.inputClass);
 
-	var timeout;
-	var previousValue = "";
-	var cache = $.Autocompleter.Cache(options);
-	var hasFocus = 0;
-	var lastKeyPressCode;
-	var config = {
-		mouseDownOnSelect: false
-	};
-	var select = $.Autocompleter.Select(options, input, selectCurrent, config);
-	
-	var blockSubmit;
-	
-	// prevent form submit in opera when selecting with return key
-	$.browser.opera && $(input.form).bind("submit.autocomplete", function() {
-		if (blockSubmit) {
-			blockSubmit = false;
-			return false;
-		}
-	});
-	
-	// only opera doesn't trigger keydown multiple times while pressed, others don't work with keypress at all
-	$input.bind(($.browser.opera ? "keypress" : "keydown") + ".autocomplete", function(event) {
-		// track last key pressed
-		lastKeyPressCode = event.keyCode;
-		switch(event.keyCode) {
-		
-			case KEY.UP:
-				event.preventDefault();
-				if ( select.visible() ) {
-					select.prev();
-				} else {
-					onChange(0, true);
-				}
-				break;
-				
-			case KEY.DOWN:
-				event.preventDefault();
-				if ( select.visible() ) {
-					select.next();
-				} else {
-					onChange(0, true);
-				}
-				break;
-				
-			case KEY.PAGEUP:
-				event.preventDefault();
-				if ( select.visible() ) {
-					select.pageUp();
-				} else {
-					onChange(0, true);
-				}
-				break;
-				
-			case KEY.PAGEDOWN:
-				event.preventDefault();
-				if ( select.visible() ) {
-					select.pageDown();
-				} else {
-					onChange(0, true);
-				}
-				break;
-			
-			// matches also semicolon
-			case options.multiple && $.trim(options.multipleSeparator) == "," && KEY.COMMA:
-			case KEY.TAB:
-			case KEY.RETURN:
-				if( selectCurrent() ) {
-					// stop default to prevent a form submit, Opera needs special handling
-					event.preventDefault();
-					blockSubmit = true;
-					return false;
-				}
-				break;
-				
-			case KEY.ESC:
-				select.hide();
-				break;
-				
-			default:
-				clearTimeout(timeout);
-				timeout = setTimeout(onChange, options.delay);
-				break;
-		}
-	}).focus(function(){
-		// track whether the field has focus, we shouldn't process any
-		// results if the field no longer has focus
-		hasFocus++;
-	}).blur(function() {
-		hasFocus = 0;
-		if (!config.mouseDownOnSelect) {
-			hideResults();
-		}
-	}).click(function() {
-		// show select when clicking in a focused field
-		if ( hasFocus++ > 1 && !select.visible() ) {
-			onChange(0, true);
-		}
-	}).bind("search", function() {
-		// TODO why not just specifying both arguments?
-		var fn = (arguments.length > 1) ? arguments[1] : null;
-		function findValueCallback(q, data) {
-			var result;
-			if( data && data.length ) {
-				for (var i=0; i < data.length; i++) {
-					if( data[i].result.toLowerCase() == q.toLowerCase() ) {
-						result = data[i];
-						break;
-					}
-				}
-			}
-			if( typeof fn == "function" ) fn(result);
-			else $input.trigger("result", result && [result.data, result.value]);
-		}
-		$.each(trimWords($input.val()), function(i, value) {
-			request(value, findValueCallback, findValueCallback);
-		});
-	}).bind("flushCache", function() {
-		cache.flush();
-	}).bind("setOptions", function() {
-		$.extend(options, arguments[1]);
-		// if we've updated the data, repopulate
-		if ( "data" in arguments[1] )
-			cache.populate();
-	}).bind("unautocomplete", function() {
-		select.unbind();
-		$input.unbind();
-		$(input.form).unbind(".autocomplete");
-	});
-	
-	
-	function selectCurrent() {
-		var selected = select.selected();
-		if( !selected )
-			return false;
-		
-		var v = selected.result;
-		previousValue = v;
-		
-		if ( options.multiple ) {
-			var words = trimWords($input.val());
-			if ( words.length > 1 ) {
-				v = words.slice(0, words.length - 1).join( options.multipleSeparator ) + options.multipleSeparator + v;
-			}
-			v += options.multipleSeparator;
-		}
-		
-		$input.val(v);
-		hideResultsNow();
-		$input.trigger("result", [selected.data, selected.value]);
-		return true;
-	}
-	
-	function onChange(crap, skipPrevCheck) {
-		if( lastKeyPressCode == KEY.DEL ) {
-			select.hide();
-			return;
-		}
-		
-		var currentValue = $input.val();
-		
-		if ( !skipPrevCheck && currentValue == previousValue )
-			return;
-		
-		previousValue = currentValue;
-		
-		currentValue = lastWord(currentValue);
-		if ( currentValue.length >= options.minChars) {
-			$input.addClass(options.loadingClass);
-			if (!options.matchCase)
-				currentValue = currentValue.toLowerCase();
-			request(currentValue, receiveData, hideResultsNow);
-		} else {
-			stopLoading();
-			select.hide();
-		}
-	};
-	
-	function trimWords(value) {
-		if ( !value ) {
-			return [""];
-		}
-		var words = value.split( options.multipleSeparator );
-		var result = [];
-		$.each(words, function(i, value) {
-			if ( $.trim(value) )
-				result[i] = $.trim(value);
-		});
-		return result;
-	}
-	
-	function lastWord(value) {
-		if ( !options.multiple )
-			return value;
-		var words = trimWords(value);
-		return words[words.length - 1];
-	}
-	
-	// fills in the input box w/the first match (assumed to be the best match)
-	// q: the term entered
-	// sValue: the first matching result
-	function autoFill(q, sValue){
-		// autofill in the complete box w/the first match as long as the user hasn't entered in more data
-		// if the last user key pressed was backspace, don't autofill
-		if( options.autoFill && (lastWord($input.val()).toLowerCase() == q.toLowerCase()) && lastKeyPressCode != KEY.BACKSPACE ) {
-			// fill in the value (keep the case the user has typed)
-			$input.val($input.val() + sValue.substring(lastWord(previousValue).length));
-			// select the portion of the value not typed by the user (so the next character will erase)
-			$.Autocompleter.Selection(input, previousValue.length, previousValue.length + sValue.length);
-		}
-	};
+  var timeout;
+  var previousValue = "";
+  var cache = $.Autocompleter.Cache(options);
+  var hasFocus = 0;
+  var lastKeyPressCode;
+  var config = {
+    mouseDownOnSelect: false
+  };
+  var select = $.Autocompleter.Select(options, input, selectCurrent, config);
+  
+  var blockSubmit;
+  
+  // prevent form submit in opera when selecting with return key
+  $.browser.opera && $(input.form).bind("submit.autocomplete", function() {
+    if (blockSubmit) {
+      blockSubmit = false;
+      return false;
+    }
+  });
+  
+  // only opera doesn't trigger keydown multiple times while pressed, others don't work with keypress at all
+  $input.bind(($.browser.opera ? "keypress" : "keydown") + ".autocomplete", function(event) {
+    // track last key pressed
+    lastKeyPressCode = event.keyCode;
+    switch(event.keyCode) {
+    
+      case KEY.UP:
+        event.preventDefault();
+        if ( select.visible() ) {
+          select.prev();
+        } else {
+          onChange(0, true);
+        }
+        break;
+        
+      case KEY.DOWN:
+        event.preventDefault();
+        if ( select.visible() ) {
+          select.next();
+        } else {
+          onChange(0, true);
+        }
+        break;
+        
+      case KEY.PAGEUP:
+        event.preventDefault();
+        if ( select.visible() ) {
+          select.pageUp();
+        } else {
+          onChange(0, true);
+        }
+        break;
+        
+      case KEY.PAGEDOWN:
+        event.preventDefault();
+        if ( select.visible() ) {
+          select.pageDown();
+        } else {
+          onChange(0, true);
+        }
+        break;
+      
+      // matches also semicolon
+      case options.multiple && $.trim(options.multipleSeparator) == "," && KEY.COMMA:
+      case KEY.TAB:
+      case KEY.RETURN:
+        if( selectCurrent() ) {
+          // stop default to prevent a form submit, Opera needs special handling
+          event.preventDefault();
+          blockSubmit = true;
+          return false;
+        }
+        break;
+        
+      case KEY.ESC:
+        select.hide();
+        break;
+        
+      default:
+        clearTimeout(timeout);
+        timeout = setTimeout(onChange, options.delay);
+        break;
+    }
+  }).focus(function(){
+    // track whether the field has focus, we shouldn't process any
+    // results if the field no longer has focus
+    hasFocus++;
+  }).blur(function() {
+    hasFocus = 0;
+    if (!config.mouseDownOnSelect) {
+      hideResults();
+    }
+  }).click(function() {
+    // show select when clicking in a focused field
+    if ( hasFocus++ > 1 && !select.visible() ) {
+      onChange(0, true);
+    }
+  }).bind("search", function() {
+    // TODO why not just specifying both arguments?
+    var fn = (arguments.length > 1) ? arguments[1] : null;
+    function findValueCallback(q, data) {
+      var result;
+      if( data && data.length ) {
+        for (var i=0; i < data.length; i++) {
+          if( data[i].result.toLowerCase() == q.toLowerCase() ) {
+            result = data[i];
+            break;
+          }
+        }
+      }
+      if( typeof fn == "function" ) fn(result);
+      else $input.trigger("result", result && [result.data, result.value]);
+    }
+    $.each(trimWords($input.val()), function(i, value) {
+      request(value, findValueCallback, findValueCallback);
+    });
+  }).bind("flushCache", function() {
+    cache.flush();
+  }).bind("setOptions", function() {
+    $.extend(options, arguments[1]);
+    // if we've updated the data, repopulate
+    if ( "data" in arguments[1] )
+      cache.populate();
+  }).bind("unautocomplete", function() {
+    select.unbind();
+    $input.unbind();
+    $(input.form).unbind(".autocomplete");
+  });
+  
+  
+  function selectCurrent() {
+    var selected = select.selected();
+    if( !selected )
+      return false;
+    
+    var v = selected.result;
+    previousValue = v;
+    
+    if ( options.multiple ) {
+      var words = trimWords($input.val());
+      if ( words.length > 1 ) {
+        v = words.slice(0, words.length - 1).join( options.multipleSeparator ) + options.multipleSeparator + v;
+      }
+      v += options.multipleSeparator;
+    }
+    
+    $input.val(v);
+    hideResultsNow();
+    $input.trigger("result", [selected.data, selected.value]);
+    return true;
+  }
+  
+  function onChange(crap, skipPrevCheck) {
+    if( lastKeyPressCode == KEY.DEL ) {
+      select.hide();
+      return;
+    }
+    
+    var currentValue = $input.val();
+    
+    if ( !skipPrevCheck && currentValue == previousValue )
+      return;
+    
+    previousValue = currentValue;
+    
+    currentValue = lastWord(currentValue);
+    if ( currentValue.length >= options.minChars) {
+      $input.addClass(options.loadingClass);
+      if (!options.matchCase)
+        currentValue = currentValue.toLowerCase();
+      request(currentValue, receiveData, hideResultsNow);
+    } else {
+      stopLoading();
+      select.hide();
+    }
+  };
+  
+  function trimWords(value) {
+    if ( !value ) {
+      return [""];
+    }
+    var words = value.split( options.multipleSeparator );
+    var result = [];
+    $.each(words, function(i, value) {
+      if ( $.trim(value) )
+        result[i] = $.trim(value);
+    });
+    return result;
+  }
+  
+  function lastWord(value) {
+    if ( !options.multiple )
+      return value;
+    var words = trimWords(value);
+    return words[words.length - 1];
+  }
+  
+  // fills in the input box w/the first match (assumed to be the best match)
+  // q: the term entered
+  // sValue: the first matching result
+  function autoFill(q, sValue){
+    // autofill in the complete box w/the first match as long as the user hasn't entered in more data
+    // if the last user key pressed was backspace, don't autofill
+    if( options.autoFill && (lastWord($input.val()).toLowerCase() == q.toLowerCase()) && lastKeyPressCode != KEY.BACKSPACE ) {
+      // fill in the value (keep the case the user has typed)
+      $input.val($input.val() + sValue.substring(lastWord(previousValue).length));
+      // select the portion of the value not typed by the user (so the next character will erase)
+      $.Autocompleter.Selection(input, previousValue.length, previousValue.length + sValue.length);
+    }
+  };
 
-	function hideResults() {
-		clearTimeout(timeout);
-		timeout = setTimeout(hideResultsNow, 200);
-	};
+  function hideResults() {
+    clearTimeout(timeout);
+    timeout = setTimeout(hideResultsNow, 200);
+  };
 
-	function hideResultsNow() {
-		var wasVisible = select.visible();
-		select.hide();
-		clearTimeout(timeout);
-		stopLoading();
-		if (options.mustMatch) {
-			// call search and run callback
-			$input.search(
-				function (result){
-					// if no value found, clear the input box
-					if( !result ) {
-						if (options.multiple) {
-							var words = trimWords($input.val()).slice(0, -1);
-							$input.val( words.join(options.multipleSeparator) + (words.length ? options.multipleSeparator : "") );
-						}
-						else
-							$input.val( "" );
-					}
-				}
-			);
-		}
-		if (wasVisible)
-			// position cursor at end of input field
-			$.Autocompleter.Selection(input, input.value.length, input.value.length);
-	};
+  function hideResultsNow() {
+    var wasVisible = select.visible();
+    select.hide();
+    clearTimeout(timeout);
+    stopLoading();
+    if (options.mustMatch) {
+      // call search and run callback
+      $input.search(
+        function (result){
+          // if no value found, clear the input box
+          if( !result ) {
+            if (options.multiple) {
+              var words = trimWords($input.val()).slice(0, -1);
+              $input.val( words.join(options.multipleSeparator) + (words.length ? options.multipleSeparator : "") );
+            }
+            else
+              $input.val( "" );
+          }
+        }
+      );
+    }
+    if (wasVisible)
+      // position cursor at end of input field
+      $.Autocompleter.Selection(input, input.value.length, input.value.length);
+  };
 
-	function receiveData(q, data) {
-		if ( data && data.length && hasFocus ) {
-			stopLoading();
-			select.display(data, q);
-			autoFill(q, data[0].value);
-			select.show();
-		} else {
-			hideResultsNow();
-		}
-	};
+  function receiveData(q, data) {
+    if ( data && data.length && hasFocus ) {
+      stopLoading();
+      select.display(data, q);
+      autoFill(q, data[0].value);
+      select.show();
+    } else {
+      hideResultsNow();
+    }
+  };
 
-	function request(term, success, failure) {
-		if (!options.matchCase)
-			term = term.toLowerCase();
-		var data = cache.load(term);
-		data = null; // Avoid buggy cache and go to Solr every time 
-		// recieve the cached data
-		if (data && data.length) {
-			success(term, data);
-		// if an AJAX url has been supplied, try loading the data now
-		} else if( (typeof options.url == "string") && (options.url.length > 0) ){
-			
-			var extraParams = {
-				timestamp: +new Date()
-			};
-			$.each(options.extraParams, function(key, param) {
-				extraParams[key] = typeof param == "function" ? param() : param;
-			});
-			
-			$.ajax({
-				// try to leverage ajaxQueue plugin to abort previous requests
-				mode: "abort",
-				// limit abortion to this input
-				port: "autocomplete" + input.name,
-				dataType: options.dataType,
-				url: options.url,
-				data: $.extend({
-					q: lastWord(term),
-					limit: options.max
-				}, extraParams),
-				success: function(data) {
-					var parsed = options.parse && options.parse(data) || parse(data);
-					cache.add(term, parsed);
-					success(term, parsed);
-				}
-			});
-		} else {
-			// if we have a failure, we need to empty the list -- this prevents the the [TAB] key from selecting the last successful match
-			select.emptyList();
-			failure(term);
-		}
-	};
-	
-	function parse(data) {
-		var parsed = [];
-		var rows = data.split("\n");
-		for (var i=0; i < rows.length; i++) {
-			var row = $.trim(rows[i]);
-			if (row) {
-				row = row.split("|");
-				parsed[parsed.length] = {
-					data: row,
-					value: row[0],
-					result: options.formatResult && options.formatResult(row, row[0]) || row[0]
-				};
-			}
-		}
-		return parsed;
-	};
+  function request(term, success, failure) {
+    if (!options.matchCase)
+      term = term.toLowerCase();
+    var data = cache.load(term);
+    data = null; // Avoid buggy cache and go to Solr every time 
+    // recieve the cached data
+    if (data && data.length) {
+      success(term, data);
+    // if an AJAX url has been supplied, try loading the data now
+    } else if( (typeof options.url == "string") && (options.url.length > 0) ){
+      
+      var extraParams = {
+        timestamp: +new Date()
+      };
+      $.each(options.extraParams, function(key, param) {
+        extraParams[key] = typeof param == "function" ? param() : param;
+      });
+      
+      $.ajax({
+        // try to leverage ajaxQueue plugin to abort previous requests
+        mode: "abort",
+        // limit abortion to this input
+        port: "autocomplete" + input.name,
+        dataType: options.dataType,
+        url: options.url,
+        data: $.extend({
+          q: lastWord(term),
+          limit: options.max
+        }, extraParams),
+        success: function(data) {
+          var parsed = options.parse && options.parse(data) || parse(data);
+          cache.add(term, parsed);
+          success(term, parsed);
+        }
+      });
+    } else {
+      // if we have a failure, we need to empty the list -- this prevents the the [TAB] key from selecting the last successful match
+      select.emptyList();
+      failure(term);
+    }
+  };
+  
+  function parse(data) {
+    var parsed = [];
+    var rows = data.split("\n");
+    for (var i=0; i < rows.length; i++) {
+      var row = $.trim(rows[i]);
+      if (row) {
+        row = row.split("|");
+        parsed[parsed.length] = {
+          data: row,
+          value: row[0],
+          result: options.formatResult && options.formatResult(row, row[0]) || row[0]
+        };
+      }
+    }
+    return parsed;
+  };
 
-	function stopLoading() {
-		$input.removeClass(options.loadingClass);
-	};
+  function stopLoading() {
+    $input.removeClass(options.loadingClass);
+  };
 
 };
 
 $.Autocompleter.defaults = {
-	inputClass: "ac_input",
-	resultsClass: "ac_results",
-	loadingClass: "ac_loading",
-	minChars: 1,
-	delay: 400,
-	matchCase: false,
-	matchSubset: true,
-	matchContains: false,
-	cacheLength: 10,
-	max: 100,
-	mustMatch: false,
-	extraParams: {},
-	selectFirst: false,
-	formatItem: function(row) { return row[0]; },
-	formatMatch: null,
-	autoFill: false,
-	width: 0,
-	multiple: false,
-	multipleSeparator: ", ",
-	highlight: function(value, term) {
-		return value.replace(new RegExp("(?![^&;]+;)(?!<[^<>]*)(" + term.replace(/([\^\$\(\)\[\]\{\}\*\.\+\?\|\\])/gi, "\\$1") + ")(?![^<>]*>)(?![^&;]+;)", "gi"), "<strong>$1</strong>");
-	},
+  inputClass: "ac_input",
+  resultsClass: "ac_results",
+  loadingClass: "ac_loading",
+  minChars: 1,
+  delay: 400,
+  matchCase: false,
+  matchSubset: true,
+  matchContains: false,
+  cacheLength: 10,
+  max: 100,
+  mustMatch: false,
+  extraParams: {},
+  selectFirst: false,
+  formatItem: function(row) { return row[0]; },
+  formatMatch: null,
+  autoFill: false,
+  width: 0,
+  multiple: false,
+  multipleSeparator: ", ",
+  highlight: function(value, term) {
+    return value.replace(new RegExp("(?![^&;]+;)(?!<[^<>]*)(" + term.replace(/([\^\$\(\)\[\]\{\}\*\.\+\?\|\\])/gi, "\\$1") + ")(?![^<>]*>)(?![^&;]+;)", "gi"), "<strong>$1</strong>");
+  },
     scroll: true,
     scrollHeight: 180
 };
 
 $.Autocompleter.Cache = function(options) {
 
-	var data = {};
-	var length = 0;
-	
-	function matchSubset(s, sub) {
-		if (!options.matchCase) 
-			s = s.toLowerCase();
-		var i = s.indexOf(sub);
-		if (options.matchContains == "word"){
-			i = s.toLowerCase().search("\\b" + sub.toLowerCase());
-		}
-		if (i == -1) return false;
-		return i == 0 || options.matchContains;
-	};
-	
-	function add(q, value) {
-		if (length > options.cacheLength){
-			flush();
-		}
-		if (!data[q]){ 
-			length++;
-		}
-		data[q] = value;
-	}
-	
-	function populate(){
-		if( !options.data ) return false;
-		// track the matches
-		var stMatchSets = {},
-			nullData = 0;
+  var data = {};
+  var length = 0;
+  
+  function matchSubset(s, sub) {
+    if (!options.matchCase) 
+      s = s.toLowerCase();
+    var i = s.indexOf(sub);
+    if (options.matchContains == "word"){
+      i = s.toLowerCase().search("\\b" + sub.toLowerCase());
+    }
+    if (i == -1) return false;
+    return i == 0 || options.matchContains;
+  };
+  
+  function add(q, value) {
+    if (length > options.cacheLength){
+      flush();
+    }
+    if (!data[q]){ 
+      length++;
+    }
+    data[q] = value;
+  }
+  
+  function populate(){
+    if( !options.data ) return false;
+    // track the matches
+    var stMatchSets = {},
+      nullData = 0;
 
-		// no url was specified, we need to adjust the cache length to make sure it fits the local data store
-		if( !options.url ) options.cacheLength = 1;
-		
-		// track all options for minChars = 0
-		stMatchSets[""] = [];
-		
-		// loop through the array and create a lookup structure
-		for ( var i = 0, ol = options.data.length; i < ol; i++ ) {
-			var rawValue = options.data[i];
-			// if rawValue is a string, make an array otherwise just reference the array
-			rawValue = (typeof rawValue == "string") ? [rawValue] : rawValue;
-			
-			var value = options.formatMatch(rawValue, i+1, options.data.length);
-			if ( value === false )
-				continue;
-				
-			var firstChar = value.charAt(0).toLowerCase();
-			// if no lookup array for this character exists, look it up now
-			if( !stMatchSets[firstChar] ) 
-				stMatchSets[firstChar] = [];
+    // no url was specified, we need to adjust the cache length to make sure it fits the local data store
+    if( !options.url ) options.cacheLength = 1;
+    
+    // track all options for minChars = 0
+    stMatchSets[""] = [];
+    
+    // loop through the array and create a lookup structure
+    for ( var i = 0, ol = options.data.length; i < ol; i++ ) {
+      var rawValue = options.data[i];
+      // if rawValue is a string, make an array otherwise just reference the array
+      rawValue = (typeof rawValue == "string") ? [rawValue] : rawValue;
+      
+      var value = options.formatMatch(rawValue, i+1, options.data.length);
+      if ( value === false )
+        continue;
+        
+      var firstChar = value.charAt(0).toLowerCase();
+      // if no lookup array for this character exists, look it up now
+      if( !stMatchSets[firstChar] ) 
+        stMatchSets[firstChar] = [];
 
-			// if the match is a string
-			var row = {
-				value: value,
-				data: rawValue,
-				result: options.formatResult && options.formatResult(rawValue) || value
-			};
-			
-			// push the current match into the set list
-			stMatchSets[firstChar].push(row);
+      // if the match is a string
+      var row = {
+        value: value,
+        data: rawValue,
+        result: options.formatResult && options.formatResult(rawValue) || value
+      };
+      
+      // push the current match into the set list
+      stMatchSets[firstChar].push(row);
 
-			// keep track of minChars zero items
-			if ( nullData++ < options.max ) {
-				stMatchSets[""].push(row);
-			}
-		};
+      // keep track of minChars zero items
+      if ( nullData++ < options.max ) {
+        stMatchSets[""].push(row);
+      }
+    };
 
-		// add the data items to the cache
-		$.each(stMatchSets, function(i, value) {
-			// increase the cache size
-			options.cacheLength++;
-			// add to the cache
-			add(i, value);
-		});
-	}
-	
-	// populate any existing data
-	setTimeout(populate, 25);
-	
-	function flush(){
-		data = {};
-		length = 0;
-	}
-	
-	return {
-		flush: flush,
-		add: add,
-		populate: populate,
-		load: function(q) {
-			if (!options.cacheLength || !length)
-				return null;
-			/* 
-			 * if dealing w/local data and matchContains than we must make sure
-			 * to loop through all the data collections looking for matches
-			 */
-			if( !options.url && options.matchContains ){
-				// track all matches
-				var csub = [];
-				// loop through all the data grids for matches
-				for( var k in data ){
-					// don't search through the stMatchSets[""] (minChars: 0) cache
-					// this prevents duplicates
-					if( k.length > 0 ){
-						var c = data[k];
-						$.each(c, function(i, x) {
-							// if we've got a match, add it to the array
-							if (matchSubset(x.value, q)) {
-								csub.push(x);
-							}
-						});
-					}
-				}				
-				return csub;
-			} else 
-			// if the exact item exists, use it
-			if (data[q]){
-				return data[q];
-			} else
-			if (options.matchSubset) {
-				for (var i = q.length - 1; i >= options.minChars; i--) {
-					var c = data[q.substr(0, i)];
-					if (c) {
-						var csub = [];
-						$.each(c, function(i, x) {
-							if (matchSubset(x.value, q)) {
-								csub[csub.length] = x;
-							}
-						});
-						return csub;
-					}
-				}
-			}
-			return null;
-		}
-	};
+    // add the data items to the cache
+    $.each(stMatchSets, function(i, value) {
+      // increase the cache size
+      options.cacheLength++;
+      // add to the cache
+      add(i, value);
+    });
+  }
+  
+  // populate any existing data
+  setTimeout(populate, 25);
+  
+  function flush(){
+    data = {};
+    length = 0;
+  }
+  
+  return {
+    flush: flush,
+    add: add,
+    populate: populate,
+    load: function(q) {
+      if (!options.cacheLength || !length)
+        return null;
+      /* 
+       * if dealing w/local data and matchContains than we must make sure
+       * to loop through all the data collections looking for matches
+       */
+      if( !options.url && options.matchContains ){
+        // track all matches
+        var csub = [];
+        // loop through all the data grids for matches
+        for( var k in data ){
+          // don't search through the stMatchSets[""] (minChars: 0) cache
+          // this prevents duplicates
+          if( k.length > 0 ){
+            var c = data[k];
+            $.each(c, function(i, x) {
+              // if we've got a match, add it to the array
+              if (matchSubset(x.value, q)) {
+                csub.push(x);
+              }
+            });
+          }
+        }        
+        return csub;
+      } else 
+      // if the exact item exists, use it
+      if (data[q]){
+        return data[q];
+      } else
+      if (options.matchSubset) {
+        for (var i = q.length - 1; i >= options.minChars; i--) {
+          var c = data[q.substr(0, i)];
+          if (c) {
+            var csub = [];
+            $.each(c, function(i, x) {
+              if (matchSubset(x.value, q)) {
+                csub[csub.length] = x;
+              }
+            });
+            return csub;
+          }
+        }
+      }
+      return null;
+    }
+  };
 };
 
 $.Autocompleter.Select = function (options, input, select, config) {
-	var CLASSES = {
-		ACTIVE: "ac_over"
-	};
-	
-	var listItems,
-		active = -1,
-		data,
-		term = "",
-		needsInit = true,
-		element,
-		list;
-	
-	// Create results
-	function init() {
-		if (!needsInit)
-			return;
-		element = $("<div/>")
-		.hide()
-		.addClass(options.resultsClass)
-		.css("position", "absolute")
-		.appendTo(document.body);
-	
-		list = $("<ul/>").appendTo(element).mouseover( function(event) {
-			if(target(event).nodeName && target(event).nodeName.toUpperCase() == 'LI') {
-	            active = $("li", list).removeClass(CLASSES.ACTIVE).index(target(event));
-			    $(target(event)).addClass(CLASSES.ACTIVE);            
-	        }
-		}).click(function(event) {
-			$(target(event)).addClass(CLASSES.ACTIVE);
-			select();
-			// TODO provide option to avoid setting focus again after selection? useful for cleanup-on-focus
-			input.focus();
-			return false;
-		}).mousedown(function() {
-			config.mouseDownOnSelect = true;
-		}).mouseup(function() {
-			config.mouseDownOnSelect = false;
-		});
-		
-		if( options.width > 0 )
-			element.css("width", options.width);
-			
-		needsInit = false;
-	} 
-	
-	function target(event) {
-		var element = event.target;
-		while(element && element.tagName != "LI")
-			element = element.parentNode;
-		// more fun with IE, sometimes event.target is empty, just ignore it then
-		if(!element)
-			return [];
-		return element;
-	}
+  var CLASSES = {
+    ACTIVE: "ac_over"
+  };
+  
+  var listItems,
+    active = -1,
+    data,
+    term = "",
+    needsInit = true,
+    element,
+    list;
+  
+  // Create results
+  function init() {
+    if (!needsInit)
+      return;
+    element = $("<div/>")
+    .hide()
+    .addClass(options.resultsClass)
+    .css("position", "absolute")
+    .appendTo(document.body);
+  
+    list = $("<ul/>").appendTo(element).mouseover( function(event) {
+      if(target(event).nodeName && target(event).nodeName.toUpperCase() == 'LI') {
+              active = $("li", list).removeClass(CLASSES.ACTIVE).index(target(event));
+          $(target(event)).addClass(CLASSES.ACTIVE);            
+          }
+    }).click(function(event) {
+      $(target(event)).addClass(CLASSES.ACTIVE);
+      select();
+      // TODO provide option to avoid setting focus again after selection? useful for cleanup-on-focus
+      input.focus();
+      return false;
+    }).mousedown(function() {
+      config.mouseDownOnSelect = true;
+    }).mouseup(function() {
+      config.mouseDownOnSelect = false;
+    });
+    
+    if( options.width > 0 )
+      element.css("width", options.width);
+      
+    needsInit = false;
+  } 
+  
+  function target(event) {
+    var element = event.target;
+    while(element && element.tagName != "LI")
+      element = element.parentNode;
+    // more fun with IE, sometimes event.target is empty, just ignore it then
+    if(!element)
+      return [];
+    return element;
+  }
 
-	function moveSelect(step) {
-		listItems.slice(active, active + 1).removeClass(CLASSES.ACTIVE);
-		movePosition(step);
+  function moveSelect(step) {
+    listItems.slice(active, active + 1).removeClass(CLASSES.ACTIVE);
+    movePosition(step);
         var activeItem = listItems.slice(active, active + 1).addClass(CLASSES.ACTIVE);
         if(options.scroll) {
             var offset = 0;
             listItems.slice(0, active).each(function() {
-				offset += this.offsetHeight;
-			});
+        offset += this.offsetHeight;
+      });
             if((offset + activeItem[0].offsetHeight - list.scrollTop()) > list[0].clientHeight) {
                 list.scrollTop(offset + activeItem[0].offsetHeight - list.innerHeight());
             } else if(offset < list.scrollTop()) {
                 list.scrollTop(offset);
             }
         }
-	};
-	
-	function movePosition(step) {
-		active += step;
-		if (active < 0) {
-			active = listItems.size() - 1;
-		} else if (active >= listItems.size()) {
-			active = 0;
-		}
-	}
-	
-	function limitNumberOfItems(available) {
-		return options.max && options.max < available
-			? options.max
-			: available;
-	}
-	
-	function fillList() {
-		list.empty();
-		var max = limitNumberOfItems(data.length);
-		for (var i=0; i < max; i++) {
-			if (!data[i])
-				continue;
-			var formatted = options.formatItem(data[i].data, i+1, max, data[i].value, term);
-			if ( formatted === false )
-				continue;
-			var li = $("<li/>").html( options.highlight(formatted, term) ).addClass(i%2 == 0 ? "ac_even" : "ac_odd").appendTo(list)[0];
-			$.data(li, "ac_data", data[i]);
-		}
-		listItems = list.find("li");
-		if ( options.selectFirst ) {
-			listItems.slice(0, 1).addClass(CLASSES.ACTIVE);
-			active = 0;
-		}
-		// apply bgiframe if available
-		if ( $.fn.bgiframe )
-			list.bgiframe();
-	}
-	
-	return {
-		display: function(d, q) {
-			init();
-			data = d;
-			term = q;
-			fillList();
-		},
-		next: function() {
-			moveSelect(1);
-		},
-		prev: function() {
-			moveSelect(-1);
-		},
-		pageUp: function() {
-			if (active != 0 && active - 8 < 0) {
-				moveSelect( -active );
-			} else {
-				moveSelect(-8);
-			}
-		},
-		pageDown: function() {
-			if (active != listItems.size() - 1 && active + 8 > listItems.size()) {
-				moveSelect( listItems.size() - 1 - active );
-			} else {
-				moveSelect(8);
-			}
-		},
-		hide: function() {
-			element && element.hide();
-			listItems && listItems.removeClass(CLASSES.ACTIVE);
-			active = -1;
-		},
-		visible : function() {
-			return element && element.is(":visible");
-		},
-		current: function() {
-			return this.visible() && (listItems.filter("." + CLASSES.ACTIVE)[0] || options.selectFirst && listItems[0]);
-		},
-		show: function() {
-			var offset = $(input).offset();
-			element.css({
-				width: typeof options.width == "string" || options.width > 0 ? options.width : $(input).width(),
-				top: offset.top + input.offsetHeight,
-				left: offset.left
-			}).show();
+  };
+  
+  function movePosition(step) {
+    active += step;
+    if (active < 0) {
+      active = listItems.size() - 1;
+    } else if (active >= listItems.size()) {
+      active = 0;
+    }
+  }
+  
+  function limitNumberOfItems(available) {
+    return options.max && options.max < available
+      ? options.max
+      : available;
+  }
+  
+  function fillList() {
+    list.empty();
+    var max = limitNumberOfItems(data.length);
+    for (var i=0; i < max; i++) {
+      if (!data[i])
+        continue;
+      var formatted = options.formatItem(data[i].data, i+1, max, data[i].value, term);
+      if ( formatted === false )
+        continue;
+      var li = $("<li/>").html( options.highlight(formatted, term) ).addClass(i%2 == 0 ? "ac_even" : "ac_odd").appendTo(list)[0];
+      $.data(li, "ac_data", data[i]);
+    }
+    listItems = list.find("li");
+    if ( options.selectFirst ) {
+      listItems.slice(0, 1).addClass(CLASSES.ACTIVE);
+      active = 0;
+    }
+    // apply bgiframe if available
+    if ( $.fn.bgiframe )
+      list.bgiframe();
+  }
+  
+  return {
+    display: function(d, q) {
+      init();
+      data = d;
+      term = q;
+      fillList();
+    },
+    next: function() {
+      moveSelect(1);
+    },
+    prev: function() {
+      moveSelect(-1);
+    },
+    pageUp: function() {
+      if (active != 0 && active - 8 < 0) {
+        moveSelect( -active );
+      } else {
+        moveSelect(-8);
+      }
+    },
+    pageDown: function() {
+      if (active != listItems.size() - 1 && active + 8 > listItems.size()) {
+        moveSelect( listItems.size() - 1 - active );
+      } else {
+        moveSelect(8);
+      }
+    },
+    hide: function() {
+      element && element.hide();
+      listItems && listItems.removeClass(CLASSES.ACTIVE);
+      active = -1;
+    },
+    visible : function() {
+      return element && element.is(":visible");
+    },
+    current: function() {
+      return this.visible() && (listItems.filter("." + CLASSES.ACTIVE)[0] || options.selectFirst && listItems[0]);
+    },
+    show: function() {
+      var offset = $(input).offset();
+      element.css({
+        width: typeof options.width == "string" || options.width > 0 ? options.width : $(input).width(),
+        top: offset.top + input.offsetHeight,
+        left: offset.left
+      }).show();
             if(options.scroll) {
                 list.scrollTop(0);
                 list.css({
-					maxHeight: options.scrollHeight,
-					overflow: 'auto'
-				});
-				
+          maxHeight: options.scrollHeight,
+          overflow: 'auto'
+        });
+        
                 if($.browser.msie && typeof document.body.style.maxHeight === "undefined") {
-					var listHeight = 0;
-					listItems.each(function() {
-						listHeight += this.offsetHeight;
-					});
-					var scrollbarsVisible = listHeight > options.scrollHeight;
+          var listHeight = 0;
+          listItems.each(function() {
+            listHeight += this.offsetHeight;
+          });
+          var scrollbarsVisible = listHeight > options.scrollHeight;
                     list.css('height', scrollbarsVisible ? options.scrollHeight : listHeight );
-					if (!scrollbarsVisible) {
-						// IE doesn't recalculate width when scrollbar disappears
-						listItems.width( list.width() - parseInt(listItems.css("padding-left")) - parseInt(listItems.css("padding-right")) );
-					}
+          if (!scrollbarsVisible) {
+            // IE doesn't recalculate width when scrollbar disappears
+            listItems.width( list.width() - parseInt(listItems.css("padding-left")) - parseInt(listItems.css("padding-right")) );
+          }
                 }
                 
             }
-		},
-		selected: function() {
-			var selected = listItems && listItems.filter("." + CLASSES.ACTIVE).removeClass(CLASSES.ACTIVE);
-			return selected && selected.length && $.data(selected[0], "ac_data");
-		},
-		emptyList: function (){
-			list && list.empty();
-		},
-		unbind: function() {
-			element && element.remove();
-		}
-	};
+    },
+    selected: function() {
+      var selected = listItems && listItems.filter("." + CLASSES.ACTIVE).removeClass(CLASSES.ACTIVE);
+      return selected && selected.length && $.data(selected[0], "ac_data");
+    },
+    emptyList: function (){
+      list && list.empty();
+    },
+    unbind: function() {
+      element && element.remove();
+    }
+  };
 };
 
 $.Autocompleter.Selection = function(field, start, end) {
-	if( field.createTextRange ){
-		var selRange = field.createTextRange();
-		selRange.collapse(true);
-		selRange.moveStart("character", start);
-		selRange.moveEnd("character", end);
-		selRange.select();
-	} else if( field.setSelectionRange ){
-		field.setSelectionRange(start, end);
-	} else {
-		if( field.selectionStart ){
-			field.selectionStart = start;
-			field.selectionEnd = end;
-		}
-	}
-	field.focus();
+  if( field.createTextRange ){
+    var selRange = field.createTextRange();
+    selRange.collapse(true);
+    selRange.moveStart("character", start);
+    selRange.moveEnd("character", end);
+    selRange.select();
+  } else if( field.setSelectionRange ){
+    field.setSelectionRange(start, end);
+  } else {
+    if( field.selectionStart ){
+      field.selectionStart = start;
+      field.selectionEnd = end;
+    }
+  }
+  field.focus();
 };
 
 })(jQuery);
\ No newline at end of file
diff --git a/solr/solrj/src/test-files/solrj/docs2.xml b/solr/solrj/src/test-files/solrj/docs2.xml
index 0b89d67..4c457a8 100644
--- a/solr/solrj/src/test-files/solrj/docs2.xml
+++ b/solr/solrj/src/test-files/solrj/docs2.xml
@@ -24,7 +24,7 @@
   <field name="manu_id_s">corsair</field>
   <field name="cat">electronics</field>
   <field name="cat">memory</field>
-  <field name="features">CAS latency 2,	2-3-3-6 timing, 2.75v, unbuffered, heat-spreader</field>
+  <field name="features">CAS latency 2,  2-3-3-6 timing, 2.75v, unbuffered, heat-spreader</field>
   <field name="price">185</field>
   <field name="popularity">5</field>
   <field name="inStock">true</field>
@@ -62,7 +62,7 @@
   <field name="manu_id_s">corsair</field>
   <field name="cat">electronics</field>
   <field name="cat">memory</field>
-  <field name="features">CAS latency 3,	 2.7v</field>
+  <field name="features">CAS latency 3,   2.7v</field>
   <!-- note: price & popularity is missing on this one -->
   <field name="popularity">0</field>
   <field name="inStock">true</field>
diff --git a/solr/solrj/src/test-files/solrj/solr/collection1/conf/schema.xml b/solr/solrj/src/test-files/solrj/solr/collection1/conf/schema.xml
index cec1105..c7e68ea 100644
--- a/solr/solrj/src/test-files/solrj/solr/collection1/conf/schema.xml
+++ b/solr/solrj/src/test-files/solrj/solr/collection1/conf/schema.xml
@@ -430,7 +430,7 @@
    <field name="standardfilt" type="standardfilt" indexed="true" stored="true"/>
    <field name="lowerfilt" type="lowerfilt" indexed="true" stored="true"/>
    <field name="lowerfilt1" type="lowerfilt" indexed="true" stored="true"/>
-	 <field name="lowerfilt1and2" type="lowerfilt" indexed="true" stored="true"/>
+   <field name="lowerfilt1and2" type="lowerfilt" indexed="true" stored="true"/>
    <field name="patterntok" type="patterntok" indexed="true" stored="true"/>
    <field name="patternreplacefilt" type="patternreplacefilt" indexed="true" stored="true"/>
    <field name="porterfilt" type="porterfilt" indexed="true" stored="true"/>
@@ -549,15 +549,15 @@
    <copyField source="title" dest="title_lettertok"/>
 
    <copyField source="title" dest="text"/>
-	 <copyField source="subject" dest="text"/>
+   <copyField source="subject" dest="text"/>
 
-	 <copyField source="lowerfilt1" dest="lowerfilt1and2"/>
-	 <copyField source="lowerfilt" dest="lowerfilt1and2"/>
+   <copyField source="lowerfilt1" dest="lowerfilt1and2"/>
+   <copyField source="lowerfilt" dest="lowerfilt1and2"/>
 
-	 <copyField source="*_t" dest="text"/>
+   <copyField source="*_t" dest="text"/>
 
-	 <copyField source="id"            dest="range_facet_l"/>
-	 <copyField source="range_facet_f" dest="range_facet_d"/>
+   <copyField source="id"            dest="range_facet_l"/>
+   <copyField source="range_facet_f" dest="range_facet_d"/>
 
    <!-- dynamic destination -->
    <copyField source="*_dynamic" dest="dynamic_*"/>
diff --git a/solr/test-framework/build.xml b/solr/test-framework/build.xml
index cab380c..021076d 100644
--- a/solr/test-framework/build.xml
+++ b/solr/test-framework/build.xml
@@ -63,19 +63,19 @@
     <sequential>
       <mkdir dir="${javadoc.dir}/${name}"/>
       <!-- NOTE: explicitly not using solr-invoke-javadoc, or attempting to 
-	   link to lucene-test-framework because if we did javadoc would 
-	   attempt to link class refs in in org.apache.lucene, causing 
-	   broken links. (either broken links to things like "Directory" if 
-	   lucene-test-framework was first, or broken links to things like 
-	   LuceneTestCase if lucene-core was first)
+     link to lucene-test-framework because if we did javadoc would 
+     attempt to link class refs in in org.apache.lucene, causing 
+     broken links. (either broken links to things like "Directory" if 
+     lucene-test-framework was first, or broken links to things like 
+     LuceneTestCase if lucene-core was first)
       -->
       <invoke-javadoc destdir="${javadoc.dir}/${name}" 
-		      title="${Name} ${version} Test Framework API">
-	<sources>
-	  <link offline="true" href="${javadoc.link.junit}"
-		packagelistLoc="${javadoc.packagelist.dir}/junit"/>
-	  <packageset dir="${src.dir}"/>
-	</sources>
+          title="${Name} ${version} Test Framework API">
+  <sources>
+    <link offline="true" href="${javadoc.link.junit}"
+    packagelistLoc="${javadoc.packagelist.dir}/junit"/>
+    <packageset dir="${src.dir}"/>
+  </sources>
       </invoke-javadoc>
       <solr-jarify basedir="${javadoc.dir}/${name}" destfile="${build.dir}/${final.name}-javadoc.jar"/>
     </sequential>
@@ -107,11 +107,11 @@
     <mkdir  dir="${dist}/test-framework" />
     <copy todir="${dist}/test-framework">
       <fileset dir="${build.dir}">
-	<include name="lucene-libs/*.jar" />
+  <include name="lucene-libs/*.jar" />
       </fileset>
       <fileset dir=".">
-	<include name="lib/*" />
-	<include name="README.txt" />
+  <include name="lib/*" />
+  <include name="README.txt" />
       </fileset>
     </copy>
   </target>
diff --git a/solr/webapp/build.xml b/solr/webapp/build.xml
index aa3496b..c7c5c85 100644
--- a/solr/webapp/build.xml
+++ b/solr/webapp/build.xml
@@ -24,7 +24,7 @@
   <import file="../common-build.xml"/>
 
   <property name="exclude.from.webapp" value="*slf4j*,log4j-*,*javax.servlet*" />
-	
+  
   <!-- this module has no javadocs -->
   <target name="javadocs"/>
 
diff --git a/solr/webapp/web/WEB-INF/weblogic.xml b/solr/webapp/web/WEB-INF/weblogic.xml
index b8645eb..43809ee 100644
--- a/solr/webapp/web/WEB-INF/weblogic.xml
+++ b/solr/webapp/web/WEB-INF/weblogic.xml
@@ -21,7 +21,7 @@
     xsi:schemaLocation="http://www.bea.com/ns/weblogic/90 http://www.bea.com/ns/weblogic/90/weblogic-web-app.xsd">
 
     <container-descriptor>
-	<filter-dispatched-requests-enabled>false</filter-dispatched-requests-enabled>
+      <filter-dispatched-requests-enabled>false</filter-dispatched-requests-enabled>
     </container-descriptor>
 
 </weblogic-web-app>
diff --git a/solr/webapp/web/js/lib/ZeroClipboard.js b/solr/webapp/web/js/lib/ZeroClipboard.js
index 5d7671a..a521be8 100644
--- a/solr/webapp/web/js/lib/ZeroClipboard.js
+++ b/solr/webapp/web/js/lib/ZeroClipboard.js
@@ -27,316 +27,316 @@ THE SOFTWARE.
 // Author: Joseph Huckaby
 
 var ZeroClipboard = {
-	
-	version: "1.0.7",
-	clients: {}, // registered upload clients on page, indexed by id
-	moviePath: 'ZeroClipboard.swf', // URL to movie
-	nextId: 1, // ID of next movie
-	
-	$: function(thingy) {
-		// simple DOM lookup utility function
-		if (typeof(thingy) == 'string') thingy = document.getElementById(thingy);
-		if (!thingy.addClass) {
-			// extend element with a few useful methods
-			thingy.hide = function() { this.style.display = 'none'; };
-			thingy.show = function() { this.style.display = ''; };
-			thingy.addClass = function(name) { this.removeClass(name); this.className += ' ' + name; };
-			thingy.removeClass = function(name) {
-				var classes = this.className.split(/\s+/);
-				var idx = -1;
-				for (var k = 0; k < classes.length; k++) {
-					if (classes[k] == name) { idx = k; k = classes.length; }
-				}
-				if (idx > -1) {
-					classes.splice( idx, 1 );
-					this.className = classes.join(' ');
-				}
-				return this;
-			};
-			thingy.hasClass = function(name) {
-				return !!this.className.match( new RegExp("\\s*" + name + "\\s*") );
-			};
-		}
-		return thingy;
-	},
-	
-	setMoviePath: function(path) {
-		// set path to ZeroClipboard.swf
-		this.moviePath = path;
-	},
-	
-	dispatch: function(id, eventName, args) {
-		// receive event from flash movie, send to client		
-		var client = this.clients[id];
-		if (client) {
-			client.receiveEvent(eventName, args);
-		}
-	},
-	
-	register: function(id, client) {
-		// register new client to receive events
-		this.clients[id] = client;
-	},
-	
-	getDOMObjectPosition: function(obj, stopObj) {
-		// get absolute coordinates for dom element
-		var info = {
-			left: 0, 
-			top: 0, 
-			width: obj.width ? obj.width : obj.offsetWidth, 
-			height: obj.height ? obj.height : obj.offsetHeight
-		};
+  
+  version: "1.0.7",
+  clients: {}, // registered upload clients on page, indexed by id
+  moviePath: 'ZeroClipboard.swf', // URL to movie
+  nextId: 1, // ID of next movie
+  
+  $: function(thingy) {
+    // simple DOM lookup utility function
+    if (typeof(thingy) == 'string') thingy = document.getElementById(thingy);
+    if (!thingy.addClass) {
+      // extend element with a few useful methods
+      thingy.hide = function() { this.style.display = 'none'; };
+      thingy.show = function() { this.style.display = ''; };
+      thingy.addClass = function(name) { this.removeClass(name); this.className += ' ' + name; };
+      thingy.removeClass = function(name) {
+        var classes = this.className.split(/\s+/);
+        var idx = -1;
+        for (var k = 0; k < classes.length; k++) {
+          if (classes[k] == name) { idx = k; k = classes.length; }
+        }
+        if (idx > -1) {
+          classes.splice( idx, 1 );
+          this.className = classes.join(' ');
+        }
+        return this;
+      };
+      thingy.hasClass = function(name) {
+        return !!this.className.match( new RegExp("\\s*" + name + "\\s*") );
+      };
+    }
+    return thingy;
+  },
+  
+  setMoviePath: function(path) {
+    // set path to ZeroClipboard.swf
+    this.moviePath = path;
+  },
+  
+  dispatch: function(id, eventName, args) {
+    // receive event from flash movie, send to client    
+    var client = this.clients[id];
+    if (client) {
+      client.receiveEvent(eventName, args);
+    }
+  },
+  
+  register: function(id, client) {
+    // register new client to receive events
+    this.clients[id] = client;
+  },
+  
+  getDOMObjectPosition: function(obj, stopObj) {
+    // get absolute coordinates for dom element
+    var info = {
+      left: 0, 
+      top: 0, 
+      width: obj.width ? obj.width : obj.offsetWidth, 
+      height: obj.height ? obj.height : obj.offsetHeight
+    };
 
-		while (obj && (obj != stopObj)) {
-			info.left += obj.offsetLeft;
-			info.top += obj.offsetTop;
-			obj = obj.offsetParent;
-		}
+    while (obj && (obj != stopObj)) {
+      info.left += obj.offsetLeft;
+      info.top += obj.offsetTop;
+      obj = obj.offsetParent;
+    }
 
-		return info;
-	},
-	
-	Client: function(elem) {
-		// constructor for new simple upload client
-		this.handlers = {};
-		
-		// unique ID
-		this.id = ZeroClipboard.nextId++;
-		this.movieId = 'ZeroClipboardMovie_' + this.id;
-		
-		// register client with singleton to receive flash events
-		ZeroClipboard.register(this.id, this);
-		
-		// create movie
-		if (elem) this.glue(elem);
-	}
+    return info;
+  },
+  
+  Client: function(elem) {
+    // constructor for new simple upload client
+    this.handlers = {};
+    
+    // unique ID
+    this.id = ZeroClipboard.nextId++;
+    this.movieId = 'ZeroClipboardMovie_' + this.id;
+    
+    // register client with singleton to receive flash events
+    ZeroClipboard.register(this.id, this);
+    
+    // create movie
+    if (elem) this.glue(elem);
+  }
 };
 
 ZeroClipboard.Client.prototype = {
-	
-	id: 0, // unique ID for us
-	ready: false, // whether movie is ready to receive events or not
-	movie: null, // reference to movie object
-	clipText: '', // text to copy to clipboard
-	handCursorEnabled: true, // whether to show hand cursor, or default pointer cursor
-	cssEffects: true, // enable CSS mouse effects on dom container
-	handlers: null, // user event handlers
-	
-	glue: function(elem, appendElem, stylesToAdd) {
-		// glue to DOM element
-		// elem can be ID or actual DOM element object
-		this.domElement = ZeroClipboard.$(elem);
-		
-		// float just above object, or zIndex 99 if dom element isn't set
-		var zIndex = 99;
-		if (this.domElement.style.zIndex) {
-			zIndex = parseInt(this.domElement.style.zIndex, 10) + 1;
-		}
-		
-		if (typeof(appendElem) == 'string') {
-			appendElem = ZeroClipboard.$(appendElem);
-		}
-		else if (typeof(appendElem) == 'undefined') {
-			appendElem = document.getElementsByTagName('body')[0];
-		}
-		
-		// find X/Y position of domElement
-		var box = ZeroClipboard.getDOMObjectPosition(this.domElement, appendElem);
-		
-		// create floating DIV above element
-		this.div = document.createElement('div');
-		var style = this.div.style;
-		style.position = 'absolute';
-		style.left = '' + box.left + 'px';
-		style.top = '' + box.top + 'px';
-		style.width = '' + box.width + 'px';
-		style.height = '' + box.height + 'px';
-		style.zIndex = zIndex;
+  
+  id: 0, // unique ID for us
+  ready: false, // whether movie is ready to receive events or not
+  movie: null, // reference to movie object
+  clipText: '', // text to copy to clipboard
+  handCursorEnabled: true, // whether to show hand cursor, or default pointer cursor
+  cssEffects: true, // enable CSS mouse effects on dom container
+  handlers: null, // user event handlers
+  
+  glue: function(elem, appendElem, stylesToAdd) {
+    // glue to DOM element
+    // elem can be ID or actual DOM element object
+    this.domElement = ZeroClipboard.$(elem);
+    
+    // float just above object, or zIndex 99 if dom element isn't set
+    var zIndex = 99;
+    if (this.domElement.style.zIndex) {
+      zIndex = parseInt(this.domElement.style.zIndex, 10) + 1;
+    }
+    
+    if (typeof(appendElem) == 'string') {
+      appendElem = ZeroClipboard.$(appendElem);
+    }
+    else if (typeof(appendElem) == 'undefined') {
+      appendElem = document.getElementsByTagName('body')[0];
+    }
+    
+    // find X/Y position of domElement
+    var box = ZeroClipboard.getDOMObjectPosition(this.domElement, appendElem);
+    
+    // create floating DIV above element
+    this.div = document.createElement('div');
+    var style = this.div.style;
+    style.position = 'absolute';
+    style.left = '' + box.left + 'px';
+    style.top = '' + box.top + 'px';
+    style.width = '' + box.width + 'px';
+    style.height = '' + box.height + 'px';
+    style.zIndex = zIndex;
 
-		style.left = '0px';
-		style.top = '0px';
-		
-		if (typeof(stylesToAdd) == 'object') {
-			for (addedStyle in stylesToAdd) {
-				style[addedStyle] = stylesToAdd[addedStyle];
-			}
-		}
-		
-		// style.backgroundColor = '#f00'; // debug
-		
-		appendElem.appendChild(this.div);
-		
-		this.div.innerHTML = this.getHTML( box.width, box.height );
-	},
-	
-	getHTML: function(width, height) {
-		// return HTML for movie
-		var html = '';
-		var flashvars = 'id=' + this.id + 
-			'&width=' + width + 
-			'&height=' + height;
-			
-		if (navigator.userAgent.match(/MSIE/)) {
-			// IE gets an OBJECT tag
-			var protocol = location.href.match(/^https/i) ? 'https://' : 'http://';
-			html += '<object classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" codebase="'+protocol+'download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=9,0,0,0" width="'+width+'" height="'+height+'" id="'+this.movieId+'" align="middle"><param name="allowScriptAccess" value="always" /><param name="allowFullScreen" value="false" /><param name="movie" value="'+ZeroClipboard.moviePath+'" /><param name="loop" value="false" /><param name="menu" value="false" /><param name="quality" value="best" /><param name="bgcolor" value="#ffffff" /><param name="flashvars" value="'+flashvars+'"/><param name="wmode" value="transparent"/></object>';
-		}
-		else {
-			// all other browsers get an EMBED tag
-			html += '<embed id="'+this.movieId+'" src="'+ZeroClipboard.moviePath+'" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="'+width+'" height="'+height+'" name="'+this.movieId+'" align="middle" allowScriptAccess="always" allowFullScreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="'+flashvars+'" wmode="transparent" />';
-		}
-		return html;
-	},
-	
-	hide: function() {
-		// temporarily hide floater offscreen
-		if (this.div) {
-			this.div.style.left = '-2000px';
-		}
-	},
-	
-	show: function() {
-		// show ourselves after a call to hide()
-		this.reposition();
-	},
-	
-	destroy: function() {
-		// destroy control and floater
-		if (this.domElement && this.div) {
-			this.hide();
-			this.div.innerHTML = '';
-			
-			var body = document.getElementsByTagName('body')[0];
-			try { body.removeChild( this.div ); } catch(e) {;}
-			
-			this.domElement = null;
-			this.div = null;
-		}
-	},
-	
-	reposition: function(elem) {
-		// reposition our floating div, optionally to new container
-		// warning: container CANNOT change size, only position
-		if (elem) {
-			this.domElement = ZeroClipboard.$(elem);
-			if (!this.domElement) this.hide();
-		}
+    style.left = '0px';
+    style.top = '0px';
+    
+    if (typeof(stylesToAdd) == 'object') {
+      for (addedStyle in stylesToAdd) {
+        style[addedStyle] = stylesToAdd[addedStyle];
+      }
+    }
+    
+    // style.backgroundColor = '#f00'; // debug
+    
+    appendElem.appendChild(this.div);
+    
+    this.div.innerHTML = this.getHTML( box.width, box.height );
+  },
+  
+  getHTML: function(width, height) {
+    // return HTML for movie
+    var html = '';
+    var flashvars = 'id=' + this.id + 
+      '&width=' + width + 
+      '&height=' + height;
+      
+    if (navigator.userAgent.match(/MSIE/)) {
+      // IE gets an OBJECT tag
+      var protocol = location.href.match(/^https/i) ? 'https://' : 'http://';
+      html += '<object classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" codebase="'+protocol+'download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=9,0,0,0" width="'+width+'" height="'+height+'" id="'+this.movieId+'" align="middle"><param name="allowScriptAccess" value="always" /><param name="allowFullScreen" value="false" /><param name="movie" value="'+ZeroClipboard.moviePath+'" /><param name="loop" value="false" /><param name="menu" value="false" /><param name="quality" value="best" /><param name="bgcolor" value="#ffffff" /><param name="flashvars" value="'+flashvars+'"/><param name="wmode" value="transparent"/></object>';
+    }
+    else {
+      // all other browsers get an EMBED tag
+      html += '<embed id="'+this.movieId+'" src="'+ZeroClipboard.moviePath+'" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="'+width+'" height="'+height+'" name="'+this.movieId+'" align="middle" allowScriptAccess="always" allowFullScreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="'+flashvars+'" wmode="transparent" />';
+    }
+    return html;
+  },
+  
+  hide: function() {
+    // temporarily hide floater offscreen
+    if (this.div) {
+      this.div.style.left = '-2000px';
+    }
+  },
+  
+  show: function() {
+    // show ourselves after a call to hide()
+    this.reposition();
+  },
+  
+  destroy: function() {
+    // destroy control and floater
+    if (this.domElement && this.div) {
+      this.hide();
+      this.div.innerHTML = '';
+      
+      var body = document.getElementsByTagName('body')[0];
+      try { body.removeChild( this.div ); } catch(e) {;}
+      
+      this.domElement = null;
+      this.div = null;
+    }
+  },
+  
+  reposition: function(elem) {
+    // reposition our floating div, optionally to new container
+    // warning: container CANNOT change size, only position
+    if (elem) {
+      this.domElement = ZeroClipboard.$(elem);
+      if (!this.domElement) this.hide();
+    }
 
-		console.debug( this.domElement, this.div );
-		
-		if (this.domElement && this.div) {
-			var box = ZeroClipboard.getDOMObjectPosition(this.domElement);
-			console.debug( box );
-			var style = this.div.style;
-			style.left = '' + box.left + 'px';
-			style.top = '' + box.top + 'px';
-		}
-	},
-	
-	setText: function(newText) {
-		// set text to be copied to clipboard
-		this.clipText = newText;
-		if (this.ready) this.movie.setText(newText);
-	},
-	
-	addEventListener: function(eventName, func) {
-		// add user event listener for event
-		// event types: load, queueStart, fileStart, fileComplete, queueComplete, progress, error, cancel
-		eventName = eventName.toString().toLowerCase().replace(/^on/, '');
-		if (!this.handlers[eventName]) this.handlers[eventName] = [];
-		this.handlers[eventName].push(func);
-	},
-	
-	setHandCursor: function(enabled) {
-		// enable hand cursor (true), or default arrow cursor (false)
-		this.handCursorEnabled = enabled;
-		if (this.ready) this.movie.setHandCursor(enabled);
-	},
-	
-	setCSSEffects: function(enabled) {
-		// enable or disable CSS effects on DOM container
-		this.cssEffects = !!enabled;
-	},
-	
-	receiveEvent: function(eventName, args) {
-		// receive event from flash
-		eventName = eventName.toString().toLowerCase().replace(/^on/, '');
-				
-		// special behavior for certain events
-		switch (eventName) {
-			case 'load':
-				// movie claims it is ready, but in IE this isn't always the case...
-				// bug fix: Cannot extend EMBED DOM elements in Firefox, must use traditional function
-				this.movie = document.getElementById(this.movieId);
-				if (!this.movie) {
-					var self = this;
-					setTimeout( function() { self.receiveEvent('load', null); }, 1 );
-					return;
-				}
-				
-				// firefox on pc needs a "kick" in order to set these in certain cases
-				if (!this.ready && navigator.userAgent.match(/Firefox/) && navigator.userAgent.match(/Windows/)) {
-					var self = this;
-					setTimeout( function() { self.receiveEvent('load', null); }, 100 );
-					this.ready = true;
-					return;
-				}
-				
-				this.ready = true;
-				this.movie.setText( this.clipText );
-				this.movie.setHandCursor( this.handCursorEnabled );
-				break;
-			
-			case 'mouseover':
-				if (this.domElement && this.cssEffects) {
-					this.domElement.addClass('hover');
-					if (this.recoverActive) this.domElement.addClass('active');
-				}
-				break;
-			
-			case 'mouseout':
-				if (this.domElement && this.cssEffects) {
-					this.recoverActive = false;
-					if (this.domElement.hasClass('active')) {
-						this.domElement.removeClass('active');
-						this.recoverActive = true;
-					}
-					this.domElement.removeClass('hover');
-				}
-				break;
-			
-			case 'mousedown':
-				if (this.domElement && this.cssEffects) {
-					this.domElement.addClass('active');
-				}
-				break;
-			
-			case 'mouseup':
-				if (this.domElement && this.cssEffects) {
-					this.domElement.removeClass('active');
-					this.recoverActive = false;
-				}
-				break;
-		} // switch eventName
-		
-		if (this.handlers[eventName]) {
-			for (var idx = 0, len = this.handlers[eventName].length; idx < len; idx++) {
-				var func = this.handlers[eventName][idx];
-			
-				if (typeof(func) == 'function') {
-					// actual function reference
-					func(this, args);
-				}
-				else if ((typeof(func) == 'object') && (func.length == 2)) {
-					// PHP style object + method, i.e. [myObject, 'myMethod']
-					func[0][ func[1] ](this, args);
-				}
-				else if (typeof(func) == 'string') {
-					// name of function
-					window[func](this, args);
-				}
-			} // foreach event handler defined
-		} // user defined handler for event
-	}
-	
+    console.debug( this.domElement, this.div );
+    
+    if (this.domElement && this.div) {
+      var box = ZeroClipboard.getDOMObjectPosition(this.domElement);
+      console.debug( box );
+      var style = this.div.style;
+      style.left = '' + box.left + 'px';
+      style.top = '' + box.top + 'px';
+    }
+  },
+  
+  setText: function(newText) {
+    // set text to be copied to clipboard
+    this.clipText = newText;
+    if (this.ready) this.movie.setText(newText);
+  },
+  
+  addEventListener: function(eventName, func) {
+    // add user event listener for event
+    // event types: load, queueStart, fileStart, fileComplete, queueComplete, progress, error, cancel
+    eventName = eventName.toString().toLowerCase().replace(/^on/, '');
+    if (!this.handlers[eventName]) this.handlers[eventName] = [];
+    this.handlers[eventName].push(func);
+  },
+  
+  setHandCursor: function(enabled) {
+    // enable hand cursor (true), or default arrow cursor (false)
+    this.handCursorEnabled = enabled;
+    if (this.ready) this.movie.setHandCursor(enabled);
+  },
+  
+  setCSSEffects: function(enabled) {
+    // enable or disable CSS effects on DOM container
+    this.cssEffects = !!enabled;
+  },
+  
+  receiveEvent: function(eventName, args) {
+    // receive event from flash
+    eventName = eventName.toString().toLowerCase().replace(/^on/, '');
+        
+    // special behavior for certain events
+    switch (eventName) {
+      case 'load':
+        // movie claims it is ready, but in IE this isn't always the case...
+        // bug fix: Cannot extend EMBED DOM elements in Firefox, must use traditional function
+        this.movie = document.getElementById(this.movieId);
+        if (!this.movie) {
+          var self = this;
+          setTimeout( function() { self.receiveEvent('load', null); }, 1 );
+          return;
+        }
+        
+        // firefox on pc needs a "kick" in order to set these in certain cases
+        if (!this.ready && navigator.userAgent.match(/Firefox/) && navigator.userAgent.match(/Windows/)) {
+          var self = this;
+          setTimeout( function() { self.receiveEvent('load', null); }, 100 );
+          this.ready = true;
+          return;
+        }
+        
+        this.ready = true;
+        this.movie.setText( this.clipText );
+        this.movie.setHandCursor( this.handCursorEnabled );
+        break;
+      
+      case 'mouseover':
+        if (this.domElement && this.cssEffects) {
+          this.domElement.addClass('hover');
+          if (this.recoverActive) this.domElement.addClass('active');
+        }
+        break;
+      
+      case 'mouseout':
+        if (this.domElement && this.cssEffects) {
+          this.recoverActive = false;
+          if (this.domElement.hasClass('active')) {
+            this.domElement.removeClass('active');
+            this.recoverActive = true;
+          }
+          this.domElement.removeClass('hover');
+        }
+        break;
+      
+      case 'mousedown':
+        if (this.domElement && this.cssEffects) {
+          this.domElement.addClass('active');
+        }
+        break;
+      
+      case 'mouseup':
+        if (this.domElement && this.cssEffects) {
+          this.domElement.removeClass('active');
+          this.recoverActive = false;
+        }
+        break;
+    } // switch eventName
+    
+    if (this.handlers[eventName]) {
+      for (var idx = 0, len = this.handlers[eventName].length; idx < len; idx++) {
+        var func = this.handlers[eventName][idx];
+      
+        if (typeof(func) == 'function') {
+          // actual function reference
+          func(this, args);
+        }
+        else if ((typeof(func) == 'object') && (func.length == 2)) {
+          // PHP style object + method, i.e. [myObject, 'myMethod']
+          func[0][ func[1] ](this, args);
+        }
+        else if (typeof(func) == 'string') {
+          // name of function
+          window[func](this, args);
+        }
+      } // foreach event handler defined
+    } // user defined handler for event
+  }
+  
 };
diff --git a/solr/webapp/web/js/lib/jquery.blockUI.js b/solr/webapp/web/js/lib/jquery.blockUI.js
index 38e6410..d1e14a6 100644
--- a/solr/webapp/web/js/lib/jquery.blockUI.js
+++ b/solr/webapp/web/js/lib/jquery.blockUI.js
@@ -39,8 +39,8 @@ THE SOFTWARE.
 ;(function($) {
 
 if (/1\.(0|1|2)\.(0|1|2)/.test($.fn.jquery) || /^1.1/.test($.fn.jquery)) {
-	alert('blockUI requires jQuery v1.2.3 or later!  You are using v' + $.fn.jquery);
-	return;
+  alert('blockUI requires jQuery v1.2.3 or later!  You are using v' + $.fn.jquery);
+  return;
 }
 
 $.fn._fadeIn = $.fn.fadeIn;
@@ -59,153 +59,153 @@ $.unblockUI = function(opts) { remove(window, opts); };
 
 // convenience method for quick growl-like notifications  (http://www.google.com/search?q=growl)
 $.growlUI = function(title, message, timeout, onClose) {
-	var $m = $('<div class="growlUI"></div>');
-	if (title) $m.append('<h1>'+title+'</h1>');
-	if (message) $m.append('<h2>'+message+'</h2>');
-	if (timeout == undefined) timeout = 3000;
-	$.blockUI({
-		message: $m, fadeIn: 700, fadeOut: 1000, centerY: false,
-		timeout: timeout, showOverlay: false,
-		onUnblock: onClose, 
-		css: $.blockUI.defaults.growlCSS
-	});
+  var $m = $('<div class="growlUI"></div>');
+  if (title) $m.append('<h1>'+title+'</h1>');
+  if (message) $m.append('<h2>'+message+'</h2>');
+  if (timeout == undefined) timeout = 3000;
+  $.blockUI({
+    message: $m, fadeIn: 700, fadeOut: 1000, centerY: false,
+    timeout: timeout, showOverlay: false,
+    onUnblock: onClose, 
+    css: $.blockUI.defaults.growlCSS
+  });
 };
 
 // plugin method for blocking element content
 $.fn.block = function(opts) {
-	return this.unblock({ fadeOut: 0 }).each(function() {
-		if ($.css(this,'position') == 'static')
-			this.style.position = 'relative';
-		if ($.browser.msie)
-			this.style.zoom = 1; // force 'hasLayout'
-		install(this, opts);
-	});
+  return this.unblock({ fadeOut: 0 }).each(function() {
+    if ($.css(this,'position') == 'static')
+      this.style.position = 'relative';
+    if ($.browser.msie)
+      this.style.zoom = 1; // force 'hasLayout'
+    install(this, opts);
+  });
 };
 
 // plugin method for unblocking element content
 $.fn.unblock = function(opts) {
-	return this.each(function() {
-		remove(this, opts);
-	});
+  return this.each(function() {
+    remove(this, opts);
+  });
 };
 
 $.blockUI.version = 2.39; // 2nd generation blocking at no extra cost!
 
 // override these in your code to change the default behavior and style
 $.blockUI.defaults = {
-	// message displayed when blocking (use null for no message)
-	message:  '<h1>Please wait...</h1>',
-
-	title: null,	  // title string; only used when theme == true
-	draggable: true,  // only used when theme == true (requires jquery-ui.js to be loaded)
-	
-	theme: false, // set to true to use with jQuery UI themes
-	
-	// styles for the message when blocking; if you wish to disable
-	// these and use an external stylesheet then do this in your code:
-	// $.blockUI.defaults.css = {};
-	css: {
-		padding:	0,
-		margin:		0,
-		width:		'30%',
-		top:		'40%',
-		left:		'35%',
-		textAlign:	'center',
-		color:		'#000',
-		border:		'3px solid #aaa',
-		backgroundColor:'#fff',
-		cursor:		'wait'
-	},
-	
-	// minimal style set used when themes are used
-	themedCSS: {
-		width:	'30%',
-		top:	'40%',
-		left:	'35%'
-	},
-
-	// styles for the overlay
-	overlayCSS:  {
-		backgroundColor: '#000',
-		opacity:	  	 0.6,
-		cursor:		  	 'wait'
-	},
-
-	// styles applied when using $.growlUI
-	growlCSS: {
-		width:  	'350px',
-		top:		'10px',
-		left:   	'',
-		right:  	'10px',
-		border: 	'none',
-		padding:	'5px',
-		opacity:	0.6,
-		cursor: 	'default',
-		color:		'#fff',
-		backgroundColor: '#000',
-		'-webkit-border-radius': '10px',
-		'-moz-border-radius':	 '10px',
-		'border-radius': 		 '10px'
-	},
-	
-	// IE issues: 'about:blank' fails on HTTPS and javascript:false is s-l-o-w
-	// (hat tip to Jorge H. N. de Vasconcelos)
-	iframeSrc: /^https/i.test(window.location.href || '') ? 'javascript:false' : 'about:blank',
-
-	// force usage of iframe in non-IE browsers (handy for blocking applets)
-	forceIframe: false,
-
-	// z-index for the blocking overlay
-	baseZ: 1000,
-
-	// set these to true to have the message automatically centered
-	centerX: true, // <-- only effects element blocking (page block controlled via css above)
-	centerY: true,
-
-	// allow body element to be stetched in ie6; this makes blocking look better
-	// on "short" pages.  disable if you wish to prevent changes to the body height
-	allowBodyStretch: true,
-
-	// enable if you want key and mouse events to be disabled for content that is blocked
-	bindEvents: true,
-
-	// be default blockUI will supress tab navigation from leaving blocking content
-	// (if bindEvents is true)
-	constrainTabKey: true,
-
-	// fadeIn time in millis; set to 0 to disable fadeIn on block
-	fadeIn:  200,
-
-	// fadeOut time in millis; set to 0 to disable fadeOut on unblock
-	fadeOut:  400,
-
-	// time in millis to wait before auto-unblocking; set to 0 to disable auto-unblock
-	timeout: 0,
-
-	// disable if you don't want to show the overlay
-	showOverlay: true,
-
-	// if true, focus will be placed in the first available input field when
-	// page blocking
-	focusInput: true,
-
-	// suppresses the use of overlay styles on FF/Linux (due to performance issues with opacity)
-	applyPlatformOpacityRules: true,
-	
-	// callback method invoked when fadeIn has completed and blocking message is visible
-	onBlock: null,
-
-	// callback method invoked when unblocking has completed; the callback is
-	// passed the element that has been unblocked (which is the window object for page
-	// blocks) and the options that were passed to the unblock call:
-	//	 onUnblock(element, options)
-	onUnblock: null,
-
-	// don't ask; if you really must know: http://groups.google.com/group/jquery-en/browse_thread/thread/36640a8730503595/2f6a79a77a78e493#2f6a79a77a78e493
-	quirksmodeOffsetHack: 4,
-
-	// class name of the message block
-	blockMsgClass: 'blockMsg'
+  // message displayed when blocking (use null for no message)
+  message:  '<h1>Please wait...</h1>',
+
+  title: null,    // title string; only used when theme == true
+  draggable: true,  // only used when theme == true (requires jquery-ui.js to be loaded)
+  
+  theme: false, // set to true to use with jQuery UI themes
+  
+  // styles for the message when blocking; if you wish to disable
+  // these and use an external stylesheet then do this in your code:
+  // $.blockUI.defaults.css = {};
+  css: {
+    padding:  0,
+    margin:    0,
+    width:    '30%',
+    top:    '40%',
+    left:    '35%',
+    textAlign:  'center',
+    color:    '#000',
+    border:    '3px solid #aaa',
+    backgroundColor:'#fff',
+    cursor:    'wait'
+  },
+  
+  // minimal style set used when themes are used
+  themedCSS: {
+    width:  '30%',
+    top:  '40%',
+    left:  '35%'
+  },
+
+  // styles for the overlay
+  overlayCSS:  {
+    backgroundColor: '#000',
+    opacity:       0.6,
+    cursor:         'wait'
+  },
+
+  // styles applied when using $.growlUI
+  growlCSS: {
+    width:    '350px',
+    top:    '10px',
+    left:     '',
+    right:    '10px',
+    border:   'none',
+    padding:  '5px',
+    opacity:  0.6,
+    cursor:   'default',
+    color:    '#fff',
+    backgroundColor: '#000',
+    '-webkit-border-radius': '10px',
+    '-moz-border-radius':   '10px',
+    'border-radius':      '10px'
+  },
+  
+  // IE issues: 'about:blank' fails on HTTPS and javascript:false is s-l-o-w
+  // (hat tip to Jorge H. N. de Vasconcelos)
+  iframeSrc: /^https/i.test(window.location.href || '') ? 'javascript:false' : 'about:blank',
+
+  // force usage of iframe in non-IE browsers (handy for blocking applets)
+  forceIframe: false,
+
+  // z-index for the blocking overlay
+  baseZ: 1000,
+
+  // set these to true to have the message automatically centered
+  centerX: true, // <-- only effects element blocking (page block controlled via css above)
+  centerY: true,
+
+  // allow body element to be stetched in ie6; this makes blocking look better
+  // on "short" pages.  disable if you wish to prevent changes to the body height
+  allowBodyStretch: true,
+
+  // enable if you want key and mouse events to be disabled for content that is blocked
+  bindEvents: true,
+
+  // be default blockUI will supress tab navigation from leaving blocking content
+  // (if bindEvents is true)
+  constrainTabKey: true,
+
+  // fadeIn time in millis; set to 0 to disable fadeIn on block
+  fadeIn:  200,
+
+  // fadeOut time in millis; set to 0 to disable fadeOut on unblock
+  fadeOut:  400,
+
+  // time in millis to wait before auto-unblocking; set to 0 to disable auto-unblock
+  timeout: 0,
+
+  // disable if you don't want to show the overlay
+  showOverlay: true,
+
+  // if true, focus will be placed in the first available input field when
+  // page blocking
+  focusInput: true,
+
+  // suppresses the use of overlay styles on FF/Linux (due to performance issues with opacity)
+  applyPlatformOpacityRules: true,
+  
+  // callback method invoked when fadeIn has completed and blocking message is visible
+  onBlock: null,
+
+  // callback method invoked when unblocking has completed; the callback is
+  // passed the element that has been unblocked (which is the window object for page
+  // blocks) and the options that were passed to the unblock call:
+  //   onUnblock(element, options)
+  onUnblock: null,
+
+  // don't ask; if you really must know: http://groups.google.com/group/jquery-en/browse_thread/thread/36640a8730503595/2f6a79a77a78e493#2f6a79a77a78e493
+  quirksmodeOffsetHack: 4,
+
+  // class name of the message block
+  blockMsgClass: 'blockMsg'
 };
 
 // private data and functions follow...
@@ -214,310 +214,310 @@ var pageBlock = null;
 var pageBlockEls = [];
 
 function install(el, opts) {
-	var full = (el == window);
-	var msg = opts && opts.message !== undefined ? opts.message : undefined;
-	opts = $.extend({}, $.blockUI.defaults, opts || {});
-	opts.overlayCSS = $.extend({}, $.blockUI.defaults.overlayCSS, opts.overlayCSS || {});
-	var css = $.extend({}, $.blockUI.defaults.css, opts.css || {});
-	var themedCSS = $.extend({}, $.blockUI.defaults.themedCSS, opts.themedCSS || {});
-	msg = msg === undefined ? opts.message : msg;
-
-	// remove the current block (if there is one)
-	if (full && pageBlock)
-		remove(window, {fadeOut:0});
-
-	// if an existing element is being used as the blocking content then we capture
-	// its current place in the DOM (and current display style) so we can restore
-	// it when we unblock
-	if (msg && typeof msg != 'string' && (msg.parentNode || msg.jquery)) {
-		var node = msg.jquery ? msg[0] : msg;
-		var data = {};
-		$(el).data('blockUI.history', data);
-		data.el = node;
-		data.parent = node.parentNode;
-		data.display = node.style.display;
-		data.position = node.style.position;
-		if (data.parent)
-			data.parent.removeChild(node);
-	}
-
-	$(el).data('blockUI.onUnblock', opts.onUnblock);
-	var z = opts.baseZ;
-
-	// blockUI uses 3 layers for blocking, for simplicity they are all used on every platform;
-	// layer1 is the iframe layer which is used to supress bleed through of underlying content
-	// layer2 is the overlay layer which has opacity and a wait cursor (by default)
-	// layer3 is the message content that is displayed while blocking
-
-	var lyr1 = ($.browser.msie || opts.forceIframe) 
-		? $('<iframe class="blockUI" style="z-index:'+ (z++) +';display:none;border:none;margin:0;padding:0;position:absolute;width:100%;height:100%;top:0;left:0" src="'+opts.iframeSrc+'"></iframe>')
-		: $('<div class="blockUI" style="display:none"></div>');
-	
-	var lyr2 = opts.theme 
-	 	? $('<div class="blockUI blockOverlay ui-widget-overlay" style="z-index:'+ (z++) +';display:none"></div>')
-	 	: $('<div class="blockUI blockOverlay" style="z-index:'+ (z++) +';display:none;border:none;margin:0;padding:0;width:100%;height:100%;top:0;left:0"></div>');
-
-	var lyr3, s;
-	if (opts.theme && full) {
-		s = '<div class="blockUI ' + opts.blockMsgClass + ' blockPage ui-dialog ui-widget ui-corner-all" style="z-index:'+(z+10)+';display:none;position:fixed">' +
-				'<div class="ui-widget-header ui-dialog-titlebar ui-corner-all blockTitle">'+(opts.title || '&nbsp;')+'</div>' +
-				'<div class="ui-widget-content ui-dialog-content"></div>' +
-			'</div>';
-	}
-	else if (opts.theme) {
-		s = '<div class="blockUI ' + opts.blockMsgClass + ' blockElement ui-dialog ui-widget ui-corner-all" style="z-index:'+(z+10)+';display:none;position:absolute">' +
-				'<div class="ui-widget-header ui-dialog-titlebar ui-corner-all blockTitle">'+(opts.title || '&nbsp;')+'</div>' +
-				'<div class="ui-widget-content ui-dialog-content"></div>' +
-			'</div>';
-	}
-	else if (full) {
-		s = '<div class="blockUI ' + opts.blockMsgClass + ' blockPage" style="z-index:'+(z+10)+';display:none;position:fixed"></div>';
-	}			 
-	else {
-		s = '<div class="blockUI ' + opts.blockMsgClass + ' blockElement" style="z-index:'+(z+10)+';display:none;position:absolute"></div>';
-	}
-	lyr3 = $(s);
-
-	// if we have a message, style it
-	if (msg) {
-		if (opts.theme) {
-			lyr3.css(themedCSS);
-			lyr3.addClass('ui-widget-content');
-		}
-		else 
-			lyr3.css(css);
-	}
-
-	// style the overlay
-	if (!opts.theme && (!opts.applyPlatformOpacityRules || !($.browser.mozilla && /Linux/.test(navigator.platform))))
-		lyr2.css(opts.overlayCSS);
-	lyr2.css('position', full ? 'fixed' : 'absolute');
-
-	// make iframe layer transparent in IE
-	if ($.browser.msie || opts.forceIframe)
-		lyr1.css('opacity',0.0);
-
-	//$([lyr1[0],lyr2[0],lyr3[0]]).appendTo(full ? 'body' : el);
-	var layers = [lyr1,lyr2,lyr3], $par = full ? $('body') : $(el);
-	$.each(layers, function() {
-		this.appendTo($par);
-	});
-	
-	if (opts.theme && opts.draggable && $.fn.draggable) {
-		lyr3.draggable({
-			handle: '.ui-dialog-titlebar',
-			cancel: 'li'
-		});
-	}
-
-	// ie7 must use absolute positioning in quirks mode and to account for activex issues (when scrolling)
-	var expr = setExpr && (!$.boxModel || $('object,embed', full ? null : el).length > 0);
-	if (ie6 || expr) {
-		// give body 100% height
-		if (full && opts.allowBodyStretch && $.boxModel)
-			$('html,body').css('height','100%');
-
-		// fix ie6 issue when blocked element has a border width
-		if ((ie6 || !$.boxModel) && !full) {
-			var t = sz(el,'borderTopWidth'), l = sz(el,'borderLeftWidth');
-			var fixT = t ? '(0 - '+t+')' : 0;
-			var fixL = l ? '(0 - '+l+')' : 0;
-		}
-
-		// simulate fixed position
-		$.each([lyr1,lyr2,lyr3], function(i,o) {
-			var s = o[0].style;
-			s.position = 'absolute';
-			if (i < 2) {
-				full ? s.setExpression('height','Math.max(document.body.scrollHeight, document.body.offsetHeight) - (jQuery.boxModel?0:'+opts.quirksmodeOffsetHack+') + "px"')
-					 : s.setExpression('height','this.parentNode.offsetHeight + "px"');
-				full ? s.setExpression('width','jQuery.boxModel && document.documentElement.clientWidth || document.body.clientWidth + "px"')
-					 : s.setExpression('width','this.parentNode.offsetWidth + "px"');
-				if (fixL) s.setExpression('left', fixL);
-				if (fixT) s.setExpression('top', fixT);
-			}
-			else if (opts.centerY) {
-				if (full) s.setExpression('top','(document.documentElement.clientHeight || document.body.clientHeight) / 2 - (this.offsetHeight / 2) + (blah = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop) + "px"');
-				s.marginTop = 0;
-			}
-			else if (!opts.centerY && full) {
-				var top = (opts.css && opts.css.top) ? parseInt(opts.css.top) : 0;
-				var expression = '((document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop) + '+top+') + "px"';
-				s.setExpression('top',expression);
-			}
-		});
-	}
-
-	// show the message
-	if (msg) {
-		if (opts.theme)
-			lyr3.find('.ui-widget-content').append(msg);
-		else
-			lyr3.append(msg);
-		if (msg.jquery || msg.nodeType)
-			$(msg).show();
-	}
-
-	if (($.browser.msie || opts.forceIframe) && opts.showOverlay)
-		lyr1.show(); // opacity is zero
-	if (opts.fadeIn) {
-		var cb = opts.onBlock ? opts.onBlock : noOp;
-		var cb1 = (opts.showOverlay && !msg) ? cb : noOp;
-		var cb2 = msg ? cb : noOp;
-		if (opts.showOverlay)
-			lyr2._fadeIn(opts.fadeIn, cb1);
-		if (msg)
-			lyr3._fadeIn(opts.fadeIn, cb2);
-	}
-	else {
-		if (opts.showOverlay)
-			lyr2.show();
-		if (msg)
-			lyr3.show();
-		if (opts.onBlock)
-			opts.onBlock();
-	}
-
-	// bind key and mouse events
-	bind(1, el, opts);
-
-	if (full) {
-		pageBlock = lyr3[0];
-		pageBlockEls = $(':input:enabled:visible',pageBlock);
-		if (opts.focusInput)
-			setTimeout(focus, 20);
-	}
-	else
-		center(lyr3[0], opts.centerX, opts.centerY);
-
-	if (opts.timeout) {
-		// auto-unblock
-		var to = setTimeout(function() {
-			full ? $.unblockUI(opts) : $(el).unblock(opts);
-		}, opts.timeout);
-		$(el).data('blockUI.timeout', to);
-	}
+  var full = (el == window);
+  var msg = opts && opts.message !== undefined ? opts.message : undefined;
+  opts = $.extend({}, $.blockUI.defaults, opts || {});
+  opts.overlayCSS = $.extend({}, $.blockUI.defaults.overlayCSS, opts.overlayCSS || {});
+  var css = $.extend({}, $.blockUI.defaults.css, opts.css || {});
+  var themedCSS = $.extend({}, $.blockUI.defaults.themedCSS, opts.themedCSS || {});
+  msg = msg === undefined ? opts.message : msg;
+
+  // remove the current block (if there is one)
+  if (full && pageBlock)
+    remove(window, {fadeOut:0});
+
+  // if an existing element is being used as the blocking content then we capture
+  // its current place in the DOM (and current display style) so we can restore
+  // it when we unblock
+  if (msg && typeof msg != 'string' && (msg.parentNode || msg.jquery)) {
+    var node = msg.jquery ? msg[0] : msg;
+    var data = {};
+    $(el).data('blockUI.history', data);
+    data.el = node;
+    data.parent = node.parentNode;
+    data.display = node.style.display;
+    data.position = node.style.position;
+    if (data.parent)
+      data.parent.removeChild(node);
+  }
+
+  $(el).data('blockUI.onUnblock', opts.onUnblock);
+  var z = opts.baseZ;
+
+  // blockUI uses 3 layers for blocking, for simplicity they are all used on every platform;
+  // layer1 is the iframe layer which is used to supress bleed through of underlying content
+  // layer2 is the overlay layer which has opacity and a wait cursor (by default)
+  // layer3 is the message content that is displayed while blocking
+
+  var lyr1 = ($.browser.msie || opts.forceIframe) 
+    ? $('<iframe class="blockUI" style="z-index:'+ (z++) +';display:none;border:none;margin:0;padding:0;position:absolute;width:100%;height:100%;top:0;left:0" src="'+opts.iframeSrc+'"></iframe>')
+    : $('<div class="blockUI" style="display:none"></div>');
+  
+  var lyr2 = opts.theme 
+     ? $('<div class="blockUI blockOverlay ui-widget-overlay" style="z-index:'+ (z++) +';display:none"></div>')
+     : $('<div class="blockUI blockOverlay" style="z-index:'+ (z++) +';display:none;border:none;margin:0;padding:0;width:100%;height:100%;top:0;left:0"></div>');
+
+  var lyr3, s;
+  if (opts.theme && full) {
+    s = '<div class="blockUI ' + opts.blockMsgClass + ' blockPage ui-dialog ui-widget ui-corner-all" style="z-index:'+(z+10)+';display:none;position:fixed">' +
+        '<div class="ui-widget-header ui-dialog-titlebar ui-corner-all blockTitle">'+(opts.title || '&nbsp;')+'</div>' +
+        '<div class="ui-widget-content ui-dialog-content"></div>' +
+      '</div>';
+  }
+  else if (opts.theme) {
+    s = '<div class="blockUI ' + opts.blockMsgClass + ' blockElement ui-dialog ui-widget ui-corner-all" style="z-index:'+(z+10)+';display:none;position:absolute">' +
+        '<div class="ui-widget-header ui-dialog-titlebar ui-corner-all blockTitle">'+(opts.title || '&nbsp;')+'</div>' +
+        '<div class="ui-widget-content ui-dialog-content"></div>' +
+      '</div>';
+  }
+  else if (full) {
+    s = '<div class="blockUI ' + opts.blockMsgClass + ' blockPage" style="z-index:'+(z+10)+';display:none;position:fixed"></div>';
+  }       
+  else {
+    s = '<div class="blockUI ' + opts.blockMsgClass + ' blockElement" style="z-index:'+(z+10)+';display:none;position:absolute"></div>';
+  }
+  lyr3 = $(s);
+
+  // if we have a message, style it
+  if (msg) {
+    if (opts.theme) {
+      lyr3.css(themedCSS);
+      lyr3.addClass('ui-widget-content');
+    }
+    else 
+      lyr3.css(css);
+  }
+
+  // style the overlay
+  if (!opts.theme && (!opts.applyPlatformOpacityRules || !($.browser.mozilla && /Linux/.test(navigator.platform))))
+    lyr2.css(opts.overlayCSS);
+  lyr2.css('position', full ? 'fixed' : 'absolute');
+
+  // make iframe layer transparent in IE
+  if ($.browser.msie || opts.forceIframe)
+    lyr1.css('opacity',0.0);
+
+  //$([lyr1[0],lyr2[0],lyr3[0]]).appendTo(full ? 'body' : el);
+  var layers = [lyr1,lyr2,lyr3], $par = full ? $('body') : $(el);
+  $.each(layers, function() {
+    this.appendTo($par);
+  });
+  
+  if (opts.theme && opts.draggable && $.fn.draggable) {
+    lyr3.draggable({
+      handle: '.ui-dialog-titlebar',
+      cancel: 'li'
+    });
+  }
+
+  // ie7 must use absolute positioning in quirks mode and to account for activex issues (when scrolling)
+  var expr = setExpr && (!$.boxModel || $('object,embed', full ? null : el).length > 0);
+  if (ie6 || expr) {
+    // give body 100% height
+    if (full && opts.allowBodyStretch && $.boxModel)
+      $('html,body').css('height','100%');
+
+    // fix ie6 issue when blocked element has a border width
+    if ((ie6 || !$.boxModel) && !full) {
+      var t = sz(el,'borderTopWidth'), l = sz(el,'borderLeftWidth');
+      var fixT = t ? '(0 - '+t+')' : 0;
+      var fixL = l ? '(0 - '+l+')' : 0;
+    }
+
+    // simulate fixed position
+    $.each([lyr1,lyr2,lyr3], function(i,o) {
+      var s = o[0].style;
+      s.position = 'absolute';
+      if (i < 2) {
+        full ? s.setExpression('height','Math.max(document.body.scrollHeight, document.body.offsetHeight) - (jQuery.boxModel?0:'+opts.quirksmodeOffsetHack+') + "px"')
+           : s.setExpression('height','this.parentNode.offsetHeight + "px"');
+        full ? s.setExpression('width','jQuery.boxModel && document.documentElement.clientWidth || document.body.clientWidth + "px"')
+           : s.setExpression('width','this.parentNode.offsetWidth + "px"');
+        if (fixL) s.setExpression('left', fixL);
+        if (fixT) s.setExpression('top', fixT);
+      }
+      else if (opts.centerY) {
+        if (full) s.setExpression('top','(document.documentElement.clientHeight || document.body.clientHeight) / 2 - (this.offsetHeight / 2) + (blah = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop) + "px"');
+        s.marginTop = 0;
+      }
+      else if (!opts.centerY && full) {
+        var top = (opts.css && opts.css.top) ? parseInt(opts.css.top) : 0;
+        var expression = '((document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop) + '+top+') + "px"';
+        s.setExpression('top',expression);
+      }
+    });
+  }
+
+  // show the message
+  if (msg) {
+    if (opts.theme)
+      lyr3.find('.ui-widget-content').append(msg);
+    else
+      lyr3.append(msg);
+    if (msg.jquery || msg.nodeType)
+      $(msg).show();
+  }
+
+  if (($.browser.msie || opts.forceIframe) && opts.showOverlay)
+    lyr1.show(); // opacity is zero
+  if (opts.fadeIn) {
+    var cb = opts.onBlock ? opts.onBlock : noOp;
+    var cb1 = (opts.showOverlay && !msg) ? cb : noOp;
+    var cb2 = msg ? cb : noOp;
+    if (opts.showOverlay)
+      lyr2._fadeIn(opts.fadeIn, cb1);
+    if (msg)
+      lyr3._fadeIn(opts.fadeIn, cb2);
+  }
+  else {
+    if (opts.showOverlay)
+      lyr2.show();
+    if (msg)
+      lyr3.show();
+    if (opts.onBlock)
+      opts.onBlock();
+  }
+
+  // bind key and mouse events
+  bind(1, el, opts);
+
+  if (full) {
+    pageBlock = lyr3[0];
+    pageBlockEls = $(':input:enabled:visible',pageBlock);
+    if (opts.focusInput)
+      setTimeout(focus, 20);
+  }
+  else
+    center(lyr3[0], opts.centerX, opts.centerY);
+
+  if (opts.timeout) {
+    // auto-unblock
+    var to = setTimeout(function() {
+      full ? $.unblockUI(opts) : $(el).unblock(opts);
+    }, opts.timeout);
+    $(el).data('blockUI.timeout', to);
+  }
 };
 
 // remove the block
 function remove(el, opts) {
-	var full = (el == window);
-	var $el = $(el);
-	var data = $el.data('blockUI.history');
-	var to = $el.data('blockUI.timeout');
-	if (to) {
-		clearTimeout(to);
-		$el.removeData('blockUI.timeout');
-	}
-	opts = $.extend({}, $.blockUI.defaults, opts || {});
-	bind(0, el, opts); // unbind events
-
-	if (opts.onUnblock === null) {
-		opts.onUnblock = $el.data('blockUI.onUnblock');
-		$el.removeData('blockUI.onUnblock');
-	}
-
-	var els;
-	if (full) // crazy selector to handle odd field errors in ie6/7
-		els = $('body').children().filter('.blockUI').add('body > .blockUI');
-	else
-		els = $('.blockUI', el);
-
-	if (full)
-		pageBlock = pageBlockEls = null;
-
-	if (opts.fadeOut) {
-		els.fadeOut(opts.fadeOut);
-		setTimeout(function() { reset(els,data,opts,el); }, opts.fadeOut);
-	}
-	else
-		reset(els, data, opts, el);
+  var full = (el == window);
+  var $el = $(el);
+  var data = $el.data('blockUI.history');
+  var to = $el.data('blockUI.timeout');
+  if (to) {
+    clearTimeout(to);
+    $el.removeData('blockUI.timeout');
+  }
+  opts = $.extend({}, $.blockUI.defaults, opts || {});
+  bind(0, el, opts); // unbind events
+
+  if (opts.onUnblock === null) {
+    opts.onUnblock = $el.data('blockUI.onUnblock');
+    $el.removeData('blockUI.onUnblock');
+  }
+
+  var els;
+  if (full) // crazy selector to handle odd field errors in ie6/7
+    els = $('body').children().filter('.blockUI').add('body > .blockUI');
+  else
+    els = $('.blockUI', el);
+
+  if (full)
+    pageBlock = pageBlockEls = null;
+
+  if (opts.fadeOut) {
+    els.fadeOut(opts.fadeOut);
+    setTimeout(function() { reset(els,data,opts,el); }, opts.fadeOut);
+  }
+  else
+    reset(els, data, opts, el);
 };
 
 // move blocking element back into the DOM where it started
 function reset(els,data,opts,el) {
-	els.each(function(i,o) {
-		// remove via DOM calls so we don't lose event handlers
-		if (this.parentNode)
-			this.parentNode.removeChild(this);
-	});
-
-	if (data && data.el) {
-		data.el.style.display = data.display;
-		data.el.style.position = data.position;
-		if (data.parent)
-			data.parent.appendChild(data.el);
-		$(el).removeData('blockUI.history');
-	}
-
-	if (typeof opts.onUnblock == 'function')
-		opts.onUnblock(el,opts);
+  els.each(function(i,o) {
+    // remove via DOM calls so we don't lose event handlers
+    if (this.parentNode)
+      this.parentNode.removeChild(this);
+  });
+
+  if (data && data.el) {
+    data.el.style.display = data.display;
+    data.el.style.position = data.position;
+    if (data.parent)
+      data.parent.appendChild(data.el);
+    $(el).removeData('blockUI.history');
+  }
+
+  if (typeof opts.onUnblock == 'function')
+    opts.onUnblock(el,opts);
 };
 
 // bind/unbind the handler
 function bind(b, el, opts) {
-	var full = el == window, $el = $(el);
+  var full = el == window, $el = $(el);
 
-	// don't bother unbinding if there is nothing to unbind
-	if (!b && (full && !pageBlock || !full && !$el.data('blockUI.isBlocked')))
-		return;
-	if (!full)
-		$el.data('blockUI.isBlocked', b);
+  // don't bother unbinding if there is nothing to unbind
+  if (!b && (full && !pageBlock || !full && !$el.data('blockUI.isBlocked')))
+    return;
+  if (!full)
+    $el.data('blockUI.isBlocked', b);
 
-	// don't bind events when overlay is not in use or if bindEvents is false
-	if (!opts.bindEvents || (b && !opts.showOverlay)) 
-		return;
+  // don't bind events when overlay is not in use or if bindEvents is false
+  if (!opts.bindEvents || (b && !opts.showOverlay)) 
+    return;
 
-	// bind anchors and inputs for mouse and key events
-	var events = 'mousedown mouseup keydown keypress';
-	b ? $(document).bind(events, opts, handler) : $(document).unbind(events, handler);
+  // bind anchors and inputs for mouse and key events
+  var events = 'mousedown mouseup keydown keypress';
+  b ? $(document).bind(events, opts, handler) : $(document).unbind(events, handler);
 
 // former impl...
-//	   var $e = $('a,:input');
-//	   b ? $e.bind(events, opts, handler) : $e.unbind(events, handler);
+//     var $e = $('a,:input');
+//     b ? $e.bind(events, opts, handler) : $e.unbind(events, handler);
 };
 
 // event handler to suppress keyboard/mouse events when blocking
 function handler(e) {
-	// allow tab navigation (conditionally)
-	if (e.keyCode && e.keyCode == 9) {
-		if (pageBlock && e.data.constrainTabKey) {
-			var els = pageBlockEls;
-			var fwd = !e.shiftKey && e.target === els[els.length-1];
-			var back = e.shiftKey && e.target === els[0];
-			if (fwd || back) {
-				setTimeout(function(){focus(back)},10);
-				return false;
-			}
-		}
-	}
-	var opts = e.data;
-	// allow events within the message content
-	if ($(e.target).parents('div.' + opts.blockMsgClass).length > 0)
-		return true;
-
-	// allow events for content that is not being blocked
-	return $(e.target).parents().children().filter('div.blockUI').length == 0;
+  // allow tab navigation (conditionally)
+  if (e.keyCode && e.keyCode == 9) {
+    if (pageBlock && e.data.constrainTabKey) {
+      var els = pageBlockEls;
+      var fwd = !e.shiftKey && e.target === els[els.length-1];
+      var back = e.shiftKey && e.target === els[0];
+      if (fwd || back) {
+        setTimeout(function(){focus(back)},10);
+        return false;
+      }
+    }
+  }
+  var opts = e.data;
+  // allow events within the message content
+  if ($(e.target).parents('div.' + opts.blockMsgClass).length > 0)
+    return true;
+
+  // allow events for content that is not being blocked
+  return $(e.target).parents().children().filter('div.blockUI').length == 0;
 };
 
 function focus(back) {
-	if (!pageBlockEls)
-		return;
-	var e = pageBlockEls[back===true ? pageBlockEls.length-1 : 0];
-	if (e)
-		e.focus();
+  if (!pageBlockEls)
+    return;
+  var e = pageBlockEls[back===true ? pageBlockEls.length-1 : 0];
+  if (e)
+    e.focus();
 };
 
 function center(el, x, y) {
-	var p = el.parentNode, s = el.style;
-	var l = ((p.offsetWidth - el.offsetWidth)/2) - sz(p,'borderLeftWidth');
-	var t = ((p.offsetHeight - el.offsetHeight)/2) - sz(p,'borderTopWidth');
-	if (x) s.left = l > 0 ? (l+'px') : '0';
-	if (y) s.top  = t > 0 ? (t+'px') : '0';
+  var p = el.parentNode, s = el.style;
+  var l = ((p.offsetWidth - el.offsetWidth)/2) - sz(p,'borderLeftWidth');
+  var t = ((p.offsetHeight - el.offsetHeight)/2) - sz(p,'borderTopWidth');
+  if (x) s.left = l > 0 ? (l+'px') : '0';
+  if (y) s.top  = t > 0 ? (t+'px') : '0';
 };
 
 function sz(el, p) {
-	return parseInt($.css(el,p))||0;
+  return parseInt($.css(el,p))||0;
 };
 
 })(jQuery);
diff --git a/solr/webapp/web/js/lib/jquery.form.js b/solr/webapp/web/js/lib/jquery.form.js
index 63ee4c1..114affc 100644
--- a/solr/webapp/web/js/lib/jquery.form.js
+++ b/solr/webapp/web/js/lib/jquery.form.js
@@ -36,32 +36,32 @@ THE SOFTWARE.
 ;(function($) {
 
 /*
-	Usage Note:
-	-----------
-	Do not use both ajaxSubmit and ajaxForm on the same form.  These
-	functions are intended to be exclusive.  Use ajaxSubmit if you want
-	to bind your own submit handler to the form.  For example,
-
-	$(document).ready(function() {
-		$('#myForm').bind('submit', function() {
-			$(this).ajaxSubmit({
-				target: '#output'
-			});
-			return false; // <-- important!
-		});
-	});
-
-	Use ajaxForm when you want the plugin to manage all the event binding
-	for you.  For example,
-
-	$(document).ready(function() {
-		$('#myForm').ajaxForm({
-			target: '#output'
-		});
-	});
-
-	When using ajaxForm, the ajaxSubmit function will be invoked for you
-	at the appropriate time.
+  Usage Note:
+  -----------
+  Do not use both ajaxSubmit and ajaxForm on the same form.  These
+  functions are intended to be exclusive.  Use ajaxSubmit if you want
+  to bind your own submit handler to the form.  For example,
+
+  $(document).ready(function() {
+    $('#myForm').bind('submit', function() {
+      $(this).ajaxSubmit({
+        target: '#output'
+      });
+      return false; // <-- important!
+    });
+  });
+
+  Use ajaxForm when you want the plugin to manage all the event binding
+  for you.  For example,
+
+  $(document).ready(function() {
+    $('#myForm').ajaxForm({
+      target: '#output'
+    });
+  });
+
+  When using ajaxForm, the ajaxSubmit function will be invoked for you
+  at the appropriate time.
 */
 
 /**
@@ -69,382 +69,382 @@ THE SOFTWARE.
  * an HTML form using AJAX.
  */
 $.fn.ajaxSubmit = function(options) {
-	// fast fail if nothing selected (http://dev.jquery.com/ticket/2752)
-	if (!this.length) {
-		log('ajaxSubmit: skipping submit process - no element selected');
-		return this;
-	}
-
-	if (typeof options == 'function') {
-		options = { success: options };
-	}
-
-	var url = $.trim(this.attr('action'));
-	if (url) {
-		// clean url (don't include hash vaue)
-		url = (url.match(/^([^#]+)/)||[])[1];
-	}
-	url = url || window.location.href || '';
-
-	options = $.extend(true, {
-		url:  url,
-		type: this.attr('method') || 'GET',
-		iframeSrc: /^https/i.test(window.location.href || '') ? 'javascript:false' : 'about:blank'
-	}, options);
-
-	// hook for manipulating the form data before it is extracted;
-	// convenient for use with rich editors like tinyMCE or FCKEditor
-	var veto = {};
-	this.trigger('form-pre-serialize', [this, options, veto]);
-	if (veto.veto) {
-		log('ajaxSubmit: submit vetoed via form-pre-serialize trigger');
-		return this;
-	}
-
-	// provide opportunity to alter form data before it is serialized
-	if (options.beforeSerialize && options.beforeSerialize(this, options) === false) {
-		log('ajaxSubmit: submit aborted via beforeSerialize callback');
-		return this;
-	}
-
-	var n,v,a = this.formToArray(options.semantic);
-	if (options.data) {
-		options.extraData = options.data;
-		for (n in options.data) {
-			if(options.data[n] instanceof Array) {
-				for (var k in options.data[n]) {
-					a.push( { name: n, value: options.data[n][k] } );
-				}
-			}
-			else {
-				v = options.data[n];
-				v = $.isFunction(v) ? v() : v; // if value is fn, invoke it
-				a.push( { name: n, value: v } );
-			}
-		}
-	}
-
-	// give pre-submit callback an opportunity to abort the submit
-	if (options.beforeSubmit && options.beforeSubmit(a, this, options) === false) {
-		log('ajaxSubmit: submit aborted via beforeSubmit callback');
-		return this;
-	}
-
-	// fire vetoable 'validate' event
-	this.trigger('form-submit-validate', [a, this, options, veto]);
-	if (veto.veto) {
-		log('ajaxSubmit: submit vetoed via form-submit-validate trigger');
-		return this;
-	}
-
-	var q = $.param(a);
-
-	if (options.type.toUpperCase() == 'GET') {
-		options.url += (options.url.indexOf('?') >= 0 ? '&' : '?') + q;
-		options.data = null;  // data is null for 'get'
-	}
-	else {
-		options.data = q; // data is the query string for 'post'
-	}
-
-	var $form = this, callbacks = [];
-	if (options.resetForm) {
-		callbacks.push(function() { $form.resetForm(); });
-	}
-	if (options.clearForm) {
-		callbacks.push(function() { $form.clearForm(); });
-	}
-
-	// perform a load on the target only if dataType is not provided
-	if (!options.dataType && options.target) {
-		var oldSuccess = options.success || function(){};
-		callbacks.push(function(data) {
-			var fn = options.replaceTarget ? 'replaceWith' : 'html';
-			$(options.target)[fn](data).each(oldSuccess, arguments);
-		});
-	}
-	else if (options.success) {
-		callbacks.push(options.success);
-	}
-
-	options.success = function(data, status, xhr) { // jQuery 1.4+ passes xhr as 3rd arg
-		var context = options.context || options;   // jQuery 1.4+ supports scope context 
-		for (var i=0, max=callbacks.length; i < max; i++) {
-			callbacks[i].apply(context, [data, status, xhr || $form, $form]);
-		}
-	};
-
-	// are there files to upload?
-	var fileInputs = $('input:file', this).length > 0;
-	var mp = 'multipart/form-data';
-	var multipart = ($form.attr('enctype') == mp || $form.attr('encoding') == mp);
-
-	// options.iframe allows user to force iframe mode
-	// 06-NOV-09: now defaulting to iframe mode if file input is detected
+  // fast fail if nothing selected (http://dev.jquery.com/ticket/2752)
+  if (!this.length) {
+    log('ajaxSubmit: skipping submit process - no element selected');
+    return this;
+  }
+
+  if (typeof options == 'function') {
+    options = { success: options };
+  }
+
+  var url = $.trim(this.attr('action'));
+  if (url) {
+    // clean url (don't include hash vaue)
+    url = (url.match(/^([^#]+)/)||[])[1];
+  }
+  url = url || window.location.href || '';
+
+  options = $.extend(true, {
+    url:  url,
+    type: this.attr('method') || 'GET',
+    iframeSrc: /^https/i.test(window.location.href || '') ? 'javascript:false' : 'about:blank'
+  }, options);
+
+  // hook for manipulating the form data before it is extracted;
+  // convenient for use with rich editors like tinyMCE or FCKEditor
+  var veto = {};
+  this.trigger('form-pre-serialize', [this, options, veto]);
+  if (veto.veto) {
+    log('ajaxSubmit: submit vetoed via form-pre-serialize trigger');
+    return this;
+  }
+
+  // provide opportunity to alter form data before it is serialized
+  if (options.beforeSerialize && options.beforeSerialize(this, options) === false) {
+    log('ajaxSubmit: submit aborted via beforeSerialize callback');
+    return this;
+  }
+
+  var n,v,a = this.formToArray(options.semantic);
+  if (options.data) {
+    options.extraData = options.data;
+    for (n in options.data) {
+      if(options.data[n] instanceof Array) {
+        for (var k in options.data[n]) {
+          a.push( { name: n, value: options.data[n][k] } );
+        }
+      }
+      else {
+        v = options.data[n];
+        v = $.isFunction(v) ? v() : v; // if value is fn, invoke it
+        a.push( { name: n, value: v } );
+      }
+    }
+  }
+
+  // give pre-submit callback an opportunity to abort the submit
+  if (options.beforeSubmit && options.beforeSubmit(a, this, options) === false) {
+    log('ajaxSubmit: submit aborted via beforeSubmit callback');
+    return this;
+  }
+
+  // fire vetoable 'validate' event
+  this.trigger('form-submit-validate', [a, this, options, veto]);
+  if (veto.veto) {
+    log('ajaxSubmit: submit vetoed via form-submit-validate trigger');
+    return this;
+  }
+
+  var q = $.param(a);
+
+  if (options.type.toUpperCase() == 'GET') {
+    options.url += (options.url.indexOf('?') >= 0 ? '&' : '?') + q;
+    options.data = null;  // data is null for 'get'
+  }
+  else {
+    options.data = q; // data is the query string for 'post'
+  }
+
+  var $form = this, callbacks = [];
+  if (options.resetForm) {
+    callbacks.push(function() { $form.resetForm(); });
+  }
+  if (options.clearForm) {
+    callbacks.push(function() { $form.clearForm(); });
+  }
+
+  // perform a load on the target only if dataType is not provided
+  if (!options.dataType && options.target) {
+    var oldSuccess = options.success || function(){};
+    callbacks.push(function(data) {
+      var fn = options.replaceTarget ? 'replaceWith' : 'html';
+      $(options.target)[fn](data).each(oldSuccess, arguments);
+    });
+  }
+  else if (options.success) {
+    callbacks.push(options.success);
+  }
+
+  options.success = function(data, status, xhr) { // jQuery 1.4+ passes xhr as 3rd arg
+    var context = options.context || options;   // jQuery 1.4+ supports scope context 
+    for (var i=0, max=callbacks.length; i < max; i++) {
+      callbacks[i].apply(context, [data, status, xhr || $form, $form]);
+    }
+  };
+
+  // are there files to upload?
+  var fileInputs = $('input:file', this).length > 0;
+  var mp = 'multipart/form-data';
+  var multipart = ($form.attr('enctype') == mp || $form.attr('encoding') == mp);
+
+  // options.iframe allows user to force iframe mode
+  // 06-NOV-09: now defaulting to iframe mode if file input is detected
    if (options.iframe !== false && (fileInputs || options.iframe || multipart)) {
-	   // hack to fix Safari hang (thanks to Tim Molendijk for this)
-	   // see:  http://groups.google.com/group/jquery-dev/browse_thread/thread/36395b7ab510dd5d
-	   if (options.closeKeepAlive) {
-		   $.get(options.closeKeepAlive, fileUpload);
-		}
-	   else {
-		   fileUpload();
-		}
+     // hack to fix Safari hang (thanks to Tim Molendijk for this)
+     // see:  http://groups.google.com/group/jquery-dev/browse_thread/thread/36395b7ab510dd5d
+     if (options.closeKeepAlive) {
+       $.get(options.closeKeepAlive, fileUpload);
+    }
+     else {
+       fileUpload();
+    }
    }
    else {
-	   $.ajax(options);
+     $.ajax(options);
    }
 
-	// fire 'notify' event
-	this.trigger('form-submit-notify', [this, options]);
-	return this;
-
-
-	// private function for handling file uploads (hat tip to YAHOO!)
-	function fileUpload() {
-		var form = $form[0];
-
-		if ($(':input[name=submit],:input[id=submit]', form).length) {
-			// if there is an input with a name or id of 'submit' then we won't be
-			// able to invoke the submit fn on the form (at least not x-browser)
-			alert('Error: Form elements must not have name or id of "submit".');
-			return;
-		}
-		
-		var s = $.extend(true, {}, $.ajaxSettings, options);
-		s.context = s.context || s;
-		var id = 'jqFormIO' + (new Date().getTime()), fn = '_'+id;
-		window[fn] = function() {
-			var f = $io.data('form-plugin-onload');
-			if (f) {
-				f();
-				window[fn] = undefined;
-				try { delete window[fn]; } catch(e){}
-			}
-		}
-		var $io = $('<iframe id="' + id + '" name="' + id + '" src="'+ s.iframeSrc +'" onload="window[\'_\'+this.id]()" />');
-		var io = $io[0];
-
-		$io.css({ position: 'absolute', top: '-1000px', left: '-1000px' });
-
-		var xhr = { // mock object
-			aborted: 0,
-			responseText: null,
-			responseXML: null,
-			status: 0,
-			statusText: 'n/a',
-			getAllResponseHeaders: function() {},
-			getResponseHeader: function() {},
-			setRequestHeader: function() {},
-			abort: function() {
-				this.aborted = 1;
-				$io.attr('src', s.iframeSrc); // abort op in progress
-			}
-		};
-
-		var g = s.global;
-		// trigger ajax global events so that activity/block indicators work like normal
-		if (g && ! $.active++) {
-			$.event.trigger("ajaxStart");
-		}
-		if (g) {
-			$.event.trigger("ajaxSend", [xhr, s]);
-		}
-
-		if (s.beforeSend && s.beforeSend.call(s.context, xhr, s) === false) {
-			if (s.global) { 
-				$.active--;
-			}
-			return;
-		}
-		if (xhr.aborted) {
-			return;
-		}
-
-		var cbInvoked = false;
-		var timedOut = 0;
-
-		// add submitting element to data if we know it
-		var sub = form.clk;
-		if (sub) {
-			var n = sub.name;
-			if (n && !sub.disabled) {
-				s.extraData = s.extraData || {};
-				s.extraData[n] = sub.value;
-				if (sub.type == "image") {
-					s.extraData[n+'.x'] = form.clk_x;
-					s.extraData[n+'.y'] = form.clk_y;
-				}
-			}
-		}
-
-		// take a breath so that pending repaints get some cpu time before the upload starts
-		function doSubmit() {
-			// make sure form attrs are set
-			var t = $form.attr('target'), a = $form.attr('action');
-
-			// update form attrs in IE friendly way
-			form.setAttribute('target',id);
-			if (form.getAttribute('method') != 'POST') {
-				form.setAttribute('method', 'POST');
-			}
-			if (form.getAttribute('action') != s.url) {
-				form.setAttribute('action', s.url);
-			}
-
-			// ie borks in some cases when setting encoding
-			if (! s.skipEncodingOverride) {
-				$form.attr({
-					encoding: 'multipart/form-data',
-					enctype:  'multipart/form-data'
-				});
-			}
-
-			// support timout
-			if (s.timeout) {
-				setTimeout(function() { timedOut = true; cb(); }, s.timeout);
-			}
-
-			// add "extra" data to form if provided in options
-			var extraInputs = [];
-			try {
-				if (s.extraData) {
-					for (var n in s.extraData) {
-						extraInputs.push(
-							$('<input type="hidden" name="'+n+'" value="'+s.extraData[n]+'" />')
-								.appendTo(form)[0]);
-					}
-				}
-
-				// add iframe to doc and submit the form
-				$io.appendTo('body');
-				$io.data('form-plugin-onload', cb);
-				form.submit();
-			}
-			finally {
-				// reset attrs and remove "extra" input elements
-				form.setAttribute('action',a);
-				if(t) {
-					form.setAttribute('target', t);
-				} else {
-					$form.removeAttr('target');
-				}
-				$(extraInputs).remove();
-			}
-		}
-
-		if (s.forceSync) {
-			doSubmit();
-		}
-		else {
-			setTimeout(doSubmit, 10); // this lets dom updates render
-		}
-	
-		var data, doc, domCheckCount = 50;
-
-		function cb() {
-			if (cbInvoked) {
-				return;
-			}
-
-			$io.removeData('form-plugin-onload');
-			
-			var ok = true;
-			try {
-				if (timedOut) {
-					throw 'timeout';
-				}
-				// extract the server response from the iframe
-				doc = io.contentWindow ? io.contentWindow.document : io.contentDocument ? io.contentDocument : io.document;
-				
-				var isXml = s.dataType == 'xml' || doc.XMLDocument || $.isXMLDoc(doc);
-				log('isXml='+isXml);
-				if (!isXml && window.opera && (doc.body == null || doc.body.innerHTML == '')) {
-					if (--domCheckCount) {
-						// in some browsers (Opera) the iframe DOM is not always traversable when
-						// the onload callback fires, so we loop a bit to accommodate
-						log('requeing onLoad callback, DOM not available');
-						setTimeout(cb, 250);
-						return;
-					}
-					// let this fall through because server response could be an empty document
-					//log('Could not access iframe DOM after mutiple tries.');
-					//throw 'DOMException: not available';
-				}
-
-				//log('response detected');
-				cbInvoked = true;
-				xhr.responseText = doc.documentElement ? doc.documentElement.innerHTML : null; 
-				xhr.responseXML = doc.XMLDocument ? doc.XMLDocument : doc;
-				xhr.getResponseHeader = function(header){
-					var headers = {'content-type': s.dataType};
-					return headers[header];
-				};
-
-				var scr = /(json|script)/.test(s.dataType);
-				if (scr || s.textarea) {
-					// see if user embedded response in textarea
-					var ta = doc.getElementsByTagName('textarea')[0];
-					if (ta) {
-						xhr.responseText = ta.value;
-					}
-					else if (scr) {
-						// account for browsers injecting pre around json response
-						var pre = doc.getElementsByTagName('pre')[0];
-						if (pre) {
-							xhr.responseText = pre.innerHTML;
-						}
-					}			  
-				}
-				else if (s.dataType == 'xml' && !xhr.responseXML && xhr.responseText != null) {
-					xhr.responseXML = toXml(xhr.responseText);
-				}
-				data = $.httpData(xhr, s.dataType);
-			}
-			catch(e){
-				log('error caught:',e);
-				ok = false;
-				xhr.error = e;
-				$.handleError(s, xhr, 'error', e);
-			}
-
-			// ordering of these callbacks/triggers is odd, but that's how $.ajax does it
-			if (ok) {
-				s.success.call(s.context, data, 'success', xhr);
-				if (g) {
-					$.event.trigger("ajaxSuccess", [xhr, s]);
-				}
-			}
-			if (g) {
-				$.event.trigger("ajaxComplete", [xhr, s]);
-			}
-			if (g && ! --$.active) {
-				$.event.trigger("ajaxStop");
-			}
-			if (s.complete) {
-				s.complete.call(s.context, xhr, ok ? 'success' : 'error');
-			}
-
-			// clean up
-			setTimeout(function() {
-				$io.removeData('form-plugin-onload');
-				$io.remove();
-				xhr.responseXML = null;
-			}, 100);
-		}
-
-		function toXml(s, doc) {
-			if (window.ActiveXObject) {
-				doc = new ActiveXObject('Microsoft.XMLDOM');
-				doc.async = 'false';
-				doc.loadXML(s);
-			}
-			else {
-				doc = (new DOMParser()).parseFromString(s, 'text/xml');
-			}
-			return (doc && doc.documentElement && doc.documentElement.tagName != 'parsererror') ? doc : null;
-		}
-	}
+  // fire 'notify' event
+  this.trigger('form-submit-notify', [this, options]);
+  return this;
+
+
+  // private function for handling file uploads (hat tip to YAHOO!)
+  function fileUpload() {
+    var form = $form[0];
+
+    if ($(':input[name=submit],:input[id=submit]', form).length) {
+      // if there is an input with a name or id of 'submit' then we won't be
+      // able to invoke the submit fn on the form (at least not x-browser)
+      alert('Error: Form elements must not have name or id of "submit".');
+      return;
+    }
+    
+    var s = $.extend(true, {}, $.ajaxSettings, options);
+    s.context = s.context || s;
+    var id = 'jqFormIO' + (new Date().getTime()), fn = '_'+id;
+    window[fn] = function() {
+      var f = $io.data('form-plugin-onload');
+      if (f) {
+        f();
+        window[fn] = undefined;
+        try { delete window[fn]; } catch(e){}
+      }
+    }
+    var $io = $('<iframe id="' + id + '" name="' + id + '" src="'+ s.iframeSrc +'" onload="window[\'_\'+this.id]()" />');
+    var io = $io[0];
+
+    $io.css({ position: 'absolute', top: '-1000px', left: '-1000px' });
+
+    var xhr = { // mock object
+      aborted: 0,
+      responseText: null,
+      responseXML: null,
+      status: 0,
+      statusText: 'n/a',
+      getAllResponseHeaders: function() {},
+      getResponseHeader: function() {},
+      setRequestHeader: function() {},
+      abort: function() {
+        this.aborted = 1;
+        $io.attr('src', s.iframeSrc); // abort op in progress
+      }
+    };
+
+    var g = s.global;
+    // trigger ajax global events so that activity/block indicators work like normal
+    if (g && ! $.active++) {
+      $.event.trigger("ajaxStart");
+    }
+    if (g) {
+      $.event.trigger("ajaxSend", [xhr, s]);
+    }
+
+    if (s.beforeSend && s.beforeSend.call(s.context, xhr, s) === false) {
+      if (s.global) { 
+        $.active--;
+      }
+      return;
+    }
+    if (xhr.aborted) {
+      return;
+    }
+
+    var cbInvoked = false;
+    var timedOut = 0;
+
+    // add submitting element to data if we know it
+    var sub = form.clk;
+    if (sub) {
+      var n = sub.name;
+      if (n && !sub.disabled) {
+        s.extraData = s.extraData || {};
+        s.extraData[n] = sub.value;
+        if (sub.type == "image") {
+          s.extraData[n+'.x'] = form.clk_x;
+          s.extraData[n+'.y'] = form.clk_y;
+        }
+      }
+    }
+
+    // take a breath so that pending repaints get some cpu time before the upload starts
+    function doSubmit() {
+      // make sure form attrs are set
+      var t = $form.attr('target'), a = $form.attr('action');
+
+      // update form attrs in IE friendly way
+      form.setAttribute('target',id);
+      if (form.getAttribute('method') != 'POST') {
+        form.setAttribute('method', 'POST');
+      }
+      if (form.getAttribute('action') != s.url) {
+        form.setAttribute('action', s.url);
+      }
+
+      // ie borks in some cases when setting encoding
+      if (! s.skipEncodingOverride) {
+        $form.attr({
+          encoding: 'multipart/form-data',
+          enctype:  'multipart/form-data'
+        });
+      }
+
+      // support timout
+      if (s.timeout) {
+        setTimeout(function() { timedOut = true; cb(); }, s.timeout);
+      }
+
+      // add "extra" data to form if provided in options
+      var extraInputs = [];
+      try {
+        if (s.extraData) {
+          for (var n in s.extraData) {
+            extraInputs.push(
+              $('<input type="hidden" name="'+n+'" value="'+s.extraData[n]+'" />')
+                .appendTo(form)[0]);
+          }
+        }
+
+        // add iframe to doc and submit the form
+        $io.appendTo('body');
+        $io.data('form-plugin-onload', cb);
+        form.submit();
+      }
+      finally {
+        // reset attrs and remove "extra" input elements
+        form.setAttribute('action',a);
+        if(t) {
+          form.setAttribute('target', t);
+        } else {
+          $form.removeAttr('target');
+        }
+        $(extraInputs).remove();
+      }
+    }
+
+    if (s.forceSync) {
+      doSubmit();
+    }
+    else {
+      setTimeout(doSubmit, 10); // this lets dom updates render
+    }
+  
+    var data, doc, domCheckCount = 50;
+
+    function cb() {
+      if (cbInvoked) {
+        return;
+      }
+
+      $io.removeData('form-plugin-onload');
+      
+      var ok = true;
+      try {
+        if (timedOut) {
+          throw 'timeout';
+        }
+        // extract the server response from the iframe
+        doc = io.contentWindow ? io.contentWindow.document : io.contentDocument ? io.contentDocument : io.document;
+        
+        var isXml = s.dataType == 'xml' || doc.XMLDocument || $.isXMLDoc(doc);
+        log('isXml='+isXml);
+        if (!isXml && window.opera && (doc.body == null || doc.body.innerHTML == '')) {
+          if (--domCheckCount) {
+            // in some browsers (Opera) the iframe DOM is not always traversable when
+            // the onload callback fires, so we loop a bit to accommodate
+            log('requeing onLoad callback, DOM not available');
+            setTimeout(cb, 250);
+            return;
+          }
+          // let this fall through because server response could be an empty document
+          //log('Could not access iframe DOM after mutiple tries.');
+          //throw 'DOMException: not available';
+        }
+
+        //log('response detected');
+        cbInvoked = true;
+        xhr.responseText = doc.documentElement ? doc.documentElement.innerHTML : null; 
+        xhr.responseXML = doc.XMLDocument ? doc.XMLDocument : doc;
+        xhr.getResponseHeader = function(header){
+          var headers = {'content-type': s.dataType};
+          return headers[header];
+        };
+
+        var scr = /(json|script)/.test(s.dataType);
+        if (scr || s.textarea) {
+          // see if user embedded response in textarea
+          var ta = doc.getElementsByTagName('textarea')[0];
+          if (ta) {
+            xhr.responseText = ta.value;
+          }
+          else if (scr) {
+            // account for browsers injecting pre around json response
+            var pre = doc.getElementsByTagName('pre')[0];
+            if (pre) {
+              xhr.responseText = pre.innerHTML;
+            }
+          }        
+        }
+        else if (s.dataType == 'xml' && !xhr.responseXML && xhr.responseText != null) {
+          xhr.responseXML = toXml(xhr.responseText);
+        }
+        data = $.httpData(xhr, s.dataType);
+      }
+      catch(e){
+        log('error caught:',e);
+        ok = false;
+        xhr.error = e;
+        $.handleError(s, xhr, 'error', e);
+      }
+
+      // ordering of these callbacks/triggers is odd, but that's how $.ajax does it
+      if (ok) {
+        s.success.call(s.context, data, 'success', xhr);
+        if (g) {
+          $.event.trigger("ajaxSuccess", [xhr, s]);
+        }
+      }
+      if (g) {
+        $.event.trigger("ajaxComplete", [xhr, s]);
+      }
+      if (g && ! --$.active) {
+        $.event.trigger("ajaxStop");
+      }
+      if (s.complete) {
+        s.complete.call(s.context, xhr, ok ? 'success' : 'error');
+      }
+
+      // clean up
+      setTimeout(function() {
+        $io.removeData('form-plugin-onload');
+        $io.remove();
+        xhr.responseXML = null;
+      }, 100);
+    }
+
+    function toXml(s, doc) {
+      if (window.ActiveXObject) {
+        doc = new ActiveXObject('Microsoft.XMLDOM');
+        doc.async = 'false';
+        doc.loadXML(s);
+      }
+      else {
+        doc = (new DOMParser()).parseFromString(s, 'text/xml');
+      }
+      return (doc && doc.documentElement && doc.documentElement.tagName != 'parsererror') ? doc : null;
+    }
+  }
 };
 
 /**
@@ -453,9 +453,9 @@ $.fn.ajaxSubmit = function(options) {
  * The advantages of using this method instead of ajaxSubmit() are:
  *
  * 1: This method will include coordinates for <input type="image" /> elements (if the element
- *	is used to submit the form).
+ *  is used to submit the form).
  * 2. This method will include the submit element's name/value data (for the element that was
- *	used to submit the form).
+ *  used to submit the form).
  * 3. This method binds the submit() method to the form for you.
  *
  * The options argument for ajaxForm works exactly as it does for ajaxSubmit.  ajaxForm merely
@@ -463,60 +463,60 @@ $.fn.ajaxSubmit = function(options) {
  * the form itself.
  */
 $.fn.ajaxForm = function(options) {
-	// in jQuery 1.3+ we can fix mistakes with the ready state
-	if (this.length === 0) {
-		var o = { s: this.selector, c: this.context };
-		if (!$.isReady && o.s) {
-			log('DOM not ready, queuing ajaxForm');
-			$(function() {
-				$(o.s,o.c).ajaxForm(options);
-			});
-			return this;
-		}
-		// is your DOM ready?  http://docs.jquery.com/Tutorials:Introducing_$(document).ready()
-		log('terminating; zero elements found by selector' + ($.isReady ? '' : ' (DOM not ready)'));
-		return this;
-	}
-	
-	return this.ajaxFormUnbind().bind('submit.form-plugin', function(e) {
-		if (!e.isDefaultPrevented()) { // if event has been canceled, don't proceed
-			e.preventDefault();
-			$(this).ajaxSubmit(options);
-		}
-	}).bind('click.form-plugin', function(e) {
-		var target = e.target;
-		var $el = $(target);
-		if (!($el.is(":submit,input:image"))) {
-			// is this a child element of the submit el?  (ex: a span within a button)
-			var t = $el.closest(':submit');
-			if (t.length == 0) {
-				return;
-			}
-			target = t[0];
-		}
-		var form = this;
-		form.clk = target;
-		if (target.type == 'image') {
-			if (e.offsetX != undefined) {
-				form.clk_x = e.offsetX;
-				form.clk_y = e.offsetY;
-			} else if (typeof $.fn.offset == 'function') { // try to use dimensions plugin
-				var offset = $el.offset();
-				form.clk_x = e.pageX - offset.left;
-				form.clk_y = e.pageY - offset.top;
-			} else {
-				form.clk_x = e.pageX - target.offsetLeft;
-				form.clk_y = e.pageY - target.offsetTop;
-			}
-		}
-		// clear form vars
-		setTimeout(function() { form.clk = form.clk_x = form.clk_y = null; }, 100);
-	});
+  // in jQuery 1.3+ we can fix mistakes with the ready state
+  if (this.length === 0) {
+    var o = { s: this.selector, c: this.context };
+    if (!$.isReady && o.s) {
+      log('DOM not ready, queuing ajaxForm');
+      $(function() {
+        $(o.s,o.c).ajaxForm(options);
+      });
+      return this;
+    }
+    // is your DOM ready?  http://docs.jquery.com/Tutorials:Introducing_$(document).ready()
+    log('terminating; zero elements found by selector' + ($.isReady ? '' : ' (DOM not ready)'));
+    return this;
+  }
+  
+  return this.ajaxFormUnbind().bind('submit.form-plugin', function(e) {
+    if (!e.isDefaultPrevented()) { // if event has been canceled, don't proceed
+      e.preventDefault();
+      $(this).ajaxSubmit(options);
+    }
+  }).bind('click.form-plugin', function(e) {
+    var target = e.target;
+    var $el = $(target);
+    if (!($el.is(":submit,input:image"))) {
+      // is this a child element of the submit el?  (ex: a span within a button)
+      var t = $el.closest(':submit');
+      if (t.length == 0) {
+        return;
+      }
+      target = t[0];
+    }
+    var form = this;
+    form.clk = target;
+    if (target.type == 'image') {
+      if (e.offsetX != undefined) {
+        form.clk_x = e.offsetX;
+        form.clk_y = e.offsetY;
+      } else if (typeof $.fn.offset == 'function') { // try to use dimensions plugin
+        var offset = $el.offset();
+        form.clk_x = e.pageX - offset.left;
+        form.clk_y = e.pageY - offset.top;
+      } else {
+        form.clk_x = e.pageX - target.offsetLeft;
+        form.clk_y = e.pageY - target.offsetTop;
+      }
+    }
+    // clear form vars
+    setTimeout(function() { form.clk = form.clk_x = form.clk_y = null; }, 100);
+  });
 };
 
 // ajaxFormUnbind unbinds the event handlers that were bound by ajaxForm
 $.fn.ajaxFormUnbind = function() {
-	return this.unbind('submit.form-plugin click.form-plugin');
+  return this.unbind('submit.form-plugin click.form-plugin');
 };
 
 /**
@@ -531,55 +531,55 @@ $.fn.ajaxFormUnbind = function() {
  * ajaxSubmit() and ajaxForm() methods.
  */
 $.fn.formToArray = function(semantic) {
-	var a = [];
-	if (this.length === 0) {
-		return a;
-	}
-
-	var form = this[0];
-	var els = semantic ? form.getElementsByTagName('*') : form.elements;
-	if (!els) {
-		return a;
-	}
-	
-	var i,j,n,v,el;
-	for(i=0, max=els.length; i < max; i++) {
-		el = els[i];
-		n = el.name;
-		if (!n) {
-			continue;
-		}
-
-		if (semantic && form.clk && el.type == "image") {
-			// handle image inputs on the fly when semantic == true
-			if(!el.disabled && form.clk == el) {
-				a.push({name: n, value: $(el).val()});
-				a.push({name: n+'.x', value: form.clk_x}, {name: n+'.y', value: form.clk_y});
-			}
-			continue;
-		}
-
-		v = $.fieldValue(el, true);
-		if (v && v.constructor == Array) {
-			for(j=0, jmax=v.length; j < jmax; j++) {
-				a.push({name: n, value: v[j]});
-			}
-		}
-		else if (v !== null && typeof v != 'undefined') {
-			a.push({name: n, value: v});
-		}
-	}
-
-	if (!semantic && form.clk) {
-		// input type=='image' are not found in elements array! handle it here
-		var $input = $(form.clk), input = $input[0];
-		n = input.name;
-		if (n && !input.disabled && input.type == 'image') {
-			a.push({name: n, value: $input.val()});
-			a.push({name: n+'.x', value: form.clk_x}, {name: n+'.y', value: form.clk_y});
-		}
-	}
-	return a;
+  var a = [];
+  if (this.length === 0) {
+    return a;
+  }
+
+  var form = this[0];
+  var els = semantic ? form.getElementsByTagName('*') : form.elements;
+  if (!els) {
+    return a;
+  }
+  
+  var i,j,n,v,el;
+  for(i=0, max=els.length; i < max; i++) {
+    el = els[i];
+    n = el.name;
+    if (!n) {
+      continue;
+    }
+
+    if (semantic && form.clk && el.type == "image") {
+      // handle image inputs on the fly when semantic == true
+      if(!el.disabled && form.clk == el) {
+        a.push({name: n, value: $(el).val()});
+        a.push({name: n+'.x', value: form.clk_x}, {name: n+'.y', value: form.clk_y});
+      }
+      continue;
+    }
+
+    v = $.fieldValue(el, true);
+    if (v && v.constructor == Array) {
+      for(j=0, jmax=v.length; j < jmax; j++) {
+        a.push({name: n, value: v[j]});
+      }
+    }
+    else if (v !== null && typeof v != 'undefined') {
+      a.push({name: n, value: v});
+    }
+  }
+
+  if (!semantic && form.clk) {
+    // input type=='image' are not found in elements array! handle it here
+    var $input = $(form.clk), input = $input[0];
+    n = input.name;
+    if (n && !input.disabled && input.type == 'image') {
+      a.push({name: n, value: $input.val()});
+      a.push({name: n+'.x', value: form.clk_x}, {name: n+'.y', value: form.clk_y});
+    }
+  }
+  return a;
 };
 
 /**
@@ -587,8 +587,8 @@ $.fn.formToArray = function(semantic) {
  * in the format: name1=value1&amp;name2=value2
  */
 $.fn.formSerialize = function(semantic) {
-	//hand off to jQuery.param for proper encoding
-	return $.param(this.formToArray(semantic));
+  //hand off to jQuery.param for proper encoding
+  return $.param(this.formToArray(semantic));
 };
 
 /**
@@ -596,36 +596,36 @@ $.fn.formSerialize = function(semantic) {
  * This method will return a string in the format: name1=value1&amp;name2=value2
  */
 $.fn.fieldSerialize = function(successful) {
-	var a = [];
-	this.each(function() {
-		var n = this.name;
-		if (!n) {
-			return;
-		}
-		var v = $.fieldValue(this, successful);
-		if (v && v.constructor == Array) {
-			for (var i=0,max=v.length; i < max; i++) {
-				a.push({name: n, value: v[i]});
-			}
-		}
-		else if (v !== null && typeof v != 'undefined') {
-			a.push({name: this.name, value: v});
-		}
-	});
-	//hand off to jQuery.param for proper encoding
-	return $.param(a);
+  var a = [];
+  this.each(function() {
+    var n = this.name;
+    if (!n) {
+      return;
+    }
+    var v = $.fieldValue(this, successful);
+    if (v && v.constructor == Array) {
+      for (var i=0,max=v.length; i < max; i++) {
+        a.push({name: n, value: v[i]});
+      }
+    }
+    else if (v !== null && typeof v != 'undefined') {
+      a.push({name: this.name, value: v});
+    }
+  });
+  //hand off to jQuery.param for proper encoding
+  return $.param(a);
 };
 
 /**
  * Returns the value(s) of the element in the matched set.  For example, consider the following form:
  *
  *  <form><fieldset>
- *	  <input name="A" type="text" />
- *	  <input name="A" type="text" />
- *	  <input name="B" type="checkbox" value="B1" />
- *	  <input name="B" type="checkbox" value="B2"/>
- *	  <input name="C" type="radio" value="C1" />
- *	  <input name="C" type="radio" value="C2" />
+ *    <input name="A" type="text" />
+ *    <input name="A" type="text" />
+ *    <input name="B" type="checkbox" value="B1" />
+ *    <input name="B" type="checkbox" value="B2"/>
+ *    <input name="C" type="radio" value="C1" />
+ *    <input name="C" type="radio" value="C2" />
  *  </fieldset></form>
  *
  *  var v = $(':text').fieldValue();
@@ -652,60 +652,60 @@ $.fn.fieldSerialize = function(successful) {
  * for each element is returned.
  *
  * Note: This method *always* returns an array.  If no valid value can be determined the
- *	   array will be empty, otherwise it will contain one or more values.
+ *     array will be empty, otherwise it will contain one or more values.
  */
 $.fn.fieldValue = function(successful) {
-	for (var val=[], i=0, max=this.length; i < max; i++) {
-		var el = this[i];
-		var v = $.fieldValue(el, successful);
-		if (v === null || typeof v == 'undefined' || (v.constructor == Array && !v.length)) {
-			continue;
-		}
-		v.constructor == Array ? $.merge(val, v) : val.push(v);
-	}
-	return val;
+  for (var val=[], i=0, max=this.length; i < max; i++) {
+    var el = this[i];
+    var v = $.fieldValue(el, successful);
+    if (v === null || typeof v == 'undefined' || (v.constructor == Array && !v.length)) {
+      continue;
+    }
+    v.constructor == Array ? $.merge(val, v) : val.push(v);
+  }
+  return val;
 };
 
 /**
  * Returns the value of the field element.
  */
 $.fieldValue = function(el, successful) {
-	var n = el.name, t = el.type, tag = el.tagName.toLowerCase();
-	if (successful === undefined) {
-		successful = true;
-	}
-
-	if (successful && (!n || el.disabled || t == 'reset' || t == 'button' ||
-		(t == 'checkbox' || t == 'radio') && !el.checked ||
-		(t == 'submit' || t == 'image') && el.form && el.form.clk != el ||
-		tag == 'select' && el.selectedIndex == -1)) {
-			return null;
-	}
-
-	if (tag == 'select') {
-		var index = el.selectedIndex;
-		if (index < 0) {
-			return null;
-		}
-		var a = [], ops = el.options;
-		var one = (t == 'select-one');
-		var max = (one ? index+1 : ops.length);
-		for(var i=(one ? index : 0); i < max; i++) {
-			var op = ops[i];
-			if (op.selected) {
-				var v = op.value;
-				if (!v) { // extra pain for IE...
-					v = (op.attributes && op.attributes['value'] && !(op.attributes['value'].specified)) ? op.text : op.value;
-				}
-				if (one) {
-					return v;
-				}
-				a.push(v);
-			}
-		}
-		return a;
-	}
-	return $(el).val();
+  var n = el.name, t = el.type, tag = el.tagName.toLowerCase();
+  if (successful === undefined) {
+    successful = true;
+  }
+
+  if (successful && (!n || el.disabled || t == 'reset' || t == 'button' ||
+    (t == 'checkbox' || t == 'radio') && !el.checked ||
+    (t == 'submit' || t == 'image') && el.form && el.form.clk != el ||
+    tag == 'select' && el.selectedIndex == -1)) {
+      return null;
+  }
+
+  if (tag == 'select') {
+    var index = el.selectedIndex;
+    if (index < 0) {
+      return null;
+    }
+    var a = [], ops = el.options;
+    var one = (t == 'select-one');
+    var max = (one ? index+1 : ops.length);
+    for(var i=(one ? index : 0); i < max; i++) {
+      var op = ops[i];
+      if (op.selected) {
+        var v = op.value;
+        if (!v) { // extra pain for IE...
+          v = (op.attributes && op.attributes['value'] && !(op.attributes['value'].specified)) ? op.text : op.value;
+        }
+        if (one) {
+          return v;
+        }
+        a.push(v);
+      }
+    }
+    return a;
+  }
+  return $(el).val();
 };
 
 /**
@@ -717,52 +717,52 @@ $.fieldValue = function(el, successful) {
  *  - button elements will *not* be effected
  */
 $.fn.clearForm = function() {
-	return this.each(function() {
-		$('input,select,textarea', this).clearFields();
-	});
+  return this.each(function() {
+    $('input,select,textarea', this).clearFields();
+  });
 };
 
 /**
  * Clears the selected form elements.
  */
 $.fn.clearFields = $.fn.clearInputs = function() {
-	return this.each(function() {
-		var t = this.type, tag = this.tagName.toLowerCase();
-		if (t == 'text' || t == 'password' || tag == 'textarea') {
-			this.value = '';
-		}
-		else if (t == 'checkbox' || t == 'radio') {
-			this.checked = false;
-		}
-		else if (tag == 'select') {
-			this.selectedIndex = -1;
-		}
-	});
+  return this.each(function() {
+    var t = this.type, tag = this.tagName.toLowerCase();
+    if (t == 'text' || t == 'password' || tag == 'textarea') {
+      this.value = '';
+    }
+    else if (t == 'checkbox' || t == 'radio') {
+      this.checked = false;
+    }
+    else if (tag == 'select') {
+      this.selectedIndex = -1;
+    }
+  });
 };
 
 /**
  * Resets the form data.  Causes all form elements to be reset to their original value.
  */
 $.fn.resetForm = function() {
-	return this.each(function() {
-		// guard against an input with the name of 'reset'
-		// note that IE reports the reset function as an 'object'
-		if (typeof this.reset == 'function' || (typeof this.reset == 'object' && !this.reset.nodeType)) {
-			this.reset();
-		}
-	});
+  return this.each(function() {
+    // guard against an input with the name of 'reset'
+    // note that IE reports the reset function as an 'object'
+    if (typeof this.reset == 'function' || (typeof this.reset == 'object' && !this.reset.nodeType)) {
+      this.reset();
+    }
+  });
 };
 
 /**
  * Enables or disables any matching elements.
  */
 $.fn.enable = function(b) {
-	if (b === undefined) {
-		b = true;
-	}
-	return this.each(function() {
-		this.disabled = !b;
-	});
+  if (b === undefined) {
+    b = true;
+  }
+  return this.each(function() {
+    this.disabled = !b;
+  });
 };
 
 /**
@@ -770,37 +770,37 @@ $.fn.enable = function(b) {
  * selects/deselects and matching option elements.
  */
 $.fn.selected = function(select) {
-	if (select === undefined) {
-		select = true;
-	}
-	return this.each(function() {
-		var t = this.type;
-		if (t == 'checkbox' || t == 'radio') {
-			this.checked = select;
-		}
-		else if (this.tagName.toLowerCase() == 'option') {
-			var $sel = $(this).parent('select');
-			if (select && $sel[0] && $sel[0].type == 'select-one') {
-				// deselect all other options
-				$sel.find('option').selected(false);
-			}
-			this.selected = select;
-		}
-	});
+  if (select === undefined) {
+    select = true;
+  }
+  return this.each(function() {
+    var t = this.type;
+    if (t == 'checkbox' || t == 'radio') {
+      this.checked = select;
+    }
+    else if (this.tagName.toLowerCase() == 'option') {
+      var $sel = $(this).parent('select');
+      if (select && $sel[0] && $sel[0].type == 'select-one') {
+        // deselect all other options
+        $sel.find('option').selected(false);
+      }
+      this.selected = select;
+    }
+  });
 };
 
 // helper fn for console logging
 // set $.fn.ajaxSubmit.debug to true to enable debug logging
 function log() {
-	if ($.fn.ajaxSubmit.debug) {
-		var msg = '[jquery.form] ' + Array.prototype.join.call(arguments,'');
-		if (window.console && window.console.log) {
-			window.console.log(msg);
-		}
-		else if (window.opera && window.opera.postError) {
-			window.opera.postError(msg);
-		}
-	}
+  if ($.fn.ajaxSubmit.debug) {
+    var msg = '[jquery.form] ' + Array.prototype.join.call(arguments,'');
+    if (window.console && window.console.log) {
+      window.console.log(msg);
+    }
+    else if (window.opera && window.opera.postError) {
+      window.opera.postError(msg);
+    }
+  }
 };
 
 })(jQuery);
diff --git a/solr/webapp/web/js/lib/jquery.jstree.js b/solr/webapp/web/js/lib/jquery.jstree.js
index 20c2f60..50c1767 100644
--- a/solr/webapp/web/js/lib/jquery.jstree.js
+++ b/solr/webapp/web/js/lib/jquery.jstree.js
@@ -43,802 +43,802 @@ THE SOFTWARE.
 // Common functions not related to jsTree 
 // decided to move them to a `vakata` "namespace"
 (function ($) {
-	$.vakata = {};
-	// CSS related functions
-	$.vakata.css = {
-		get_css : function(rule_name, delete_flag, sheet) {
-			rule_name = rule_name.toLowerCase();
-			var css_rules = sheet.cssRules || sheet.rules,
-				j = 0;
-			do {
-				if(css_rules.length && j > css_rules.length + 5) { return false; }
-				if(css_rules[j].selectorText && css_rules[j].selectorText.toLowerCase() == rule_name) {
-					if(delete_flag === true) {
-						if(sheet.removeRule) { sheet.removeRule(j); }
-						if(sheet.deleteRule) { sheet.deleteRule(j); }
-						return true;
-					}
-					else { return css_rules[j]; }
-				}
-			}
-			while (css_rules[++j]);
-			return false;
-		},
-		add_css : function(rule_name, sheet) {
-			if($.jstree.css.get_css(rule_name, false, sheet)) { return false; }
-			if(sheet.insertRule) { sheet.insertRule(rule_name + ' { }', 0); } else { sheet.addRule(rule_name, null, 0); }
-			return $.vakata.css.get_css(rule_name);
-		},
-		remove_css : function(rule_name, sheet) { 
-			return $.vakata.css.get_css(rule_name, true, sheet); 
-		},
-		add_sheet : function(opts) {
-			var tmp;
-			if(opts.str) {
-				tmp = document.createElement("style");
-				tmp.setAttribute('type',"text/css");
-				if(tmp.styleSheet) {
-					document.getElementsByTagName("head")[0].appendChild(tmp);
-					tmp.styleSheet.cssText = opts.str;
-				}
-				else {
-					tmp.appendChild(document.createTextNode(opts.str));
-					document.getElementsByTagName("head")[0].appendChild(tmp);
-				}
-				return tmp.sheet || tmp.styleSheet;
-			}
-			if(opts.url) {
-				if(document.createStyleSheet) {
-					try { tmp = document.createStyleSheet(opts.url); } catch (e) { }
-				}
-				else {
-					tmp			= document.createElement('link');
-					tmp.rel		= 'stylesheet';
-					tmp.type	= 'text/css';
-					tmp.media	= "all";
-					tmp.href	= opts.url;
-					document.getElementsByTagName("head")[0].appendChild(tmp);
-					return tmp.styleSheet;
-				}
-			}
-		}
-	};
+  $.vakata = {};
+  // CSS related functions
+  $.vakata.css = {
+    get_css : function(rule_name, delete_flag, sheet) {
+      rule_name = rule_name.toLowerCase();
+      var css_rules = sheet.cssRules || sheet.rules,
+        j = 0;
+      do {
+        if(css_rules.length && j > css_rules.length + 5) { return false; }
+        if(css_rules[j].selectorText && css_rules[j].selectorText.toLowerCase() == rule_name) {
+          if(delete_flag === true) {
+            if(sheet.removeRule) { sheet.removeRule(j); }
+            if(sheet.deleteRule) { sheet.deleteRule(j); }
+            return true;
+          }
+          else { return css_rules[j]; }
+        }
+      }
+      while (css_rules[++j]);
+      return false;
+    },
+    add_css : function(rule_name, sheet) {
+      if($.jstree.css.get_css(rule_name, false, sheet)) { return false; }
+      if(sheet.insertRule) { sheet.insertRule(rule_name + ' { }', 0); } else { sheet.addRule(rule_name, null, 0); }
+      return $.vakata.css.get_css(rule_name);
+    },
+    remove_css : function(rule_name, sheet) { 
+      return $.vakata.css.get_css(rule_name, true, sheet); 
+    },
+    add_sheet : function(opts) {
+      var tmp;
+      if(opts.str) {
+        tmp = document.createElement("style");
+        tmp.setAttribute('type',"text/css");
+        if(tmp.styleSheet) {
+          document.getElementsByTagName("head")[0].appendChild(tmp);
+          tmp.styleSheet.cssText = opts.str;
+        }
+        else {
+          tmp.appendChild(document.createTextNode(opts.str));
+          document.getElementsByTagName("head")[0].appendChild(tmp);
+        }
+        return tmp.sheet || tmp.styleSheet;
+      }
+      if(opts.url) {
+        if(document.createStyleSheet) {
+          try { tmp = document.createStyleSheet(opts.url); } catch (e) { }
+        }
+        else {
+          tmp      = document.createElement('link');
+          tmp.rel    = 'stylesheet';
+          tmp.type  = 'text/css';
+          tmp.media  = "all";
+          tmp.href  = opts.url;
+          document.getElementsByTagName("head")[0].appendChild(tmp);
+          return tmp.styleSheet;
+        }
+      }
+    }
+  };
 })(jQuery);
 
 /* 
  * jsTree core 1.0
  */
 (function ($) {
-	// private variables 
-	var instances = [],			// instance array (used by $.jstree.reference/create/focused)
-		focused_instance = -1,	// the index in the instance array of the currently focused instance
-		plugins = {},			// list of included plugins
-		prepared_move = {},		// for the move plugin
-		is_ie6 = false;
-
-	// jQuery plugin wrapper (thanks to jquery UI widget function)
-	$.fn.jstree = function (settings) {
-		var isMethodCall = (typeof settings == 'string'), // is this a method call like $().jstree("open_node")
-			args = Array.prototype.slice.call(arguments, 1), 
-			returnValue = this;
-
-		// extend settings and allow for multiple hashes and metadata
-		if(!isMethodCall && $.meta) { args.push($.metadata.get(this).jstree); }
-		settings = !isMethodCall && args.length ? $.extend.apply(null, [true, settings].concat(args)) : settings;
-		// block calls to "private" methods
-		if(isMethodCall && settings.substring(0, 1) == '_') { return returnValue; }
-
-		// if a method call execute the method on all selected instances
-		if(isMethodCall) {
-			this.each(function() {
-				var instance = instances[$.data(this, "jstree-instance-id")],
-					methodValue = (instance && $.isFunction(instance[settings])) ? instance[settings].apply(instance, args) : instance;
-					if(typeof methodValue !== "undefined" && (settings.indexOf("is_" === 0) || (methodValue !== true && methodValue !== false))) { returnValue = methodValue; return false; }
-			});
-		}
-		else {
-			this.each(function() {
-				var instance_id = $.data(this, "jstree-instance-id"),
-					s = false;
-				// if an instance already exists, destroy it first
-				if(typeof instance_id !== "undefined" && instances[instance_id]) { instances[instance_id].destroy(); }
-				// push a new empty object to the instances array
-				instance_id = parseInt(instances.push({}),10) - 1;
-				// store the jstree instance id to the container element
-				$.data(this, "jstree-instance-id", instance_id);
-				// clean up all plugins
-				if(!settings) { settings = {}; }
-				settings.plugins = $.isArray(settings.plugins) ? settings.plugins : $.jstree.defaults.plugins;
-				if($.inArray("core", settings.plugins) === -1) { settings.plugins.unshift("core"); }
-				
-				// only unique plugins (NOT WORKING)
-				// settings.plugins = settings.plugins.sort().join(",,").replace(/(,|^)([^,]+)(,,\2)+(,|$)/g,"$1$2$4").replace(/,,+/g,",").replace(/,$/,"").split(",");
-
-				// extend defaults with passed data
-				s = $.extend(true, {}, $.jstree.defaults, settings);
-				s.plugins = settings.plugins;
-				$.each(plugins, function (i, val) { if($.inArray(i, s.plugins) === -1) { s[i] = null; delete s[i]; } });
-				// push the new object to the instances array (at the same time set the default classes to the container) and init
-				instances[instance_id] = new $.jstree._instance(instance_id, $(this).addClass("jstree jstree-" + instance_id), s); 
-				// init all activated plugins for this instance
-				$.each(instances[instance_id]._get_settings().plugins, function (i, val) { instances[instance_id].data[val] = {}; });
-				$.each(instances[instance_id]._get_settings().plugins, function (i, val) { if(plugins[val]) { plugins[val].__init.apply(instances[instance_id]); } });
-				// initialize the instance
-				instances[instance_id].init();
-			});
-		}
-		// return the jquery selection (or if it was a method call that returned a value - the returned value)
-		return returnValue;
-	};
-	// object to store exposed functions and objects
-	$.jstree = {
-		defaults : {
-			plugins : []
-		},
-		_focused : function () { return instances[focused_instance] || null; },
-		_reference : function (needle) { 
-			// get by instance id
-			if(instances[needle]) { return instances[needle]; }
-			// get by DOM (if still no luck - return null
-			var o = $(needle); 
-			if(!o.length && typeof needle === "string") { o = $("#" + needle); }
-			if(!o.length) { return null; }
-			return instances[o.closest(".jstree").data("jstree-instance-id")] || null; 
-		},
-		_instance : function (index, container, settings) { 
-			// for plugins to store data in
-			this.data = { core : {} };
-			this.get_settings	= function () { return $.extend(true, {}, settings); };
-			this._get_settings	= function () { return settings; };
-			this.get_index		= function () { return index; };
-			this.get_container	= function () { return container; };
-			this._set_settings	= function (s) { 
-				settings = $.extend(true, {}, settings, s);
-			};
-		},
-		_fn : { },
-		plugin : function (pname, pdata) {
-			pdata = $.extend({}, {
-				__init		: $.noop, 
-				__destroy	: $.noop,
-				_fn			: {},
-				defaults	: false
-			}, pdata);
-			plugins[pname] = pdata;
-
-			$.jstree.defaults[pname] = pdata.defaults;
-			$.each(pdata._fn, function (i, val) {
-				val.plugin		= pname;
-				val.old			= $.jstree._fn[i];
-				$.jstree._fn[i] = function () {
-					var rslt,
-						func = val,
-						args = Array.prototype.slice.call(arguments),
-						evnt = new $.Event("before.jstree"),
-						rlbk = false;
-
-					// Check if function belongs to the included plugins of this instance
-					do {
-						if(func && func.plugin && $.inArray(func.plugin, this._get_settings().plugins) !== -1) { break; }
-						func = func.old;
-					} while(func);
-					if(!func) { return; }
-
-					// a chance to stop execution (or change arguments): 
-					// * just bind to jstree.before
-					// * check the additional data object (func property)
-					// * call event.stopImmediatePropagation()
-					// * return false (or an array of arguments)
-					rslt = this.get_container().triggerHandler(evnt, { "func" : i, "inst" : this, "args" : args });
-					if(rslt === false) { return; }
-					if(typeof rslt !== "undefined") { args = rslt; }
-
-					// context and function to trigger events, then finally call the function
-					if(i.indexOf("_") === 0) {
-						rslt = func.apply(this, args);
-					}
-					else {
-						rslt = func.apply(
-							$.extend({}, this, { 
-								__callback : function (data) { 
-									this.get_container().triggerHandler( i + '.jstree', { "inst" : this, "args" : args, "rslt" : data, "rlbk" : rlbk });
-								},
-								__rollback : function () { 
-									rlbk = this.get_rollback();
-									return rlbk;
-								},
-								__call_old : function (replace_arguments) {
-									return func.old.apply(this, (replace_arguments ? Array.prototype.slice.call(arguments, 1) : args ) );
-								}
-							}), args);
-					}
-
-					// return the result
-					return rslt;
-				};
-				$.jstree._fn[i].old = val.old;
-				$.jstree._fn[i].plugin = pname;
-			});
-		},
-		rollback : function (rb) {
-			if(rb) {
-				if(!$.isArray(rb)) { rb = [ rb ]; }
-				$.each(rb, function (i, val) {
-					instances[val.i].set_rollback(val.h, val.d);
-				});
-			}
-		}
-	};
-	// set the prototype for all instances
-	$.jstree._fn = $.jstree._instance.prototype = {};
-
-	// css functions - used internally
-
-	// load the css when DOM is ready
-	$(function() {
-		// code is copied form jQuery ($.browser is deprecated + there is a bug in IE)
-		var u = navigator.userAgent.toLowerCase(),
-			v = (u.match( /.+?(?:rv|it|ra|ie)[\/: ]([\d.]+)/ ) || [0,'0'])[1],
-			css_string = '' + 
-				'.jstree ul, .jstree li { display:block; margin:0 0 0 0; padding:0 0 0 0; list-style-type:none; } ' + 
-				'.jstree li { display:block; min-height:18px; line-height:18px; white-space:nowrap; margin-left:18px; } ' + 
-				'.jstree-rtl li { margin-left:0; margin-right:18px; } ' + 
-				'.jstree > ul > li { margin-left:0px; } ' + 
-				'.jstree-rtl > ul > li { margin-right:0px; } ' + 
-				'.jstree ins { display:inline-block; text-decoration:none; width:18px; height:18px; margin:0 0 0 0; padding:0; } ' + 
-				'.jstree a { display:inline-block; line-height:16px; height:16px; color:black; white-space:nowrap; text-decoration:none; padding:1px 2px; margin:0; } ' + 
-				'.jstree a:focus { outline: none; } ' + 
-				'.jstree a > ins { height:16px; width:16px; } ' + 
-				'.jstree a > .jstree-icon { margin-right:3px; } ' + 
-				'.jstree-rtl a > .jstree-icon { margin-left:3px; margin-right:0; } ' + 
-				'li.jstree-open > ul { display:block; } ' + 
-				'li.jstree-closed > ul { display:none; } ';
-		// Correct IE 6 (does not support the > CSS selector)
-		if(/msie/.test(u) && parseInt(v, 10) == 6) { 
-			is_ie6 = true;
-			css_string += '' + 
-				'.jstree li { height:18px; margin-left:0; margin-right:0; } ' + 
-				'.jstree li li { margin-left:18px; } ' + 
-				'.jstree-rtl li li { margin-left:0px; margin-right:18px; } ' + 
-				'li.jstree-open ul { display:block; } ' + 
-				'li.jstree-closed ul { display:none !important; } ' + 
-				'.jstree li a { display:inline; border-width:0 !important; padding:0px 2px !important; } ' + 
-				'.jstree li a ins { height:16px; width:16px; margin-right:3px; } ' + 
-				'.jstree-rtl li a ins { margin-right:0px; margin-left:3px; } ';
-		}
-		// Correct IE 7 (shifts anchor nodes onhover)
-		if(/msie/.test(u) && parseInt(v, 10) == 7) { 
-			css_string += '.jstree li a { border-width:0 !important; padding:0px 2px !important; } ';
-		}
-		$.vakata.css.add_sheet({ str : css_string });
-	});
-
-	// core functions (open, close, create, update, delete)
-	$.jstree.plugin("core", {
-		__init : function () {
-			this.data.core.to_open = $.map($.makeArray(this.get_settings().core.initially_open), function (n) { return "#" + n.toString().replace(/^#/,"").replace('\\/','/').replace('/','\\/'); });
-		},
-		defaults : { 
-			html_titles	: false,
-			animation	: 500,
-			initially_open : [],
-			rtl			: false,
-			strings		: {
-				loading		: "Loading ...",
-				new_node	: "New node"
-			}
-		},
-		_fn : { 
-			init	: function () { 
-				this.set_focus(); 
-				if(this._get_settings().core.rtl) {
-					this.get_container().addClass("jstree-rtl").css("direction", "rtl");
-				}
-				this.get_container().html("<ul><li class='jstree-last jstree-leaf'><ins>&#160;</ins><a class='jstree-loading' href='#'><ins class='jstree-icon'>&#160;</ins>" + this._get_settings().core.strings.loading + "</a></li></ul>");
-				this.data.core.li_height = this.get_container().find("ul li.jstree-closed, ul li.jstree-leaf").eq(0).height() || 18;
-
-				this.get_container()
-					.delegate("li > ins", "click.jstree", $.proxy(function (event) {
-							var trgt = $(event.target);
-							if(trgt.is("ins") && event.pageY - trgt.offset().top < this.data.core.li_height) { this.toggle_node(trgt); }
-						}, this))
-					.bind("mousedown.jstree", $.proxy(function () { 
-							this.set_focus(); // This used to be setTimeout(set_focus,0) - why?
-						}, this))
-					.bind("dblclick.jstree", function (event) { 
-						var sel;
-						if(document.selection && document.selection.empty) { document.selection.empty(); }
-						else {
-							if(window.getSelection) {
-								sel = window.getSelection();
-								try { 
-									sel.removeAllRanges();
-									sel.collapse();
-								} catch (err) { }
-							}
-						}
-					});
-				this.__callback();
-				this.load_node(-1, function () { this.loaded(); this.reopen(); });
-			},
-			destroy	: function () { 
-				var i,
-					n = this.get_index(),
-					s = this._get_settings(),
-					_this = this;
-
-				$.each(s.plugins, function (i, val) {
-					try { plugins[val].__destroy.apply(_this); } catch(err) { }
-				});
-				this.__callback();
-				// set focus to another instance if this one is focused
-				if(this.is_focused()) { 
-					for(i in instances) { 
-						if(instances.hasOwnProperty(i) && i != n) { 
-							instances[i].set_focus(); 
-							break; 
-						} 
-					}
-				}
-				// if no other instance found
-				if(n === focused_instance) { focused_instance = -1; }
-				// remove all traces of jstree in the DOM (only the ones set using jstree*) and cleans all events
-				this.get_container()
-					.unbind(".jstree")
-					.undelegate(".jstree")
-					.removeData("jstree-instance-id")
-					.find("[class^='jstree']")
-						.andSelf()
-						.attr("class", function () { return this.className.replace(/jstree[^ ]*|$/ig,''); });
-				// remove the actual data
-				instances[n] = null;
-				delete instances[n];
-			},
-			save_opened : function () {
-				var _this = this;
-				this.data.core.to_open = [];
-				this.get_container().find(".jstree-open").each(function () { 
-					_this.data.core.to_open.push("#" + this.id.toString().replace(/^#/,"").replace('\\/','/').replace('/','\\/')); 
-				});
-				this.__callback(_this.data.core.to_open);
-			},
-			reopen : function (is_callback) {
-				var _this = this,
-					done = true,
-					current = [],
-					remaining = [];
-				if(!is_callback) { this.data.core.reopen = false; this.data.core.refreshing = true; }
-				if(this.data.core.to_open.length) {
-					$.each(this.data.core.to_open, function (i, val) {
-						if(val == "#") { return true; }
-						if($(val).length && $(val).is(".jstree-closed")) { current.push(val); }
-						else { remaining.push(val); }
-					});
-					if(current.length) {
-						this.data.core.to_open = remaining;
-						$.each(current, function (i, val) { 
-							_this.open_node(val, function () { _this.reopen(true); }, true); 
-						});
-						done = false;
-					}
-				}
-				if(done) { 
-					// TODO: find a more elegant approach to syncronizing returning requests
-					if(this.data.core.reopen) { clearTimeout(this.data.core.reopen); }
-					this.data.core.reopen = setTimeout(function () { _this.__callback({}, _this); }, 50);
-					this.data.core.refreshing = false;
-				}
-			},
-			refresh : function (obj) {
-				var _this = this;
-				this.save_opened();
-				if(!obj) { obj = -1; }
-				obj = this._get_node(obj);
-				if(!obj) { obj = -1; }
-				if(obj !== -1) { obj.children("UL").remove(); }
-				this.load_node(obj, function () { _this.__callback({ "obj" : obj}); _this.reopen(); });
-			},
-			// Dummy function to fire after the first load (so that there is a jstree.loaded event)
-			loaded	: function () { 
-				this.__callback(); 
-			},
-			// deal with focus
-			set_focus	: function () { 
-				var f = $.jstree._focused();
-				if(f && f !== this) {
-					f.get_container().removeClass("jstree-focused"); 
-				}
-				if(f !== this) {
-					this.get_container().addClass("jstree-focused"); 
-					focused_instance = this.get_index(); 
-				}
-				this.__callback();
-			},
-			is_focused	: function () { 
-				return focused_instance == this.get_index(); 
-			},
-
-			// traverse
-			_get_node		: function (obj) { 
-				var $obj = $(obj, this.get_container()); 
-				if($obj.is(".jstree") || obj == -1) { return -1; } 
-				$obj = $obj.closest("li", this.get_container()); 
-				return $obj.length ? $obj : false; 
-			},
-			_get_next		: function (obj, strict) {
-				obj = this._get_node(obj);
-				if(obj === -1) { return this.get_container().find("> ul > li:first-child"); }
-				if(!obj.length) { return false; }
-				if(strict) { return (obj.nextAll("li").size() > 0) ? obj.nextAll("li:eq(0)") : false; }
-
-				if(obj.hasClass("jstree-open")) { return obj.find("li:eq(0)"); }
-				else if(obj.nextAll("li").size() > 0) { return obj.nextAll("li:eq(0)"); }
-				else { return obj.parentsUntil(".jstree","li").next("li").eq(0); }
-			},
-			_get_prev		: function (obj, strict) {
-				obj = this._get_node(obj);
-				if(obj === -1) { return this.get_container().find("> ul > li:last-child"); }
-				if(!obj.length) { return false; }
-				if(strict) { return (obj.prevAll("li").length > 0) ? obj.prevAll("li:eq(0)") : false; }
-
-				if(obj.prev("li").length) {
-					obj = obj.prev("li").eq(0);
-					while(obj.hasClass("jstree-open")) { obj = obj.children("ul:eq(0)").children("li:last"); }
-					return obj;
-				}
-				else { var o = obj.parentsUntil(".jstree","li:eq(0)"); return o.length ? o : false; }
-			},
-			_get_parent		: function (obj) {
-				obj = this._get_node(obj);
-				if(obj == -1 || !obj.length) { return false; }
-				var o = obj.parentsUntil(".jstree", "li:eq(0)");
-				return o.length ? o : -1;
-			},
-			_get_children	: function (obj) {
-				obj = this._get_node(obj);
-				if(obj === -1) { return this.get_container().children("ul:eq(0)").children("li"); }
-				if(!obj.length) { return false; }
-				return obj.children("ul:eq(0)").children("li");
-			},
-			get_path		: function (obj, id_mode) {
-				var p = [],
-					_this = this;
-				obj = this._get_node(obj);
-				if(obj === -1 || !obj || !obj.length) { return false; }
-				obj.parentsUntil(".jstree", "li").each(function () {
-					p.push( id_mode ? this.id : _this.get_text(this) );
-				});
-				p.reverse();
-				p.push( id_mode ? obj.attr("id") : this.get_text(obj) );
-				return p;
-			},
-
-			is_open		: function (obj) { obj = this._get_node(obj); return obj && obj !== -1 && obj.hasClass("jstree-open"); },
-			is_closed	: function (obj) { obj = this._get_node(obj); return obj && obj !== -1 && obj.hasClass("jstree-closed"); },
-			is_leaf		: function (obj) { obj = this._get_node(obj); return obj && obj !== -1 && obj.hasClass("jstree-leaf"); },
-			// open/close
-			open_node	: function (obj, callback, skip_animation) {
-				obj = this._get_node(obj);
-				if(!obj.length) { return false; }
-				if(!obj.hasClass("jstree-closed")) { if(callback) { callback.call(); } return false; }
-				var s = skip_animation || is_ie6 ? 0 : this._get_settings().core.animation,
-					t = this;
-				if(!this._is_loaded(obj)) {
-					obj.children("a").addClass("jstree-loading");
-					this.load_node(obj, function () { t.open_node(obj, callback, skip_animation); }, callback);
-				}
-				else {
-					if(s) { obj.children("ul").css("display","none"); }
-					obj.removeClass("jstree-closed").addClass("jstree-open").children("a").removeClass("jstree-loading");
-					if(s) { obj.children("ul").stop(true).slideDown(s, function () { this.style.display = ""; }); }
-					this.__callback({ "obj" : obj });
-					if(callback) { callback.call(); }
-				}
-			},
-			close_node	: function (obj, skip_animation) {
-				obj = this._get_node(obj);
-				var s = skip_animation || is_ie6 ? 0 : this._get_settings().core.animation;
-				if(!obj.length || !obj.hasClass("jstree-open")) { return false; }
-				if(s) { obj.children("ul").attr("style","display:block !important"); }
-				obj.removeClass("jstree-open").addClass("jstree-closed");
-				if(s) { obj.children("ul").stop(true).slideUp(s, function () { this.style.display = ""; }); }
-				this.__callback({ "obj" : obj });
-			},
-			toggle_node	: function (obj) {
-				obj = this._get_node(obj);
-				if(obj.hasClass("jstree-closed")) { return this.open_node(obj); }
-				if(obj.hasClass("jstree-open")) { return this.close_node(obj); }
-			},
-			open_all	: function (obj, original_obj) {
-				obj = obj ? this._get_node(obj) : this.get_container();
-				if(!obj || obj === -1) { obj = this.get_container(); }
-				if(original_obj) { 
-					obj = obj.find("li.jstree-closed");
-				}
-				else {
-					original_obj = obj;
-					if(obj.is(".jstree-closed")) { obj = obj.find("li.jstree-closed").andSelf(); }
-					else { obj = obj.find("li.jstree-closed"); }
-				}
-				var _this = this;
-				obj.each(function () { 
-					var __this = this; 
-					if(!_this._is_loaded(this)) { _this.open_node(this, function() { _this.open_all(__this, original_obj); }, true); }
-					else { _this.open_node(this, false, true); }
-				});
-				// so that callback is fired AFTER all nodes are open
-				if(original_obj.find('li.jstree-closed').length === 0) { this.__callback({ "obj" : original_obj }); }
-			},
-			close_all	: function (obj) {
-				var _this = this;
-				obj = obj ? this._get_node(obj) : this.get_container();
-				if(!obj || obj === -1) { obj = this.get_container(); }
-				obj.find("li.jstree-open").andSelf().each(function () { _this.close_node(this); });
-				this.__callback({ "obj" : obj });
-			},
-			clean_node	: function (obj) {
-				obj = obj && obj != -1 ? $(obj) : this.get_container();
-				obj = obj.is("li") ? obj.find("li").andSelf() : obj.find("li");
-				obj.removeClass("jstree-last")
-					.filter("li:last-child").addClass("jstree-last").end()
-					.filter(":has(li)")
-						.not(".jstree-open").removeClass("jstree-leaf").addClass("jstree-closed");
-				obj.not(".jstree-open, .jstree-closed").addClass("jstree-leaf").children("ul").remove();
-				this.__callback({ "obj" : obj });
-			},
-			// rollback
-			get_rollback : function () { 
-				this.__callback();
-				return { i : this.get_index(), h : this.get_container().children("ul").clone(true), d : this.data }; 
-			},
-			set_rollback : function (html, data) {
-				this.get_container().empty().append(html);
-				this.data = data;
-				this.__callback();
-			},
-			// Dummy functions to be overwritten by any datastore plugin included
-			load_node	: function (obj, s_call, e_call) { this.__callback({ "obj" : obj }); },
-			_is_loaded	: function (obj) { return true; },
-
-			// Basic operations: create
-			create_node	: function (obj, position, js, callback, is_loaded) {
-				obj = this._get_node(obj);
-				position = typeof position === "undefined" ? "last" : position;
-				var d = $("<li>"),
-					s = this._get_settings().core,
-					tmp;
-
-				if(obj !== -1 && !obj.length) { return false; }
-				if(!is_loaded && !this._is_loaded(obj)) { this.load_node(obj, function () { this.create_node(obj, position, js, callback, true); }); return false; }
-
-				this.__rollback();
-
-				if(typeof js === "string") { js = { "data" : js }; }
-				if(!js) { js = {}; }
-				if(js.attr) { d.attr(js.attr); }
-				if(js.state) { d.addClass("jstree-" + js.state); }
-				if(!js.data) { js.data = s.strings.new_node; }
-				if(!$.isArray(js.data)) { tmp = js.data; js.data = []; js.data.push(tmp); }
-				$.each(js.data, function (i, m) {
-					tmp = $("<a>");
-					if($.isFunction(m)) { m = m.call(this, js); }
-					if(typeof m == "string") { tmp.attr('href','#')[ s.html_titles ? "html" : "text" ](m); }
-					else {
-						if(!m.attr) { m.attr = {}; }
-						if(!m.attr.href) { m.attr.href = '#'; }
-						tmp.attr(m.attr)[ s.html_titles ? "html" : "text" ](m.title);
-						if(m.language) { tmp.addClass(m.language); }
-					}
-					tmp.prepend("<ins class='jstree-icon'>&#160;</ins>");
-					if(m.icon) { 
-						if(m.icon.indexOf("/") === -1) { tmp.children("ins").addClass(m.icon); }
-						else { tmp.children("ins").css("background","url('" + m.icon + "') center center no-repeat"); }
-					}
-					d.append(tmp);
-				});
-				d.prepend("<ins class='jstree-icon'>&#160;</ins>");
-				if(obj === -1) {
-					obj = this.get_container();
-					if(position === "before") { position = "first"; }
-					if(position === "after") { position = "last"; }
-				}
-				switch(position) {
-					case "before": obj.before(d); tmp = this._get_parent(obj); break;
-					case "after" : obj.after(d);  tmp = this._get_parent(obj); break;
-					case "inside":
-					case "first" :
-						if(!obj.children("ul").length) { obj.append("<ul>"); }
-						obj.children("ul").prepend(d);
-						tmp = obj;
-						break;
-					case "last":
-						if(!obj.children("ul").length) { obj.append("<ul>"); }
-						obj.children("ul").append(d);
-						tmp = obj;
-						break;
-					default:
-						if(!obj.children("ul").length) { obj.append("<ul>"); }
-						if(!position) { position = 0; }
-						tmp = obj.children("ul").children("li").eq(position);
-						if(tmp.length) { tmp.before(d); }
-						else { obj.children("ul").append(d); }
-						tmp = obj;
-						break;
-				}
-				if(tmp === -1 || tmp.get(0) === this.get_container().get(0)) { tmp = -1; }
-				this.clean_node(tmp);
-				this.__callback({ "obj" : d, "parent" : tmp });
-				if(callback) { callback.call(this, d); }
-				return d;
-			},
-			// Basic operations: rename (deal with text)
-			get_text	: function (obj) {
-				obj = this._get_node(obj);
-				if(!obj.length) { return false; }
-				var s = this._get_settings().core.html_titles;
-				obj = obj.children("a:eq(0)");
-				if(s) {
-					obj = obj.clone();
-					obj.children("INS").remove();
-					return obj.html();
-				}
-				else {
-					obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];
-					return obj.nodeValue;
-				}
-			},
-			set_text	: function (obj, val) {
-				obj = this._get_node(obj);
-				if(!obj.length) { return false; }
-				obj = obj.children("a:eq(0)");
-				if(this._get_settings().core.html_titles) {
-					var tmp = obj.children("INS").clone();
-					obj.html(val).prepend(tmp);
-					this.__callback({ "obj" : obj, "name" : val });
-					return true;
-				}
-				else {
-					obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];
-					this.__callback({ "obj" : obj, "name" : val });
-					return (obj.nodeValue = val);
-				}
-			},
-			rename_node : function (obj, val) {
-				obj = this._get_node(obj);
-				this.__rollback();
-				if(obj && obj.length && this.set_text.apply(this, Array.prototype.slice.call(arguments))) { this.__callback({ "obj" : obj, "name" : val }); }
-			},
-			// Basic operations: deleting nodes
-			delete_node : function (obj) {
-				obj = this._get_node(obj);
-				if(!obj.length) { return false; }
-				this.__rollback();
-				var p = this._get_parent(obj), prev = this._get_prev(obj);
-				obj = obj.remove();
-				if(p !== -1 && p.find("> ul > li").length === 0) {
-					p.removeClass("jstree-open jstree-closed").addClass("jstree-leaf");
-				}
-				this.clean_node(p);
-				this.__callback({ "obj" : obj, "prev" : prev });
-				return obj;
-			},
-			prepare_move : function (o, r, pos, cb, is_cb) {
-				var p = {};
-
-				p.ot = $.jstree._reference(p.o) || this;
-				p.o = p.ot._get_node(o);
-				p.r = r === - 1 ? -1 : this._get_node(r);
-				p.p = (typeof p === "undefined") ? "last" : pos; // TODO: move to a setting
-				if(!is_cb && prepared_move.o && prepared_move.o[0] === p.o[0] && prepared_move.r[0] === p.r[0] && prepared_move.p === p.p) {
-					this.__callback(prepared_move);
-					if(cb) { cb.call(this, prepared_move); }
-					return;
-				}
-				p.ot = $.jstree._reference(p.o) || this;
-				p.rt = r === -1 ? p.ot : $.jstree._reference(p.r) || this;
-				if(p.r === -1) {
-					p.cr = -1;
-					switch(p.p) {
-						case "first":
-						case "before":
-						case "inside":
-							p.cp = 0; 
-							break;
-						case "after":
-						case "last":
-							p.cp = p.rt.get_container().find(" > ul > li").length; 
-							break;
-						default:
-							p.cp = p.p;
-							break;
-					}
-				}
-				else {
-					if(!/^(before|after)$/.test(p.p) && !this._is_loaded(p.r)) {
-						return this.load_node(p.r, function () { this.prepare_move(o, r, pos, cb, true); });
-					}
-					switch(p.p) {
-						case "before":
-							p.cp = p.r.index();
-							p.cr = p.rt._get_parent(p.r);
-							break;
-						case "after":
-							p.cp = p.r.index() + 1;
-							p.cr = p.rt._get_parent(p.r);
-							break;
-						case "inside":
-						case "first":
-							p.cp = 0;
-							p.cr = p.r;
-							break;
-						case "last":
-							p.cp = p.r.find(" > ul > li").length; 
-							p.cr = p.r;
-							break;
-						default: 
-							p.cp = p.p;
-							p.cr = p.r;
-							break;
-					}
-				}
-				p.np = p.cr == -1 ? p.rt.get_container() : p.cr;
-				p.op = p.ot._get_parent(p.o);
-				p.or = p.np.find(" > ul > li:nth-child(" + (p.cp + 1) + ")");
-
-				prepared_move = p;
-				this.__callback(prepared_move);
-				if(cb) { cb.call(this, prepared_move); }
-			},
-			check_move : function () {
-				var obj = prepared_move, ret = true;
-				if(obj.or[0] === obj.o[0]) { return false; }
-				obj.o.each(function () { 
-					if(obj.r.parentsUntil(".jstree").andSelf().filter("li").index(this) !== -1) { ret = false; return false; }
-				});
-				return ret;
-			},
-			move_node : function (obj, ref, position, is_copy, is_prepared, skip_check) {
-				if(!is_prepared) { 
-					return this.prepare_move(obj, ref, position, function (p) {
-						this.move_node(p, false, false, is_copy, true, skip_check);
-					});
-				}
-				if(!skip_check && !this.check_move()) { return false; }
-
-				this.__rollback();
-				var o = false;
-				if(is_copy) {
-					o = obj.o.clone();
-					o.find("*[id]").andSelf().each(function () {
-						if(this.id) { this.id = "copy_" + this.id; }
-					});
-				}
-				else { o = obj.o; }
-
-				if(obj.or.length) { obj.or.before(o); }
-				else { 
-					if(!obj.np.children("ul").length) { $("<ul>").appendTo(obj.np); }
-					obj.np.children("ul:eq(0)").append(o); 
-				}
-
-				try { 
-					obj.ot.clean_node(obj.op);
-					obj.rt.clean_node(obj.np);
-					if(!obj.op.find("> ul > li").length) {
-						obj.op.removeClass("jstree-open jstree-closed").addClass("jstree-leaf").children("ul").remove();
-					}
-				} catch (e) { }
-
-				if(is_copy) { 
-					prepared_move.cy = true;
-					prepared_move.oc = o; 
-				}
-				this.__callback(prepared_move);
-				return prepared_move;
-			},
-			_get_move : function () { return prepared_move; }
-		}
-	});
+  // private variables 
+  var instances = [],      // instance array (used by $.jstree.reference/create/focused)
+    focused_instance = -1,  // the index in the instance array of the currently focused instance
+    plugins = {},      // list of included plugins
+    prepared_move = {},    // for the move plugin
+    is_ie6 = false;
+
+  // jQuery plugin wrapper (thanks to jquery UI widget function)
+  $.fn.jstree = function (settings) {
+    var isMethodCall = (typeof settings == 'string'), // is this a method call like $().jstree("open_node")
+      args = Array.prototype.slice.call(arguments, 1), 
+      returnValue = this;
+
+    // extend settings and allow for multiple hashes and metadata
+    if(!isMethodCall && $.meta) { args.push($.metadata.get(this).jstree); }
+    settings = !isMethodCall && args.length ? $.extend.apply(null, [true, settings].concat(args)) : settings;
+    // block calls to "private" methods
+    if(isMethodCall && settings.substring(0, 1) == '_') { return returnValue; }
+
+    // if a method call execute the method on all selected instances
+    if(isMethodCall) {
+      this.each(function() {
+        var instance = instances[$.data(this, "jstree-instance-id")],
+          methodValue = (instance && $.isFunction(instance[settings])) ? instance[settings].apply(instance, args) : instance;
+          if(typeof methodValue !== "undefined" && (settings.indexOf("is_" === 0) || (methodValue !== true && methodValue !== false))) { returnValue = methodValue; return false; }
+      });
+    }
+    else {
+      this.each(function() {
+        var instance_id = $.data(this, "jstree-instance-id"),
+          s = false;
+        // if an instance already exists, destroy it first
+        if(typeof instance_id !== "undefined" && instances[instance_id]) { instances[instance_id].destroy(); }
+        // push a new empty object to the instances array
+        instance_id = parseInt(instances.push({}),10) - 1;
+        // store the jstree instance id to the container element
+        $.data(this, "jstree-instance-id", instance_id);
+        // clean up all plugins
+        if(!settings) { settings = {}; }
+        settings.plugins = $.isArray(settings.plugins) ? settings.plugins : $.jstree.defaults.plugins;
+        if($.inArray("core", settings.plugins) === -1) { settings.plugins.unshift("core"); }
+        
+        // only unique plugins (NOT WORKING)
+        // settings.plugins = settings.plugins.sort().join(",,").replace(/(,|^)([^,]+)(,,\2)+(,|$)/g,"$1$2$4").replace(/,,+/g,",").replace(/,$/,"").split(",");
+
+        // extend defaults with passed data
+        s = $.extend(true, {}, $.jstree.defaults, settings);
+        s.plugins = settings.plugins;
+        $.each(plugins, function (i, val) { if($.inArray(i, s.plugins) === -1) { s[i] = null; delete s[i]; } });
+        // push the new object to the instances array (at the same time set the default classes to the container) and init
+        instances[instance_id] = new $.jstree._instance(instance_id, $(this).addClass("jstree jstree-" + instance_id), s); 
+        // init all activated plugins for this instance
+        $.each(instances[instance_id]._get_settings().plugins, function (i, val) { instances[instance_id].data[val] = {}; });
+        $.each(instances[instance_id]._get_settings().plugins, function (i, val) { if(plugins[val]) { plugins[val].__init.apply(instances[instance_id]); } });
+        // initialize the instance
+        instances[instance_id].init();
+      });
+    }
+    // return the jquery selection (or if it was a method call that returned a value - the returned value)
+    return returnValue;
+  };
+  // object to store exposed functions and objects
+  $.jstree = {
+    defaults : {
+      plugins : []
+    },
+    _focused : function () { return instances[focused_instance] || null; },
+    _reference : function (needle) { 
+      // get by instance id
+      if(instances[needle]) { return instances[needle]; }
+      // get by DOM (if still no luck - return null
+      var o = $(needle); 
+      if(!o.length && typeof needle === "string") { o = $("#" + needle); }
+      if(!o.length) { return null; }
+      return instances[o.closest(".jstree").data("jstree-instance-id")] || null; 
+    },
+    _instance : function (index, container, settings) { 
+      // for plugins to store data in
+      this.data = { core : {} };
+      this.get_settings  = function () { return $.extend(true, {}, settings); };
+      this._get_settings  = function () { return settings; };
+      this.get_index    = function () { return index; };
+      this.get_container  = function () { return container; };
+      this._set_settings  = function (s) { 
+        settings = $.extend(true, {}, settings, s);
+      };
+    },
+    _fn : { },
+    plugin : function (pname, pdata) {
+      pdata = $.extend({}, {
+        __init    : $.noop, 
+        __destroy  : $.noop,
+        _fn      : {},
+        defaults  : false
+      }, pdata);
+      plugins[pname] = pdata;
+
+      $.jstree.defaults[pname] = pdata.defaults;
+      $.each(pdata._fn, function (i, val) {
+        val.plugin    = pname;
+        val.old      = $.jstree._fn[i];
+        $.jstree._fn[i] = function () {
+          var rslt,
+            func = val,
+            args = Array.prototype.slice.call(arguments),
+            evnt = new $.Event("before.jstree"),
+            rlbk = false;
+
+          // Check if function belongs to the included plugins of this instance
+          do {
+            if(func && func.plugin && $.inArray(func.plugin, this._get_settings().plugins) !== -1) { break; }
+            func = func.old;
+          } while(func);
+          if(!func) { return; }
+
+          // a chance to stop execution (or change arguments): 
+          // * just bind to jstree.before
+          // * check the additional data object (func property)
+          // * call event.stopImmediatePropagation()
+          // * return false (or an array of arguments)
+          rslt = this.get_container().triggerHandler(evnt, { "func" : i, "inst" : this, "args" : args });
+          if(rslt === false) { return; }
+          if(typeof rslt !== "undefined") { args = rslt; }
+
+          // context and function to trigger events, then finally call the function
+          if(i.indexOf("_") === 0) {
+            rslt = func.apply(this, args);
+          }
+          else {
+            rslt = func.apply(
+              $.extend({}, this, { 
+                __callback : function (data) { 
+                  this.get_container().triggerHandler( i + '.jstree', { "inst" : this, "args" : args, "rslt" : data, "rlbk" : rlbk });
+                },
+                __rollback : function () { 
+                  rlbk = this.get_rollback();
+                  return rlbk;
+                },
+                __call_old : function (replace_arguments) {
+                  return func.old.apply(this, (replace_arguments ? Array.prototype.slice.call(arguments, 1) : args ) );
+                }
+              }), args);
+          }
+
+          // return the result
+          return rslt;
+        };
+        $.jstree._fn[i].old = val.old;
+        $.jstree._fn[i].plugin = pname;
+      });
+    },
+    rollback : function (rb) {
+      if(rb) {
+        if(!$.isArray(rb)) { rb = [ rb ]; }
+        $.each(rb, function (i, val) {
+          instances[val.i].set_rollback(val.h, val.d);
+        });
+      }
+    }
+  };
+  // set the prototype for all instances
+  $.jstree._fn = $.jstree._instance.prototype = {};
+
+  // css functions - used internally
+
+  // load the css when DOM is ready
+  $(function() {
+    // code is copied form jQuery ($.browser is deprecated + there is a bug in IE)
+    var u = navigator.userAgent.toLowerCase(),
+      v = (u.match( /.+?(?:rv|it|ra|ie)[\/: ]([\d.]+)/ ) || [0,'0'])[1],
+      css_string = '' + 
+        '.jstree ul, .jstree li { display:block; margin:0 0 0 0; padding:0 0 0 0; list-style-type:none; } ' + 
+        '.jstree li { display:block; min-height:18px; line-height:18px; white-space:nowrap; margin-left:18px; } ' + 
+        '.jstree-rtl li { margin-left:0; margin-right:18px; } ' + 
+        '.jstree > ul > li { margin-left:0px; } ' + 
+        '.jstree-rtl > ul > li { margin-right:0px; } ' + 
+        '.jstree ins { display:inline-block; text-decoration:none; width:18px; height:18px; margin:0 0 0 0; padding:0; } ' + 
+        '.jstree a { display:inline-block; line-height:16px; height:16px; color:black; white-space:nowrap; text-decoration:none; padding:1px 2px; margin:0; } ' + 
+        '.jstree a:focus { outline: none; } ' + 
+        '.jstree a > ins { height:16px; width:16px; } ' + 
+        '.jstree a > .jstree-icon { margin-right:3px; } ' + 
+        '.jstree-rtl a > .jstree-icon { margin-left:3px; margin-right:0; } ' + 
+        'li.jstree-open > ul { display:block; } ' + 
+        'li.jstree-closed > ul { display:none; } ';
+    // Correct IE 6 (does not support the > CSS selector)
+    if(/msie/.test(u) && parseInt(v, 10) == 6) { 
+      is_ie6 = true;
+      css_string += '' + 
+        '.jstree li { height:18px; margin-left:0; margin-right:0; } ' + 
+        '.jstree li li { margin-left:18px; } ' + 
+        '.jstree-rtl li li { margin-left:0px; margin-right:18px; } ' + 
+        'li.jstree-open ul { display:block; } ' + 
+        'li.jstree-closed ul { display:none !important; } ' + 
+        '.jstree li a { display:inline; border-width:0 !important; padding:0px 2px !important; } ' + 
+        '.jstree li a ins { height:16px; width:16px; margin-right:3px; } ' + 
+        '.jstree-rtl li a ins { margin-right:0px; margin-left:3px; } ';
+    }
+    // Correct IE 7 (shifts anchor nodes onhover)
+    if(/msie/.test(u) && parseInt(v, 10) == 7) { 
+      css_string += '.jstree li a { border-width:0 !important; padding:0px 2px !important; } ';
+    }
+    $.vakata.css.add_sheet({ str : css_string });
+  });
+
+  // core functions (open, close, create, update, delete)
+  $.jstree.plugin("core", {
+    __init : function () {
+      this.data.core.to_open = $.map($.makeArray(this.get_settings().core.initially_open), function (n) { return "#" + n.toString().replace(/^#/,"").replace('\\/','/').replace('/','\\/'); });
+    },
+    defaults : { 
+      html_titles  : false,
+      animation  : 500,
+      initially_open : [],
+      rtl      : false,
+      strings    : {
+        loading    : "Loading ...",
+        new_node  : "New node"
+      }
+    },
+    _fn : { 
+      init  : function () { 
+        this.set_focus(); 
+        if(this._get_settings().core.rtl) {
+          this.get_container().addClass("jstree-rtl").css("direction", "rtl");
+        }
+        this.get_container().html("<ul><li class='jstree-last jstree-leaf'><ins>&#160;</ins><a class='jstree-loading' href='#'><ins class='jstree-icon'>&#160;</ins>" + this._get_settings().core.strings.loading + "</a></li></ul>");
+        this.data.core.li_height = this.get_container().find("ul li.jstree-closed, ul li.jstree-leaf").eq(0).height() || 18;
+
+        this.get_container()
+          .delegate("li > ins", "click.jstree", $.proxy(function (event) {
+              var trgt = $(event.target);
+              if(trgt.is("ins") && event.pageY - trgt.offset().top < this.data.core.li_height) { this.toggle_node(trgt); }
+            }, this))
+          .bind("mousedown.jstree", $.proxy(function () { 
+              this.set_focus(); // This used to be setTimeout(set_focus,0) - why?
+            }, this))
+          .bind("dblclick.jstree", function (event) { 
+            var sel;
+            if(document.selection && document.selection.empty) { document.selection.empty(); }
+            else {
+              if(window.getSelection) {
+                sel = window.getSelection();
+                try { 
+                  sel.removeAllRanges();
+                  sel.collapse();
+                } catch (err) { }
+              }
+            }
+          });
+        this.__callback();
+        this.load_node(-1, function () { this.loaded(); this.reopen(); });
+      },
+      destroy  : function () { 
+        var i,
+          n = this.get_index(),
+          s = this._get_settings(),
+          _this = this;
+
+        $.each(s.plugins, function (i, val) {
+          try { plugins[val].__destroy.apply(_this); } catch(err) { }
+        });
+        this.__callback();
+        // set focus to another instance if this one is focused
+        if(this.is_focused()) { 
+          for(i in instances) { 
+            if(instances.hasOwnProperty(i) && i != n) { 
+              instances[i].set_focus(); 
+              break; 
+            } 
+          }
+        }
+        // if no other instance found
+        if(n === focused_instance) { focused_instance = -1; }
+        // remove all traces of jstree in the DOM (only the ones set using jstree*) and cleans all events
+        this.get_container()
+          .unbind(".jstree")
+          .undelegate(".jstree")
+          .removeData("jstree-instance-id")
+          .find("[class^='jstree']")
+            .andSelf()
+            .attr("class", function () { return this.className.replace(/jstree[^ ]*|$/ig,''); });
+        // remove the actual data
+        instances[n] = null;
+        delete instances[n];
+      },
+      save_opened : function () {
+        var _this = this;
+        this.data.core.to_open = [];
+        this.get_container().find(".jstree-open").each(function () { 
+          _this.data.core.to_open.push("#" + this.id.toString().replace(/^#/,"").replace('\\/','/').replace('/','\\/')); 
+        });
+        this.__callback(_this.data.core.to_open);
+      },
+      reopen : function (is_callback) {
+        var _this = this,
+          done = true,
+          current = [],
+          remaining = [];
+        if(!is_callback) { this.data.core.reopen = false; this.data.core.refreshing = true; }
+        if(this.data.core.to_open.length) {
+          $.each(this.data.core.to_open, function (i, val) {
+            if(val == "#") { return true; }
+            if($(val).length && $(val).is(".jstree-closed")) { current.push(val); }
+            else { remaining.push(val); }
+          });
+          if(current.length) {
+            this.data.core.to_open = remaining;
+            $.each(current, function (i, val) { 
+              _this.open_node(val, function () { _this.reopen(true); }, true); 
+            });
+            done = false;
+          }
+        }
+        if(done) { 
+          // TODO: find a more elegant approach to syncronizing returning requests
+          if(this.data.core.reopen) { clearTimeout(this.data.core.reopen); }
+          this.data.core.reopen = setTimeout(function () { _this.__callback({}, _this); }, 50);
+          this.data.core.refreshing = false;
+        }
+      },
+      refresh : function (obj) {
+        var _this = this;
+        this.save_opened();
+        if(!obj) { obj = -1; }
+        obj = this._get_node(obj);
+        if(!obj) { obj = -1; }
+        if(obj !== -1) { obj.children("UL").remove(); }
+        this.load_node(obj, function () { _this.__callback({ "obj" : obj}); _this.reopen(); });
+      },
+      // Dummy function to fire after the first load (so that there is a jstree.loaded event)
+      loaded  : function () { 
+        this.__callback(); 
+      },
+      // deal with focus
+      set_focus  : function () { 
+        var f = $.jstree._focused();
+        if(f && f !== this) {
+          f.get_container().removeClass("jstree-focused"); 
+        }
+        if(f !== this) {
+          this.get_container().addClass("jstree-focused"); 
+          focused_instance = this.get_index(); 
+        }
+        this.__callback();
+      },
+      is_focused  : function () { 
+        return focused_instance == this.get_index(); 
+      },
+
+      // traverse
+      _get_node    : function (obj) { 
+        var $obj = $(obj, this.get_container()); 
+        if($obj.is(".jstree") || obj == -1) { return -1; } 
+        $obj = $obj.closest("li", this.get_container()); 
+        return $obj.length ? $obj : false; 
+      },
+      _get_next    : function (obj, strict) {
+        obj = this._get_node(obj);
+        if(obj === -1) { return this.get_container().find("> ul > li:first-child"); }
+        if(!obj.length) { return false; }
+        if(strict) { return (obj.nextAll("li").size() > 0) ? obj.nextAll("li:eq(0)") : false; }
+
+        if(obj.hasClass("jstree-open")) { return obj.find("li:eq(0)"); }
+        else if(obj.nextAll("li").size() > 0) { return obj.nextAll("li:eq(0)"); }
+        else { return obj.parentsUntil(".jstree","li").next("li").eq(0); }
+      },
+      _get_prev    : function (obj, strict) {
+        obj = this._get_node(obj);
+        if(obj === -1) { return this.get_container().find("> ul > li:last-child"); }
+        if(!obj.length) { return false; }
+        if(strict) { return (obj.prevAll("li").length > 0) ? obj.prevAll("li:eq(0)") : false; }
+
+        if(obj.prev("li").length) {
+          obj = obj.prev("li").eq(0);
+          while(obj.hasClass("jstree-open")) { obj = obj.children("ul:eq(0)").children("li:last"); }
+          return obj;
+        }
+        else { var o = obj.parentsUntil(".jstree","li:eq(0)"); return o.length ? o : false; }
+      },
+      _get_parent    : function (obj) {
+        obj = this._get_node(obj);
+        if(obj == -1 || !obj.length) { return false; }
+        var o = obj.parentsUntil(".jstree", "li:eq(0)");
+        return o.length ? o : -1;
+      },
+      _get_children  : function (obj) {
+        obj = this._get_node(obj);
+        if(obj === -1) { return this.get_container().children("ul:eq(0)").children("li"); }
+        if(!obj.length) { return false; }
+        return obj.children("ul:eq(0)").children("li");
+      },
+      get_path    : function (obj, id_mode) {
+        var p = [],
+          _this = this;
+        obj = this._get_node(obj);
+        if(obj === -1 || !obj || !obj.length) { return false; }
+        obj.parentsUntil(".jstree", "li").each(function () {
+          p.push( id_mode ? this.id : _this.get_text(this) );
+        });
+        p.reverse();
+        p.push( id_mode ? obj.attr("id") : this.get_text(obj) );
+        return p;
+      },
+
+      is_open    : function (obj) { obj = this._get_node(obj); return obj && obj !== -1 && obj.hasClass("jstree-open"); },
+      is_closed  : function (obj) { obj = this._get_node(obj); return obj && obj !== -1 && obj.hasClass("jstree-closed"); },
+      is_leaf    : function (obj) { obj = this._get_node(obj); return obj && obj !== -1 && obj.hasClass("jstree-leaf"); },
+      // open/close
+      open_node  : function (obj, callback, skip_animation) {
+        obj = this._get_node(obj);
+        if(!obj.length) { return false; }
+        if(!obj.hasClass("jstree-closed")) { if(callback) { callback.call(); } return false; }
+        var s = skip_animation || is_ie6 ? 0 : this._get_settings().core.animation,
+          t = this;
+        if(!this._is_loaded(obj)) {
+          obj.children("a").addClass("jstree-loading");
+          this.load_node(obj, function () { t.open_node(obj, callback, skip_animation); }, callback);
+        }
+        else {
+          if(s) { obj.children("ul").css("display","none"); }
+          obj.removeClass("jstree-closed").addClass("jstree-open").children("a").removeClass("jstree-loading");
+          if(s) { obj.children("ul").stop(true).slideDown(s, function () { this.style.display = ""; }); }
+          this.__callback({ "obj" : obj });
+          if(callback) { callback.call(); }
+        }
+      },
+      close_node  : function (obj, skip_animation) {
+        obj = this._get_node(obj);
+        var s = skip_animation || is_ie6 ? 0 : this._get_settings().core.animation;
+        if(!obj.length || !obj.hasClass("jstree-open")) { return false; }
+        if(s) { obj.children("ul").attr("style","display:block !important"); }
+        obj.removeClass("jstree-open").addClass("jstree-closed");
+        if(s) { obj.children("ul").stop(true).slideUp(s, function () { this.style.display = ""; }); }
+        this.__callback({ "obj" : obj });
+      },
+      toggle_node  : function (obj) {
+        obj = this._get_node(obj);
+        if(obj.hasClass("jstree-closed")) { return this.open_node(obj); }
+        if(obj.hasClass("jstree-open")) { return this.close_node(obj); }
+      },
+      open_all  : function (obj, original_obj) {
+        obj = obj ? this._get_node(obj) : this.get_container();
+        if(!obj || obj === -1) { obj = this.get_container(); }
+        if(original_obj) { 
+          obj = obj.find("li.jstree-closed");
+        }
+        else {
+          original_obj = obj;
+          if(obj.is(".jstree-closed")) { obj = obj.find("li.jstree-closed").andSelf(); }
+          else { obj = obj.find("li.jstree-closed"); }
+        }
+        var _this = this;
+        obj.each(function () { 
+          var __this = this; 
+          if(!_this._is_loaded(this)) { _this.open_node(this, function() { _this.open_all(__this, original_obj); }, true); }
+          else { _this.open_node(this, false, true); }
+        });
+        // so that callback is fired AFTER all nodes are open
+        if(original_obj.find('li.jstree-closed').length === 0) { this.__callback({ "obj" : original_obj }); }
+      },
+      close_all  : function (obj) {
+        var _this = this;
+        obj = obj ? this._get_node(obj) : this.get_container();
+        if(!obj || obj === -1) { obj = this.get_container(); }
+        obj.find("li.jstree-open").andSelf().each(function () { _this.close_node(this); });
+        this.__callback({ "obj" : obj });
+      },
+      clean_node  : function (obj) {
+        obj = obj && obj != -1 ? $(obj) : this.get_container();
+        obj = obj.is("li") ? obj.find("li").andSelf() : obj.find("li");
+        obj.removeClass("jstree-last")
+          .filter("li:last-child").addClass("jstree-last").end()
+          .filter(":has(li)")
+            .not(".jstree-open").removeClass("jstree-leaf").addClass("jstree-closed");
+        obj.not(".jstree-open, .jstree-closed").addClass("jstree-leaf").children("ul").remove();
+        this.__callback({ "obj" : obj });
+      },
+      // rollback
+      get_rollback : function () { 
+        this.__callback();
+        return { i : this.get_index(), h : this.get_container().children("ul").clone(true), d : this.data }; 
+      },
+      set_rollback : function (html, data) {
+        this.get_container().empty().append(html);
+        this.data = data;
+        this.__callback();
+      },
+      // Dummy functions to be overwritten by any datastore plugin included
+      load_node  : function (obj, s_call, e_call) { this.__callback({ "obj" : obj }); },
+      _is_loaded  : function (obj) { return true; },
+
+      // Basic operations: create
+      create_node  : function (obj, position, js, callback, is_loaded) {
+        obj = this._get_node(obj);
+        position = typeof position === "undefined" ? "last" : position;
+        var d = $("<li>"),
+          s = this._get_settings().core,
+          tmp;
+
+        if(obj !== -1 && !obj.length) { return false; }
+        if(!is_loaded && !this._is_loaded(obj)) { this.load_node(obj, function () { this.create_node(obj, position, js, callback, true); }); return false; }
+
+        this.__rollback();
+
+        if(typeof js === "string") { js = { "data" : js }; }
+        if(!js) { js = {}; }
+        if(js.attr) { d.attr(js.attr); }
+        if(js.state) { d.addClass("jstree-" + js.state); }
+        if(!js.data) { js.data = s.strings.new_node; }
+        if(!$.isArray(js.data)) { tmp = js.data; js.data = []; js.data.push(tmp); }
+        $.each(js.data, function (i, m) {
+          tmp = $("<a>");
+          if($.isFunction(m)) { m = m.call(this, js); }
+          if(typeof m == "string") { tmp.attr('href','#')[ s.html_titles ? "html" : "text" ](m); }
+          else {
+            if(!m.attr) { m.attr = {}; }
+            if(!m.attr.href) { m.attr.href = '#'; }
+            tmp.attr(m.attr)[ s.html_titles ? "html" : "text" ](m.title);
+            if(m.language) { tmp.addClass(m.language); }
+          }
+          tmp.prepend("<ins class='jstree-icon'>&#160;</ins>");
+          if(m.icon) { 
+            if(m.icon.indexOf("/") === -1) { tmp.children("ins").addClass(m.icon); }
+            else { tmp.children("ins").css("background","url('" + m.icon + "') center center no-repeat"); }
+          }
+          d.append(tmp);
+        });
+        d.prepend("<ins class='jstree-icon'>&#160;</ins>");
+        if(obj === -1) {
+          obj = this.get_container();
+          if(position === "before") { position = "first"; }
+          if(position === "after") { position = "last"; }
+        }
+        switch(position) {
+          case "before": obj.before(d); tmp = this._get_parent(obj); break;
+          case "after" : obj.after(d);  tmp = this._get_parent(obj); break;
+          case "inside":
+          case "first" :
+            if(!obj.children("ul").length) { obj.append("<ul>"); }
+            obj.children("ul").prepend(d);
+            tmp = obj;
+            break;
+          case "last":
+            if(!obj.children("ul").length) { obj.append("<ul>"); }
+            obj.children("ul").append(d);
+            tmp = obj;
+            break;
+          default:
+            if(!obj.children("ul").length) { obj.append("<ul>"); }
+            if(!position) { position = 0; }
+            tmp = obj.children("ul").children("li").eq(position);
+            if(tmp.length) { tmp.before(d); }
+            else { obj.children("ul").append(d); }
+            tmp = obj;
+            break;
+        }
+        if(tmp === -1 || tmp.get(0) === this.get_container().get(0)) { tmp = -1; }
+        this.clean_node(tmp);
+        this.__callback({ "obj" : d, "parent" : tmp });
+        if(callback) { callback.call(this, d); }
+        return d;
+      },
+      // Basic operations: rename (deal with text)
+      get_text  : function (obj) {
+        obj = this._get_node(obj);
+        if(!obj.length) { return false; }
+        var s = this._get_settings().core.html_titles;
+        obj = obj.children("a:eq(0)");
+        if(s) {
+          obj = obj.clone();
+          obj.children("INS").remove();
+          return obj.html();
+        }
+        else {
+          obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];
+          return obj.nodeValue;
+        }
+      },
+      set_text  : function (obj, val) {
+        obj = this._get_node(obj);
+        if(!obj.length) { return false; }
+        obj = obj.children("a:eq(0)");
+        if(this._get_settings().core.html_titles) {
+          var tmp = obj.children("INS").clone();
+          obj.html(val).prepend(tmp);
+          this.__callback({ "obj" : obj, "name" : val });
+          return true;
+        }
+        else {
+          obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];
+          this.__callback({ "obj" : obj, "name" : val });
+          return (obj.nodeValue = val);
+        }
+      },
+      rename_node : function (obj, val) {
+        obj = this._get_node(obj);
+        this.__rollback();
+        if(obj && obj.length && this.set_text.apply(this, Array.prototype.slice.call(arguments))) { this.__callback({ "obj" : obj, "name" : val }); }
+      },
+      // Basic operations: deleting nodes
+      delete_node : function (obj) {
+        obj = this._get_node(obj);
+        if(!obj.length) { return false; }
+        this.__rollback();
+        var p = this._get_parent(obj), prev = this._get_prev(obj);
+        obj = obj.remove();
+        if(p !== -1 && p.find("> ul > li").length === 0) {
+          p.removeClass("jstree-open jstree-closed").addClass("jstree-leaf");
+        }
+        this.clean_node(p);
+        this.__callback({ "obj" : obj, "prev" : prev });
+        return obj;
+      },
+      prepare_move : function (o, r, pos, cb, is_cb) {
+        var p = {};
+
+        p.ot = $.jstree._reference(p.o) || this;
+        p.o = p.ot._get_node(o);
+        p.r = r === - 1 ? -1 : this._get_node(r);
+        p.p = (typeof p === "undefined") ? "last" : pos; // TODO: move to a setting
+        if(!is_cb && prepared_move.o && prepared_move.o[0] === p.o[0] && prepared_move.r[0] === p.r[0] && prepared_move.p === p.p) {
+          this.__callback(prepared_move);
+          if(cb) { cb.call(this, prepared_move); }
+          return;
+        }
+        p.ot = $.jstree._reference(p.o) || this;
+        p.rt = r === -1 ? p.ot : $.jstree._reference(p.r) || this;
+        if(p.r === -1) {
+          p.cr = -1;
+          switch(p.p) {
+            case "first":
+            case "before":
+            case "inside":
+              p.cp = 0; 
+              break;
+            case "after":
+            case "last":
+              p.cp = p.rt.get_container().find(" > ul > li").length; 
+              break;
+            default:
+              p.cp = p.p;
+              break;
+          }
+        }
+        else {
+          if(!/^(before|after)$/.test(p.p) && !this._is_loaded(p.r)) {
+            return this.load_node(p.r, function () { this.prepare_move(o, r, pos, cb, true); });
+          }
+          switch(p.p) {
+            case "before":
+              p.cp = p.r.index();
+              p.cr = p.rt._get_parent(p.r);
+              break;
+            case "after":
+              p.cp = p.r.index() + 1;
+              p.cr = p.rt._get_parent(p.r);
+              break;
+            case "inside":
+            case "first":
+              p.cp = 0;
+              p.cr = p.r;
+              break;
+            case "last":
+              p.cp = p.r.find(" > ul > li").length; 
+              p.cr = p.r;
+              break;
+            default: 
+              p.cp = p.p;
+              p.cr = p.r;
+              break;
+          }
+        }
+        p.np = p.cr == -1 ? p.rt.get_container() : p.cr;
+        p.op = p.ot._get_parent(p.o);
+        p.or = p.np.find(" > ul > li:nth-child(" + (p.cp + 1) + ")");
+
+        prepared_move = p;
+        this.__callback(prepared_move);
+        if(cb) { cb.call(this, prepared_move); }
+      },
+      check_move : function () {
+        var obj = prepared_move, ret = true;
+        if(obj.or[0] === obj.o[0]) { return false; }
+        obj.o.each(function () { 
+          if(obj.r.parentsUntil(".jstree").andSelf().filter("li").index(this) !== -1) { ret = false; return false; }
+        });
+        return ret;
+      },
+      move_node : function (obj, ref, position, is_copy, is_prepared, skip_check) {
+        if(!is_prepared) { 
+          return this.prepare_move(obj, ref, position, function (p) {
+            this.move_node(p, false, false, is_copy, true, skip_check);
+          });
+        }
+        if(!skip_check && !this.check_move()) { return false; }
+
+        this.__rollback();
+        var o = false;
+        if(is_copy) {
+          o = obj.o.clone();
+          o.find("*[id]").andSelf().each(function () {
+            if(this.id) { this.id = "copy_" + this.id; }
+          });
+        }
+        else { o = obj.o; }
+
+        if(obj.or.length) { obj.or.before(o); }
+        else { 
+          if(!obj.np.children("ul").length) { $("<ul>").appendTo(obj.np); }
+          obj.np.children("ul:eq(0)").append(o); 
+        }
+
+        try { 
+          obj.ot.clean_node(obj.op);
+          obj.rt.clean_node(obj.np);
+          if(!obj.op.find("> ul > li").length) {
+            obj.op.removeClass("jstree-open jstree-closed").addClass("jstree-leaf").children("ul").remove();
+          }
+        } catch (e) { }
+
+        if(is_copy) { 
+          prepared_move.cy = true;
+          prepared_move.oc = o; 
+        }
+        this.__callback(prepared_move);
+        return prepared_move;
+      },
+      _get_move : function () { return prepared_move; }
+    }
+  });
 })(jQuery);
 //*/
 
@@ -847,180 +847,180 @@ THE SOFTWARE.
  * This plugins handles selecting/deselecting/hovering/dehovering nodes
  */
 (function ($) {
-	$.jstree.plugin("ui", {
-		__init : function () { 
-			this.data.ui.selected = $(); 
-			this.data.ui.last_selected = false; 
-			this.data.ui.hovered = null;
-			this.data.ui.to_select = this.get_settings().ui.initially_select;
-
-			this.get_container()
-				.delegate("a", "click.jstree", $.proxy(function (event) {
-						event.preventDefault();
-						this.select_node(event.currentTarget, true, event);
-					}, this))
-				.delegate("a", "mouseenter.jstree", $.proxy(function (event) {
-						this.hover_node(event.target);
-					}, this))
-				.delegate("a", "mouseleave.jstree", $.proxy(function (event) {
-						this.dehover_node(event.target);
-					}, this))
-				.bind("reopen.jstree", $.proxy(function () { 
-						this.reselect();
-					}, this))
-				.bind("get_rollback.jstree", $.proxy(function () { 
-						this.dehover_node();
-						this.save_selected();
-					}, this))
-				.bind("set_rollback.jstree", $.proxy(function () { 
-						this.reselect();
-					}, this))
-				.bind("close_node.jstree", $.proxy(function (event, data) { 
-						var s = this._get_settings().ui,
-							obj = this._get_node(data.rslt.obj),
-							clk = (obj && obj.length) ? obj.children("ul").find(".jstree-clicked") : $(),
-							_this = this;
-						if(s.selected_parent_close === false || !clk.length) { return; }
-						clk.each(function () { 
-							_this.deselect_node(this);
-							if(s.selected_parent_close === "select_parent") { _this.select_node(obj); }
-						});
-					}, this))
-				.bind("delete_node.jstree", $.proxy(function (event, data) { 
-						var s = this._get_settings().ui.select_prev_on_delete,
-							obj = this._get_node(data.rslt.obj),
-							clk = (obj && obj.length) ? obj.find(".jstree-clicked") : [],
-							_this = this;
-						clk.each(function () { _this.deselect_node(this); });
-						if(s && clk.length) { this.select_node(data.rslt.prev); }
-					}, this))
-				.bind("move_node.jstree", $.proxy(function (event, data) { 
-						if(data.rslt.cy) { 
-							data.rslt.oc.find(".jstree-clicked").removeClass("jstree-clicked");
-						}
-					}, this));
-		},
-		defaults : {
-			select_limit : -1, // 0, 1, 2 ... or -1 for unlimited
-			select_multiple_modifier : "ctrl", // on, or ctrl, shift, alt
-			selected_parent_close : "select_parent", // false, "deselect", "select_parent"
-			select_prev_on_delete : true,
-			disable_selecting_children : false,
-			initially_select : []
-		},
-		_fn : { 
-			_get_node : function (obj, allow_multiple) {
-				if(typeof obj === "undefined" || obj === null) { return allow_multiple ? this.data.ui.selected : this.data.ui.last_selected; }
-				var $obj = $(obj, this.get_container()); 
-				if($obj.is(".jstree") || obj == -1) { return -1; } 
-				$obj = $obj.closest("li", this.get_container()); 
-				return $obj.length ? $obj : false; 
-			},
-			save_selected : function () {
-				var _this = this;
-				this.data.ui.to_select = [];
-				this.data.ui.selected.each(function () { _this.data.ui.to_select.push("#" + this.id.toString().replace(/^#/,"").replace('\\/','/').replace('/','\\/')); });
-				this.__callback(this.data.ui.to_select);
-			},
-			reselect : function () {
-				var _this = this,
-					s = this.data.ui.to_select;
-				s = $.map($.makeArray(s), function (n) { return "#" + n.toString().replace(/^#/,"").replace('\\/','/').replace('/','\\/'); });
-				this.deselect_all();
-				$.each(s, function (i, val) { if(val && val !== "#") { _this.select_node(val); } });
-				this.__callback();
-			},
-			refresh : function (obj) {
-				this.save_selected();
-				return this.__call_old();
-			},
-			hover_node : function (obj) {
-				obj = this._get_node(obj);
-				if(!obj.length) { return false; }
-				//if(this.data.ui.hovered && obj.get(0) === this.data.ui.hovered.get(0)) { return; }
-				if(!obj.hasClass("jstree-hovered")) { this.dehover_node(); }
-				this.data.ui.hovered = obj.children("a").addClass("jstree-hovered").parent();
-				this.__callback({ "obj" : obj });
-			},
-			dehover_node : function () {
-				var obj = this.data.ui.hovered, p;
-				if(!obj || !obj.length) { return false; }
-				p = obj.children("a").removeClass("jstree-hovered").parent();
-				if(this.data.ui.hovered[0] === p[0]) { this.data.ui.hovered = null; }
-				this.__callback({ "obj" : obj });
-			},
-			select_node : function (obj, check, e) {
-				obj = this._get_node(obj);
-				if(obj == -1 || !obj || !obj.length) { return false; }
-				var s = this._get_settings().ui,
-					is_multiple = (s.select_multiple_modifier == "on" || (s.select_multiple_modifier !== false && e && e[s.select_multiple_modifier + "Key"])),
-					is_selected = this.is_selected(obj),
-					proceed = true;
-				if(check) {
-					if(s.disable_selecting_children && is_multiple && obj.parents("li", this.get_container()).children(".jstree-clicked").length) {
-						return false;
-					}
-					proceed = false;
-					switch(!0) {
-						case (is_selected && !is_multiple): 
-							this.deselect_all();
-							is_selected = false;
-							proceed = true;
-							break;
-						case (!is_selected && !is_multiple): 
-							if(s.select_limit == -1 || s.select_limit > 0) {
-								this.deselect_all();
-								proceed = true;
-							}
-							break;
-						case (is_selected && is_multiple): 
-							this.deselect_node(obj);
-							break;
-						case (!is_selected && is_multiple): 
-							if(s.select_limit == -1 || this.data.ui.selected.length + 1 <= s.select_limit) { 
-								proceed = true;
-							}
-							break;
-					}
-				}
-				if(proceed && !is_selected) {
-					obj.children("a").addClass("jstree-clicked");
-					this.data.ui.selected = this.data.ui.selected.add(obj);
-					this.data.ui.last_selected = obj;
-					this.__callback({ "obj" : obj });
-				}
-			},
-			deselect_node : function (obj) {
-				obj = this._get_node(obj);
-				if(!obj.length) { return false; }
-				if(this.is_selected(obj)) {
-					obj.children("a").removeClass("jstree-clicked");
-					this.data.ui.selected = this.data.ui.selected.not(obj);
-					if(this.data.ui.last_selected.get(0) === obj.get(0)) { this.data.ui.last_selected = this.data.ui.selected.eq(0); }
-					this.__callback({ "obj" : obj });
-				}
-			},
-			toggle_select : function (obj) {
-				obj = this._get_node(obj);
-				if(!obj.length) { return false; }
-				if(this.is_selected(obj)) { this.deselect_node(obj); }
-				else { this.select_node(obj); }
-			},
-			is_selected : function (obj) { return this.data.ui.selected.index(this._get_node(obj)) >= 0; },
-			get_selected : function (context) { 
-				return context ? $(context).find(".jstree-clicked").parent() : this.data.ui.selected; 
-			},
-			deselect_all : function (context) {
-				if(context) { $(context).find(".jstree-clicked").removeClass("jstree-clicked"); } 
-				else { this.get_container().find(".jstree-clicked").removeClass("jstree-clicked"); }
-				this.data.ui.selected = $([]);
-				this.data.ui.last_selected = false;
-				this.__callback();
-			}
-		}
-	});
-	// include the selection plugin by default
-	$.jstree.defaults.plugins.push("ui");
+  $.jstree.plugin("ui", {
+    __init : function () { 
+      this.data.ui.selected = $(); 
+      this.data.ui.last_selected = false; 
+      this.data.ui.hovered = null;
+      this.data.ui.to_select = this.get_settings().ui.initially_select;
+
+      this.get_container()
+        .delegate("a", "click.jstree", $.proxy(function (event) {
+            event.preventDefault();
+            this.select_node(event.currentTarget, true, event);
+          }, this))
+        .delegate("a", "mouseenter.jstree", $.proxy(function (event) {
+            this.hover_node(event.target);
+          }, this))
+        .delegate("a", "mouseleave.jstree", $.proxy(function (event) {
+            this.dehover_node(event.target);
+          }, this))
+        .bind("reopen.jstree", $.proxy(function () { 
+            this.reselect();
+          }, this))
+        .bind("get_rollback.jstree", $.proxy(function () { 
+            this.dehover_node();
+            this.save_selected();
+          }, this))
+        .bind("set_rollback.jstree", $.proxy(function () { 
+            this.reselect();
+          }, this))
+        .bind("close_node.jstree", $.proxy(function (event, data) { 
+            var s = this._get_settings().ui,
+              obj = this._get_node(data.rslt.obj),
+              clk = (obj && obj.length) ? obj.children("ul").find(".jstree-clicked") : $(),
+              _this = this;
+            if(s.selected_parent_close === false || !clk.length) { return; }
+            clk.each(function () { 
+              _this.deselect_node(this);
+              if(s.selected_parent_close === "select_parent") { _this.select_node(obj); }
+            });
+          }, this))
+        .bind("delete_node.jstree", $.proxy(function (event, data) { 
+            var s = this._get_settings().ui.select_prev_on_delete,
+              obj = this._get_node(data.rslt.obj),
+              clk = (obj && obj.length) ? obj.find(".jstree-clicked") : [],
+              _this = this;
+            clk.each(function () { _this.deselect_node(this); });
+            if(s && clk.length) { this.select_node(data.rslt.prev); }
+          }, this))
+        .bind("move_node.jstree", $.proxy(function (event, data) { 
+            if(data.rslt.cy) { 
+              data.rslt.oc.find(".jstree-clicked").removeClass("jstree-clicked");
+            }
+          }, this));
+    },
+    defaults : {
+      select_limit : -1, // 0, 1, 2 ... or -1 for unlimited
+      select_multiple_modifier : "ctrl", // on, or ctrl, shift, alt
+      selected_parent_close : "select_parent", // false, "deselect", "select_parent"
+      select_prev_on_delete : true,
+      disable_selecting_children : false,
+      initially_select : []
+    },
+    _fn : { 
+      _get_node : function (obj, allow_multiple) {
+        if(typeof obj === "undefined" || obj === null) { return allow_multiple ? this.data.ui.selected : this.data.ui.last_selected; }
+        var $obj = $(obj, this.get_container()); 
+        if($obj.is(".jstree") || obj == -1) { return -1; } 
+        $obj = $obj.closest("li", this.get_container()); 
+        return $obj.length ? $obj : false; 
+      },
+      save_selected : function () {
+        var _this = this;
+        this.data.ui.to_select = [];
+        this.data.ui.selected.each(function () { _this.data.ui.to_select.push("#" + this.id.toString().replace(/^#/,"").replace('\\/','/').replace('/','\\/')); });
+        this.__callback(this.data.ui.to_select);
+      },
+      reselect : function () {
+        var _this = this,
+          s = this.data.ui.to_select;
+        s = $.map($.makeArray(s), function (n) { return "#" + n.toString().replace(/^#/,"").replace('\\/','/').replace('/','\\/'); });
+        this.deselect_all();
+        $.each(s, function (i, val) { if(val && val !== "#") { _this.select_node(val); } });
+        this.__callback();
+      },
+      refresh : function (obj) {
+        this.save_selected();
+        return this.__call_old();
+      },
+      hover_node : function (obj) {
+        obj = this._get_node(obj);
+        if(!obj.length) { return false; }
+        //if(this.data.ui.hovered && obj.get(0) === this.data.ui.hovered.get(0)) { return; }
+        if(!obj.hasClass("jstree-hovered")) { this.dehover_node(); }
+        this.data.ui.hovered = obj.children("a").addClass("jstree-hovered").parent();
+        this.__callback({ "obj" : obj });
+      },
+      dehover_node : function () {
+        var obj = this.data.ui.hovered, p;
+        if(!obj || !obj.length) { return false; }
+        p = obj.children("a").removeClass("jstree-hovered").parent();
+        if(this.data.ui.hovered[0] === p[0]) { this.data.ui.hovered = null; }
+        this.__callback({ "obj" : obj });
+      },
+      select_node : function (obj, check, e) {
+        obj = this._get_node(obj);
+        if(obj == -1 || !obj || !obj.length) { return false; }
+        var s = this._get_settings().ui,
+          is_multiple = (s.select_multiple_modifier == "on" || (s.select_multiple_modifier !== false && e && e[s.select_multiple_modifier + "Key"])),
+          is_selected = this.is_selected(obj),
+          proceed = true;
+        if(check) {
+          if(s.disable_selecting_children && is_multiple && obj.parents("li", this.get_container()).children(".jstree-clicked").length) {
+            return false;
+          }
+          proceed = false;
+          switch(!0) {
+            case (is_selected && !is_multiple): 
+              this.deselect_all();
+              is_selected = false;
+              proceed = true;
+              break;
+            case (!is_selected && !is_multiple): 
+              if(s.select_limit == -1 || s.select_limit > 0) {
+                this.deselect_all();
+                proceed = true;
+              }
+              break;
+            case (is_selected && is_multiple): 
+              this.deselect_node(obj);
+              break;
+            case (!is_selected && is_multiple): 
+              if(s.select_limit == -1 || this.data.ui.selected.length + 1 <= s.select_limit) { 
+                proceed = true;
+              }
+              break;
+          }
+        }
+        if(proceed && !is_selected) {
+          obj.children("a").addClass("jstree-clicked");
+          this.data.ui.selected = this.data.ui.selected.add(obj);
+          this.data.ui.last_selected = obj;
+          this.__callback({ "obj" : obj });
+        }
+      },
+      deselect_node : function (obj) {
+        obj = this._get_node(obj);
+        if(!obj.length) { return false; }
+        if(this.is_selected(obj)) {
+          obj.children("a").removeClass("jstree-clicked");
+          this.data.ui.selected = this.data.ui.selected.not(obj);
+          if(this.data.ui.last_selected.get(0) === obj.get(0)) { this.data.ui.last_selected = this.data.ui.selected.eq(0); }
+          this.__callback({ "obj" : obj });
+        }
+      },
+      toggle_select : function (obj) {
+        obj = this._get_node(obj);
+        if(!obj.length) { return false; }
+        if(this.is_selected(obj)) { this.deselect_node(obj); }
+        else { this.select_node(obj); }
+      },
+      is_selected : function (obj) { return this.data.ui.selected.index(this._get_node(obj)) >= 0; },
+      get_selected : function (context) { 
+        return context ? $(context).find(".jstree-clicked").parent() : this.data.ui.selected; 
+      },
+      deselect_all : function (context) {
+        if(context) { $(context).find(".jstree-clicked").removeClass("jstree-clicked"); } 
+        else { this.get_container().find(".jstree-clicked").removeClass("jstree-clicked"); }
+        this.data.ui.selected = $([]);
+        this.data.ui.last_selected = false;
+        this.__callback();
+      }
+    }
+  });
+  // include the selection plugin by default
+  $.jstree.defaults.plugins.push("ui");
 })(jQuery);
 //*/
 
@@ -1029,164 +1029,164 @@ THE SOFTWARE.
  * Handles creating/renaming/removing/moving nodes by user interaction.
  */
 (function ($) {
-	$.jstree.plugin("crrm", { 
-		__init : function () {
-			this.get_container()
-				.bind("move_node.jstree", $.proxy(function (e, data) {
-					if(this._get_settings().crrm.move.open_onmove) {
-						var t = this;
-						data.rslt.np.parentsUntil(".jstree").andSelf().filter(".jstree-closed").each(function () {
-							t.open_node(this, false, true);
-						});
-					}
-				}, this));
-		},
-		defaults : {
-			input_width_limit : 200,
-			move : {
-				always_copy			: false, // false, true or "multitree"
-				open_onmove			: true,
-				default_position	: "last",
-				check_move			: function (m) { return true; }
-			}
-		},
-		_fn : {
-			_show_input : function (obj, callback) {
-				obj = this._get_node(obj);
-				var rtl = this._get_settings().core.rtl,
-					w = this._get_settings().crrm.input_width_limit,
-					w1 = obj.children("ins").width(),
-					w2 = obj.find("> a:visible > ins").width() * obj.find("> a:visible > ins").length,
-					t = this.get_text(obj),
-					h1 = $("<div>", { css : { "position" : "absolute", "top" : "-200px", "left" : (rtl ? "0px" : "-1000px"), "visibility" : "hidden" } }).appendTo("body"),
-					h2 = obj.css("position","relative").append(
-					$("<input>", { 
-						"value" : t,
-						// "size" : t.length,
-						"css" : {
-							"padding" : "0",
-							"border" : "1px solid silver",
-							"position" : "absolute",
-							"left"  : (rtl ? "auto" : (w1 + w2 + 4) + "px"),
-							"right" : (rtl ? (w1 + w2 + 4) + "px" : "auto"),
-							"top" : "0px",
-							"height" : (this.data.core.li_height - 2) + "px",
-							"lineHeight" : (this.data.core.li_height - 2) + "px",
-							"width" : "150px" // will be set a bit further down
-						},
-						"blur" : $.proxy(function () {
-							var i = obj.children("input"),
-								v = i.val();
-							if(v === "") { v = t; }
-							i.remove(); // rollback purposes
-							this.set_text(obj,t); // rollback purposes
-							this.rename_node(obj, v);
-							callback.call(this, obj, v, t);
-							obj.css("position","");
-						}, this),
-						"keyup" : function (event) {
-							var key = event.keyCode || event.which;
-							if(key == 27) { this.value = t; this.blur(); return; }
-							else if(key == 13) { this.blur(); return; }
-							else {
-								h2.width(Math.min(h1.text("pW" + this.value).width(),w));
-							}
-						}
-					})
-				).children("input"); 
-				this.set_text(obj, "");
-				h1.css({
-						fontFamily		: h2.css('fontFamily')		|| '',
-						fontSize		: h2.css('fontSize')		|| '',
-						fontWeight		: h2.css('fontWeight')		|| '',
-						fontStyle		: h2.css('fontStyle')		|| '',
-						fontStretch		: h2.css('fontStretch')		|| '',
-						fontVariant		: h2.css('fontVariant')		|| '',
-						letterSpacing	: h2.css('letterSpacing')	|| '',
-						wordSpacing		: h2.css('wordSpacing')		|| ''
-				});
-				h2.width(Math.min(h1.text("pW" + h2[0].value).width(),w))[0].select();
-			},
-			rename : function (obj) {
-				obj = this._get_node(obj);
-				this.__rollback();
-				var f = this.__callback;
-				this._show_input(obj, function (obj, new_name, old_name) { 
-					f.call(this, { "obj" : obj, "new_name" : new_name, "old_name" : old_name });
-				});
-			},
-			create : function (obj, position, js, callback, skip_rename) {
-				var t, _this = this;
-				obj = this._get_node(obj);
-				if(!obj) { obj = -1; }
-				this.__rollback();
-				t = this.create_node(obj, position, js, function (t) {
-					var p = this._get_parent(t),
-						pos = $(t).index();
-					if(callback) { callback.call(this, t); }
-					if(p.length && p.hasClass("jstree-closed")) { this.open_node(p, false, true); }
-					if(!skip_rename) { 
-						this._show_input(t, function (obj, new_name, old_name) { 
-							_this.__callback({ "obj" : obj, "name" : new_name, "parent" : p, "position" : pos });
-						});
-					}
-					else { _this.__callback({ "obj" : t, "name" : this.get_text(t), "parent" : p, "position" : pos }); }
-				});
-				return t;
-			},
-			remove : function (obj) {
-				obj = this._get_node(obj, true);
-				this.__rollback();
-				this.delete_node(obj);
-				this.__callback({ "obj" : obj });
-			},
-			check_move : function () {
-				if(!this.__call_old()) { return false; }
-				var s = this._get_settings().crrm.move;
-				if(!s.check_move.call(this, this._get_move())) { return false; }
-				return true;
-			},
-			move_node : function (obj, ref, position, is_copy, is_prepared, skip_check) {
-				var s = this._get_settings().crrm.move;
-				if(!is_prepared) { 
-					if(!position) { position = s.default_position; }
-					if(position === "inside" && !s.default_position.match(/^(before|after)$/)) { position = s.default_position; }
-					return this.__call_old(true, obj, ref, position, is_copy, false, skip_check);
-				}
-				// if the move is already prepared
-				if(s.always_copy === true || (s.always_copy === "multitree" && obj.rt.get_index() !== obj.ot.get_index() )) {
-					is_copy = true;
-				}
-				this.__call_old(true, obj, ref, position, is_copy, true, skip_check);
-			},
-
-			cut : function (obj) {
-				obj = this._get_node(obj);
-				this.data.crrm.cp_nodes = false;
-				this.data.crrm.ct_nodes = false;
-				if(!obj || !obj.length) { return false; }
-				this.data.crrm.ct_nodes = obj;
-			},
-			copy : function (obj) {
-				obj = this._get_node(obj);
-				this.data.crrm.cp_nodes = false;
-				this.data.crrm.ct_nodes = false;
-				if(!obj || !obj.length) { return false; }
-				this.data.crrm.cp_nodes = obj;
-			},
-			paste : function (obj) { 
-				obj = this._get_node(obj);
-				if(!obj || !obj.length) { return false; }
-				if(!this.data.crrm.ct_nodes && !this.data.crrm.cp_nodes) { return false; }
-				if(this.data.crrm.ct_nodes) { this.move_node(this.data.crrm.ct_nodes, obj); }
-				if(this.data.crrm.cp_nodes) { this.move_node(this.data.crrm.cp_nodes, obj, false, true); }
-				this.data.crrm.cp_nodes = false;
-				this.data.crrm.ct_nodes = false;
-			}
-		}
-	});
-	// include the crr plugin by default
-	$.jstree.defaults.plugins.push("crrm");
+  $.jstree.plugin("crrm", { 
+    __init : function () {
+      this.get_container()
+        .bind("move_node.jstree", $.proxy(function (e, data) {
+          if(this._get_settings().crrm.move.open_onmove) {
+            var t = this;
+            data.rslt.np.parentsUntil(".jstree").andSelf().filter(".jstree-closed").each(function () {
+              t.open_node(this, false, true);
+            });
+          }
+        }, this));
+    },
+    defaults : {
+      input_width_limit : 200,
+      move : {
+        always_copy      : false, // false, true or "multitree"
+        open_onmove      : true,
+        default_position  : "last",
+        check_move      : function (m) { return true; }
+      }
+    },
+    _fn : {
+      _show_input : function (obj, callback) {
+        obj = this._get_node(obj);
+        var rtl = this._get_settings().core.rtl,
+          w = this._get_settings().crrm.input_width_limit,
+          w1 = obj.children("ins").width(),
+          w2 = obj.find("> a:visible > ins").width() * obj.find("> a:visible > ins").length,
+          t = this.get_text(obj),
+          h1 = $("<div>", { css : { "position" : "absolute", "top" : "-200px", "left" : (rtl ? "0px" : "-1000px"), "visibility" : "hidden" } }).appendTo("body"),
+          h2 = obj.css("position","relative").append(
+          $("<input>", { 
+            "value" : t,
+            // "size" : t.length,
+            "css" : {
+              "padding" : "0",
+              "border" : "1px solid silver",
+              "position" : "absolute",
+              "left"  : (rtl ? "auto" : (w1 + w2 + 4) + "px"),
+              "right" : (rtl ? (w1 + w2 + 4) + "px" : "auto"),
+              "top" : "0px",
+              "height" : (this.data.core.li_height - 2) + "px",
+              "lineHeight" : (this.data.core.li_height - 2) + "px",
+              "width" : "150px" // will be set a bit further down
+            },
+            "blur" : $.proxy(function () {
+              var i = obj.children("input"),
+                v = i.val();
+              if(v === "") { v = t; }
+              i.remove(); // rollback purposes
+              this.set_text(obj,t); // rollback purposes
+              this.rename_node(obj, v);
+              callback.call(this, obj, v, t);
+              obj.css("position","");
+            }, this),
+            "keyup" : function (event) {
+              var key = event.keyCode || event.which;
+              if(key == 27) { this.value = t; this.blur(); return; }
+              else if(key == 13) { this.blur(); return; }
+              else {
+                h2.width(Math.min(h1.text("pW" + this.value).width(),w));
+              }
+            }
+          })
+        ).children("input"); 
+        this.set_text(obj, "");
+        h1.css({
+            fontFamily    : h2.css('fontFamily')    || '',
+            fontSize    : h2.css('fontSize')    || '',
+            fontWeight    : h2.css('fontWeight')    || '',
+            fontStyle    : h2.css('fontStyle')    || '',
+            fontStretch    : h2.css('fontStretch')    || '',
+            fontVariant    : h2.css('fontVariant')    || '',
+            letterSpacing  : h2.css('letterSpacing')  || '',
+            wordSpacing    : h2.css('wordSpacing')    || ''
+        });
+        h2.width(Math.min(h1.text("pW" + h2[0].value).width(),w))[0].select();
+      },
+      rename : function (obj) {
+        obj = this._get_node(obj);
+        this.__rollback();
+        var f = this.__callback;
+        this._show_input(obj, function (obj, new_name, old_name) { 
+          f.call(this, { "obj" : obj, "new_name" : new_name, "old_name" : old_name });
+        });
+      },
+      create : function (obj, position, js, callback, skip_rename) {
+        var t, _this = this;
+        obj = this._get_node(obj);
+        if(!obj) { obj = -1; }
+        this.__rollback();
+        t = this.create_node(obj, position, js, function (t) {
+          var p = this._get_parent(t),
+            pos = $(t).index();
+          if(callback) { callback.call(this, t); }
+          if(p.length && p.hasClass("jstree-closed")) { this.open_node(p, false, true); }
+          if(!skip_rename) { 
+            this._show_input(t, function (obj, new_name, old_name) { 
+              _this.__callback({ "obj" : obj, "name" : new_name, "parent" : p, "position" : pos });
+            });
+          }
+          else { _this.__callback({ "obj" : t, "name" : this.get_text(t), "parent" : p, "position" : pos }); }
+        });
+        return t;
+      },
+      remove : function (obj) {
+        obj = this._get_node(obj, true);
+        this.__rollback();
+        this.delete_node(obj);
+        this.__callback({ "obj" : obj });
+      },
+      check_move : function () {
+        if(!this.__call_old()) { return false; }
+        var s = this._get_settings().crrm.move;
+        if(!s.check_move.call(this, this._get_move())) { return false; }
+        return true;
+      },
+      move_node : function (obj, ref, position, is_copy, is_prepared, skip_check) {
+        var s = this._get_settings().crrm.move;
+        if(!is_prepared) { 
+          if(!position) { position = s.default_position; }
+          if(position === "inside" && !s.default_position.match(/^(before|after)$/)) { position = s.default_position; }
+          return this.__call_old(true, obj, ref, position, is_copy, false, skip_check);
+        }
+        // if the move is already prepared
+        if(s.always_copy === true || (s.always_copy === "multitree" && obj.rt.get_index() !== obj.ot.get_index() )) {
+          is_copy = true;
+        }
+        this.__call_old(true, obj, ref, position, is_copy, true, skip_check);
+      },
+
+      cut : function (obj) {
+        obj = this._get_node(obj);
+        this.data.crrm.cp_nodes = false;
+        this.data.crrm.ct_nodes = false;
+        if(!obj || !obj.length) { return false; }
+        this.data.crrm.ct_nodes = obj;
+      },
+      copy : function (obj) {
+        obj = this._get_node(obj);
+        this.data.crrm.cp_nodes = false;
+        this.data.crrm.ct_nodes = false;
+        if(!obj || !obj.length) { return false; }
+        this.data.crrm.cp_nodes = obj;
+      },
+      paste : function (obj) { 
+        obj = this._get_node(obj);
+        if(!obj || !obj.length) { return false; }
+        if(!this.data.crrm.ct_nodes && !this.data.crrm.cp_nodes) { return false; }
+        if(this.data.crrm.ct_nodes) { this.move_node(this.data.crrm.ct_nodes, obj); }
+        if(this.data.crrm.cp_nodes) { this.move_node(this.data.crrm.cp_nodes, obj, false, true); }
+        this.data.crrm.cp_nodes = false;
+        this.data.crrm.ct_nodes = false;
+      }
+    }
+  });
+  // include the crr plugin by default
+  $.jstree.defaults.plugins.push("crrm");
 })(jQuery);
 
 /* 
@@ -1194,77 +1194,77 @@ THE SOFTWARE.
  * Handles loading and setting themes, as well as detecting path to themes, etc.
  */
 (function ($) {
-	var themes_loaded = [];
-	// this variable stores the path to the themes folder - if left as false - it will be autodetected
-	$.jstree._themes = false;
-	$.jstree.plugin("themes", {
-		__init : function () { 
-			this.get_container()
-				.bind("init.jstree", $.proxy(function () {
-						var s = this._get_settings().themes;
-						this.data.themes.dots = s.dots; 
-						this.data.themes.icons = s.icons; 
-						//alert(s.dots);
-						this.set_theme(s.theme, s.url);
-					}, this))
-				.bind("loaded.jstree", $.proxy(function () {
-						// bound here too, as simple HTML tree's won't honor dots & icons otherwise
-						if(!this.data.themes.dots) { this.hide_dots(); }
-						else { this.show_dots(); }
-						if(!this.data.themes.icons) { this.hide_icons(); }
-						else { this.show_icons(); }
-					}, this));
-		},
-		defaults : { 
-			theme : "default", 
-			url : false,
-			dots : true,
-			icons : true
-		},
-		_fn : {
-			set_theme : function (theme_name, theme_url) {
-				if(!theme_name) { return false; }
-				if(!theme_url) { theme_url = $.jstree._themes + theme_name + '/style.css'; }
-				if($.inArray(theme_url, themes_loaded) == -1) {
-					$.vakata.css.add_sheet({ "url" : theme_url, "rel" : "jstree" });
-					themes_loaded.push(theme_url);
-				}
-				if(this.data.themes.theme != theme_name) {
-					this.get_container().removeClass('jstree-' + this.data.themes.theme);
-					this.data.themes.theme = theme_name;
-				}
-				this.get_container().addClass('jstree-' + theme_name);
-				if(!this.data.themes.dots) { this.hide_dots(); }
-				else { this.show_dots(); }
-				if(!this.data.themes.icons) { this.hide_icons(); }
-				else { this.show_icons(); }
-				this.__callback();
-			},
-			get_theme	: function () { return this.data.themes.theme; },
-
-			show_dots	: function () { this.data.themes.dots = true; this.get_container().children("ul").removeClass("jstree-no-dots"); },
-			hide_dots	: function () { this.data.themes.dots = false; this.get_container().children("ul").addClass("jstree-no-dots"); },
-			toggle_dots	: function () { if(this.data.themes.dots) { this.hide_dots(); } else { this.show_dots(); } },
-
-			show_icons	: function () { this.data.themes.icons = true; this.get_container().children("ul").removeClass("jstree-no-icons"); },
-			hide_icons	: function () { this.data.themes.icons = false; this.get_container().children("ul").addClass("jstree-no-icons"); },
-			toggle_icons: function () { if(this.data.themes.icons) { this.hide_icons(); } else { this.show_icons(); } }
-		}
-	});
-	// autodetect themes path
-	$(function () {
-		if($.jstree._themes === false) {
-			$("script").each(function () { 
-				if(this.src.toString().match(/jquery\.jstree[^\/]*?\.js(\?.*)?$/)) { 
-					$.jstree._themes = this.src.toString().replace(/jquery\.jstree[^\/]*?\.js(\?.*)?$/, "") + 'themes/'; 
-					return false; 
-				}
-			});
-		}
-		if($.jstree._themes === false) { $.jstree._themes = "themes/"; }
-	});
-	// include the themes plugin by default
-	$.jstree.defaults.plugins.push("themes");
+  var themes_loaded = [];
+  // this variable stores the path to the themes folder - if left as false - it will be autodetected
+  $.jstree._themes = false;
+  $.jstree.plugin("themes", {
+    __init : function () { 
+      this.get_container()
+        .bind("init.jstree", $.proxy(function () {
+            var s = this._get_settings().themes;
+            this.data.themes.dots = s.dots; 
+            this.data.themes.icons = s.icons; 
+            //alert(s.dots);
+            this.set_theme(s.theme, s.url);
+          }, this))
+        .bind("loaded.jstree", $.proxy(function () {
+            // bound here too, as simple HTML tree's won't honor dots & icons otherwise
+            if(!this.data.themes.dots) { this.hide_dots(); }
+            else { this.show_dots(); }
+            if(!this.data.themes.icons) { this.hide_icons(); }
+            else { this.show_icons(); }
+          }, this));
+    },
+    defaults : { 
+      theme : "default", 
+      url : false,
+      dots : true,
+      icons : true
+    },
+    _fn : {
+      set_theme : function (theme_name, theme_url) {
+        if(!theme_name) { return false; }
+        if(!theme_url) { theme_url = $.jstree._themes + theme_name + '/style.css'; }
+        if($.inArray(theme_url, themes_loaded) == -1) {
+          $.vakata.css.add_sheet({ "url" : theme_url, "rel" : "jstree" });
+          themes_loaded.push(theme_url);
+        }
+        if(this.data.themes.theme != theme_name) {
+          this.get_container().removeClass('jstree-' + this.data.themes.theme);
+          this.data.themes.theme = theme_name;
+        }
+        this.get_container().addClass('jstree-' + theme_name);
+        if(!this.data.themes.dots) { this.hide_dots(); }
+        else { this.show_dots(); }
+        if(!this.data.themes.icons) { this.hide_icons(); }
+        else { this.show_icons(); }
+        this.__callback();
+      },
+      get_theme  : function () { return this.data.themes.theme; },
+
+      show_dots  : function () { this.data.themes.dots = true; this.get_container().children("ul").removeClass("jstree-no-dots"); },
+      hide_dots  : function () { this.data.themes.dots = false; this.get_container().children("ul").addClass("jstree-no-dots"); },
+      toggle_dots  : function () { if(this.data.themes.dots) { this.hide_dots(); } else { this.show_dots(); } },
+
+      show_icons  : function () { this.data.themes.icons = true; this.get_container().children("ul").removeClass("jstree-no-icons"); },
+      hide_icons  : function () { this.data.themes.icons = false; this.get_container().children("ul").addClass("jstree-no-icons"); },
+      toggle_icons: function () { if(this.data.themes.icons) { this.hide_icons(); } else { this.show_icons(); } }
+    }
+  });
+  // autodetect themes path
+  $(function () {
+    if($.jstree._themes === false) {
+      $("script").each(function () { 
+        if(this.src.toString().match(/jquery\.jstree[^\/]*?\.js(\?.*)?$/)) { 
+          $.jstree._themes = this.src.toString().replace(/jquery\.jstree[^\/]*?\.js(\?.*)?$/, "") + 'themes/'; 
+          return false; 
+        }
+      });
+    }
+    if($.jstree._themes === false) { $.jstree._themes = "themes/"; }
+  });
+  // include the themes plugin by default
+  $.jstree.defaults.plugins.push("themes");
 })(jQuery);
 //*/
 
@@ -1274,74 +1274,74 @@ THE SOFTWARE.
  * Depends on the jstree ui & jquery hotkeys plugins
  */
 (function ($) {
-	var bound = [];
-	function exec(i, event) {
-		var f = $.jstree._focused(), tmp;
-		if(f && f.data && f.data.hotkeys && f.data.hotkeys.enabled) { 
-			tmp = f._get_settings().hotkeys[i];
-			if(tmp) { return tmp.call(f, event); }
-		}
-	}
-	$.jstree.plugin("hotkeys", {
-		__init : function () {
-			if(typeof $.hotkeys === "undefined") { throw "jsTree hotkeys: jQuery hotkeys plugin not included."; }
-			if(!this.data.ui) { throw "jsTree hotkeys: jsTree UI plugin not included."; }
-			$.each(this._get_settings().hotkeys, function (i, val) {
-				if($.inArray(i, bound) == -1) {
-					$(document).bind("keydown", i, function (event) { return exec(i, event); });
-					bound.push(i);
-				}
-			});
-			this.enable_hotkeys();
-		},
-		defaults : {
-			"up" : function () { 
-				var o = this.data.ui.hovered || this.data.ui.last_selected || -1;
-				this.hover_node(this._get_prev(o));
-				return false; 
-			},
-			"down" : function () { 
-				var o = this.data.ui.hovered || this.data.ui.last_selected || -1;
-				this.hover_node(this._get_next(o));
-				return false;
-			},
-			"left" : function () { 
-				var o = this.data.ui.hovered || this.data.ui.last_selected;
-				if(o) {
-					if(o.hasClass("jstree-open")) { this.close_node(o); }
-					else { this.hover_node(this._get_prev(o)); }
-				}
-				return false;
-			},
-			"right" : function () { 
-				var o = this.data.ui.hovered || this.data.ui.last_selected;
-				if(o && o.length) {
-					if(o.hasClass("jstree-closed")) { this.open_node(o); }
-					else { this.hover_node(this._get_next(o)); }
-				}
-				return false;
-			},
-			"space" : function () { 
-				if(this.data.ui.hovered) { this.data.ui.hovered.children("a:eq(0)").click(); } 
-				return false; 
-			},
-			"ctrl+space" : function (event) { 
-				event.type = "click";
-				if(this.data.ui.hovered) { this.data.ui.hovered.children("a:eq(0)").trigger(event); } 
-				return false; 
-			},
-			"f2" : function () { this.rename(this.data.ui.hovered || this.data.ui.last_selected); },
-			"del" : function () { this.remove(this.data.ui.hovered || this._get_node(null)); }
-		},
-		_fn : {
-			enable_hotkeys : function () {
-				this.data.hotkeys.enabled = true;
-			},
-			disable_hotkeys : function () {
-				this.data.hotkeys.enabled = false;
-			}
-		}
-	});
+  var bound = [];
+  function exec(i, event) {
+    var f = $.jstree._focused(), tmp;
+    if(f && f.data && f.data.hotkeys && f.data.hotkeys.enabled) { 
+      tmp = f._get_settings().hotkeys[i];
+      if(tmp) { return tmp.call(f, event); }
+    }
+  }
+  $.jstree.plugin("hotkeys", {
+    __init : function () {
+      if(typeof $.hotkeys === "undefined") { throw "jsTree hotkeys: jQuery hotkeys plugin not included."; }
+      if(!this.data.ui) { throw "jsTree hotkeys: jsTree UI plugin not included."; }
+      $.each(this._get_settings().hotkeys, function (i, val) {
+        if($.inArray(i, bound) == -1) {
+          $(document).bind("keydown", i, function (event) { return exec(i, event); });
+          bound.push(i);
+        }
+      });
+      this.enable_hotkeys();
+    },
+    defaults : {
+      "up" : function () { 
+        var o = this.data.ui.hovered || this.data.ui.last_selected || -1;
+        this.hover_node(this._get_prev(o));
+        return false; 
+      },
+      "down" : function () { 
+        var o = this.data.ui.hovered || this.data.ui.last_selected || -1;
+        this.hover_node(this._get_next(o));
+        return false;
+      },
+      "left" : function () { 
+        var o = this.data.ui.hovered || this.data.ui.last_selected;
+        if(o) {
+          if(o.hasClass("jstree-open")) { this.close_node(o); }
+          else { this.hover_node(this._get_prev(o)); }
+        }
+        return false;
+      },
+      "right" : function () { 
+        var o = this.data.ui.hovered || this.data.ui.last_selected;
+        if(o && o.length) {
+          if(o.hasClass("jstree-closed")) { this.open_node(o); }
+          else { this.hover_node(this._get_next(o)); }
+        }
+        return false;
+      },
+      "space" : function () { 
+        if(this.data.ui.hovered) { this.data.ui.hovered.children("a:eq(0)").click(); } 
+        return false; 
+      },
+      "ctrl+space" : function (event) { 
+        event.type = "click";
+        if(this.data.ui.hovered) { this.data.ui.hovered.children("a:eq(0)").trigger(event); } 
+        return false; 
+      },
+      "f2" : function () { this.rename(this.data.ui.hovered || this.data.ui.last_selected); },
+      "del" : function () { this.remove(this.data.ui.hovered || this._get_node(null)); }
+    },
+    _fn : {
+      enable_hotkeys : function () {
+        this.data.hotkeys.enabled = true;
+      },
+      disable_hotkeys : function () {
+        this.data.hotkeys.enabled = false;
+      }
+    }
+  });
 })(jQuery);
 //*/
 
@@ -1350,248 +1350,248 @@ THE SOFTWARE.
  * The JSON data store. Datastores are build by overriding the `load_node` and `_is_loaded` functions.
  */
 (function ($) {
-	$.jstree.plugin("json_data", {
-		defaults : { 
-			data : false,
-			ajax : false,
-			correct_state : true,
-			progressive_render : false
-		},
-		_fn : {
-			load_node : function (obj, s_call, e_call) { var _this = this; this.load_node_json(obj, function () { _this.__callback({ "obj" : obj }); s_call.call(this); }, e_call); },
-			_is_loaded : function (obj) { 
-				var s = this._get_settings().json_data, d;
-				obj = this._get_node(obj); 
-				if(obj && obj !== -1 && s.progressive_render && !obj.is(".jstree-open, .jstree-leaf") && obj.children("ul").children("li").length === 0 && obj.data("jstree-children")) {
-					d = this._parse_json(obj.data("jstree-children"));
-					if(d) {
-						obj.append(d);
-						$.removeData(obj, "jstree-children");
-					}
-					this.clean_node(obj);
-					return true;
-				}
-				return obj == -1 || !obj || !s.ajax || obj.is(".jstree-open, .jstree-leaf") || obj.children("ul").children("li").size() > 0;
-			},
-			load_node_json : function (obj, s_call, e_call) {
-				var s = this.get_settings().json_data, d,
-					error_func = function () {},
-					success_func = function () {};
-				obj = this._get_node(obj);
-				if(obj && obj !== -1) {
-					if(obj.data("jstree-is-loading")) { return; }
-					else { obj.data("jstree-is-loading",true); }
-				}
-				switch(!0) {
-					case (!s.data && !s.ajax): throw "Neither data nor ajax settings supplied.";
-					case (!!s.data && !s.ajax) || (!!s.data && !!s.ajax && (!obj || obj === -1)):
-						if(!obj || obj == -1) {
-							d = this._parse_json(s.data);
-							if(d) {
-								this.get_container().children("ul").empty().append(d.children());
-								this.clean_node();
-							}
-							else { 
-								if(s.correct_state) { this.get_container().children("ul").empty(); }
-							}
-						}
-						if(s_call) { s_call.call(this); }
-						break;
-					case (!s.data && !!s.ajax) || (!!s.data && !!s.ajax && obj && obj !== -1):
-						error_func = function (x, t, e) {
-							var ef = this.get_settings().json_data.ajax.error; 
-							if(ef) { ef.call(this, x, t, e); }
-							if(obj != -1 && obj.length) {
-								obj.children(".jstree-loading").removeClass("jstree-loading");
-								obj.data("jstree-is-loading",false);
-								if(t === "success" && s.correct_state) { obj.removeClass("jstree-open jstree-closed").addClass("jstree-leaf"); }
-							}
-							else {
-								if(t === "success" && s.correct_state) { this.get_container().children("ul").empty(); }
-							}
-							if(e_call) { e_call.call(this); }
-						};
-						success_func = function (d, t, x) {
-							var sf = this.get_settings().json_data.ajax.success; 
-							if(sf) { d = sf.call(this,d,t,x) || d; }
-							if(d === "" || (!$.isArray(d) && !$.isPlainObject(d))) {
-								return error_func.call(this, x, t, "");
-							}
-							d = this._parse_json(d);
-							if(d) {
-								if(obj === -1 || !obj) { this.get_container().children("ul").empty().append(d.children()); }
-								else { obj.append(d).children(".jstree-loading").removeClass("jstree-loading"); obj.data("jstree-is-loading",false); }
-								this.clean_node(obj);
-								if(s_call) { s_call.call(this); }
-							}
-							else {
-								if(obj === -1 || !obj) {
-									if(s.correct_state) { 
-										this.get_container().children("ul").empty(); 
-										if(s_call) { s_call.call(this); }
-									}
-								}
-								else {
-									obj.children(".jstree-loading").removeClass("jstree-loading");
-									obj.data("jstree-is-loading",false);
-									if(s.correct_state) { 
-										obj.removeClass("jstree-open jstree-closed").addClass("jstree-leaf"); 
-										if(s_call) { s_call.call(this); } 
-									}
-								}
-							}
-						};
-						s.ajax.context = this;
-						s.ajax.error = error_func;
-						s.ajax.success = success_func;
-						if(!s.ajax.dataType) { s.ajax.dataType = "json"; }
-						if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, obj); }
-						if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, obj); }
-						$.ajax(s.ajax);
-						break;
-				}
-			},
-			_parse_json : function (js, is_callback) {
-				var d = false, 
-					p = this._get_settings(),
-					s = p.json_data,
-					t = p.core.html_titles,
-					tmp, i, j, ul1, ul2;
-
-				if(!js) { return d; }
-				if($.isFunction(js)) { 
-					js = js.call(this);
-				}
-				if($.isArray(js)) {
-					d = $();
-					if(!js.length) { return false; }
-					for(i = 0, j = js.length; i < j; i++) {
-						tmp = this._parse_json(js[i], true);
-						if(tmp.length) { d = d.add(tmp); }
-					}
-				}
-				else {
-					if(typeof js == "string") { js = { data : js }; }
-					if(!js.data && js.data !== "") { return d; }
-					d = $("<li>");
-					if(js.attr) { d.attr(js.attr); }
-					if(js.metadata) { d.data("jstree", js.metadata); }
-					if(js.state) { d.addClass("jstree-" + js.state); }
-					if(!$.isArray(js.data)) { tmp = js.data; js.data = []; js.data.push(tmp); }
-					$.each(js.data, function (i, m) {
-						tmp = $("<a>");
-						if($.isFunction(m)) { m = m.call(this, js); }
-						if(typeof m == "string") { tmp.attr('href','#')[ t ? "html" : "text" ](m); }
-						else {
-							if(!m.attr) { m.attr = {}; }
-							if(!m.attr.href) { m.attr.href = '#'; }
-							tmp.attr(m.attr)[ t ? "html" : "text" ](m.title);
-							if(m.language) { tmp.addClass(m.language); }
-						}
-						tmp.prepend("<ins class='jstree-icon'>&#160;</ins>");
-						if(!m.icon && js.icon) { m.icon = js.icon; }
-						if(m.icon) { 
-							if(m.icon.indexOf("/") === -1) { tmp.children("ins").addClass(m.icon); }
-							else { tmp.children("ins").css("background","url('" + m.icon + "') center center no-repeat"); }
-						}
-						d.append(tmp);
-					});
-					d.prepend("<ins class='jstree-icon'>&#160;</ins>");
-					if(js.children) { 
-						if(s.progressive_render && js.state !== "open") {
-							d.addClass("jstree-closed").data("jstree-children", js.children);
-						}
-						else {
-							if($.isFunction(js.children)) {
-								js.children = js.children.call(this, js);
-							}
-							if($.isArray(js.children) && js.children.length) {
-								tmp = this._parse_json(js.children, true);
-								if(tmp.length) {
-									ul2 = $("<ul>");
-									ul2.append(tmp);
-									d.append(ul2);
-								}
-							}
-						}
-					}
-				}
-				if(!is_callback) {
-					ul1 = $("<ul>");
-					ul1.append(d);
-					d = ul1;
-				}
-				return d;
-			},
-			get_json : function (obj, li_attr, a_attr, is_callback) {
-				var result = [], 
-					s = this._get_settings(), 
-					_this = this,
-					tmp1, tmp2, li, a, t, lang;
-				obj = this._get_node(obj);
-				if(!obj || obj === -1) { obj = this.get_container().find("> ul > li"); }
-				li_attr = $.isArray(li_attr) ? li_attr : [ "id", "class" ];
-				if(!is_callback && this.data.types) { li_attr.push(s.types.type_attr); }
-				a_attr = $.isArray(a_attr) ? a_attr : [ ];
-
-				obj.each(function () {
-					li = $(this);
-					tmp1 = { data : [] };
-					if(li_attr.length) { tmp1.attr = { }; }
-					$.each(li_attr, function (i, v) { 
-						tmp2 = li.attr(v); 
-						if(tmp2 && tmp2.length && tmp2.replace(/jstree[^ ]*|$/ig,'').length) {
-							tmp1.attr[v] = tmp2.replace(/jstree[^ ]*|$/ig,''); 
-						}
-					});
-					if(li.hasClass("jstree-open")) { tmp1.state = "open"; }
-					if(li.hasClass("jstree-closed")) { tmp1.state = "closed"; }
-					a = li.children("a");
-					a.each(function () {
-						t = $(this);
-						if(
-							a_attr.length || 
-							$.inArray("languages", s.plugins) !== -1 || 
-							t.children("ins").get(0).style.backgroundImage.length || 
-							(t.children("ins").get(0).className && t.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').length)
-						) { 
-							lang = false;
-							if($.inArray("languages", s.plugins) !== -1 && $.isArray(s.languages) && s.languages.length) {
-								$.each(s.languages, function (l, lv) {
-									if(t.hasClass(lv)) {
-										lang = lv;
-										return false;
-									}
-								});
-							}
-							tmp2 = { attr : { }, title : _this.get_text(t, lang) }; 
-							$.each(a_attr, function (k, z) {
-								tmp1.attr[z] = (t.attr(z) || "").replace(/jstree[^ ]*|$/ig,'');
-							});
-							$.each(s.languages, function (k, z) {
-								if(t.hasClass(z)) { tmp2.language = z; return true; }
-							});
-							if(t.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').replace(/^\s+$/ig,"").length) {
-								tmp2.icon = t.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').replace(/^\s+$/ig,"");
-							}
-							if(t.children("ins").get(0).style.backgroundImage.length) {
-								tmp2.icon = t.children("ins").get(0).style.backgroundImage.replace("url(","").replace(")","");
-							}
-						}
-						else {
-							tmp2 = _this.get_text(t);
-						}
-						if(a.length > 1) { tmp1.data.push(tmp2); }
-						else { tmp1.data = tmp2; }
-					});
-					li = li.find("> ul > li");
-					if(li.length) { tmp1.children = _this.get_json(li, li_attr, a_attr, true); }
-					result.push(tmp1);
-				});
-				return result;
-			}
-		}
-	});
+  $.jstree.plugin("json_data", {
+    defaults : { 
+      data : false,
+      ajax : false,
+      correct_state : true,
+      progressive_render : false
+    },
+    _fn : {
+      load_node : function (obj, s_call, e_call) { var _this = this; this.load_node_json(obj, function () { _this.__callback({ "obj" : obj }); s_call.call(this); }, e_call); },
+      _is_loaded : function (obj) { 
+        var s = this._get_settings().json_data, d;
+        obj = this._get_node(obj); 
+        if(obj && obj !== -1 && s.progressive_render && !obj.is(".jstree-open, .jstree-leaf") && obj.children("ul").children("li").length === 0 && obj.data("jstree-children")) {
+          d = this._parse_json(obj.data("jstree-children"));
+          if(d) {
+            obj.append(d);
+            $.removeData(obj, "jstree-children");
+          }
+          this.clean_node(obj);
+          return true;
+        }
+        return obj == -1 || !obj || !s.ajax || obj.is(".jstree-open, .jstree-leaf") || obj.children("ul").children("li").size() > 0;
+      },
+      load_node_json : function (obj, s_call, e_call) {
+        var s = this.get_settings().json_data, d,
+          error_func = function () {},
+          success_func = function () {};
+        obj = this._get_node(obj);
+        if(obj && obj !== -1) {
+          if(obj.data("jstree-is-loading")) { return; }
+          else { obj.data("jstree-is-loading",true); }
+        }
+        switch(!0) {
+          case (!s.data && !s.ajax): throw "Neither data nor ajax settings supplied.";
+          case (!!s.data && !s.ajax) || (!!s.data && !!s.ajax && (!obj || obj === -1)):
+            if(!obj || obj == -1) {
+              d = this._parse_json(s.data);
+              if(d) {
+                this.get_container().children("ul").empty().append(d.children());
+                this.clean_node();
+              }
+              else { 
+                if(s.correct_state) { this.get_container().children("ul").empty(); }
+              }
+            }
+            if(s_call) { s_call.call(this); }
+            break;
+          case (!s.data && !!s.ajax) || (!!s.data && !!s.ajax && obj && obj !== -1):
+            error_func = function (x, t, e) {
+              var ef = this.get_settings().json_data.ajax.error; 
+              if(ef) { ef.call(this, x, t, e); }
+              if(obj != -1 && obj.length) {
+                obj.children(".jstree-loading").removeClass("jstree-loading");
+                obj.data("jstree-is-loading",false);
+                if(t === "success" && s.correct_state) { obj.removeClass("jstree-open jstree-closed").addClass("jstree-leaf"); }
+              }
+              else {
+                if(t === "success" && s.correct_state) { this.get_container().children("ul").empty(); }
+              }
+              if(e_call) { e_call.call(this); }
+            };
+            success_func = function (d, t, x) {
+              var sf = this.get_settings().json_data.ajax.success; 
+              if(sf) { d = sf.call(this,d,t,x) || d; }
+              if(d === "" || (!$.isArray(d) && !$.isPlainObject(d))) {
+                return error_func.call(this, x, t, "");
+              }
+              d = this._parse_json(d);
+              if(d) {
+                if(obj === -1 || !obj) { this.get_container().children("ul").empty().append(d.children()); }
+                else { obj.append(d).children(".jstree-loading").removeClass("jstree-loading"); obj.data("jstree-is-loading",false); }
+                this.clean_node(obj);
+                if(s_call) { s_call.call(this); }
+              }
+              else {
+                if(obj === -1 || !obj) {
+                  if(s.correct_state) { 
+                    this.get_container().children("ul").empty(); 
+                    if(s_call) { s_call.call(this); }
+                  }
+                }
+                else {
+                  obj.children(".jstree-loading").removeClass("jstree-loading");
+                  obj.data("jstree-is-loading",false);
+                  if(s.correct_state) { 
+                    obj.removeClass("jstree-open jstree-closed").addClass("jstree-leaf"); 
+                    if(s_call) { s_call.call(this); } 
+                  }
+                }
+              }
+            };
+            s.ajax.context = this;
+            s.ajax.error = error_func;
+            s.ajax.success = success_func;
+            if(!s.ajax.dataType) { s.ajax.dataType = "json"; }
+            if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, obj); }
+            if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, obj); }
+            $.ajax(s.ajax);
+            break;
+        }
+      },
+      _parse_json : function (js, is_callback) {
+        var d = false, 
+          p = this._get_settings(),
+          s = p.json_data,
+          t = p.core.html_titles,
+          tmp, i, j, ul1, ul2;
+
+        if(!js) { return d; }
+        if($.isFunction(js)) { 
+          js = js.call(this);
+        }
+        if($.isArray(js)) {
+          d = $();
+          if(!js.length) { return false; }
+          for(i = 0, j = js.length; i < j; i++) {
+            tmp = this._parse_json(js[i], true);
+            if(tmp.length) { d = d.add(tmp); }
+          }
+        }
+        else {
+          if(typeof js == "string") { js = { data : js }; }
+          if(!js.data && js.data !== "") { return d; }
+          d = $("<li>");
+          if(js.attr) { d.attr(js.attr); }
+          if(js.metadata) { d.data("jstree", js.metadata); }
+          if(js.state) { d.addClass("jstree-" + js.state); }
+          if(!$.isArray(js.data)) { tmp = js.data; js.data = []; js.data.push(tmp); }
+          $.each(js.data, function (i, m) {
+            tmp = $("<a>");
+            if($.isFunction(m)) { m = m.call(this, js); }
+            if(typeof m == "string") { tmp.attr('href','#')[ t ? "html" : "text" ](m); }
+            else {
+              if(!m.attr) { m.attr = {}; }
+              if(!m.attr.href) { m.attr.href = '#'; }
+              tmp.attr(m.attr)[ t ? "html" : "text" ](m.title);
+              if(m.language) { tmp.addClass(m.language); }
+            }
+            tmp.prepend("<ins class='jstree-icon'>&#160;</ins>");
+            if(!m.icon && js.icon) { m.icon = js.icon; }
+            if(m.icon) { 
+              if(m.icon.indexOf("/") === -1) { tmp.children("ins").addClass(m.icon); }
+              else { tmp.children("ins").css("background","url('" + m.icon + "') center center no-repeat"); }
+            }
+            d.append(tmp);
+          });
+          d.prepend("<ins class='jstree-icon'>&#160;</ins>");
+          if(js.children) { 
+            if(s.progressive_render && js.state !== "open") {
+              d.addClass("jstree-closed").data("jstree-children", js.children);
+            }
+            else {
+              if($.isFunction(js.children)) {
+                js.children = js.children.call(this, js);
+              }
+              if($.isArray(js.children) && js.children.length) {
+                tmp = this._parse_json(js.children, true);
+                if(tmp.length) {
+                  ul2 = $("<ul>");
+                  ul2.append(tmp);
+                  d.append(ul2);
+                }
+              }
+            }
+          }
+        }
+        if(!is_callback) {
+          ul1 = $("<ul>");
+          ul1.append(d);
+          d = ul1;
+        }
+        return d;
+      },
+      get_json : function (obj, li_attr, a_attr, is_callback) {
+        var result = [], 
+          s = this._get_settings(), 
+          _this = this,
+          tmp1, tmp2, li, a, t, lang;
+        obj = this._get_node(obj);
+        if(!obj || obj === -1) { obj = this.get_container().find("> ul > li"); }
+        li_attr = $.isArray(li_attr) ? li_attr : [ "id", "class" ];
+        if(!is_callback && this.data.types) { li_attr.push(s.types.type_attr); }
+        a_attr = $.isArray(a_attr) ? a_attr : [ ];
+
+        obj.each(function () {
+          li = $(this);
+          tmp1 = { data : [] };
+          if(li_attr.length) { tmp1.attr = { }; }
+          $.each(li_attr, function (i, v) { 
+            tmp2 = li.attr(v); 
+            if(tmp2 && tmp2.length && tmp2.replace(/jstree[^ ]*|$/ig,'').length) {
+              tmp1.attr[v] = tmp2.replace(/jstree[^ ]*|$/ig,''); 
+            }
+          });
+          if(li.hasClass("jstree-open")) { tmp1.state = "open"; }
+          if(li.hasClass("jstree-closed")) { tmp1.state = "closed"; }
+          a = li.children("a");
+          a.each(function () {
+            t = $(this);
+            if(
+              a_attr.length || 
+              $.inArray("languages", s.plugins) !== -1 || 
+              t.children("ins").get(0).style.backgroundImage.length || 
+              (t.children("ins").get(0).className && t.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').length)
+            ) { 
+              lang = false;
+              if($.inArray("languages", s.plugins) !== -1 && $.isArray(s.languages) && s.languages.length) {
+                $.each(s.languages, function (l, lv) {
+                  if(t.hasClass(lv)) {
+                    lang = lv;
+                    return false;
+                  }
+                });
+              }
+              tmp2 = { attr : { }, title : _this.get_text(t, lang) }; 
+              $.each(a_attr, function (k, z) {
+                tmp1.attr[z] = (t.attr(z) || "").replace(/jstree[^ ]*|$/ig,'');
+              });
+              $.each(s.languages, function (k, z) {
+                if(t.hasClass(z)) { tmp2.language = z; return true; }
+              });
+              if(t.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').replace(/^\s+$/ig,"").length) {
+                tmp2.icon = t.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').replace(/^\s+$/ig,"");
+              }
+              if(t.children("ins").get(0).style.backgroundImage.length) {
+                tmp2.icon = t.children("ins").get(0).style.backgroundImage.replace("url(","").replace(")","");
+              }
+            }
+            else {
+              tmp2 = _this.get_text(t);
+            }
+            if(a.length > 1) { tmp1.data.push(tmp2); }
+            else { tmp1.data = tmp2; }
+          });
+          li = li.find("> ul > li");
+          if(li.length) { tmp1.children = _this.get_json(li, li_attr, a_attr, true); }
+          result.push(tmp1);
+        });
+        return result;
+      }
+    }
+  });
 })(jQuery);
 //*/
 
@@ -1602,108 +1602,108 @@ THE SOFTWARE.
  * This is useful for maintaining the same structure in many languages (hence the name of the plugin)
  */
 (function ($) {
-	$.jstree.plugin("languages", {
-		__init : function () { this._load_css();  },
-		defaults : [],
-		_fn : {
-			set_lang : function (i) { 
-				var langs = this._get_settings().languages,
-					st = false,
-					selector = ".jstree-" + this.get_index() + ' a';
-				if(!$.isArray(langs) || langs.length === 0) { return false; }
-				if($.inArray(i,langs) == -1) {
-					if(!!langs[i]) { i = langs[i]; }
-					else { return false; }
-				}
-				if(i == this.data.languages.current_language) { return true; }
-				st = $.vakata.css.get_css(selector + "." + this.data.languages.current_language, false, this.data.languages.language_css);
-				if(st !== false) { st.style.display = "none"; }
-				st = $.vakata.css.get_css(selector + "." + i, false, this.data.languages.language_css);
-				if(st !== false) { st.style.display = ""; }
-				this.data.languages.current_language = i;
-				this.__callback(i);
-				return true;
-			},
-			get_lang : function () {
-				return this.data.languages.current_language;
-			},
-			get_text : function (obj, lang) {
-				obj = this._get_node(obj) || this.data.ui.last_selected;
-				if(!obj.size()) { return false; }
-				var langs = this._get_settings().languages,
-					s = this._get_settings().core.html_titles;
-				if($.isArray(langs) && langs.length) {
-					lang = (lang && $.inArray(lang,langs) != -1) ? lang : this.data.languages.current_language;
-					obj = obj.children("a." + lang);
-				}
-				else { obj = obj.children("a:eq(0)"); }
-				if(s) {
-					obj = obj.clone();
-					obj.children("INS").remove();
-					return obj.html();
-				}
-				else {
-					obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];
-					return obj.nodeValue;
-				}
-			},
-			set_text : function (obj, val, lang) {
-				obj = this._get_node(obj) || this.data.ui.last_selected;
-				if(!obj.size()) { return false; }
-				var langs = this._get_settings().languages,
-					s = this._get_settings().core.html_titles,
-					tmp;
-				if($.isArray(langs) && langs.length) {
-					lang = (lang && $.inArray(lang,langs) != -1) ? lang : this.data.languages.current_language;
-					obj = obj.children("a." + lang);
-				}
-				else { obj = obj.children("a:eq(0)"); }
-				if(s) {
-					tmp = obj.children("INS").clone();
-					obj.html(val).prepend(tmp);
-					this.__callback({ "obj" : obj, "name" : val, "lang" : lang });
-					return true;
-				}
-				else {
-					obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];
-					this.__callback({ "obj" : obj, "name" : val, "lang" : lang });
-					return (obj.nodeValue = val);
-				}
-			},
-			_load_css : function () {
-				var langs = this._get_settings().languages,
-					str = "/* languages css */",
-					selector = ".jstree-" + this.get_index() + ' a',
-					ln;
-				if($.isArray(langs) && langs.length) {
-					this.data.languages.current_language = langs[0];
-					for(ln = 0; ln < langs.length; ln++) {
-						str += selector + "." + langs[ln] + " {";
-						if(langs[ln] != this.data.languages.current_language) { str += " display:none; "; }
-						str += " } ";
-					}
-					this.data.languages.language_css = $.vakata.css.add_sheet({ 'str' : str });
-				}
-			},
-			create_node : function (obj, position, js, callback) {
-				var t = this.__call_old(true, obj, position, js, function (t) {
-					var langs = this._get_settings().languages,
-						a = t.children("a"),
-						ln;
-					if($.isArray(langs) && langs.length) {
-						for(ln = 0; ln < langs.length; ln++) {
-							if(!a.is("." + langs[ln])) {
-								t.append(a.eq(0).clone().removeClass(langs.join(" ")).addClass(langs[ln]));
-							}
-						}
-						a.not("." + langs.join(", .")).remove();
-					}
-					if(callback) { callback.call(this, t); }
-				});
-				return t;
-			}
-		}
-	});
+  $.jstree.plugin("languages", {
+    __init : function () { this._load_css();  },
+    defaults : [],
+    _fn : {
+      set_lang : function (i) { 
+        var langs = this._get_settings().languages,
+          st = false,
+          selector = ".jstree-" + this.get_index() + ' a';
+        if(!$.isArray(langs) || langs.length === 0) { return false; }
+        if($.inArray(i,langs) == -1) {
+          if(!!langs[i]) { i = langs[i]; }
+          else { return false; }
+        }
+        if(i == this.data.languages.current_language) { return true; }
+        st = $.vakata.css.get_css(selector + "." + this.data.languages.current_language, false, this.data.languages.language_css);
+        if(st !== false) { st.style.display = "none"; }
+        st = $.vakata.css.get_css(selector + "." + i, false, this.data.languages.language_css);
+        if(st !== false) { st.style.display = ""; }
+        this.data.languages.current_language = i;
+        this.__callback(i);
+        return true;
+      },
+      get_lang : function () {
+        return this.data.languages.current_language;
+      },
+      get_text : function (obj, lang) {
+        obj = this._get_node(obj) || this.data.ui.last_selected;
+        if(!obj.size()) { return false; }
+        var langs = this._get_settings().languages,
+          s = this._get_settings().core.html_titles;
+        if($.isArray(langs) && langs.length) {
+          lang = (lang && $.inArray(lang,langs) != -1) ? lang : this.data.languages.current_language;
+          obj = obj.children("a." + lang);
+        }
+        else { obj = obj.children("a:eq(0)"); }
+        if(s) {
+          obj = obj.clone();
+          obj.children("INS").remove();
+          return obj.html();
+        }
+        else {
+          obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];
+          return obj.nodeValue;
+        }
+      },
+      set_text : function (obj, val, lang) {
+        obj = this._get_node(obj) || this.data.ui.last_selected;
+        if(!obj.size()) { return false; }
+        var langs = this._get_settings().languages,
+          s = this._get_settings().core.html_titles,
+          tmp;
+        if($.isArray(langs) && langs.length) {
+          lang = (lang && $.inArray(lang,langs) != -1) ? lang : this.data.languages.current_language;
+          obj = obj.children("a." + lang);
+        }
+        else { obj = obj.children("a:eq(0)"); }
+        if(s) {
+          tmp = obj.children("INS").clone();
+          obj.html(val).prepend(tmp);
+          this.__callback({ "obj" : obj, "name" : val, "lang" : lang });
+          return true;
+        }
+        else {
+          obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];
+          this.__callback({ "obj" : obj, "name" : val, "lang" : lang });
+          return (obj.nodeValue = val);
+        }
+      },
+      _load_css : function () {
+        var langs = this._get_settings().languages,
+          str = "/* languages css */",
+          selector = ".jstree-" + this.get_index() + ' a',
+          ln;
+        if($.isArray(langs) && langs.length) {
+          this.data.languages.current_language = langs[0];
+          for(ln = 0; ln < langs.length; ln++) {
+            str += selector + "." + langs[ln] + " {";
+            if(langs[ln] != this.data.languages.current_language) { str += " display:none; "; }
+            str += " } ";
+          }
+          this.data.languages.language_css = $.vakata.css.add_sheet({ 'str' : str });
+        }
+      },
+      create_node : function (obj, position, js, callback) {
+        var t = this.__call_old(true, obj, position, js, function (t) {
+          var langs = this._get_settings().languages,
+            a = t.children("a"),
+            ln;
+          if($.isArray(langs) && langs.length) {
+            for(ln = 0; ln < langs.length; ln++) {
+              if(!a.is("." + langs[ln])) {
+                t.append(a.eq(0).clone().removeClass(langs.join(" ")).addClass(langs[ln]));
+              }
+            }
+            a.not("." + langs.join(", .")).remove();
+          }
+          if(callback) { callback.call(this, t); }
+        });
+        return t;
+      }
+    }
+  });
 })(jQuery);
 //*/
 
@@ -1713,70 +1713,70 @@ THE SOFTWARE.
  * Depends on the jquery.cookie plugin
  */
 (function ($) {
-	$.jstree.plugin("cookies", {
-		__init : function () {
-			if(typeof $.cookie === "undefined") { throw "jsTree cookie: jQuery cookie plugin not included."; }
-
-			var s = this._get_settings().cookies,
-				tmp;
-			if(!!s.save_opened) {
-				tmp = $.cookie(s.save_opened);
-				if(tmp && tmp.length) { this.data.core.to_open = tmp.split(","); }
-			}
-			if(!!s.save_selected) {
-				tmp = $.cookie(s.save_selected);
-				if(tmp && tmp.length && this.data.ui) { this.data.ui.to_select = tmp.split(","); }
-			}
-			this.get_container()
-				.one( ( this.data.ui ? "reselect" : "reopen" ) + ".jstree", $.proxy(function () {
-					this.get_container()
-						.bind("open_node.jstree close_node.jstree select_node.jstree deselect_node.jstree", $.proxy(function (e) { 
-								if(this._get_settings().cookies.auto_save) { this.save_cookie((e.handleObj.namespace + e.handleObj.type).replace("jstree","")); }
-							}, this));
-				}, this));
-		},
-		defaults : {
-			save_opened		: "jstree_open",
-			save_selected	: "jstree_select",
-			auto_save		: true,
-			cookie_options	: {}
-		},
-		_fn : {
-			save_cookie : function (c) {
-				if(this.data.core.refreshing) { return; }
-				var s = this._get_settings().cookies;
-				if(!c) { // if called manually and not by event
-					if(s.save_opened) {
-						this.save_opened();
-						$.cookie(s.save_opened, this.data.core.to_open.join(","), s.cookie_options);
-					}
-					if(s.save_selected && this.data.ui) {
-						this.save_selected();
-						$.cookie(s.save_selected, this.data.ui.to_select.join(","), s.cookie_options);
-					}
-					return;
-				}
-				switch(c) {
-					case "open_node":
-					case "close_node":
-						if(!!s.save_opened) { 
-							this.save_opened(); 
-							$.cookie(s.save_opened, this.data.core.to_open.join(","), s.cookie_options); 
-						}
-						break;
-					case "select_node":
-					case "deselect_node":
-						if(!!s.save_selected && this.data.ui) { 
-							this.save_selected(); 
-							$.cookie(s.save_selected, this.data.ui.to_select.join(","), s.cookie_options); 
-						}
-						break;
-				}
-			}
-		}
-	});
-	// include cookies by default
-	$.jstree.defaults.plugins.push("cookies");
+  $.jstree.plugin("cookies", {
+    __init : function () {
+      if(typeof $.cookie === "undefined") { throw "jsTree cookie: jQuery cookie plugin not included."; }
+
+      var s = this._get_settings().cookies,
+        tmp;
+      if(!!s.save_opened) {
+        tmp = $.cookie(s.save_opened);
+        if(tmp && tmp.length) { this.data.core.to_open = tmp.split(","); }
+      }
+      if(!!s.save_selected) {
+        tmp = $.cookie(s.save_selected);
+        if(tmp && tmp.length && this.data.ui) { this.data.ui.to_select = tmp.split(","); }
+      }
+      this.get_container()
+        .one( ( this.data.ui ? "reselect" : "reopen" ) + ".jstree", $.proxy(function () {
+          this.get_container()
+            .bind("open_node.jstree close_node.jstree select_node.jstree deselect_node.jstree", $.proxy(function (e) { 
+                if(this._get_settings().cookies.auto_save) { this.save_cookie((e.handleObj.namespace + e.handleObj.type).replace("jstree","")); }
+              }, this));
+        }, this));
+    },
+    defaults : {
+      save_opened    : "jstree_open",
+      save_selected  : "jstree_select",
+      auto_save    : true,
+      cookie_options  : {}
+    },
+    _fn : {
+      save_cookie : function (c) {
+        if(this.data.core.refreshing) { return; }
+        var s = this._get_settings().cookies;
+        if(!c) { // if called manually and not by event
+          if(s.save_opened) {
+            this.save_opened();
+            $.cookie(s.save_opened, this.data.core.to_open.join(","), s.cookie_options);
+          }
+          if(s.save_selected && this.data.ui) {
+            this.save_selected();
+            $.cookie(s.save_selected, this.data.ui.to_select.join(","), s.cookie_options);
+          }
+          return;
+        }
+        switch(c) {
+          case "open_node":
+          case "close_node":
+            if(!!s.save_opened) { 
+              this.save_opened(); 
+              $.cookie(s.save_opened, this.data.core.to_open.join(","), s.cookie_options); 
+            }
+            break;
+          case "select_node":
+          case "deselect_node":
+            if(!!s.save_selected && this.data.ui) { 
+              this.save_selected(); 
+              $.cookie(s.save_selected, this.data.ui.to_select.join(","), s.cookie_options); 
+            }
+            break;
+        }
+      }
+    }
+  });
+  // include cookies by default
+  $.jstree.defaults.plugins.push("cookies");
 })(jQuery);
 //*/
 
@@ -1785,33 +1785,33 @@ THE SOFTWARE.
  * Sorts items alphabetically (or using any other function)
  */
 (function ($) {
-	$.jstree.plugin("sort", {
-		__init : function () {
-			this.get_container()
-				.bind("load_node.jstree", $.proxy(function (e, data) {
-						var obj = this._get_node(data.rslt.obj);
-						obj = obj === -1 ? this.get_container().children("ul") : obj.children("ul");
-						this.sort(obj);
-					}, this))
-				.bind("rename_node.jstree", $.proxy(function (e, data) {
-						this.sort(data.rslt.obj.parent());
-					}, this))
-				.bind("move_node.jstree", $.proxy(function (e, data) {
-						var m = data.rslt.np == -1 ? this.get_container() : data.rslt.np;
-						this.sort(m.children("ul"));
-					}, this));
-		},
-		defaults : function (a, b) { return this.get_text(a) > this.get_text(b) ? 1 : -1; },
-		_fn : {
-			sort : function (obj) {
-				var s = this._get_settings().sort,
-					t = this;
-				obj.append($.makeArray(obj.children("li")).sort($.proxy(s, t)));
-				obj.find("> li > ul").each(function() { t.sort($(this)); });
-				this.clean_node(obj);
-			}
-		}
-	});
+  $.jstree.plugin("sort", {
+    __init : function () {
+      this.get_container()
+        .bind("load_node.jstree", $.proxy(function (e, data) {
+            var obj = this._get_node(data.rslt.obj);
+            obj = obj === -1 ? this.get_container().children("ul") : obj.children("ul");
+            this.sort(obj);
+          }, this))
+        .bind("rename_node.jstree", $.proxy(function (e, data) {
+            this.sort(data.rslt.obj.parent());
+          }, this))
+        .bind("move_node.jstree", $.proxy(function (e, data) {
+            var m = data.rslt.np == -1 ? this.get_container() : data.rslt.np;
+            this.sort(m.children("ul"));
+          }, this));
+    },
+    defaults : function (a, b) { return this.get_text(a) > this.get_text(b) ? 1 : -1; },
+    _fn : {
+      sort : function (obj) {
+        var s = this._get_settings().sort,
+          t = this;
+        obj.append($.makeArray(obj.children("li")).sort($.proxy(s, t)));
+        obj.find("> li > ul").each(function() { t.sort($(this)); });
+        this.clean_node(obj);
+      }
+    }
+  });
 })(jQuery);
 //*/
 
@@ -1820,425 +1820,425 @@ THE SOFTWARE.
  * Drag and drop plugin for moving/copying nodes
  */
 (function ($) {
-	var o = false,
-		r = false,
-		m = false,
-		sli = false,
-		sti = false,
-		dir1 = false,
-		dir2 = false;
-	$.vakata.dnd = {
-		is_down : false,
-		is_drag : false,
-		helper : false,
-		scroll_spd : 10,
-		init_x : 0,
-		init_y : 0,
-		threshold : 5,
-		user_data : {},
-
-		drag_start : function (e, data, html) { 
-			if($.vakata.dnd.is_drag) { $.vakata.drag_stop({}); }
-			try {
-				e.currentTarget.unselectable = "on";
-				e.currentTarget.onselectstart = function() { return false; };
-				if(e.currentTarget.style) { e.currentTarget.style.MozUserSelect = "none"; }
-			} catch(err) { }
-			$.vakata.dnd.init_x = e.pageX;
-			$.vakata.dnd.init_y = e.pageY;
-			$.vakata.dnd.user_data = data;
-			$.vakata.dnd.is_down = true;
-			$.vakata.dnd.helper = $("<div id='vakata-dragged'>").html(html).css("opacity", "0.75");
-			$(document).bind("mousemove", $.vakata.dnd.drag);
-			$(document).bind("mouseup", $.vakata.dnd.drag_stop);
-			return false;
-		},
-		drag : function (e) { 
-			if(!$.vakata.dnd.is_down) { return; }
-			if(!$.vakata.dnd.is_drag) {
-				if(Math.abs(e.pageX - $.vakata.dnd.init_x) > 5 || Math.abs(e.pageY - $.vakata.dnd.init_y) > 5) { 
-					$.vakata.dnd.helper.appendTo("body");
-					$.vakata.dnd.is_drag = true;
-					$(document).triggerHandler("drag_start.vakata", { "event" : e, "data" : $.vakata.dnd.user_data });
-				}
-				else { return; }
-			}
-
-			// maybe use a scrolling parent element instead of document?
-			if(e.type === "mousemove") { // thought of adding scroll in order to move the helper, but mouse poisition is n/a
-				var d = $(document), t = d.scrollTop(), l = d.scrollLeft();
-				if(e.pageY - t < 20) { 
-					if(sti && dir1 === "down") { clearInterval(sti); sti = false; }
-					if(!sti) { dir1 = "up"; sti = setInterval(function () { $(document).scrollTop($(document).scrollTop() - $.vakata.dnd.scroll_spd); }, 150); }
-				}
-				else { 
-					if(sti && dir1 === "up") { clearInterval(sti); sti = false; }
-				}
-				if($(window).height() - (e.pageY - t) < 20) {
-					if(sti && dir1 === "up") { clearInterval(sti); sti = false; }
-					if(!sti) { dir1 = "down"; sti = setInterval(function () { $(document).scrollTop($(document).scrollTop() + $.vakata.dnd.scroll_spd); }, 150); }
-				}
-				else { 
-					if(sti && dir1 === "down") { clearInterval(sti); sti = false; }
-				}
-
-				if(e.pageX - l < 20) {
-					if(sli && dir2 === "right") { clearInterval(sli); sli = false; }
-					if(!sli) { dir2 = "left"; sli = setInterval(function () { $(document).scrollLeft($(document).scrollLeft() - $.vakata.dnd.scroll_spd); }, 150); }
-				}
-				else { 
-					if(sli && dir2 === "left") { clearInterval(sli); sli = false; }
-				}
-				if($(window).width() - (e.pageX - l) < 20) {
-					if(sli && dir2 === "left") { clearInterval(sli); sli = false; }
-					if(!sli) { dir2 = "right"; sli = setInterval(function () { $(document).scrollLeft($(document).scrollLeft() + $.vakata.dnd.scroll_spd); }, 150); }
-				}
-				else { 
-					if(sli && dir2 === "right") { clearInterval(sli); sli = false; }
-				}
-			}
-
-			$.vakata.dnd.helper.css({ left : (e.pageX + 5) + "px", top : (e.pageY + 10) + "px" });
-			$(document).triggerHandler("drag.vakata", { "event" : e, "data" : $.vakata.dnd.user_data });
-		},
-		drag_stop : function (e) {
-			$(document).unbind("mousemove", $.vakata.dnd.drag);
-			$(document).unbind("mouseup", $.vakata.dnd.drag_stop);
-			$(document).triggerHandler("drag_stop.vakata", { "event" : e, "data" : $.vakata.dnd.user_data });
-			$.vakata.dnd.helper.remove();
-			$.vakata.dnd.init_x = 0;
-			$.vakata.dnd.init_y = 0;
-			$.vakata.dnd.user_data = {};
-			$.vakata.dnd.is_down = false;
-			$.vakata.dnd.is_drag = false;
-		}
-	};
-	$(function() {
-		var css_string = '#vakata-dragged { display:block; margin:0 0 0 0; padding:4px 4px 4px 24px; position:absolute; top:-2000px; line-height:16px; z-index:10000; } ';
-		$.vakata.css.add_sheet({ str : css_string });
-	});
-
-	$.jstree.plugin("dnd", {
-		__init : function () {
-			this.data.dnd = {
-				active : false,
-				after : false,
-				inside : false,
-				before : false,
-				off : false,
-				prepared : false,
-				w : 0,
-				to1 : false,
-				to2 : false,
-				cof : false,
-				cw : false,
-				ch : false,
-				i1 : false,
-				i2 : false
-			};
-			this.get_container()
-				.bind("mouseenter.jstree", $.proxy(function () {
-						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree && this.data.themes) {
-							m.attr("class", "jstree-" + this.data.themes.theme); 
-							$.vakata.dnd.helper.attr("class", "jstree-dnd-helper jstree-" + this.data.themes.theme);
-						}
-					}, this))
-				.bind("mouseleave.jstree", $.proxy(function () {
-						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
-							if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
-							if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
-						}
-					}, this))
-				.bind("mousemove.jstree", $.proxy(function (e) {
-						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
-							var cnt = this.get_container()[0];
-
-							// Horizontal scroll
-							if(e.pageX + 24 > this.data.dnd.cof.left + this.data.dnd.cw) {
-								if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
-								this.data.dnd.i1 = setInterval($.proxy(function () { this.scrollLeft += $.vakata.dnd.scroll_spd; }, cnt), 100);
-							}
-							else if(e.pageX - 24 < this.data.dnd.cof.left) {
-								if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
-								this.data.dnd.i1 = setInterval($.proxy(function () { this.scrollLeft -= $.vakata.dnd.scroll_spd; }, cnt), 100);
-							}
-							else {
-								if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
-							}
-
-							// Vertical scroll
-							if(e.pageY + 24 > this.data.dnd.cof.top + this.data.dnd.ch) {
-								if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
-								this.data.dnd.i2 = setInterval($.proxy(function () { this.scrollTop += $.vakata.dnd.scroll_spd; }, cnt), 100);
-							}
-							else if(e.pageY - 24 < this.data.dnd.cof.top) {
-								if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
-								this.data.dnd.i2 = setInterval($.proxy(function () { this.scrollTop -= $.vakata.dnd.scroll_spd; }, cnt), 100);
-							}
-							else {
-								if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
-							}
-
-						}
-					}, this))
-				.delegate("a", "mousedown.jstree", $.proxy(function (e) { 
-						if(e.which === 1) {
-							this.start_drag(e.currentTarget, e);
-							return false;
-						}
-					}, this))
-				.delegate("a", "mouseenter.jstree", $.proxy(function (e) { 
-						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
-							this.dnd_enter(e.currentTarget);
-						}
-					}, this))
-				.delegate("a", "mousemove.jstree", $.proxy(function (e) { 
-						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
-							if(typeof this.data.dnd.off.top === "undefined") { this.data.dnd.off = $(e.target).offset(); }
-							this.data.dnd.w = (e.pageY - (this.data.dnd.off.top || 0)) % this.data.core.li_height;
-							if(this.data.dnd.w < 0) { this.data.dnd.w += this.data.core.li_height; }
-							this.dnd_show();
-						}
-					}, this))
-				.delegate("a", "mouseleave.jstree", $.proxy(function (e) { 
-						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
-							this.data.dnd.after		= false;
-							this.data.dnd.before	= false;
-							this.data.dnd.inside	= false;
-							$.vakata.dnd.helper.children("ins").attr("class","jstree-invalid");
-							m.hide();
-							if(r && r[0] === e.target.parentNode) {
-								if(this.data.dnd.to1) {
-									clearTimeout(this.data.dnd.to1);
-									this.data.dnd.to1 = false;
-								}
-								if(this.data.dnd.to2) {
-									clearTimeout(this.data.dnd.to2);
-									this.data.dnd.to2 = false;
-								}
-							}
-						}
-					}, this))
-				.delegate("a", "mouseup.jstree", $.proxy(function (e) { 
-						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
-							this.dnd_finish(e);
-						}
-					}, this));
-
-			$(document)
-				.bind("drag_stop.vakata", $.proxy(function () {
-						this.data.dnd.after		= false;
-						this.data.dnd.before	= false;
-						this.data.dnd.inside	= false;
-						this.data.dnd.off		= false;
-						this.data.dnd.prepared	= false;
-						this.data.dnd.w			= false;
-						this.data.dnd.to1		= false;
-						this.data.dnd.to2		= false;
-						this.data.dnd.active	= false;
-						this.data.dnd.foreign	= false;
-						if(m) { m.css({ "top" : "-2000px" }); }
-					}, this))
-				.bind("drag_start.vakata", $.proxy(function (e, data) {
-						if(data.data.jstree) { 
-							var et = $(data.event.target);
-							if(et.closest(".jstree").hasClass("jstree-" + this.get_index())) {
-								this.dnd_enter(et);
-							}
-						}
-					}, this));
-
-			var s = this._get_settings().dnd;
-			if(s.drag_target) {
-				$(document)
-					.delegate(s.drag_target, "mousedown.jstree", $.proxy(function (e) {
-						o = e.target;
-						$.vakata.dnd.drag_start(e, { jstree : true, obj : e.target }, "<ins class='jstree-icon'></ins>" + $(e.target).text() );
-						if(this.data.themes) { 
-							m.attr("class", "jstree-" + this.data.themes.theme); 
-							$.vakata.dnd.helper.attr("class", "jstree-dnd-helper jstree-" + this.data.themes.theme); 
-						}
-						$.vakata.dnd.helper.children("ins").attr("class","jstree-invalid");
-						var cnt = this.get_container();
-						this.data.dnd.cof = cnt.offset();
-						this.data.dnd.cw = parseInt(cnt.width(),10);
-						this.data.dnd.ch = parseInt(cnt.height(),10);
-						this.data.dnd.foreign = true;
-						return false;
-					}, this));
-			}
-			if(s.drop_target) {
-				$(document)
-					.delegate(s.drop_target, "mouseenter.jstree", $.proxy(function (e) {
-							if(this.data.dnd.active && this._get_settings().dnd.drop_check.call(this, { "o" : o, "r" : $(e.target) })) {
-								$.vakata.dnd.helper.children("ins").attr("class","jstree-ok");
-							}
-						}, this))
-					.delegate(s.drop_target, "mouseleave.jstree", $.proxy(function (e) {
-							if(this.data.dnd.active) {
-								$.vakata.dnd.helper.children("ins").attr("class","jstree-invalid");
-							}
-						}, this))
-					.delegate(s.drop_target, "mouseup.jstree", $.proxy(function (e) {
-							if(this.data.dnd.active && $.vakata.dnd.helper.children("ins").hasClass("jstree-ok")) {
-								this._get_settings().dnd.drop_finish.call(this, { "o" : o, "r" : $(e.target) });
-							}
-						}, this));
-			}
-		},
-		defaults : {
-			copy_modifier	: "ctrl",
-			check_timeout	: 200,
-			open_timeout	: 500,
-			drop_target		: ".jstree-drop",
-			drop_check		: function (data) { return true; },
-			drop_finish		: $.noop,
-			drag_target		: ".jstree-draggable",
-			drag_finish		: $.noop,
-			drag_check		: function (data) { return { after : false, before : false, inside : true }; }
-		},
-		_fn : {
-			dnd_prepare : function () {
-				if(!r || !r.length) { return; }
-				this.data.dnd.off = r.offset();
-				if(this._get_settings().core.rtl) {
-					this.data.dnd.off.right = this.data.dnd.off.left + r.width();
-				}
-				if(this.data.dnd.foreign) {
-					var a = this._get_settings().dnd.drag_check.call(this, { "o" : o, "r" : r });
-					this.data.dnd.after = a.after;
-					this.data.dnd.before = a.before;
-					this.data.dnd.inside = a.inside;
-					this.data.dnd.prepared = true;
-					return this.dnd_show();
-				}
-				this.prepare_move(o, r, "before");
-				this.data.dnd.before = this.check_move();
-				this.prepare_move(o, r, "after");
-				this.data.dnd.after = this.check_move();
-				if(this._is_loaded(r)) {
-					this.prepare_move(o, r, "inside");
-					this.data.dnd.inside = this.check_move();
-				}
-				else {
-					this.data.dnd.inside = false;
-				}
-				this.data.dnd.prepared = true;
-				return this.dnd_show();
-			},
-			dnd_show : function () {
-				if(!this.data.dnd.prepared) { return; }
-				var o = ["before","inside","after"],
-					r = false,
-					rtl = this._get_settings().core.rtl,
-					pos;
-				if(this.data.dnd.w < this.data.core.li_height/3) { o = ["before","inside","after"]; }
-				else if(this.data.dnd.w <= this.data.core.li_height*2/3) {
-					o = this.data.dnd.w < this.data.core.li_height/2 ? ["inside","before","after"] : ["inside","after","before"];
-				}
-				else { o = ["after","inside","before"]; }
-				$.each(o, $.proxy(function (i, val) { 
-					if(this.data.dnd[val]) {
-						$.vakata.dnd.helper.children("ins").attr("class","jstree-ok");
-						r = val;
-						return false;
-					}
-				}, this));
-				if(r === false) { $.vakata.dnd.helper.children("ins").attr("class","jstree-invalid"); }
-				
-				pos = rtl ? (this.data.dnd.off.right - 18) : (this.data.dnd.off.left + 10);
-				switch(r) {
-					case "before":
-						m.css({ "left" : pos + "px", "top" : (this.data.dnd.off.top - 6) + "px" }).show();
-						break;
-					case "after":
-						m.css({ "left" : pos + "px", "top" : (this.data.dnd.off.top + this.data.core.li_height - 7) + "px" }).show();
-						break;
-					case "inside":
-						m.css({ "left" : pos + ( rtl ? -4 : 4) + "px", "top" : (this.data.dnd.off.top + this.data.core.li_height/2 - 5) + "px" }).show();
-						break;
-					default:
-						m.hide();
-						break;
-				}
-				return r;
-			},
-			dnd_open : function () {
-				this.data.dnd.to2 = false;
-				this.open_node(r, $.proxy(this.dnd_prepare,this), true);
-			},
-			dnd_finish : function (e) {
-				if(this.data.dnd.foreign) {
-					if(this.data.dnd.after || this.data.dnd.before || this.data.dnd.inside) {
-						this._get_settings().dnd.drag_finish.call(this, { "o" : o, "r" : r });
-					}
-				}
-				else {
-					this.dnd_prepare();
-					this.move_node(o, r, this.dnd_show(), e[this._get_settings().dnd.copy_modifier + "Key"]);
-				}
-				o = false;
-				r = false;
-				m.hide();
-			},
-			dnd_enter : function (obj) {
-				var s = this._get_settings().dnd;
-				this.data.dnd.prepared = false;
-				r = this._get_node(obj);
-				if(s.check_timeout) { 
-					// do the calculations after a minimal timeout (users tend to drag quickly to the desired location)
-					if(this.data.dnd.to1) { clearTimeout(this.data.dnd.to1); }
-					this.data.dnd.to1 = setTimeout($.proxy(this.dnd_prepare, this), s.check_timeout); 
-				}
-				else { 
-					this.dnd_prepare(); 
-				}
-				if(s.open_timeout) { 
-					if(this.data.dnd.to2) { clearTimeout(this.data.dnd.to2); }
-					if(r && r.length && r.hasClass("jstree-closed")) { 
-						// if the node is closed - open it, then recalculate
-						this.data.dnd.to2 = setTimeout($.proxy(this.dnd_open, this), s.open_timeout);
-					}
-				}
-				else {
-					if(r && r.length && r.hasClass("jstree-closed")) { 
-						this.dnd_open();
-					}
-				}
-			},
-			start_drag : function (obj, e) {
-				o = this._get_node(obj);
-				if(this.data.ui && this.is_selected(o)) { o = this._get_node(null, true); }
-				$.vakata.dnd.drag_start(e, { jstree : true, obj : o }, "<ins class='jstree-icon'></ins>" + (o.length > 1 ? "Multiple selection" : this.get_text(o)) );
-				if(this.data.themes) { 
-					m.attr("class", "jstree-" + this.data.themes.theme); 
-					$.vakata.dnd.helper.attr("class", "jstree-dnd-helper jstree-" + this.data.themes.theme); 
-				}
-				var cnt = this.get_container();
-				this.data.dnd.cof = cnt.children("ul").offset();
-				this.data.dnd.cw = parseInt(cnt.width(),10);
-				this.data.dnd.ch = parseInt(cnt.height(),10);
-				this.data.dnd.active = true;
-			}
-		}
-	});
-	$(function() {
-		var css_string = '' + 
-			'#vakata-dragged ins { display:block; text-decoration:none; width:16px; height:16px; margin:0 0 0 0; padding:0; position:absolute; top:4px; left:4px; } ' + 
-			'#vakata-dragged .jstree-ok { background:green; } ' + 
-			'#vakata-dragged .jstree-invalid { background:red; } ' + 
-			'#jstree-marker { padding:0; margin:0; line-height:12px; font-size:1px; overflow:hidden; height:12px; width:8px; position:absolute; top:-30px; z-index:10000; background-repeat:no-repeat; display:none; background-color:silver; } ';
-		$.vakata.css.add_sheet({ str : css_string });
-		m = $("<div>").attr({ id : "jstree-marker" }).hide().appendTo("body");
-		$(document).bind("drag_start.vakata", function (e, data) {
-			if(data.data.jstree) { 
-				m.show(); 
-			}
-		});
-		$(document).bind("drag_stop.vakata", function (e, data) {
-			if(data.data.jstree) { m.hide(); }
-		});
-	});
+  var o = false,
+    r = false,
+    m = false,
+    sli = false,
+    sti = false,
+    dir1 = false,
+    dir2 = false;
+  $.vakata.dnd = {
+    is_down : false,
+    is_drag : false,
+    helper : false,
+    scroll_spd : 10,
+    init_x : 0,
+    init_y : 0,
+    threshold : 5,
+    user_data : {},
+
+    drag_start : function (e, data, html) { 
+      if($.vakata.dnd.is_drag) { $.vakata.drag_stop({}); }
+      try {
+        e.currentTarget.unselectable = "on";
+        e.currentTarget.onselectstart = function() { return false; };
+        if(e.currentTarget.style) { e.currentTarget.style.MozUserSelect = "none"; }
+      } catch(err) { }
+      $.vakata.dnd.init_x = e.pageX;
+      $.vakata.dnd.init_y = e.pageY;
+      $.vakata.dnd.user_data = data;
+      $.vakata.dnd.is_down = true;
+      $.vakata.dnd.helper = $("<div id='vakata-dragged'>").html(html).css("opacity", "0.75");
+      $(document).bind("mousemove", $.vakata.dnd.drag);
+      $(document).bind("mouseup", $.vakata.dnd.drag_stop);
+      return false;
+    },
+    drag : function (e) { 
+      if(!$.vakata.dnd.is_down) { return; }
+      if(!$.vakata.dnd.is_drag) {
+        if(Math.abs(e.pageX - $.vakata.dnd.init_x) > 5 || Math.abs(e.pageY - $.vakata.dnd.init_y) > 5) { 
+          $.vakata.dnd.helper.appendTo("body");
+          $.vakata.dnd.is_drag = true;
+          $(document).triggerHandler("drag_start.vakata", { "event" : e, "data" : $.vakata.dnd.user_data });
+        }
+        else { return; }
+      }
+
+      // maybe use a scrolling parent element instead of document?
+      if(e.type === "mousemove") { // thought of adding scroll in order to move the helper, but mouse poisition is n/a
+        var d = $(document), t = d.scrollTop(), l = d.scrollLeft();
+        if(e.pageY - t < 20) { 
+          if(sti && dir1 === "down") { clearInterval(sti); sti = false; }
+          if(!sti) { dir1 = "up"; sti = setInterval(function () { $(document).scrollTop($(document).scrollTop() - $.vakata.dnd.scroll_spd); }, 150); }
+        }
+        else { 
+          if(sti && dir1 === "up") { clearInterval(sti); sti = false; }
+        }
+        if($(window).height() - (e.pageY - t) < 20) {
+          if(sti && dir1 === "up") { clearInterval(sti); sti = false; }
+          if(!sti) { dir1 = "down"; sti = setInterval(function () { $(document).scrollTop($(document).scrollTop() + $.vakata.dnd.scroll_spd); }, 150); }
+        }
+        else { 
+          if(sti && dir1 === "down") { clearInterval(sti); sti = false; }
+        }
+
+        if(e.pageX - l < 20) {
+          if(sli && dir2 === "right") { clearInterval(sli); sli = false; }
+          if(!sli) { dir2 = "left"; sli = setInterval(function () { $(document).scrollLeft($(document).scrollLeft() - $.vakata.dnd.scroll_spd); }, 150); }
+        }
+        else { 
+          if(sli && dir2 === "left") { clearInterval(sli); sli = false; }
+        }
+        if($(window).width() - (e.pageX - l) < 20) {
+          if(sli && dir2 === "left") { clearInterval(sli); sli = false; }
+          if(!sli) { dir2 = "right"; sli = setInterval(function () { $(document).scrollLeft($(document).scrollLeft() + $.vakata.dnd.scroll_spd); }, 150); }
+        }
+        else { 
+          if(sli && dir2 === "right") { clearInterval(sli); sli = false; }
+        }
+      }
+
+      $.vakata.dnd.helper.css({ left : (e.pageX + 5) + "px", top : (e.pageY + 10) + "px" });
+      $(document).triggerHandler("drag.vakata", { "event" : e, "data" : $.vakata.dnd.user_data });
+    },
+    drag_stop : function (e) {
+      $(document).unbind("mousemove", $.vakata.dnd.drag);
+      $(document).unbind("mouseup", $.vakata.dnd.drag_stop);
+      $(document).triggerHandler("drag_stop.vakata", { "event" : e, "data" : $.vakata.dnd.user_data });
+      $.vakata.dnd.helper.remove();
+      $.vakata.dnd.init_x = 0;
+      $.vakata.dnd.init_y = 0;
+      $.vakata.dnd.user_data = {};
+      $.vakata.dnd.is_down = false;
+      $.vakata.dnd.is_drag = false;
+    }
+  };
+  $(function() {
+    var css_string = '#vakata-dragged { display:block; margin:0 0 0 0; padding:4px 4px 4px 24px; position:absolute; top:-2000px; line-height:16px; z-index:10000; } ';
+    $.vakata.css.add_sheet({ str : css_string });
+  });
+
+  $.jstree.plugin("dnd", {
+    __init : function () {
+      this.data.dnd = {
+        active : false,
+        after : false,
+        inside : false,
+        before : false,
+        off : false,
+        prepared : false,
+        w : 0,
+        to1 : false,
+        to2 : false,
+        cof : false,
+        cw : false,
+        ch : false,
+        i1 : false,
+        i2 : false
+      };
+      this.get_container()
+        .bind("mouseenter.jstree", $.proxy(function () {
+            if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree && this.data.themes) {
+              m.attr("class", "jstree-" + this.data.themes.theme); 
+              $.vakata.dnd.helper.attr("class", "jstree-dnd-helper jstree-" + this.data.themes.theme);
+            }
+          }, this))
+        .bind("mouseleave.jstree", $.proxy(function () {
+            if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
+              if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
+              if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
+            }
+          }, this))
+        .bind("mousemove.jstree", $.proxy(function (e) {
+            if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
+              var cnt = this.get_container()[0];
+
+              // Horizontal scroll
+              if(e.pageX + 24 > this.data.dnd.cof.left + this.data.dnd.cw) {
+                if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
+                this.data.dnd.i1 = setInterval($.proxy(function () { this.scrollLeft += $.vakata.dnd.scroll_spd; }, cnt), 100);
+              }
+              else if(e.pageX - 24 < this.data.dnd.cof.left) {
+                if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
+                this.data.dnd.i1 = setInterval($.proxy(function () { this.scrollLeft -= $.vakata.dnd.scroll_spd; }, cnt), 100);
+              }
+              else {
+                if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
+              }
+
+              // Vertical scroll
+              if(e.pageY + 24 > this.data.dnd.cof.top + this.data.dnd.ch) {
+                if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
+                this.data.dnd.i2 = setInterval($.proxy(function () { this.scrollTop += $.vakata.dnd.scroll_spd; }, cnt), 100);
+              }
+              else if(e.pageY - 24 < this.data.dnd.cof.top) {
+                if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
+                this.data.dnd.i2 = setInterval($.proxy(function () { this.scrollTop -= $.vakata.dnd.scroll_spd; }, cnt), 100);
+              }
+              else {
+                if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
+              }
+
+            }
+          }, this))
+        .delegate("a", "mousedown.jstree", $.proxy(function (e) { 
+            if(e.which === 1) {
+              this.start_drag(e.currentTarget, e);
+              return false;
+            }
+          }, this))
+        .delegate("a", "mouseenter.jstree", $.proxy(function (e) { 
+            if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
+              this.dnd_enter(e.currentTarget);
+            }
+          }, this))
+        .delegate("a", "mousemove.jstree", $.proxy(function (e) { 
+            if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
+              if(typeof this.data.dnd.off.top === "undefined") { this.data.dnd.off = $(e.target).offset(); }
+              this.data.dnd.w = (e.pageY - (this.data.dnd.off.top || 0)) % this.data.core.li_height;
+              if(this.data.dnd.w < 0) { this.data.dnd.w += this.data.core.li_height; }
+              this.dnd_show();
+            }
+          }, this))
+        .delegate("a", "mouseleave.jstree", $.proxy(function (e) { 
+            if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
+              this.data.dnd.after    = false;
+              this.data.dnd.before  = false;
+              this.data.dnd.inside  = false;
+              $.vakata.dnd.helper.children("ins").attr("class","jstree-invalid");
+              m.hide();
+              if(r && r[0] === e.target.parentNode) {
+                if(this.data.dnd.to1) {
+                  clearTimeout(this.data.dnd.to1);
+                  this.data.dnd.to1 = false;
+                }
+                if(this.data.dnd.to2) {
+                  clearTimeout(this.data.dnd.to2);
+                  this.data.dnd.to2 = false;
+                }
+              }
+            }
+          }, this))
+        .delegate("a", "mouseup.jstree", $.proxy(function (e) { 
+            if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
+              this.dnd_finish(e);
+            }
+          }, this));
+
+      $(document)
+        .bind("drag_stop.vakata", $.proxy(function () {
+            this.data.dnd.after    = false;
+            this.data.dnd.before  = false;
+            this.data.dnd.inside  = false;
+            this.data.dnd.off    = false;
+            this.data.dnd.prepared  = false;
+            this.data.dnd.w      = false;
+            this.data.dnd.to1    = false;
+            this.data.dnd.to2    = false;
+            this.data.dnd.active  = false;
+            this.data.dnd.foreign  = false;
+            if(m) { m.css({ "top" : "-2000px" }); }
+          }, this))
+        .bind("drag_start.vakata", $.proxy(function (e, data) {
+            if(data.data.jstree) { 
+              var et = $(data.event.target);
+              if(et.closest(".jstree").hasClass("jstree-" + this.get_index())) {
+                this.dnd_enter(et);
+              }
+            }
+          }, this));
+
+      var s = this._get_settings().dnd;
+      if(s.drag_target) {
+        $(document)
+          .delegate(s.drag_target, "mousedown.jstree", $.proxy(function (e) {
+            o = e.target;
+            $.vakata.dnd.drag_start(e, { jstree : true, obj : e.target }, "<ins class='jstree-icon'></ins>" + $(e.target).text() );
+            if(this.data.themes) { 
+              m.attr("class", "jstree-" + this.data.themes.theme); 
+              $.vakata.dnd.helper.attr("class", "jstree-dnd-helper jstree-" + this.data.themes.theme); 
+            }
+            $.vakata.dnd.helper.children("ins").attr("class","jstree-invalid");
+            var cnt = this.get_container();
+            this.data.dnd.cof = cnt.offset();
+            this.data.dnd.cw = parseInt(cnt.width(),10);
+            this.data.dnd.ch = parseInt(cnt.height(),10);
+            this.data.dnd.foreign = true;
+            return false;
+          }, this));
+      }
+      if(s.drop_target) {
+        $(document)
+          .delegate(s.drop_target, "mouseenter.jstree", $.proxy(function (e) {
+              if(this.data.dnd.active && this._get_settings().dnd.drop_check.call(this, { "o" : o, "r" : $(e.target) })) {
+                $.vakata.dnd.helper.children("ins").attr("class","jstree-ok");
+              }
+            }, this))
+          .delegate(s.drop_target, "mouseleave.jstree", $.proxy(function (e) {
+              if(this.data.dnd.active) {
+                $.vakata.dnd.helper.children("ins").attr("class","jstree-invalid");
+              }
+            }, this))
+          .delegate(s.drop_target, "mouseup.jstree", $.proxy(function (e) {
+              if(this.data.dnd.active && $.vakata.dnd.helper.children("ins").hasClass("jstree-ok")) {
+                this._get_settings().dnd.drop_finish.call(this, { "o" : o, "r" : $(e.target) });
+              }
+            }, this));
+      }
+    },
+    defaults : {
+      copy_modifier  : "ctrl",
+      check_timeout  : 200,
+      open_timeout  : 500,
+      drop_target    : ".jstree-drop",
+      drop_check    : function (data) { return true; },
+      drop_finish    : $.noop,
+      drag_target    : ".jstree-draggable",
+      drag_finish    : $.noop,
+      drag_check    : function (data) { return { after : false, before : false, inside : true }; }
+    },
+    _fn : {
+      dnd_prepare : function () {
+        if(!r || !r.length) { return; }
+        this.data.dnd.off = r.offset();
+        if(this._get_settings().core.rtl) {
+          this.data.dnd.off.right = this.data.dnd.off.left + r.width();
+        }
+        if(this.data.dnd.foreign) {
+          var a = this._get_settings().dnd.drag_check.call(this, { "o" : o, "r" : r });
+          this.data.dnd.after = a.after;
+          this.data.dnd.before = a.before;
+          this.data.dnd.inside = a.inside;
+          this.data.dnd.prepared = true;
+          return this.dnd_show();
+        }
+        this.prepare_move(o, r, "before");
+        this.data.dnd.before = this.check_move();
+        this.prepare_move(o, r, "after");
+        this.data.dnd.after = this.check_move();
+        if(this._is_loaded(r)) {
+          this.prepare_move(o, r, "inside");
+          this.data.dnd.inside = this.check_move();
+        }
+        else {
+          this.data.dnd.inside = false;
+        }
+        this.data.dnd.prepared = true;
+        return this.dnd_show();
+      },
+      dnd_show : function () {
+        if(!this.data.dnd.prepared) { return; }
+        var o = ["before","inside","after"],
+          r = false,
+          rtl = this._get_settings().core.rtl,
+          pos;
+        if(this.data.dnd.w < this.data.core.li_height/3) { o = ["before","inside","after"]; }
+        else if(this.data.dnd.w <= this.data.core.li_height*2/3) {
+          o = this.data.dnd.w < this.data.core.li_height/2 ? ["inside","before","after"] : ["inside","after","before"];
+        }
+        else { o = ["after","inside","before"]; }
+        $.each(o, $.proxy(function (i, val) { 
+          if(this.data.dnd[val]) {
+            $.vakata.dnd.helper.children("ins").attr("class","jstree-ok");
+            r = val;
+            return false;
+          }
+        }, this));
+        if(r === false) { $.vakata.dnd.helper.children("ins").attr("class","jstree-invalid"); }
+        
+        pos = rtl ? (this.data.dnd.off.right - 18) : (this.data.dnd.off.left + 10);
+        switch(r) {
+          case "before":
+            m.css({ "left" : pos + "px", "top" : (this.data.dnd.off.top - 6) + "px" }).show();
+            break;
+          case "after":
+            m.css({ "left" : pos + "px", "top" : (this.data.dnd.off.top + this.data.core.li_height - 7) + "px" }).show();
+            break;
+          case "inside":
+            m.css({ "left" : pos + ( rtl ? -4 : 4) + "px", "top" : (this.data.dnd.off.top + this.data.core.li_height/2 - 5) + "px" }).show();
+            break;
+          default:
+            m.hide();
+            break;
+        }
+        return r;
+      },
+      dnd_open : function () {
+        this.data.dnd.to2 = false;
+        this.open_node(r, $.proxy(this.dnd_prepare,this), true);
+      },
+      dnd_finish : function (e) {
+        if(this.data.dnd.foreign) {
+          if(this.data.dnd.after || this.data.dnd.before || this.data.dnd.inside) {
+            this._get_settings().dnd.drag_finish.call(this, { "o" : o, "r" : r });
+          }
+        }
+        else {
+          this.dnd_prepare();
+          this.move_node(o, r, this.dnd_show(), e[this._get_settings().dnd.copy_modifier + "Key"]);
+        }
+        o = false;
+        r = false;
+        m.hide();
+      },
+      dnd_enter : function (obj) {
+        var s = this._get_settings().dnd;
+        this.data.dnd.prepared = false;
+        r = this._get_node(obj);
+        if(s.check_timeout) { 
+          // do the calculations after a minimal timeout (users tend to drag quickly to the desired location)
+          if(this.data.dnd.to1) { clearTimeout(this.data.dnd.to1); }
+          this.data.dnd.to1 = setTimeout($.proxy(this.dnd_prepare, this), s.check_timeout); 
+        }
+        else { 
+          this.dnd_prepare(); 
+        }
+        if(s.open_timeout) { 
+          if(this.data.dnd.to2) { clearTimeout(this.data.dnd.to2); }
+          if(r && r.length && r.hasClass("jstree-closed")) { 
+            // if the node is closed - open it, then recalculate
+            this.data.dnd.to2 = setTimeout($.proxy(this.dnd_open, this), s.open_timeout);
+          }
+        }
+        else {
+          if(r && r.length && r.hasClass("jstree-closed")) { 
+            this.dnd_open();
+          }
+        }
+      },
+      start_drag : function (obj, e) {
+        o = this._get_node(obj);
+        if(this.data.ui && this.is_selected(o)) { o = this._get_node(null, true); }
+        $.vakata.dnd.drag_start(e, { jstree : true, obj : o }, "<ins class='jstree-icon'></ins>" + (o.length > 1 ? "Multiple selection" : this.get_text(o)) );
+        if(this.data.themes) { 
+          m.attr("class", "jstree-" + this.data.themes.theme); 
+          $.vakata.dnd.helper.attr("class", "jstree-dnd-helper jstree-" + this.data.themes.theme); 
+        }
+        var cnt = this.get_container();
+        this.data.dnd.cof = cnt.children("ul").offset();
+        this.data.dnd.cw = parseInt(cnt.width(),10);
+        this.data.dnd.ch = parseInt(cnt.height(),10);
+        this.data.dnd.active = true;
+      }
+    }
+  });
+  $(function() {
+    var css_string = '' + 
+      '#vakata-dragged ins { display:block; text-decoration:none; width:16px; height:16px; margin:0 0 0 0; padding:0; position:absolute; top:4px; left:4px; } ' + 
+      '#vakata-dragged .jstree-ok { background:green; } ' + 
+      '#vakata-dragged .jstree-invalid { background:red; } ' + 
+      '#jstree-marker { padding:0; margin:0; line-height:12px; font-size:1px; overflow:hidden; height:12px; width:8px; position:absolute; top:-30px; z-index:10000; background-repeat:no-repeat; display:none; background-color:silver; } ';
+    $.vakata.css.add_sheet({ str : css_string });
+    m = $("<div>").attr({ id : "jstree-marker" }).hide().appendTo("body");
+    $(document).bind("drag_start.vakata", function (e, data) {
+      if(data.data.jstree) { 
+        m.show(); 
+      }
+    });
+    $(document).bind("drag_stop.vakata", function (e, data) {
+      if(data.data.jstree) { m.hide(); }
+    });
+  });
 })(jQuery);
 //*/
 
@@ -2249,135 +2249,135 @@ THE SOFTWARE.
  * DOES NOT WORK NICELY WITH MULTITREE DRAG'N'DROP
  */
 (function ($) {
-	$.jstree.plugin("checkbox", {
-		__init : function () {
-			this.select_node = this.deselect_node = this.deselect_all = $.noop;
-			this.get_selected = this.get_checked;
-
-			this.get_container()
-				.bind("open_node.jstree create_node.jstree clean_node.jstree", $.proxy(function (e, data) { 
-						this._prepare_checkboxes(data.rslt.obj);
-					}, this))
-				.bind("loaded.jstree", $.proxy(function (e) {
-						this._prepare_checkboxes();
-					}, this))
-				.delegate("a", "click.jstree", $.proxy(function (e) {
-						if(this._get_node(e.target).hasClass("jstree-checked")) { this.uncheck_node(e.target); }
-						else { this.check_node(e.target); }
-						if(this.data.ui) { this.save_selected(); }
-						if(this.data.cookies) { this.save_cookie("select_node"); }
-						e.preventDefault();
-					}, this));
-		},
-		__destroy : function () {
-			this.get_container().find(".jstree-checkbox").remove();
-		},
-		_fn : {
-			_prepare_checkboxes : function (obj) {
-				obj = !obj || obj == -1 ? this.get_container() : this._get_node(obj);
-				var c, _this = this, t;
-				obj.each(function () {
-					t = $(this);
-					c = t.is("li") && t.hasClass("jstree-checked") ? "jstree-checked" : "jstree-unchecked";
-					t.find("a").not(":has(.jstree-checkbox)").prepend("<ins class='jstree-checkbox'>&#160;</ins>").parent().not(".jstree-checked, .jstree-unchecked").addClass(c);
-				});
-				if(obj.is("li")) { this._repair_state(obj); }
-				else { obj.find("> ul > li").each(function () { _this._repair_state(this); }); }
-			},
-			change_state : function (obj, state) {
-				obj = this._get_node(obj);
-				state = (state === false || state === true) ? state : obj.hasClass("jstree-checked");
-				if(state) { obj.find("li").andSelf().removeClass("jstree-checked jstree-undetermined").addClass("jstree-unchecked"); }
-				else { 
-					obj.find("li").andSelf().removeClass("jstree-unchecked jstree-undetermined").addClass("jstree-checked"); 
-					if(this.data.ui) { this.data.ui.last_selected = obj; }
-					this.data.checkbox.last_selected = obj;
-				}
-				obj.parentsUntil(".jstree", "li").each(function () {
-					var $this = $(this);
-					if(state) {
-						if($this.children("ul").children(".jstree-checked, .jstree-undetermined").length) {
-							$this.parentsUntil(".jstree", "li").andSelf().removeClass("jstree-checked jstree-unchecked").addClass("jstree-undetermined");
-							return false;
-						}
-						else {
-							$this.removeClass("jstree-checked jstree-undetermined").addClass("jstree-unchecked");
-						}
-					}
-					else {
-						if($this.children("ul").children(".jstree-unchecked, .jstree-undetermined").length) {
-							$this.parentsUntil(".jstree", "li").andSelf().removeClass("jstree-checked jstree-unchecked").addClass("jstree-undetermined");
-							return false;
-						}
-						else {
-							$this.removeClass("jstree-unchecked jstree-undetermined").addClass("jstree-checked");
-						}
-					}
-				});
-				if(this.data.ui) { this.data.ui.selected = this.get_checked(); }
-				this.__callback(obj);
-			},
-			check_node : function (obj) {
-				this.change_state(obj, false);
-			},
-			uncheck_node : function (obj) {
-				this.change_state(obj, true);
-			},
-			check_all : function () {
-				var _this = this;
-				this.get_container().children("ul").children("li").each(function () {
-					_this.check_node(this, false);
-				});
-			},
-			uncheck_all : function () {
-				var _this = this;
-				this.get_container().children("ul").children("li").each(function () {
-					_this.change_state(this, true);
-				});
-			},
-
-			is_checked : function(obj) {
-				obj = this._get_node(obj);
-				return obj.length ? obj.is(".jstree-checked") : false;
-			},
-			get_checked : function (obj) {
-				obj = !obj || obj === -1 ? this.get_container() : this._get_node(obj);
-				return obj.find("> ul > .jstree-checked, .jstree-undetermined > ul > .jstree-checked");
-			},
-			get_unchecked : function (obj) { 
-				obj = !obj || obj === -1 ? this.get_container() : this._get_node(obj);
-				return obj.find("> ul > .jstree-unchecked, .jstree-undetermined > ul > .jstree-unchecked");
-			},
-
-			show_checkboxes : function () { this.get_container().children("ul").removeClass("jstree-no-checkboxes"); },
-			hide_checkboxes : function () { this.get_container().children("ul").addClass("jstree-no-checkboxes"); },
-
-			_repair_state : function (obj) {
-				obj = this._get_node(obj);
-				if(!obj.length) { return; }
-				var a = obj.find("> ul > .jstree-checked").length,
-					b = obj.find("> ul > .jstree-undetermined").length,
-					c = obj.find("> ul > li").length;
-
-				if(c === 0) { if(obj.hasClass("jstree-undetermined")) { this.check_node(obj); } }
-				else if(a === 0 && b === 0) { this.uncheck_node(obj); }
-				else if(a === c) { this.check_node(obj); }
-				else { 
-					obj.parentsUntil(".jstree","li").removeClass("jstree-checked jstree-unchecked").addClass("jstree-undetermined");
-				}
-			},
-			reselect : function () {
-				if(this.data.ui) { 
-					var _this = this,
-						s = this.data.ui.to_select;
-					s = $.map($.makeArray(s), function (n) { return "#" + n.toString().replace(/^#/,"").replace('\\/','/').replace('/','\\/'); });
-					this.deselect_all();
-					$.each(s, function (i, val) { _this.check_node(val); });
-					this.__callback();
-				}
-			}
-		}
-	});
+  $.jstree.plugin("checkbox", {
+    __init : function () {
+      this.select_node = this.deselect_node = this.deselect_all = $.noop;
+      this.get_selected = this.get_checked;
+
+      this.get_container()
+        .bind("open_node.jstree create_node.jstree clean_node.jstree", $.proxy(function (e, data) { 
+            this._prepare_checkboxes(data.rslt.obj);
+          }, this))
+        .bind("loaded.jstree", $.proxy(function (e) {
+            this._prepare_checkboxes();
+          }, this))
+        .delegate("a", "click.jstree", $.proxy(function (e) {
+            if(this._get_node(e.target).hasClass("jstree-checked")) { this.uncheck_node(e.target); }
+            else { this.check_node(e.target); }
+            if(this.data.ui) { this.save_selected(); }
+            if(this.data.cookies) { this.save_cookie("select_node"); }
+            e.preventDefault();
+          }, this));
+    },
+    __destroy : function () {
+      this.get_container().find(".jstree-checkbox").remove();
+    },
+    _fn : {
+      _prepare_checkboxes : function (obj) {
+        obj = !obj || obj == -1 ? this.get_container() : this._get_node(obj);
+        var c, _this = this, t;
+        obj.each(function () {
+          t = $(this);
+          c = t.is("li") && t.hasClass("jstree-checked") ? "jstree-checked" : "jstree-unchecked";
+          t.find("a").not(":has(.jstree-checkbox)").prepend("<ins class='jstree-checkbox'>&#160;</ins>").parent().not(".jstree-checked, .jstree-unchecked").addClass(c);
+        });
+        if(obj.is("li")) { this._repair_state(obj); }
+        else { obj.find("> ul > li").each(function () { _this._repair_state(this); }); }
+      },
+      change_state : function (obj, state) {
+        obj = this._get_node(obj);
+        state = (state === false || state === true) ? state : obj.hasClass("jstree-checked");
+        if(state) { obj.find("li").andSelf().removeClass("jstree-checked jstree-undetermined").addClass("jstree-unchecked"); }
+        else { 
+          obj.find("li").andSelf().removeClass("jstree-unchecked jstree-undetermined").addClass("jstree-checked"); 
+          if(this.data.ui) { this.data.ui.last_selected = obj; }
+          this.data.checkbox.last_selected = obj;
+        }
+        obj.parentsUntil(".jstree", "li").each(function () {
+          var $this = $(this);
+          if(state) {
+            if($this.children("ul").children(".jstree-checked, .jstree-undetermined").length) {
+              $this.parentsUntil(".jstree", "li").andSelf().removeClass("jstree-checked jstree-unchecked").addClass("jstree-undetermined");
+              return false;
+            }
+            else {
+              $this.removeClass("jstree-checked jstree-undetermined").addClass("jstree-unchecked");
+            }
+          }
+          else {
+            if($this.children("ul").children(".jstree-unchecked, .jstree-undetermined").length) {
+              $this.parentsUntil(".jstree", "li").andSelf().removeClass("jstree-checked jstree-unchecked").addClass("jstree-undetermined");
+              return false;
+            }
+            else {
+              $this.removeClass("jstree-unchecked jstree-undetermined").addClass("jstree-checked");
+            }
+          }
+        });
+        if(this.data.ui) { this.data.ui.selected = this.get_checked(); }
+        this.__callback(obj);
+      },
+      check_node : function (obj) {
+        this.change_state(obj, false);
+      },
+      uncheck_node : function (obj) {
+        this.change_state(obj, true);
+      },
+      check_all : function () {
+        var _this = this;
+        this.get_container().children("ul").children("li").each(function () {
+          _this.check_node(this, false);
+        });
+      },
+      uncheck_all : function () {
+        var _this = this;
+        this.get_container().children("ul").children("li").each(function () {
+          _this.change_state(this, true);
+        });
+      },
+
+      is_checked : function(obj) {
+        obj = this._get_node(obj);
+        return obj.length ? obj.is(".jstree-checked") : false;
+      },
+      get_checked : function (obj) {
+        obj = !obj || obj === -1 ? this.get_container() : this._get_node(obj);
+        return obj.find("> ul > .jstree-checked, .jstree-undetermined > ul > .jstree-checked");
+      },
+      get_unchecked : function (obj) { 
+        obj = !obj || obj === -1 ? this.get_container() : this._get_node(obj);
+        return obj.find("> ul > .jstree-unchecked, .jstree-undetermined > ul > .jstree-unchecked");
+      },
+
+      show_checkboxes : function () { this.get_container().children("ul").removeClass("jstree-no-checkboxes"); },
+      hide_checkboxes : function () { this.get_container().children("ul").addClass("jstree-no-checkboxes"); },
+
+      _repair_state : function (obj) {
+        obj = this._get_node(obj);
+        if(!obj.length) { return; }
+        var a = obj.find("> ul > .jstree-checked").length,
+          b = obj.find("> ul > .jstree-undetermined").length,
+          c = obj.find("> ul > li").length;
+
+        if(c === 0) { if(obj.hasClass("jstree-undetermined")) { this.check_node(obj); } }
+        else if(a === 0 && b === 0) { this.uncheck_node(obj); }
+        else if(a === c) { this.check_node(obj); }
+        else { 
+          obj.parentsUntil(".jstree","li").removeClass("jstree-checked jstree-unchecked").addClass("jstree-undetermined");
+        }
+      },
+      reselect : function () {
+        if(this.data.ui) { 
+          var _this = this,
+            s = this.data.ui.to_select;
+          s = $.map($.makeArray(s), function (n) { return "#" + n.toString().replace(/^#/,"").replace('\\/','/').replace('/','\\/'); });
+          this.deselect_all();
+          $.each(s, function (i, val) { _this.check_node(val); });
+          this.__callback();
+        }
+      }
+    }
+  });
 })(jQuery);
 //*/
 
@@ -2386,352 +2386,352 @@ THE SOFTWARE.
  * The XML data store. Datastores are build by overriding the `load_node` and `_is_loaded` functions.
  */
 (function ($) {
-	$.vakata.xslt = function (xml, xsl, callback) {
-		var rs = "", xm, xs, processor, support;
-		if(document.recalc) {
-			xm = document.createElement('xml');
-			xs = document.createElement('xml');
-			xm.innerHTML = xml;
-			xs.innerHTML = xsl;
-			$("body").append(xm).append(xs);
-			setTimeout( (function (xm, xs, callback) {
-				return function () {
-					callback.call(null, xm.transformNode(xs.XMLDocument));
-					setTimeout( (function (xm, xs) { return function () { jQuery("body").remove(xm).remove(xs); }; })(xm, xs), 200);
-				};
-			}) (xm, xs, callback), 100);
-			return true;
-		}
-		if(typeof window.DOMParser !== "undefined" && typeof window.XMLHttpRequest !== "undefined" && typeof window.XSLTProcessor !== "undefined") {
-			processor = new XSLTProcessor();
-			support = $.isFunction(processor.transformDocument) ? (typeof window.XMLSerializer !== "undefined") : true;
-			if(!support) { return false; }
-			xml = new DOMParser().parseFromString(xml, "text/xml");
-			xsl = new DOMParser().parseFromString(xsl, "text/xml");
-			if($.isFunction(processor.transformDocument)) {
-				rs = document.implementation.createDocument("", "", null);
-				processor.transformDocument(xml, xsl, rs, null);
-				callback.call(null, XMLSerializer().serializeToString(rs));
-				return true;
-			}
-			else {
-				processor.importStylesheet(xsl);
-				rs = processor.transformToFragment(xml, document);
-				callback.call(null, $("<div>").append(rs).html());
-				return true;
-			}
-		}
-		return false;
-	};
-	var xsl = {
-		'nest' : '<?xml version="1.0" encoding="utf-8" ?>' + 
-			'<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" >' + 
-			'<xsl:output method="html" encoding="utf-8" omit-xml-declaration="yes" standalone="no" indent="no" media-type="text/html" />' + 
-			'<xsl:template match="/">' + 
-			'	<xsl:call-template name="nodes">' + 
-			'		<xsl:with-param name="node" select="/root" />' + 
-			'	</xsl:call-template>' + 
-			'</xsl:template>' + 
-			'<xsl:template name="nodes">' + 
-			'	<xsl:param name="node" />' + 
-			'	<ul>' + 
-			'	<xsl:for-each select="$node/item">' + 
-			'		<xsl:variable name="children" select="count(./item) &gt; 0" />' + 
-			'		<li>' + 
-			'			<xsl:attribute name="class">' + 
-			'				<xsl:if test="position() = last()">jstree-last </xsl:if>' + 
-			'				<xsl:choose>' + 
-			'					<xsl:when test="@state = \'open\'">jstree-open </xsl:when>' + 
-			'					<xsl:when test="$children or @hasChildren or @state = \'closed\'">jstree-closed </xsl:when>' + 
-			'					<xsl:otherwise>jstree-leaf </xsl:otherwise>' + 
-			'				</xsl:choose>' + 
-			'				<xsl:value-of select="@class" />' + 
-			'			</xsl:attribute>' + 
-			'			<xsl:for-each select="@*">' + 
-			'				<xsl:if test="name() != \'class\' and name() != \'state\' and name() != \'hasChildren\'">' + 
-			'					<xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>' + 
-			'				</xsl:if>' + 
-			'			</xsl:for-each>' + 
-			'	<ins class="jstree-icon"><xsl:text>&#xa0;</xsl:text></ins>' + 
-			'			<xsl:for-each select="content/name">' + 
-			'				<a>' + 
-			'				<xsl:attribute name="href">' + 
-			'					<xsl:choose>' + 
-			'					<xsl:when test="@href"><xsl:value-of select="@href" /></xsl:when>' + 
-			'					<xsl:otherwise>#</xsl:otherwise>' + 
-			'					</xsl:choose>' + 
-			'				</xsl:attribute>' + 
-			'				<xsl:attribute name="class"><xsl:value-of select="@lang" /> <xsl:value-of select="@class" /></xsl:attribute>' + 
-			'				<xsl:attribute name="style"><xsl:value-of select="@style" /></xsl:attribute>' + 
-			'				<xsl:for-each select="@*">' + 
-			'					<xsl:if test="name() != \'style\' and name() != \'class\' and name() != \'href\'">' + 
-			'						<xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>' + 
-			'					</xsl:if>' + 
-			'				</xsl:for-each>' + 
-			'					<ins>' + 
-			'						<xsl:attribute name="class">jstree-icon ' + 
-			'							<xsl:if test="string-length(attribute::icon) > 0 and not(contains(@icon,\'/\'))"><xsl:value-of select="@icon" /></xsl:if>' + 
-			'						</xsl:attribute>' + 
-			'						<xsl:if test="string-length(attribute::icon) > 0 and contains(@icon,\'/\')"><xsl:attribute name="style">background:url(<xsl:value-of select="@icon" />) center center no-repeat;</xsl:attribute></xsl:if>' + 
-			'						<xsl:text>&#xa0;</xsl:text>' + 
-			'					</ins>' + 
-			'					<xsl:value-of select="current()" />' + 
-			'				</a>' + 
-			'			</xsl:for-each>' + 
-			'			<xsl:if test="$children or @hasChildren"><xsl:call-template name="nodes"><xsl:with-param name="node" select="current()" /></xsl:call-template></xsl:if>' + 
-			'		</li>' + 
-			'	</xsl:for-each>' + 
-			'	</ul>' + 
-			'</xsl:template>' + 
-			'</xsl:stylesheet>',
-
-		'flat' : '<?xml version="1.0" encoding="utf-8" ?>' + 
-			'<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" >' + 
-			'<xsl:output method="html" encoding="utf-8" omit-xml-declaration="yes" standalone="no" indent="no" media-type="text/xml" />' + 
-			'<xsl:template match="/">' + 
-			'	<ul>' + 
-			'	<xsl:for-each select="//item[not(@parent_id) or @parent_id=0 or not(@parent_id = //item/@id)]">' + /* the last `or` may be removed */
-			'		<xsl:call-template name="nodes">' + 
-			'			<xsl:with-param name="node" select="." />' + 
-			'			<xsl:with-param name="is_last" select="number(position() = last())" />' + 
-			'		</xsl:call-template>' + 
-			'	</xsl:for-each>' + 
-			'	</ul>' + 
-			'</xsl:template>' + 
-			'<xsl:template name="nodes">' + 
-			'	<xsl:param name="node" />' + 
-			'	<xsl:param name="is_last" />' + 
-			'	<xsl:variable name="children" select="count(//item[@parent_id=$node/attribute::id]) &gt; 0" />' + 
-			'	<li>' + 
-			'	<xsl:attribute name="class">' + 
-			'		<xsl:if test="$is_last = true()">jstree-last </xsl:if>' + 
-			'		<xsl:choose>' + 
-			'			<xsl:when test="@state = \'open\'">jstree-open </xsl:when>' + 
-			'			<xsl:when test="$children or @hasChildren or @state = \'closed\'">jstree-closed </xsl:when>' + 
-			'			<xsl:otherwise>jstree-leaf </xsl:otherwise>' + 
-			'		</xsl:choose>' + 
-			'		<xsl:value-of select="@class" />' + 
-			'	</xsl:attribute>' + 
-			'	<xsl:for-each select="@*">' + 
-			'		<xsl:if test="name() != \'parent_id\' and name() != \'hasChildren\' and name() != \'class\' and name() != \'state\'">' + 
-			'		<xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>' + 
-			'		</xsl:if>' + 
-			'	</xsl:for-each>' + 
-			'	<ins class="jstree-icon"><xsl:text>&#xa0;</xsl:text></ins>' + 
-			'	<xsl:for-each select="content/name">' + 
-			'		<a>' + 
-			'		<xsl:attribute name="href">' + 
-			'			<xsl:choose>' + 
-			'			<xsl:when test="@href"><xsl:value-of select="@href" /></xsl:when>' + 
-			'			<xsl:otherwise>#</xsl:otherwise>' + 
-			'			</xsl:choose>' + 
-			'		</xsl:attribute>' + 
-			'		<xsl:attribute name="class"><xsl:value-of select="@lang" /> <xsl:value-of select="@class" /></xsl:attribute>' + 
-			'		<xsl:attribute name="style"><xsl:value-of select="@style" /></xsl:attribute>' + 
-			'		<xsl:for-each select="@*">' + 
-			'			<xsl:if test="name() != \'style\' and name() != \'class\' and name() != \'href\'">' + 
-			'				<xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>' + 
-			'			</xsl:if>' + 
-			'		</xsl:for-each>' + 
-			'			<ins>' + 
-			'				<xsl:attribute name="class">jstree-icon ' + 
-			'					<xsl:if test="string-length(attribute::icon) > 0 and not(contains(@icon,\'/\'))"><xsl:value-of select="@icon" /></xsl:if>' + 
-			'				</xsl:attribute>' + 
-			'				<xsl:if test="string-length(attribute::icon) > 0 and contains(@icon,\'/\')"><xsl:attribute name="style">background:url(<xsl:value-of select="@icon" />) center center no-repeat;</xsl:attribute></xsl:if>' + 
-			'				<xsl:text>&#xa0;</xsl:text>' + 
-			'			</ins>' + 
-			'			<xsl:value-of select="current()" />' + 
-			'		</a>' + 
-			'	</xsl:for-each>' + 
-			'	<xsl:if test="$children">' + 
-			'		<ul>' + 
-			'		<xsl:for-each select="//item[@parent_id=$node/attribute::id]">' + 
-			'			<xsl:call-template name="nodes">' + 
-			'				<xsl:with-param name="node" select="." />' + 
-			'				<xsl:with-param name="is_last" select="number(position() = last())" />' + 
-			'			</xsl:call-template>' + 
-			'		</xsl:for-each>' + 
-			'		</ul>' + 
-			'	</xsl:if>' + 
-			'	</li>' + 
-			'</xsl:template>' + 
-			'</xsl:stylesheet>'
-	};
-	$.jstree.plugin("xml_data", {
-		defaults : { 
-			data : false,
-			ajax : false,
-			xsl : "flat",
-			clean_node : false,
-			correct_state : true
-		},
-		_fn : {
-			load_node : function (obj, s_call, e_call) { var _this = this; this.load_node_xml(obj, function () { _this.__callback({ "obj" : obj }); s_call.call(this); }, e_call); },
-			_is_loaded : function (obj) { 
-				var s = this._get_settings().xml_data;
-				obj = this._get_node(obj);
-				return obj == -1 || !obj || !s.ajax || obj.is(".jstree-open, .jstree-leaf") || obj.children("ul").children("li").size() > 0;
-			},
-			load_node_xml : function (obj, s_call, e_call) {
-				var s = this.get_settings().xml_data,
-					error_func = function () {},
-					success_func = function () {};
-
-				obj = this._get_node(obj);
-				if(obj && obj !== -1) {
-					if(obj.data("jstree-is-loading")) { return; }
-					else { obj.data("jstree-is-loading",true); }
-				}
-				switch(!0) {
-					case (!s.data && !s.ajax): throw "Neither data nor ajax settings supplied.";
-					case (!!s.data && !s.ajax) || (!!s.data && !!s.ajax && (!obj || obj === -1)):
-						if(!obj || obj == -1) {
-							this.parse_xml(s.data, $.proxy(function (d) {
-								if(d) {
-									d = d.replace(/ ?xmlns="[^"]*"/ig, "");
-									if(d.length > 10) {
-										d = $(d);
-										this.get_container().children("ul").empty().append(d.children());
-										if(s.clean_node) { this.clean_node(obj); }
-										if(s_call) { s_call.call(this); }
-									}
-								}
-								else { 
-									if(s.correct_state) { 
-										this.get_container().children("ul").empty(); 
-										if(s_call) { s_call.call(this); }
-									}
-								}
-							}, this));
-						}
-						break;
-					case (!s.data && !!s.ajax) || (!!s.data && !!s.ajax && obj && obj !== -1):
-						error_func = function (x, t, e) {
-							var ef = this.get_settings().xml_data.ajax.error; 
-							if(ef) { ef.call(this, x, t, e); }
-							if(obj !== -1 && obj.length) {
-								obj.children(".jstree-loading").removeClass("jstree-loading");
-								obj.data("jstree-is-loading",false);
-								if(t === "success" && s.correct_state) { obj.removeClass("jstree-open jstree-closed").addClass("jstree-leaf"); }
-							}
-							else {
-								if(t === "success" && s.correct_state) { this.get_container().children("ul").empty(); }
-							}
-							if(e_call) { e_call.call(this); }
-						};
-						success_func = function (d, t, x) {
-							d = x.responseText;
-							var sf = this.get_settings().xml_data.ajax.success; 
-							if(sf) { d = sf.call(this,d,t,x) || d; }
-							if(d == "") {
-								return error_func.call(this, x, t, "");
-							}
-							this.parse_xml(d, $.proxy(function (d) {
-								if(d) {
-									d = d.replace(/ ?xmlns="[^"]*"/ig, "");
-									if(d.length > 10) {
-										d = $(d);
-										if(obj === -1 || !obj) { this.get_container().children("ul").empty().append(d.children()); }
-										else { obj.children(".jstree-loading").removeClass("jstree-loading"); obj.append(d); obj.data("jstree-is-loading",false); }
-										if(s.clean_node) { this.clean_node(obj); }
-										if(s_call) { s_call.call(this); }
-									}
-									else {
-										if(obj && obj !== -1) { 
-											obj.children(".jstree-loading").removeClass("jstree-loading");
-											obj.data("jstree-is-loading",false);
-											if(s.correct_state) { 
-												obj.removeClass("jstree-open jstree-closed").addClass("jstree-leaf"); 
-												if(s_call) { s_call.call(this); } 
-											}
-										}
-										else {
-											if(s.correct_state) { 
-												this.get_container().children("ul").empty();
-												if(s_call) { s_call.call(this); } 
-											}
-										}
-									}
-								}
-							}, this));
-						};
-						s.ajax.context = this;
-						s.ajax.error = error_func;
-						s.ajax.success = success_func;
-						if(!s.ajax.dataType) { s.ajax.dataType = "xml"; }
-						if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, obj); }
-						if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, obj); }
-						$.ajax(s.ajax);
-						break;
-				}
-			},
-			parse_xml : function (xml, callback) {
-				var s = this._get_settings().xml_data;
-				$.vakata.xslt(xml, xsl[s.xsl], callback);
-			},
-			get_xml : function (tp, obj, li_attr, a_attr, is_callback) {
-				var result = "", 
-					s = this._get_settings(), 
-					_this = this,
-					tmp1, tmp2, li, a, lang;
-				if(!tp) { tp = "flat"; }
-				if(!is_callback) { is_callback = 0; }
-				obj = this._get_node(obj);
-				if(!obj || obj === -1) { obj = this.get_container().find("> ul > li"); }
-				li_attr = $.isArray(li_attr) ? li_attr : [ "id", "class" ];
-				if(!is_callback && this.data.types && $.inArray(s.types.type_attr, li_attr) === -1) { li_attr.push(s.types.type_attr); }
-
-				a_attr = $.isArray(a_attr) ? a_attr : [ ];
-
-				if(!is_callback) { result += "<root>"; }
-				obj.each(function () {
-					result += "<item";
-					li = $(this);
-					$.each(li_attr, function (i, v) { result += " " + v + "=\"" + (li.attr(v) || "").replace(/jstree[^ ]*|$/ig,'').replace(/^\s+$/ig,"") + "\""; });
-					if(li.hasClass("jstree-open")) { result += " state=\"open\""; }
-					if(li.hasClass("jstree-closed")) { result += " state=\"closed\""; }
-					if(tp === "flat") { result += " parent_id=\"" + is_callback + "\""; }
-					result += ">";
-					result += "<content>";
-					a = li.children("a");
-					a.each(function () {
-						tmp1 = $(this);
-						lang = false;
-						result += "<name";
-						if($.inArray("languages", s.plugins) !== -1) {
-							$.each(s.languages, function (k, z) {
-								if(tmp1.hasClass(z)) { result += " lang=\"" + z + "\""; lang = z; return false; }
-							});
-						}
-						if(a_attr.length) { 
-							$.each(a_attr, function (k, z) {
-								result += " " + z + "=\"" + (tmp1.attr(z) || "").replace(/jstree[^ ]*|$/ig,'') + "\"";
-							});
-						}
-						if(tmp1.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').replace(/^\s+$/ig,"").length) {
-							result += ' icon="' + tmp1.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').replace(/^\s+$/ig,"") + '"';
-						}
-						if(tmp1.children("ins").get(0).style.backgroundImage.length) {
-							result += ' icon="' + tmp1.children("ins").get(0).style.backgroundImage.replace("url(","").replace(")","") + '"';
-						}
-						result += ">";
-						result += "<![CDATA[" + _this.get_text(tmp1, lang) + "]]>";
-						result += "</name>";
-					});
-					result += "</content>";
-					tmp2 = li[0].id;
-					li = li.find("> ul > li");
-					if(li.length) { tmp2 = _this.get_xml(tp, li, li_attr, a_attr, tmp2); }
-					else { tmp2 = ""; }
-					if(tp == "nest") { result += tmp2; }
-					result += "</item>";
-					if(tp == "flat") { result += tmp2; }
-				});
-				if(!is_callback) { result += "</root>"; }
-				return result;
-			}
-		}
-	});
+  $.vakata.xslt = function (xml, xsl, callback) {
+    var rs = "", xm, xs, processor, support;
+    if(document.recalc) {
+      xm = document.createElement('xml');
+      xs = document.createElement('xml');
+      xm.innerHTML = xml;
+      xs.innerHTML = xsl;
+      $("body").append(xm).append(xs);
+      setTimeout( (function (xm, xs, callback) {
+        return function () {
+          callback.call(null, xm.transformNode(xs.XMLDocument));
+          setTimeout( (function (xm, xs) { return function () { jQuery("body").remove(xm).remove(xs); }; })(xm, xs), 200);
+        };
+      }) (xm, xs, callback), 100);
+      return true;
+    }
+    if(typeof window.DOMParser !== "undefined" && typeof window.XMLHttpRequest !== "undefined" && typeof window.XSLTProcessor !== "undefined") {
+      processor = new XSLTProcessor();
+      support = $.isFunction(processor.transformDocument) ? (typeof window.XMLSerializer !== "undefined") : true;
+      if(!support) { return false; }
+      xml = new DOMParser().parseFromString(xml, "text/xml");
+      xsl = new DOMParser().parseFromString(xsl, "text/xml");
+      if($.isFunction(processor.transformDocument)) {
+        rs = document.implementation.createDocument("", "", null);
+        processor.transformDocument(xml, xsl, rs, null);
+        callback.call(null, XMLSerializer().serializeToString(rs));
+        return true;
+      }
+      else {
+        processor.importStylesheet(xsl);
+        rs = processor.transformToFragment(xml, document);
+        callback.call(null, $("<div>").append(rs).html());
+        return true;
+      }
+    }
+    return false;
+  };
+  var xsl = {
+    'nest' : '<?xml version="1.0" encoding="utf-8" ?>' + 
+      '<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" >' + 
+      '<xsl:output method="html" encoding="utf-8" omit-xml-declaration="yes" standalone="no" indent="no" media-type="text/html" />' + 
+      '<xsl:template match="/">' + 
+      '  <xsl:call-template name="nodes">' + 
+      '    <xsl:with-param name="node" select="/root" />' + 
+      '  </xsl:call-template>' + 
+      '</xsl:template>' + 
+      '<xsl:template name="nodes">' + 
+      '  <xsl:param name="node" />' + 
+      '  <ul>' + 
+      '  <xsl:for-each select="$node/item">' + 
+      '    <xsl:variable name="children" select="count(./item) &gt; 0" />' + 
+      '    <li>' + 
+      '      <xsl:attribute name="class">' + 
+      '        <xsl:if test="position() = last()">jstree-last </xsl:if>' + 
+      '        <xsl:choose>' + 
+      '          <xsl:when test="@state = \'open\'">jstree-open </xsl:when>' + 
+      '          <xsl:when test="$children or @hasChildren or @state = \'closed\'">jstree-closed </xsl:when>' + 
+      '          <xsl:otherwise>jstree-leaf </xsl:otherwise>' + 
+      '        </xsl:choose>' + 
+      '        <xsl:value-of select="@class" />' + 
+      '      </xsl:attribute>' + 
+      '      <xsl:for-each select="@*">' + 
+      '        <xsl:if test="name() != \'class\' and name() != \'state\' and name() != \'hasChildren\'">' + 
+      '          <xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>' + 
+      '        </xsl:if>' + 
+      '      </xsl:for-each>' + 
+      '  <ins class="jstree-icon"><xsl:text>&#xa0;</xsl:text></ins>' + 
+      '      <xsl:for-each select="content/name">' + 
+      '        <a>' + 
+      '        <xsl:attribute name="href">' + 
+      '          <xsl:choose>' + 
+      '          <xsl:when test="@href"><xsl:value-of select="@href" /></xsl:when>' + 
+      '          <xsl:otherwise>#</xsl:otherwise>' + 
+      '          </xsl:choose>' + 
+      '        </xsl:attribute>' + 
+      '        <xsl:attribute name="class"><xsl:value-of select="@lang" /> <xsl:value-of select="@class" /></xsl:attribute>' + 
+      '        <xsl:attribute name="style"><xsl:value-of select="@style" /></xsl:attribute>' + 
+      '        <xsl:for-each select="@*">' + 
+      '          <xsl:if test="name() != \'style\' and name() != \'class\' and name() != \'href\'">' + 
+      '            <xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>' + 
+      '          </xsl:if>' + 
+      '        </xsl:for-each>' + 
+      '          <ins>' + 
+      '            <xsl:attribute name="class">jstree-icon ' + 
+      '              <xsl:if test="string-length(attribute::icon) > 0 and not(contains(@icon,\'/\'))"><xsl:value-of select="@icon" /></xsl:if>' + 
+      '            </xsl:attribute>' + 
+      '            <xsl:if test="string-length(attribute::icon) > 0 and contains(@icon,\'/\')"><xsl:attribute name="style">background:url(<xsl:value-of select="@icon" />) center center no-repeat;</xsl:attribute></xsl:if>' + 
+      '            <xsl:text>&#xa0;</xsl:text>' + 
+      '          </ins>' + 
+      '          <xsl:value-of select="current()" />' + 
+      '        </a>' + 
+      '      </xsl:for-each>' + 
+      '      <xsl:if test="$children or @hasChildren"><xsl:call-template name="nodes"><xsl:with-param name="node" select="current()" /></xsl:call-template></xsl:if>' + 
+      '    </li>' + 
+      '  </xsl:for-each>' + 
+      '  </ul>' + 
+      '</xsl:template>' + 
+      '</xsl:stylesheet>',
+
+    'flat' : '<?xml version="1.0" encoding="utf-8" ?>' + 
+      '<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" >' + 
+      '<xsl:output method="html" encoding="utf-8" omit-xml-declaration="yes" standalone="no" indent="no" media-type="text/xml" />' + 
+      '<xsl:template match="/">' + 
+      '  <ul>' + 
+      '  <xsl:for-each select="//item[not(@parent_id) or @parent_id=0 or not(@parent_id = //item/@id)]">' + /* the last `or` may be removed */
+      '    <xsl:call-template name="nodes">' + 
+      '      <xsl:with-param name="node" select="." />' + 
+      '      <xsl:with-param name="is_last" select="number(position() = last())" />' + 
+      '    </xsl:call-template>' + 
+      '  </xsl:for-each>' + 
+      '  </ul>' + 
+      '</xsl:template>' + 
+      '<xsl:template name="nodes">' + 
+      '  <xsl:param name="node" />' + 
+      '  <xsl:param name="is_last" />' + 
+      '  <xsl:variable name="children" select="count(//item[@parent_id=$node/attribute::id]) &gt; 0" />' + 
+      '  <li>' + 
+      '  <xsl:attribute name="class">' + 
+      '    <xsl:if test="$is_last = true()">jstree-last </xsl:if>' + 
+      '    <xsl:choose>' + 
+      '      <xsl:when test="@state = \'open\'">jstree-open </xsl:when>' + 
+      '      <xsl:when test="$children or @hasChildren or @state = \'closed\'">jstree-closed </xsl:when>' + 
+      '      <xsl:otherwise>jstree-leaf </xsl:otherwise>' + 
+      '    </xsl:choose>' + 
+      '    <xsl:value-of select="@class" />' + 
+      '  </xsl:attribute>' + 
+      '  <xsl:for-each select="@*">' + 
+      '    <xsl:if test="name() != \'parent_id\' and name() != \'hasChildren\' and name() != \'class\' and name() != \'state\'">' + 
+      '    <xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>' + 
+      '    </xsl:if>' + 
+      '  </xsl:for-each>' + 
+      '  <ins class="jstree-icon"><xsl:text>&#xa0;</xsl:text></ins>' + 
+      '  <xsl:for-each select="content/name">' + 
+      '    <a>' + 
+      '    <xsl:attribute name="href">' + 
+      '      <xsl:choose>' + 
+      '      <xsl:when test="@href"><xsl:value-of select="@href" /></xsl:when>' + 
+      '      <xsl:otherwise>#</xsl:otherwise>' + 
+      '      </xsl:choose>' + 
+      '    </xsl:attribute>' + 
+      '    <xsl:attribute name="class"><xsl:value-of select="@lang" /> <xsl:value-of select="@class" /></xsl:attribute>' + 
+      '    <xsl:attribute name="style"><xsl:value-of select="@style" /></xsl:attribute>' + 
+      '    <xsl:for-each select="@*">' + 
+      '      <xsl:if test="name() != \'style\' and name() != \'class\' and name() != \'href\'">' + 
+      '        <xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>' + 
+      '      </xsl:if>' + 
+      '    </xsl:for-each>' + 
+      '      <ins>' + 
+      '        <xsl:attribute name="class">jstree-icon ' + 
+      '          <xsl:if test="string-length(attribute::icon) > 0 and not(contains(@icon,\'/\'))"><xsl:value-of select="@icon" /></xsl:if>' + 
+      '        </xsl:attribute>' + 
+      '        <xsl:if test="string-length(attribute::icon) > 0 and contains(@icon,\'/\')"><xsl:attribute name="style">background:url(<xsl:value-of select="@icon" />) center center no-repeat;</xsl:attribute></xsl:if>' + 
+      '        <xsl:text>&#xa0;</xsl:text>' + 
+      '      </ins>' + 
+      '      <xsl:value-of select="current()" />' + 
+      '    </a>' + 
+      '  </xsl:for-each>' + 
+      '  <xsl:if test="$children">' + 
+      '    <ul>' + 
+      '    <xsl:for-each select="//item[@parent_id=$node/attribute::id]">' + 
+      '      <xsl:call-template name="nodes">' + 
+      '        <xsl:with-param name="node" select="." />' + 
+      '        <xsl:with-param name="is_last" select="number(position() = last())" />' + 
+      '      </xsl:call-template>' + 
+      '    </xsl:for-each>' + 
+      '    </ul>' + 
+      '  </xsl:if>' + 
+      '  </li>' + 
+      '</xsl:template>' + 
+      '</xsl:stylesheet>'
+  };
+  $.jstree.plugin("xml_data", {
+    defaults : { 
+      data : false,
+      ajax : false,
+      xsl : "flat",
+      clean_node : false,
+      correct_state : true
+    },
+    _fn : {
+      load_node : function (obj, s_call, e_call) { var _this = this; this.load_node_xml(obj, function () { _this.__callback({ "obj" : obj }); s_call.call(this); }, e_call); },
+      _is_loaded : function (obj) { 
+        var s = this._get_settings().xml_data;
+        obj = this._get_node(obj);
+        return obj == -1 || !obj || !s.ajax || obj.is(".jstree-open, .jstree-leaf") || obj.children("ul").children("li").size() > 0;
+      },
+      load_node_xml : function (obj, s_call, e_call) {
+        var s = this.get_settings().xml_data,
+          error_func = function () {},
+          success_func = function () {};
+
+        obj = this._get_node(obj);
+        if(obj && obj !== -1) {
+          if(obj.data("jstree-is-loading")) { return; }
+          else { obj.data("jstree-is-loading",true); }
+        }
+        switch(!0) {
+          case (!s.data && !s.ajax): throw "Neither data nor ajax settings supplied.";
+          case (!!s.data && !s.ajax) || (!!s.data && !!s.ajax && (!obj || obj === -1)):
+            if(!obj || obj == -1) {
+              this.parse_xml(s.data, $.proxy(function (d) {
+                if(d) {
+                  d = d.replace(/ ?xmlns="[^"]*"/ig, "");
+                  if(d.length > 10) {
+                    d = $(d);
+                    this.get_container().children("ul").empty().append(d.children());
+                    if(s.clean_node) { this.clean_node(obj); }
+                    if(s_call) { s_call.call(this); }
+                  }
+                }
+                else { 
+                  if(s.correct_state) { 
+                    this.get_container().children("ul").empty(); 
+                    if(s_call) { s_call.call(this); }
+                  }
+                }
+              }, this));
+            }
+            break;
+          case (!s.data && !!s.ajax) || (!!s.data && !!s.ajax && obj && obj !== -1):
+            error_func = function (x, t, e) {
+              var ef = this.get_settings().xml_data.ajax.error; 
+              if(ef) { ef.call(this, x, t, e); }
+              if(obj !== -1 && obj.length) {
+                obj.children(".jstree-loading").removeClass("jstree-loading");
+                obj.data("jstree-is-loading",false);
+                if(t === "success" && s.correct_state) { obj.removeClass("jstree-open jstree-closed").addClass("jstree-leaf"); }
+              }
+              else {
+                if(t === "success" && s.correct_state) { this.get_container().children("ul").empty(); }
+              }
+              if(e_call) { e_call.call(this); }
+            };
+            success_func = function (d, t, x) {
+              d = x.responseText;
+              var sf = this.get_settings().xml_data.ajax.success; 
+              if(sf) { d = sf.call(this,d,t,x) || d; }
+              if(d == "") {
+                return error_func.call(this, x, t, "");
+              }
+              this.parse_xml(d, $.proxy(function (d) {
+                if(d) {
+                  d = d.replace(/ ?xmlns="[^"]*"/ig, "");
+                  if(d.length > 10) {
+                    d = $(d);
+                    if(obj === -1 || !obj) { this.get_container().children("ul").empty().append(d.children()); }
+                    else { obj.children(".jstree-loading").removeClass("jstree-loading"); obj.append(d); obj.data("jstree-is-loading",false); }
+                    if(s.clean_node) { this.clean_node(obj); }
+                    if(s_call) { s_call.call(this); }
+                  }
+                  else {
+                    if(obj && obj !== -1) { 
+                      obj.children(".jstree-loading").removeClass("jstree-loading");
+                      obj.data("jstree-is-loading",false);
+                      if(s.correct_state) { 
+                        obj.removeClass("jstree-open jstree-closed").addClass("jstree-leaf"); 
+                        if(s_call) { s_call.call(this); } 
+                      }
+                    }
+                    else {
+                      if(s.correct_state) { 
+                        this.get_container().children("ul").empty();
+                        if(s_call) { s_call.call(this); } 
+                      }
+                    }
+                  }
+                }
+              }, this));
+            };
+            s.ajax.context = this;
+            s.ajax.error = error_func;
+            s.ajax.success = success_func;
+            if(!s.ajax.dataType) { s.ajax.dataType = "xml"; }
+            if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, obj); }
+            if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, obj); }
+            $.ajax(s.ajax);
+            break;
+        }
+      },
+      parse_xml : function (xml, callback) {
+        var s = this._get_settings().xml_data;
+        $.vakata.xslt(xml, xsl[s.xsl], callback);
+      },
+      get_xml : function (tp, obj, li_attr, a_attr, is_callback) {
+        var result = "", 
+          s = this._get_settings(), 
+          _this = this,
+          tmp1, tmp2, li, a, lang;
+        if(!tp) { tp = "flat"; }
+        if(!is_callback) { is_callback = 0; }
+        obj = this._get_node(obj);
+        if(!obj || obj === -1) { obj = this.get_container().find("> ul > li"); }
+        li_attr = $.isArray(li_attr) ? li_attr : [ "id", "class" ];
+        if(!is_callback && this.data.types && $.inArray(s.types.type_attr, li_attr) === -1) { li_attr.push(s.types.type_attr); }
+
+        a_attr = $.isArray(a_attr) ? a_attr : [ ];
+
+        if(!is_callback) { result += "<root>"; }
+        obj.each(function () {
+          result += "<item";
+          li = $(this);
+          $.each(li_attr, function (i, v) { result += " " + v + "=\"" + (li.attr(v) || "").replace(/jstree[^ ]*|$/ig,'').replace(/^\s+$/ig,"") + "\""; });
+          if(li.hasClass("jstree-open")) { result += " state=\"open\""; }
+          if(li.hasClass("jstree-closed")) { result += " state=\"closed\""; }
+          if(tp === "flat") { result += " parent_id=\"" + is_callback + "\""; }
+          result += ">";
+          result += "<content>";
+          a = li.children("a");
+          a.each(function () {
+            tmp1 = $(this);
+            lang = false;
+            result += "<name";
+            if($.inArray("languages", s.plugins) !== -1) {
+              $.each(s.languages, function (k, z) {
+                if(tmp1.hasClass(z)) { result += " lang=\"" + z + "\""; lang = z; return false; }
+              });
+            }
+            if(a_attr.length) { 
+              $.each(a_attr, function (k, z) {
+                result += " " + z + "=\"" + (tmp1.attr(z) || "").replace(/jstree[^ ]*|$/ig,'') + "\"";
+              });
+            }
+            if(tmp1.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').replace(/^\s+$/ig,"").length) {
+              result += ' icon="' + tmp1.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').replace(/^\s+$/ig,"") + '"';
+            }
+            if(tmp1.children("ins").get(0).style.backgroundImage.length) {
+              result += ' icon="' + tmp1.children("ins").get(0).style.backgroundImage.replace("url(","").replace(")","") + '"';
+            }
+            result += ">";
+            result += "<![CDATA[" + _this.get_text(tmp1, lang) + "]]>";
+            result += "</name>";
+          });
+          result += "</content>";
+          tmp2 = li[0].id;
+          li = li.find("> ul > li");
+          if(li.length) { tmp2 = _this.get_xml(tp, li, li_attr, a_attr, tmp2); }
+          else { tmp2 = ""; }
+          if(tp == "nest") { result += tmp2; }
+          result += "</item>";
+          if(tp == "flat") { result += tmp2; }
+        });
+        if(!is_callback) { result += "</root>"; }
+        return result;
+      }
+    }
+  });
 })(jQuery);
 //*/
 
@@ -2741,81 +2741,81 @@ THE SOFTWARE.
  * DOES NOT WORK WITH JSON PROGRESSIVE RENDER
  */
 (function ($) {
-	$.expr[':'].jstree_contains = function(a,i,m){
-		return (a.textContent || a.innerText || "").toLowerCase().indexOf(m[3].toLowerCase())>=0;
-	};
-	$.jstree.plugin("search", {
-		__init : function () {
-			this.data.search.str = "";
-			this.data.search.result = $();
-		},
-		defaults : {
-			ajax : false, // OR ajax object
-			case_insensitive : false
-		},
-		_fn : {
-			search : function (str, skip_async) {
-				if(str === "") { return; }
-				var s = this.get_settings().search, 
-					t = this,
-					error_func = function () { },
-					success_func = function () { };
-				this.data.search.str = str;
-
-				if(!skip_async && s.ajax !== false && this.get_container().find(".jstree-closed:eq(0)").length > 0) {
-					this.search.supress_callback = true;
-					error_func = function () { };
-					success_func = function (d, t, x) {
-						var sf = this.get_settings().search.ajax.success; 
-						if(sf) { d = sf.call(this,d,t,x) || d; }
-						this.data.search.to_open = d;
-						this._search_open();
-					};
-					s.ajax.context = this;
-					s.ajax.error = error_func;
-					s.ajax.success = success_func;
-					if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, str); }
-					if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, str); }
-					if(!s.ajax.data) { s.ajax.data = { "search_string" : str }; }
-					if(!s.ajax.dataType || /^json/.exec(s.ajax.dataType)) { s.ajax.dataType = "json"; }
-					$.ajax(s.ajax);
-					return;
-				}
-				if(this.data.search.result.length) { this.clear_search(); }
-				this.data.search.result = this.get_container().find("a" + (this.data.languages ? "." + this.get_lang() : "" ) + ":" + (s.case_insensitive ? "jstree_contains" : "contains") + "(" + this.data.search.str + ")");
-				this.data.search.result.addClass("jstree-search").parents(".jstree-closed").each(function () {
-					t.open_node(this, false, true);
-				});
-				this.__callback({ nodes : this.data.search.result, str : str });
-			},
-			clear_search : function (str) {
-				this.data.search.result.removeClass("jstree-search");
-				this.__callback(this.data.search.result);
-				this.data.search.result = $();
-			},
-			_search_open : function (is_callback) {
-				var _this = this,
-					done = true,
-					current = [],
-					remaining = [];
-				if(this.data.search.to_open.length) {
-					$.each(this.data.search.to_open, function (i, val) {
-						if(val == "#") { return true; }
-						if($(val).length && $(val).is(".jstree-closed")) { current.push(val); }
-						else { remaining.push(val); }
-					});
-					if(current.length) {
-						this.data.search.to_open = remaining;
-						$.each(current, function (i, val) { 
-							_this.open_node(val, function () { _this._search_open(true); }); 
-						});
-						done = false;
-					}
-				}
-				if(done) { this.search(this.data.search.str, true); }
-			}
-		}
-	});
+  $.expr[':'].jstree_contains = function(a,i,m){
+    return (a.textContent || a.innerText || "").toLowerCase().indexOf(m[3].toLowerCase())>=0;
+  };
+  $.jstree.plugin("search", {
+    __init : function () {
+      this.data.search.str = "";
+      this.data.search.result = $();
+    },
+    defaults : {
+      ajax : false, // OR ajax object
+      case_insensitive : false
+    },
+    _fn : {
+      search : function (str, skip_async) {
+        if(str === "") { return; }
+        var s = this.get_settings().search, 
+          t = this,
+          error_func = function () { },
+          success_func = function () { };
+        this.data.search.str = str;
+
+        if(!skip_async && s.ajax !== false && this.get_container().find(".jstree-closed:eq(0)").length > 0) {
+          this.search.supress_callback = true;
+          error_func = function () { };
+          success_func = function (d, t, x) {
+            var sf = this.get_settings().search.ajax.success; 
+            if(sf) { d = sf.call(this,d,t,x) || d; }
+            this.data.search.to_open = d;
+            this._search_open();
+          };
+          s.ajax.context = this;
+          s.ajax.error = error_func;
+          s.ajax.success = success_func;
+          if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, str); }
+          if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, str); }
+          if(!s.ajax.data) { s.ajax.data = { "search_string" : str }; }
+          if(!s.ajax.dataType || /^json/.exec(s.ajax.dataType)) { s.ajax.dataType = "json"; }
+          $.ajax(s.ajax);
+          return;
+        }
+        if(this.data.search.result.length) { this.clear_search(); }
+        this.data.search.result = this.get_container().find("a" + (this.data.languages ? "." + this.get_lang() : "" ) + ":" + (s.case_insensitive ? "jstree_contains" : "contains") + "(" + this.data.search.str + ")");
+        this.data.search.result.addClass("jstree-search").parents(".jstree-closed").each(function () {
+          t.open_node(this, false, true);
+        });
+        this.__callback({ nodes : this.data.search.result, str : str });
+      },
+      clear_search : function (str) {
+        this.data.search.result.removeClass("jstree-search");
+        this.__callback(this.data.search.result);
+        this.data.search.result = $();
+      },
+      _search_open : function (is_callback) {
+        var _this = this,
+          done = true,
+          current = [],
+          remaining = [];
+        if(this.data.search.to_open.length) {
+          $.each(this.data.search.to_open, function (i, val) {
+            if(val == "#") { return true; }
+            if($(val).length && $(val).is(".jstree-closed")) { current.push(val); }
+            else { remaining.push(val); }
+          });
+          if(current.length) {
+            this.data.search.to_open = remaining;
+            $.each(current, function (i, val) { 
+              _this.open_node(val, function () { _this._search_open(true); }); 
+            });
+            done = false;
+          }
+        }
+        if(done) { this.search(this.data.search.str, true); }
+      }
+    }
+  });
 })(jQuery);
 //*/
 
@@ -2823,263 +2823,263 @@ THE SOFTWARE.
  * jsTree contextmenu plugin 1.0
  */
 (function ($) {
-	$.vakata.context = {
-		cnt		: $("<div id='vakata-contextmenu'>"),
-		vis		: false,
-		tgt		: false,
-		par		: false,
-		func	: false,
-		data	: false,
-		show	: function (s, t, x, y, d, p) {
-			var html = $.vakata.context.parse(s), h, w;
-			if(!html) { return; }
-			$.vakata.context.vis = true;
-			$.vakata.context.tgt = t;
-			$.vakata.context.par = p || t || null;
-			$.vakata.context.data = d || null;
-			$.vakata.context.cnt
-				.html(html)
-				.css({ "visibility" : "hidden", "display" : "block", "left" : 0, "top" : 0 });
-			h = $.vakata.context.cnt.height();
-			w = $.vakata.context.cnt.width();
-			if(x + w > $(document).width()) { 
-				x = $(document).width() - (w + 5); 
-				$.vakata.context.cnt.find("li > ul").addClass("right"); 
-			}
-			if(y + h > $(document).height()) { 
-				y = y - (h + t[0].offsetHeight); 
-				$.vakata.context.cnt.find("li > ul").addClass("bottom"); 
-			}
-
-			$.vakata.context.cnt
-				.css({ "left" : x, "top" : y })
-				.find("li:has(ul)")
-					.bind("mouseenter", function (e) { 
-						var w = $(document).width(),
-							h = $(document).height(),
-							ul = $(this).children("ul").show(); 
-						if(w !== $(document).width()) { ul.toggleClass("right"); }
-						if(h !== $(document).height()) { ul.toggleClass("bottom"); }
-					})
-					.bind("mouseleave", function (e) { 
-						$(this).children("ul").hide(); 
-					})
-					.end()
-				.css({ "visibility" : "visible" })
-				.show();
-			$(document).triggerHandler("context_show.vakata");
-		},
-		hide	: function () {
-			$.vakata.context.vis = false;
-			$.vakata.context.cnt.attr("class","").hide();
-			$(document).triggerHandler("context_hide.vakata");
-		},
-		parse	: function (s, is_callback) {
-			if(!s) { return false; }
-			var str = "",
-				tmp = false,
-				was_sep = true;
-			if(!is_callback) { $.vakata.context.func = {}; }
-			str += "<ul>";
-			$.each(s, function (i, val) {
-				if(!val) { return true; }
-				$.vakata.context.func[i] = val.action;
-				if(!was_sep && val.separator_before) {
-					str += "<li class='vakata-separator vakata-separator-before'></li>";
-				}
-				was_sep = false;
-				str += "<li class='" + (val._class || "") + (val._disabled ? " jstree-contextmenu-disabled " : "") + "'><ins ";
-				if(val.icon && val.icon.indexOf("/") === -1) { str += " class='" + val.icon + "' "; }
-				if(val.icon && val.icon.indexOf("/") !== -1) { str += " style='background:url(" + val.icon + ") center center no-repeat;' "; }
-				str += ">&#160;</ins><a href='#' rel='" + i + "'>";
-				if(val.submenu) {
-					str += "<span style='float:right;'>&raquo;</span>";
-				}
-				str += val.label + "</a>";
-				if(val.submenu) {
-					tmp = $.vakata.context.parse(val.submenu, true);
-					if(tmp) { str += tmp; }
-				}
-				str += "</li>";
-				if(val.separator_after) {
-					str += "<li class='vakata-separator vakata-separator-after'></li>";
-					was_sep = true;
-				}
-			});
-			str = str.replace(/<li class\='vakata-separator vakata-separator-after'\><\/li\>$/,"");
-			str += "</ul>";
-			return str.length > 10 ? str : false;
-		},
-		exec	: function (i) {
-			if($.isFunction($.vakata.context.func[i])) {
-				$.vakata.context.func[i].call($.vakata.context.data, $.vakata.context.par);
-				return true;
-			}
-			else { return false; }
-		}
-	};
-	$(function () {
-		var css_string = '' + 
-			'#vakata-contextmenu { display:none; position:absolute; margin:0; padding:0; min-width:180px; background:#ebebeb; border:1px solid silver; z-index:10000; *width:180px; } ' + 
-			'#vakata-contextmenu ul { min-width:180px; *width:180px; } ' + 
-			'#vakata-contextmenu ul, #vakata-contextmenu li { margin:0; padding:0; list-style-type:none; display:block; } ' + 
-			'#vakata-contextmenu li { line-height:20px; min-height:20px; position:relative; padding:0px; } ' + 
-			'#vakata-contextmenu li a { padding:1px 6px; line-height:17px; display:block; text-decoration:none; margin:1px 1px 0 1px; } ' + 
-			'#vakata-contextmenu li ins { float:left; width:16px; height:16px; text-decoration:none; margin-right:2px; } ' + 
-			'#vakata-contextmenu li a:hover, #vakata-contextmenu li.vakata-hover > a { background:gray; color:white; } ' + 
-			'#vakata-contextmenu li ul { display:none; position:absolute; top:-2px; left:100%; background:#ebebeb; border:1px solid gray; } ' + 
-			'#vakata-contextmenu .right { right:100%; left:auto; } ' + 
-			'#vakata-contextmenu .bottom { bottom:-1px; top:auto; } ' + 
-			'#vakata-contextmenu li.vakata-separator { min-height:0; height:1px; line-height:1px; font-size:1px; overflow:hidden; margin:0 2px; background:silver; /* border-top:1px solid #fefefe; */ padding:0; } ';
-		$.vakata.css.add_sheet({ str : css_string });
-		$.vakata.context.cnt
-			.delegate("a","click", function (e) { e.preventDefault(); })
-			.delegate("a","mouseup", function (e) {
-				if(!$(this).parent().hasClass("jstree-contextmenu-disabled") && $.vakata.context.exec($(this).attr("rel"))) {
-					$.vakata.context.hide();
-				}
-				else { $(this).blur(); }
-			})
-			.delegate("a","mouseover", function () {
-				$.vakata.context.cnt.find(".vakata-hover").removeClass("vakata-hover");
-			})
-			.appendTo("body");
-		$(document).bind("mousedown", function (e) { if($.vakata.context.vis && !$.contains($.vakata.context.cnt[0], e.target)) { $.vakata.context.hide(); } });
-		if(typeof $.hotkeys !== "undefined") {
-			$(document)
-				.bind("keydown", "up", function (e) { 
-					if($.vakata.context.vis) { 
-						var o = $.vakata.context.cnt.find("ul:visible").last().children(".vakata-hover").removeClass("vakata-hover").prevAll("li:not(.vakata-separator)").first();
-						if(!o.length) { o = $.vakata.context.cnt.find("ul:visible").last().children("li:not(.vakata-separator)").last(); }
-						o.addClass("vakata-hover");
-						e.stopImmediatePropagation(); 
-						e.preventDefault();
-					} 
-				})
-				.bind("keydown", "down", function (e) { 
-					if($.vakata.context.vis) { 
-						var o = $.vakata.context.cnt.find("ul:visible").last().children(".vakata-hover").removeClass("vakata-hover").nextAll("li:not(.vakata-separator)").first();
-						if(!o.length) { o = $.vakata.context.cnt.find("ul:visible").last().children("li:not(.vakata-separator)").first(); }
-						o.addClass("vakata-hover");
-						e.stopImmediatePropagation(); 
-						e.preventDefault();
-					} 
-				})
-				.bind("keydown", "right", function (e) { 
-					if($.vakata.context.vis) { 
-						$.vakata.context.cnt.find(".vakata-hover").children("ul").show().children("li:not(.vakata-separator)").removeClass("vakata-hover").first().addClass("vakata-hover");
-						e.stopImmediatePropagation(); 
-						e.preventDefault();
-					} 
-				})
-				.bind("keydown", "left", function (e) { 
-					if($.vakata.context.vis) { 
-						$.vakata.context.cnt.find(".vakata-hover").children("ul").hide().children(".vakata-separator").removeClass("vakata-hover");
-						e.stopImmediatePropagation(); 
-						e.preventDefault();
-					} 
-				})
-				.bind("keydown", "esc", function (e) { 
-					$.vakata.context.hide(); 
-					e.preventDefault();
-				})
-				.bind("keydown", "space", function (e) { 
-					$.vakata.context.cnt.find(".vakata-hover").last().children("a").click();
-					e.preventDefault();
-				});
-		}
-	});
-
-	$.jstree.plugin("contextmenu", {
-		__init : function () {
-			this.get_container()
-				.delegate("a", "contextmenu.jstree", $.proxy(function (e) {
-						e.preventDefault();
-						this.show_contextmenu(e.currentTarget, e.pageX, e.pageY);
-					}, this))
-				.bind("destroy.jstree", $.proxy(function () {
-						if(this.data.contextmenu) {
-							$.vakata.context.hide();
-						}
-					}, this));
-			$(document).bind("context_hide.vakata", $.proxy(function () { this.data.contextmenu = false; }, this));
-		},
-		defaults : { 
-			select_node : false, // requires UI plugin
-			show_at_node : true,
-			items : { // Could be a function that should return an object like this one
-				"create" : {
-					"separator_before"	: false,
-					"separator_after"	: true,
-					"label"				: "Create",
-					"action"			: function (obj) { this.create(obj); }
-				},
-				"rename" : {
-					"separator_before"	: false,
-					"separator_after"	: false,
-					"label"				: "Rename",
-					"action"			: function (obj) { this.rename(obj); }
-				},
-				"remove" : {
-					"separator_before"	: false,
-					"icon"				: false,
-					"separator_after"	: false,
-					"label"				: "Delete",
-					"action"			: function (obj) { this.remove(obj); }
-				},
-				"ccp" : {
-					"separator_before"	: true,
-					"icon"				: false,
-					"separator_after"	: false,
-					"label"				: "Edit",
-					"action"			: false,
-					"submenu" : { 
-						"cut" : {
-							"separator_before"	: false,
-							"separator_after"	: false,
-							"label"				: "Cut",
-							"action"			: function (obj) { this.cut(obj); }
-						},
-						"copy" : {
-							"separator_before"	: false,
-							"icon"				: false,
-							"separator_after"	: false,
-							"label"				: "Copy",
-							"action"			: function (obj) { this.copy(obj); }
-						},
-						"paste" : {
-							"separator_before"	: false,
-							"icon"				: false,
-							"separator_after"	: false,
-							"label"				: "Paste",
-							"action"			: function (obj) { this.paste(obj); }
-						}
-					}
-				}
-			}
-		},
-		_fn : {
-			show_contextmenu : function (obj, x, y) {
-				obj = this._get_node(obj);
-				var s = this.get_settings().contextmenu,
-					a = obj.children("a:visible:eq(0)"),
-					o = false;
-				if(s.select_node && this.data.ui && !this.is_selected(obj)) {
-					this.deselect_all();
-					this.select_node(obj, true);
-				}
-				if(s.show_at_node || typeof x === "undefined" || typeof y === "undefined") {
-					o = a.offset();
-					x = o.left;
-					y = o.top + this.data.core.li_height;
-				}
-				if($.isFunction(s.items)) { s.items = s.items.call(this, obj); }
-				this.data.contextmenu = true;
-				$.vakata.context.show(s.items, a, x, y, this, obj);
-				if(this.data.themes) { $.vakata.context.cnt.attr("class", "jstree-" + this.data.themes.theme + "-context"); }
-			}
-		}
-	});
+  $.vakata.context = {
+    cnt    : $("<div id='vakata-contextmenu'>"),
+    vis    : false,
+    tgt    : false,
+    par    : false,
+    func  : false,
+    data  : false,
+    show  : function (s, t, x, y, d, p) {
+      var html = $.vakata.context.parse(s), h, w;
+      if(!html) { return; }
+      $.vakata.context.vis = true;
+      $.vakata.context.tgt = t;
+      $.vakata.context.par = p || t || null;
+      $.vakata.context.data = d || null;
+      $.vakata.context.cnt
+        .html(html)
+        .css({ "visibility" : "hidden", "display" : "block", "left" : 0, "top" : 0 });
+      h = $.vakata.context.cnt.height();
+      w = $.vakata.context.cnt.width();
+      if(x + w > $(document).width()) { 
+        x = $(document).width() - (w + 5); 
+        $.vakata.context.cnt.find("li > ul").addClass("right"); 
+      }
+      if(y + h > $(document).height()) { 
+        y = y - (h + t[0].offsetHeight); 
+        $.vakata.context.cnt.find("li > ul").addClass("bottom"); 
+      }
+
+      $.vakata.context.cnt
+        .css({ "left" : x, "top" : y })
+        .find("li:has(ul)")
+          .bind("mouseenter", function (e) { 
+            var w = $(document).width(),
+              h = $(document).height(),
+              ul = $(this).children("ul").show(); 
+            if(w !== $(document).width()) { ul.toggleClass("right"); }
+            if(h !== $(document).height()) { ul.toggleClass("bottom"); }
+          })
+          .bind("mouseleave", function (e) { 
+            $(this).children("ul").hide(); 
+          })
+          .end()
+        .css({ "visibility" : "visible" })
+        .show();
+      $(document).triggerHandler("context_show.vakata");
+    },
+    hide  : function () {
+      $.vakata.context.vis = false;
+      $.vakata.context.cnt.attr("class","").hide();
+      $(document).triggerHandler("context_hide.vakata");
+    },
+    parse  : function (s, is_callback) {
+      if(!s) { return false; }
+      var str = "",
+        tmp = false,
+        was_sep = true;
+      if(!is_callback) { $.vakata.context.func = {}; }
+      str += "<ul>";
+      $.each(s, function (i, val) {
+        if(!val) { return true; }
+        $.vakata.context.func[i] = val.action;
+        if(!was_sep && val.separator_before) {
+          str += "<li class='vakata-separator vakata-separator-before'></li>";
+        }
+        was_sep = false;
+        str += "<li class='" + (val._class || "") + (val._disabled ? " jstree-contextmenu-disabled " : "") + "'><ins ";
+        if(val.icon && val.icon.indexOf("/") === -1) { str += " class='" + val.icon + "' "; }
+        if(val.icon && val.icon.indexOf("/") !== -1) { str += " style='background:url(" + val.icon + ") center center no-repeat;' "; }
+        str += ">&#160;</ins><a href='#' rel='" + i + "'>";
+        if(val.submenu) {
+          str += "<span style='float:right;'>&raquo;</span>";
+        }
+        str += val.label + "</a>";
+        if(val.submenu) {
+          tmp = $.vakata.context.parse(val.submenu, true);
+          if(tmp) { str += tmp; }
+        }
+        str += "</li>";
+        if(val.separator_after) {
+          str += "<li class='vakata-separator vakata-separator-after'></li>";
+          was_sep = true;
+        }
+      });
+      str = str.replace(/<li class\='vakata-separator vakata-separator-after'\><\/li\>$/,"");
+      str += "</ul>";
+      return str.length > 10 ? str : false;
+    },
+    exec  : function (i) {
+      if($.isFunction($.vakata.context.func[i])) {
+        $.vakata.context.func[i].call($.vakata.context.data, $.vakata.context.par);
+        return true;
+      }
+      else { return false; }
+    }
+  };
+  $(function () {
+    var css_string = '' + 
+      '#vakata-contextmenu { display:none; position:absolute; margin:0; padding:0; min-width:180px; background:#ebebeb; border:1px solid silver; z-index:10000; *width:180px; } ' + 
+      '#vakata-contextmenu ul { min-width:180px; *width:180px; } ' + 
+      '#vakata-contextmenu ul, #vakata-contextmenu li { margin:0; padding:0; list-style-type:none; display:block; } ' + 
+      '#vakata-contextmenu li { line-height:20px; min-height:20px; position:relative; padding:0px; } ' + 
+      '#vakata-contextmenu li a { padding:1px 6px; line-height:17px; display:block; text-decoration:none; margin:1px 1px 0 1px; } ' + 
+      '#vakata-contextmenu li ins { float:left; width:16px; height:16px; text-decoration:none; margin-right:2px; } ' + 
+      '#vakata-contextmenu li a:hover, #vakata-contextmenu li.vakata-hover > a { background:gray; color:white; } ' + 
+      '#vakata-contextmenu li ul { display:none; position:absolute; top:-2px; left:100%; background:#ebebeb; border:1px solid gray; } ' + 
+      '#vakata-contextmenu .right { right:100%; left:auto; } ' + 
+      '#vakata-contextmenu .bottom { bottom:-1px; top:auto; } ' + 
+      '#vakata-contextmenu li.vakata-separator { min-height:0; height:1px; line-height:1px; font-size:1px; overflow:hidden; margin:0 2px; background:silver; /* border-top:1px solid #fefefe; */ padding:0; } ';
+    $.vakata.css.add_sheet({ str : css_string });
+    $.vakata.context.cnt
+      .delegate("a","click", function (e) { e.preventDefault(); })
+      .delegate("a","mouseup", function (e) {
+        if(!$(this).parent().hasClass("jstree-contextmenu-disabled") && $.vakata.context.exec($(this).attr("rel"))) {
+          $.vakata.context.hide();
+        }
+        else { $(this).blur(); }
+      })
+      .delegate("a","mouseover", function () {
+        $.vakata.context.cnt.find(".vakata-hover").removeClass("vakata-hover");
+      })
+      .appendTo("body");
+    $(document).bind("mousedown", function (e) { if($.vakata.context.vis && !$.contains($.vakata.context.cnt[0], e.target)) { $.vakata.context.hide(); } });
+    if(typeof $.hotkeys !== "undefined") {
+      $(document)
+        .bind("keydown", "up", function (e) { 
+          if($.vakata.context.vis) { 
+            var o = $.vakata.context.cnt.find("ul:visible").last().children(".vakata-hover").removeClass("vakata-hover").prevAll("li:not(.vakata-separator)").first();
+            if(!o.length) { o = $.vakata.context.cnt.find("ul:visible").last().children("li:not(.vakata-separator)").last(); }
+            o.addClass("vakata-hover");
+            e.stopImmediatePropagation(); 
+            e.preventDefault();
+          } 
+        })
+        .bind("keydown", "down", function (e) { 
+          if($.vakata.context.vis) { 
+            var o = $.vakata.context.cnt.find("ul:visible").last().children(".vakata-hover").removeClass("vakata-hover").nextAll("li:not(.vakata-separator)").first();
+            if(!o.length) { o = $.vakata.context.cnt.find("ul:visible").last().children("li:not(.vakata-separator)").first(); }
+            o.addClass("vakata-hover");
+            e.stopImmediatePropagation(); 
+            e.preventDefault();
+          } 
+        })
+        .bind("keydown", "right", function (e) { 
+          if($.vakata.context.vis) { 
+            $.vakata.context.cnt.find(".vakata-hover").children("ul").show().children("li:not(.vakata-separator)").removeClass("vakata-hover").first().addClass("vakata-hover");
+            e.stopImmediatePropagation(); 
+            e.preventDefault();
+          } 
+        })
+        .bind("keydown", "left", function (e) { 
+          if($.vakata.context.vis) { 
+            $.vakata.context.cnt.find(".vakata-hover").children("ul").hide().children(".vakata-separator").removeClass("vakata-hover");
+            e.stopImmediatePropagation(); 
+            e.preventDefault();
+          } 
+        })
+        .bind("keydown", "esc", function (e) { 
+          $.vakata.context.hide(); 
+          e.preventDefault();
+        })
+        .bind("keydown", "space", function (e) { 
+          $.vakata.context.cnt.find(".vakata-hover").last().children("a").click();
+          e.preventDefault();
+        });
+    }
+  });
+
+  $.jstree.plugin("contextmenu", {
+    __init : function () {
+      this.get_container()
+        .delegate("a", "contextmenu.jstree", $.proxy(function (e) {
+            e.preventDefault();
+            this.show_contextmenu(e.currentTarget, e.pageX, e.pageY);
+          }, this))
+        .bind("destroy.jstree", $.proxy(function () {
+            if(this.data.contextmenu) {
+              $.vakata.context.hide();
+            }
+          }, this));
+      $(document).bind("context_hide.vakata", $.proxy(function () { this.data.contextmenu = false; }, this));
+    },
+    defaults : { 
+      select_node : false, // requires UI plugin
+      show_at_node : true,
+      items : { // Could be a function that should return an object like this one
+        "create" : {
+          "separator_before"  : false,
+          "separator_after"  : true,
+          "label"        : "Create",
+          "action"      : function (obj) { this.create(obj); }
+        },
+        "rename" : {
+          "separator_before"  : false,
+          "separator_after"  : false,
+          "label"        : "Rename",
+          "action"      : function (obj) { this.rename(obj); }
+        },
+        "remove" : {
+          "separator_before"  : false,
+          "icon"        : false,
+          "separator_after"  : false,
+          "label"        : "Delete",
+          "action"      : function (obj) { this.remove(obj); }
+        },
+        "ccp" : {
+          "separator_before"  : true,
+          "icon"        : false,
+          "separator_after"  : false,
+          "label"        : "Edit",
+          "action"      : false,
+          "submenu" : { 
+            "cut" : {
+              "separator_before"  : false,
+              "separator_after"  : false,
+              "label"        : "Cut",
+              "action"      : function (obj) { this.cut(obj); }
+            },
+            "copy" : {
+              "separator_before"  : false,
+              "icon"        : false,
+              "separator_after"  : false,
+              "label"        : "Copy",
+              "action"      : function (obj) { this.copy(obj); }
+            },
+            "paste" : {
+              "separator_before"  : false,
+              "icon"        : false,
+              "separator_after"  : false,
+              "label"        : "Paste",
+              "action"      : function (obj) { this.paste(obj); }
+            }
+          }
+        }
+      }
+    },
+    _fn : {
+      show_contextmenu : function (obj, x, y) {
+        obj = this._get_node(obj);
+        var s = this.get_settings().contextmenu,
+          a = obj.children("a:visible:eq(0)"),
+          o = false;
+        if(s.select_node && this.data.ui && !this.is_selected(obj)) {
+          this.deselect_all();
+          this.select_node(obj, true);
+        }
+        if(s.show_at_node || typeof x === "undefined" || typeof y === "undefined") {
+          o = a.offset();
+          x = o.left;
+          y = o.top + this.data.core.li_height;
+        }
+        if($.isFunction(s.items)) { s.items = s.items.call(this, obj); }
+        this.data.contextmenu = true;
+        $.vakata.context.show(s.items, a, x, y, this, obj);
+        if(this.data.themes) { $.vakata.context.cnt.attr("class", "jstree-" + this.data.themes.theme + "-context"); }
+      }
+    }
+  });
 })(jQuery);
 //*/
 
@@ -3090,178 +3090,178 @@ THE SOFTWARE.
  * According to the type setting the node may get custom icon/validation rules
  */
 (function ($) {
-	$.jstree.plugin("types", {
-		__init : function () {
-			var s = this._get_settings().types;
-			this.data.types.attach_to = [];
-			this.get_container()
-				.bind("init.jstree", $.proxy(function () { 
-						var types = s.types, 
-							attr  = s.type_attr, 
-							icons_css = "", 
-							_this = this;
-
-						$.each(types, function (i, tp) {
-							$.each(tp, function (k, v) { 
-								if(!/^(max_depth|max_children|icon|valid_children)$/.test(k)) { _this.data.types.attach_to.push(k); }
-							});
-							if(!tp.icon) { return true; }
-							if( tp.icon.image || tp.icon.position) {
-								if(i == "default")	{ icons_css += '.jstree-' + _this.get_index() + ' a > .jstree-icon { '; }
-								else				{ icons_css += '.jstree-' + _this.get_index() + ' li[' + attr + '=' + i + '] > a > .jstree-icon { '; }
-								if(tp.icon.image)	{ icons_css += ' background-image:url(' + tp.icon.image + '); '; }
-								if(tp.icon.position){ icons_css += ' background-position:' + tp.icon.position + '; '; }
-								else				{ icons_css += ' background-position:0 0; '; }
-								icons_css += '} ';
-							}
-						});
-						if(icons_css != "") { $.vakata.css.add_sheet({ 'str' : icons_css }); }
-					}, this))
-				.bind("before.jstree", $.proxy(function (e, data) { 
-						if($.inArray(data.func, this.data.types.attach_to) !== -1) {
-							var s = this._get_settings().types.types,
-								t = this._get_type(data.args[0]);
-							if(
-								( 
-									(s[t] && typeof s[t][data.func] !== "undefined") || 
-									(s["default"] && typeof s["default"][data.func] !== "undefined")
-								) && !this._check(data.func, data.args[0])
-							) {
-								e.stopImmediatePropagation();
-								return false;
-							}
-						}
-					}, this));
-		},
-		defaults : {
-			// defines maximum number of root nodes (-1 means unlimited, -2 means disable max_children checking)
-			max_children		: -1,
-			// defines the maximum depth of the tree (-1 means unlimited, -2 means disable max_depth checking)
-			max_depth			: -1,
-			// defines valid node types for the root nodes
-			valid_children		: "all",
-
-			// where is the type stores (the rel attribute of the LI element)
-			type_attr : "rel",
-			// a list of types
-			types : {
-				// the default type
-				"default" : {
-					"max_children"	: -1,
-					"max_depth"		: -1,
-					"valid_children": "all"
-
-					// Bound functions - you can bind any other function here (using boolean or function)
-					//"select_node"	: true,
-					//"open_node"	: true,
-					//"close_node"	: true,
-					//"create_node"	: true,
-					//"delete_node"	: true
-				}
-			}
-		},
-		_fn : {
-			_get_type : function (obj) {
-				obj = this._get_node(obj);
-				return (!obj || !obj.length) ? false : obj.attr(this._get_settings().types.type_attr) || "default";
-			},
-			set_type : function (str, obj) {
-				obj = this._get_node(obj);
-				return (!obj.length || !str) ? false : obj.attr(this._get_settings().types.type_attr, str);
-			},
-			_check : function (rule, obj, opts) {
-				var v = false, t = this._get_type(obj), d = 0, _this = this, s = this._get_settings().types;
-				if(obj === -1) { 
-					if(!!s[rule]) { v = s[rule]; }
-					else { return; }
-				}
-				else {
-					if(t === false) { return; }
-					if(!!s.types[t] && !!s.types[t][rule]) { v = s.types[t][rule]; }
-					else if(!!s.types["default"] && !!s.types["default"][rule]) { v = s.types["default"][rule]; }
-				}
-				if($.isFunction(v)) { v = v.call(this, obj); }
-				if(rule === "max_depth" && obj !== -1 && opts !== false && s.max_depth !== -2 && v !== 0) {
-					// also include the node itself - otherwise if root node it is not checked
-					this._get_node(obj).children("a:eq(0)").parentsUntil(".jstree","li").each(function (i) {
-						// check if current depth already exceeds global tree depth
-						if(s.max_depth !== -1 && s.max_depth - (i + 1) <= 0) { v = 0; return false; }
-						d = (i === 0) ? v : _this._check(rule, this, false);
-						// check if current node max depth is already matched or exceeded
-						if(d !== -1 && d - (i + 1) <= 0) { v = 0; return false; }
-						// otherwise - set the max depth to the current value minus current depth
-						if(d >= 0 && (d - (i + 1) < v || v < 0) ) { v = d - (i + 1); }
-						// if the global tree depth exists and it minus the nodes calculated so far is less than `v` or `v` is unlimited
-						if(s.max_depth >= 0 && (s.max_depth - (i + 1) < v || v < 0) ) { v = s.max_depth - (i + 1); }
-					});
-				}
-				return v;
-			},
-			check_move : function () {
-				if(!this.__call_old()) { return false; }
-				var m  = this._get_move(),
-					s  = m.rt._get_settings().types,
-					mc = m.rt._check("max_children", m.cr),
-					md = m.rt._check("max_depth", m.cr),
-					vc = m.rt._check("valid_children", m.cr),
-					ch = 0, d = 1, t;
-
-				if(vc === "none") { return false; } 
-				if($.isArray(vc) && m.ot && m.ot._get_type) {
-					m.o.each(function () {
-						if($.inArray(m.ot._get_type(this), vc) === -1) { d = false; return false; }
-					});
-					if(d === false) { return false; }
-				}
-				if(s.max_children !== -2 && mc !== -1) {
-					ch = m.cr === -1 ? this.get_container().children("> ul > li").not(m.o).length : m.cr.children("> ul > li").not(m.o).length;
-					if(ch + m.o.length > mc) { return false; }
-				}
-				if(s.max_depth !== -2 && md !== -1) {
-					d = 0;
-					if(md === 0) { return false; }
-					if(typeof m.o.d === "undefined") {
-						// TODO: deal with progressive rendering and async when checking max_depth (how to know the depth of the moved node)
-						t = m.o;
-						while(t.length > 0) {
-							t = t.find("> ul > li");
-							d ++;
-						}
-						m.o.d = d;
-					}
-					if(md - m.o.d < 0) { return false; }
-				}
-				return true;
-			},
-			create_node : function (obj, position, js, callback, is_loaded, skip_check) {
-				if(!skip_check && (is_loaded || this._is_loaded(obj))) {
-					var p  = (position && position.match(/^before|after$/i) && obj !== -1) ? this._get_parent(obj) : this._get_node(obj),
-						s  = this._get_settings().types,
-						mc = this._check("max_children", p),
-						md = this._check("max_depth", p),
-						vc = this._check("valid_children", p),
-						ch;
-					if(!js) { js = {}; }
-					if(vc === "none") { return false; } 
-					if($.isArray(vc)) {
-						if(!js.attr || !js.attr[s.type_attr]) { 
-							if(!js.attr) { js.attr = {}; }
-							js.attr[s.type_attr] = vc[0]; 
-						}
-						else {
-							if($.inArray(js.attr[s.type_attr], vc) === -1) { return false; }
-						}
-					}
-					if(s.max_children !== -2 && mc !== -1) {
-						ch = p === -1 ? this.get_container().children("> ul > li").length : p.children("> ul > li").length;
-						if(ch + 1 > mc) { return false; }
-					}
-					if(s.max_depth !== -2 && md !== -1 && (md - 1) < 0) { return false; }
-				}
-				return this.__call_old(true, obj, position, js, callback, is_loaded, skip_check);
-			}
-		}
-	});
+  $.jstree.plugin("types", {
+    __init : function () {
+      var s = this._get_settings().types;
+      this.data.types.attach_to = [];
+      this.get_container()
+        .bind("init.jstree", $.proxy(function () { 
+            var types = s.types, 
+              attr  = s.type_attr, 
+              icons_css = "", 
+              _this = this;
+
+            $.each(types, function (i, tp) {
+              $.each(tp, function (k, v) { 
+                if(!/^(max_depth|max_children|icon|valid_children)$/.test(k)) { _this.data.types.attach_to.push(k); }
+              });
+              if(!tp.icon) { return true; }
+              if( tp.icon.image || tp.icon.position) {
+                if(i == "default")  { icons_css += '.jstree-' + _this.get_index() + ' a > .jstree-icon { '; }
+                else        { icons_css += '.jstree-' + _this.get_index() + ' li[' + attr + '=' + i + '] > a > .jstree-icon { '; }
+                if(tp.icon.image)  { icons_css += ' background-image:url(' + tp.icon.image + '); '; }
+                if(tp.icon.position){ icons_css += ' background-position:' + tp.icon.position + '; '; }
+                else        { icons_css += ' background-position:0 0; '; }
+                icons_css += '} ';
+              }
+            });
+            if(icons_css != "") { $.vakata.css.add_sheet({ 'str' : icons_css }); }
+          }, this))
+        .bind("before.jstree", $.proxy(function (e, data) { 
+            if($.inArray(data.func, this.data.types.attach_to) !== -1) {
+              var s = this._get_settings().types.types,
+                t = this._get_type(data.args[0]);
+              if(
+                ( 
+                  (s[t] && typeof s[t][data.func] !== "undefined") || 
+                  (s["default"] && typeof s["default"][data.func] !== "undefined")
+                ) && !this._check(data.func, data.args[0])
+              ) {
+                e.stopImmediatePropagation();
+                return false;
+              }
+            }
+          }, this));
+    },
+    defaults : {
+      // defines maximum number of root nodes (-1 means unlimited, -2 means disable max_children checking)
+      max_children    : -1,
+      // defines the maximum depth of the tree (-1 means unlimited, -2 means disable max_depth checking)
+      max_depth      : -1,
+      // defines valid node types for the root nodes
+      valid_children    : "all",
+
+      // where is the type stores (the rel attribute of the LI element)
+      type_attr : "rel",
+      // a list of types
+      types : {
+        // the default type
+        "default" : {
+          "max_children"  : -1,
+          "max_depth"    : -1,
+          "valid_children": "all"
+
+          // Bound functions - you can bind any other function here (using boolean or function)
+          //"select_node"  : true,
+          //"open_node"  : true,
+          //"close_node"  : true,
+          //"create_node"  : true,
+          //"delete_node"  : true
+        }
+      }
+    },
+    _fn : {
+      _get_type : function (obj) {
+        obj = this._get_node(obj);
+        return (!obj || !obj.length) ? false : obj.attr(this._get_settings().types.type_attr) || "default";
+      },
+      set_type : function (str, obj) {
+        obj = this._get_node(obj);
+        return (!obj.length || !str) ? false : obj.attr(this._get_settings().types.type_attr, str);
+      },
+      _check : function (rule, obj, opts) {
+        var v = false, t = this._get_type(obj), d = 0, _this = this, s = this._get_settings().types;
+        if(obj === -1) { 
+          if(!!s[rule]) { v = s[rule]; }
+          else { return; }
+        }
+        else {
+          if(t === false) { return; }
+          if(!!s.types[t] && !!s.types[t][rule]) { v = s.types[t][rule]; }
+          else if(!!s.types["default"] && !!s.types["default"][rule]) { v = s.types["default"][rule]; }
+        }
+        if($.isFunction(v)) { v = v.call(this, obj); }
+        if(rule === "max_depth" && obj !== -1 && opts !== false && s.max_depth !== -2 && v !== 0) {
+          // also include the node itself - otherwise if root node it is not checked
+          this._get_node(obj).children("a:eq(0)").parentsUntil(".jstree","li").each(function (i) {
+            // check if current depth already exceeds global tree depth
+            if(s.max_depth !== -1 && s.max_depth - (i + 1) <= 0) { v = 0; return false; }
+            d = (i === 0) ? v : _this._check(rule, this, false);
+            // check if current node max depth is already matched or exceeded
+            if(d !== -1 && d - (i + 1) <= 0) { v = 0; return false; }
+            // otherwise - set the max depth to the current value minus current depth
+            if(d >= 0 && (d - (i + 1) < v || v < 0) ) { v = d - (i + 1); }
+            // if the global tree depth exists and it minus the nodes calculated so far is less than `v` or `v` is unlimited
+            if(s.max_depth >= 0 && (s.max_depth - (i + 1) < v || v < 0) ) { v = s.max_depth - (i + 1); }
+          });
+        }
+        return v;
+      },
+      check_move : function () {
+        if(!this.__call_old()) { return false; }
+        var m  = this._get_move(),
+          s  = m.rt._get_settings().types,
+          mc = m.rt._check("max_children", m.cr),
+          md = m.rt._check("max_depth", m.cr),
+          vc = m.rt._check("valid_children", m.cr),
+          ch = 0, d = 1, t;
+
+        if(vc === "none") { return false; } 
+        if($.isArray(vc) && m.ot && m.ot._get_type) {
+          m.o.each(function () {
+            if($.inArray(m.ot._get_type(this), vc) === -1) { d = false; return false; }
+          });
+          if(d === false) { return false; }
+        }
+        if(s.max_children !== -2 && mc !== -1) {
+          ch = m.cr === -1 ? this.get_container().children("> ul > li").not(m.o).length : m.cr.children("> ul > li").not(m.o).length;
+          if(ch + m.o.length > mc) { return false; }
+        }
+        if(s.max_depth !== -2 && md !== -1) {
+          d = 0;
+          if(md === 0) { return false; }
+          if(typeof m.o.d === "undefined") {
+            // TODO: deal with progressive rendering and async when checking max_depth (how to know the depth of the moved node)
+            t = m.o;
+            while(t.length > 0) {
+              t = t.find("> ul > li");
+              d ++;
+            }
+            m.o.d = d;
+          }
+          if(md - m.o.d < 0) { return false; }
+        }
+        return true;
+      },
+      create_node : function (obj, position, js, callback, is_loaded, skip_check) {
+        if(!skip_check && (is_loaded || this._is_loaded(obj))) {
+          var p  = (position && position.match(/^before|after$/i) && obj !== -1) ? this._get_parent(obj) : this._get_node(obj),
+            s  = this._get_settings().types,
+            mc = this._check("max_children", p),
+            md = this._check("max_depth", p),
+            vc = this._check("valid_children", p),
+            ch;
+          if(!js) { js = {}; }
+          if(vc === "none") { return false; } 
+          if($.isArray(vc)) {
+            if(!js.attr || !js.attr[s.type_attr]) { 
+              if(!js.attr) { js.attr = {}; }
+              js.attr[s.type_attr] = vc[0]; 
+            }
+            else {
+              if($.inArray(js.attr[s.type_attr], vc) === -1) { return false; }
+            }
+          }
+          if(s.max_children !== -2 && mc !== -1) {
+            ch = p === -1 ? this.get_container().children("> ul > li").length : p.children("> ul > li").length;
+            if(ch + 1 > mc) { return false; }
+          }
+          if(s.max_depth !== -2 && md !== -1 && (md - 1) < 0) { return false; }
+        }
+        return this.__call_old(true, obj, position, js, callback, is_loaded, skip_check);
+      }
+    }
+  });
 })(jQuery);
 //*/
 
@@ -3270,118 +3270,118 @@ THE SOFTWARE.
  * The HTML data store. Datastores are build by replacing the `load_node` and `_is_loaded` functions.
  */
 (function ($) {
-	$.jstree.plugin("html_data", {
-		__init : function () { 
-			// this used to use html() and clean the whitespace, but this way any attached data was lost
-			this.data.html_data.original_container_html = this.get_container().find(" > ul > li").clone(true);
-			// remove white space from LI node - otherwise nodes appear a bit to the right
-			this.data.html_data.original_container_html.find("li").andSelf().contents().filter(function() { return this.nodeType == 3; }).remove();
-		},
-		defaults : { 
-			data : false,
-			ajax : false,
-			correct_state : true
-		},
-		_fn : {
-			load_node : function (obj, s_call, e_call) { var _this = this; this.load_node_html(obj, function () { _this.__callback({ "obj" : obj }); s_call.call(this); }, e_call); },
-			_is_loaded : function (obj) { 
-				obj = this._get_node(obj); 
-				return obj == -1 || !obj || !this._get_settings().html_data.ajax || obj.is(".jstree-open, .jstree-leaf") || obj.children("ul").children("li").size() > 0;
-			},
-			load_node_html : function (obj, s_call, e_call) {
-				var d,
-					s = this.get_settings().html_data,
-					error_func = function () {},
-					success_func = function () {};
-				obj = this._get_node(obj);
-				if(obj && obj !== -1) {
-					if(obj.data("jstree-is-loading")) { return; }
-					else { obj.data("jstree-is-loading",true); }
-				}
-				switch(!0) {
-					case (!s.data && !s.ajax):
-						if(!obj || obj == -1) {
-							this.get_container()
-								.children("ul").empty()
-								.append(this.data.html_data.original_container_html)
-								.find("li, a").filter(function () { return this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end()
-								.filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon");
-							this.clean_node();
-						}
-						if(s_call) { s_call.call(this); }
-						break;
-					case (!!s.data && !s.ajax) || (!!s.data && !!s.ajax && (!obj || obj === -1)):
-						if(!obj || obj == -1) {
-							d = $(s.data);
-							if(!d.is("ul")) { d = $("<ul>").append(d); }
-							this.get_container()
-								.children("ul").empty().append(d.children())
-								.find("li, a").filter(function () { return this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end()
-								.filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon");
-							this.clean_node();
-						}
-						if(s_call) { s_call.call(this); }
-						break;
-					case (!s.data && !!s.ajax) || (!!s.data && !!s.ajax && obj && obj !== -1):
-						obj = this._get_node(obj);
-						error_func = function (x, t, e) {
-							var ef = this.get_settings().html_data.ajax.error; 
-							if(ef) { ef.call(this, x, t, e); }
-							if(obj != -1 && obj.length) {
-								obj.children(".jstree-loading").removeClass("jstree-loading");
-								obj.data("jstree-is-loading",false);
-								if(t === "success" && s.correct_state) { obj.removeClass("jstree-open jstree-closed").addClass("jstree-leaf"); }
-							}
-							else {
-								if(t === "success" && s.correct_state) { this.get_container().children("ul").empty(); }
-							}
-							if(e_call) { e_call.call(this); }
-						};
-						success_func = function (d, t, x) {
-							var sf = this.get_settings().html_data.ajax.success; 
-							if(sf) { d = sf.call(this,d,t,x) || d; }
-							if(d == "") {
-								return error_func.call(this, x, t, "");
-							}
-							if(d) {
-								d = $(d);
-								if(!d.is("ul")) { d = $("<ul>").append(d); }
-								if(obj == -1 || !obj) { this.get_container().children("ul").empty().append(d.children()).find("li, a").filter(function () { return this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end().filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon"); }
-								else { obj.children(".jstree-loading").removeClass("jstree-loading"); obj.append(d).find("li, a").filter(function () { return this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end().filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon"); obj.data("jstree-is-loading",false); }
-								this.clean_node(obj);
-								if(s_call) { s_call.call(this); }
-							}
-							else {
-								if(obj && obj !== -1) {
-									obj.children(".jstree-loading").removeClass("jstree-loading");
-									obj.data("jstree-is-loading",false);
-									if(s.correct_state) { 
-										obj.removeClass("jstree-open jstree-closed").addClass("jstree-leaf"); 
-										if(s_call) { s_call.call(this); } 
-									}
-								}
-								else {
-									if(s.correct_state) { 
-										this.get_container().children("ul").empty();
-										if(s_call) { s_call.call(this); } 
-									}
-								}
-							}
-						};
-						s.ajax.context = this;
-						s.ajax.error = error_func;
-						s.ajax.success = success_func;
-						if(!s.ajax.dataType) { s.ajax.dataType = "html"; }
-						if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, obj); }
-						if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, obj); }
-						$.ajax(s.ajax);
-						break;
-				}
-			}
-		}
-	});
-	// include the HTML data plugin by default
-	$.jstree.defaults.plugins.push("html_data");
+  $.jstree.plugin("html_data", {
+    __init : function () { 
+      // this used to use html() and clean the whitespace, but this way any attached data was lost
+      this.data.html_data.original_container_html = this.get_container().find(" > ul > li").clone(true);
+      // remove white space from LI node - otherwise nodes appear a bit to the right
+      this.data.html_data.original_container_html.find("li").andSelf().contents().filter(function() { return this.nodeType == 3; }).remove();
+    },
+    defaults : { 
+      data : false,
+      ajax : false,
+      correct_state : true
+    },
+    _fn : {
+      load_node : function (obj, s_call, e_call) { var _this = this; this.load_node_html(obj, function () { _this.__callback({ "obj" : obj }); s_call.call(this); }, e_call); },
+      _is_loaded : function (obj) { 
+        obj = this._get_node(obj); 
+        return obj == -1 || !obj || !this._get_settings().html_data.ajax || obj.is(".jstree-open, .jstree-leaf") || obj.children("ul").children("li").size() > 0;
+      },
+      load_node_html : function (obj, s_call, e_call) {
+        var d,
+          s = this.get_settings().html_data,
+          error_func = function () {},
+          success_func = function () {};
+        obj = this._get_node(obj);
+        if(obj && obj !== -1) {
+          if(obj.data("jstree-is-loading")) { return; }
+          else { obj.data("jstree-is-loading",true); }
+        }
+        switch(!0) {
+          case (!s.data && !s.ajax):
+            if(!obj || obj == -1) {
+              this.get_container()
+                .children("ul").empty()
+                .append(this.data.html_data.original_container_html)
+                .find("li, a").filter(function () { return this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end()
+                .filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon");
+              this.clean_node();
+            }
+            if(s_call) { s_call.call(this); }
+            break;
+          case (!!s.data && !s.ajax) || (!!s.data && !!s.ajax && (!obj || obj === -1)):
+            if(!obj || obj == -1) {
+              d = $(s.data);
+              if(!d.is("ul")) { d = $("<ul>").append(d); }
+              this.get_container()
+                .children("ul").empty().append(d.children())
+                .find("li, a").filter(function () { return this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end()
+                .filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon");
+              this.clean_node();
+            }
+            if(s_call) { s_call.call(this); }
+            break;
+          case (!s.data && !!s.ajax) || (!!s.data && !!s.ajax && obj && obj !== -1):
+            obj = this._get_node(obj);
+            error_func = function (x, t, e) {
+              var ef = this.get_settings().html_data.ajax.error; 
+              if(ef) { ef.call(this, x, t, e); }
+              if(obj != -1 && obj.length) {
+                obj.children(".jstree-loading").removeClass("jstree-loading");
+                obj.data("jstree-is-loading",false);
+                if(t === "success" && s.correct_state) { obj.removeClass("jstree-open jstree-closed").addClass("jstree-leaf"); }
+              }
+              else {
+                if(t === "success" && s.correct_state) { this.get_container().children("ul").empty(); }
+              }
+              if(e_call) { e_call.call(this); }
+            };
+            success_func = function (d, t, x) {
+              var sf = this.get_settings().html_data.ajax.success; 
+              if(sf) { d = sf.call(this,d,t,x) || d; }
+              if(d == "") {
+                return error_func.call(this, x, t, "");
+              }
+              if(d) {
+                d = $(d);
+                if(!d.is("ul")) { d = $("<ul>").append(d); }
+                if(obj == -1 || !obj) { this.get_container().children("ul").empty().append(d.children()).find("li, a").filter(function () { return this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end().filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon"); }
+                else { obj.children(".jstree-loading").removeClass("jstree-loading"); obj.append(d).find("li, a").filter(function () { return this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end().filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon"); obj.data("jstree-is-loading",false); }
+                this.clean_node(obj);
+                if(s_call) { s_call.call(this); }
+              }
+              else {
+                if(obj && obj !== -1) {
+                  obj.children(".jstree-loading").removeClass("jstree-loading");
+                  obj.data("jstree-is-loading",false);
+                  if(s.correct_state) { 
+                    obj.removeClass("jstree-open jstree-closed").addClass("jstree-leaf"); 
+                    if(s_call) { s_call.call(this); } 
+                  }
+                }
+                else {
+                  if(s.correct_state) { 
+                    this.get_container().children("ul").empty();
+                    if(s_call) { s_call.call(this); } 
+                  }
+                }
+              }
+            };
+            s.ajax.context = this;
+            s.ajax.error = error_func;
+            s.ajax.success = success_func;
+            if(!s.ajax.dataType) { s.ajax.dataType = "html"; }
+            if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, obj); }
+            if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, obj); }
+            $.ajax(s.ajax);
+            break;
+        }
+      }
+    }
+  });
+  // include the HTML data plugin by default
+  $.jstree.defaults.plugins.push("html_data");
 })(jQuery);
 //*/
 
@@ -3390,73 +3390,73 @@ THE SOFTWARE.
  * Adds support for jQuery UI themes. Include this at the end of your plugins list, also make sure "themes" is not included.
  */
 (function ($) {
-	$.jstree.plugin("themeroller", {
-		__init : function () {
-			var s = this._get_settings().themeroller;
-			this.get_container()
-				.addClass("ui-widget-content")
-				.delegate("a","mouseenter.jstree", function () {
-					$(this).addClass(s.item_h);
-				})
-				.delegate("a","mouseleave.jstree", function () {
-					$(this).removeClass(s.item_h);
-				})
-				.bind("open_node.jstree create_node.jstree", $.proxy(function (e, data) { 
-						this._themeroller(data.rslt.obj);
-					}, this))
-				.bind("loaded.jstree refresh.jstree", $.proxy(function (e) {
-						this._themeroller();
-					}, this))
-				.bind("close_node.jstree", $.proxy(function (e, data) {
-						data.rslt.obj.children("ins").removeClass(s.opened).addClass(s.closed);
-					}, this))
-				.bind("select_node.jstree", $.proxy(function (e, data) {
-						data.rslt.obj.children("a").addClass(s.item_a);
-					}, this))
-				.bind("deselect_node.jstree deselect_all.jstree", $.proxy(function (e, data) {
-						this.get_container()
-							.find("." + s.item_a).removeClass(s.item_a).end()
-							.find(".jstree-clicked").addClass(s.item_a);
-					}, this))
-				.bind("move_node.jstree", $.proxy(function (e, data) {
-						this._themeroller(data.rslt.o);
-					}, this));
-		},
-		__destroy : function () {
-			var s = this._get_settings().themeroller,
-				c = [ "ui-icon" ];
-			$.each(s, function (i, v) {
-				v = v.split(" ");
-				if(v.length) { c = c.concat(v); }
-			});
-			this.get_container()
-				.removeClass("ui-widget-content")
-				.find("." + c.join(", .")).removeClass(c.join(" "));
-		},
-		_fn : {
-			_themeroller : function (obj) {
-				var s = this._get_settings().themeroller;
-				obj = !obj || obj == -1 ? this.get_container() : this._get_node(obj).parent();
-				obj
-					.find("li.jstree-closed > ins.jstree-icon").removeClass(s.opened).addClass("ui-icon " + s.closed).end()
-					.find("li.jstree-open > ins.jstree-icon").removeClass(s.closed).addClass("ui-icon " + s.opened).end()
-					.find("a").addClass(s.item)
-						.children("ins.jstree-icon").addClass("ui-icon " + s.item_icon);
-			}
-		},
-		defaults : {
-			"opened" : "ui-icon-triangle-1-se",
-			"closed" : "ui-icon-triangle-1-e",
-			"item" : "ui-state-default",
-			"item_h" : "ui-state-hover",
-			"item_a" : "ui-state-active",
-			"item_icon" : "ui-icon-folder-collapsed"
-		}
-	});
-	$(function() {
-		var css_string = '.jstree .ui-icon { overflow:visible; } .jstree a { padding:0 2px; }';
-		$.vakata.css.add_sheet({ str : css_string });
-	});
+  $.jstree.plugin("themeroller", {
+    __init : function () {
+      var s = this._get_settings().themeroller;
+      this.get_container()
+        .addClass("ui-widget-content")
+        .delegate("a","mouseenter.jstree", function () {
+          $(this).addClass(s.item_h);
+        })
+        .delegate("a","mouseleave.jstree", function () {
+          $(this).removeClass(s.item_h);
+        })
+        .bind("open_node.jstree create_node.jstree", $.proxy(function (e, data) { 
+            this._themeroller(data.rslt.obj);
+          }, this))
+        .bind("loaded.jstree refresh.jstree", $.proxy(function (e) {
+            this._themeroller();
+          }, this))
+        .bind("close_node.jstree", $.proxy(function (e, data) {
+            data.rslt.obj.children("ins").removeClass(s.opened).addClass(s.closed);
+          }, this))
+        .bind("select_node.jstree", $.proxy(function (e, data) {
+            data.rslt.obj.children("a").addClass(s.item_a);
+          }, this))
+        .bind("deselect_node.jstree deselect_all.jstree", $.proxy(function (e, data) {
+            this.get_container()
+              .find("." + s.item_a).removeClass(s.item_a).end()
+              .find(".jstree-clicked").addClass(s.item_a);
+          }, this))
+        .bind("move_node.jstree", $.proxy(function (e, data) {
+            this._themeroller(data.rslt.o);
+          }, this));
+    },
+    __destroy : function () {
+      var s = this._get_settings().themeroller,
+        c = [ "ui-icon" ];
+      $.each(s, function (i, v) {
+        v = v.split(" ");
+        if(v.length) { c = c.concat(v); }
+      });
+      this.get_container()
+        .removeClass("ui-widget-content")
+        .find("." + c.join(", .")).removeClass(c.join(" "));
+    },
+    _fn : {
+      _themeroller : function (obj) {
+        var s = this._get_settings().themeroller;
+        obj = !obj || obj == -1 ? this.get_container() : this._get_node(obj).parent();
+        obj
+          .find("li.jstree-closed > ins.jstree-icon").removeClass(s.opened).addClass("ui-icon " + s.closed).end()
+          .find("li.jstree-open > ins.jstree-icon").removeClass(s.closed).addClass("ui-icon " + s.opened).end()
+          .find("a").addClass(s.item)
+            .children("ins.jstree-icon").addClass("ui-icon " + s.item_icon);
+      }
+    },
+    defaults : {
+      "opened" : "ui-icon-triangle-1-se",
+      "closed" : "ui-icon-triangle-1-e",
+      "item" : "ui-state-default",
+      "item_h" : "ui-state-hover",
+      "item_a" : "ui-state-active",
+      "item_icon" : "ui-icon-folder-collapsed"
+    }
+  });
+  $(function() {
+    var css_string = '.jstree .ui-icon { overflow:visible; } .jstree a { padding:0 2px; }';
+    $.vakata.css.add_sheet({ str : css_string });
+  });
 })(jQuery);
 //*/
 
@@ -3466,69 +3466,69 @@ THE SOFTWARE.
  * NOTE: does not check language versions (it will not be possible to have nodes with the same title, even in different languages)
  */
 (function ($) {
-	$.jstree.plugin("unique", {
-		__init : function () {
-			this.get_container()
-				.bind("before.jstree", $.proxy(function (e, data) { 
-						var nms = [], res = true, p, t;
-						if(data.func == "move_node") {
-							// obj, ref, position, is_copy, is_prepared, skip_check
-							if(data.args[4] === true) {
-								if(data.args[0].o && data.args[0].o.length) {
-									data.args[0].o.children("a").each(function () { nms.push($(this).text().replace(/^\s+/g,"")); });
-									res = this._check_unique(nms, data.args[0].np.find("> ul > li").not(data.args[0].o));
-								}
-							}
-						}
-						if(data.func == "create_node") {
-							// obj, position, js, callback, is_loaded
-							if(data.args[4] || this._is_loaded(data.args[0])) {
-								p = this._get_node(data.args[0]);
-								if(data.args[1] && (data.args[1] === "before" || data.args[1] === "after")) {
-									p = this._get_parent(data.args[0]);
-									if(!p || p === -1) { p = this.get_container(); }
-								}
-								if(typeof data.args[2] === "string") { nms.push(data.args[2]); }
-								else if(!data.args[2] || !data.args[2].data) { nms.push(this._get_settings().core.strings.new_node); }
-								else { nms.push(data.args[2].data); }
-								res = this._check_unique(nms, p.find("> ul > li"));
-							}
-						}
-						if(data.func == "rename_node") {
-							// obj, val
-							nms.push(data.args[1]);
-							t = this._get_node(data.args[0]);
-							p = this._get_parent(t);
-							if(!p || p === -1) { p = this.get_container(); }
-							res = this._check_unique(nms, p.find("> ul > li").not(t));
-						}
-						if(!res) {
-							e.stopPropagation();
-							return false;
-						}
-					}, this));
-		},
-		_fn : { 
-			_check_unique : function (nms, p) {
-				var cnms = [];
-				p.children("a").each(function () { cnms.push($(this).text().replace(/^\s+/g,"")); });
-				if(!cnms.length || !nms.length) { return true; }
-				cnms = cnms.sort().join(",,").replace(/(,|^)([^,]+)(,,\2)+(,|$)/g,"$1$2$4").replace(/,,+/g,",").replace(/,$/,"").split(",");
-				if((cnms.length + nms.length) != cnms.concat(nms).sort().join(",,").replace(/(,|^)([^,]+)(,,\2)+(,|$)/g,"$1$2$4").replace(/,,+/g,",").replace(/,$/,"").split(",").length) {
-					return false;
-				}
-				return true;
-			},
-			check_move : function () {
-				if(!this.__call_old()) { return false; }
-				var p = this._get_move(), nms = [];
-				if(p.o && p.o.length) {
-					p.o.children("a").each(function () { nms.push($(this).text().replace(/^\s+/g,"")); });
-					return this._check_unique(nms, p.np.find("> ul > li").not(p.o));
-				}
-				return true;
-			}
-		}
-	});
+  $.jstree.plugin("unique", {
+    __init : function () {
+      this.get_container()
+        .bind("before.jstree", $.proxy(function (e, data) { 
+            var nms = [], res = true, p, t;
+            if(data.func == "move_node") {
+              // obj, ref, position, is_copy, is_prepared, skip_check
+              if(data.args[4] === true) {
+                if(data.args[0].o && data.args[0].o.length) {
+                  data.args[0].o.children("a").each(function () { nms.push($(this).text().replace(/^\s+/g,"")); });
+                  res = this._check_unique(nms, data.args[0].np.find("> ul > li").not(data.args[0].o));
+                }
+              }
+            }
+            if(data.func == "create_node") {
+              // obj, position, js, callback, is_loaded
+              if(data.args[4] || this._is_loaded(data.args[0])) {
+                p = this._get_node(data.args[0]);
+                if(data.args[1] && (data.args[1] === "before" || data.args[1] === "after")) {
+                  p = this._get_parent(data.args[0]);
+                  if(!p || p === -1) { p = this.get_container(); }
+                }
+                if(typeof data.args[2] === "string") { nms.push(data.args[2]); }
+                else if(!data.args[2] || !data.args[2].data) { nms.push(this._get_settings().core.strings.new_node); }
+                else { nms.push(data.args[2].data); }
+                res = this._check_unique(nms, p.find("> ul > li"));
+              }
+            }
+            if(data.func == "rename_node") {
+              // obj, val
+              nms.push(data.args[1]);
+              t = this._get_node(data.args[0]);
+              p = this._get_parent(t);
+              if(!p || p === -1) { p = this.get_container(); }
+              res = this._check_unique(nms, p.find("> ul > li").not(t));
+            }
+            if(!res) {
+              e.stopPropagation();
+              return false;
+            }
+          }, this));
+    },
+    _fn : { 
+      _check_unique : function (nms, p) {
+        var cnms = [];
+        p.children("a").each(function () { cnms.push($(this).text().replace(/^\s+/g,"")); });
+        if(!cnms.length || !nms.length) { return true; }
+        cnms = cnms.sort().join(",,").replace(/(,|^)([^,]+)(,,\2)+(,|$)/g,"$1$2$4").replace(/,,+/g,",").replace(/,$/,"").split(",");
+        if((cnms.length + nms.length) != cnms.concat(nms).sort().join(",,").replace(/(,|^)([^,]+)(,,\2)+(,|$)/g,"$1$2$4").replace(/,,+/g,",").replace(/,$/,"").split(",").length) {
+          return false;
+        }
+        return true;
+      },
+      check_move : function () {
+        if(!this.__call_old()) { return false; }
+        var p = this._get_move(), nms = [];
+        if(p.o && p.o.length) {
+          p.o.children("a").each(function () { nms.push($(this).text().replace(/^\s+/g,"")); });
+          return this._check_unique(nms, p.np.find("> ul > li").not(p.o));
+        }
+        return true;
+      }
+    }
+  });
 })(jQuery);
 //*/
diff --git a/solr/webapp/web/js/require.js b/solr/webapp/web/js/require.js
index 5cb347a..a47f8b4 100644
--- a/solr/webapp/web/js/require.js
+++ b/solr/webapp/web/js/require.js
@@ -2097,900 +2097,900 @@ var requirejs, require, define;
 
 // Use the correct document accordingly with window argument (sandbox)
 var document = window.document,
-	navigator = window.navigator,
-	location = window.location;
+  navigator = window.navigator,
+  location = window.location;
 var jQuery = (function() {
 
 // Define a local copy of jQuery
 var jQuery = function( selector, context ) {
-		// The jQuery object is actually just the init constructor 'enhanced'
-		return new jQuery.fn.init( selector, context, rootjQuery );
-	},
+    // The jQuery object is actually just the init constructor 'enhanced'
+    return new jQuery.fn.init( selector, context, rootjQuery );
+  },
 
-	// Map over jQuery in case of overwrite
-	_jQuery = window.jQuery,
+  // Map over jQuery in case of overwrite
+  _jQuery = window.jQuery,
 
-	// Map over the $ in case of overwrite
-	_$ = window.$,
+  // Map over the $ in case of overwrite
+  _$ = window.$,
 
-	// A central reference to the root jQuery(document)
-	rootjQuery,
+  // A central reference to the root jQuery(document)
+  rootjQuery,
 
-	// A simple way to check for HTML strings or ID strings
-	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
-	quickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,
+  // A simple way to check for HTML strings or ID strings
+  // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
+  quickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,
 
-	// Check if a string has a non-whitespace character in it
-	rnotwhite = /\S/,
+  // Check if a string has a non-whitespace character in it
+  rnotwhite = /\S/,
 
-	// Used for trimming whitespace
-	trimLeft = /^\s+/,
-	trimRight = /\s+$/,
+  // Used for trimming whitespace
+  trimLeft = /^\s+/,
+  trimRight = /\s+$/,
 
-	// Match a standalone tag
-	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,
+  // Match a standalone tag
+  rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,
 
-	// JSON RegExp
-	rvalidchars = /^[\],:{}\s]*$/,
-	rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
-	rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
-	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,
+  // JSON RegExp
+  rvalidchars = /^[\],:{}\s]*$/,
+  rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
+  rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
+  rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,
 
-	// Useragent RegExp
-	rwebkit = /(webkit)[ \/]([\w.]+)/,
-	ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
-	rmsie = /(msie) ([\w.]+)/,
-	rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,
+  // Useragent RegExp
+  rwebkit = /(webkit)[ \/]([\w.]+)/,
+  ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
+  rmsie = /(msie) ([\w.]+)/,
+  rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,
 
-	// Matches dashed string for camelizing
-	rdashAlpha = /-([a-z]|[0-9])/ig,
-	rmsPrefix = /^-ms-/,
+  // Matches dashed string for camelizing
+  rdashAlpha = /-([a-z]|[0-9])/ig,
+  rmsPrefix = /^-ms-/,
 
-	// Used by jQuery.camelCase as callback to replace()
-	fcamelCase = function( all, letter ) {
-		return ( letter + "" ).toUpperCase();
-	},
+  // Used by jQuery.camelCase as callback to replace()
+  fcamelCase = function( all, letter ) {
+    return ( letter + "" ).toUpperCase();
+  },
 
-	// Keep a UserAgent string for use with jQuery.browser
-	userAgent = navigator.userAgent,
+  // Keep a UserAgent string for use with jQuery.browser
+  userAgent = navigator.userAgent,
 
-	// For matching the engine and version of the browser
-	browserMatch,
+  // For matching the engine and version of the browser
+  browserMatch,
 
-	// The deferred used on DOM ready
-	readyList,
+  // The deferred used on DOM ready
+  readyList,
 
-	// The ready event handler
-	DOMContentLoaded,
+  // The ready event handler
+  DOMContentLoaded,
 
-	// Save a reference to some core methods
-	toString = Object.prototype.toString,
-	hasOwn = Object.prototype.hasOwnProperty,
-	push = Array.prototype.push,
-	slice = Array.prototype.slice,
-	trim = String.prototype.trim,
-	indexOf = Array.prototype.indexOf,
+  // Save a reference to some core methods
+  toString = Object.prototype.toString,
+  hasOwn = Object.prototype.hasOwnProperty,
+  push = Array.prototype.push,
+  slice = Array.prototype.slice,
+  trim = String.prototype.trim,
+  indexOf = Array.prototype.indexOf,
 
-	// [[Class]] -> type pairs
-	class2type = {};
+  // [[Class]] -> type pairs
+  class2type = {};
 
 jQuery.fn = jQuery.prototype = {
-	constructor: jQuery,
-	init: function( selector, context, rootjQuery ) {
-		var match, elem, ret, doc;
-
-		// Handle $(""), $(null), or $(undefined)
-		if ( !selector ) {
-			return this;
-		}
-
-		// Handle $(DOMElement)
-		if ( selector.nodeType ) {
-			this.context = this[0] = selector;
-			this.length = 1;
-			return this;
-		}
-
-		// The body element only exists once, optimize finding it
-		if ( selector === "body" && !context && document.body ) {
-			this.context = document;
-			this[0] = document.body;
-			this.selector = selector;
-			this.length = 1;
-			return this;
-		}
-
-		// Handle HTML strings
-		if ( typeof selector === "string" ) {
-			// Are we dealing with HTML string or an ID?
-			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
-				// Assume that strings that start and end with <> are HTML and skip the regex check
-				match = [ null, selector, null ];
-
-			} else {
-				match = quickExpr.exec( selector );
-			}
-
-			// Verify a match, and that no context was specified for #id
-			if ( match && (match[1] || !context) ) {
-
-				// HANDLE: $(html) -> $(array)
-				if ( match[1] ) {
-					context = context instanceof jQuery ? context[0] : context;
-					doc = ( context ? context.ownerDocument || context : document );
-
-					// If a single string is passed in and it's a single tag
-					// just do a createElement and skip the rest
-					ret = rsingleTag.exec( selector );
-
-					if ( ret ) {
-						if ( jQuery.isPlainObject( context ) ) {
-							selector = [ document.createElement( ret[1] ) ];
-							jQuery.fn.attr.call( selector, context, true );
-
-						} else {
-							selector = [ doc.createElement( ret[1] ) ];
-						}
-
-					} else {
-						ret = jQuery.buildFragment( [ match[1] ], [ doc ] );
-						selector = ( ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment ).childNodes;
-					}
-
-					return jQuery.merge( this, selector );
-
-				// HANDLE: $("#id")
-				} else {
-					elem = document.getElementById( match[2] );
-
-					// Check parentNode to catch when Blackberry 4.6 returns
-					// nodes that are no longer in the document #6963
-					if ( elem && elem.parentNode ) {
-						// Handle the case where IE and Opera return items
-						// by name instead of ID
-						if ( elem.id !== match[2] ) {
-							return rootjQuery.find( selector );
-						}
-
-						// Otherwise, we inject the element directly into the jQuery object
-						this.length = 1;
-						this[0] = elem;
-					}
-
-					this.context = document;
-					this.selector = selector;
-					return this;
-				}
-
-			// HANDLE: $(expr, $(...))
-			} else if ( !context || context.jquery ) {
-				return ( context || rootjQuery ).find( selector );
-
-			// HANDLE: $(expr, context)
-			// (which is just equivalent to: $(context).find(expr)
-			} else {
-				return this.constructor( context ).find( selector );
-			}
-
-		// HANDLE: $(function)
-		// Shortcut for document ready
-		} else if ( jQuery.isFunction( selector ) ) {
-			return rootjQuery.ready( selector );
-		}
-
-		if ( selector.selector !== undefined ) {
-			this.selector = selector.selector;
-			this.context = selector.context;
-		}
-
-		return jQuery.makeArray( selector, this );
-	},
-
-	// Start with an empty selector
-	selector: "",
-
-	// The current version of jQuery being used
-	jquery: "1.7.1",
-
-	// The default length of a jQuery object is 0
-	length: 0,
-
-	// The number of elements contained in the matched element set
-	size: function() {
-		return this.length;
-	},
-
-	toArray: function() {
-		return slice.call( this, 0 );
-	},
-
-	// Get the Nth element in the matched element set OR
-	// Get the whole matched element set as a clean array
-	get: function( num ) {
-		return num == null ?
-
-			// Return a 'clean' array
-			this.toArray() :
-
-			// Return just the object
-			( num < 0 ? this[ this.length + num ] : this[ num ] );
-	},
-
-	// Take an array of elements and push it onto the stack
-	// (returning the new matched element set)
-	pushStack: function( elems, name, selector ) {
-		// Build a new jQuery matched element set
-		var ret = this.constructor();
-
-		if ( jQuery.isArray( elems ) ) {
-			push.apply( ret, elems );
-
-		} else {
-			jQuery.merge( ret, elems );
-		}
-
-		// Add the old object onto the stack (as a reference)
-		ret.prevObject = this;
-
-		ret.context = this.context;
-
-		if ( name === "find" ) {
-			ret.selector = this.selector + ( this.selector ? " " : "" ) + selector;
-		} else if ( name ) {
-			ret.selector = this.selector + "." + name + "(" + selector + ")";
-		}
-
-		// Return the newly-formed element set
-		return ret;
-	},
-
-	// Execute a callback for every element in the matched set.
-	// (You can seed the arguments with an array of args, but this is
-	// only used internally.)
-	each: function( callback, args ) {
-		return jQuery.each( this, callback, args );
-	},
-
-	ready: function( fn ) {
-		// Attach the listeners
-		jQuery.bindReady();
-
-		// Add the callback
-		readyList.add( fn );
-
-		return this;
-	},
-
-	eq: function( i ) {
-		i = +i;
-		return i === -1 ?
-			this.slice( i ) :
-			this.slice( i, i + 1 );
-	},
-
-	first: function() {
-		return this.eq( 0 );
-	},
-
-	last: function() {
-		return this.eq( -1 );
-	},
-
-	slice: function() {
-		return this.pushStack( slice.apply( this, arguments ),
-			"slice", slice.call(arguments).join(",") );
-	},
-
-	map: function( callback ) {
-		return this.pushStack( jQuery.map(this, function( elem, i ) {
-			return callback.call( elem, i, elem );
-		}));
-	},
-
-	end: function() {
-		return this.prevObject || this.constructor(null);
-	},
-
-	// For internal use only.
-	// Behaves like an Array's method, not like a jQuery method.
-	push: push,
-	sort: [].sort,
-	splice: [].splice
+  constructor: jQuery,
+  init: function( selector, context, rootjQuery ) {
+    var match, elem, ret, doc;
+
+    // Handle $(""), $(null), or $(undefined)
+    if ( !selector ) {
+      return this;
+    }
+
+    // Handle $(DOMElement)
+    if ( selector.nodeType ) {
+      this.context = this[0] = selector;
+      this.length = 1;
+      return this;
+    }
+
+    // The body element only exists once, optimize finding it
+    if ( selector === "body" && !context && document.body ) {
+      this.context = document;
+      this[0] = document.body;
+      this.selector = selector;
+      this.length = 1;
+      return this;
+    }
+
+    // Handle HTML strings
+    if ( typeof selector === "string" ) {
+      // Are we dealing with HTML string or an ID?
+      if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
+        // Assume that strings that start and end with <> are HTML and skip the regex check
+        match = [ null, selector, null ];
+
+      } else {
+        match = quickExpr.exec( selector );
+      }
+
+      // Verify a match, and that no context was specified for #id
+      if ( match && (match[1] || !context) ) {
+
+        // HANDLE: $(html) -> $(array)
+        if ( match[1] ) {
+          context = context instanceof jQuery ? context[0] : context;
+          doc = ( context ? context.ownerDocument || context : document );
+
+          // If a single string is passed in and it's a single tag
+          // just do a createElement and skip the rest
+          ret = rsingleTag.exec( selector );
+
+          if ( ret ) {
+            if ( jQuery.isPlainObject( context ) ) {
+              selector = [ document.createElement( ret[1] ) ];
+              jQuery.fn.attr.call( selector, context, true );
+
+            } else {
+              selector = [ doc.createElement( ret[1] ) ];
+            }
+
+          } else {
+            ret = jQuery.buildFragment( [ match[1] ], [ doc ] );
+            selector = ( ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment ).childNodes;
+          }
+
+          return jQuery.merge( this, selector );
+
+        // HANDLE: $("#id")
+        } else {
+          elem = document.getElementById( match[2] );
+
+          // Check parentNode to catch when Blackberry 4.6 returns
+          // nodes that are no longer in the document #6963
+          if ( elem && elem.parentNode ) {
+            // Handle the case where IE and Opera return items
+            // by name instead of ID
+            if ( elem.id !== match[2] ) {
+              return rootjQuery.find( selector );
+            }
+
+            // Otherwise, we inject the element directly into the jQuery object
+            this.length = 1;
+            this[0] = elem;
+          }
+
+          this.context = document;
+          this.selector = selector;
+          return this;
+        }
+
+      // HANDLE: $(expr, $(...))
+      } else if ( !context || context.jquery ) {
+        return ( context || rootjQuery ).find( selector );
+
+      // HANDLE: $(expr, context)
+      // (which is just equivalent to: $(context).find(expr)
+      } else {
+        return this.constructor( context ).find( selector );
+      }
+
+    // HANDLE: $(function)
+    // Shortcut for document ready
+    } else if ( jQuery.isFunction( selector ) ) {
+      return rootjQuery.ready( selector );
+    }
+
+    if ( selector.selector !== undefined ) {
+      this.selector = selector.selector;
+      this.context = selector.context;
+    }
+
+    return jQuery.makeArray( selector, this );
+  },
+
+  // Start with an empty selector
+  selector: "",
+
+  // The current version of jQuery being used
+  jquery: "1.7.1",
+
+  // The default length of a jQuery object is 0
+  length: 0,
+
+  // The number of elements contained in the matched element set
+  size: function() {
+    return this.length;
+  },
+
+  toArray: function() {
+    return slice.call( this, 0 );
+  },
+
+  // Get the Nth element in the matched element set OR
+  // Get the whole matched element set as a clean array
+  get: function( num ) {
+    return num == null ?
+
+      // Return a 'clean' array
+      this.toArray() :
+
+      // Return just the object
+      ( num < 0 ? this[ this.length + num ] : this[ num ] );
+  },
+
+  // Take an array of elements and push it onto the stack
+  // (returning the new matched element set)
+  pushStack: function( elems, name, selector ) {
+    // Build a new jQuery matched element set
+    var ret = this.constructor();
+
+    if ( jQuery.isArray( elems ) ) {
+      push.apply( ret, elems );
+
+    } else {
+      jQuery.merge( ret, elems );
+    }
+
+    // Add the old object onto the stack (as a reference)
+    ret.prevObject = this;
+
+    ret.context = this.context;
+
+    if ( name === "find" ) {
+      ret.selector = this.selector + ( this.selector ? " " : "" ) + selector;
+    } else if ( name ) {
+      ret.selector = this.selector + "." + name + "(" + selector + ")";
+    }
+
+    // Return the newly-formed element set
+    return ret;
+  },
+
+  // Execute a callback for every element in the matched set.
+  // (You can seed the arguments with an array of args, but this is
+  // only used internally.)
+  each: function( callback, args ) {
+    return jQuery.each( this, callback, args );
+  },
+
+  ready: function( fn ) {
+    // Attach the listeners
+    jQuery.bindReady();
+
+    // Add the callback
+    readyList.add( fn );
+
+    return this;
+  },
+
+  eq: function( i ) {
+    i = +i;
+    return i === -1 ?
+      this.slice( i ) :
+      this.slice( i, i + 1 );
+  },
+
+  first: function() {
+    return this.eq( 0 );
+  },
+
+  last: function() {
+    return this.eq( -1 );
+  },
+
+  slice: function() {
+    return this.pushStack( slice.apply( this, arguments ),
+      "slice", slice.call(arguments).join(",") );
+  },
+
+  map: function( callback ) {
+    return this.pushStack( jQuery.map(this, function( elem, i ) {
+      return callback.call( elem, i, elem );
+    }));
+  },
+
+  end: function() {
+    return this.prevObject || this.constructor(null);
+  },
+
+  // For internal use only.
+  // Behaves like an Array's method, not like a jQuery method.
+  push: push,
+  sort: [].sort,
+  splice: [].splice
 };
 
 // Give the init function the jQuery prototype for later instantiation
 jQuery.fn.init.prototype = jQuery.fn;
 
 jQuery.extend = jQuery.fn.extend = function() {
-	var options, name, src, copy, copyIsArray, clone,
-		target = arguments[0] || {},
-		i = 1,
-		length = arguments.length,
-		deep = false;
-
-	// Handle a deep copy situation
-	if ( typeof target === "boolean" ) {
-		deep = target;
-		target = arguments[1] || {};
-		// skip the boolean and the target
-		i = 2;
-	}
-
-	// Handle case when target is a string or something (possible in deep copy)
-	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
-		target = {};
-	}
-
-	// extend jQuery itself if only one argument is passed
-	if ( length === i ) {
-		target = this;
-		--i;
-	}
-
-	for ( ; i < length; i++ ) {
-		// Only deal with non-null/undefined values
-		if ( (options = arguments[ i ]) != null ) {
-			// Extend the base object
-			for ( name in options ) {
-				src = target[ name ];
-				copy = options[ name ];
-
-				// Prevent never-ending loop
-				if ( target === copy ) {
-					continue;
-				}
-
-				// Recurse if we're merging plain objects or arrays
-				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
-					if ( copyIsArray ) {
-						copyIsArray = false;
-						clone = src && jQuery.isArray(src) ? src : [];
-
-					} else {
-						clone = src && jQuery.isPlainObject(src) ? src : {};
-					}
-
-					// Never move original objects, clone them
-					target[ name ] = jQuery.extend( deep, clone, copy );
-
-				// Don't bring in undefined values
-				} else if ( copy !== undefined ) {
-					target[ name ] = copy;
-				}
-			}
-		}
-	}
-
-	// Return the modified object
-	return target;
+  var options, name, src, copy, copyIsArray, clone,
+    target = arguments[0] || {},
+    i = 1,
+    length = arguments.length,
+    deep = false;
+
+  // Handle a deep copy situation
+  if ( typeof target === "boolean" ) {
+    deep = target;
+    target = arguments[1] || {};
+    // skip the boolean and the target
+    i = 2;
+  }
+
+  // Handle case when target is a string or something (possible in deep copy)
+  if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
+    target = {};
+  }
+
+  // extend jQuery itself if only one argument is passed
+  if ( length === i ) {
+    target = this;
+    --i;
+  }
+
+  for ( ; i < length; i++ ) {
+    // Only deal with non-null/undefined values
+    if ( (options = arguments[ i ]) != null ) {
+      // Extend the base object
+      for ( name in options ) {
+        src = target[ name ];
+        copy = options[ name ];
+
+        // Prevent never-ending loop
+        if ( target === copy ) {
+          continue;
+        }
+
+        // Recurse if we're merging plain objects or arrays
+        if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
+          if ( copyIsArray ) {
+            copyIsArray = false;
+            clone = src && jQuery.isArray(src) ? src : [];
+
+          } else {
+            clone = src && jQuery.isPlainObject(src) ? src : {};
+          }
+
+          // Never move original objects, clone them
+          target[ name ] = jQuery.extend( deep, clone, copy );
+
+        // Don't bring in undefined values
+        } else if ( copy !== undefined ) {
+          target[ name ] = copy;
+        }
+      }
+    }
+  }
+
+  // Return the modified object
+  return target;
 };
 
 jQuery.extend({
-	noConflict: function( deep ) {
-		if ( window.$ === jQuery ) {
-			window.$ = _$;
-		}
-
-		if ( deep && window.jQuery === jQuery ) {
-			window.jQuery = _jQuery;
-		}
-
-		return jQuery;
-	},
-
-	// Is the DOM ready to be used? Set to true once it occurs.
-	isReady: false,
-
-	// A counter to track how many items to wait for before
-	// the ready event fires. See #6781
-	readyWait: 1,
-
-	// Hold (or release) the ready event
-	holdReady: function( hold ) {
-		if ( hold ) {
-			jQuery.readyWait++;
-		} else {
-			jQuery.ready( true );
-		}
-	},
-
-	// Handle when the DOM is ready
-	ready: function( wait ) {
-		// Either a released hold or an DOMready/load event and not yet ready
-		if ( (wait === true && !--jQuery.readyWait) || (wait !== true && !jQuery.isReady) ) {
-			// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
-			if ( !document.body ) {
-				return setTimeout( jQuery.ready, 1 );
-			}
-
-			// Remember that the DOM is ready
-			jQuery.isReady = true;
-
-			// If a normal DOM Ready event fired, decrement, and wait if need be
-			if ( wait !== true && --jQuery.readyWait > 0 ) {
-				return;
-			}
-
-			// If there are functions bound, to execute
-			readyList.fireWith( document, [ jQuery ] );
-
-			// Trigger any bound ready events
-			if ( jQuery.fn.trigger ) {
-				jQuery( document ).trigger( "ready" ).off( "ready" );
-			}
-		}
-	},
-
-	bindReady: function() {
-		if ( readyList ) {
-			return;
-		}
-
-		readyList = jQuery.Callbacks( "once memory" );
-
-		// Catch cases where $(document).ready() is called after the
-		// browser event has already occurred.
-		if ( document.readyState === "complete" ) {
-			// Handle it asynchronously to allow scripts the opportunity to delay ready
-			return setTimeout( jQuery.ready, 1 );
-		}
-
-		// Mozilla, Opera and webkit nightlies currently support this event
-		if ( document.addEventListener ) {
-			// Use the handy event callback
-			document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );
-
-			// A fallback to window.onload, that will always work
-			window.addEventListener( "load", jQuery.ready, false );
-
-		// If IE event model is used
-		} else if ( document.attachEvent ) {
-			// ensure firing before onload,
-			// maybe late but safe also for iframes
-			document.attachEvent( "onreadystatechange", DOMContentLoaded );
-
-			// A fallback to window.onload, that will always work
-			window.attachEvent( "onload", jQuery.ready );
-
-			// If IE and not a frame
-			// continually check to see if the document is ready
-			var toplevel = false;
-
-			try {
-				toplevel = window.frameElement == null;
-			} catch(e) {}
-
-			if ( document.documentElement.doScroll && toplevel ) {
-				doScrollCheck();
-			}
-		}
-	},
-
-	// See test/unit/core.js for details concerning isFunction.
-	// Since version 1.3, DOM methods and functions like alert
-	// aren't supported. They return false on IE (#2968).
-	isFunction: function( obj ) {
-		return jQuery.type(obj) === "function";
-	},
-
-	isArray: Array.isArray || function( obj ) {
-		return jQuery.type(obj) === "array";
-	},
-
-	// A crude way of determining if an object is a window
-	isWindow: function( obj ) {
-		return obj && typeof obj === "object" && "setInterval" in obj;
-	},
-
-	isNumeric: function( obj ) {
-		return !isNaN( parseFloat(obj) ) && isFinite( obj );
-	},
-
-	type: function( obj ) {
-		return obj == null ?
-			String( obj ) :
-			class2type[ toString.call(obj) ] || "object";
-	},
-
-	isPlainObject: function( obj ) {
-		// Must be an Object.
-		// Because of IE, we also have to check the presence of the constructor property.
-		// Make sure that DOM nodes and window objects don't pass through, as well
-		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
-			return false;
-		}
-
-		try {
-			// Not own constructor property must be Object
-			if ( obj.constructor &&
-				!hasOwn.call(obj, "constructor") &&
-				!hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
-				return false;
-			}
-		} catch ( e ) {
-			// IE8,9 Will throw exceptions on certain host objects #9897
-			return false;
-		}
-
-		// Own properties are enumerated firstly, so to speed up,
-		// if last one is own, then all properties are own.
-
-		var key;
-		for ( key in obj ) {}
-
-		return key === undefined || hasOwn.call( obj, key );
-	},
-
-	isEmptyObject: function( obj ) {
-		for ( var name in obj ) {
-			return false;
-		}
-		return true;
-	},
-
-	error: function( msg ) {
-		throw new Error( msg );
-	},
-
-	parseJSON: function( data ) {
-		if ( typeof data !== "string" || !data ) {
-			return null;
-		}
-
-		// Make sure leading/trailing whitespace is removed (IE can't handle it)
-		data = jQuery.trim( data );
-
-		// Attempt to parse using the native JSON parser first
-		if ( window.JSON && window.JSON.parse ) {
-			return window.JSON.parse( data );
-		}
-
-		// Make sure the incoming data is actual JSON
-		// Logic borrowed from http://json.org/json2.js
-		if ( rvalidchars.test( data.replace( rvalidescape, "@" )
-			.replace( rvalidtokens, "]" )
-			.replace( rvalidbraces, "")) ) {
-
-			return ( new Function( "return " + data ) )();
-
-		}
-		jQuery.error( "Invalid JSON: " + data );
-	},
-
-	// Cross-browser xml parsing
-	parseXML: function( data ) {
-		var xml, tmp;
-		try {
-			if ( window.DOMParser ) { // Standard
-				tmp = new DOMParser();
-				xml = tmp.parseFromString( data , "text/xml" );
-			} else { // IE
-				xml = new ActiveXObject( "Microsoft.XMLDOM" );
-				xml.async = "false";
-				xml.loadXML( data );
-			}
-		} catch( e ) {
-			xml = undefined;
-		}
-		if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
-			jQuery.error( "Invalid XML: " + data );
-		}
-		return xml;
-	},
-
-	noop: function() {},
-
-	// Evaluates a script in a global context
-	// Workarounds based on findings by Jim Driscoll
-	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
-	globalEval: function( data ) {
-		if ( data && rnotwhite.test( data ) ) {
-			// We use execScript on Internet Explorer
-			// We use an anonymous function so that context is window
-			// rather than jQuery in Firefox
-			( window.execScript || function( data ) {
-				window[ "eval" ].call( window, data );
-			} )( data );
-		}
-	},
-
-	// Convert dashed to camelCase; used by the css and data modules
-	// Microsoft forgot to hump their vendor prefix (#9572)
-	camelCase: function( string ) {
-		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
-	},
-
-	nodeName: function( elem, name ) {
-		return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
-	},
-
-	// args is for internal usage only
-	each: function( object, callback, args ) {
-		var name, i = 0,
-			length = object.length,
-			isObj = length === undefined || jQuery.isFunction( object );
-
-		if ( args ) {
-			if ( isObj ) {
-				for ( name in object ) {
-					if ( callback.apply( object[ name ], args ) === false ) {
-						break;
-					}
-				}
-			} else {
-				for ( ; i < length; ) {
-					if ( callback.apply( object[ i++ ], args ) === false ) {
-						break;
-					}
-				}
-			}
-
-		// A special, fast, case for the most common use of each
-		} else {
-			if ( isObj ) {
-				for ( name in object ) {
-					if ( callback.call( object[ name ], name, object[ name ] ) === false ) {
-						break;
-					}
-				}
-			} else {
-				for ( ; i < length; ) {
-					if ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {
-						break;
-					}
-				}
-			}
-		}
-
-		return object;
-	},
-
-	// Use native String.trim function wherever possible
-	trim: trim ?
-		function( text ) {
-			return text == null ?
-				"" :
-				trim.call( text );
-		} :
-
-		// Otherwise use our own trimming functionality
-		function( text ) {
-			return text == null ?
-				"" :
-				text.toString().replace( trimLeft, "" ).replace( trimRight, "" );
-		},
-
-	// results is for internal usage only
-	makeArray: function( array, results ) {
-		var ret = results || [];
-
-		if ( array != null ) {
-			// The window, strings (and functions) also have 'length'
-			// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
-			var type = jQuery.type( array );
-
-			if ( array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( array ) ) {
-				push.call( ret, array );
-			} else {
-				jQuery.merge( ret, array );
-			}
-		}
-
-		return ret;
-	},
-
-	inArray: function( elem, array, i ) {
-		var len;
-
-		if ( array ) {
-			if ( indexOf ) {
-				return indexOf.call( array, elem, i );
-			}
-
-			len = array.length;
-			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;
-
-			for ( ; i < len; i++ ) {
-				// Skip accessing in sparse arrays
-				if ( i in array && array[ i ] === elem ) {
-					return i;
-				}
-			}
-		}
-
-		return -1;
-	},
-
-	merge: function( first, second ) {
-		var i = first.length,
-			j = 0;
-
-		if ( typeof second.length === "number" ) {
-			for ( var l = second.length; j < l; j++ ) {
-				first[ i++ ] = second[ j ];
-			}
-
-		} else {
-			while ( second[j] !== undefined ) {
-				first[ i++ ] = second[ j++ ];
-			}
-		}
-
-		first.length = i;
-
-		return first;
-	},
-
-	grep: function( elems, callback, inv ) {
-		var ret = [], retVal;
-		inv = !!inv;
-
-		// Go through the array, only saving the items
-		// that pass the validator function
-		for ( var i = 0, length = elems.length; i < length; i++ ) {
-			retVal = !!callback( elems[ i ], i );
-			if ( inv !== retVal ) {
-				ret.push( elems[ i ] );
-			}
-		}
-
-		return ret;
-	},
-
-	// arg is for internal usage only
-	map: function( elems, callback, arg ) {
-		var value, key, ret = [],
-			i = 0,
-			length = elems.length,
-			// jquery objects are treated as arrays
-			isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;
-
-		// Go through the array, translating each of the items to their
-		if ( isArray ) {
-			for ( ; i < length; i++ ) {
-				value = callback( elems[ i ], i, arg );
-
-				if ( value != null ) {
-					ret[ ret.length ] = value;
-				}
-			}
-
-		// Go through every key on the object,
-		} else {
-			for ( key in elems ) {
-				value = callback( elems[ key ], key, arg );
-
-				if ( value != null ) {
-					ret[ ret.length ] = value;
-				}
-			}
-		}
-
-		// Flatten any nested arrays
-		return ret.concat.apply( [], ret );
-	},
-
-	// A global GUID counter for objects
-	guid: 1,
-
-	// Bind a function to a context, optionally partially applying any
-	// arguments.
-	proxy: function( fn, context ) {
-		if ( typeof context === "string" ) {
-			var tmp = fn[ context ];
-			context = fn;
-			fn = tmp;
-		}
-
-		// Quick check to determine if target is callable, in the spec
-		// this throws a TypeError, but we will just return undefined.
-		if ( !jQuery.isFunction( fn ) ) {
-			return undefined;
-		}
-
-		// Simulated bind
-		var args = slice.call( arguments, 2 ),
-			proxy = function() {
-				return fn.apply( context, args.concat( slice.call( arguments ) ) );
-			};
-
-		// Set the guid of unique handler to the same of original handler, so it can be removed
-		proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;
-
-		return proxy;
-	},
-
-	// Mutifunctional method to get and set values to a collection
-	// The value/s can optionally be executed if it's a function
-	access: function( elems, key, value, exec, fn, pass ) {
-		var length = elems.length;
-
-		// Setting many attributes
-		if ( typeof key === "object" ) {
-			for ( var k in key ) {
-				jQuery.access( elems, k, key[k], exec, fn, value );
-			}
-			return elems;
-		}
-
-		// Setting one attribute
-		if ( value !== undefined ) {
-			// Optionally, function values get executed if exec is true
-			exec = !pass && exec && jQuery.isFunction(value);
-
-			for ( var i = 0; i < length; i++ ) {
-				fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
-			}
-
-			return elems;
-		}
-
-		// Getting an attribute
-		return length ? fn( elems[0], key ) : undefined;
-	},
-
-	now: function() {
-		return ( new Date() ).getTime();
-	},
-
-	// Use of jQuery.browser is frowned upon.
-	// More details: http://docs.jquery.com/Utilities/jQuery.browser
-	uaMatch: function( ua ) {
-		ua = ua.toLowerCase();
-
-		var match = rwebkit.exec( ua ) ||
-			ropera.exec( ua ) ||
-			rmsie.exec( ua ) ||
-			ua.indexOf("compatible") < 0 && rmozilla.exec( ua ) ||
-			[];
-
-		return { browser: match[1] || "", version: match[2] || "0" };
-	},
-
-	sub: function() {
-		function jQuerySub( selector, context ) {
-			return new jQuerySub.fn.init( selector, context );
-		}
-		jQuery.extend( true, jQuerySub, this );
-		jQuerySub.superclass = this;
-		jQuerySub.fn = jQuerySub.prototype = this();
-		jQuerySub.fn.constructor = jQuerySub;
-		jQuerySub.sub = this.sub;
-		jQuerySub.fn.init = function init( selector, context ) {
-			if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
-				context = jQuerySub( context );
-			}
-
-			return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
-		};
-		jQuerySub.fn.init.prototype = jQuerySub.fn;
-		var rootjQuerySub = jQuerySub(document);
-		return jQuerySub;
-	},
-
-	browser: {}
+  noConflict: function( deep ) {
+    if ( window.$ === jQuery ) {
+      window.$ = _$;
+    }
+
+    if ( deep && window.jQuery === jQuery ) {
+      window.jQuery = _jQuery;
+    }
+
+    return jQuery;
+  },
+
+  // Is the DOM ready to be used? Set to true once it occurs.
+  isReady: false,
+
+  // A counter to track how many items to wait for before
+  // the ready event fires. See #6781
+  readyWait: 1,
+
+  // Hold (or release) the ready event
+  holdReady: function( hold ) {
+    if ( hold ) {
+      jQuery.readyWait++;
+    } else {
+      jQuery.ready( true );
+    }
+  },
+
+  // Handle when the DOM is ready
+  ready: function( wait ) {
+    // Either a released hold or an DOMready/load event and not yet ready
+    if ( (wait === true && !--jQuery.readyWait) || (wait !== true && !jQuery.isReady) ) {
+      // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
+      if ( !document.body ) {
+        return setTimeout( jQuery.ready, 1 );
+      }
+
+      // Remember that the DOM is ready
+      jQuery.isReady = true;
+
+      // If a normal DOM Ready event fired, decrement, and wait if need be
+      if ( wait !== true && --jQuery.readyWait > 0 ) {
+        return;
+      }
+
+      // If there are functions bound, to execute
+      readyList.fireWith( document, [ jQuery ] );
+
+      // Trigger any bound ready events
+      if ( jQuery.fn.trigger ) {
+        jQuery( document ).trigger( "ready" ).off( "ready" );
+      }
+    }
+  },
+
+  bindReady: function() {
+    if ( readyList ) {
+      return;
+    }
+
+    readyList = jQuery.Callbacks( "once memory" );
+
+    // Catch cases where $(document).ready() is called after the
+    // browser event has already occurred.
+    if ( document.readyState === "complete" ) {
+      // Handle it asynchronously to allow scripts the opportunity to delay ready
+      return setTimeout( jQuery.ready, 1 );
+    }
+
+    // Mozilla, Opera and webkit nightlies currently support this event
+    if ( document.addEventListener ) {
+      // Use the handy event callback
+      document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );
+
+      // A fallback to window.onload, that will always work
+      window.addEventListener( "load", jQuery.ready, false );
+
+    // If IE event model is used
+    } else if ( document.attachEvent ) {
+      // ensure firing before onload,
+      // maybe late but safe also for iframes
+      document.attachEvent( "onreadystatechange", DOMContentLoaded );
+
+      // A fallback to window.onload, that will always work
+      window.attachEvent( "onload", jQuery.ready );
+
+      // If IE and not a frame
+      // continually check to see if the document is ready
+      var toplevel = false;
+
+      try {
+        toplevel = window.frameElement == null;
+      } catch(e) {}
+
+      if ( document.documentElement.doScroll && toplevel ) {
+        doScrollCheck();
+      }
+    }
+  },
+
+  // See test/unit/core.js for details concerning isFunction.
+  // Since version 1.3, DOM methods and functions like alert
+  // aren't supported. They return false on IE (#2968).
+  isFunction: function( obj ) {
+    return jQuery.type(obj) === "function";
+  },
+
+  isArray: Array.isArray || function( obj ) {
+    return jQuery.type(obj) === "array";
+  },
+
+  // A crude way of determining if an object is a window
+  isWindow: function( obj ) {
+    return obj && typeof obj === "object" && "setInterval" in obj;
+  },
+
+  isNumeric: function( obj ) {
+    return !isNaN( parseFloat(obj) ) && isFinite( obj );
+  },
+
+  type: function( obj ) {
+    return obj == null ?
+      String( obj ) :
+      class2type[ toString.call(obj) ] || "object";
+  },
+
+  isPlainObject: function( obj ) {
+    // Must be an Object.
+    // Because of IE, we also have to check the presence of the constructor property.
+    // Make sure that DOM nodes and window objects don't pass through, as well
+    if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
+      return false;
+    }
+
+    try {
+      // Not own constructor property must be Object
+      if ( obj.constructor &&
+        !hasOwn.call(obj, "constructor") &&
+        !hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
+        return false;
+      }
+    } catch ( e ) {
+      // IE8,9 Will throw exceptions on certain host objects #9897
+      return false;
+    }
+
+    // Own properties are enumerated firstly, so to speed up,
+    // if last one is own, then all properties are own.
+
+    var key;
+    for ( key in obj ) {}
+
+    return key === undefined || hasOwn.call( obj, key );
+  },
+
+  isEmptyObject: function( obj ) {
+    for ( var name in obj ) {
+      return false;
+    }
+    return true;
+  },
+
+  error: function( msg ) {
+    throw new Error( msg );
+  },
+
+  parseJSON: function( data ) {
+    if ( typeof data !== "string" || !data ) {
+      return null;
+    }
+
+    // Make sure leading/trailing whitespace is removed (IE can't handle it)
+    data = jQuery.trim( data );
+
+    // Attempt to parse using the native JSON parser first
+    if ( window.JSON && window.JSON.parse ) {
+      return window.JSON.parse( data );
+    }
+
+    // Make sure the incoming data is actual JSON
+    // Logic borrowed from http://json.org/json2.js
+    if ( rvalidchars.test( data.replace( rvalidescape, "@" )
+      .replace( rvalidtokens, "]" )
+      .replace( rvalidbraces, "")) ) {
+
+      return ( new Function( "return " + data ) )();
+
+    }
+    jQuery.error( "Invalid JSON: " + data );
+  },
+
+  // Cross-browser xml parsing
+  parseXML: function( data ) {
+    var xml, tmp;
+    try {
+      if ( window.DOMParser ) { // Standard
+        tmp = new DOMParser();
+        xml = tmp.parseFromString( data , "text/xml" );
+      } else { // IE
+        xml = new ActiveXObject( "Microsoft.XMLDOM" );
+        xml.async = "false";
+        xml.loadXML( data );
+      }
+    } catch( e ) {
+      xml = undefined;
+    }
+    if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
+      jQuery.error( "Invalid XML: " + data );
+    }
+    return xml;
+  },
+
+  noop: function() {},
+
+  // Evaluates a script in a global context
+  // Workarounds based on findings by Jim Driscoll
+  // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
+  globalEval: function( data ) {
+    if ( data && rnotwhite.test( data ) ) {
+      // We use execScript on Internet Explorer
+      // We use an anonymous function so that context is window
+      // rather than jQuery in Firefox
+      ( window.execScript || function( data ) {
+        window[ "eval" ].call( window, data );
+      } )( data );
+    }
+  },
+
+  // Convert dashed to camelCase; used by the css and data modules
+  // Microsoft forgot to hump their vendor prefix (#9572)
+  camelCase: function( string ) {
+    return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
+  },
+
+  nodeName: function( elem, name ) {
+    return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
+  },
+
+  // args is for internal usage only
+  each: function( object, callback, args ) {
+    var name, i = 0,
+      length = object.length,
+      isObj = length === undefined || jQuery.isFunction( object );
+
+    if ( args ) {
+      if ( isObj ) {
+        for ( name in object ) {
+          if ( callback.apply( object[ name ], args ) === false ) {
+            break;
+          }
+        }
+      } else {
+        for ( ; i < length; ) {
+          if ( callback.apply( object[ i++ ], args ) === false ) {
+            break;
+          }
+        }
+      }
+
+    // A special, fast, case for the most common use of each
+    } else {
+      if ( isObj ) {
+        for ( name in object ) {
+          if ( callback.call( object[ name ], name, object[ name ] ) === false ) {
+            break;
+          }
+        }
+      } else {
+        for ( ; i < length; ) {
+          if ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {
+            break;
+          }
+        }
+      }
+    }
+
+    return object;
+  },
+
+  // Use native String.trim function wherever possible
+  trim: trim ?
+    function( text ) {
+      return text == null ?
+        "" :
+        trim.call( text );
+    } :
+
+    // Otherwise use our own trimming functionality
+    function( text ) {
+      return text == null ?
+        "" :
+        text.toString().replace( trimLeft, "" ).replace( trimRight, "" );
+    },
+
+  // results is for internal usage only
+  makeArray: function( array, results ) {
+    var ret = results || [];
+
+    if ( array != null ) {
+      // The window, strings (and functions) also have 'length'
+      // Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
+      var type = jQuery.type( array );
+
+      if ( array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( array ) ) {
+        push.call( ret, array );
+      } else {
+        jQuery.merge( ret, array );
+      }
+    }
+
+    return ret;
+  },
+
+  inArray: function( elem, array, i ) {
+    var len;
+
+    if ( array ) {
+      if ( indexOf ) {
+        return indexOf.call( array, elem, i );
+      }
+
+      len = array.length;
+      i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;
+
+      for ( ; i < len; i++ ) {
+        // Skip accessing in sparse arrays
+        if ( i in array && array[ i ] === elem ) {
+          return i;
+        }
+      }
+    }
+
+    return -1;
+  },
+
+  merge: function( first, second ) {
+    var i = first.length,
+      j = 0;
+
+    if ( typeof second.length === "number" ) {
+      for ( var l = second.length; j < l; j++ ) {
+        first[ i++ ] = second[ j ];
+      }
+
+    } else {
+      while ( second[j] !== undefined ) {
+        first[ i++ ] = second[ j++ ];
+      }
+    }
+
+    first.length = i;
+
+    return first;
+  },
+
+  grep: function( elems, callback, inv ) {
+    var ret = [], retVal;
+    inv = !!inv;
+
+    // Go through the array, only saving the items
+    // that pass the validator function
+    for ( var i = 0, length = elems.length; i < length; i++ ) {
+      retVal = !!callback( elems[ i ], i );
+      if ( inv !== retVal ) {
+        ret.push( elems[ i ] );
+      }
+    }
+
+    return ret;
+  },
+
+  // arg is for internal usage only
+  map: function( elems, callback, arg ) {
+    var value, key, ret = [],
+      i = 0,
+      length = elems.length,
+      // jquery objects are treated as arrays
+      isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;
+
+    // Go through the array, translating each of the items to their
+    if ( isArray ) {
+      for ( ; i < length; i++ ) {
+        value = callback( elems[ i ], i, arg );
+
+        if ( value != null ) {
+          ret[ ret.length ] = value;
+        }
+      }
+
+    // Go through every key on the object,
+    } else {
+      for ( key in elems ) {
+        value = callback( elems[ key ], key, arg );
+
+        if ( value != null ) {
+          ret[ ret.length ] = value;
+        }
+      }
+    }
+
+    // Flatten any nested arrays
+    return ret.concat.apply( [], ret );
+  },
+
+  // A global GUID counter for objects
+  guid: 1,
+
+  // Bind a function to a context, optionally partially applying any
+  // arguments.
+  proxy: function( fn, context ) {
+    if ( typeof context === "string" ) {
+      var tmp = fn[ context ];
+      context = fn;
+      fn = tmp;
+    }
+
+    // Quick check to determine if target is callable, in the spec
+    // this throws a TypeError, but we will just return undefined.
+    if ( !jQuery.isFunction( fn ) ) {
+      return undefined;
+    }
+
+    // Simulated bind
+    var args = slice.call( arguments, 2 ),
+      proxy = function() {
+        return fn.apply( context, args.concat( slice.call( arguments ) ) );
+      };
+
+    // Set the guid of unique handler to the same of original handler, so it can be removed
+    proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;
+
+    return proxy;
+  },
+
+  // Mutifunctional method to get and set values to a collection
+  // The value/s can optionally be executed if it's a function
+  access: function( elems, key, value, exec, fn, pass ) {
+    var length = elems.length;
+
+    // Setting many attributes
+    if ( typeof key === "object" ) {
+      for ( var k in key ) {
+        jQuery.access( elems, k, key[k], exec, fn, value );
+      }
+      return elems;
+    }
+
+    // Setting one attribute
+    if ( value !== undefined ) {
+      // Optionally, function values get executed if exec is true
+      exec = !pass && exec && jQuery.isFunction(value);
+
+      for ( var i = 0; i < length; i++ ) {
+        fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
+      }
+
+      return elems;
+    }
+
+    // Getting an attribute
+    return length ? fn( elems[0], key ) : undefined;
+  },
+
+  now: function() {
+    return ( new Date() ).getTime();
+  },
+
+  // Use of jQuery.browser is frowned upon.
+  // More details: http://docs.jquery.com/Utilities/jQuery.browser
+  uaMatch: function( ua ) {
+    ua = ua.toLowerCase();
+
+    var match = rwebkit.exec( ua ) ||
+      ropera.exec( ua ) ||
+      rmsie.exec( ua ) ||
+      ua.indexOf("compatible") < 0 && rmozilla.exec( ua ) ||
+      [];
+
+    return { browser: match[1] || "", version: match[2] || "0" };
+  },
+
+  sub: function() {
+    function jQuerySub( selector, context ) {
+      return new jQuerySub.fn.init( selector, context );
+    }
+    jQuery.extend( true, jQuerySub, this );
+    jQuerySub.superclass = this;
+    jQuerySub.fn = jQuerySub.prototype = this();
+    jQuerySub.fn.constructor = jQuerySub;
+    jQuerySub.sub = this.sub;
+    jQuerySub.fn.init = function init( selector, context ) {
+      if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
+        context = jQuerySub( context );
+      }
+
+      return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
+    };
+    jQuerySub.fn.init.prototype = jQuerySub.fn;
+    var rootjQuerySub = jQuerySub(document);
+    return jQuerySub;
+  },
+
+  browser: {}
 });
 
 // Populate the class2type map
 jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
-	class2type[ "[object " + name + "]" ] = name.toLowerCase();
+  class2type[ "[object " + name + "]" ] = name.toLowerCase();
 });
 
 browserMatch = jQuery.uaMatch( userAgent );
 if ( browserMatch.browser ) {
-	jQuery.browser[ browserMatch.browser ] = true;
-	jQuery.browser.version = browserMatch.version;
+  jQuery.browser[ browserMatch.browser ] = true;
+  jQuery.browser.version = browserMatch.version;
 }
 
 // Deprecated, use jQuery.browser.webkit instead
 if ( jQuery.browser.webkit ) {
-	jQuery.browser.safari = true;
+  jQuery.browser.safari = true;
 }
 
 // IE doesn't match non-breaking spaces with \s
 if ( rnotwhite.test( "\xA0" ) ) {
-	trimLeft = /^[\s\xA0]+/;
-	trimRight = /[\s\xA0]+$/;
+  trimLeft = /^[\s\xA0]+/;
+  trimRight = /[\s\xA0]+$/;
 }
 
 // All jQuery objects should point back to these
@@ -2998,38 +2998,38 @@ rootjQuery = jQuery(document);
 
 // Cleanup functions for the document ready method
 if ( document.addEventListener ) {
-	DOMContentLoaded = function() {
-		document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
-		jQuery.ready();
-	};
+  DOMContentLoaded = function() {
+    document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
+    jQuery.ready();
+  };
 
 } else if ( document.attachEvent ) {
-	DOMContentLoaded = function() {
-		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
-		if ( document.readyState === "complete" ) {
-			document.detachEvent( "onreadystatechange", DOMContentLoaded );
-			jQuery.ready();
-		}
-	};
+  DOMContentLoaded = function() {
+    // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
+    if ( document.readyState === "complete" ) {
+      document.detachEvent( "onreadystatechange", DOMContentLoaded );
+      jQuery.ready();
+    }
+  };
 }
 
 // The DOM ready check for Internet Explorer
 function doScrollCheck() {
-	if ( jQuery.isReady ) {
-		return;
-	}
-
-	try {
-		// If IE is used, use the trick by Diego Perini
-		// http://javascript.nwbox.com/IEContentLoaded/
-		document.documentElement.doScroll("left");
-	} catch(e) {
-		setTimeout( doScrollCheck, 1 );
-		return;
-	}
-
-	// and execute any waiting functions
-	jQuery.ready();
+  if ( jQuery.isReady ) {
+    return;
+  }
+
+  try {
+    // If IE is used, use the trick by Diego Perini
+    // http://javascript.nwbox.com/IEContentLoaded/
+    document.documentElement.doScroll("left");
+  } catch(e) {
+    setTimeout( doScrollCheck, 1 );
+    return;
+  }
+
+  // and execute any waiting functions
+  jQuery.ready();
 }
 
 return jQuery;
@@ -3042,2455 +3042,2455 @@ var flagsCache = {};
 
 // Convert String-formatted flags into Object-formatted ones and store in cache
 function createFlags( flags ) {
-	var object = flagsCache[ flags ] = {},
-		i, length;
-	flags = flags.split( /\s+/ );
-	for ( i = 0, length = flags.length; i < length; i++ ) {
-		object[ flags[i] ] = true;
-	}
-	return object;
+  var object = flagsCache[ flags ] = {},
+    i, length;
+  flags = flags.split( /\s+/ );
+  for ( i = 0, length = flags.length; i < length; i++ ) {
+    object[ flags[i] ] = true;
+  }
+  return object;
 }
 
 /*
  * Create a callback list using the following parameters:
  *
- *	flags:	an optional list of space-separated flags that will change how
- *			the callback list behaves
+ *  flags:  an optional list of space-separated flags that will change how
+ *      the callback list behaves
  *
  * By default a callback list will act like an event callback list and can be
  * "fired" multiple times.
  *
  * Possible flags:
  *
- *	once:			will ensure the callback list can only be fired once (like a Deferred)
+ *  once:      will ensure the callback list can only be fired once (like a Deferred)
  *
- *	memory:			will keep track of previous values and will call any callback added
- *					after the list has been fired right away with the latest "memorized"
- *					values (like a Deferred)
+ *  memory:      will keep track of previous values and will call any callback added
+ *          after the list has been fired right away with the latest "memorized"
+ *          values (like a Deferred)
  *
- *	unique:			will ensure a callback can only be added once (no duplicate in the list)
+ *  unique:      will ensure a callback can only be added once (no duplicate in the list)
  *
- *	stopOnFalse:	interrupt callings when a callback returns false
+ *  stopOnFalse:  interrupt callings when a callback returns false
  *
  */
 jQuery.Callbacks = function( flags ) {
 
-	// Convert flags from String-formatted to Object-formatted
-	// (we check in cache first)
-	flags = flags ? ( flagsCache[ flags ] || createFlags( flags ) ) : {};
-
-	var // Actual callback list
-		list = [],
-		// Stack of fire calls for repeatable lists
-		stack = [],
-		// Last fire value (for non-forgettable lists)
-		memory,
-		// Flag to know if list is currently firing
-		firing,
-		// First callback to fire (used internally by add and fireWith)
-		firingStart,
-		// End of the loop when firing
-		firingLength,
-		// Index of currently firing callback (modified by remove if needed)
-		firingIndex,
-		// Add one or several callbacks to the list
-		add = function( args ) {
-			var i,
-				length,
-				elem,
-				type,
-				actual;
-			for ( i = 0, length = args.length; i < length; i++ ) {
-				elem = args[ i ];
-				type = jQuery.type( elem );
-				if ( type === "array" ) {
-					// Inspect recursively
-					add( elem );
-				} else if ( type === "function" ) {
-					// Add if not in unique mode and callback is not in
-					if ( !flags.unique || !self.has( elem ) ) {
-						list.push( elem );
-					}
-				}
-			}
-		},
-		// Fire callbacks
-		fire = function( context, args ) {
-			args = args || [];
-			memory = !flags.memory || [ context, args ];
-			firing = true;
-			firingIndex = firingStart || 0;
-			firingStart = 0;
-			firingLength = list.length;
-			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
-				if ( list[ firingIndex ].apply( context, args ) === false && flags.stopOnFalse ) {
-					memory = true; // Mark as halted
-					break;
-				}
-			}
-			firing = false;
-			if ( list ) {
-				if ( !flags.once ) {
-					if ( stack && stack.length ) {
-						memory = stack.shift();
-						self.fireWith( memory[ 0 ], memory[ 1 ] );
-					}
-				} else if ( memory === true ) {
-					self.disable();
-				} else {
-					list = [];
-				}
-			}
-		},
-		// Actual Callbacks object
-		self = {
-			// Add a callback or a collection of callbacks to the list
-			add: function() {
-				if ( list ) {
-					var length = list.length;
-					add( arguments );
-					// Do we need to add the callbacks to the
-					// current firing batch?
-					if ( firing ) {
-						firingLength = list.length;
-					// With memory, if we're not firing then
-					// we should call right away, unless previous
-					// firing was halted (stopOnFalse)
-					} else if ( memory && memory !== true ) {
-						firingStart = length;
-						fire( memory[ 0 ], memory[ 1 ] );
-					}
-				}
-				return this;
-			},
-			// Remove a callback from the list
-			remove: function() {
-				if ( list ) {
-					var args = arguments,
-						argIndex = 0,
-						argLength = args.length;
-					for ( ; argIndex < argLength ; argIndex++ ) {
-						for ( var i = 0; i < list.length; i++ ) {
-							if ( args[ argIndex ] === list[ i ] ) {
-								// Handle firingIndex and firingLength
-								if ( firing ) {
-									if ( i <= firingLength ) {
-										firingLength--;
-										if ( i <= firingIndex ) {
-											firingIndex--;
-										}
-									}
-								}
-								// Remove the element
-								list.splice( i--, 1 );
-								// If we have some unicity property then
-								// we only need to do this once
-								if ( flags.unique ) {
-									break;
-								}
-							}
-						}
-					}
-				}
-				return this;
-			},
-			// Control if a given callback is in the list
-			has: function( fn ) {
-				if ( list ) {
-					var i = 0,
-						length = list.length;
-					for ( ; i < length; i++ ) {
-						if ( fn === list[ i ] ) {
-							return true;
-						}
-					}
-				}
-				return false;
-			},
-			// Remove all callbacks from the list
-			empty: function() {
-				list = [];
-				return this;
-			},
-			// Have the list do nothing anymore
-			disable: function() {
-				list = stack = memory = undefined;
-				return this;
-			},
-			// Is it disabled?
-			disabled: function() {
-				return !list;
-			},
-			// Lock the list in its current state
-			lock: function() {
-				stack = undefined;
-				if ( !memory || memory === true ) {
-					self.disable();
-				}
-				return this;
-			},
-			// Is it locked?
-			locked: function() {
-				return !stack;
-			},
-			// Call all callbacks with the given context and arguments
-			fireWith: function( context, args ) {
-				if ( stack ) {
-					if ( firing ) {
-						if ( !flags.once ) {
-							stack.push( [ context, args ] );
-						}
-					} else if ( !( flags.once && memory ) ) {
-						fire( context, args );
-					}
-				}
-				return this;
-			},
-			// Call all the callbacks with the given arguments
-			fire: function() {
-				self.fireWith( this, arguments );
-				return this;
-			},
-			// To know if the callbacks have already been called at least once
-			fired: function() {
-				return !!memory;
-			}
-		};
-
-	return self;
+  // Convert flags from String-formatted to Object-formatted
+  // (we check in cache first)
+  flags = flags ? ( flagsCache[ flags ] || createFlags( flags ) ) : {};
+
+  var // Actual callback list
+    list = [],
+    // Stack of fire calls for repeatable lists
+    stack = [],
+    // Last fire value (for non-forgettable lists)
+    memory,
+    // Flag to know if list is currently firing
+    firing,
+    // First callback to fire (used internally by add and fireWith)
+    firingStart,
+    // End of the loop when firing
+    firingLength,
+    // Index of currently firing callback (modified by remove if needed)
+    firingIndex,
+    // Add one or several callbacks to the list
+    add = function( args ) {
+      var i,
+        length,
+        elem,
+        type,
+        actual;
+      for ( i = 0, length = args.length; i < length; i++ ) {
+        elem = args[ i ];
+        type = jQuery.type( elem );
+        if ( type === "array" ) {
+          // Inspect recursively
+          add( elem );
+        } else if ( type === "function" ) {
+          // Add if not in unique mode and callback is not in
+          if ( !flags.unique || !self.has( elem ) ) {
+            list.push( elem );
+          }
+        }
+      }
+    },
+    // Fire callbacks
+    fire = function( context, args ) {
+      args = args || [];
+      memory = !flags.memory || [ context, args ];
+      firing = true;
+      firingIndex = firingStart || 0;
+      firingStart = 0;
+      firingLength = list.length;
+      for ( ; list && firingIndex < firingLength; firingIndex++ ) {
+        if ( list[ firingIndex ].apply( context, args ) === false && flags.stopOnFalse ) {
+          memory = true; // Mark as halted
+          break;
+        }
+      }
+      firing = false;
+      if ( list ) {
+        if ( !flags.once ) {
+          if ( stack && stack.length ) {
+            memory = stack.shift();
+            self.fireWith( memory[ 0 ], memory[ 1 ] );
+          }
+        } else if ( memory === true ) {
+          self.disable();
+        } else {
+          list = [];
+        }
+      }
+    },
+    // Actual Callbacks object
+    self = {
+      // Add a callback or a collection of callbacks to the list
+      add: function() {
+        if ( list ) {
+          var length = list.length;
+          add( arguments );
+          // Do we need to add the callbacks to the
+          // current firing batch?
+          if ( firing ) {
+            firingLength = list.length;
+          // With memory, if we're not firing then
+          // we should call right away, unless previous
+          // firing was halted (stopOnFalse)
+          } else if ( memory && memory !== true ) {
+            firingStart = length;
+            fire( memory[ 0 ], memory[ 1 ] );
+          }
+        }
+        return this;
+      },
+      // Remove a callback from the list
+      remove: function() {
+        if ( list ) {
+          var args = arguments,
+            argIndex = 0,
+            argLength = args.length;
+          for ( ; argIndex < argLength ; argIndex++ ) {
+            for ( var i = 0; i < list.length; i++ ) {
+              if ( args[ argIndex ] === list[ i ] ) {
+                // Handle firingIndex and firingLength
+                if ( firing ) {
+                  if ( i <= firingLength ) {
+                    firingLength--;
+                    if ( i <= firingIndex ) {
+                      firingIndex--;
+                    }
+                  }
+                }
+                // Remove the element
+                list.splice( i--, 1 );
+                // If we have some unicity property then
+                // we only need to do this once
+                if ( flags.unique ) {
+                  break;
+                }
+              }
+            }
+          }
+        }
+        return this;
+      },
+      // Control if a given callback is in the list
+      has: function( fn ) {
+        if ( list ) {
+          var i = 0,
+            length = list.length;
+          for ( ; i < length; i++ ) {
+            if ( fn === list[ i ] ) {
+              return true;
+            }
+          }
+        }
+        return false;
+      },
+      // Remove all callbacks from the list
+      empty: function() {
+        list = [];
+        return this;
+      },
+      // Have the list do nothing anymore
+      disable: function() {
+        list = stack = memory = undefined;
+        return this;
+      },
+      // Is it disabled?
+      disabled: function() {
+        return !list;
+      },
+      // Lock the list in its current state
+      lock: function() {
+        stack = undefined;
+        if ( !memory || memory === true ) {
+          self.disable();
+        }
+        return this;
+      },
+      // Is it locked?
+      locked: function() {
+        return !stack;
+      },
+      // Call all callbacks with the given context and arguments
+      fireWith: function( context, args ) {
+        if ( stack ) {
+          if ( firing ) {
+            if ( !flags.once ) {
+              stack.push( [ context, args ] );
+            }
+          } else if ( !( flags.once && memory ) ) {
+            fire( context, args );
+          }
+        }
+        return this;
+      },
+      // Call all the callbacks with the given arguments
+      fire: function() {
+        self.fireWith( this, arguments );
+        return this;
+      },
+      // To know if the callbacks have already been called at least once
+      fired: function() {
+        return !!memory;
+      }
+    };
+
+  return self;
 };
 
 
 
 
 var // Static reference to slice
-	sliceDeferred = [].slice;
+  sliceDeferred = [].slice;
 
 jQuery.extend({
 
-	Deferred: function( func ) {
-		var doneList = jQuery.Callbacks( "once memory" ),
-			failList = jQuery.Callbacks( "once memory" ),
-			progressList = jQuery.Callbacks( "memory" ),
-			state = "pending",
-			lists = {
-				resolve: doneList,
-				reject: failList,
-				notify: progressList
-			},
-			promise = {
-				done: doneList.add,
-				fail: failList.add,
-				progress: progressList.add,
-
-				state: function() {
-					return state;
-				},
-
-				// Deprecated
-				isResolved: doneList.fired,
-				isRejected: failList.fired,
-
-				then: function( doneCallbacks, failCallbacks, progressCallbacks ) {
-					deferred.done( doneCallbacks ).fail( failCallbacks ).progress( progressCallbacks );
-					return this;
-				},
-				always: function() {
-					deferred.done.apply( deferred, arguments ).fail.apply( deferred, arguments );
-					return this;
-				},
-				pipe: function( fnDone, fnFail, fnProgress ) {
-					return jQuery.Deferred(function( newDefer ) {
-						jQuery.each( {
-							done: [ fnDone, "resolve" ],
-							fail: [ fnFail, "reject" ],
-							progress: [ fnProgress, "notify" ]
-						}, function( handler, data ) {
-							var fn = data[ 0 ],
-								action = data[ 1 ],
-								returned;
-							if ( jQuery.isFunction( fn ) ) {
-								deferred[ handler ](function() {
-									returned = fn.apply( this, arguments );
-									if ( returned && jQuery.isFunction( returned.promise ) ) {
-										returned.promise().then( newDefer.resolve, newDefer.reject, newDefer.notify );
-									} else {
-										newDefer[ action + "With" ]( this === deferred ? newDefer : this, [ returned ] );
-									}
-								});
-							} else {
-								deferred[ handler ]( newDefer[ action ] );
-							}
-						});
-					}).promise();
-				},
-				// Get a promise for this deferred
-				// If obj is provided, the promise aspect is added to the object
-				promise: function( obj ) {
-					if ( obj == null ) {
-						obj = promise;
-					} else {
-						for ( var key in promise ) {
-							obj[ key ] = promise[ key ];
-						}
-					}
-					return obj;
-				}
-			},
-			deferred = promise.promise({}),
-			key;
-
-		for ( key in lists ) {
-			deferred[ key ] = lists[ key ].fire;
-			deferred[ key + "With" ] = lists[ key ].fireWith;
-		}
-
-		// Handle state
-		deferred.done( function() {
-			state = "resolved";
-		}, failList.disable, progressList.lock ).fail( function() {
-			state = "rejected";
-		}, doneList.disable, progressList.lock );
-
-		// Call given func if any
-		if ( func ) {
-			func.call( deferred, deferred );
-		}
-
-		// All done!
-		return deferred;
-	},
-
-	// Deferred helper
-	when: function( firstParam ) {
-		var args = sliceDeferred.call( arguments, 0 ),
-			i = 0,
-			length = args.length,
-			pValues = new Array( length ),
-			count = length,
-			pCount = length,
-			deferred = length <= 1 && firstParam && jQuery.isFunction( firstParam.promise ) ?
-				firstParam :
-				jQuery.Deferred(),
-			promise = deferred.promise();
-		function resolveFunc( i ) {
-			return function( value ) {
-				args[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
-				if ( !( --count ) ) {
-					deferred.resolveWith( deferred, args );
-				}
-			};
-		}
-		function progressFunc( i ) {
-			return function( value ) {
-				pValues[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
-				deferred.notifyWith( promise, pValues );
-			};
-		}
-		if ( length > 1 ) {
-			for ( ; i < length; i++ ) {
-				if ( args[ i ] && args[ i ].promise && jQuery.isFunction( args[ i ].promise ) ) {
-					args[ i ].promise().then( resolveFunc(i), deferred.reject, progressFunc(i) );
-				} else {
-					--count;
-				}
-			}
-			if ( !count ) {
-				deferred.resolveWith( deferred, args );
-			}
-		} else if ( deferred !== firstParam ) {
-			deferred.resolveWith( deferred, length ? [ firstParam ] : [] );
-		}
-		return promise;
-	}
-});
-
+  Deferred: function( func ) {
+    var doneList = jQuery.Callbacks( "once memory" ),
+      failList = jQuery.Callbacks( "once memory" ),
+      progressList = jQuery.Callbacks( "memory" ),
+      state = "pending",
+      lists = {
+        resolve: doneList,
+        reject: failList,
+        notify: progressList
+      },
+      promise = {
+        done: doneList.add,
+        fail: failList.add,
+        progress: progressList.add,
+
+        state: function() {
+          return state;
+        },
 
+        // Deprecated
+        isResolved: doneList.fired,
+        isRejected: failList.fired,
 
+        then: function( doneCallbacks, failCallbacks, progressCallbacks ) {
+          deferred.done( doneCallbacks ).fail( failCallbacks ).progress( progressCallbacks );
+          return this;
+        },
+        always: function() {
+          deferred.done.apply( deferred, arguments ).fail.apply( deferred, arguments );
+          return this;
+        },
+        pipe: function( fnDone, fnFail, fnProgress ) {
+          return jQuery.Deferred(function( newDefer ) {
+            jQuery.each( {
+              done: [ fnDone, "resolve" ],
+              fail: [ fnFail, "reject" ],
+              progress: [ fnProgress, "notify" ]
+            }, function( handler, data ) {
+              var fn = data[ 0 ],
+                action = data[ 1 ],
+                returned;
+              if ( jQuery.isFunction( fn ) ) {
+                deferred[ handler ](function() {
+                  returned = fn.apply( this, arguments );
+                  if ( returned && jQuery.isFunction( returned.promise ) ) {
+                    returned.promise().then( newDefer.resolve, newDefer.reject, newDefer.notify );
+                  } else {
+                    newDefer[ action + "With" ]( this === deferred ? newDefer : this, [ returned ] );
+                  }
+                });
+              } else {
+                deferred[ handler ]( newDefer[ action ] );
+              }
+            });
+          }).promise();
+        },
+        // Get a promise for this deferred
+        // If obj is provided, the promise aspect is added to the object
+        promise: function( obj ) {
+          if ( obj == null ) {
+            obj = promise;
+          } else {
+            for ( var key in promise ) {
+              obj[ key ] = promise[ key ];
+            }
+          }
+          return obj;
+        }
+      },
+      deferred = promise.promise({}),
+      key;
 
-jQuery.support = (function() {
+    for ( key in lists ) {
+      deferred[ key ] = lists[ key ].fire;
+      deferred[ key + "With" ] = lists[ key ].fireWith;
+    }
 
-	var support,
-		all,
-		a,
-		select,
-		opt,
-		input,
-		marginDiv,
-		fragment,
-		tds,
-		events,
-		eventName,
-		i,
-		isSupported,
-		div = document.createElement( "div" ),
-		documentElement = document.documentElement;
-
-	// Preliminary tests
-	div.setAttribute("className", "t");
-	div.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";
-
-	all = div.getElementsByTagName( "*" );
-	a = div.getElementsByTagName( "a" )[ 0 ];
-
-	// Can't get basic test support
-	if ( !all || !all.length || !a ) {
-		return {};
-	}
-
-	// First batch of supports tests
-	select = document.createElement( "select" );
-	opt = select.appendChild( document.createElement("option") );
-	input = div.getElementsByTagName( "input" )[ 0 ];
-
-	support = {
-		// IE strips leading whitespace when .innerHTML is used
-		leadingWhitespace: ( div.firstChild.nodeType === 3 ),
-
-		// Make sure that tbody elements aren't automatically inserted
-		// IE will insert them into empty tables
-		tbody: !div.getElementsByTagName("tbody").length,
-
-		// Make sure that link elements get serialized correctly by innerHTML
-		// This requires a wrapper element in IE
-		htmlSerialize: !!div.getElementsByTagName("link").length,
-
-		// Get the style information from getAttribute
-		// (IE uses .cssText instead)
-		style: /top/.test( a.getAttribute("style") ),
-
-		// Make sure that URLs aren't manipulated
-		// (IE normalizes it by default)
-		hrefNormalized: ( a.getAttribute("href") === "/a" ),
-
-		// Make sure that element opacity exists
-		// (IE uses filter instead)
-		// Use a regex to work around a WebKit issue. See #5145
-		opacity: /^0.55/.test( a.style.opacity ),
-
-		// Verify style float existence
-		// (IE uses styleFloat instead of cssFloat)
-		cssFloat: !!a.style.cssFloat,
-
-		// Make sure that if no value is specified for a checkbox
-		// that it defaults to "on".
-		// (WebKit defaults to "" instead)
-		checkOn: ( input.value === "on" ),
-
-		// Make sure that a selected-by-default option has a working selected property.
-		// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
-		optSelected: opt.selected,
-
-		// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
-		getSetAttribute: div.className !== "t",
-
-		// Tests for enctype support on a form(#6743)
-		enctype: !!document.createElement("form").enctype,
-
-		// Makes sure cloning an html5 element does not cause problems
-		// Where outerHTML is undefined, this still works
-		html5Clone: document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>",
-
-		// Will be defined later
-		submitBubbles: true,
-		changeBubbles: true,
-		focusinBubbles: false,
-		deleteExpando: true,
-		noCloneEvent: true,
-		inlineBlockNeedsLayout: false,
-		shrinkWrapBlocks: false,
-		reliableMarginRight: true
-	};
-
-	// Make sure checked status is properly cloned
-	input.checked = true;
-	support.noCloneChecked = input.cloneNode( true ).checked;
-
-	// Make sure that the options inside disabled selects aren't marked as disabled
-	// (WebKit marks them as disabled)
-	select.disabled = true;
-	support.optDisabled = !opt.disabled;
-
-	// Test to see if it's possible to delete an expando from an element
-	// Fails in Internet Explorer
-	try {
-		delete div.test;
-	} catch( e ) {
-		support.deleteExpando = false;
-	}
-
-	if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {
-		div.attachEvent( "onclick", function() {
-			// Cloning a node shouldn't copy over any
-			// bound event handlers (IE does this)
-			support.noCloneEvent = false;
-		});
-		div.cloneNode( true ).fireEvent( "onclick" );
-	}
-
-	// Check if a radio maintains its value
-	// after being appended to the DOM
-	input = document.createElement("input");
-	input.value = "t";
-	input.setAttribute("type", "radio");
-	support.radioValue = input.value === "t";
-
-	input.setAttribute("checked", "checked");
-	div.appendChild( input );
-	fragment = document.createDocumentFragment();
-	fragment.appendChild( div.lastChild );
-
-	// WebKit doesn't clone checked state correctly in fragments
-	support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;
-
-	// Check if a disconnected checkbox will retain its checked
-	// value of true after appended to the DOM (IE6/7)
-	support.appendChecked = input.checked;
-
-	fragment.removeChild( input );
-	fragment.appendChild( div );
-
-	div.innerHTML = "";
-
-	// Check if div with explicit width and no margin-right incorrectly
-	// gets computed margin-right based on width of container. For more
-	// info see bug #3333
-	// Fails in WebKit before Feb 2011 nightlies
-	// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
-	if ( window.getComputedStyle ) {
-		marginDiv = document.createElement( "div" );
-		marginDiv.style.width = "0";
-		marginDiv.style.marginRight = "0";
-		div.style.width = "2px";
-		div.appendChild( marginDiv );
-		support.reliableMarginRight =
-			( parseInt( ( window.getComputedStyle( marginDiv, null ) || { marginRight: 0 } ).marginRight, 10 ) || 0 ) === 0;
-	}
-
-	// Technique from Juriy Zaytsev
-	// http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
-	// We only care about the case where non-standard event systems
-	// are used, namely in IE. Short-circuiting here helps us to
-	// avoid an eval call (in setAttribute) which can cause CSP
-	// to go haywire. See: https://developer.mozilla.org/en/Security/CSP
-	if ( div.attachEvent ) {
-		for( i in {
-			submit: 1,
-			change: 1,
-			focusin: 1
-		}) {
-			eventName = "on" + i;
-			isSupported = ( eventName in div );
-			if ( !isSupported ) {
-				div.setAttribute( eventName, "return;" );
-				isSupported = ( typeof div[ eventName ] === "function" );
-			}
-			support[ i + "Bubbles" ] = isSupported;
-		}
-	}
-
-	fragment.removeChild( div );
-
-	// Null elements to avoid leaks in IE
-	fragment = select = opt = marginDiv = div = input = null;
-
-	// Run tests that need a body at doc ready
-	jQuery(function() {
-		var container, outer, inner, table, td, offsetSupport,
-			conMarginTop, ptlm, vb, style, html,
-			body = document.getElementsByTagName("body")[0];
-
-		if ( !body ) {
-			// Return for frameset docs that don't have a body
-			return;
-		}
-
-		conMarginTop = 1;
-		ptlm = "position:absolute;top:0;left:0;width:1px;height:1px;margin:0;";
-		vb = "visibility:hidden;border:0;";
-		style = "style='" + ptlm + "border:5px solid #000;padding:0;'";
-		html = "<div " + style + "><div></div></div>" +
-			"<table " + style + " cellpadding='0' cellspacing='0'>" +
-			"<tr><td></td></tr></table>";
-
-		container = document.createElement("div");
-		container.style.cssText = vb + "width:0;height:0;position:static;top:0;margin-top:" + conMarginTop + "px";
-		body.insertBefore( container, body.firstChild );
-
-		// Construct the test element
-		div = document.createElement("div");
-		container.appendChild( div );
-
-		// Check if table cells still have offsetWidth/Height when they are set
-		// to display:none and there are still other visible table cells in a
-		// table row; if so, offsetWidth/Height are not reliable for use when
-		// determining if an element has been hidden directly using
-		// display:none (it is still safe to use offsets if a parent element is
-		// hidden; don safety goggles and see bug #4512 for more information).
-		// (only IE 8 fails this test)
-		div.innerHTML = "<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>";
-		tds = div.getElementsByTagName( "td" );
-		isSupported = ( tds[ 0 ].offsetHeight === 0 );
-
-		tds[ 0 ].style.display = "";
-		tds[ 1 ].style.display = "none";
-
-		// Check if empty table cells still have offsetWidth/Height
-		// (IE <= 8 fail this test)
-		support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );
-
-		// Figure out if the W3C box model works as expected
-		div.innerHTML = "";
-		div.style.width = div.style.paddingLeft = "1px";
-		jQuery.boxModel = support.boxModel = div.offsetWidth === 2;
-
-		if ( typeof div.style.zoom !== "undefined" ) {
-			// Check if natively block-level elements act like inline-block
-			// elements when setting their display to 'inline' and giving
-			// them layout
-			// (IE < 8 does this)
-			div.style.display = "inline";
-			div.style.zoom = 1;
-			support.inlineBlockNeedsLayout = ( div.offsetWidth === 2 );
-
-			// Check if elements with layout shrink-wrap their children
-			// (IE 6 does this)
-			div.style.display = "";
-			div.innerHTML = "<div style='width:4px;'></div>";
-			support.shrinkWrapBlocks = ( div.offsetWidth !== 2 );
-		}
-
-		div.style.cssText = ptlm + vb;
-		div.innerHTML = html;
-
-		outer = div.firstChild;
-		inner = outer.firstChild;
-		td = outer.nextSibling.firstChild.firstChild;
-
-		offsetSupport = {
-			doesNotAddBorder: ( inner.offsetTop !== 5 ),
-			doesAddBorderForTableAndCells: ( td.offsetTop === 5 )
-		};
-
-		inner.style.position = "fixed";
-		inner.style.top = "20px";
-
-		// safari subtracts parent border width here which is 5px
-		offsetSupport.fixedPosition = ( inner.offsetTop === 20 || inner.offsetTop === 15 );
-		inner.style.position = inner.style.top = "";
-
-		outer.style.overflow = "hidden";
-		outer.style.position = "relative";
-
-		offsetSupport.subtractsBorderForOverflowNotVisible = ( inner.offsetTop === -5 );
-		offsetSupport.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== conMarginTop );
-
-		body.removeChild( container );
-		div  = container = null;
-
-		jQuery.extend( support, offsetSupport );
-	});
-
-	return support;
-})();
+    // Handle state
+    deferred.done( function() {
+      state = "resolved";
+    }, failList.disable, progressList.lock ).fail( function() {
+      state = "rejected";
+    }, doneList.disable, progressList.lock );
 
+    // Call given func if any
+    if ( func ) {
+      func.call( deferred, deferred );
+    }
 
+    // All done!
+    return deferred;
+  },
+
+  // Deferred helper
+  when: function( firstParam ) {
+    var args = sliceDeferred.call( arguments, 0 ),
+      i = 0,
+      length = args.length,
+      pValues = new Array( length ),
+      count = length,
+      pCount = length,
+      deferred = length <= 1 && firstParam && jQuery.isFunction( firstParam.promise ) ?
+        firstParam :
+        jQuery.Deferred(),
+      promise = deferred.promise();
+    function resolveFunc( i ) {
+      return function( value ) {
+        args[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
+        if ( !( --count ) ) {
+          deferred.resolveWith( deferred, args );
+        }
+      };
+    }
+    function progressFunc( i ) {
+      return function( value ) {
+        pValues[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
+        deferred.notifyWith( promise, pValues );
+      };
+    }
+    if ( length > 1 ) {
+      for ( ; i < length; i++ ) {
+        if ( args[ i ] && args[ i ].promise && jQuery.isFunction( args[ i ].promise ) ) {
+          args[ i ].promise().then( resolveFunc(i), deferred.reject, progressFunc(i) );
+        } else {
+          --count;
+        }
+      }
+      if ( !count ) {
+        deferred.resolveWith( deferred, args );
+      }
+    } else if ( deferred !== firstParam ) {
+      deferred.resolveWith( deferred, length ? [ firstParam ] : [] );
+    }
+    return promise;
+  }
+});
 
 
-var rbrace = /^(?:\{.*\}|\[.*\])$/,
-	rmultiDash = /([A-Z])/g;
 
-jQuery.extend({
-	cache: {},
-
-	// Please use with caution
-	uuid: 0,
-
-	// Unique for each copy of jQuery on the page
-	// Non-digits removed to match rinlinejQuery
-	expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),
-
-	// The following elements throw uncatchable exceptions if you
-	// attempt to add expando properties to them.
-	noData: {
-		"embed": true,
-		// Ban all objects except for Flash (which handle expandos)
-		"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
-		"applet": true
-	},
-
-	hasData: function( elem ) {
-		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
-		return !!elem && !isEmptyDataObject( elem );
-	},
-
-	data: function( elem, name, data, pvt /* Internal Use Only */ ) {
-		if ( !jQuery.acceptData( elem ) ) {
-			return;
-		}
-
-		var privateCache, thisCache, ret,
-			internalKey = jQuery.expando,
-			getByName = typeof name === "string",
-
-			// We have to handle DOM nodes and JS objects differently because IE6-7
-			// can't GC object references properly across the DOM-JS boundary
-			isNode = elem.nodeType,
-
-			// Only DOM nodes need the global jQuery cache; JS object data is
-			// attached directly to the object so GC can occur automatically
-			cache = isNode ? jQuery.cache : elem,
-
-			// Only defining an ID for JS objects if its cache already exists allows
-			// the code to shortcut on the same path as a DOM node with no cache
-			id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey,
-			isEvents = name === "events";
-
-		// Avoid doing any more work than we need to when trying to get data on an
-		// object that has no data at all
-		if ( (!id || !cache[id] || (!isEvents && !pvt && !cache[id].data)) && getByName && data === undefined ) {
-			return;
-		}
-
-		if ( !id ) {
-			// Only DOM nodes need a new unique ID for each element since their data
-			// ends up in the global cache
-			if ( isNode ) {
-				elem[ internalKey ] = id = ++jQuery.uuid;
-			} else {
-				id = internalKey;
-			}
-		}
-
-		if ( !cache[ id ] ) {
-			cache[ id ] = {};
-
-			// Avoids exposing jQuery metadata on plain JS objects when the object
-			// is serialized using JSON.stringify
-			if ( !isNode ) {
-				cache[ id ].toJSON = jQuery.noop;
-			}
-		}
-
-		// An object can be passed to jQuery.data instead of a key/value pair; this gets
-		// shallow copied over onto the existing cache
-		if ( typeof name === "object" || typeof name === "function" ) {
-			if ( pvt ) {
-				cache[ id ] = jQuery.extend( cache[ id ], name );
-			} else {
-				cache[ id ].data = jQuery.extend( cache[ id ].data, name );
-			}
-		}
-
-		privateCache = thisCache = cache[ id ];
-
-		// jQuery data() is stored in a separate object inside the object's internal data
-		// cache in order to avoid key collisions between internal data and user-defined
-		// data.
-		if ( !pvt ) {
-			if ( !thisCache.data ) {
-				thisCache.data = {};
-			}
-
-			thisCache = thisCache.data;
-		}
-
-		if ( data !== undefined ) {
-			thisCache[ jQuery.camelCase( name ) ] = data;
-		}
-
-		// Users should not attempt to inspect the internal events object using jQuery.data,
-		// it is undocumented and subject to change. But does anyone listen? No.
-		if ( isEvents && !thisCache[ name ] ) {
-			return privateCache.events;
-		}
-
-		// Check for both converted-to-camel and non-converted data property names
-		// If a data property was specified
-		if ( getByName ) {
-
-			// First Try to find as-is property data
-			ret = thisCache[ name ];
-
-			// Test for null|undefined property data
-			if ( ret == null ) {
-
-				// Try to find the camelCased property
-				ret = thisCache[ jQuery.camelCase( name ) ];
-			}
-		} else {
-			ret = thisCache;
-		}
-
-		return ret;
-	},
-
-	removeData: function( elem, name, pvt /* Internal Use Only */ ) {
-		if ( !jQuery.acceptData( elem ) ) {
-			return;
-		}
-
-		var thisCache, i, l,
-
-			// Reference to internal data cache key
-			internalKey = jQuery.expando,
-
-			isNode = elem.nodeType,
-
-			// See jQuery.data for more information
-			cache = isNode ? jQuery.cache : elem,
-
-			// See jQuery.data for more information
-			id = isNode ? elem[ internalKey ] : internalKey;
-
-		// If there is already no cache entry for this object, there is no
-		// purpose in continuing
-		if ( !cache[ id ] ) {
-			return;
-		}
-
-		if ( name ) {
-
-			thisCache = pvt ? cache[ id ] : cache[ id ].data;
-
-			if ( thisCache ) {
-
-				// Support array or space separated string names for data keys
-				if ( !jQuery.isArray( name ) ) {
-
-					// try the string as a key before any manipulation
-					if ( name in thisCache ) {
-						name = [ name ];
-					} else {
-
-						// split the camel cased version by spaces unless a key with the spaces exists
-						name = jQuery.camelCase( name );
-						if ( name in thisCache ) {
-							name = [ name ];
-						} else {
-							name = name.split( " " );
-						}
-					}
-				}
-
-				for ( i = 0, l = name.length; i < l; i++ ) {
-					delete thisCache[ name[i] ];
-				}
-
-				// If there is no data left in the cache, we want to continue
-				// and let the cache object itself get destroyed
-				if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
-					return;
-				}
-			}
-		}
-
-		// See jQuery.data for more information
-		if ( !pvt ) {
-			delete cache[ id ].data;
-
-			// Don't destroy the parent cache unless the internal data object
-			// had been the only thing left in it
-			if ( !isEmptyDataObject(cache[ id ]) ) {
-				return;
-			}
-		}
-
-		// Browsers that fail expando deletion also refuse to delete expandos on
-		// the window, but it will allow it on all other JS objects; other browsers
-		// don't care
-		// Ensure that `cache` is not a window object #10080
-		if ( jQuery.support.deleteExpando || !cache.setInterval ) {
-			delete cache[ id ];
-		} else {
-			cache[ id ] = null;
-		}
-
-		// We destroyed the cache and need to eliminate the expando on the node to avoid
-		// false lookups in the cache for entries that no longer exist
-		if ( isNode ) {
-			// IE does not allow us to delete expando properties from nodes,
-			// nor does it have a removeAttribute function on Document nodes;
-			// we must handle all of these cases
-			if ( jQuery.support.deleteExpando ) {
-				delete elem[ internalKey ];
-			} else if ( elem.removeAttribute ) {
-				elem.removeAttribute( internalKey );
-			} else {
-				elem[ internalKey ] = null;
-			}
-		}
-	},
-
-	// For internal use only.
-	_data: function( elem, name, data ) {
-		return jQuery.data( elem, name, data, true );
-	},
-
-	// A method for determining if a DOM node can handle the data expando
-	acceptData: function( elem ) {
-		if ( elem.nodeName ) {
-			var match = jQuery.noData[ elem.nodeName.toLowerCase() ];
-
-			if ( match ) {
-				return !(match === true || elem.getAttribute("classid") !== match);
-			}
-		}
-
-		return true;
-	}
-});
 
-jQuery.fn.extend({
-	data: function( key, value ) {
-		var parts, attr, name,
-			data = null;
-
-		if ( typeof key === "undefined" ) {
-			if ( this.length ) {
-				data = jQuery.data( this[0] );
-
-				if ( this[0].nodeType === 1 && !jQuery._data( this[0], "parsedAttrs" ) ) {
-					attr = this[0].attributes;
-					for ( var i = 0, l = attr.length; i < l; i++ ) {
-						name = attr[i].name;
-
-						if ( name.indexOf( "data-" ) === 0 ) {
-							name = jQuery.camelCase( name.substring(5) );
-
-							dataAttr( this[0], name, data[ name ] );
-						}
-					}
-					jQuery._data( this[0], "parsedAttrs", true );
-				}
-			}
-
-			return data;
-
-		} else if ( typeof key === "object" ) {
-			return this.each(function() {
-				jQuery.data( this, key );
-			});
-		}
-
-		parts = key.split(".");
-		parts[1] = parts[1] ? "." + parts[1] : "";
-
-		if ( value === undefined ) {
-			data = this.triggerHandler("getData" + parts[1] + "!", [parts[0]]);
-
-			// Try to fetch any internally stored data first
-			if ( data === undefined && this.length ) {
-				data = jQuery.data( this[0], key );
-				data = dataAttr( this[0], key, data );
-			}
-
-			return data === undefined && parts[1] ?
-				this.data( parts[0] ) :
-				data;
-
-		} else {
-			return this.each(function() {
-				var self = jQuery( this ),
-					args = [ parts[0], value ];
-
-				self.triggerHandler( "setData" + parts[1] + "!", args );
-				jQuery.data( this, key, value );
-				self.triggerHandler( "changeData" + parts[1] + "!", args );
-			});
-		}
-	},
-
-	removeData: function( key ) {
-		return this.each(function() {
-			jQuery.removeData( this, key );
-		});
-	}
-});
+jQuery.support = (function() {
 
-function dataAttr( elem, key, data ) {
-	// If nothing was found internally, try to fetch any
-	// data from the HTML5 data-* attribute
-	if ( data === undefined && elem.nodeType === 1 ) {
+  var support,
+    all,
+    a,
+    select,
+    opt,
+    input,
+    marginDiv,
+    fragment,
+    tds,
+    events,
+    eventName,
+    i,
+    isSupported,
+    div = document.createElement( "div" ),
+    documentElement = document.documentElement;
+
+  // Preliminary tests
+  div.setAttribute("className", "t");
+  div.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";
+
+  all = div.getElementsByTagName( "*" );
+  a = div.getElementsByTagName( "a" )[ 0 ];
+
+  // Can't get basic test support
+  if ( !all || !all.length || !a ) {
+    return {};
+  }
+
+  // First batch of supports tests
+  select = document.createElement( "select" );
+  opt = select.appendChild( document.createElement("option") );
+  input = div.getElementsByTagName( "input" )[ 0 ];
+
+  support = {
+    // IE strips leading whitespace when .innerHTML is used
+    leadingWhitespace: ( div.firstChild.nodeType === 3 ),
+
+    // Make sure that tbody elements aren't automatically inserted
+    // IE will insert them into empty tables
+    tbody: !div.getElementsByTagName("tbody").length,
+
+    // Make sure that link elements get serialized correctly by innerHTML
+    // This requires a wrapper element in IE
+    htmlSerialize: !!div.getElementsByTagName("link").length,
+
+    // Get the style information from getAttribute
+    // (IE uses .cssText instead)
+    style: /top/.test( a.getAttribute("style") ),
+
+    // Make sure that URLs aren't manipulated
+    // (IE normalizes it by default)
+    hrefNormalized: ( a.getAttribute("href") === "/a" ),
+
+    // Make sure that element opacity exists
+    // (IE uses filter instead)
+    // Use a regex to work around a WebKit issue. See #5145
+    opacity: /^0.55/.test( a.style.opacity ),
+
+    // Verify style float existence
+    // (IE uses styleFloat instead of cssFloat)
+    cssFloat: !!a.style.cssFloat,
+
+    // Make sure that if no value is specified for a checkbox
+    // that it defaults to "on".
+    // (WebKit defaults to "" instead)
+    checkOn: ( input.value === "on" ),
+
+    // Make sure that a selected-by-default option has a working selected property.
+    // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
+    optSelected: opt.selected,
+
+    // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
+    getSetAttribute: div.className !== "t",
+
+    // Tests for enctype support on a form(#6743)
+    enctype: !!document.createElement("form").enctype,
+
+    // Makes sure cloning an html5 element does not cause problems
+    // Where outerHTML is undefined, this still works
+    html5Clone: document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>",
+
+    // Will be defined later
+    submitBubbles: true,
+    changeBubbles: true,
+    focusinBubbles: false,
+    deleteExpando: true,
+    noCloneEvent: true,
+    inlineBlockNeedsLayout: false,
+    shrinkWrapBlocks: false,
+    reliableMarginRight: true
+  };
+
+  // Make sure checked status is properly cloned
+  input.checked = true;
+  support.noCloneChecked = input.cloneNode( true ).checked;
+
+  // Make sure that the options inside disabled selects aren't marked as disabled
+  // (WebKit marks them as disabled)
+  select.disabled = true;
+  support.optDisabled = !opt.disabled;
+
+  // Test to see if it's possible to delete an expando from an element
+  // Fails in Internet Explorer
+  try {
+    delete div.test;
+  } catch( e ) {
+    support.deleteExpando = false;
+  }
+
+  if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {
+    div.attachEvent( "onclick", function() {
+      // Cloning a node shouldn't copy over any
+      // bound event handlers (IE does this)
+      support.noCloneEvent = false;
+    });
+    div.cloneNode( true ).fireEvent( "onclick" );
+  }
+
+  // Check if a radio maintains its value
+  // after being appended to the DOM
+  input = document.createElement("input");
+  input.value = "t";
+  input.setAttribute("type", "radio");
+  support.radioValue = input.value === "t";
+
+  input.setAttribute("checked", "checked");
+  div.appendChild( input );
+  fragment = document.createDocumentFragment();
+  fragment.appendChild( div.lastChild );
+
+  // WebKit doesn't clone checked state correctly in fragments
+  support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;
+
+  // Check if a disconnected checkbox will retain its checked
+  // value of true after appended to the DOM (IE6/7)
+  support.appendChecked = input.checked;
+
+  fragment.removeChild( input );
+  fragment.appendChild( div );
+
+  div.innerHTML = "";
+
+  // Check if div with explicit width and no margin-right incorrectly
+  // gets computed margin-right based on width of container. For more
+  // info see bug #3333
+  // Fails in WebKit before Feb 2011 nightlies
+  // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
+  if ( window.getComputedStyle ) {
+    marginDiv = document.createElement( "div" );
+    marginDiv.style.width = "0";
+    marginDiv.style.marginRight = "0";
+    div.style.width = "2px";
+    div.appendChild( marginDiv );
+    support.reliableMarginRight =
+      ( parseInt( ( window.getComputedStyle( marginDiv, null ) || { marginRight: 0 } ).marginRight, 10 ) || 0 ) === 0;
+  }
+
+  // Technique from Juriy Zaytsev
+  // http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
+  // We only care about the case where non-standard event systems
+  // are used, namely in IE. Short-circuiting here helps us to
+  // avoid an eval call (in setAttribute) which can cause CSP
+  // to go haywire. See: https://developer.mozilla.org/en/Security/CSP
+  if ( div.attachEvent ) {
+    for( i in {
+      submit: 1,
+      change: 1,
+      focusin: 1
+    }) {
+      eventName = "on" + i;
+      isSupported = ( eventName in div );
+      if ( !isSupported ) {
+        div.setAttribute( eventName, "return;" );
+        isSupported = ( typeof div[ eventName ] === "function" );
+      }
+      support[ i + "Bubbles" ] = isSupported;
+    }
+  }
 
-		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
+  fragment.removeChild( div );
 
-		data = elem.getAttribute( name );
+  // Null elements to avoid leaks in IE
+  fragment = select = opt = marginDiv = div = input = null;
 
-		if ( typeof data === "string" ) {
-			try {
-				data = data === "true" ? true :
-				data === "false" ? false :
-				data === "null" ? null :
-				jQuery.isNumeric( data ) ? parseFloat( data ) :
-					rbrace.test( data ) ? jQuery.parseJSON( data ) :
-					data;
-			} catch( e ) {}
+  // Run tests that need a body at doc ready
+  jQuery(function() {
+    var container, outer, inner, table, td, offsetSupport,
+      conMarginTop, ptlm, vb, style, html,
+      body = document.getElementsByTagName("body")[0];
 
-			// Make sure we set the data so it isn't changed later
-			jQuery.data( elem, key, data );
+    if ( !body ) {
+      // Return for frameset docs that don't have a body
+      return;
+    }
 
-		} else {
-			data = undefined;
-		}
-	}
+    conMarginTop = 1;
+    ptlm = "position:absolute;top:0;left:0;width:1px;height:1px;margin:0;";
+    vb = "visibility:hidden;border:0;";
+    style = "style='" + ptlm + "border:5px solid #000;padding:0;'";
+    html = "<div " + style + "><div></div></div>" +
+      "<table " + style + " cellpadding='0' cellspacing='0'>" +
+      "<tr><td></td></tr></table>";
+
+    container = document.createElement("div");
+    container.style.cssText = vb + "width:0;height:0;position:static;top:0;margin-top:" + conMarginTop + "px";
+    body.insertBefore( container, body.firstChild );
+
+    // Construct the test element
+    div = document.createElement("div");
+    container.appendChild( div );
+
+    // Check if table cells still have offsetWidth/Height when they are set
+    // to display:none and there are still other visible table cells in a
+    // table row; if so, offsetWidth/Height are not reliable for use when
+    // determining if an element has been hidden directly using
+    // display:none (it is still safe to use offsets if a parent element is
+    // hidden; don safety goggles and see bug #4512 for more information).
+    // (only IE 8 fails this test)
+    div.innerHTML = "<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>";
+    tds = div.getElementsByTagName( "td" );
+    isSupported = ( tds[ 0 ].offsetHeight === 0 );
+
+    tds[ 0 ].style.display = "";
+    tds[ 1 ].style.display = "none";
+
+    // Check if empty table cells still have offsetWidth/Height
+    // (IE <= 8 fail this test)
+    support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );
+
+    // Figure out if the W3C box model works as expected
+    div.innerHTML = "";
+    div.style.width = div.style.paddingLeft = "1px";
+    jQuery.boxModel = support.boxModel = div.offsetWidth === 2;
+
+    if ( typeof div.style.zoom !== "undefined" ) {
+      // Check if natively block-level elements act like inline-block
+      // elements when setting their display to 'inline' and giving
+      // them layout
+      // (IE < 8 does this)
+      div.style.display = "inline";
+      div.style.zoom = 1;
+      support.inlineBlockNeedsLayout = ( div.offsetWidth === 2 );
+
+      // Check if elements with layout shrink-wrap their children
+      // (IE 6 does this)
+      div.style.display = "";
+      div.innerHTML = "<div style='width:4px;'></div>";
+      support.shrinkWrapBlocks = ( div.offsetWidth !== 2 );
+    }
 
-	return data;
-}
+    div.style.cssText = ptlm + vb;
+    div.innerHTML = html;
 
-// checks a cache object for emptiness
-function isEmptyDataObject( obj ) {
-	for ( var name in obj ) {
-
-		// if the public data object is empty, the private is still empty
-		if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
-			continue;
-		}
-		if ( name !== "toJSON" ) {
-			return false;
-		}
-	}
-
-	return true;
-}
+    outer = div.firstChild;
+    inner = outer.firstChild;
+    td = outer.nextSibling.firstChild.firstChild;
 
+    offsetSupport = {
+      doesNotAddBorder: ( inner.offsetTop !== 5 ),
+      doesAddBorderForTableAndCells: ( td.offsetTop === 5 )
+    };
 
+    inner.style.position = "fixed";
+    inner.style.top = "20px";
 
+    // safari subtracts parent border width here which is 5px
+    offsetSupport.fixedPosition = ( inner.offsetTop === 20 || inner.offsetTop === 15 );
+    inner.style.position = inner.style.top = "";
 
-function handleQueueMarkDefer( elem, type, src ) {
-	var deferDataKey = type + "defer",
-		queueDataKey = type + "queue",
-		markDataKey = type + "mark",
-		defer = jQuery._data( elem, deferDataKey );
-	if ( defer &&
-		( src === "queue" || !jQuery._data(elem, queueDataKey) ) &&
-		( src === "mark" || !jQuery._data(elem, markDataKey) ) ) {
-		// Give room for hard-coded callbacks to fire first
-		// and eventually mark/queue something else on the element
-		setTimeout( function() {
-			if ( !jQuery._data( elem, queueDataKey ) &&
-				!jQuery._data( elem, markDataKey ) ) {
-				jQuery.removeData( elem, deferDataKey, true );
-				defer.fire();
-			}
-		}, 0 );
-	}
-}
+    outer.style.overflow = "hidden";
+    outer.style.position = "relative";
 
-jQuery.extend({
+    offsetSupport.subtractsBorderForOverflowNotVisible = ( inner.offsetTop === -5 );
+    offsetSupport.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== conMarginTop );
 
-	_mark: function( elem, type ) {
-		if ( elem ) {
-			type = ( type || "fx" ) + "mark";
-			jQuery._data( elem, type, (jQuery._data( elem, type ) || 0) + 1 );
-		}
-	},
-
-	_unmark: function( force, elem, type ) {
-		if ( force !== true ) {
-			type = elem;
-			elem = force;
-			force = false;
-		}
-		if ( elem ) {
-			type = type || "fx";
-			var key = type + "mark",
-				count = force ? 0 : ( (jQuery._data( elem, key ) || 1) - 1 );
-			if ( count ) {
-				jQuery._data( elem, key, count );
-			} else {
-				jQuery.removeData( elem, key, true );
-				handleQueueMarkDefer( elem, type, "mark" );
-			}
-		}
-	},
-
-	queue: function( elem, type, data ) {
-		var q;
-		if ( elem ) {
-			type = ( type || "fx" ) + "queue";
-			q = jQuery._data( elem, type );
-
-			// Speed up dequeue by getting out quickly if this is just a lookup
-			if ( data ) {
-				if ( !q || jQuery.isArray(data) ) {
-					q = jQuery._data( elem, type, jQuery.makeArray(data) );
-				} else {
-					q.push( data );
-				}
-			}
-			return q || [];
-		}
-	},
-
-	dequeue: function( elem, type ) {
-		type = type || "fx";
-
-		var queue = jQuery.queue( elem, type ),
-			fn = queue.shift(),
-			hooks = {};
-
-		// If the fx queue is dequeued, always remove the progress sentinel
-		if ( fn === "inprogress" ) {
-			fn = queue.shift();
-		}
-
-		if ( fn ) {
-			// Add a progress sentinel to prevent the fx queue from being
-			// automatically dequeued
-			if ( type === "fx" ) {
-				queue.unshift( "inprogress" );
-			}
-
-			jQuery._data( elem, type + ".run", hooks );
-			fn.call( elem, function() {
-				jQuery.dequeue( elem, type );
-			}, hooks );
-		}
-
-		if ( !queue.length ) {
-			jQuery.removeData( elem, type + "queue " + type + ".run", true );
-			handleQueueMarkDefer( elem, type, "queue" );
-		}
-	}
-});
+    body.removeChild( container );
+    div  = container = null;
 
-jQuery.fn.extend({
-	queue: function( type, data ) {
-		if ( typeof type !== "string" ) {
-			data = type;
-			type = "fx";
-		}
-
-		if ( data === undefined ) {
-			return jQuery.queue( this[0], type );
-		}
-		return this.each(function() {
-			var queue = jQuery.queue( this, type, data );
-
-			if ( type === "fx" && queue[0] !== "inprogress" ) {
-				jQuery.dequeue( this, type );
-			}
-		});
-	},
-	dequeue: function( type ) {
-		return this.each(function() {
-			jQuery.dequeue( this, type );
-		});
-	},
-	// Based off of the plugin by Clint Helfers, with permission.
-	// http://blindsignals.com/index.php/2009/07/jquery-delay/
-	delay: function( time, type ) {
-		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
-		type = type || "fx";
-
-		return this.queue( type, function( next, hooks ) {
-			var timeout = setTimeout( next, time );
-			hooks.stop = function() {
-				clearTimeout( timeout );
-			};
-		});
-	},
-	clearQueue: function( type ) {
-		return this.queue( type || "fx", [] );
-	},
-	// Get a promise resolved when queues of a certain type
-	// are emptied (fx is the type by default)
-	promise: function( type, object ) {
-		if ( typeof type !== "string" ) {
-			object = type;
-			type = undefined;
-		}
-		type = type || "fx";
-		var defer = jQuery.Deferred(),
-			elements = this,
-			i = elements.length,
-			count = 1,
-			deferDataKey = type + "defer",
-			queueDataKey = type + "queue",
-			markDataKey = type + "mark",
-			tmp;
-		function resolve() {
-			if ( !( --count ) ) {
-				defer.resolveWith( elements, [ elements ] );
-			}
-		}
-		while( i-- ) {
-			if (( tmp = jQuery.data( elements[ i ], deferDataKey, undefined, true ) ||
-					( jQuery.data( elements[ i ], queueDataKey, undefined, true ) ||
-						jQuery.data( elements[ i ], markDataKey, undefined, true ) ) &&
-					jQuery.data( elements[ i ], deferDataKey, jQuery.Callbacks( "once memory" ), true ) )) {
-				count++;
-				tmp.add( resolve );
-			}
-		}
-		resolve();
-		return defer.promise();
-	}
-});
+    jQuery.extend( support, offsetSupport );
+  });
 
+  return support;
+})();
 
 
 
-var rclass = /[\n\t\r]/g,
-	rspace = /\s+/,
-	rreturn = /\r/g,
-	rtype = /^(?:button|input)$/i,
-	rfocusable = /^(?:button|input|object|select|textarea)$/i,
-	rclickable = /^a(?:rea)?$/i,
-	rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
-	getSetAttribute = jQuery.support.getSetAttribute,
-	nodeHook, boolHook, fixSpecified;
 
-jQuery.fn.extend({
-	attr: function( name, value ) {
-		return jQuery.access( this, name, value, true, jQuery.attr );
-	},
-
-	removeAttr: function( name ) {
-		return this.each(function() {
-			jQuery.removeAttr( this, name );
-		});
-	},
-
-	prop: function( name, value ) {
-		return jQuery.access( this, name, value, true, jQuery.prop );
-	},
-
-	removeProp: function( name ) {
-		name = jQuery.propFix[ name ] || name;
-		return this.each(function() {
-			// try/catch handles cases where IE balks (such as removing a property on window)
-			try {
-				this[ name ] = undefined;
-				delete this[ name ];
-			} catch( e ) {}
-		});
-	},
-
-	addClass: function( value ) {
-		var classNames, i, l, elem,
-			setClass, c, cl;
-
-		if ( jQuery.isFunction( value ) ) {
-			return this.each(function( j ) {
-				jQuery( this ).addClass( value.call(this, j, this.className) );
-			});
-		}
-
-		if ( value && typeof value === "string" ) {
-			classNames = value.split( rspace );
-
-			for ( i = 0, l = this.length; i < l; i++ ) {
-				elem = this[ i ];
-
-				if ( elem.nodeType === 1 ) {
-					if ( !elem.className && classNames.length === 1 ) {
-						elem.className = value;
-
-					} else {
-						setClass = " " + elem.className + " ";
-
-						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
-							if ( !~setClass.indexOf( " " + classNames[ c ] + " " ) ) {
-								setClass += classNames[ c ] + " ";
-							}
-						}
-						elem.className = jQuery.trim( setClass );
-					}
-				}
-			}
-		}
-
-		return this;
-	},
-
-	removeClass: function( value ) {
-		var classNames, i, l, elem, className, c, cl;
-
-		if ( jQuery.isFunction( value ) ) {
-			return this.each(function( j ) {
-				jQuery( this ).removeClass( value.call(this, j, this.className) );
-			});
-		}
-
-		if ( (value && typeof value === "string") || value === undefined ) {
-			classNames = ( value || "" ).split( rspace );
-
-			for ( i = 0, l = this.length; i < l; i++ ) {
-				elem = this[ i ];
-
-				if ( elem.nodeType === 1 && elem.className ) {
-					if ( value ) {
-						className = (" " + elem.className + " ").replace( rclass, " " );
-						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
-							className = className.replace(" " + classNames[ c ] + " ", " ");
-						}
-						elem.className = jQuery.trim( className );
-
-					} else {
-						elem.className = "";
-					}
-				}
-			}
-		}
-
-		return this;
-	},
-
-	toggleClass: function( value, stateVal ) {
-		var type = typeof value,
-			isBool = typeof stateVal === "boolean";
-
-		if ( jQuery.isFunction( value ) ) {
-			return this.each(function( i ) {
-				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
-			});
-		}
-
-		return this.each(function() {
-			if ( type === "string" ) {
-				// toggle individual class names
-				var className,
-					i = 0,
-					self = jQuery( this ),
-					state = stateVal,
-					classNames = value.split( rspace );
-
-				while ( (className = classNames[ i++ ]) ) {
-					// check each className given, space seperated list
-					state = isBool ? state : !self.hasClass( className );
-					self[ state ? "addClass" : "removeClass" ]( className );
-				}
-
-			} else if ( type === "undefined" || type === "boolean" ) {
-				if ( this.className ) {
-					// store className if set
-					jQuery._data( this, "__className__", this.className );
-				}
-
-				// toggle whole className
-				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
-			}
-		});
-	},
-
-	hasClass: function( selector ) {
-		var className = " " + selector + " ",
-			i = 0,
-			l = this.length;
-		for ( ; i < l; i++ ) {
-			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) > -1 ) {
-				return true;
-			}
-		}
-
-		return false;
-	},
-
-	val: function( value ) {
-		var hooks, ret, isFunction,
-			elem = this[0];
-
-		if ( !arguments.length ) {
-			if ( elem ) {
-				hooks = jQuery.valHooks[ elem.nodeName.toLowerCase() ] || jQuery.valHooks[ elem.type ];
-
-				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
-					return ret;
-				}
-
-				ret = elem.value;
-
-				return typeof ret === "string" ?
-					// handle most common string cases
-					ret.replace(rreturn, "") :
-					// handle cases where value is null/undef or number
-					ret == null ? "" : ret;
-			}
-
-			return;
-		}
-
-		isFunction = jQuery.isFunction( value );
-
-		return this.each(function( i ) {
-			var self = jQuery(this), val;
-
-			if ( this.nodeType !== 1 ) {
-				return;
-			}
-
-			if ( isFunction ) {
-				val = value.call( this, i, self.val() );
-			} else {
-				val = value;
-			}
-
-			// Treat null/undefined as ""; convert numbers to string
-			if ( val == null ) {
-				val = "";
-			} else if ( typeof val === "number" ) {
-				val += "";
-			} else if ( jQuery.isArray( val ) ) {
-				val = jQuery.map(val, function ( value ) {
-					return value == null ? "" : value + "";
-				});
-			}
-
-			hooks = jQuery.valHooks[ this.nodeName.toLowerCase() ] || jQuery.valHooks[ this.type ];
-
-			// If set returns undefined, fall back to normal setting
-			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
-				this.value = val;
-			}
-		});
-	}
-});
+var rbrace = /^(?:\{.*\}|\[.*\])$/,
+  rmultiDash = /([A-Z])/g;
 
 jQuery.extend({
-	valHooks: {
-		option: {
-			get: function( elem ) {
-				// attributes.value is undefined in Blackberry 4.7 but
-				// uses .value. See #6932
-				var val = elem.attributes.value;
-				return !val || val.specified ? elem.value : elem.text;
-			}
-		},
-		select: {
-			get: function( elem ) {
-				var value, i, max, option,
-					index = elem.selectedIndex,
-					values = [],
-					options = elem.options,
-					one = elem.type === "select-one";
-
-				// Nothing was selected
-				if ( index < 0 ) {
-					return null;
-				}
-
-				// Loop through all the selected options
-				i = one ? index : 0;
-				max = one ? index + 1 : options.length;
-				for ( ; i < max; i++ ) {
-					option = options[ i ];
-
-					// Don't return options that are disabled or in a disabled optgroup
-					if ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
-							(!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" )) ) {
-
-						// Get the specific value for the option
-						value = jQuery( option ).val();
-
-						// We don't need an array for one selects
-						if ( one ) {
-							return value;
-						}
-
-						// Multi-Selects return an array
-						values.push( value );
-					}
-				}
-
-				// Fixes Bug #2551 -- select.val() broken in IE after form.reset()
-				if ( one && !values.length && options.length ) {
-					return jQuery( options[ index ] ).val();
-				}
-
-				return values;
-			},
-
-			set: function( elem, value ) {
-				var values = jQuery.makeArray( value );
-
-				jQuery(elem).find("option").each(function() {
-					this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
-				});
-
-				if ( !values.length ) {
-					elem.selectedIndex = -1;
-				}
-				return values;
-			}
-		}
-	},
-
-	attrFn: {
-		val: true,
-		css: true,
-		html: true,
-		text: true,
-		data: true,
-		width: true,
-		height: true,
-		offset: true
-	},
-
-	attr: function( elem, name, value, pass ) {
-		var ret, hooks, notxml,
-			nType = elem.nodeType;
-
-		// don't get/set attributes on text, comment and attribute nodes
-		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
-			return;
-		}
-
-		if ( pass && name in jQuery.attrFn ) {
-			return jQuery( elem )[ name ]( value );
-		}
-
-		// Fallback to prop when attributes are not supported
-		if ( typeof elem.getAttribute === "undefined" ) {
-			return jQuery.prop( elem, name, value );
-		}
-
-		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );
-
-		// All attributes are lowercase
-		// Grab necessary hook if one is defined
-		if ( notxml ) {
-			name = name.toLowerCase();
-			hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
-		}
-
-		if ( value !== undefined ) {
-
-			if ( value === null ) {
-				jQuery.removeAttr( elem, name );
-				return;
-
-			} else if ( hooks && "set" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {
-				return ret;
-
-			} else {
-				elem.setAttribute( name, "" + value );
-				return value;
-			}
-
-		} else if ( hooks && "get" in hooks && notxml && (ret = hooks.get( elem, name )) !== null ) {
-			return ret;
-
-		} else {
-
-			ret = elem.getAttribute( name );
-
-			// Non-existent attributes return null, we normalize to undefined
-			return ret === null ?
-				undefined :
-				ret;
-		}
-	},
-
-	removeAttr: function( elem, value ) {
-		var propName, attrNames, name, l,
-			i = 0;
-
-		if ( value && elem.nodeType === 1 ) {
-			attrNames = value.toLowerCase().split( rspace );
-			l = attrNames.length;
-
-			for ( ; i < l; i++ ) {
-				name = attrNames[ i ];
-
-				if ( name ) {
-					propName = jQuery.propFix[ name ] || name;
-
-					// See #9699 for explanation of this approach (setting first, then removal)
-					jQuery.attr( elem, name, "" );
-					elem.removeAttribute( getSetAttribute ? name : propName );
-
-					// Set corresponding property to false for boolean attributes
-					if ( rboolean.test( name ) && propName in elem ) {
-						elem[ propName ] = false;
-					}
-				}
-			}
-		}
-	},
-
-	attrHooks: {
-		type: {
-			set: function( elem, value ) {
-				// We can't allow the type property to be changed (since it causes problems in IE)
-				if ( rtype.test( elem.nodeName ) && elem.parentNode ) {
-					jQuery.error( "type property can't be changed" );
-				} else if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
-					// Setting the type on a radio button after the value resets the value in IE6-9
-					// Reset value to its default in case type is set after value
-					// This is for element creation
-					var val = elem.value;
-					elem.setAttribute( "type", value );
-					if ( val ) {
-						elem.value = val;
-					}
-					return value;
-				}
-			}
-		},
-		// Use the value property for back compat
-		// Use the nodeHook for button elements in IE6/7 (#1954)
-		value: {
-			get: function( elem, name ) {
-				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
-					return nodeHook.get( elem, name );
-				}
-				return name in elem ?
-					elem.value :
-					null;
-			},
-			set: function( elem, value, name ) {
-				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
-					return nodeHook.set( elem, value, name );
-				}
-				// Does not return so that setAttribute is also used
-				elem.value = value;
-			}
-		}
-	},
-
-	propFix: {
-		tabindex: "tabIndex",
-		readonly: "readOnly",
-		"for": "htmlFor",
-		"class": "className",
-		maxlength: "maxLength",
-		cellspacing: "cellSpacing",
-		cellpadding: "cellPadding",
-		rowspan: "rowSpan",
-		colspan: "colSpan",
-		usemap: "useMap",
-		frameborder: "frameBorder",
-		contenteditable: "contentEditable"
-	},
-
-	prop: function( elem, name, value ) {
-		var ret, hooks, notxml,
-			nType = elem.nodeType;
-
-		// don't get/set properties on text, comment and attribute nodes
-		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
-			return;
-		}
-
-		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );
-
-		if ( notxml ) {
-			// Fix name and attach hooks
-			name = jQuery.propFix[ name ] || name;
-			hooks = jQuery.propHooks[ name ];
-		}
-
-		if ( value !== undefined ) {
-			if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
-				return ret;
-
-			} else {
-				return ( elem[ name ] = value );
-			}
-
-		} else {
-			if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
-				return ret;
-
-			} else {
-				return elem[ name ];
-			}
-		}
-	},
-
-	propHooks: {
-		tabIndex: {
-			get: function( elem ) {
-				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
-				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
-				var attributeNode = elem.getAttributeNode("tabindex");
-
-				return attributeNode && attributeNode.specified ?
-					parseInt( attributeNode.value, 10 ) :
-					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
-						0 :
-						undefined;
-			}
-		}
-	}
-});
+  cache: {},
+
+  // Please use with caution
+  uuid: 0,
+
+  // Unique for each copy of jQuery on the page
+  // Non-digits removed to match rinlinejQuery
+  expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),
+
+  // The following elements throw uncatchable exceptions if you
+  // attempt to add expando properties to them.
+  noData: {
+    "embed": true,
+    // Ban all objects except for Flash (which handle expandos)
+    "object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
+    "applet": true
+  },
+
+  hasData: function( elem ) {
+    elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
+    return !!elem && !isEmptyDataObject( elem );
+  },
+
+  data: function( elem, name, data, pvt /* Internal Use Only */ ) {
+    if ( !jQuery.acceptData( elem ) ) {
+      return;
+    }
 
-// Add the tabIndex propHook to attrHooks for back-compat (different case is intentional)
-jQuery.attrHooks.tabindex = jQuery.propHooks.tabIndex;
+    var privateCache, thisCache, ret,
+      internalKey = jQuery.expando,
+      getByName = typeof name === "string",
 
-// Hook for boolean attributes
-boolHook = {
-	get: function( elem, name ) {
-		// Align boolean attributes with corresponding properties
-		// Fall back to attribute presence where some booleans are not supported
-		var attrNode,
-			property = jQuery.prop( elem, name );
-		return property === true || typeof property !== "boolean" && ( attrNode = elem.getAttributeNode(name) ) && attrNode.nodeValue !== false ?
-			name.toLowerCase() :
-			undefined;
-	},
-	set: function( elem, value, name ) {
-		var propName;
-		if ( value === false ) {
-			// Remove boolean attributes when set to false
-			jQuery.removeAttr( elem, name );
-		} else {
-			// value is true since we know at this point it's type boolean and not false
-			// Set boolean attributes to the same name and set the DOM property
-			propName = jQuery.propFix[ name ] || name;
-			if ( propName in elem ) {
-				// Only set the IDL specifically if it already exists on the element
-				elem[ propName ] = true;
-			}
-
-			elem.setAttribute( name, name.toLowerCase() );
-		}
-		return name;
-	}
-};
+      // We have to handle DOM nodes and JS objects differently because IE6-7
+      // can't GC object references properly across the DOM-JS boundary
+      isNode = elem.nodeType,
 
-// IE6/7 do not support getting/setting some attributes with get/setAttribute
-if ( !getSetAttribute ) {
+      // Only DOM nodes need the global jQuery cache; JS object data is
+      // attached directly to the object so GC can occur automatically
+      cache = isNode ? jQuery.cache : elem,
 
-	fixSpecified = {
-		name: true,
-		id: true
-	};
-
-	// Use this for any attribute in IE6/7
-	// This fixes almost every IE6/7 issue
-	nodeHook = jQuery.valHooks.button = {
-		get: function( elem, name ) {
-			var ret;
-			ret = elem.getAttributeNode( name );
-			return ret && ( fixSpecified[ name ] ? ret.nodeValue !== "" : ret.specified ) ?
-				ret.nodeValue :
-				undefined;
-		},
-		set: function( elem, value, name ) {
-			// Set the existing or create a new attribute node
-			var ret = elem.getAttributeNode( name );
-			if ( !ret ) {
-				ret = document.createAttribute( name );
-				elem.setAttributeNode( ret );
-			}
-			return ( ret.nodeValue = value + "" );
-		}
-	};
-
-	// Apply the nodeHook to tabindex
-	jQuery.attrHooks.tabindex.set = nodeHook.set;
-
-	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
-	// This is for removals
-	jQuery.each([ "width", "height" ], function( i, name ) {
-		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
-			set: function( elem, value ) {
-				if ( value === "" ) {
-					elem.setAttribute( name, "auto" );
-					return value;
-				}
-			}
-		});
-	});
-
-	// Set contenteditable to false on removals(#10429)
-	// Setting to empty string throws an error as an invalid value
-	jQuery.attrHooks.contenteditable = {
-		get: nodeHook.get,
-		set: function( elem, value, name ) {
-			if ( value === "" ) {
-				value = "false";
-			}
-			nodeHook.set( elem, value, name );
-		}
-	};
-}
+      // Only defining an ID for JS objects if its cache already exists allows
+      // the code to shortcut on the same path as a DOM node with no cache
+      id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey,
+      isEvents = name === "events";
 
+    // Avoid doing any more work than we need to when trying to get data on an
+    // object that has no data at all
+    if ( (!id || !cache[id] || (!isEvents && !pvt && !cache[id].data)) && getByName && data === undefined ) {
+      return;
+    }
 
-// Some attributes require a special call on IE
-if ( !jQuery.support.hrefNormalized ) {
-	jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
-		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
-			get: function( elem ) {
-				var ret = elem.getAttribute( name, 2 );
-				return ret === null ? undefined : ret;
-			}
-		});
-	});
-}
+    if ( !id ) {
+      // Only DOM nodes need a new unique ID for each element since their data
+      // ends up in the global cache
+      if ( isNode ) {
+        elem[ internalKey ] = id = ++jQuery.uuid;
+      } else {
+        id = internalKey;
+      }
+    }
 
-if ( !jQuery.support.style ) {
-	jQuery.attrHooks.style = {
-		get: function( elem ) {
-			// Return undefined in the case of empty string
-			// Normalize to lowercase since IE uppercases css property names
-			return elem.style.cssText.toLowerCase() || undefined;
-		},
-		set: function( elem, value ) {
-			return ( elem.style.cssText = "" + value );
-		}
-	};
-}
+    if ( !cache[ id ] ) {
+      cache[ id ] = {};
 
-// Safari mis-reports the default selected property of an option
-// Accessing the parent's selectedIndex property fixes it
-if ( !jQuery.support.optSelected ) {
-	jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
-		get: function( elem ) {
-			var parent = elem.parentNode;
-
-			if ( parent ) {
-				parent.selectedIndex;
-
-				// Make sure that it also works with optgroups, see #5701
-				if ( parent.parentNode ) {
-					parent.parentNode.selectedIndex;
-				}
-			}
-			return null;
-		}
-	});
-}
+      // Avoids exposing jQuery metadata on plain JS objects when the object
+      // is serialized using JSON.stringify
+      if ( !isNode ) {
+        cache[ id ].toJSON = jQuery.noop;
+      }
+    }
 
-// IE6/7 call enctype encoding
-if ( !jQuery.support.enctype ) {
-	jQuery.propFix.enctype = "encoding";
-}
+    // An object can be passed to jQuery.data instead of a key/value pair; this gets
+    // shallow copied over onto the existing cache
+    if ( typeof name === "object" || typeof name === "function" ) {
+      if ( pvt ) {
+        cache[ id ] = jQuery.extend( cache[ id ], name );
+      } else {
+        cache[ id ].data = jQuery.extend( cache[ id ].data, name );
+      }
+    }
 
-// Radios and checkboxes getter/setter
-if ( !jQuery.support.checkOn ) {
-	jQuery.each([ "radio", "checkbox" ], function() {
-		jQuery.valHooks[ this ] = {
-			get: function( elem ) {
-				// Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
-				return elem.getAttribute("value") === null ? "on" : elem.value;
-			}
-		};
-	});
-}
-jQuery.each([ "radio", "checkbox" ], function() {
-	jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
-		set: function( elem, value ) {
-			if ( jQuery.isArray( value ) ) {
-				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
-			}
-		}
-	});
-});
+    privateCache = thisCache = cache[ id ];
 
+    // jQuery data() is stored in a separate object inside the object's internal data
+    // cache in order to avoid key collisions between internal data and user-defined
+    // data.
+    if ( !pvt ) {
+      if ( !thisCache.data ) {
+        thisCache.data = {};
+      }
 
+      thisCache = thisCache.data;
+    }
 
+    if ( data !== undefined ) {
+      thisCache[ jQuery.camelCase( name ) ] = data;
+    }
 
-var rformElems = /^(?:textarea|input|select)$/i,
-	rtypenamespace = /^([^\.]*)?(?:\.(.+))?$/,
-	rhoverHack = /\bhover(\.\S+)?\b/,
-	rkeyEvent = /^key/,
-	rmouseEvent = /^(?:mouse|contextmenu)|click/,
-	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
-	rquickIs = /^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,
-	quickParse = function( selector ) {
-		var quick = rquickIs.exec( selector );
-		if ( quick ) {
-			//   0  1    2   3
-			// [ _, tag, id, class ]
-			quick[1] = ( quick[1] || "" ).toLowerCase();
-			quick[3] = quick[3] && new RegExp( "(?:^|\\s)" + quick[3] + "(?:\\s|$)" );
-		}
-		return quick;
-	},
-	quickIs = function( elem, m ) {
-		var attrs = elem.attributes || {};
-		return (
-			(!m[1] || elem.nodeName.toLowerCase() === m[1]) &&
-			(!m[2] || (attrs.id || {}).value === m[2]) &&
-			(!m[3] || m[3].test( (attrs[ "class" ] || {}).value ))
-		);
-	},
-	hoverHack = function( events ) {
-		return jQuery.event.special.hover ? events : events.replace( rhoverHack, "mouseenter$1 mouseleave$1" );
-	};
+    // Users should not attempt to inspect the internal events object using jQuery.data,
+    // it is undocumented and subject to change. But does anyone listen? No.
+    if ( isEvents && !thisCache[ name ] ) {
+      return privateCache.events;
+    }
 
-/*
+    // Check for both converted-to-camel and non-converted data property names
+    // If a data property was specified
+    if ( getByName ) {
+
+      // First Try to find as-is property data
+      ret = thisCache[ name ];
+
+      // Test for null|undefined property data
+      if ( ret == null ) {
+
+        // Try to find the camelCased property
+        ret = thisCache[ jQuery.camelCase( name ) ];
+      }
+    } else {
+      ret = thisCache;
+    }
+
+    return ret;
+  },
+
+  removeData: function( elem, name, pvt /* Internal Use Only */ ) {
+    if ( !jQuery.acceptData( elem ) ) {
+      return;
+    }
+
+    var thisCache, i, l,
+
+      // Reference to internal data cache key
+      internalKey = jQuery.expando,
+
+      isNode = elem.nodeType,
+
+      // See jQuery.data for more information
+      cache = isNode ? jQuery.cache : elem,
+
+      // See jQuery.data for more information
+      id = isNode ? elem[ internalKey ] : internalKey;
+
+    // If there is already no cache entry for this object, there is no
+    // purpose in continuing
+    if ( !cache[ id ] ) {
+      return;
+    }
+
+    if ( name ) {
+
+      thisCache = pvt ? cache[ id ] : cache[ id ].data;
+
+      if ( thisCache ) {
+
+        // Support array or space separated string names for data keys
+        if ( !jQuery.isArray( name ) ) {
+
+          // try the string as a key before any manipulation
+          if ( name in thisCache ) {
+            name = [ name ];
+          } else {
+
+            // split the camel cased version by spaces unless a key with the spaces exists
+            name = jQuery.camelCase( name );
+            if ( name in thisCache ) {
+              name = [ name ];
+            } else {
+              name = name.split( " " );
+            }
+          }
+        }
+
+        for ( i = 0, l = name.length; i < l; i++ ) {
+          delete thisCache[ name[i] ];
+        }
+
+        // If there is no data left in the cache, we want to continue
+        // and let the cache object itself get destroyed
+        if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
+          return;
+        }
+      }
+    }
+
+    // See jQuery.data for more information
+    if ( !pvt ) {
+      delete cache[ id ].data;
+
+      // Don't destroy the parent cache unless the internal data object
+      // had been the only thing left in it
+      if ( !isEmptyDataObject(cache[ id ]) ) {
+        return;
+      }
+    }
+
+    // Browsers that fail expando deletion also refuse to delete expandos on
+    // the window, but it will allow it on all other JS objects; other browsers
+    // don't care
+    // Ensure that `cache` is not a window object #10080
+    if ( jQuery.support.deleteExpando || !cache.setInterval ) {
+      delete cache[ id ];
+    } else {
+      cache[ id ] = null;
+    }
+
+    // We destroyed the cache and need to eliminate the expando on the node to avoid
+    // false lookups in the cache for entries that no longer exist
+    if ( isNode ) {
+      // IE does not allow us to delete expando properties from nodes,
+      // nor does it have a removeAttribute function on Document nodes;
+      // we must handle all of these cases
+      if ( jQuery.support.deleteExpando ) {
+        delete elem[ internalKey ];
+      } else if ( elem.removeAttribute ) {
+        elem.removeAttribute( internalKey );
+      } else {
+        elem[ internalKey ] = null;
+      }
+    }
+  },
+
+  // For internal use only.
+  _data: function( elem, name, data ) {
+    return jQuery.data( elem, name, data, true );
+  },
+
+  // A method for determining if a DOM node can handle the data expando
+  acceptData: function( elem ) {
+    if ( elem.nodeName ) {
+      var match = jQuery.noData[ elem.nodeName.toLowerCase() ];
+
+      if ( match ) {
+        return !(match === true || elem.getAttribute("classid") !== match);
+      }
+    }
+
+    return true;
+  }
+});
+
+jQuery.fn.extend({
+  data: function( key, value ) {
+    var parts, attr, name,
+      data = null;
+
+    if ( typeof key === "undefined" ) {
+      if ( this.length ) {
+        data = jQuery.data( this[0] );
+
+        if ( this[0].nodeType === 1 && !jQuery._data( this[0], "parsedAttrs" ) ) {
+          attr = this[0].attributes;
+          for ( var i = 0, l = attr.length; i < l; i++ ) {
+            name = attr[i].name;
+
+            if ( name.indexOf( "data-" ) === 0 ) {
+              name = jQuery.camelCase( name.substring(5) );
+
+              dataAttr( this[0], name, data[ name ] );
+            }
+          }
+          jQuery._data( this[0], "parsedAttrs", true );
+        }
+      }
+
+      return data;
+
+    } else if ( typeof key === "object" ) {
+      return this.each(function() {
+        jQuery.data( this, key );
+      });
+    }
+
+    parts = key.split(".");
+    parts[1] = parts[1] ? "." + parts[1] : "";
+
+    if ( value === undefined ) {
+      data = this.triggerHandler("getData" + parts[1] + "!", [parts[0]]);
+
+      // Try to fetch any internally stored data first
+      if ( data === undefined && this.length ) {
+        data = jQuery.data( this[0], key );
+        data = dataAttr( this[0], key, data );
+      }
+
+      return data === undefined && parts[1] ?
+        this.data( parts[0] ) :
+        data;
+
+    } else {
+      return this.each(function() {
+        var self = jQuery( this ),
+          args = [ parts[0], value ];
+
+        self.triggerHandler( "setData" + parts[1] + "!", args );
+        jQuery.data( this, key, value );
+        self.triggerHandler( "changeData" + parts[1] + "!", args );
+      });
+    }
+  },
+
+  removeData: function( key ) {
+    return this.each(function() {
+      jQuery.removeData( this, key );
+    });
+  }
+});
+
+function dataAttr( elem, key, data ) {
+  // If nothing was found internally, try to fetch any
+  // data from the HTML5 data-* attribute
+  if ( data === undefined && elem.nodeType === 1 ) {
+
+    var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
+
+    data = elem.getAttribute( name );
+
+    if ( typeof data === "string" ) {
+      try {
+        data = data === "true" ? true :
+        data === "false" ? false :
+        data === "null" ? null :
+        jQuery.isNumeric( data ) ? parseFloat( data ) :
+          rbrace.test( data ) ? jQuery.parseJSON( data ) :
+          data;
+      } catch( e ) {}
+
+      // Make sure we set the data so it isn't changed later
+      jQuery.data( elem, key, data );
+
+    } else {
+      data = undefined;
+    }
+  }
+
+  return data;
+}
+
+// checks a cache object for emptiness
+function isEmptyDataObject( obj ) {
+  for ( var name in obj ) {
+
+    // if the public data object is empty, the private is still empty
+    if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
+      continue;
+    }
+    if ( name !== "toJSON" ) {
+      return false;
+    }
+  }
+
+  return true;
+}
+
+
+
+
+function handleQueueMarkDefer( elem, type, src ) {
+  var deferDataKey = type + "defer",
+    queueDataKey = type + "queue",
+    markDataKey = type + "mark",
+    defer = jQuery._data( elem, deferDataKey );
+  if ( defer &&
+    ( src === "queue" || !jQuery._data(elem, queueDataKey) ) &&
+    ( src === "mark" || !jQuery._data(elem, markDataKey) ) ) {
+    // Give room for hard-coded callbacks to fire first
+    // and eventually mark/queue something else on the element
+    setTimeout( function() {
+      if ( !jQuery._data( elem, queueDataKey ) &&
+        !jQuery._data( elem, markDataKey ) ) {
+        jQuery.removeData( elem, deferDataKey, true );
+        defer.fire();
+      }
+    }, 0 );
+  }
+}
+
+jQuery.extend({
+
+  _mark: function( elem, type ) {
+    if ( elem ) {
+      type = ( type || "fx" ) + "mark";
+      jQuery._data( elem, type, (jQuery._data( elem, type ) || 0) + 1 );
+    }
+  },
+
+  _unmark: function( force, elem, type ) {
+    if ( force !== true ) {
+      type = elem;
+      elem = force;
+      force = false;
+    }
+    if ( elem ) {
+      type = type || "fx";
+      var key = type + "mark",
+        count = force ? 0 : ( (jQuery._data( elem, key ) || 1) - 1 );
+      if ( count ) {
+        jQuery._data( elem, key, count );
+      } else {
+        jQuery.removeData( elem, key, true );
+        handleQueueMarkDefer( elem, type, "mark" );
+      }
+    }
+  },
+
+  queue: function( elem, type, data ) {
+    var q;
+    if ( elem ) {
+      type = ( type || "fx" ) + "queue";
+      q = jQuery._data( elem, type );
+
+      // Speed up dequeue by getting out quickly if this is just a lookup
+      if ( data ) {
+        if ( !q || jQuery.isArray(data) ) {
+          q = jQuery._data( elem, type, jQuery.makeArray(data) );
+        } else {
+          q.push( data );
+        }
+      }
+      return q || [];
+    }
+  },
+
+  dequeue: function( elem, type ) {
+    type = type || "fx";
+
+    var queue = jQuery.queue( elem, type ),
+      fn = queue.shift(),
+      hooks = {};
+
+    // If the fx queue is dequeued, always remove the progress sentinel
+    if ( fn === "inprogress" ) {
+      fn = queue.shift();
+    }
+
+    if ( fn ) {
+      // Add a progress sentinel to prevent the fx queue from being
+      // automatically dequeued
+      if ( type === "fx" ) {
+        queue.unshift( "inprogress" );
+      }
+
+      jQuery._data( elem, type + ".run", hooks );
+      fn.call( elem, function() {
+        jQuery.dequeue( elem, type );
+      }, hooks );
+    }
+
+    if ( !queue.length ) {
+      jQuery.removeData( elem, type + "queue " + type + ".run", true );
+      handleQueueMarkDefer( elem, type, "queue" );
+    }
+  }
+});
+
+jQuery.fn.extend({
+  queue: function( type, data ) {
+    if ( typeof type !== "string" ) {
+      data = type;
+      type = "fx";
+    }
+
+    if ( data === undefined ) {
+      return jQuery.queue( this[0], type );
+    }
+    return this.each(function() {
+      var queue = jQuery.queue( this, type, data );
+
+      if ( type === "fx" && queue[0] !== "inprogress" ) {
+        jQuery.dequeue( this, type );
+      }
+    });
+  },
+  dequeue: function( type ) {
+    return this.each(function() {
+      jQuery.dequeue( this, type );
+    });
+  },
+  // Based off of the plugin by Clint Helfers, with permission.
+  // http://blindsignals.com/index.php/2009/07/jquery-delay/
+  delay: function( time, type ) {
+    time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
+    type = type || "fx";
+
+    return this.queue( type, function( next, hooks ) {
+      var timeout = setTimeout( next, time );
+      hooks.stop = function() {
+        clearTimeout( timeout );
+      };
+    });
+  },
+  clearQueue: function( type ) {
+    return this.queue( type || "fx", [] );
+  },
+  // Get a promise resolved when queues of a certain type
+  // are emptied (fx is the type by default)
+  promise: function( type, object ) {
+    if ( typeof type !== "string" ) {
+      object = type;
+      type = undefined;
+    }
+    type = type || "fx";
+    var defer = jQuery.Deferred(),
+      elements = this,
+      i = elements.length,
+      count = 1,
+      deferDataKey = type + "defer",
+      queueDataKey = type + "queue",
+      markDataKey = type + "mark",
+      tmp;
+    function resolve() {
+      if ( !( --count ) ) {
+        defer.resolveWith( elements, [ elements ] );
+      }
+    }
+    while( i-- ) {
+      if (( tmp = jQuery.data( elements[ i ], deferDataKey, undefined, true ) ||
+          ( jQuery.data( elements[ i ], queueDataKey, undefined, true ) ||
+            jQuery.data( elements[ i ], markDataKey, undefined, true ) ) &&
+          jQuery.data( elements[ i ], deferDataKey, jQuery.Callbacks( "once memory" ), true ) )) {
+        count++;
+        tmp.add( resolve );
+      }
+    }
+    resolve();
+    return defer.promise();
+  }
+});
+
+
+
+
+var rclass = /[\n\t\r]/g,
+  rspace = /\s+/,
+  rreturn = /\r/g,
+  rtype = /^(?:button|input)$/i,
+  rfocusable = /^(?:button|input|object|select|textarea)$/i,
+  rclickable = /^a(?:rea)?$/i,
+  rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
+  getSetAttribute = jQuery.support.getSetAttribute,
+  nodeHook, boolHook, fixSpecified;
+
+jQuery.fn.extend({
+  attr: function( name, value ) {
+    return jQuery.access( this, name, value, true, jQuery.attr );
+  },
+
+  removeAttr: function( name ) {
+    return this.each(function() {
+      jQuery.removeAttr( this, name );
+    });
+  },
+
+  prop: function( name, value ) {
+    return jQuery.access( this, name, value, true, jQuery.prop );
+  },
+
+  removeProp: function( name ) {
+    name = jQuery.propFix[ name ] || name;
+    return this.each(function() {
+      // try/catch handles cases where IE balks (such as removing a property on window)
+      try {
+        this[ name ] = undefined;
+        delete this[ name ];
+      } catch( e ) {}
+    });
+  },
+
+  addClass: function( value ) {
+    var classNames, i, l, elem,
+      setClass, c, cl;
+
+    if ( jQuery.isFunction( value ) ) {
+      return this.each(function( j ) {
+        jQuery( this ).addClass( value.call(this, j, this.className) );
+      });
+    }
+
+    if ( value && typeof value === "string" ) {
+      classNames = value.split( rspace );
+
+      for ( i = 0, l = this.length; i < l; i++ ) {
+        elem = this[ i ];
+
+        if ( elem.nodeType === 1 ) {
+          if ( !elem.className && classNames.length === 1 ) {
+            elem.className = value;
+
+          } else {
+            setClass = " " + elem.className + " ";
+
+            for ( c = 0, cl = classNames.length; c < cl; c++ ) {
+              if ( !~setClass.indexOf( " " + classNames[ c ] + " " ) ) {
+                setClass += classNames[ c ] + " ";
+              }
+            }
+            elem.className = jQuery.trim( setClass );
+          }
+        }
+      }
+    }
+
+    return this;
+  },
+
+  removeClass: function( value ) {
+    var classNames, i, l, elem, className, c, cl;
+
+    if ( jQuery.isFunction( value ) ) {
+      return this.each(function( j ) {
+        jQuery( this ).removeClass( value.call(this, j, this.className) );
+      });
+    }
+
+    if ( (value && typeof value === "string") || value === undefined ) {
+      classNames = ( value || "" ).split( rspace );
+
+      for ( i = 0, l = this.length; i < l; i++ ) {
+        elem = this[ i ];
+
+        if ( elem.nodeType === 1 && elem.className ) {
+          if ( value ) {
+            className = (" " + elem.className + " ").replace( rclass, " " );
+            for ( c = 0, cl = classNames.length; c < cl; c++ ) {
+              className = className.replace(" " + classNames[ c ] + " ", " ");
+            }
+            elem.className = jQuery.trim( className );
+
+          } else {
+            elem.className = "";
+          }
+        }
+      }
+    }
+
+    return this;
+  },
+
+  toggleClass: function( value, stateVal ) {
+    var type = typeof value,
+      isBool = typeof stateVal === "boolean";
+
+    if ( jQuery.isFunction( value ) ) {
+      return this.each(function( i ) {
+        jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
+      });
+    }
+
+    return this.each(function() {
+      if ( type === "string" ) {
+        // toggle individual class names
+        var className,
+          i = 0,
+          self = jQuery( this ),
+          state = stateVal,
+          classNames = value.split( rspace );
+
+        while ( (className = classNames[ i++ ]) ) {
+          // check each className given, space seperated list
+          state = isBool ? state : !self.hasClass( className );
+          self[ state ? "addClass" : "removeClass" ]( className );
+        }
+
+      } else if ( type === "undefined" || type === "boolean" ) {
+        if ( this.className ) {
+          // store className if set
+          jQuery._data( this, "__className__", this.className );
+        }
+
+        // toggle whole className
+        this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
+      }
+    });
+  },
+
+  hasClass: function( selector ) {
+    var className = " " + selector + " ",
+      i = 0,
+      l = this.length;
+    for ( ; i < l; i++ ) {
+      if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) > -1 ) {
+        return true;
+      }
+    }
+
+    return false;
+  },
+
+  val: function( value ) {
+    var hooks, ret, isFunction,
+      elem = this[0];
+
+    if ( !arguments.length ) {
+      if ( elem ) {
+        hooks = jQuery.valHooks[ elem.nodeName.toLowerCase() ] || jQuery.valHooks[ elem.type ];
+
+        if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
+          return ret;
+        }
+
+        ret = elem.value;
+
+        return typeof ret === "string" ?
+          // handle most common string cases
+          ret.replace(rreturn, "") :
+          // handle cases where value is null/undef or number
+          ret == null ? "" : ret;
+      }
+
+      return;
+    }
+
+    isFunction = jQuery.isFunction( value );
+
+    return this.each(function( i ) {
+      var self = jQuery(this), val;
+
+      if ( this.nodeType !== 1 ) {
+        return;
+      }
+
+      if ( isFunction ) {
+        val = value.call( this, i, self.val() );
+      } else {
+        val = value;
+      }
+
+      // Treat null/undefined as ""; convert numbers to string
+      if ( val == null ) {
+        val = "";
+      } else if ( typeof val === "number" ) {
+        val += "";
+      } else if ( jQuery.isArray( val ) ) {
+        val = jQuery.map(val, function ( value ) {
+          return value == null ? "" : value + "";
+        });
+      }
+
+      hooks = jQuery.valHooks[ this.nodeName.toLowerCase() ] || jQuery.valHooks[ this.type ];
+
+      // If set returns undefined, fall back to normal setting
+      if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
+        this.value = val;
+      }
+    });
+  }
+});
+
+jQuery.extend({
+  valHooks: {
+    option: {
+      get: function( elem ) {
+        // attributes.value is undefined in Blackberry 4.7 but
+        // uses .value. See #6932
+        var val = elem.attributes.value;
+        return !val || val.specified ? elem.value : elem.text;
+      }
+    },
+    select: {
+      get: function( elem ) {
+        var value, i, max, option,
+          index = elem.selectedIndex,
+          values = [],
+          options = elem.options,
+          one = elem.type === "select-one";
+
+        // Nothing was selected
+        if ( index < 0 ) {
+          return null;
+        }
+
+        // Loop through all the selected options
+        i = one ? index : 0;
+        max = one ? index + 1 : options.length;
+        for ( ; i < max; i++ ) {
+          option = options[ i ];
+
+          // Don't return options that are disabled or in a disabled optgroup
+          if ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
+              (!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" )) ) {
+
+            // Get the specific value for the option
+            value = jQuery( option ).val();
+
+            // We don't need an array for one selects
+            if ( one ) {
+              return value;
+            }
+
+            // Multi-Selects return an array
+            values.push( value );
+          }
+        }
+
+        // Fixes Bug #2551 -- select.val() broken in IE after form.reset()
+        if ( one && !values.length && options.length ) {
+          return jQuery( options[ index ] ).val();
+        }
+
+        return values;
+      },
+
+      set: function( elem, value ) {
+        var values = jQuery.makeArray( value );
+
+        jQuery(elem).find("option").each(function() {
+          this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
+        });
+
+        if ( !values.length ) {
+          elem.selectedIndex = -1;
+        }
+        return values;
+      }
+    }
+  },
+
+  attrFn: {
+    val: true,
+    css: true,
+    html: true,
+    text: true,
+    data: true,
+    width: true,
+    height: true,
+    offset: true
+  },
+
+  attr: function( elem, name, value, pass ) {
+    var ret, hooks, notxml,
+      nType = elem.nodeType;
+
+    // don't get/set attributes on text, comment and attribute nodes
+    if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
+      return;
+    }
+
+    if ( pass && name in jQuery.attrFn ) {
+      return jQuery( elem )[ name ]( value );
+    }
+
+    // Fallback to prop when attributes are not supported
+    if ( typeof elem.getAttribute === "undefined" ) {
+      return jQuery.prop( elem, name, value );
+    }
+
+    notxml = nType !== 1 || !jQuery.isXMLDoc( elem );
+
+    // All attributes are lowercase
+    // Grab necessary hook if one is defined
+    if ( notxml ) {
+      name = name.toLowerCase();
+      hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
+    }
+
+    if ( value !== undefined ) {
+
+      if ( value === null ) {
+        jQuery.removeAttr( elem, name );
+        return;
+
+      } else if ( hooks && "set" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {
+        return ret;
+
+      } else {
+        elem.setAttribute( name, "" + value );
+        return value;
+      }
+
+    } else if ( hooks && "get" in hooks && notxml && (ret = hooks.get( elem, name )) !== null ) {
+      return ret;
+
+    } else {
+
+      ret = elem.getAttribute( name );
+
+      // Non-existent attributes return null, we normalize to undefined
+      return ret === null ?
+        undefined :
+        ret;
+    }
+  },
+
+  removeAttr: function( elem, value ) {
+    var propName, attrNames, name, l,
+      i = 0;
+
+    if ( value && elem.nodeType === 1 ) {
+      attrNames = value.toLowerCase().split( rspace );
+      l = attrNames.length;
+
+      for ( ; i < l; i++ ) {
+        name = attrNames[ i ];
+
+        if ( name ) {
+          propName = jQuery.propFix[ name ] || name;
+
+          // See #9699 for explanation of this approach (setting first, then removal)
+          jQuery.attr( elem, name, "" );
+          elem.removeAttribute( getSetAttribute ? name : propName );
+
+          // Set corresponding property to false for boolean attributes
+          if ( rboolean.test( name ) && propName in elem ) {
+            elem[ propName ] = false;
+          }
+        }
+      }
+    }
+  },
+
+  attrHooks: {
+    type: {
+      set: function( elem, value ) {
+        // We can't allow the type property to be changed (since it causes problems in IE)
+        if ( rtype.test( elem.nodeName ) && elem.parentNode ) {
+          jQuery.error( "type property can't be changed" );
+        } else if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
+          // Setting the type on a radio button after the value resets the value in IE6-9
+          // Reset value to its default in case type is set after value
+          // This is for element creation
+          var val = elem.value;
+          elem.setAttribute( "type", value );
+          if ( val ) {
+            elem.value = val;
+          }
+          return value;
+        }
+      }
+    },
+    // Use the value property for back compat
+    // Use the nodeHook for button elements in IE6/7 (#1954)
+    value: {
+      get: function( elem, name ) {
+        if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
+          return nodeHook.get( elem, name );
+        }
+        return name in elem ?
+          elem.value :
+          null;
+      },
+      set: function( elem, value, name ) {
+        if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
+          return nodeHook.set( elem, value, name );
+        }
+        // Does not return so that setAttribute is also used
+        elem.value = value;
+      }
+    }
+  },
+
+  propFix: {
+    tabindex: "tabIndex",
+    readonly: "readOnly",
+    "for": "htmlFor",
+    "class": "className",
+    maxlength: "maxLength",
+    cellspacing: "cellSpacing",
+    cellpadding: "cellPadding",
+    rowspan: "rowSpan",
+    colspan: "colSpan",
+    usemap: "useMap",
+    frameborder: "frameBorder",
+    contenteditable: "contentEditable"
+  },
+
+  prop: function( elem, name, value ) {
+    var ret, hooks, notxml,
+      nType = elem.nodeType;
+
+    // don't get/set properties on text, comment and attribute nodes
+    if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
+      return;
+    }
+
+    notxml = nType !== 1 || !jQuery.isXMLDoc( elem );
+
+    if ( notxml ) {
+      // Fix name and attach hooks
+      name = jQuery.propFix[ name ] || name;
+      hooks = jQuery.propHooks[ name ];
+    }
+
+    if ( value !== undefined ) {
+      if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
+        return ret;
+
+      } else {
+        return ( elem[ name ] = value );
+      }
+
+    } else {
+      if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
+        return ret;
+
+      } else {
+        return elem[ name ];
+      }
+    }
+  },
+
+  propHooks: {
+    tabIndex: {
+      get: function( elem ) {
+        // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
+        // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
+        var attributeNode = elem.getAttributeNode("tabindex");
+
+        return attributeNode && attributeNode.specified ?
+          parseInt( attributeNode.value, 10 ) :
+          rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
+            0 :
+            undefined;
+      }
+    }
+  }
+});
+
+// Add the tabIndex propHook to attrHooks for back-compat (different case is intentional)
+jQuery.attrHooks.tabindex = jQuery.propHooks.tabIndex;
+
+// Hook for boolean attributes
+boolHook = {
+  get: function( elem, name ) {
+    // Align boolean attributes with corresponding properties
+    // Fall back to attribute presence where some booleans are not supported
+    var attrNode,
+      property = jQuery.prop( elem, name );
+    return property === true || typeof property !== "boolean" && ( attrNode = elem.getAttributeNode(name) ) && attrNode.nodeValue !== false ?
+      name.toLowerCase() :
+      undefined;
+  },
+  set: function( elem, value, name ) {
+    var propName;
+    if ( value === false ) {
+      // Remove boolean attributes when set to false
+      jQuery.removeAttr( elem, name );
+    } else {
+      // value is true since we know at this point it's type boolean and not false
+      // Set boolean attributes to the same name and set the DOM property
+      propName = jQuery.propFix[ name ] || name;
+      if ( propName in elem ) {
+        // Only set the IDL specifically if it already exists on the element
+        elem[ propName ] = true;
+      }
+
+      elem.setAttribute( name, name.toLowerCase() );
+    }
+    return name;
+  }
+};
+
+// IE6/7 do not support getting/setting some attributes with get/setAttribute
+if ( !getSetAttribute ) {
+
+  fixSpecified = {
+    name: true,
+    id: true
+  };
+
+  // Use this for any attribute in IE6/7
+  // This fixes almost every IE6/7 issue
+  nodeHook = jQuery.valHooks.button = {
+    get: function( elem, name ) {
+      var ret;
+      ret = elem.getAttributeNode( name );
+      return ret && ( fixSpecified[ name ] ? ret.nodeValue !== "" : ret.specified ) ?
+        ret.nodeValue :
+        undefined;
+    },
+    set: function( elem, value, name ) {
+      // Set the existing or create a new attribute node
+      var ret = elem.getAttributeNode( name );
+      if ( !ret ) {
+        ret = document.createAttribute( name );
+        elem.setAttributeNode( ret );
+      }
+      return ( ret.nodeValue = value + "" );
+    }
+  };
+
+  // Apply the nodeHook to tabindex
+  jQuery.attrHooks.tabindex.set = nodeHook.set;
+
+  // Set width and height to auto instead of 0 on empty string( Bug #8150 )
+  // This is for removals
+  jQuery.each([ "width", "height" ], function( i, name ) {
+    jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
+      set: function( elem, value ) {
+        if ( value === "" ) {
+          elem.setAttribute( name, "auto" );
+          return value;
+        }
+      }
+    });
+  });
+
+  // Set contenteditable to false on removals(#10429)
+  // Setting to empty string throws an error as an invalid value
+  jQuery.attrHooks.contenteditable = {
+    get: nodeHook.get,
+    set: function( elem, value, name ) {
+      if ( value === "" ) {
+        value = "false";
+      }
+      nodeHook.set( elem, value, name );
+    }
+  };
+}
+
+
+// Some attributes require a special call on IE
+if ( !jQuery.support.hrefNormalized ) {
+  jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
+    jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
+      get: function( elem ) {
+        var ret = elem.getAttribute( name, 2 );
+        return ret === null ? undefined : ret;
+      }
+    });
+  });
+}
+
+if ( !jQuery.support.style ) {
+  jQuery.attrHooks.style = {
+    get: function( elem ) {
+      // Return undefined in the case of empty string
+      // Normalize to lowercase since IE uppercases css property names
+      return elem.style.cssText.toLowerCase() || undefined;
+    },
+    set: function( elem, value ) {
+      return ( elem.style.cssText = "" + value );
+    }
+  };
+}
+
+// Safari mis-reports the default selected property of an option
+// Accessing the parent's selectedIndex property fixes it
+if ( !jQuery.support.optSelected ) {
+  jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
+    get: function( elem ) {
+      var parent = elem.parentNode;
+
+      if ( parent ) {
+        parent.selectedIndex;
+
+        // Make sure that it also works with optgroups, see #5701
+        if ( parent.parentNode ) {
+          parent.parentNode.selectedIndex;
+        }
+      }
+      return null;
+    }
+  });
+}
+
+// IE6/7 call enctype encoding
+if ( !jQuery.support.enctype ) {
+  jQuery.propFix.enctype = "encoding";
+}
+
+// Radios and checkboxes getter/setter
+if ( !jQuery.support.checkOn ) {
+  jQuery.each([ "radio", "checkbox" ], function() {
+    jQuery.valHooks[ this ] = {
+      get: function( elem ) {
+        // Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
+        return elem.getAttribute("value") === null ? "on" : elem.value;
+      }
+    };
+  });
+}
+jQuery.each([ "radio", "checkbox" ], function() {
+  jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
+    set: function( elem, value ) {
+      if ( jQuery.isArray( value ) ) {
+        return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
+      }
+    }
+  });
+});
+
+
+
+
+var rformElems = /^(?:textarea|input|select)$/i,
+  rtypenamespace = /^([^\.]*)?(?:\.(.+))?$/,
+  rhoverHack = /\bhover(\.\S+)?\b/,
+  rkeyEvent = /^key/,
+  rmouseEvent = /^(?:mouse|contextmenu)|click/,
+  rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
+  rquickIs = /^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,
+  quickParse = function( selector ) {
+    var quick = rquickIs.exec( selector );
+    if ( quick ) {
+      //   0  1    2   3
+      // [ _, tag, id, class ]
+      quick[1] = ( quick[1] || "" ).toLowerCase();
+      quick[3] = quick[3] && new RegExp( "(?:^|\\s)" + quick[3] + "(?:\\s|$)" );
+    }
+    return quick;
+  },
+  quickIs = function( elem, m ) {
+    var attrs = elem.attributes || {};
+    return (
+      (!m[1] || elem.nodeName.toLowerCase() === m[1]) &&
+      (!m[2] || (attrs.id || {}).value === m[2]) &&
+      (!m[3] || m[3].test( (attrs[ "class" ] || {}).value ))
+    );
+  },
+  hoverHack = function( events ) {
+    return jQuery.event.special.hover ? events : events.replace( rhoverHack, "mouseenter$1 mouseleave$1" );
+  };
+
+/*
  * Helper functions for managing events -- not part of the public interface.
  * Props to Dean Edwards' addEvent library for many of the ideas.
  */
 jQuery.event = {
 
-	add: function( elem, types, handler, data, selector ) {
-
-		var elemData, eventHandle, events,
-			t, tns, type, namespaces, handleObj,
-			handleObjIn, quick, handlers, special;
-
-		// Don't attach events to noData or text/comment nodes (allow plain objects tho)
-		if ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {
-			return;
-		}
-
-		// Caller can pass in an object of custom data in lieu of the handler
-		if ( handler.handler ) {
-			handleObjIn = handler;
-			handler = handleObjIn.handler;
-		}
-
-		// Make sure that the handler has a unique ID, used to find/remove it later
-		if ( !handler.guid ) {
-			handler.guid = jQuery.guid++;
-		}
-
-		// Init the element's event structure and main handler, if this is the first
-		events = elemData.events;
-		if ( !events ) {
-			elemData.events = events = {};
-		}
-		eventHandle = elemData.handle;
-		if ( !eventHandle ) {
-			elemData.handle = eventHandle = function( e ) {
-				// Discard the second event of a jQuery.event.trigger() and
-				// when an event is called after a page has unloaded
-				return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
-					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
-					undefined;
-			};
-			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
-			eventHandle.elem = elem;
-		}
-
-		// Handle multiple events separated by a space
-		// jQuery(...).bind("mouseover mouseout", fn);
-		types = jQuery.trim( hoverHack(types) ).split( " " );
-		for ( t = 0; t < types.length; t++ ) {
-
-			tns = rtypenamespace.exec( types[t] ) || [];
-			type = tns[1];
-			namespaces = ( tns[2] || "" ).split( "." ).sort();
-
-			// If event changes its type, use the special event handlers for the changed type
-			special = jQuery.event.special[ type ] || {};
-
-			// If selector defined, determine special event api type, otherwise given type
-			type = ( selector ? special.delegateType : special.bindType ) || type;
-
-			// Update special based on newly reset type
-			special = jQuery.event.special[ type ] || {};
-
-			// handleObj is passed to all event handlers
-			handleObj = jQuery.extend({
-				type: type,
-				origType: tns[1],
-				data: data,
-				handler: handler,
-				guid: handler.guid,
-				selector: selector,
-				quick: quickParse( selector ),
-				namespace: namespaces.join(".")
-			}, handleObjIn );
-
-			// Init the event handler queue if we're the first
-			handlers = events[ type ];
-			if ( !handlers ) {
-				handlers = events[ type ] = [];
-				handlers.delegateCount = 0;
-
-				// Only use addEventListener/attachEvent if the special events handler returns false
-				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
-					// Bind the global event handler to the element
-					if ( elem.addEventListener ) {
-						elem.addEventListener( type, eventHandle, false );
-
-					} else if ( elem.attachEvent ) {
-						elem.attachEvent( "on" + type, eventHandle );
-					}
-				}
-			}
-
-			if ( special.add ) {
-				special.add.call( elem, handleObj );
-
-				if ( !handleObj.handler.guid ) {
-					handleObj.handler.guid = handler.guid;
-				}
-			}
-
-			// Add to the element's handler list, delegates in front
-			if ( selector ) {
-				handlers.splice( handlers.delegateCount++, 0, handleObj );
-			} else {
-				handlers.push( handleObj );
-			}
-
-			// Keep track of which events have ever been used, for event optimization
-			jQuery.event.global[ type ] = true;
-		}
-
-		// Nullify elem to prevent memory leaks in IE
-		elem = null;
-	},
-
-	global: {},
-
-	// Detach an event or set of events from an element
-	remove: function( elem, types, handler, selector, mappedTypes ) {
-
-		var elemData = jQuery.hasData( elem ) && jQuery._data( elem ),
-			t, tns, type, origType, namespaces, origCount,
-			j, events, special, handle, eventType, handleObj;
-
-		if ( !elemData || !(events = elemData.events) ) {
-			return;
-		}
-
-		// Once for each type.namespace in types; type may be omitted
-		types = jQuery.trim( hoverHack( types || "" ) ).split(" ");
-		for ( t = 0; t < types.length; t++ ) {
-			tns = rtypenamespace.exec( types[t] ) || [];
-			type = origType = tns[1];
-			namespaces = tns[2];
-
-			// Unbind all events (on this namespace, if provided) for the element
-			if ( !type ) {
-				for ( type in events ) {
-					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
-				}
-				continue;
-			}
-
-			special = jQuery.event.special[ type ] || {};
-			type = ( selector? special.delegateType : special.bindType ) || type;
-			eventType = events[ type ] || [];
-			origCount = eventType.length;
-			namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.)?") + "(\\.|$)") : null;
-
-			// Remove matching events
-			for ( j = 0; j < eventType.length; j++ ) {
-				handleObj = eventType[ j ];
-
-				if ( ( mappedTypes || origType === handleObj.origType ) &&
-					 ( !handler || handler.guid === handleObj.guid ) &&
-					 ( !namespaces || namespaces.test( handleObj.namespace ) ) &&
-					 ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
-					eventType.splice( j--, 1 );
-
-					if ( handleObj.selector ) {
-						eventType.delegateCount--;
-					}
-					if ( special.remove ) {
-						special.remove.call( elem, handleObj );
-					}
-				}
-			}
-
-			// Remove generic event handler if we removed something and no more handlers exist
-			// (avoids potential for endless recursion during removal of special event handlers)
-			if ( eventType.length === 0 && origCount !== eventType.length ) {
-				if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {
-					jQuery.removeEvent( elem, type, elemData.handle );
-				}
-
-				delete events[ type ];
-			}
-		}
-
-		// Remove the expando if it's no longer used
-		if ( jQuery.isEmptyObject( events ) ) {
-			handle = elemData.handle;
-			if ( handle ) {
-				handle.elem = null;
-			}
-
-			// removeData also checks for emptiness and clears the expando if empty
-			// so use it instead of delete
-			jQuery.removeData( elem, [ "events", "handle" ], true );
-		}
-	},
-
-	// Events that are safe to short-circuit if no handlers are attached.
-	// Native DOM events should not be added, they may have inline handlers.
-	customEvent: {
-		"getData": true,
-		"setData": true,
-		"changeData": true
-	},
-
-	trigger: function( event, data, elem, onlyHandlers ) {
-		// Don't do events on text and comment nodes
-		if ( elem && (elem.nodeType === 3 || elem.nodeType === 8) ) {
-			return;
-		}
-
-		// Event object or event type
-		var type = event.type || event,
-			namespaces = [],
-			cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType;
-
-		// focus/blur morphs to focusin/out; ensure we're not firing them right now
-		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
-			return;
-		}
-
-		if ( type.indexOf( "!" ) >= 0 ) {
-			// Exclusive events trigger only for the exact event (no namespaces)
-			type = type.slice(0, -1);
-			exclusive = true;
-		}
-
-		if ( type.indexOf( "." ) >= 0 ) {
-			// Namespaced trigger; create a regexp to match event type in handle()
-			namespaces = type.split(".");
-			type = namespaces.shift();
-			namespaces.sort();
-		}
-
-		if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
-			// No jQuery handlers for this event type, and it can't have inline handlers
-			return;
-		}
-
-		// Caller can pass in an Event, Object, or just an event type string
-		event = typeof event === "object" ?
-			// jQuery.Event object
-			event[ jQuery.expando ] ? event :
-			// Object literal
-			new jQuery.Event( type, event ) :
-			// Just the event type (string)
-			new jQuery.Event( type );
-
-		event.type = type;
-		event.isTrigger = true;
-		event.exclusive = exclusive;
-		event.namespace = namespaces.join( "." );
-		event.namespace_re = event.namespace? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.)?") + "(\\.|$)") : null;
-		ontype = type.indexOf( ":" ) < 0 ? "on" + type : "";
-
-		// Handle a global trigger
-		if ( !elem ) {
-
-			// TODO: Stop taunting the data cache; remove global events and always attach to document
-			cache = jQuery.cache;
-			for ( i in cache ) {
-				if ( cache[ i ].events && cache[ i ].events[ type ] ) {
-					jQuery.event.trigger( event, data, cache[ i ].handle.elem, true );
-				}
-			}
-			return;
-		}
-
-		// Clean up the event in case it is being reused
-		event.result = undefined;
-		if ( !event.target ) {
-			event.target = elem;
-		}
-
-		// Clone any incoming data and prepend the event, creating the handler arg list
-		data = data != null ? jQuery.makeArray( data ) : [];
-		data.unshift( event );
-
-		// Allow special events to draw outside the lines
-		special = jQuery.event.special[ type ] || {};
-		if ( special.trigger && special.trigger.apply( elem, data ) === false ) {
-			return;
-		}
-
-		// Determine event propagation path in advance, per W3C events spec (#9951)
-		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
-		eventPath = [[ elem, special.bindType || type ]];
-		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {
-
-			bubbleType = special.delegateType || type;
-			cur = rfocusMorph.test( bubbleType + type ) ? elem : elem.parentNode;
-			old = null;
-			for ( ; cur; cur = cur.parentNode ) {
-				eventPath.push([ cur, bubbleType ]);
-				old = cur;
-			}
-
-			// Only add window if we got to document (e.g., not plain obj or detached DOM)
-			if ( old && old === elem.ownerDocument ) {
-				eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);
-			}
-		}
-
-		// Fire handlers on the event path
-		for ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {
-
-			cur = eventPath[i][0];
-			event.type = eventPath[i][1];
-
-			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
-			if ( handle ) {
-				handle.apply( cur, data );
-			}
-			// Note that this is a bare JS function and not a jQuery handler
-			handle = ontype && cur[ ontype ];
-			if ( handle && jQuery.acceptData( cur ) && handle.apply( cur, data ) === false ) {
-				event.preventDefault();
-			}
-		}
-		event.type = type;
-
-		// If nobody prevented the default action, do it now
-		if ( !onlyHandlers && !event.isDefaultPrevented() ) {
-
-			if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
-				!(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {
-
-				// Call a native DOM method on the target with the same name name as the event.
-				// Can't use an .isFunction() check here because IE6/7 fails that test.
-				// Don't do default actions on window, that's where global variables be (#6170)
-				// IE<9 dies on focus/blur to hidden element (#1486)
-				if ( ontype && elem[ type ] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow( elem ) ) {
-
-					// Don't re-trigger an onFOO event when we call its FOO() method
-					old = elem[ ontype ];
-
-					if ( old ) {
-						elem[ ontype ] = null;
-					}
-
-					// Prevent re-triggering of the same event, since we already bubbled it above
-					jQuery.event.triggered = type;
-					elem[ type ]();
-					jQuery.event.triggered = undefined;
-
-					if ( old ) {
-						elem[ ontype ] = old;
-					}
-				}
-			}
-		}
-
-		return event.result;
-	},
-
-	dispatch: function( event ) {
-
-		// Make a writable jQuery.Event from the native event object
-		event = jQuery.event.fix( event || window.event );
-
-		var handlers = ( (jQuery._data( this, "events" ) || {} )[ event.type ] || []),
-			delegateCount = handlers.delegateCount,
-			args = [].slice.call( arguments, 0 ),
-			run_all = !event.exclusive && !event.namespace,
-			handlerQueue = [],
-			i, j, cur, jqcur, ret, selMatch, matched, matches, handleObj, sel, related;
-
-		// Use the fix-ed jQuery.Event rather than the (read-only) native event
-		args[0] = event;
-		event.delegateTarget = this;
-
-		// Determine handlers that should run if there are delegated events
-		// Avoid disabled elements in IE (#6911) and non-left-click bubbling in Firefox (#3861)
-		if ( delegateCount && !event.target.disabled && !(event.button && event.type === "click") ) {
-
-			// Pregenerate a single jQuery object for reuse with .is()
-			jqcur = jQuery(this);
-			jqcur.context = this.ownerDocument || this;
-
-			for ( cur = event.target; cur != this; cur = cur.parentNode || this ) {
-				selMatch = {};
-				matches = [];
-				jqcur[0] = cur;
-				for ( i = 0; i < delegateCount; i++ ) {
-					handleObj = handlers[ i ];
-					sel = handleObj.selector;
-
-					if ( selMatch[ sel ] === undefined ) {
-						selMatch[ sel ] = (
-							handleObj.quick ? quickIs( cur, handleObj.quick ) : jqcur.is( sel )
-						);
-					}
-					if ( selMatch[ sel ] ) {
-						matches.push( handleObj );
-					}
-				}
-				if ( matches.length ) {
-					handlerQueue.push({ elem: cur, matches: matches });
-				}
-			}
-		}
-
-		// Add the remaining (directly-bound) handlers
-		if ( handlers.length > delegateCount ) {
-			handlerQueue.push({ elem: this, matches: handlers.slice( delegateCount ) });
-		}
-
-		// Run delegates first; they may want to stop propagation beneath us
-		for ( i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++ ) {
-			matched = handlerQueue[ i ];
-			event.currentTarget = matched.elem;
-
-			for ( j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++ ) {
-				handleObj = matched.matches[ j ];
-
-				// Triggered event must either 1) be non-exclusive and have no namespace, or
-				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
-				if ( run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test( handleObj.namespace ) ) {
-
-					event.data = handleObj.data;
-					event.handleObj = handleObj;
-
-					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
-							.apply( matched.elem, args );
-
-					if ( ret !== undefined ) {
-						event.result = ret;
-						if ( ret === false ) {
-							event.preventDefault();
-							event.stopPropagation();
-						}
-					}
-				}
-			}
-		}
-
-		return event.result;
-	},
-
-	// Includes some event props shared by KeyEvent and MouseEvent
-	// *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
-	props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
-
-	fixHooks: {},
-
-	keyHooks: {
-		props: "char charCode key keyCode".split(" "),
-		filter: function( event, original ) {
-
-			// Add which for key events
-			if ( event.which == null ) {
-				event.which = original.charCode != null ? original.charCode : original.keyCode;
-			}
-
-			return event;
-		}
-	},
-
-	mouseHooks: {
-		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
-		filter: function( event, original ) {
-			var eventDoc, doc, body,
-				button = original.button,
-				fromElement = original.fromElement;
-
-			// Calculate pageX/Y if missing and clientX/Y available
-			if ( event.pageX == null && original.clientX != null ) {
-				eventDoc = event.target.ownerDocument || document;
-				doc = eventDoc.documentElement;
-				body = eventDoc.body;
-
-				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
-				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
-			}
-
-			// Add relatedTarget, if necessary
-			if ( !event.relatedTarget && fromElement ) {
-				event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
-			}
-
-			// Add which for click: 1 === left; 2 === middle; 3 === right
-			// Note: button is not normalized, so don't use it
-			if ( !event.which && button !== undefined ) {
-				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
-			}
-
-			return event;
-		}
-	},
-
-	fix: function( event ) {
-		if ( event[ jQuery.expando ] ) {
-			return event;
-		}
-
-		// Create a writable copy of the event object and normalize some properties
-		var i, prop,
-			originalEvent = event,
-			fixHook = jQuery.event.fixHooks[ event.type ] || {},
-			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;
-
-		event = jQuery.Event( originalEvent );
-
-		for ( i = copy.length; i; ) {
-			prop = copy[ --i ];
-			event[ prop ] = originalEvent[ prop ];
-		}
-
-		// Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)
-		if ( !event.target ) {
-			event.target = originalEvent.srcElement || document;
-		}
-
-		// Target should not be a text node (#504, Safari)
-		if ( event.target.nodeType === 3 ) {
-			event.target = event.target.parentNode;
-		}
-
-		// For mouse/key events; add metaKey if it's not there (#3368, IE6/7/8)
-		if ( event.metaKey === undefined ) {
-			event.metaKey = event.ctrlKey;
-		}
-
-		return fixHook.filter? fixHook.filter( event, originalEvent ) : event;
-	},
-
-	special: {
-		ready: {
-			// Make sure the ready event is setup
-			setup: jQuery.bindReady
-		},
-
-		load: {
-			// Prevent triggered image.load events from bubbling to window.load
-			noBubble: true
-		},
-
-		focus: {
-			delegateType: "focusin"
-		},
-		blur: {
-			delegateType: "focusout"
-		},
-
-		beforeunload: {
-			setup: function( data, namespaces, eventHandle ) {
-				// We only want to do this special case on windows
-				if ( jQuery.isWindow( this ) ) {
-					this.onbeforeunload = eventHandle;
-				}
-			},
-
-			teardown: function( namespaces, eventHandle ) {
-				if ( this.onbeforeunload === eventHandle ) {
-					this.onbeforeunload = null;
-				}
-			}
-		}
-	},
-
-	simulate: function( type, elem, event, bubble ) {
-		// Piggyback on a donor event to simulate a different one.
-		// Fake originalEvent to avoid donor's stopPropagation, but if the
-		// simulated event prevents default then we do the same on the donor.
-		var e = jQuery.extend(
-			new jQuery.Event(),
-			event,
-			{ type: type,
-				isSimulated: true,
-				originalEvent: {}
-			}
-		);
-		if ( bubble ) {
-			jQuery.event.trigger( e, null, elem );
-		} else {
-			jQuery.event.dispatch.call( elem, e );
-		}
-		if ( e.isDefaultPrevented() ) {
-			event.preventDefault();
-		}
-	}
+  add: function( elem, types, handler, data, selector ) {
+
+    var elemData, eventHandle, events,
+      t, tns, type, namespaces, handleObj,
+      handleObjIn, quick, handlers, special;
+
+    // Don't attach events to noData or text/comment nodes (allow plain objects tho)
+    if ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {
+      return;
+    }
+
+    // Caller can pass in an object of custom data in lieu of the handler
+    if ( handler.handler ) {
+      handleObjIn = handler;
+      handler = handleObjIn.handler;
+    }
+
+    // Make sure that the handler has a unique ID, used to find/remove it later
+    if ( !handler.guid ) {
+      handler.guid = jQuery.guid++;
+    }
+
+    // Init the element's event structure and main handler, if this is the first
+    events = elemData.events;
+    if ( !events ) {
+      elemData.events = events = {};
+    }
+    eventHandle = elemData.handle;
+    if ( !eventHandle ) {
+      elemData.handle = eventHandle = function( e ) {
+        // Discard the second event of a jQuery.event.trigger() and
+        // when an event is called after a page has unloaded
+        return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
+          jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
+          undefined;
+      };
+      // Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
+      eventHandle.elem = elem;
+    }
+
+    // Handle multiple events separated by a space
+    // jQuery(...).bind("mouseover mouseout", fn);
+    types = jQuery.trim( hoverHack(types) ).split( " " );
+    for ( t = 0; t < types.length; t++ ) {
+
+      tns = rtypenamespace.exec( types[t] ) || [];
+      type = tns[1];
+      namespaces = ( tns[2] || "" ).split( "." ).sort();
+
+      // If event changes its type, use the special event handlers for the changed type
+      special = jQuery.event.special[ type ] || {};
+
+      // If selector defined, determine special event api type, otherwise given type
+      type = ( selector ? special.delegateType : special.bindType ) || type;
+
+      // Update special based on newly reset type
+      special = jQuery.event.special[ type ] || {};
+
+      // handleObj is passed to all event handlers
+      handleObj = jQuery.extend({
+        type: type,
+        origType: tns[1],
+        data: data,
+        handler: handler,
+        guid: handler.guid,
+        selector: selector,
+        quick: quickParse( selector ),
+        namespace: namespaces.join(".")
+      }, handleObjIn );
+
+      // Init the event handler queue if we're the first
+      handlers = events[ type ];
+      if ( !handlers ) {
+        handlers = events[ type ] = [];
+        handlers.delegateCount = 0;
+
+        // Only use addEventListener/attachEvent if the special events handler returns false
+        if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
+          // Bind the global event handler to the element
+          if ( elem.addEventListener ) {
+            elem.addEventListener( type, eventHandle, false );
+
+          } else if ( elem.attachEvent ) {
+            elem.attachEvent( "on" + type, eventHandle );
+          }
+        }
+      }
+
+      if ( special.add ) {
+        special.add.call( elem, handleObj );
+
+        if ( !handleObj.handler.guid ) {
+          handleObj.handler.guid = handler.guid;
+        }
+      }
+
+      // Add to the element's handler list, delegates in front
+      if ( selector ) {
+        handlers.splice( handlers.delegateCount++, 0, handleObj );
+      } else {
+        handlers.push( handleObj );
+      }
+
+      // Keep track of which events have ever been used, for event optimization
+      jQuery.event.global[ type ] = true;
+    }
+
+    // Nullify elem to prevent memory leaks in IE
+    elem = null;
+  },
+
+  global: {},
+
+  // Detach an event or set of events from an element
+  remove: function( elem, types, handler, selector, mappedTypes ) {
+
+    var elemData = jQuery.hasData( elem ) && jQuery._data( elem ),
+      t, tns, type, origType, namespaces, origCount,
+      j, events, special, handle, eventType, handleObj;
+
+    if ( !elemData || !(events = elemData.events) ) {
+      return;
+    }
+
+    // Once for each type.namespace in types; type may be omitted
+    types = jQuery.trim( hoverHack( types || "" ) ).split(" ");
+    for ( t = 0; t < types.length; t++ ) {
+      tns = rtypenamespace.exec( types[t] ) || [];
+      type = origType = tns[1];
+      namespaces = tns[2];
+
+      // Unbind all events (on this namespace, if provided) for the element
+      if ( !type ) {
+        for ( type in events ) {
+          jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
+        }
+        continue;
+      }
+
+      special = jQuery.event.special[ type ] || {};
+      type = ( selector? special.delegateType : special.bindType ) || type;
+      eventType = events[ type ] || [];
+      origCount = eventType.length;
+      namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.)?") + "(\\.|$)") : null;
+
+      // Remove matching events
+      for ( j = 0; j < eventType.length; j++ ) {
+        handleObj = eventType[ j ];
+
+        if ( ( mappedTypes || origType === handleObj.origType ) &&
+           ( !handler || handler.guid === handleObj.guid ) &&
+           ( !namespaces || namespaces.test( handleObj.namespace ) ) &&
+           ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
+          eventType.splice( j--, 1 );
+
+          if ( handleObj.selector ) {
+            eventType.delegateCount--;
+          }
+          if ( special.remove ) {
+            special.remove.call( elem, handleObj );
+          }
+        }
+      }
+
+      // Remove generic event handler if we removed something and no more handlers exist
+      // (avoids potential for endless recursion during removal of special event handlers)
+      if ( eventType.length === 0 && origCount !== eventType.length ) {
+        if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {
+          jQuery.removeEvent( elem, type, elemData.handle );
+        }
+
+        delete events[ type ];
+      }
+    }
+
+    // Remove the expando if it's no longer used
+    if ( jQuery.isEmptyObject( events ) ) {
+      handle = elemData.handle;
+      if ( handle ) {
+        handle.elem = null;
+      }
+
+      // removeData also checks for emptiness and clears the expando if empty
+      // so use it instead of delete
+      jQuery.removeData( elem, [ "events", "handle" ], true );
+    }
+  },
+
+  // Events that are safe to short-circuit if no handlers are attached.
+  // Native DOM events should not be added, they may have inline handlers.
+  customEvent: {
+    "getData": true,
+    "setData": true,
+    "changeData": true
+  },
+
+  trigger: function( event, data, elem, onlyHandlers ) {
+    // Don't do events on text and comment nodes
+    if ( elem && (elem.nodeType === 3 || elem.nodeType === 8) ) {
+      return;
+    }
+
+    // Event object or event type
+    var type = event.type || event,
+      namespaces = [],
+      cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType;
+
+    // focus/blur morphs to focusin/out; ensure we're not firing them right now
+    if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
+      return;
+    }
+
+    if ( type.indexOf( "!" ) >= 0 ) {
+      // Exclusive events trigger only for the exact event (no namespaces)
+      type = type.slice(0, -1);
+      exclusive = true;
+    }
+
+    if ( type.indexOf( "." ) >= 0 ) {
+      // Namespaced trigger; create a regexp to match event type in handle()
+      namespaces = type.split(".");
+      type = namespaces.shift();
+      namespaces.sort();
+    }
+
+    if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
+      // No jQuery handlers for this event type, and it can't have inline handlers
+      return;
+    }
+
+    // Caller can pass in an Event, Object, or just an event type string
+    event = typeof event === "object" ?
+      // jQuery.Event object
+      event[ jQuery.expando ] ? event :
+      // Object literal
+      new jQuery.Event( type, event ) :
+      // Just the event type (string)
+      new jQuery.Event( type );
+
+    event.type = type;
+    event.isTrigger = true;
+    event.exclusive = exclusive;
+    event.namespace = namespaces.join( "." );
+    event.namespace_re = event.namespace? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.)?") + "(\\.|$)") : null;
+    ontype = type.indexOf( ":" ) < 0 ? "on" + type : "";
+
+    // Handle a global trigger
+    if ( !elem ) {
+
+      // TODO: Stop taunting the data cache; remove global events and always attach to document
+      cache = jQuery.cache;
+      for ( i in cache ) {
+        if ( cache[ i ].events && cache[ i ].events[ type ] ) {
+          jQuery.event.trigger( event, data, cache[ i ].handle.elem, true );
+        }
+      }
+      return;
+    }
+
+    // Clean up the event in case it is being reused
+    event.result = undefined;
+    if ( !event.target ) {
+      event.target = elem;
+    }
+
+    // Clone any incoming data and prepend the event, creating the handler arg list
+    data = data != null ? jQuery.makeArray( data ) : [];
+    data.unshift( event );
+
+    // Allow special events to draw outside the lines
+    special = jQuery.event.special[ type ] || {};
+    if ( special.trigger && special.trigger.apply( elem, data ) === false ) {
+      return;
+    }
+
+    // Determine event propagation path in advance, per W3C events spec (#9951)
+    // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
+    eventPath = [[ elem, special.bindType || type ]];
+    if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {
+
+      bubbleType = special.delegateType || type;
+      cur = rfocusMorph.test( bubbleType + type ) ? elem : elem.parentNode;
+      old = null;
+      for ( ; cur; cur = cur.parentNode ) {
+        eventPath.push([ cur, bubbleType ]);
+        old = cur;
+      }
+
+      // Only add window if we got to document (e.g., not plain obj or detached DOM)
+      if ( old && old === elem.ownerDocument ) {
+        eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);
+      }
+    }
+
+    // Fire handlers on the event path
+    for ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {
+
+      cur = eventPath[i][0];
+      event.type = eventPath[i][1];
+
+      handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
+      if ( handle ) {
+        handle.apply( cur, data );
+      }
+      // Note that this is a bare JS function and not a jQuery handler
+      handle = ontype && cur[ ontype ];
+      if ( handle && jQuery.acceptData( cur ) && handle.apply( cur, data ) === false ) {
+        event.preventDefault();
+      }
+    }
+    event.type = type;
+
+    // If nobody prevented the default action, do it now
+    if ( !onlyHandlers && !event.isDefaultPrevented() ) {
+
+      if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
+        !(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {
+
+        // Call a native DOM method on the target with the same name name as the event.
+        // Can't use an .isFunction() check here because IE6/7 fails that test.
+        // Don't do default actions on window, that's where global variables be (#6170)
+        // IE<9 dies on focus/blur to hidden element (#1486)
+        if ( ontype && elem[ type ] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow( elem ) ) {
+
+          // Don't re-trigger an onFOO event when we call its FOO() method
+          old = elem[ ontype ];
+
+          if ( old ) {
+            elem[ ontype ] = null;
+          }
+
+          // Prevent re-triggering of the same event, since we already bubbled it above
+          jQuery.event.triggered = type;
+          elem[ type ]();
+          jQuery.event.triggered = undefined;
+
+          if ( old ) {
+            elem[ ontype ] = old;
+          }
+        }
+      }
+    }
+
+    return event.result;
+  },
+
+  dispatch: function( event ) {
+
+    // Make a writable jQuery.Event from the native event object
+    event = jQuery.event.fix( event || window.event );
+
+    var handlers = ( (jQuery._data( this, "events" ) || {} )[ event.type ] || []),
+      delegateCount = handlers.delegateCount,
+      args = [].slice.call( arguments, 0 ),
+      run_all = !event.exclusive && !event.namespace,
+      handlerQueue = [],
+      i, j, cur, jqcur, ret, selMatch, matched, matches, handleObj, sel, related;
+
+    // Use the fix-ed jQuery.Event rather than the (read-only) native event
+    args[0] = event;
+    event.delegateTarget = this;
+
+    // Determine handlers that should run if there are delegated events
+    // Avoid disabled elements in IE (#6911) and non-left-click bubbling in Firefox (#3861)
+    if ( delegateCount && !event.target.disabled && !(event.button && event.type === "click") ) {
+
+      // Pregenerate a single jQuery object for reuse with .is()
+      jqcur = jQuery(this);
+      jqcur.context = this.ownerDocument || this;
+
+      for ( cur = event.target; cur != this; cur = cur.parentNode || this ) {
+        selMatch = {};
+        matches = [];
+        jqcur[0] = cur;
+        for ( i = 0; i < delegateCount; i++ ) {
+          handleObj = handlers[ i ];
+          sel = handleObj.selector;
+
+          if ( selMatch[ sel ] === undefined ) {
+            selMatch[ sel ] = (
+              handleObj.quick ? quickIs( cur, handleObj.quick ) : jqcur.is( sel )
+            );
+          }
+          if ( selMatch[ sel ] ) {
+            matches.push( handleObj );
+          }
+        }
+        if ( matches.length ) {
+          handlerQueue.push({ elem: cur, matches: matches });
+        }
+      }
+    }
+
+    // Add the remaining (directly-bound) handlers
+    if ( handlers.length > delegateCount ) {
+      handlerQueue.push({ elem: this, matches: handlers.slice( delegateCount ) });
+    }
+
+    // Run delegates first; they may want to stop propagation beneath us
+    for ( i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++ ) {
+      matched = handlerQueue[ i ];
+      event.currentTarget = matched.elem;
+
+      for ( j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++ ) {
+        handleObj = matched.matches[ j ];
+
+        // Triggered event must either 1) be non-exclusive and have no namespace, or
+        // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
+        if ( run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test( handleObj.namespace ) ) {
+
+          event.data = handleObj.data;
+          event.handleObj = handleObj;
+
+          ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
+              .apply( matched.elem, args );
+
+          if ( ret !== undefined ) {
+            event.result = ret;
+            if ( ret === false ) {
+              event.preventDefault();
+              event.stopPropagation();
+            }
+          }
+        }
+      }
+    }
+
+    return event.result;
+  },
+
+  // Includes some event props shared by KeyEvent and MouseEvent
+  // *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
+  props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
+
+  fixHooks: {},
+
+  keyHooks: {
+    props: "char charCode key keyCode".split(" "),
+    filter: function( event, original ) {
+
+      // Add which for key events
+      if ( event.which == null ) {
+        event.which = original.charCode != null ? original.charCode : original.keyCode;
+      }
+
+      return event;
+    }
+  },
+
+  mouseHooks: {
+    props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
+    filter: function( event, original ) {
+      var eventDoc, doc, body,
+        button = original.button,
+        fromElement = original.fromElement;
+
+      // Calculate pageX/Y if missing and clientX/Y available
+      if ( event.pageX == null && original.clientX != null ) {
+        eventDoc = event.target.ownerDocument || document;
+        doc = eventDoc.documentElement;
+        body = eventDoc.body;
+
+        event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
+        event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
+      }
+
+      // Add relatedTarget, if necessary
+      if ( !event.relatedTarget && fromElement ) {
+        event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
+      }
+
+      // Add which for click: 1 === left; 2 === middle; 3 === right
+      // Note: button is not normalized, so don't use it
+      if ( !event.which && button !== undefined ) {
+        event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
+      }
+
+      return event;
+    }
+  },
+
+  fix: function( event ) {
+    if ( event[ jQuery.expando ] ) {
+      return event;
+    }
+
+    // Create a writable copy of the event object and normalize some properties
+    var i, prop,
+      originalEvent = event,
+      fixHook = jQuery.event.fixHooks[ event.type ] || {},
+      copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;
+
+    event = jQuery.Event( originalEvent );
+
+    for ( i = copy.length; i; ) {
+      prop = copy[ --i ];
+      event[ prop ] = originalEvent[ prop ];
+    }
+
+    // Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)
+    if ( !event.target ) {
+      event.target = originalEvent.srcElement || document;
+    }
+
+    // Target should not be a text node (#504, Safari)
+    if ( event.target.nodeType === 3 ) {
+      event.target = event.target.parentNode;
+    }
+
+    // For mouse/key events; add metaKey if it's not there (#3368, IE6/7/8)
+    if ( event.metaKey === undefined ) {
+      event.metaKey = event.ctrlKey;
+    }
+
+    return fixHook.filter? fixHook.filter( event, originalEvent ) : event;
+  },
+
+  special: {
+    ready: {
+      // Make sure the ready event is setup
+      setup: jQuery.bindReady
+    },
+
+    load: {
+      // Prevent triggered image.load events from bubbling to window.load
+      noBubble: true
+    },
+
+    focus: {
+      delegateType: "focusin"
+    },
+    blur: {
+      delegateType: "focusout"
+    },
+
+    beforeunload: {
+      setup: function( data, namespaces, eventHandle ) {
+        // We only want to do this special case on windows
+        if ( jQuery.isWindow( this ) ) {
+          this.onbeforeunload = eventHandle;
+        }
+      },
+
+      teardown: function( namespaces, eventHandle ) {
+        if ( this.onbeforeunload === eventHandle ) {
+          this.onbeforeunload = null;
+        }
+      }
+    }
+  },
+
+  simulate: function( type, elem, event, bubble ) {
+    // Piggyback on a donor event to simulate a different one.
+    // Fake originalEvent to avoid donor's stopPropagation, but if the
+    // simulated event prevents default then we do the same on the donor.
+    var e = jQuery.extend(
+      new jQuery.Event(),
+      event,
+      { type: type,
+        isSimulated: true,
+        originalEvent: {}
+      }
+    );
+    if ( bubble ) {
+      jQuery.event.trigger( e, null, elem );
+    } else {
+      jQuery.event.dispatch.call( elem, e );
+    }
+    if ( e.isDefaultPrevented() ) {
+      event.preventDefault();
+    }
+  }
 };
 
 // Some plugins are using, but it's undocumented/deprecated and will be removed.
@@ -5498,1355 +5498,1355 @@ jQuery.event = {
 jQuery.event.handle = jQuery.event.dispatch;
 
 jQuery.removeEvent = document.removeEventListener ?
-	function( elem, type, handle ) {
-		if ( elem.removeEventListener ) {
-			elem.removeEventListener( type, handle, false );
-		}
-	} :
-	function( elem, type, handle ) {
-		if ( elem.detachEvent ) {
-			elem.detachEvent( "on" + type, handle );
-		}
-	};
+  function( elem, type, handle ) {
+    if ( elem.removeEventListener ) {
+      elem.removeEventListener( type, handle, false );
+    }
+  } :
+  function( elem, type, handle ) {
+    if ( elem.detachEvent ) {
+      elem.detachEvent( "on" + type, handle );
+    }
+  };
 
 jQuery.Event = function( src, props ) {
-	// Allow instantiation without the 'new' keyword
-	if ( !(this instanceof jQuery.Event) ) {
-		return new jQuery.Event( src, props );
-	}
-
-	// Event object
-	if ( src && src.type ) {
-		this.originalEvent = src;
-		this.type = src.type;
-
-		// Events bubbling up the document may have been marked as prevented
-		// by a handler lower down the tree; reflect the correct value.
-		this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
-			src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;
-
-	// Event type
-	} else {
-		this.type = src;
-	}
-
-	// Put explicitly provided properties onto the event object
-	if ( props ) {
-		jQuery.extend( this, props );
-	}
-
-	// Create a timestamp if incoming event doesn't have one
-	this.timeStamp = src && src.timeStamp || jQuery.now();
-
-	// Mark it as fixed
-	this[ jQuery.expando ] = true;
+  // Allow instantiation without the 'new' keyword
+  if ( !(this instanceof jQuery.Event) ) {
+    return new jQuery.Event( src, props );
+  }
+
+  // Event object
+  if ( src && src.type ) {
+    this.originalEvent = src;
+    this.type = src.type;
+
+    // Events bubbling up the document may have been marked as prevented
+    // by a handler lower down the tree; reflect the correct value.
+    this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
+      src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;
+
+  // Event type
+  } else {
+    this.type = src;
+  }
+
+  // Put explicitly provided properties onto the event object
+  if ( props ) {
+    jQuery.extend( this, props );
+  }
+
+  // Create a timestamp if incoming event doesn't have one
+  this.timeStamp = src && src.timeStamp || jQuery.now();
+
+  // Mark it as fixed
+  this[ jQuery.expando ] = true;
+};
+
+function returnFalse() {
+  return false;
+}
+function returnTrue() {
+  return true;
+}
+
+// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
+// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
+jQuery.Event.prototype = {
+  preventDefault: function() {
+    this.isDefaultPrevented = returnTrue;
+
+    var e = this.originalEvent;
+    if ( !e ) {
+      return;
+    }
+
+    // if preventDefault exists run it on the original event
+    if ( e.preventDefault ) {
+      e.preventDefault();
+
+    // otherwise set the returnValue property of the original event to false (IE)
+    } else {
+      e.returnValue = false;
+    }
+  },
+  stopPropagation: function() {
+    this.isPropagationStopped = returnTrue;
+
+    var e = this.originalEvent;
+    if ( !e ) {
+      return;
+    }
+    // if stopPropagation exists run it on the original event
+    if ( e.stopPropagation ) {
+      e.stopPropagation();
+    }
+    // otherwise set the cancelBubble property of the original event to true (IE)
+    e.cancelBubble = true;
+  },
+  stopImmediatePropagation: function() {
+    this.isImmediatePropagationStopped = returnTrue;
+    this.stopPropagation();
+  },
+  isDefaultPrevented: returnFalse,
+  isPropagationStopped: returnFalse,
+  isImmediatePropagationStopped: returnFalse
+};
+
+// Create mouseenter/leave events using mouseover/out and event-time checks
+jQuery.each({
+  mouseenter: "mouseover",
+  mouseleave: "mouseout"
+}, function( orig, fix ) {
+  jQuery.event.special[ orig ] = {
+    delegateType: fix,
+    bindType: fix,
+
+    handle: function( event ) {
+      var target = this,
+        related = event.relatedTarget,
+        handleObj = event.handleObj,
+        selector = handleObj.selector,
+        ret;
+
+      // For mousenter/leave call the handler if related is outside the target.
+      // NB: No relatedTarget if the mouse left/entered the browser window
+      if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
+        event.type = handleObj.origType;
+        ret = handleObj.handler.apply( this, arguments );
+        event.type = fix;
+      }
+      return ret;
+    }
+  };
+});
+
+// IE submit delegation
+if ( !jQuery.support.submitBubbles ) {
+
+  jQuery.event.special.submit = {
+    setup: function() {
+      // Only need this for delegated form submit events
+      if ( jQuery.nodeName( this, "form" ) ) {
+        return false;
+      }
+
+      // Lazy-add a submit handler when a descendant form may potentially be submitted
+      jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
+        // Node name check avoids a VML-related crash in IE (#9807)
+        var elem = e.target,
+          form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
+        if ( form && !form._submit_attached ) {
+          jQuery.event.add( form, "submit._submit", function( event ) {
+            // If form was submitted by the user, bubble the event up the tree
+            if ( this.parentNode && !event.isTrigger ) {
+              jQuery.event.simulate( "submit", this.parentNode, event, true );
+            }
+          });
+          form._submit_attached = true;
+        }
+      });
+      // return undefined since we don't need an event listener
+    },
+
+    teardown: function() {
+      // Only need this for delegated form submit events
+      if ( jQuery.nodeName( this, "form" ) ) {
+        return false;
+      }
+
+      // Remove delegated handlers; cleanData eventually reaps submit handlers attached above
+      jQuery.event.remove( this, "._submit" );
+    }
+  };
+}
+
+// IE change delegation and checkbox/radio fix
+if ( !jQuery.support.changeBubbles ) {
+
+  jQuery.event.special.change = {
+
+    setup: function() {
+
+      if ( rformElems.test( this.nodeName ) ) {
+        // IE doesn't fire change on a check/radio until blur; trigger it on click
+        // after a propertychange. Eat the blur-change in special.change.handle.
+        // This still fires onchange a second time for check/radio after blur.
+        if ( this.type === "checkbox" || this.type === "radio" ) {
+          jQuery.event.add( this, "propertychange._change", function( event ) {
+            if ( event.originalEvent.propertyName === "checked" ) {
+              this._just_changed = true;
+            }
+          });
+          jQuery.event.add( this, "click._change", function( event ) {
+            if ( this._just_changed && !event.isTrigger ) {
+              this._just_changed = false;
+              jQuery.event.simulate( "change", this, event, true );
+            }
+          });
+        }
+        return false;
+      }
+      // Delegated event; lazy-add a change handler on descendant inputs
+      jQuery.event.add( this, "beforeactivate._change", function( e ) {
+        var elem = e.target;
+
+        if ( rformElems.test( elem.nodeName ) && !elem._change_attached ) {
+          jQuery.event.add( elem, "change._change", function( event ) {
+            if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
+              jQuery.event.simulate( "change", this.parentNode, event, true );
+            }
+          });
+          elem._change_attached = true;
+        }
+      });
+    },
+
+    handle: function( event ) {
+      var elem = event.target;
+
+      // Swallow native change events from checkbox/radio, we already triggered them above
+      if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
+        return event.handleObj.handler.apply( this, arguments );
+      }
+    },
+
+    teardown: function() {
+      jQuery.event.remove( this, "._change" );
+
+      return rformElems.test( this.nodeName );
+    }
+  };
+}
+
+// Create "bubbling" focus and blur events
+if ( !jQuery.support.focusinBubbles ) {
+  jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {
+
+    // Attach a single capturing handler while someone wants focusin/focusout
+    var attaches = 0,
+      handler = function( event ) {
+        jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
+      };
+
+    jQuery.event.special[ fix ] = {
+      setup: function() {
+        if ( attaches++ === 0 ) {
+          document.addEventListener( orig, handler, true );
+        }
+      },
+      teardown: function() {
+        if ( --attaches === 0 ) {
+          document.removeEventListener( orig, handler, true );
+        }
+      }
+    };
+  });
+}
+
+jQuery.fn.extend({
+
+  on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
+    var origFn, type;
+
+    // Types can be a map of types/handlers
+    if ( typeof types === "object" ) {
+      // ( types-Object, selector, data )
+      if ( typeof selector !== "string" ) {
+        // ( types-Object, data )
+        data = selector;
+        selector = undefined;
+      }
+      for ( type in types ) {
+        this.on( type, selector, data, types[ type ], one );
+      }
+      return this;
+    }
+
+    if ( data == null && fn == null ) {
+      // ( types, fn )
+      fn = selector;
+      data = selector = undefined;
+    } else if ( fn == null ) {
+      if ( typeof selector === "string" ) {
+        // ( types, selector, fn )
+        fn = data;
+        data = undefined;
+      } else {
+        // ( types, data, fn )
+        fn = data;
+        data = selector;
+        selector = undefined;
+      }
+    }
+    if ( fn === false ) {
+      fn = returnFalse;
+    } else if ( !fn ) {
+      return this;
+    }
+
+    if ( one === 1 ) {
+      origFn = fn;
+      fn = function( event ) {
+        // Can use an empty set, since event contains the info
+        jQuery().off( event );
+        return origFn.apply( this, arguments );
+      };
+      // Use same guid so caller can remove using origFn
+      fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
+    }
+    return this.each( function() {
+      jQuery.event.add( this, types, fn, data, selector );
+    });
+  },
+  one: function( types, selector, data, fn ) {
+    return this.on.call( this, types, selector, data, fn, 1 );
+  },
+  off: function( types, selector, fn ) {
+    if ( types && types.preventDefault && types.handleObj ) {
+      // ( event )  dispatched jQuery.Event
+      var handleObj = types.handleObj;
+      jQuery( types.delegateTarget ).off(
+        handleObj.namespace? handleObj.type + "." + handleObj.namespace : handleObj.type,
+        handleObj.selector,
+        handleObj.handler
+      );
+      return this;
+    }
+    if ( typeof types === "object" ) {
+      // ( types-object [, selector] )
+      for ( var type in types ) {
+        this.off( type, selector, types[ type ] );
+      }
+      return this;
+    }
+    if ( selector === false || typeof selector === "function" ) {
+      // ( types [, fn] )
+      fn = selector;
+      selector = undefined;
+    }
+    if ( fn === false ) {
+      fn = returnFalse;
+    }
+    return this.each(function() {
+      jQuery.event.remove( this, types, fn, selector );
+    });
+  },
+
+  bind: function( types, data, fn ) {
+    return this.on( types, null, data, fn );
+  },
+  unbind: function( types, fn ) {
+    return this.off( types, null, fn );
+  },
+
+  live: function( types, data, fn ) {
+    jQuery( this.context ).on( types, this.selector, data, fn );
+    return this;
+  },
+  die: function( types, fn ) {
+    jQuery( this.context ).off( types, this.selector || "**", fn );
+    return this;
+  },
+
+  delegate: function( selector, types, data, fn ) {
+    return this.on( types, selector, data, fn );
+  },
+  undelegate: function( selector, types, fn ) {
+    // ( namespace ) or ( selector, types [, fn] )
+    return arguments.length == 1? this.off( selector, "**" ) : this.off( types, selector, fn );
+  },
+
+  trigger: function( type, data ) {
+    return this.each(function() {
+      jQuery.event.trigger( type, data, this );
+    });
+  },
+  triggerHandler: function( type, data ) {
+    if ( this[0] ) {
+      return jQuery.event.trigger( type, data, this[0], true );
+    }
+  },
+
+  toggle: function( fn ) {
+    // Save reference to arguments for access in closure
+    var args = arguments,
+      guid = fn.guid || jQuery.guid++,
+      i = 0,
+      toggler = function( event ) {
+        // Figure out which function to execute
+        var lastToggle = ( jQuery._data( this, "lastToggle" + fn.guid ) || 0 ) % i;
+        jQuery._data( this, "lastToggle" + fn.guid, lastToggle + 1 );
+
+        // Make sure that clicks stop
+        event.preventDefault();
+
+        // and execute the function
+        return args[ lastToggle ].apply( this, arguments ) || false;
+      };
+
+    // link all the functions, so any of them can unbind this click handler
+    toggler.guid = guid;
+    while ( i < args.length ) {
+      args[ i++ ].guid = guid;
+    }
+
+    return this.click( toggler );
+  },
+
+  hover: function( fnOver, fnOut ) {
+    return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
+  }
+});
+
+jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
+  "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
+  "change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {
+
+  // Handle event binding
+  jQuery.fn[ name ] = function( data, fn ) {
+    if ( fn == null ) {
+      fn = data;
+      data = null;
+    }
+
+    return arguments.length > 0 ?
+      this.on( name, null, data, fn ) :
+      this.trigger( name );
+  };
+
+  if ( jQuery.attrFn ) {
+    jQuery.attrFn[ name ] = true;
+  }
+
+  if ( rkeyEvent.test( name ) ) {
+    jQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;
+  }
+
+  if ( rmouseEvent.test( name ) ) {
+    jQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;
+  }
+});
+
+
+
+/*!
+ * Sizzle CSS Selector Engine
+ *  Copyright 2011, The Dojo Foundation
+ *  Released under the MIT, BSD, and GPL Licenses.
+ *  More information: http://sizzlejs.com/
+ */
+(function(){
+
+var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
+  expando = "sizcache" + (Math.random() + '').replace('.', ''),
+  done = 0,
+  toString = Object.prototype.toString,
+  hasDuplicate = false,
+  baseHasDuplicate = true,
+  rBackslash = /\\/g,
+  rReturn = /\r\n/g,
+  rNonWord = /\W/;
+
+// Here we check if the JavaScript engine is using some sort of
+// optimization where it does not always call our comparision
+// function. If that is the case, discard the hasDuplicate value.
+//   Thus far that includes Google Chrome.
+[0, 0].sort(function() {
+  baseHasDuplicate = false;
+  return 0;
+});
+
+var Sizzle = function( selector, context, results, seed ) {
+  results = results || [];
+  context = context || document;
+
+  var origContext = context;
+
+  if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
+    return [];
+  }
+  
+  if ( !selector || typeof selector !== "string" ) {
+    return results;
+  }
+
+  var m, set, checkSet, extra, ret, cur, pop, i,
+    prune = true,
+    contextXML = Sizzle.isXML( context ),
+    parts = [],
+    soFar = selector;
+  
+  // Reset the position of the chunker regexp (start from head)
+  do {
+    chunker.exec( "" );
+    m = chunker.exec( soFar );
+
+    if ( m ) {
+      soFar = m[3];
+    
+      parts.push( m[1] );
+    
+      if ( m[2] ) {
+        extra = m[3];
+        break;
+      }
+    }
+  } while ( m );
+
+  if ( parts.length > 1 && origPOS.exec( selector ) ) {
+
+    if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
+      set = posProcess( parts[0] + parts[1], context, seed );
+
+    } else {
+      set = Expr.relative[ parts[0] ] ?
+        [ context ] :
+        Sizzle( parts.shift(), context );
+
+      while ( parts.length ) {
+        selector = parts.shift();
+
+        if ( Expr.relative[ selector ] ) {
+          selector += parts.shift();
+        }
+        
+        set = posProcess( selector, set, seed );
+      }
+    }
+
+  } else {
+    // Take a shortcut and set the context if the root selector is an ID
+    // (but not if it'll be faster if the inner selector is an ID)
+    if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
+        Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {
+
+      ret = Sizzle.find( parts.shift(), context, contextXML );
+      context = ret.expr ?
+        Sizzle.filter( ret.expr, ret.set )[0] :
+        ret.set[0];
+    }
+
+    if ( context ) {
+      ret = seed ?
+        { expr: parts.pop(), set: makeArray(seed) } :
+        Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );
+
+      set = ret.expr ?
+        Sizzle.filter( ret.expr, ret.set ) :
+        ret.set;
+
+      if ( parts.length > 0 ) {
+        checkSet = makeArray( set );
+
+      } else {
+        prune = false;
+      }
+
+      while ( parts.length ) {
+        cur = parts.pop();
+        pop = cur;
+
+        if ( !Expr.relative[ cur ] ) {
+          cur = "";
+        } else {
+          pop = parts.pop();
+        }
+
+        if ( pop == null ) {
+          pop = context;
+        }
+
+        Expr.relative[ cur ]( checkSet, pop, contextXML );
+      }
+
+    } else {
+      checkSet = parts = [];
+    }
+  }
+
+  if ( !checkSet ) {
+    checkSet = set;
+  }
+
+  if ( !checkSet ) {
+    Sizzle.error( cur || selector );
+  }
+
+  if ( toString.call(checkSet) === "[object Array]" ) {
+    if ( !prune ) {
+      results.push.apply( results, checkSet );
+
+    } else if ( context && context.nodeType === 1 ) {
+      for ( i = 0; checkSet[i] != null; i++ ) {
+        if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {
+          results.push( set[i] );
+        }
+      }
+
+    } else {
+      for ( i = 0; checkSet[i] != null; i++ ) {
+        if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
+          results.push( set[i] );
+        }
+      }
+    }
+
+  } else {
+    makeArray( checkSet, results );
+  }
+
+  if ( extra ) {
+    Sizzle( extra, origContext, results, seed );
+    Sizzle.uniqueSort( results );
+  }
+
+  return results;
+};
+
+Sizzle.uniqueSort = function( results ) {
+  if ( sortOrder ) {
+    hasDuplicate = baseHasDuplicate;
+    results.sort( sortOrder );
+
+    if ( hasDuplicate ) {
+      for ( var i = 1; i < results.length; i++ ) {
+        if ( results[i] === results[ i - 1 ] ) {
+          results.splice( i--, 1 );
+        }
+      }
+    }
+  }
+
+  return results;
+};
+
+Sizzle.matches = function( expr, set ) {
+  return Sizzle( expr, null, null, set );
+};
+
+Sizzle.matchesSelector = function( node, expr ) {
+  return Sizzle( expr, null, null, [node] ).length > 0;
+};
+
+Sizzle.find = function( expr, context, isXML ) {
+  var set, i, len, match, type, left;
+
+  if ( !expr ) {
+    return [];
+  }
+
+  for ( i = 0, len = Expr.order.length; i < len; i++ ) {
+    type = Expr.order[i];
+    
+    if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
+      left = match[1];
+      match.splice( 1, 1 );
+
+      if ( left.substr( left.length - 1 ) !== "\\" ) {
+        match[1] = (match[1] || "").replace( rBackslash, "" );
+        set = Expr.find[ type ]( match, context, isXML );
+
+        if ( set != null ) {
+          expr = expr.replace( Expr.match[ type ], "" );
+          break;
+        }
+      }
+    }
+  }
+
+  if ( !set ) {
+    set = typeof context.getElementsByTagName !== "undefined" ?
+      context.getElementsByTagName( "*" ) :
+      [];
+  }
+
+  return { set: set, expr: expr };
+};
+
+Sizzle.filter = function( expr, set, inplace, not ) {
+  var match, anyFound,
+    type, found, item, filter, left,
+    i, pass,
+    old = expr,
+    result = [],
+    curLoop = set,
+    isXMLFilter = set && set[0] && Sizzle.isXML( set[0] );
+
+  while ( expr && set.length ) {
+    for ( type in Expr.filter ) {
+      if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {
+        filter = Expr.filter[ type ];
+        left = match[1];
+
+        anyFound = false;
+
+        match.splice(1,1);
+
+        if ( left.substr( left.length - 1 ) === "\\" ) {
+          continue;
+        }
+
+        if ( curLoop === result ) {
+          result = [];
+        }
+
+        if ( Expr.preFilter[ type ] ) {
+          match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );
+
+          if ( !match ) {
+            anyFound = found = true;
+
+          } else if ( match === true ) {
+            continue;
+          }
+        }
+
+        if ( match ) {
+          for ( i = 0; (item = curLoop[i]) != null; i++ ) {
+            if ( item ) {
+              found = filter( item, match, i, curLoop );
+              pass = not ^ found;
+
+              if ( inplace && found != null ) {
+                if ( pass ) {
+                  anyFound = true;
+
+                } else {
+                  curLoop[i] = false;
+                }
+
+              } else if ( pass ) {
+                result.push( item );
+                anyFound = true;
+              }
+            }
+          }
+        }
+
+        if ( found !== undefined ) {
+          if ( !inplace ) {
+            curLoop = result;
+          }
+
+          expr = expr.replace( Expr.match[ type ], "" );
+
+          if ( !anyFound ) {
+            return [];
+          }
+
+          break;
+        }
+      }
+    }
+
+    // Improper expression
+    if ( expr === old ) {
+      if ( anyFound == null ) {
+        Sizzle.error( expr );
+
+      } else {
+        break;
+      }
+    }
+
+    old = expr;
+  }
+
+  return curLoop;
+};
+
+Sizzle.error = function( msg ) {
+  throw new Error( "Syntax error, unrecognized expression: " + msg );
+};
+
+/**
+ * Utility function for retreiving the text value of an array of DOM nodes
+ * @param {Array|Element} elem
+ */
+var getText = Sizzle.getText = function( elem ) {
+    var i, node,
+    nodeType = elem.nodeType,
+    ret = "";
+
+  if ( nodeType ) {
+    if ( nodeType === 1 || nodeType === 9 ) {
+      // Use textContent || innerText for elements
+      if ( typeof elem.textContent === 'string' ) {
+        return elem.textContent;
+      } else if ( typeof elem.innerText === 'string' ) {
+        // Replace IE's carriage returns
+        return elem.innerText.replace( rReturn, '' );
+      } else {
+        // Traverse its children
+        for ( elem = elem.firstChild; elem; elem = elem.nextSibling) {
+          ret += getText( elem );
+        }
+      }
+    } else if ( nodeType === 3 || nodeType === 4 ) {
+      return elem.nodeValue;
+    }
+  } else {
+
+    // If no nodeType, this is expected to be an array
+    for ( i = 0; (node = elem[i]); i++ ) {
+      // Do not traverse comment nodes
+      if ( node.nodeType !== 8 ) {
+        ret += getText( node );
+      }
+    }
+  }
+  return ret;
 };
 
-function returnFalse() {
-	return false;
-}
-function returnTrue() {
-	return true;
-}
+var Expr = Sizzle.selectors = {
+  order: [ "ID", "NAME", "TAG" ],
+
+  match: {
+    ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
+    CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
+    NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
+    ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
+    TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
+    CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
+    POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
+    PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
+  },
+
+  leftMatch: {},
+
+  attrMap: {
+    "class": "className",
+    "for": "htmlFor"
+  },
+
+  attrHandle: {
+    href: function( elem ) {
+      return elem.getAttribute( "href" );
+    },
+    type: function( elem ) {
+      return elem.getAttribute( "type" );
+    }
+  },
+
+  relative: {
+    "+": function(checkSet, part){
+      var isPartStr = typeof part === "string",
+        isTag = isPartStr && !rNonWord.test( part ),
+        isPartStrNotTag = isPartStr && !isTag;
+
+      if ( isTag ) {
+        part = part.toLowerCase();
+      }
+
+      for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
+        if ( (elem = checkSet[i]) ) {
+          while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}
+
+          checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
+            elem || false :
+            elem === part;
+        }
+      }
+
+      if ( isPartStrNotTag ) {
+        Sizzle.filter( part, checkSet, true );
+      }
+    },
+
+    ">": function( checkSet, part ) {
+      var elem,
+        isPartStr = typeof part === "string",
+        i = 0,
+        l = checkSet.length;
+
+      if ( isPartStr && !rNonWord.test( part ) ) {
+        part = part.toLowerCase();
+
+        for ( ; i < l; i++ ) {
+          elem = checkSet[i];
+
+          if ( elem ) {
+            var parent = elem.parentNode;
+            checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
+          }
+        }
+
+      } else {
+        for ( ; i < l; i++ ) {
+          elem = checkSet[i];
+
+          if ( elem ) {
+            checkSet[i] = isPartStr ?
+              elem.parentNode :
+              elem.parentNode === part;
+          }
+        }
+
+        if ( isPartStr ) {
+          Sizzle.filter( part, checkSet, true );
+        }
+      }
+    },
+
+    "": function(checkSet, part, isXML){
+      var nodeCheck,
+        doneName = done++,
+        checkFn = dirCheck;
+
+      if ( typeof part === "string" && !rNonWord.test( part ) ) {
+        part = part.toLowerCase();
+        nodeCheck = part;
+        checkFn = dirNodeCheck;
+      }
+
+      checkFn( "parentNode", part, doneName, checkSet, nodeCheck, isXML );
+    },
+
+    "~": function( checkSet, part, isXML ) {
+      var nodeCheck,
+        doneName = done++,
+        checkFn = dirCheck;
+
+      if ( typeof part === "string" && !rNonWord.test( part ) ) {
+        part = part.toLowerCase();
+        nodeCheck = part;
+        checkFn = dirNodeCheck;
+      }
+
+      checkFn( "previousSibling", part, doneName, checkSet, nodeCheck, isXML );
+    }
+  },
+
+  find: {
+    ID: function( match, context, isXML ) {
+      if ( typeof context.getElementById !== "undefined" && !isXML ) {
+        var m = context.getElementById(match[1]);
+        // Check parentNode to catch when Blackberry 4.6 returns
+        // nodes that are no longer in the document #6963
+        return m && m.parentNode ? [m] : [];
+      }
+    },
+
+    NAME: function( match, context ) {
+      if ( typeof context.getElementsByName !== "undefined" ) {
+        var ret = [],
+          results = context.getElementsByName( match[1] );
+
+        for ( var i = 0, l = results.length; i < l; i++ ) {
+          if ( results[i].getAttribute("name") === match[1] ) {
+            ret.push( results[i] );
+          }
+        }
+
+        return ret.length === 0 ? null : ret;
+      }
+    },
+
+    TAG: function( match, context ) {
+      if ( typeof context.getElementsByTagName !== "undefined" ) {
+        return context.getElementsByTagName( match[1] );
+      }
+    }
+  },
+  preFilter: {
+    CLASS: function( match, curLoop, inplace, result, not, isXML ) {
+      match = " " + match[1].replace( rBackslash, "" ) + " ";
+
+      if ( isXML ) {
+        return match;
+      }
+
+      for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
+        if ( elem ) {
+          if ( not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0) ) {
+            if ( !inplace ) {
+              result.push( elem );
+            }
+
+          } else if ( inplace ) {
+            curLoop[i] = false;
+          }
+        }
+      }
+
+      return false;
+    },
+
+    ID: function( match ) {
+      return match[1].replace( rBackslash, "" );
+    },
+
+    TAG: function( match, curLoop ) {
+      return match[1].replace( rBackslash, "" ).toLowerCase();
+    },
 
-// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
-// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
-jQuery.Event.prototype = {
-	preventDefault: function() {
-		this.isDefaultPrevented = returnTrue;
-
-		var e = this.originalEvent;
-		if ( !e ) {
-			return;
-		}
-
-		// if preventDefault exists run it on the original event
-		if ( e.preventDefault ) {
-			e.preventDefault();
-
-		// otherwise set the returnValue property of the original event to false (IE)
-		} else {
-			e.returnValue = false;
-		}
-	},
-	stopPropagation: function() {
-		this.isPropagationStopped = returnTrue;
-
-		var e = this.originalEvent;
-		if ( !e ) {
-			return;
-		}
-		// if stopPropagation exists run it on the original event
-		if ( e.stopPropagation ) {
-			e.stopPropagation();
-		}
-		// otherwise set the cancelBubble property of the original event to true (IE)
-		e.cancelBubble = true;
-	},
-	stopImmediatePropagation: function() {
-		this.isImmediatePropagationStopped = returnTrue;
-		this.stopPropagation();
-	},
-	isDefaultPrevented: returnFalse,
-	isPropagationStopped: returnFalse,
-	isImmediatePropagationStopped: returnFalse
-};
+    CHILD: function( match ) {
+      if ( match[1] === "nth" ) {
+        if ( !match[2] ) {
+          Sizzle.error( match[0] );
+        }
 
-// Create mouseenter/leave events using mouseover/out and event-time checks
-jQuery.each({
-	mouseenter: "mouseover",
-	mouseleave: "mouseout"
-}, function( orig, fix ) {
-	jQuery.event.special[ orig ] = {
-		delegateType: fix,
-		bindType: fix,
-
-		handle: function( event ) {
-			var target = this,
-				related = event.relatedTarget,
-				handleObj = event.handleObj,
-				selector = handleObj.selector,
-				ret;
-
-			// For mousenter/leave call the handler if related is outside the target.
-			// NB: No relatedTarget if the mouse left/entered the browser window
-			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
-				event.type = handleObj.origType;
-				ret = handleObj.handler.apply( this, arguments );
-				event.type = fix;
-			}
-			return ret;
-		}
-	};
-});
+        match[2] = match[2].replace(/^\+|\s*/g, '');
 
-// IE submit delegation
-if ( !jQuery.support.submitBubbles ) {
+        // parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
+        var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
+          match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
+          !/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);
 
-	jQuery.event.special.submit = {
-		setup: function() {
-			// Only need this for delegated form submit events
-			if ( jQuery.nodeName( this, "form" ) ) {
-				return false;
-			}
-
-			// Lazy-add a submit handler when a descendant form may potentially be submitted
-			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
-				// Node name check avoids a VML-related crash in IE (#9807)
-				var elem = e.target,
-					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
-				if ( form && !form._submit_attached ) {
-					jQuery.event.add( form, "submit._submit", function( event ) {
-						// If form was submitted by the user, bubble the event up the tree
-						if ( this.parentNode && !event.isTrigger ) {
-							jQuery.event.simulate( "submit", this.parentNode, event, true );
-						}
-					});
-					form._submit_attached = true;
-				}
-			});
-			// return undefined since we don't need an event listener
-		},
-
-		teardown: function() {
-			// Only need this for delegated form submit events
-			if ( jQuery.nodeName( this, "form" ) ) {
-				return false;
-			}
-
-			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
-			jQuery.event.remove( this, "._submit" );
-		}
-	};
-}
+        // calculate the numbers (first)n+(last) including if they are negative
+        match[2] = (test[1] + (test[2] || 1)) - 0;
+        match[3] = test[3] - 0;
+      }
+      else if ( match[2] ) {
+        Sizzle.error( match[0] );
+      }
 
-// IE change delegation and checkbox/radio fix
-if ( !jQuery.support.changeBubbles ) {
+      // TODO: Move to normal caching system
+      match[0] = done++;
 
-	jQuery.event.special.change = {
-
-		setup: function() {
-
-			if ( rformElems.test( this.nodeName ) ) {
-				// IE doesn't fire change on a check/radio until blur; trigger it on click
-				// after a propertychange. Eat the blur-change in special.change.handle.
-				// This still fires onchange a second time for check/radio after blur.
-				if ( this.type === "checkbox" || this.type === "radio" ) {
-					jQuery.event.add( this, "propertychange._change", function( event ) {
-						if ( event.originalEvent.propertyName === "checked" ) {
-							this._just_changed = true;
-						}
-					});
-					jQuery.event.add( this, "click._change", function( event ) {
-						if ( this._just_changed && !event.isTrigger ) {
-							this._just_changed = false;
-							jQuery.event.simulate( "change", this, event, true );
-						}
-					});
-				}
-				return false;
-			}
-			// Delegated event; lazy-add a change handler on descendant inputs
-			jQuery.event.add( this, "beforeactivate._change", function( e ) {
-				var elem = e.target;
-
-				if ( rformElems.test( elem.nodeName ) && !elem._change_attached ) {
-					jQuery.event.add( elem, "change._change", function( event ) {
-						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
-							jQuery.event.simulate( "change", this.parentNode, event, true );
-						}
-					});
-					elem._change_attached = true;
-				}
-			});
-		},
-
-		handle: function( event ) {
-			var elem = event.target;
-
-			// Swallow native change events from checkbox/radio, we already triggered them above
-			if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
-				return event.handleObj.handler.apply( this, arguments );
-			}
-		},
-
-		teardown: function() {
-			jQuery.event.remove( this, "._change" );
-
-			return rformElems.test( this.nodeName );
-		}
-	};
-}
+      return match;
+    },
 
-// Create "bubbling" focus and blur events
-if ( !jQuery.support.focusinBubbles ) {
-	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {
-
-		// Attach a single capturing handler while someone wants focusin/focusout
-		var attaches = 0,
-			handler = function( event ) {
-				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
-			};
-
-		jQuery.event.special[ fix ] = {
-			setup: function() {
-				if ( attaches++ === 0 ) {
-					document.addEventListener( orig, handler, true );
-				}
-			},
-			teardown: function() {
-				if ( --attaches === 0 ) {
-					document.removeEventListener( orig, handler, true );
-				}
-			}
-		};
-	});
-}
+    ATTR: function( match, curLoop, inplace, result, not, isXML ) {
+      var name = match[1] = match[1].replace( rBackslash, "" );
+      
+      if ( !isXML && Expr.attrMap[name] ) {
+        match[1] = Expr.attrMap[name];
+      }
 
-jQuery.fn.extend({
+      // Handle if an un-quoted value was used
+      match[4] = ( match[4] || match[5] || "" ).replace( rBackslash, "" );
 
-	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
-		var origFn, type;
-
-		// Types can be a map of types/handlers
-		if ( typeof types === "object" ) {
-			// ( types-Object, selector, data )
-			if ( typeof selector !== "string" ) {
-				// ( types-Object, data )
-				data = selector;
-				selector = undefined;
-			}
-			for ( type in types ) {
-				this.on( type, selector, data, types[ type ], one );
-			}
-			return this;
-		}
-
-		if ( data == null && fn == null ) {
-			// ( types, fn )
-			fn = selector;
-			data = selector = undefined;
-		} else if ( fn == null ) {
-			if ( typeof selector === "string" ) {
-				// ( types, selector, fn )
-				fn = data;
-				data = undefined;
-			} else {
-				// ( types, data, fn )
-				fn = data;
-				data = selector;
-				selector = undefined;
-			}
-		}
-		if ( fn === false ) {
-			fn = returnFalse;
-		} else if ( !fn ) {
-			return this;
-		}
-
-		if ( one === 1 ) {
-			origFn = fn;
-			fn = function( event ) {
-				// Can use an empty set, since event contains the info
-				jQuery().off( event );
-				return origFn.apply( this, arguments );
-			};
-			// Use same guid so caller can remove using origFn
-			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
-		}
-		return this.each( function() {
-			jQuery.event.add( this, types, fn, data, selector );
-		});
-	},
-	one: function( types, selector, data, fn ) {
-		return this.on.call( this, types, selector, data, fn, 1 );
-	},
-	off: function( types, selector, fn ) {
-		if ( types && types.preventDefault && types.handleObj ) {
-			// ( event )  dispatched jQuery.Event
-			var handleObj = types.handleObj;
-			jQuery( types.delegateTarget ).off(
-				handleObj.namespace? handleObj.type + "." + handleObj.namespace : handleObj.type,
-				handleObj.selector,
-				handleObj.handler
-			);
-			return this;
-		}
-		if ( typeof types === "object" ) {
-			// ( types-object [, selector] )
-			for ( var type in types ) {
-				this.off( type, selector, types[ type ] );
-			}
-			return this;
-		}
-		if ( selector === false || typeof selector === "function" ) {
-			// ( types [, fn] )
-			fn = selector;
-			selector = undefined;
-		}
-		if ( fn === false ) {
-			fn = returnFalse;
-		}
-		return this.each(function() {
-			jQuery.event.remove( this, types, fn, selector );
-		});
-	},
-
-	bind: function( types, data, fn ) {
-		return this.on( types, null, data, fn );
-	},
-	unbind: function( types, fn ) {
-		return this.off( types, null, fn );
-	},
-
-	live: function( types, data, fn ) {
-		jQuery( this.context ).on( types, this.selector, data, fn );
-		return this;
-	},
-	die: function( types, fn ) {
-		jQuery( this.context ).off( types, this.selector || "**", fn );
-		return this;
-	},
-
-	delegate: function( selector, types, data, fn ) {
-		return this.on( types, selector, data, fn );
-	},
-	undelegate: function( selector, types, fn ) {
-		// ( namespace ) or ( selector, types [, fn] )
-		return arguments.length == 1? this.off( selector, "**" ) : this.off( types, selector, fn );
-	},
-
-	trigger: function( type, data ) {
-		return this.each(function() {
-			jQuery.event.trigger( type, data, this );
-		});
-	},
-	triggerHandler: function( type, data ) {
-		if ( this[0] ) {
-			return jQuery.event.trigger( type, data, this[0], true );
-		}
-	},
-
-	toggle: function( fn ) {
-		// Save reference to arguments for access in closure
-		var args = arguments,
-			guid = fn.guid || jQuery.guid++,
-			i = 0,
-			toggler = function( event ) {
-				// Figure out which function to execute
-				var lastToggle = ( jQuery._data( this, "lastToggle" + fn.guid ) || 0 ) % i;
-				jQuery._data( this, "lastToggle" + fn.guid, lastToggle + 1 );
-
-				// Make sure that clicks stop
-				event.preventDefault();
-
-				// and execute the function
-				return args[ lastToggle ].apply( this, arguments ) || false;
-			};
-
-		// link all the functions, so any of them can unbind this click handler
-		toggler.guid = guid;
-		while ( i < args.length ) {
-			args[ i++ ].guid = guid;
-		}
-
-		return this.click( toggler );
-	},
-
-	hover: function( fnOver, fnOut ) {
-		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
-	}
-});
+      if ( match[2] === "~=" ) {
+        match[4] = " " + match[4] + " ";
+      }
 
-jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
-	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
-	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {
-
-	// Handle event binding
-	jQuery.fn[ name ] = function( data, fn ) {
-		if ( fn == null ) {
-			fn = data;
-			data = null;
-		}
-
-		return arguments.length > 0 ?
-			this.on( name, null, data, fn ) :
-			this.trigger( name );
-	};
-
-	if ( jQuery.attrFn ) {
-		jQuery.attrFn[ name ] = true;
-	}
-
-	if ( rkeyEvent.test( name ) ) {
-		jQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;
-	}
-
-	if ( rmouseEvent.test( name ) ) {
-		jQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;
-	}
-});
+      return match;
+    },
 
+    PSEUDO: function( match, curLoop, inplace, result, not ) {
+      if ( match[1] === "not" ) {
+        // If we're dealing with a complex expression, or a simple one
+        if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
+          match[3] = Sizzle(match[3], null, null, curLoop);
 
+        } else {
+          var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);
 
-/*!
- * Sizzle CSS Selector Engine
- *  Copyright 2011, The Dojo Foundation
- *  Released under the MIT, BSD, and GPL Licenses.
- *  More information: http://sizzlejs.com/
- */
-(function(){
+          if ( !inplace ) {
+            result.push.apply( result, ret );
+          }
 
-var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
-	expando = "sizcache" + (Math.random() + '').replace('.', ''),
-	done = 0,
-	toString = Object.prototype.toString,
-	hasDuplicate = false,
-	baseHasDuplicate = true,
-	rBackslash = /\\/g,
-	rReturn = /\r\n/g,
-	rNonWord = /\W/;
+          return false;
+        }
 
-// Here we check if the JavaScript engine is using some sort of
-// optimization where it does not always call our comparision
-// function. If that is the case, discard the hasDuplicate value.
-//   Thus far that includes Google Chrome.
-[0, 0].sort(function() {
-	baseHasDuplicate = false;
-	return 0;
-});
+      } else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
+        return true;
+      }
+      
+      return match;
+    },
 
-var Sizzle = function( selector, context, results, seed ) {
-	results = results || [];
-	context = context || document;
-
-	var origContext = context;
-
-	if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
-		return [];
-	}
-	
-	if ( !selector || typeof selector !== "string" ) {
-		return results;
-	}
-
-	var m, set, checkSet, extra, ret, cur, pop, i,
-		prune = true,
-		contextXML = Sizzle.isXML( context ),
-		parts = [],
-		soFar = selector;
-	
-	// Reset the position of the chunker regexp (start from head)
-	do {
-		chunker.exec( "" );
-		m = chunker.exec( soFar );
-
-		if ( m ) {
-			soFar = m[3];
-		
-			parts.push( m[1] );
-		
-			if ( m[2] ) {
-				extra = m[3];
-				break;
-			}
-		}
-	} while ( m );
-
-	if ( parts.length > 1 && origPOS.exec( selector ) ) {
-
-		if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
-			set = posProcess( parts[0] + parts[1], context, seed );
-
-		} else {
-			set = Expr.relative[ parts[0] ] ?
-				[ context ] :
-				Sizzle( parts.shift(), context );
-
-			while ( parts.length ) {
-				selector = parts.shift();
-
-				if ( Expr.relative[ selector ] ) {
-					selector += parts.shift();
-				}
-				
-				set = posProcess( selector, set, seed );
-			}
-		}
-
-	} else {
-		// Take a shortcut and set the context if the root selector is an ID
-		// (but not if it'll be faster if the inner selector is an ID)
-		if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
-				Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {
-
-			ret = Sizzle.find( parts.shift(), context, contextXML );
-			context = ret.expr ?
-				Sizzle.filter( ret.expr, ret.set )[0] :
-				ret.set[0];
-		}
-
-		if ( context ) {
-			ret = seed ?
-				{ expr: parts.pop(), set: makeArray(seed) } :
-				Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );
-
-			set = ret.expr ?
-				Sizzle.filter( ret.expr, ret.set ) :
-				ret.set;
-
-			if ( parts.length > 0 ) {
-				checkSet = makeArray( set );
-
-			} else {
-				prune = false;
-			}
-
-			while ( parts.length ) {
-				cur = parts.pop();
-				pop = cur;
-
-				if ( !Expr.relative[ cur ] ) {
-					cur = "";
-				} else {
-					pop = parts.pop();
-				}
-
-				if ( pop == null ) {
-					pop = context;
-				}
-
-				Expr.relative[ cur ]( checkSet, pop, contextXML );
-			}
-
-		} else {
-			checkSet = parts = [];
-		}
-	}
-
-	if ( !checkSet ) {
-		checkSet = set;
-	}
-
-	if ( !checkSet ) {
-		Sizzle.error( cur || selector );
-	}
-
-	if ( toString.call(checkSet) === "[object Array]" ) {
-		if ( !prune ) {
-			results.push.apply( results, checkSet );
-
-		} else if ( context && context.nodeType === 1 ) {
-			for ( i = 0; checkSet[i] != null; i++ ) {
-				if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {
-					results.push( set[i] );
-				}
-			}
-
-		} else {
-			for ( i = 0; checkSet[i] != null; i++ ) {
-				if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
-					results.push( set[i] );
-				}
-			}
-		}
-
-	} else {
-		makeArray( checkSet, results );
-	}
-
-	if ( extra ) {
-		Sizzle( extra, origContext, results, seed );
-		Sizzle.uniqueSort( results );
-	}
-
-	return results;
-};
+    POS: function( match ) {
+      match.unshift( true );
 
-Sizzle.uniqueSort = function( results ) {
-	if ( sortOrder ) {
-		hasDuplicate = baseHasDuplicate;
-		results.sort( sortOrder );
-
-		if ( hasDuplicate ) {
-			for ( var i = 1; i < results.length; i++ ) {
-				if ( results[i] === results[ i - 1 ] ) {
-					results.splice( i--, 1 );
-				}
-			}
-		}
-	}
-
-	return results;
-};
+      return match;
+    }
+  },
+  
+  filters: {
+    enabled: function( elem ) {
+      return elem.disabled === false && elem.type !== "hidden";
+    },
+
+    disabled: function( elem ) {
+      return elem.disabled === true;
+    },
+
+    checked: function( elem ) {
+      return elem.checked === true;
+    },
+    
+    selected: function( elem ) {
+      // Accessing this property makes selected-by-default
+      // options in Safari work properly
+      if ( elem.parentNode ) {
+        elem.parentNode.selectedIndex;
+      }
+      
+      return elem.selected === true;
+    },
+
+    parent: function( elem ) {
+      return !!elem.firstChild;
+    },
+
+    empty: function( elem ) {
+      return !elem.firstChild;
+    },
+
+    has: function( elem, i, match ) {
+      return !!Sizzle( match[3], elem ).length;
+    },
+
+    header: function( elem ) {
+      return (/h\d/i).test( elem.nodeName );
+    },
+
+    text: function( elem ) {
+      var attr = elem.getAttribute( "type" ), type = elem.type;
+      // IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc) 
+      // use getAttribute instead to test this case
+      return elem.nodeName.toLowerCase() === "input" && "text" === type && ( attr === type || attr === null );
+    },
+
+    radio: function( elem ) {
+      return elem.nodeName.toLowerCase() === "input" && "radio" === elem.type;
+    },
+
+    checkbox: function( elem ) {
+      return elem.nodeName.toLowerCase() === "input" && "checkbox" === elem.type;
+    },
+
+    file: function( elem ) {
+      return elem.nodeName.toLowerCase() === "input" && "file" === elem.type;
+    },
+
+    password: function( elem ) {
+      return elem.nodeName.toLowerCase() === "input" && "password" === elem.type;
+    },
+
+    submit: function( elem ) {
+      var name = elem.nodeName.toLowerCase();
+      return (name === "input" || name === "button") && "submit" === elem.type;
+    },
+
+    image: function( elem ) {
+      return elem.nodeName.toLowerCase() === "input" && "image" === elem.type;
+    },
+
+    reset: function( elem ) {
+      var name = elem.nodeName.toLowerCase();
+      return (name === "input" || name === "button") && "reset" === elem.type;
+    },
+
+    button: function( elem ) {
+      var name = elem.nodeName.toLowerCase();
+      return name === "input" && "button" === elem.type || name === "button";
+    },
+
+    input: function( elem ) {
+      return (/input|select|textarea|button/i).test( elem.nodeName );
+    },
+
+    focus: function( elem ) {
+      return elem === elem.ownerDocument.activeElement;
+    }
+  },
+  setFilters: {
+    first: function( elem, i ) {
+      return i === 0;
+    },
+
+    last: function( elem, i, match, array ) {
+      return i === array.length - 1;
+    },
+
+    even: function( elem, i ) {
+      return i % 2 === 0;
+    },
+
+    odd: function( elem, i ) {
+      return i % 2 === 1;
+    },
+
+    lt: function( elem, i, match ) {
+      return i < match[3] - 0;
+    },
+
+    gt: function( elem, i, match ) {
+      return i > match[3] - 0;
+    },
+
+    nth: function( elem, i, match ) {
+      return match[3] - 0 === i;
+    },
+
+    eq: function( elem, i, match ) {
+      return match[3] - 0 === i;
+    }
+  },
+  filter: {
+    PSEUDO: function( elem, match, i, array ) {
+      var name = match[1],
+        filter = Expr.filters[ name ];
 
-Sizzle.matches = function( expr, set ) {
-	return Sizzle( expr, null, null, set );
-};
+      if ( filter ) {
+        return filter( elem, i, match, array );
 
-Sizzle.matchesSelector = function( node, expr ) {
-	return Sizzle( expr, null, null, [node] ).length > 0;
-};
+      } else if ( name === "contains" ) {
+        return (elem.textContent || elem.innerText || getText([ elem ]) || "").indexOf(match[3]) >= 0;
 
-Sizzle.find = function( expr, context, isXML ) {
-	var set, i, len, match, type, left;
-
-	if ( !expr ) {
-		return [];
-	}
-
-	for ( i = 0, len = Expr.order.length; i < len; i++ ) {
-		type = Expr.order[i];
-		
-		if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
-			left = match[1];
-			match.splice( 1, 1 );
-
-			if ( left.substr( left.length - 1 ) !== "\\" ) {
-				match[1] = (match[1] || "").replace( rBackslash, "" );
-				set = Expr.find[ type ]( match, context, isXML );
-
-				if ( set != null ) {
-					expr = expr.replace( Expr.match[ type ], "" );
-					break;
-				}
-			}
-		}
-	}
-
-	if ( !set ) {
-		set = typeof context.getElementsByTagName !== "undefined" ?
-			context.getElementsByTagName( "*" ) :
-			[];
-	}
-
-	return { set: set, expr: expr };
-};
+      } else if ( name === "not" ) {
+        var not = match[3];
 
-Sizzle.filter = function( expr, set, inplace, not ) {
-	var match, anyFound,
-		type, found, item, filter, left,
-		i, pass,
-		old = expr,
-		result = [],
-		curLoop = set,
-		isXMLFilter = set && set[0] && Sizzle.isXML( set[0] );
-
-	while ( expr && set.length ) {
-		for ( type in Expr.filter ) {
-			if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {
-				filter = Expr.filter[ type ];
-				left = match[1];
-
-				anyFound = false;
-
-				match.splice(1,1);
-
-				if ( left.substr( left.length - 1 ) === "\\" ) {
-					continue;
-				}
-
-				if ( curLoop === result ) {
-					result = [];
-				}
-
-				if ( Expr.preFilter[ type ] ) {
-					match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );
-
-					if ( !match ) {
-						anyFound = found = true;
-
-					} else if ( match === true ) {
-						continue;
-					}
-				}
-
-				if ( match ) {
-					for ( i = 0; (item = curLoop[i]) != null; i++ ) {
-						if ( item ) {
-							found = filter( item, match, i, curLoop );
-							pass = not ^ found;
-
-							if ( inplace && found != null ) {
-								if ( pass ) {
-									anyFound = true;
-
-								} else {
-									curLoop[i] = false;
-								}
-
-							} else if ( pass ) {
-								result.push( item );
-								anyFound = true;
-							}
-						}
-					}
-				}
-
-				if ( found !== undefined ) {
-					if ( !inplace ) {
-						curLoop = result;
-					}
-
-					expr = expr.replace( Expr.match[ type ], "" );
-
-					if ( !anyFound ) {
-						return [];
-					}
-
-					break;
-				}
-			}
-		}
-
-		// Improper expression
-		if ( expr === old ) {
-			if ( anyFound == null ) {
-				Sizzle.error( expr );
-
-			} else {
-				break;
-			}
-		}
-
-		old = expr;
-	}
-
-	return curLoop;
-};
+        for ( var j = 0, l = not.length; j < l; j++ ) {
+          if ( not[j] === elem ) {
+            return false;
+          }
+        }
 
-Sizzle.error = function( msg ) {
-	throw new Error( "Syntax error, unrecognized expression: " + msg );
-};
+        return true;
+
+      } else {
+        Sizzle.error( name );
+      }
+    },
+
+    CHILD: function( elem, match ) {
+      var first, last,
+        doneName, parent, cache,
+        count, diff,
+        type = match[1],
+        node = elem;
+
+      switch ( type ) {
+        case "only":
+        case "first":
+          while ( (node = node.previousSibling) )   {
+            if ( node.nodeType === 1 ) { 
+              return false; 
+            }
+          }
 
-/**
- * Utility function for retreiving the text value of an array of DOM nodes
- * @param {Array|Element} elem
- */
-var getText = Sizzle.getText = function( elem ) {
-    var i, node,
-		nodeType = elem.nodeType,
-		ret = "";
-
-	if ( nodeType ) {
-		if ( nodeType === 1 || nodeType === 9 ) {
-			// Use textContent || innerText for elements
-			if ( typeof elem.textContent === 'string' ) {
-				return elem.textContent;
-			} else if ( typeof elem.innerText === 'string' ) {
-				// Replace IE's carriage returns
-				return elem.innerText.replace( rReturn, '' );
-			} else {
-				// Traverse its children
-				for ( elem = elem.firstChild; elem; elem = elem.nextSibling) {
-					ret += getText( elem );
-				}
-			}
-		} else if ( nodeType === 3 || nodeType === 4 ) {
-			return elem.nodeValue;
-		}
-	} else {
-
-		// If no nodeType, this is expected to be an array
-		for ( i = 0; (node = elem[i]); i++ ) {
-			// Do not traverse comment nodes
-			if ( node.nodeType !== 8 ) {
-				ret += getText( node );
-			}
-		}
-	}
-	return ret;
-};
+          if ( type === "first" ) { 
+            return true; 
+          }
 
-var Expr = Sizzle.selectors = {
-	order: [ "ID", "NAME", "TAG" ],
-
-	match: {
-		ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
-		CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
-		NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
-		ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
-		TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
-		CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
-		POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
-		PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
-	},
-
-	leftMatch: {},
-
-	attrMap: {
-		"class": "className",
-		"for": "htmlFor"
-	},
-
-	attrHandle: {
-		href: function( elem ) {
-			return elem.getAttribute( "href" );
-		},
-		type: function( elem ) {
-			return elem.getAttribute( "type" );
-		}
-	},
-
-	relative: {
-		"+": function(checkSet, part){
-			var isPartStr = typeof part === "string",
-				isTag = isPartStr && !rNonWord.test( part ),
-				isPartStrNotTag = isPartStr && !isTag;
-
-			if ( isTag ) {
-				part = part.toLowerCase();
-			}
-
-			for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
-				if ( (elem = checkSet[i]) ) {
-					while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}
-
-					checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
-						elem || false :
-						elem === part;
-				}
-			}
-
-			if ( isPartStrNotTag ) {
-				Sizzle.filter( part, checkSet, true );
-			}
-		},
-
-		">": function( checkSet, part ) {
-			var elem,
-				isPartStr = typeof part === "string",
-				i = 0,
-				l = checkSet.length;
-
-			if ( isPartStr && !rNonWord.test( part ) ) {
-				part = part.toLowerCase();
-
-				for ( ; i < l; i++ ) {
-					elem = checkSet[i];
-
-					if ( elem ) {
-						var parent = elem.parentNode;
-						checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
-					}
-				}
-
-			} else {
-				for ( ; i < l; i++ ) {
-					elem = checkSet[i];
-
-					if ( elem ) {
-						checkSet[i] = isPartStr ?
-							elem.parentNode :
-							elem.parentNode === part;
-					}
-				}
-
-				if ( isPartStr ) {
-					Sizzle.filter( part, checkSet, true );
-				}
-			}
-		},
-
-		"": function(checkSet, part, isXML){
-			var nodeCheck,
-				doneName = done++,
-				checkFn = dirCheck;
-
-			if ( typeof part === "string" && !rNonWord.test( part ) ) {
-				part = part.toLowerCase();
-				nodeCheck = part;
-				checkFn = dirNodeCheck;
-			}
-
-			checkFn( "parentNode", part, doneName, checkSet, nodeCheck, isXML );
-		},
-
-		"~": function( checkSet, part, isXML ) {
-			var nodeCheck,
-				doneName = done++,
-				checkFn = dirCheck;
-
-			if ( typeof part === "string" && !rNonWord.test( part ) ) {
-				part = part.toLowerCase();
-				nodeCheck = part;
-				checkFn = dirNodeCheck;
-			}
-
-			checkFn( "previousSibling", part, doneName, checkSet, nodeCheck, isXML );
-		}
-	},
-
-	find: {
-		ID: function( match, context, isXML ) {
-			if ( typeof context.getElementById !== "undefined" && !isXML ) {
-				var m = context.getElementById(match[1]);
-				// Check parentNode to catch when Blackberry 4.6 returns
-				// nodes that are no longer in the document #6963
-				return m && m.parentNode ? [m] : [];
-			}
-		},
-
-		NAME: function( match, context ) {
-			if ( typeof context.getElementsByName !== "undefined" ) {
-				var ret = [],
-					results = context.getElementsByName( match[1] );
-
-				for ( var i = 0, l = results.length; i < l; i++ ) {
-					if ( results[i].getAttribute("name") === match[1] ) {
-						ret.push( results[i] );
-					}
-				}
-
-				return ret.length === 0 ? null : ret;
-			}
-		},
-
-		TAG: function( match, context ) {
-			if ( typeof context.getElementsByTagName !== "undefined" ) {
-				return context.getElementsByTagName( match[1] );
-			}
-		}
-	},
-	preFilter: {
-		CLASS: function( match, curLoop, inplace, result, not, isXML ) {
-			match = " " + match[1].replace( rBackslash, "" ) + " ";
-
-			if ( isXML ) {
-				return match;
-			}
-
-			for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
-				if ( elem ) {
-					if ( not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0) ) {
-						if ( !inplace ) {
-							result.push( elem );
-						}
-
-					} else if ( inplace ) {
-						curLoop[i] = false;
-					}
-				}
-			}
-
-			return false;
-		},
-
-		ID: function( match ) {
-			return match[1].replace( rBackslash, "" );
-		},
-
-		TAG: function( match, curLoop ) {
-			return match[1].replace( rBackslash, "" ).toLowerCase();
-		},
-
-		CHILD: function( match ) {
-			if ( match[1] === "nth" ) {
-				if ( !match[2] ) {
-					Sizzle.error( match[0] );
-				}
-
-				match[2] = match[2].replace(/^\+|\s*/g, '');
-
-				// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
-				var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
-					match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
-					!/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);
-
-				// calculate the numbers (first)n+(last) including if they are negative
-				match[2] = (test[1] + (test[2] || 1)) - 0;
-				match[3] = test[3] - 0;
-			}
-			else if ( match[2] ) {
-				Sizzle.error( match[0] );
-			}
-
-			// TODO: Move to normal caching system
-			match[0] = done++;
-
-			return match;
-		},
-
-		ATTR: function( match, curLoop, inplace, result, not, isXML ) {
-			var name = match[1] = match[1].replace( rBackslash, "" );
-			
-			if ( !isXML && Expr.attrMap[name] ) {
-				match[1] = Expr.attrMap[name];
-			}
-
-			// Handle if an un-quoted value was used
-			match[4] = ( match[4] || match[5] || "" ).replace( rBackslash, "" );
-
-			if ( match[2] === "~=" ) {
-				match[4] = " " + match[4] + " ";
-			}
-
-			return match;
-		},
-
-		PSEUDO: function( match, curLoop, inplace, result, not ) {
-			if ( match[1] === "not" ) {
-				// If we're dealing with a complex expression, or a simple one
-				if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
-					match[3] = Sizzle(match[3], null, null, curLoop);
-
-				} else {
-					var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);
-
-					if ( !inplace ) {
-						result.push.apply( result, ret );
-					}
-
-					return false;
-				}
-
-			} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
-				return true;
-			}
-			
-			return match;
-		},
-
-		POS: function( match ) {
-			match.unshift( true );
-
-			return match;
-		}
-	},
-	
-	filters: {
-		enabled: function( elem ) {
-			return elem.disabled === false && elem.type !== "hidden";
-		},
-
-		disabled: function( elem ) {
-			return elem.disabled === true;
-		},
-
-		checked: function( elem ) {
-			return elem.checked === true;
-		},
-		
-		selected: function( elem ) {
-			// Accessing this property makes selected-by-default
-			// options in Safari work properly
-			if ( elem.parentNode ) {
-				elem.parentNode.selectedIndex;
-			}
-			
-			return elem.selected === true;
-		},
-
-		parent: function( elem ) {
-			return !!elem.firstChild;
-		},
-
-		empty: function( elem ) {
-			return !elem.firstChild;
-		},
-
-		has: function( elem, i, match ) {
-			return !!Sizzle( match[3], elem ).length;
-		},
-
-		header: function( elem ) {
-			return (/h\d/i).test( elem.nodeName );
-		},
-
-		text: function( elem ) {
-			var attr = elem.getAttribute( "type" ), type = elem.type;
-			// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc) 
-			// use getAttribute instead to test this case
-			return elem.nodeName.toLowerCase() === "input" && "text" === type && ( attr === type || attr === null );
-		},
-
-		radio: function( elem ) {
-			return elem.nodeName.toLowerCase() === "input" && "radio" === elem.type;
-		},
-
-		checkbox: function( elem ) {
-			return elem.nodeName.toLowerCase() === "input" && "checkbox" === elem.type;
-		},
-
-		file: function( elem ) {
-			return elem.nodeName.toLowerCase() === "input" && "file" === elem.type;
-		},
-
-		password: function( elem ) {
-			return elem.nodeName.toLowerCase() === "input" && "password" === elem.type;
-		},
-
-		submit: function( elem ) {
-			var name = elem.nodeName.toLowerCase();
-			return (name === "input" || name === "button") && "submit" === elem.type;
-		},
-
-		image: function( elem ) {
-			return elem.nodeName.toLowerCase() === "input" && "image" === elem.type;
-		},
-
-		reset: function( elem ) {
-			var name = elem.nodeName.toLowerCase();
-			return (name === "input" || name === "button") && "reset" === elem.type;
-		},
-
-		button: function( elem ) {
-			var name = elem.nodeName.toLowerCase();
-			return name === "input" && "button" === elem.type || name === "button";
-		},
-
-		input: function( elem ) {
-			return (/input|select|textarea|button/i).test( elem.nodeName );
-		},
-
-		focus: function( elem ) {
-			return elem === elem.ownerDocument.activeElement;
-		}
-	},
-	setFilters: {
-		first: function( elem, i ) {
-			return i === 0;
-		},
-
-		last: function( elem, i, match, array ) {
-			return i === array.length - 1;
-		},
-
-		even: function( elem, i ) {
-			return i % 2 === 0;
-		},
-
-		odd: function( elem, i ) {
-			return i % 2 === 1;
-		},
-
-		lt: function( elem, i, match ) {
-			return i < match[3] - 0;
-		},
-
-		gt: function( elem, i, match ) {
-			return i > match[3] - 0;
-		},
-
-		nth: function( elem, i, match ) {
-			return match[3] - 0 === i;
-		},
-
-		eq: function( elem, i, match ) {
-			return match[3] - 0 === i;
-		}
-	},
-	filter: {
-		PSEUDO: function( elem, match, i, array ) {
-			var name = match[1],
-				filter = Expr.filters[ name ];
-
-			if ( filter ) {
-				return filter( elem, i, match, array );
-
-			} else if ( name === "contains" ) {
-				return (elem.textContent || elem.innerText || getText([ elem ]) || "").indexOf(match[3]) >= 0;
-
-			} else if ( name === "not" ) {
-				var not = match[3];
-
-				for ( var j = 0, l = not.length; j < l; j++ ) {
-					if ( not[j] === elem ) {
-						return false;
-					}
-				}
-
-				return true;
-
-			} else {
-				Sizzle.error( name );
-			}
-		},
-
-		CHILD: function( elem, match ) {
-			var first, last,
-				doneName, parent, cache,
-				count, diff,
-				type = match[1],
-				node = elem;
-
-			switch ( type ) {
-				case "only":
-				case "first":
-					while ( (node = node.previousSibling) )	 {
-						if ( node.nodeType === 1 ) { 
-							return false; 
-						}
-					}
-
-					if ( type === "first" ) { 
-						return true; 
-					}
-
-					node = elem;
-
-				case "last":
-					while ( (node = node.nextSibling) )	 {
-						if ( node.nodeType === 1 ) { 
-							return false; 
-						}
-					}
-
-					return true;
-
-				case "nth":
-					first = match[2];
-					last = match[3];
-
-					if ( first === 1 && last === 0 ) {
-						return true;
-					}
-					
-					doneName = match[0];
-					parent = elem.parentNode;
-	
-					if ( parent && (parent[ expando ] !== doneName || !elem.nodeIndex) ) {
-						count = 0;
-						
-						for ( node = parent.firstChild; node; node = node.nextSibling ) {
-							if ( node.nodeType === 1 ) {
-								node.nodeIndex = ++count;
-							}
-						} 
-
-						parent[ expando ] = doneName;
-					}
-					
-					diff = elem.nodeIndex - last;
-
-					if ( first === 0 ) {
-						return diff === 0;
-
-					} else {
-						return ( diff % first === 0 && diff / first >= 0 );
-					}
-			}
-		},
-
-		ID: function( elem, match ) {
-			return elem.nodeType === 1 && elem.getAttribute("id") === match;
-		},
-
-		TAG: function( elem, match ) {
-			return (match === "*" && elem.nodeType === 1) || !!elem.nodeName && elem.nodeName.toLowerCase() === match;
-		},
-		
-		CLASS: function( elem, match ) {
-			return (" " + (elem.className || elem.getAttribute("class")) + " ")
-				.indexOf( match ) > -1;
-		},
-
-		ATTR: function( elem, match ) {
-			var name = match[1],
-				result = Sizzle.attr ?
-					Sizzle.attr( elem, name ) :
-					Expr.attrHandle[ name ] ?
-					Expr.attrHandle[ name ]( elem ) :
-					elem[ name ] != null ?
-						elem[ name ] :
-						elem.getAttribute( name ),
-				value = result + "",
-				type = match[2],
-				check = match[4];
-
-			return result == null ?
-				type === "!=" :
-				!type && Sizzle.attr ?
-				result != null :
-				type === "=" ?
-				value === check :
-				type === "*=" ?
-				value.indexOf(check) >= 0 :
-				type === "~=" ?
-				(" " + value + " ").indexOf(check) >= 0 :
-				!check ?
-				value && result !== false :
-				type === "!=" ?
-				value !== check :
-				type === "^=" ?
-				value.indexOf(check) === 0 :
-				type === "$=" ?
-				value.substr(value.length - check.length) === check :
-				type === "|=" ?
-				value === check || value.substr(0, check.length + 1) === check + "-" :
-				false;
-		},
-
-		POS: function( elem, match, i, array ) {
-			var name = match[2],
-				filter = Expr.setFilters[ name ];
-
-			if ( filter ) {
-				return filter( elem, i, match, array );
-			}
-		}
-	}
+          node = elem;
+
+        case "last":
+          while ( (node = node.nextSibling) )   {
+            if ( node.nodeType === 1 ) { 
+              return false; 
+            }
+          }
+
+          return true;
+
+        case "nth":
+          first = match[2];
+          last = match[3];
+
+          if ( first === 1 && last === 0 ) {
+            return true;
+          }
+          
+          doneName = match[0];
+          parent = elem.parentNode;
+  
+          if ( parent && (parent[ expando ] !== doneName || !elem.nodeIndex) ) {
+            count = 0;
+            
+            for ( node = parent.firstChild; node; node = node.nextSibling ) {
+              if ( node.nodeType === 1 ) {
+                node.nodeIndex = ++count;
+              }
+            } 
+
+            parent[ expando ] = doneName;
+          }
+          
+          diff = elem.nodeIndex - last;
+
+          if ( first === 0 ) {
+            return diff === 0;
+
+          } else {
+            return ( diff % first === 0 && diff / first >= 0 );
+          }
+      }
+    },
+
+    ID: function( elem, match ) {
+      return elem.nodeType === 1 && elem.getAttribute("id") === match;
+    },
+
+    TAG: function( elem, match ) {
+      return (match === "*" && elem.nodeType === 1) || !!elem.nodeName && elem.nodeName.toLowerCase() === match;
+    },
+    
+    CLASS: function( elem, match ) {
+      return (" " + (elem.className || elem.getAttribute("class")) + " ")
+        .indexOf( match ) > -1;
+    },
+
+    ATTR: function( elem, match ) {
+      var name = match[1],
+        result = Sizzle.attr ?
+          Sizzle.attr( elem, name ) :
+          Expr.attrHandle[ name ] ?
+          Expr.attrHandle[ name ]( elem ) :
+          elem[ name ] != null ?
+            elem[ name ] :
+            elem.getAttribute( name ),
+        value = result + "",
+        type = match[2],
+        check = match[4];
+
+      return result == null ?
+        type === "!=" :
+        !type && Sizzle.attr ?
+        result != null :
+        type === "=" ?
+        value === check :
+        type === "*=" ?
+        value.indexOf(check) >= 0 :
+        type === "~=" ?
+        (" " + value + " ").indexOf(check) >= 0 :
+        !check ?
+        value && result !== false :
+        type === "!=" ?
+        value !== check :
+        type === "^=" ?
+        value.indexOf(check) === 0 :
+        type === "$=" ?
+        value.substr(value.length - check.length) === check :
+        type === "|=" ?
+        value === check || value.substr(0, check.length + 1) === check + "-" :
+        false;
+    },
+
+    POS: function( elem, match, i, array ) {
+      var name = match[2],
+        filter = Expr.setFilters[ name ];
+
+      if ( filter ) {
+        return filter( elem, i, match, array );
+      }
+    }
+  }
 };
 
 var origPOS = Expr.match.POS,
-	fescape = function(all, num){
-		return "\\" + (num - 0 + 1);
-	};
+  fescape = function(all, num){
+    return "\\" + (num - 0 + 1);
+  };
 
 for ( var type in Expr.match ) {
-	Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );
-	Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );
+  Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );
+  Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );
 }
 
 var makeArray = function( array, results ) {
-	array = Array.prototype.slice.call( array, 0 );
-
-	if ( results ) {
-		results.push.apply( results, array );
-		return results;
-	}
-	
-	return array;
+  array = Array.prototype.slice.call( array, 0 );
+
+  if ( results ) {
+    results.push.apply( results, array );
+    return results;
+  }
+  
+  return array;
 };
 
 // Perform a simple check to determine if the browser is capable of
@@ -6854,515 +6854,515 @@ var makeArray = function( array, results ) {
 // Also verifies that the returned array holds DOM nodes
 // (which is not the case in the Blackberry browser)
 try {
-	Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;
+  Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;
 
 // Provide a fallback method if it does not work
 } catch( e ) {
-	makeArray = function( array, results ) {
-		var i = 0,
-			ret = results || [];
-
-		if ( toString.call(array) === "[object Array]" ) {
-			Array.prototype.push.apply( ret, array );
-
-		} else {
-			if ( typeof array.length === "number" ) {
-				for ( var l = array.length; i < l; i++ ) {
-					ret.push( array[i] );
-				}
-
-			} else {
-				for ( ; array[i]; i++ ) {
-					ret.push( array[i] );
-				}
-			}
-		}
-
-		return ret;
-	};
+  makeArray = function( array, results ) {
+    var i = 0,
+      ret = results || [];
+
+    if ( toString.call(array) === "[object Array]" ) {
+      Array.prototype.push.apply( ret, array );
+
+    } else {
+      if ( typeof array.length === "number" ) {
+        for ( var l = array.length; i < l; i++ ) {
+          ret.push( array[i] );
+        }
+
+      } else {
+        for ( ; array[i]; i++ ) {
+          ret.push( array[i] );
+        }
+      }
+    }
+
+    return ret;
+  };
 }
 
 var sortOrder, siblingCheck;
 
 if ( document.documentElement.compareDocumentPosition ) {
-	sortOrder = function( a, b ) {
-		if ( a === b ) {
-			hasDuplicate = true;
-			return 0;
-		}
+  sortOrder = function( a, b ) {
+    if ( a === b ) {
+      hasDuplicate = true;
+      return 0;
+    }
 
-		if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
-			return a.compareDocumentPosition ? -1 : 1;
-		}
+    if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
+      return a.compareDocumentPosition ? -1 : 1;
+    }
 
-		return a.compareDocumentPosition(b) & 4 ? -1 : 1;
-	};
+    return a.compareDocumentPosition(b) & 4 ? -1 : 1;
+  };
 
 } else {
-	sortOrder = function( a, b ) {
-		// The nodes are identical, we can exit early
-		if ( a === b ) {
-			hasDuplicate = true;
-			return 0;
-
-		// Fallback to using sourceIndex (in IE) if it's available on both nodes
-		} else if ( a.sourceIndex && b.sourceIndex ) {
-			return a.sourceIndex - b.sourceIndex;
-		}
-
-		var al, bl,
-			ap = [],
-			bp = [],
-			aup = a.parentNode,
-			bup = b.parentNode,
-			cur = aup;
-
-		// If the nodes are siblings (or identical) we can do a quick check
-		if ( aup === bup ) {
-			return siblingCheck( a, b );
-
-		// If no parents were found then the nodes are disconnected
-		} else if ( !aup ) {
-			return -1;
-
-		} else if ( !bup ) {
-			return 1;
-		}
-
-		// Otherwise they're somewhere else in the tree so we need
-		// to build up a full list of the parentNodes for comparison
-		while ( cur ) {
-			ap.unshift( cur );
-			cur = cur.parentNode;
-		}
-
-		cur = bup;
-
-		while ( cur ) {
-			bp.unshift( cur );
-			cur = cur.parentNode;
-		}
-
-		al = ap.length;
-		bl = bp.length;
-
-		// Start walking down the tree looking for a discrepancy
-		for ( var i = 0; i < al && i < bl; i++ ) {
-			if ( ap[i] !== bp[i] ) {
-				return siblingCheck( ap[i], bp[i] );
-			}
-		}
-
-		// We ended someplace up the tree so do a sibling check
-		return i === al ?
-			siblingCheck( a, bp[i], -1 ) :
-			siblingCheck( ap[i], b, 1 );
-	};
-
-	siblingCheck = function( a, b, ret ) {
-		if ( a === b ) {
-			return ret;
-		}
-
-		var cur = a.nextSibling;
-
-		while ( cur ) {
-			if ( cur === b ) {
-				return -1;
-			}
-
-			cur = cur.nextSibling;
-		}
-
-		return 1;
-	};
+  sortOrder = function( a, b ) {
+    // The nodes are identical, we can exit early
+    if ( a === b ) {
+      hasDuplicate = true;
+      return 0;
+
+    // Fallback to using sourceIndex (in IE) if it's available on both nodes
+    } else if ( a.sourceIndex && b.sourceIndex ) {
+      return a.sourceIndex - b.sourceIndex;
+    }
+
+    var al, bl,
+      ap = [],
+      bp = [],
+      aup = a.parentNode,
+      bup = b.parentNode,
+      cur = aup;
+
+    // If the nodes are siblings (or identical) we can do a quick check
+    if ( aup === bup ) {
+      return siblingCheck( a, b );
+
+    // If no parents were found then the nodes are disconnected
+    } else if ( !aup ) {
+      return -1;
+
+    } else if ( !bup ) {
+      return 1;
+    }
+
+    // Otherwise they're somewhere else in the tree so we need
+    // to build up a full list of the parentNodes for comparison
+    while ( cur ) {
+      ap.unshift( cur );
+      cur = cur.parentNode;
+    }
+
+    cur = bup;
+
+    while ( cur ) {
+      bp.unshift( cur );
+      cur = cur.parentNode;
+    }
+
+    al = ap.length;
+    bl = bp.length;
+
+    // Start walking down the tree looking for a discrepancy
+    for ( var i = 0; i < al && i < bl; i++ ) {
+      if ( ap[i] !== bp[i] ) {
+        return siblingCheck( ap[i], bp[i] );
+      }
+    }
+
+    // We ended someplace up the tree so do a sibling check
+    return i === al ?
+      siblingCheck( a, bp[i], -1 ) :
+      siblingCheck( ap[i], b, 1 );
+  };
+
+  siblingCheck = function( a, b, ret ) {
+    if ( a === b ) {
+      return ret;
+    }
+
+    var cur = a.nextSibling;
+
+    while ( cur ) {
+      if ( cur === b ) {
+        return -1;
+      }
+
+      cur = cur.nextSibling;
+    }
+
+    return 1;
+  };
 }
 
 // Check to see if the browser returns elements by name when
 // querying by getElementById (and provide a workaround)
 (function(){
-	// We're going to inject a fake input element with a specified name
-	var form = document.createElement("div"),
-		id = "script" + (new Date()).getTime(),
-		root = document.documentElement;
-
-	form.innerHTML = "<a name='" + id + "'/>";
-
-	// Inject it into the root element, check its status, and remove it quickly
-	root.insertBefore( form, root.firstChild );
-
-	// The workaround has to do additional checks after a getElementById
-	// Which slows things down for other browsers (hence the branching)
-	if ( document.getElementById( id ) ) {
-		Expr.find.ID = function( match, context, isXML ) {
-			if ( typeof context.getElementById !== "undefined" && !isXML ) {
-				var m = context.getElementById(match[1]);
-
-				return m ?
-					m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ?
-						[m] :
-						undefined :
-					[];
-			}
-		};
-
-		Expr.filter.ID = function( elem, match ) {
-			var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
-
-			return elem.nodeType === 1 && node && node.nodeValue === match;
-		};
-	}
-
-	root.removeChild( form );
-
-	// release memory in IE
-	root = form = null;
-})();
+  // We're going to inject a fake input element with a specified name
+  var form = document.createElement("div"),
+    id = "script" + (new Date()).getTime(),
+    root = document.documentElement;
+
+  form.innerHTML = "<a name='" + id + "'/>";
+
+  // Inject it into the root element, check its status, and remove it quickly
+  root.insertBefore( form, root.firstChild );
+
+  // The workaround has to do additional checks after a getElementById
+  // Which slows things down for other browsers (hence the branching)
+  if ( document.getElementById( id ) ) {
+    Expr.find.ID = function( match, context, isXML ) {
+      if ( typeof context.getElementById !== "undefined" && !isXML ) {
+        var m = context.getElementById(match[1]);
+
+        return m ?
+          m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ?
+            [m] :
+            undefined :
+          [];
+      }
+    };
 
-(function(){
-	// Check to see if the browser returns only elements
-	// when doing getElementsByTagName("*")
+    Expr.filter.ID = function( elem, match ) {
+      var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
 
-	// Create a fake element
-	var div = document.createElement("div");
-	div.appendChild( document.createComment("") );
+      return elem.nodeType === 1 && node && node.nodeValue === match;
+    };
+  }
 
-	// Make sure no comments are found
-	if ( div.getElementsByTagName("*").length > 0 ) {
-		Expr.find.TAG = function( match, context ) {
-			var results = context.getElementsByTagName( match[1] );
+  root.removeChild( form );
 
-			// Filter out possible comments
-			if ( match[1] === "*" ) {
-				var tmp = [];
+  // release memory in IE
+  root = form = null;
+})();
 
-				for ( var i = 0; results[i]; i++ ) {
-					if ( results[i].nodeType === 1 ) {
-						tmp.push( results[i] );
-					}
-				}
+(function(){
+  // Check to see if the browser returns only elements
+  // when doing getElementsByTagName("*")
+
+  // Create a fake element
+  var div = document.createElement("div");
+  div.appendChild( document.createComment("") );
+
+  // Make sure no comments are found
+  if ( div.getElementsByTagName("*").length > 0 ) {
+    Expr.find.TAG = function( match, context ) {
+      var results = context.getElementsByTagName( match[1] );
+
+      // Filter out possible comments
+      if ( match[1] === "*" ) {
+        var tmp = [];
+
+        for ( var i = 0; results[i]; i++ ) {
+          if ( results[i].nodeType === 1 ) {
+            tmp.push( results[i] );
+          }
+        }
 
-				results = tmp;
-			}
+        results = tmp;
+      }
 
-			return results;
-		};
-	}
+      return results;
+    };
+  }
 
-	// Check to see if an attribute returns normalized href attributes
-	div.innerHTML = "<a href='#'></a>";
+  // Check to see if an attribute returns normalized href attributes
+  div.innerHTML = "<a href='#'></a>";
 
-	if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
-			div.firstChild.getAttribute("href") !== "#" ) {
+  if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
+      div.firstChild.getAttribute("href") !== "#" ) {
 
-		Expr.attrHandle.href = function( elem ) {
-			return elem.getAttribute( "href", 2 );
-		};
-	}
+    Expr.attrHandle.href = function( elem ) {
+      return elem.getAttribute( "href", 2 );
+    };
+  }
 
-	// release memory in IE
-	div = null;
+  // release memory in IE
+  div = null;
 })();
 
 if ( document.querySelectorAll ) {
-	(function(){
-		var oldSizzle = Sizzle,
-			div = document.createElement("div"),
-			id = "__sizzle__";
-
-		div.innerHTML = "<p class='TEST'></p>";
-
-		// Safari can't handle uppercase or unicode characters when
-		// in quirks mode.
-		if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
-			return;
-		}
-	
-		Sizzle = function( query, context, extra, seed ) {
-			context = context || document;
-
-			// Only use querySelectorAll on non-XML documents
-			// (ID selectors don't work in non-HTML documents)
-			if ( !seed && !Sizzle.isXML(context) ) {
-				// See if we find a selector to speed up
-				var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec( query );
-				
-				if ( match && (context.nodeType === 1 || context.nodeType === 9) ) {
-					// Speed-up: Sizzle("TAG")
-					if ( match[1] ) {
-						return makeArray( context.getElementsByTagName( query ), extra );
-					
-					// Speed-up: Sizzle(".CLASS")
-					} else if ( match[2] && Expr.find.CLASS && context.getElementsByClassName ) {
-						return makeArray( context.getElementsByClassName( match[2] ), extra );
-					}
-				}
-				
-				if ( context.nodeType === 9 ) {
-					// Speed-up: Sizzle("body")
-					// The body element only exists once, optimize finding it
-					if ( query === "body" && context.body ) {
-						return makeArray( [ context.body ], extra );
-						
-					// Speed-up: Sizzle("#ID")
-					} else if ( match && match[3] ) {
-						var elem = context.getElementById( match[3] );
-
-						// Check parentNode to catch when Blackberry 4.6 returns
-						// nodes that are no longer in the document #6963
-						if ( elem && elem.parentNode ) {
-							// Handle the case where IE and Opera return items
-							// by name instead of ID
-							if ( elem.id === match[3] ) {
-								return makeArray( [ elem ], extra );
-							}
-							
-						} else {
-							return makeArray( [], extra );
-						}
-					}
-					
-					try {
-						return makeArray( context.querySelectorAll(query), extra );
-					} catch(qsaError) {}
-
-				// qSA works strangely on Element-rooted queries
-				// We can work around this by specifying an extra ID on the root
-				// and working up from there (Thanks to Andrew Dupont for the technique)
-				// IE 8 doesn't work on object elements
-				} else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
-					var oldContext = context,
-						old = context.getAttribute( "id" ),
-						nid = old || id,
-						hasParent = context.parentNode,
-						relativeHierarchySelector = /^\s*[+~]/.test( query );
-
-					if ( !old ) {
-						context.setAttribute( "id", nid );
-					} else {
-						nid = nid.replace( /'/g, "\\$&" );
-					}
-					if ( relativeHierarchySelector && hasParent ) {
-						context = context.parentNode;
-					}
-
-					try {
-						if ( !relativeHierarchySelector || hasParent ) {
-							return makeArray( context.querySelectorAll( "[id='" + nid + "'] " + query ), extra );
-						}
-
-					} catch(pseudoError) {
-					} finally {
-						if ( !old ) {
-							oldContext.removeAttribute( "id" );
-						}
-					}
-				}
-			}
-		
-			return oldSizzle(query, context, extra, seed);
-		};
-
-		for ( var prop in oldSizzle ) {
-			Sizzle[ prop ] = oldSizzle[ prop ];
-		}
-
-		// release memory in IE
-		div = null;
-	})();
+  (function(){
+    var oldSizzle = Sizzle,
+      div = document.createElement("div"),
+      id = "__sizzle__";
+
+    div.innerHTML = "<p class='TEST'></p>";
+
+    // Safari can't handle uppercase or unicode characters when
+    // in quirks mode.
+    if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
+      return;
+    }
+  
+    Sizzle = function( query, context, extra, seed ) {
+      context = context || document;
+
+      // Only use querySelectorAll on non-XML documents
+      // (ID selectors don't work in non-HTML documents)
+      if ( !seed && !Sizzle.isXML(context) ) {
+        // See if we find a selector to speed up
+        var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec( query );
+        
+        if ( match && (context.nodeType === 1 || context.nodeType === 9) ) {
+          // Speed-up: Sizzle("TAG")
+          if ( match[1] ) {
+            return makeArray( context.getElementsByTagName( query ), extra );
+          
+          // Speed-up: Sizzle(".CLASS")
+          } else if ( match[2] && Expr.find.CLASS && context.getElementsByClassName ) {
+            return makeArray( context.getElementsByClassName( match[2] ), extra );
+          }
+        }
+        
+        if ( context.nodeType === 9 ) {
+          // Speed-up: Sizzle("body")
+          // The body element only exists once, optimize finding it
+          if ( query === "body" && context.body ) {
+            return makeArray( [ context.body ], extra );
+            
+          // Speed-up: Sizzle("#ID")
+          } else if ( match && match[3] ) {
+            var elem = context.getElementById( match[3] );
+
+            // Check parentNode to catch when Blackberry 4.6 returns
+            // nodes that are no longer in the document #6963
+            if ( elem && elem.parentNode ) {
+              // Handle the case where IE and Opera return items
+              // by name instead of ID
+              if ( elem.id === match[3] ) {
+                return makeArray( [ elem ], extra );
+              }
+              
+            } else {
+              return makeArray( [], extra );
+            }
+          }
+          
+          try {
+            return makeArray( context.querySelectorAll(query), extra );
+          } catch(qsaError) {}
+
+        // qSA works strangely on Element-rooted queries
+        // We can work around this by specifying an extra ID on the root
+        // and working up from there (Thanks to Andrew Dupont for the technique)
+        // IE 8 doesn't work on object elements
+        } else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
+          var oldContext = context,
+            old = context.getAttribute( "id" ),
+            nid = old || id,
+            hasParent = context.parentNode,
+            relativeHierarchySelector = /^\s*[+~]/.test( query );
+
+          if ( !old ) {
+            context.setAttribute( "id", nid );
+          } else {
+            nid = nid.replace( /'/g, "\\$&" );
+          }
+          if ( relativeHierarchySelector && hasParent ) {
+            context = context.parentNode;
+          }
+
+          try {
+            if ( !relativeHierarchySelector || hasParent ) {
+              return makeArray( context.querySelectorAll( "[id='" + nid + "'] " + query ), extra );
+            }
+
+          } catch(pseudoError) {
+          } finally {
+            if ( !old ) {
+              oldContext.removeAttribute( "id" );
+            }
+          }
+        }
+      }
+    
+      return oldSizzle(query, context, extra, seed);
+    };
+
+    for ( var prop in oldSizzle ) {
+      Sizzle[ prop ] = oldSizzle[ prop ];
+    }
+
+    // release memory in IE
+    div = null;
+  })();
 }
 
 (function(){
-	var html = document.documentElement,
-		matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;
-
-	if ( matches ) {
-		// Check to see if it's possible to do matchesSelector
-		// on a disconnected node (IE 9 fails this)
-		var disconnectedMatch = !matches.call( document.createElement( "div" ), "div" ),
-			pseudoWorks = false;
-
-		try {
-			// This should fail with an exception
-			// Gecko does not error, returns false instead
-			matches.call( document.documentElement, "[test!='']:sizzle" );
-	
-		} catch( pseudoError ) {
-			pseudoWorks = true;
-		}
-
-		Sizzle.matchesSelector = function( node, expr ) {
-			// Make sure that attribute selectors are quoted
-			expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");
-
-			if ( !Sizzle.isXML( node ) ) {
-				try { 
-					if ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) && !/!=/.test( expr ) ) {
-						var ret = matches.call( node, expr );
-
-						// IE 9's matchesSelector returns false on disconnected nodes
-						if ( ret || !disconnectedMatch ||
-								// As well, disconnected nodes are said to be in a document
-								// fragment in IE 9, so check for that
-								node.document && node.document.nodeType !== 11 ) {
-							return ret;
-						}
-					}
-				} catch(e) {}
-			}
-
-			return Sizzle(expr, null, null, [node]).length > 0;
-		};
-	}
+  var html = document.documentElement,
+    matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;
+
+  if ( matches ) {
+    // Check to see if it's possible to do matchesSelector
+    // on a disconnected node (IE 9 fails this)
+    var disconnectedMatch = !matches.call( document.createElement( "div" ), "div" ),
+      pseudoWorks = false;
+
+    try {
+      // This should fail with an exception
+      // Gecko does not error, returns false instead
+      matches.call( document.documentElement, "[test!='']:sizzle" );
+  
+    } catch( pseudoError ) {
+      pseudoWorks = true;
+    }
+
+    Sizzle.matchesSelector = function( node, expr ) {
+      // Make sure that attribute selectors are quoted
+      expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");
+
+      if ( !Sizzle.isXML( node ) ) {
+        try { 
+          if ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) && !/!=/.test( expr ) ) {
+            var ret = matches.call( node, expr );
+
+            // IE 9's matchesSelector returns false on disconnected nodes
+            if ( ret || !disconnectedMatch ||
+                // As well, disconnected nodes are said to be in a document
+                // fragment in IE 9, so check for that
+                node.document && node.document.nodeType !== 11 ) {
+              return ret;
+            }
+          }
+        } catch(e) {}
+      }
+
+      return Sizzle(expr, null, null, [node]).length > 0;
+    };
+  }
 })();
 
 (function(){
-	var div = document.createElement("div");
-
-	div.innerHTML = "<div class='test e'></div><div class='test'></div>";
-
-	// Opera can't find a second classname (in 9.6)
-	// Also, make sure that getElementsByClassName actually exists
-	if ( !div.getElementsByClassName || div.getElementsByClassName("e").length === 0 ) {
-		return;
-	}
-
-	// Safari caches class attributes, doesn't catch changes (in 3.2)
-	div.lastChild.className = "e";
-
-	if ( div.getElementsByClassName("e").length === 1 ) {
-		return;
-	}
-	
-	Expr.order.splice(1, 0, "CLASS");
-	Expr.find.CLASS = function( match, context, isXML ) {
-		if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
-			return context.getElementsByClassName(match[1]);
-		}
-	};
-
-	// release memory in IE
-	div = null;
+  var div = document.createElement("div");
+
+  div.innerHTML = "<div class='test e'></div><div class='test'></div>";
+
+  // Opera can't find a second classname (in 9.6)
+  // Also, make sure that getElementsByClassName actually exists
+  if ( !div.getElementsByClassName || div.getElementsByClassName("e").length === 0 ) {
+    return;
+  }
+
+  // Safari caches class attributes, doesn't catch changes (in 3.2)
+  div.lastChild.className = "e";
+
+  if ( div.getElementsByClassName("e").length === 1 ) {
+    return;
+  }
+  
+  Expr.order.splice(1, 0, "CLASS");
+  Expr.find.CLASS = function( match, context, isXML ) {
+    if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
+      return context.getElementsByClassName(match[1]);
+    }
+  };
+
+  // release memory in IE
+  div = null;
 })();
 
 function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
-	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
-		var elem = checkSet[i];
+  for ( var i = 0, l = checkSet.length; i < l; i++ ) {
+    var elem = checkSet[i];
 
-		if ( elem ) {
-			var match = false;
+    if ( elem ) {
+      var match = false;
 
-			elem = elem[dir];
+      elem = elem[dir];
 
-			while ( elem ) {
-				if ( elem[ expando ] === doneName ) {
-					match = checkSet[elem.sizset];
-					break;
-				}
+      while ( elem ) {
+        if ( elem[ expando ] === doneName ) {
+          match = checkSet[elem.sizset];
+          break;
+        }
 
-				if ( elem.nodeType === 1 && !isXML ){
-					elem[ expando ] = doneName;
-					elem.sizset = i;
-				}
+        if ( elem.nodeType === 1 && !isXML ){
+          elem[ expando ] = doneName;
+          elem.sizset = i;
+        }
 
-				if ( elem.nodeName.toLowerCase() === cur ) {
-					match = elem;
-					break;
-				}
+        if ( elem.nodeName.toLowerCase() === cur ) {
+          match = elem;
+          break;
+        }
 
-				elem = elem[dir];
-			}
+        elem = elem[dir];
+      }
 
-			checkSet[i] = match;
-		}
-	}
+      checkSet[i] = match;
+    }
+  }
 }
 
 function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
-	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
-		var elem = checkSet[i];
-
-		if ( elem ) {
-			var match = false;
-			
-			elem = elem[dir];
-
-			while ( elem ) {
-				if ( elem[ expando ] === doneName ) {
-					match = checkSet[elem.sizset];
-					break;
-				}
-
-				if ( elem.nodeType === 1 ) {
-					if ( !isXML ) {
-						elem[ expando ] = doneName;
-						elem.sizset = i;
-					}
-
-					if ( typeof cur !== "string" ) {
-						if ( elem === cur ) {
-							match = true;
-							break;
-						}
-
-					} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
-						match = elem;
-						break;
-					}
-				}
-
-				elem = elem[dir];
-			}
-
-			checkSet[i] = match;
-		}
-	}
+  for ( var i = 0, l = checkSet.length; i < l; i++ ) {
+    var elem = checkSet[i];
+
+    if ( elem ) {
+      var match = false;
+      
+      elem = elem[dir];
+
+      while ( elem ) {
+        if ( elem[ expando ] === doneName ) {
+          match = checkSet[elem.sizset];
+          break;
+        }
+
+        if ( elem.nodeType === 1 ) {
+          if ( !isXML ) {
+            elem[ expando ] = doneName;
+            elem.sizset = i;
+          }
+
+          if ( typeof cur !== "string" ) {
+            if ( elem === cur ) {
+              match = true;
+              break;
+            }
+
+          } else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
+            match = elem;
+            break;
+          }
+        }
+
+        elem = elem[dir];
+      }
+
+      checkSet[i] = match;
+    }
+  }
 }
 
 if ( document.documentElement.contains ) {
-	Sizzle.contains = function( a, b ) {
-		return a !== b && (a.contains ? a.contains(b) : true);
-	};
+  Sizzle.contains = function( a, b ) {
+    return a !== b && (a.contains ? a.contains(b) : true);
+  };
 
 } else if ( document.documentElement.compareDocumentPosition ) {
-	Sizzle.contains = function( a, b ) {
-		return !!(a.compareDocumentPosition(b) & 16);
-	};
+  Sizzle.contains = function( a, b ) {
+    return !!(a.compareDocumentPosition(b) & 16);
+  };
 
 } else {
-	Sizzle.contains = function() {
-		return false;
-	};
+  Sizzle.contains = function() {
+    return false;
+  };
 }
 
 Sizzle.isXML = function( elem ) {
-	// documentElement is verified for cases where it doesn't yet exist
-	// (such as loading iframes in IE - #4833) 
-	var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;
+  // documentElement is verified for cases where it doesn't yet exist
+  // (such as loading iframes in IE - #4833) 
+  var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;
 
-	return documentElement ? documentElement.nodeName !== "HTML" : false;
+  return documentElement ? documentElement.nodeName !== "HTML" : false;
 };
 
 var posProcess = function( selector, context, seed ) {
-	var match,
-		tmpSet = [],
-		later = "",
-		root = context.nodeType ? [context] : context;
+  var match,
+    tmpSet = [],
+    later = "",
+    root = context.nodeType ? [context] : context;
 
-	// Position selectors must be done after the filter
-	// And so must :not(positional) so we move all PSEUDOs to the end
-	while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
-		later += match[0];
-		selector = selector.replace( Expr.match.PSEUDO, "" );
-	}
+  // Position selectors must be done after the filter
+  // And so must :not(positional) so we move all PSEUDOs to the end
+  while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
+    later += match[0];
+    selector = selector.replace( Expr.match.PSEUDO, "" );
+  }
 
-	selector = Expr.relative[selector] ? selector + "*" : selector;
+  selector = Expr.relative[selector] ? selector + "*" : selector;
 
-	for ( var i = 0, l = root.length; i < l; i++ ) {
-		Sizzle( selector, root[i], tmpSet, seed );
-	}
+  for ( var i = 0, l = root.length; i < l; i++ ) {
+    Sizzle( selector, root[i], tmpSet, seed );
+  }
 
-	return Sizzle.filter( later, tmpSet );
+  return Sizzle.filter( later, tmpSet );
 };
 
 // EXPOSE
@@ -7381,1591 +7381,1591 @@ jQuery.contains = Sizzle.contains;
 })();
 
 
-var runtil = /Until$/,
-	rparentsprev = /^(?:parents|prevUntil|prevAll)/,
-	// Note: This RegExp should be improved, or likely pulled from Sizzle
-	rmultiselector = /,/,
-	isSimple = /^.[^:#\[\.,]*$/,
-	slice = Array.prototype.slice,
-	POS = jQuery.expr.match.POS,
-	// methods guaranteed to produce a unique set when starting from a unique set
-	guaranteedUnique = {
-		children: true,
-		contents: true,
-		next: true,
-		prev: true
-	};
+var runtil = /Until$/,
+  rparentsprev = /^(?:parents|prevUntil|prevAll)/,
+  // Note: This RegExp should be improved, or likely pulled from Sizzle
+  rmultiselector = /,/,
+  isSimple = /^.[^:#\[\.,]*$/,
+  slice = Array.prototype.slice,
+  POS = jQuery.expr.match.POS,
+  // methods guaranteed to produce a unique set when starting from a unique set
+  guaranteedUnique = {
+    children: true,
+    contents: true,
+    next: true,
+    prev: true
+  };
+
+jQuery.fn.extend({
+  find: function( selector ) {
+    var self = this,
+      i, l;
+
+    if ( typeof selector !== "string" ) {
+      return jQuery( selector ).filter(function() {
+        for ( i = 0, l = self.length; i < l; i++ ) {
+          if ( jQuery.contains( self[ i ], this ) ) {
+            return true;
+          }
+        }
+      });
+    }
+
+    var ret = this.pushStack( "", "find", selector ),
+      length, n, r;
+
+    for ( i = 0, l = this.length; i < l; i++ ) {
+      length = ret.length;
+      jQuery.find( selector, this[i], ret );
+
+      if ( i > 0 ) {
+        // Make sure that the results are unique
+        for ( n = length; n < ret.length; n++ ) {
+          for ( r = 0; r < length; r++ ) {
+            if ( ret[r] === ret[n] ) {
+              ret.splice(n--, 1);
+              break;
+            }
+          }
+        }
+      }
+    }
+
+    return ret;
+  },
+
+  has: function( target ) {
+    var targets = jQuery( target );
+    return this.filter(function() {
+      for ( var i = 0, l = targets.length; i < l; i++ ) {
+        if ( jQuery.contains( this, targets[i] ) ) {
+          return true;
+        }
+      }
+    });
+  },
+
+  not: function( selector ) {
+    return this.pushStack( winnow(this, selector, false), "not", selector);
+  },
+
+  filter: function( selector ) {
+    return this.pushStack( winnow(this, selector, true), "filter", selector );
+  },
+
+  is: function( selector ) {
+    return !!selector && ( 
+      typeof selector === "string" ?
+        // If this is a positional selector, check membership in the returned set
+        // so $("p:first").is("p:last") won't return true for a doc with two "p".
+        POS.test( selector ) ? 
+          jQuery( selector, this.context ).index( this[0] ) >= 0 :
+          jQuery.filter( selector, this ).length > 0 :
+        this.filter( selector ).length > 0 );
+  },
+
+  closest: function( selectors, context ) {
+    var ret = [], i, l, cur = this[0];
+    
+    // Array (deprecated as of jQuery 1.7)
+    if ( jQuery.isArray( selectors ) ) {
+      var level = 1;
+
+      while ( cur && cur.ownerDocument && cur !== context ) {
+        for ( i = 0; i < selectors.length; i++ ) {
+
+          if ( jQuery( cur ).is( selectors[ i ] ) ) {
+            ret.push({ selector: selectors[ i ], elem: cur, level: level });
+          }
+        }
+
+        cur = cur.parentNode;
+        level++;
+      }
+
+      return ret;
+    }
+
+    // String
+    var pos = POS.test( selectors ) || typeof selectors !== "string" ?
+        jQuery( selectors, context || this.context ) :
+        0;
+
+    for ( i = 0, l = this.length; i < l; i++ ) {
+      cur = this[i];
+
+      while ( cur ) {
+        if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
+          ret.push( cur );
+          break;
+
+        } else {
+          cur = cur.parentNode;
+          if ( !cur || !cur.ownerDocument || cur === context || cur.nodeType === 11 ) {
+            break;
+          }
+        }
+      }
+    }
+
+    ret = ret.length > 1 ? jQuery.unique( ret ) : ret;
+
+    return this.pushStack( ret, "closest", selectors );
+  },
+
+  // Determine the position of an element within
+  // the matched set of elements
+  index: function( elem ) {
+
+    // No argument, return index in parent
+    if ( !elem ) {
+      return ( this[0] && this[0].parentNode ) ? this.prevAll().length : -1;
+    }
+
+    // index in selector
+    if ( typeof elem === "string" ) {
+      return jQuery.inArray( this[0], jQuery( elem ) );
+    }
+
+    // Locate the position of the desired element
+    return jQuery.inArray(
+      // If it receives a jQuery object, the first element is used
+      elem.jquery ? elem[0] : elem, this );
+  },
+
+  add: function( selector, context ) {
+    var set = typeof selector === "string" ?
+        jQuery( selector, context ) :
+        jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
+      all = jQuery.merge( this.get(), set );
+
+    return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
+      all :
+      jQuery.unique( all ) );
+  },
+
+  andSelf: function() {
+    return this.add( this.prevObject );
+  }
+});
+
+// A painfully simple check to see if an element is disconnected
+// from a document (should be improved, where feasible).
+function isDisconnected( node ) {
+  return !node || !node.parentNode || node.parentNode.nodeType === 11;
+}
+
+jQuery.each({
+  parent: function( elem ) {
+    var parent = elem.parentNode;
+    return parent && parent.nodeType !== 11 ? parent : null;
+  },
+  parents: function( elem ) {
+    return jQuery.dir( elem, "parentNode" );
+  },
+  parentsUntil: function( elem, i, until ) {
+    return jQuery.dir( elem, "parentNode", until );
+  },
+  next: function( elem ) {
+    return jQuery.nth( elem, 2, "nextSibling" );
+  },
+  prev: function( elem ) {
+    return jQuery.nth( elem, 2, "previousSibling" );
+  },
+  nextAll: function( elem ) {
+    return jQuery.dir( elem, "nextSibling" );
+  },
+  prevAll: function( elem ) {
+    return jQuery.dir( elem, "previousSibling" );
+  },
+  nextUntil: function( elem, i, until ) {
+    return jQuery.dir( elem, "nextSibling", until );
+  },
+  prevUntil: function( elem, i, until ) {
+    return jQuery.dir( elem, "previousSibling", until );
+  },
+  siblings: function( elem ) {
+    return jQuery.sibling( elem.parentNode.firstChild, elem );
+  },
+  children: function( elem ) {
+    return jQuery.sibling( elem.firstChild );
+  },
+  contents: function( elem ) {
+    return jQuery.nodeName( elem, "iframe" ) ?
+      elem.contentDocument || elem.contentWindow.document :
+      jQuery.makeArray( elem.childNodes );
+  }
+}, function( name, fn ) {
+  jQuery.fn[ name ] = function( until, selector ) {
+    var ret = jQuery.map( this, fn, until );
+
+    if ( !runtil.test( name ) ) {
+      selector = until;
+    }
+
+    if ( selector && typeof selector === "string" ) {
+      ret = jQuery.filter( selector, ret );
+    }
+
+    ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;
+
+    if ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {
+      ret = ret.reverse();
+    }
+
+    return this.pushStack( ret, name, slice.call( arguments ).join(",") );
+  };
+});
+
+jQuery.extend({
+  filter: function( expr, elems, not ) {
+    if ( not ) {
+      expr = ":not(" + expr + ")";
+    }
+
+    return elems.length === 1 ?
+      jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
+      jQuery.find.matches(expr, elems);
+  },
+
+  dir: function( elem, dir, until ) {
+    var matched = [],
+      cur = elem[ dir ];
+
+    while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
+      if ( cur.nodeType === 1 ) {
+        matched.push( cur );
+      }
+      cur = cur[dir];
+    }
+    return matched;
+  },
+
+  nth: function( cur, result, dir, elem ) {
+    result = result || 1;
+    var num = 0;
+
+    for ( ; cur; cur = cur[dir] ) {
+      if ( cur.nodeType === 1 && ++num === result ) {
+        break;
+      }
+    }
+
+    return cur;
+  },
+
+  sibling: function( n, elem ) {
+    var r = [];
+
+    for ( ; n; n = n.nextSibling ) {
+      if ( n.nodeType === 1 && n !== elem ) {
+        r.push( n );
+      }
+    }
+
+    return r;
+  }
+});
+
+// Implement the identical functionality for filter and not
+function winnow( elements, qualifier, keep ) {
+
+  // Can't pass null or undefined to indexOf in Firefox 4
+  // Set to 0 to skip string check
+  qualifier = qualifier || 0;
+
+  if ( jQuery.isFunction( qualifier ) ) {
+    return jQuery.grep(elements, function( elem, i ) {
+      var retVal = !!qualifier.call( elem, i, elem );
+      return retVal === keep;
+    });
+
+  } else if ( qualifier.nodeType ) {
+    return jQuery.grep(elements, function( elem, i ) {
+      return ( elem === qualifier ) === keep;
+    });
+
+  } else if ( typeof qualifier === "string" ) {
+    var filtered = jQuery.grep(elements, function( elem ) {
+      return elem.nodeType === 1;
+    });
+
+    if ( isSimple.test( qualifier ) ) {
+      return jQuery.filter(qualifier, filtered, !keep);
+    } else {
+      qualifier = jQuery.filter( qualifier, filtered );
+    }
+  }
+
+  return jQuery.grep(elements, function( elem, i ) {
+    return ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;
+  });
+}
+
+
+
+
+function createSafeFragment( document ) {
+  var list = nodeNames.split( "|" ),
+  safeFrag = document.createDocumentFragment();
+
+  if ( safeFrag.createElement ) {
+    while ( list.length ) {
+      safeFrag.createElement(
+        list.pop()
+      );
+    }
+  }
+  return safeFrag;
+}
+
+var nodeNames = "abbr|article|aside|audio|canvas|datalist|details|figcaption|figure|footer|" +
+    "header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
+  rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
+  rleadingWhitespace = /^\s+/,
+  rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
+  rtagName = /<([\w:]+)/,
+  rtbody = /<tbody/i,
+  rhtml = /<|&#?\w+;/,
+  rnoInnerhtml = /<(?:script|style)/i,
+  rnocache = /<(?:script|object|embed|option|style)/i,
+  rnoshimcache = new RegExp("<(?:" + nodeNames + ")", "i"),
+  // checked="checked" or checked
+  rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
+  rscriptType = /\/(java|ecma)script/i,
+  rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)/,
+  wrapMap = {
+    option: [ 1, "<select multiple='multiple'>", "</select>" ],
+    legend: [ 1, "<fieldset>", "</fieldset>" ],
+    thead: [ 1, "<table>", "</table>" ],
+    tr: [ 2, "<table><tbody>", "</tbody></table>" ],
+    td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
+    col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
+    area: [ 1, "<map>", "</map>" ],
+    _default: [ 0, "", "" ]
+  },
+  safeFragment = createSafeFragment( document );
+
+wrapMap.optgroup = wrapMap.option;
+wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
+wrapMap.th = wrapMap.td;
+
+// IE can't serialize <link> and <script> tags normally
+if ( !jQuery.support.htmlSerialize ) {
+  wrapMap._default = [ 1, "div<div>", "</div>" ];
+}
+
+jQuery.fn.extend({
+  text: function( text ) {
+    if ( jQuery.isFunction(text) ) {
+      return this.each(function(i) {
+        var self = jQuery( this );
+
+        self.text( text.call(this, i, self.text()) );
+      });
+    }
+
+    if ( typeof text !== "object" && text !== undefined ) {
+      return this.empty().append( (this[0] && this[0].ownerDocument || document).createTextNode( text ) );
+    }
+
+    return jQuery.text( this );
+  },
+
+  wrapAll: function( html ) {
+    if ( jQuery.isFunction( html ) ) {
+      return this.each(function(i) {
+        jQuery(this).wrapAll( html.call(this, i) );
+      });
+    }
+
+    if ( this[0] ) {
+      // The elements to wrap the target around
+      var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);
+
+      if ( this[0].parentNode ) {
+        wrap.insertBefore( this[0] );
+      }
+
+      wrap.map(function() {
+        var elem = this;
+
+        while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
+          elem = elem.firstChild;
+        }
+
+        return elem;
+      }).append( this );
+    }
+
+    return this;
+  },
+
+  wrapInner: function( html ) {
+    if ( jQuery.isFunction( html ) ) {
+      return this.each(function(i) {
+        jQuery(this).wrapInner( html.call(this, i) );
+      });
+    }
+
+    return this.each(function() {
+      var self = jQuery( this ),
+        contents = self.contents();
+
+      if ( contents.length ) {
+        contents.wrapAll( html );
+
+      } else {
+        self.append( html );
+      }
+    });
+  },
+
+  wrap: function( html ) {
+    var isFunction = jQuery.isFunction( html );
+
+    return this.each(function(i) {
+      jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
+    });
+  },
+
+  unwrap: function() {
+    return this.parent().each(function() {
+      if ( !jQuery.nodeName( this, "body" ) ) {
+        jQuery( this ).replaceWith( this.childNodes );
+      }
+    }).end();
+  },
+
+  append: function() {
+    return this.domManip(arguments, true, function( elem ) {
+      if ( this.nodeType === 1 ) {
+        this.appendChild( elem );
+      }
+    });
+  },
+
+  prepend: function() {
+    return this.domManip(arguments, true, function( elem ) {
+      if ( this.nodeType === 1 ) {
+        this.insertBefore( elem, this.firstChild );
+      }
+    });
+  },
+
+  before: function() {
+    if ( this[0] && this[0].parentNode ) {
+      return this.domManip(arguments, false, function( elem ) {
+        this.parentNode.insertBefore( elem, this );
+      });
+    } else if ( arguments.length ) {
+      var set = jQuery.clean( arguments );
+      set.push.apply( set, this.toArray() );
+      return this.pushStack( set, "before", arguments );
+    }
+  },
+
+  after: function() {
+    if ( this[0] && this[0].parentNode ) {
+      return this.domManip(arguments, false, function( elem ) {
+        this.parentNode.insertBefore( elem, this.nextSibling );
+      });
+    } else if ( arguments.length ) {
+      var set = this.pushStack( this, "after", arguments );
+      set.push.apply( set, jQuery.clean(arguments) );
+      return set;
+    }
+  },
+
+  // keepData is for internal use only--do not document
+  remove: function( selector, keepData ) {
+    for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
+      if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
+        if ( !keepData && elem.nodeType === 1 ) {
+          jQuery.cleanData( elem.getElementsByTagName("*") );
+          jQuery.cleanData( [ elem ] );
+        }
 
-jQuery.fn.extend({
-	find: function( selector ) {
-		var self = this,
-			i, l;
-
-		if ( typeof selector !== "string" ) {
-			return jQuery( selector ).filter(function() {
-				for ( i = 0, l = self.length; i < l; i++ ) {
-					if ( jQuery.contains( self[ i ], this ) ) {
-						return true;
-					}
-				}
-			});
-		}
-
-		var ret = this.pushStack( "", "find", selector ),
-			length, n, r;
-
-		for ( i = 0, l = this.length; i < l; i++ ) {
-			length = ret.length;
-			jQuery.find( selector, this[i], ret );
-
-			if ( i > 0 ) {
-				// Make sure that the results are unique
-				for ( n = length; n < ret.length; n++ ) {
-					for ( r = 0; r < length; r++ ) {
-						if ( ret[r] === ret[n] ) {
-							ret.splice(n--, 1);
-							break;
-						}
-					}
-				}
-			}
-		}
-
-		return ret;
-	},
-
-	has: function( target ) {
-		var targets = jQuery( target );
-		return this.filter(function() {
-			for ( var i = 0, l = targets.length; i < l; i++ ) {
-				if ( jQuery.contains( this, targets[i] ) ) {
-					return true;
-				}
-			}
-		});
-	},
-
-	not: function( selector ) {
-		return this.pushStack( winnow(this, selector, false), "not", selector);
-	},
-
-	filter: function( selector ) {
-		return this.pushStack( winnow(this, selector, true), "filter", selector );
-	},
-
-	is: function( selector ) {
-		return !!selector && ( 
-			typeof selector === "string" ?
-				// If this is a positional selector, check membership in the returned set
-				// so $("p:first").is("p:last") won't return true for a doc with two "p".
-				POS.test( selector ) ? 
-					jQuery( selector, this.context ).index( this[0] ) >= 0 :
-					jQuery.filter( selector, this ).length > 0 :
-				this.filter( selector ).length > 0 );
-	},
-
-	closest: function( selectors, context ) {
-		var ret = [], i, l, cur = this[0];
-		
-		// Array (deprecated as of jQuery 1.7)
-		if ( jQuery.isArray( selectors ) ) {
-			var level = 1;
-
-			while ( cur && cur.ownerDocument && cur !== context ) {
-				for ( i = 0; i < selectors.length; i++ ) {
-
-					if ( jQuery( cur ).is( selectors[ i ] ) ) {
-						ret.push({ selector: selectors[ i ], elem: cur, level: level });
-					}
-				}
-
-				cur = cur.parentNode;
-				level++;
-			}
-
-			return ret;
-		}
-
-		// String
-		var pos = POS.test( selectors ) || typeof selectors !== "string" ?
-				jQuery( selectors, context || this.context ) :
-				0;
-
-		for ( i = 0, l = this.length; i < l; i++ ) {
-			cur = this[i];
-
-			while ( cur ) {
-				if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
-					ret.push( cur );
-					break;
-
-				} else {
-					cur = cur.parentNode;
-					if ( !cur || !cur.ownerDocument || cur === context || cur.nodeType === 11 ) {
-						break;
-					}
-				}
-			}
-		}
-
-		ret = ret.length > 1 ? jQuery.unique( ret ) : ret;
-
-		return this.pushStack( ret, "closest", selectors );
-	},
-
-	// Determine the position of an element within
-	// the matched set of elements
-	index: function( elem ) {
-
-		// No argument, return index in parent
-		if ( !elem ) {
-			return ( this[0] && this[0].parentNode ) ? this.prevAll().length : -1;
-		}
-
-		// index in selector
-		if ( typeof elem === "string" ) {
-			return jQuery.inArray( this[0], jQuery( elem ) );
-		}
-
-		// Locate the position of the desired element
-		return jQuery.inArray(
-			// If it receives a jQuery object, the first element is used
-			elem.jquery ? elem[0] : elem, this );
-	},
-
-	add: function( selector, context ) {
-		var set = typeof selector === "string" ?
-				jQuery( selector, context ) :
-				jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
-			all = jQuery.merge( this.get(), set );
-
-		return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
-			all :
-			jQuery.unique( all ) );
-	},
-
-	andSelf: function() {
-		return this.add( this.prevObject );
-	}
-});
+        if ( elem.parentNode ) {
+          elem.parentNode.removeChild( elem );
+        }
+      }
+    }
 
-// A painfully simple check to see if an element is disconnected
-// from a document (should be improved, where feasible).
-function isDisconnected( node ) {
-	return !node || !node.parentNode || node.parentNode.nodeType === 11;
-}
+    return this;
+  },
 
-jQuery.each({
-	parent: function( elem ) {
-		var parent = elem.parentNode;
-		return parent && parent.nodeType !== 11 ? parent : null;
-	},
-	parents: function( elem ) {
-		return jQuery.dir( elem, "parentNode" );
-	},
-	parentsUntil: function( elem, i, until ) {
-		return jQuery.dir( elem, "parentNode", until );
-	},
-	next: function( elem ) {
-		return jQuery.nth( elem, 2, "nextSibling" );
-	},
-	prev: function( elem ) {
-		return jQuery.nth( elem, 2, "previousSibling" );
-	},
-	nextAll: function( elem ) {
-		return jQuery.dir( elem, "nextSibling" );
-	},
-	prevAll: function( elem ) {
-		return jQuery.dir( elem, "previousSibling" );
-	},
-	nextUntil: function( elem, i, until ) {
-		return jQuery.dir( elem, "nextSibling", until );
-	},
-	prevUntil: function( elem, i, until ) {
-		return jQuery.dir( elem, "previousSibling", until );
-	},
-	siblings: function( elem ) {
-		return jQuery.sibling( elem.parentNode.firstChild, elem );
-	},
-	children: function( elem ) {
-		return jQuery.sibling( elem.firstChild );
-	},
-	contents: function( elem ) {
-		return jQuery.nodeName( elem, "iframe" ) ?
-			elem.contentDocument || elem.contentWindow.document :
-			jQuery.makeArray( elem.childNodes );
-	}
-}, function( name, fn ) {
-	jQuery.fn[ name ] = function( until, selector ) {
-		var ret = jQuery.map( this, fn, until );
+  empty: function() {
+    for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
+      // Remove element nodes and prevent memory leaks
+      if ( elem.nodeType === 1 ) {
+        jQuery.cleanData( elem.getElementsByTagName("*") );
+      }
 
-		if ( !runtil.test( name ) ) {
-			selector = until;
-		}
+      // Remove any remaining nodes
+      while ( elem.firstChild ) {
+        elem.removeChild( elem.firstChild );
+      }
+    }
 
-		if ( selector && typeof selector === "string" ) {
-			ret = jQuery.filter( selector, ret );
-		}
+    return this;
+  },
+
+  clone: function( dataAndEvents, deepDataAndEvents ) {
+    dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
+    deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
+
+    return this.map( function () {
+      return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
+    });
+  },
+
+  html: function( value ) {
+    if ( value === undefined ) {
+      return this[0] && this[0].nodeType === 1 ?
+        this[0].innerHTML.replace(rinlinejQuery, "") :
+        null;
+
+    // See if we can take a shortcut and just use innerHTML
+    } else if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
+      (jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value )) &&
+      !wrapMap[ (rtagName.exec( value ) || ["", ""])[1].toLowerCase() ] ) {
+
+      value = value.replace(rxhtmlTag, "<$1></$2>");
+
+      try {
+        for ( var i = 0, l = this.length; i < l; i++ ) {
+          // Remove element nodes and prevent memory leaks
+          if ( this[i].nodeType === 1 ) {
+            jQuery.cleanData( this[i].getElementsByTagName("*") );
+            this[i].innerHTML = value;
+          }
+        }
 
-		ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;
+      // If using innerHTML throws an exception, use the fallback method
+      } catch(e) {
+        this.empty().append( value );
+      }
 
-		if ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {
-			ret = ret.reverse();
-		}
+    } else if ( jQuery.isFunction( value ) ) {
+      this.each(function(i){
+        var self = jQuery( this );
 
-		return this.pushStack( ret, name, slice.call( arguments ).join(",") );
-	};
-});
+        self.html( value.call(this, i, self.html()) );
+      });
 
-jQuery.extend({
-	filter: function( expr, elems, not ) {
-		if ( not ) {
-			expr = ":not(" + expr + ")";
-		}
-
-		return elems.length === 1 ?
-			jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
-			jQuery.find.matches(expr, elems);
-	},
-
-	dir: function( elem, dir, until ) {
-		var matched = [],
-			cur = elem[ dir ];
-
-		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
-			if ( cur.nodeType === 1 ) {
-				matched.push( cur );
-			}
-			cur = cur[dir];
-		}
-		return matched;
-	},
-
-	nth: function( cur, result, dir, elem ) {
-		result = result || 1;
-		var num = 0;
-
-		for ( ; cur; cur = cur[dir] ) {
-			if ( cur.nodeType === 1 && ++num === result ) {
-				break;
-			}
-		}
-
-		return cur;
-	},
-
-	sibling: function( n, elem ) {
-		var r = [];
-
-		for ( ; n; n = n.nextSibling ) {
-			if ( n.nodeType === 1 && n !== elem ) {
-				r.push( n );
-			}
-		}
-
-		return r;
-	}
-});
+    } else {
+      this.empty().append( value );
+    }
 
-// Implement the identical functionality for filter and not
-function winnow( elements, qualifier, keep ) {
+    return this;
+  },
 
-	// Can't pass null or undefined to indexOf in Firefox 4
-	// Set to 0 to skip string check
-	qualifier = qualifier || 0;
-
-	if ( jQuery.isFunction( qualifier ) ) {
-		return jQuery.grep(elements, function( elem, i ) {
-			var retVal = !!qualifier.call( elem, i, elem );
-			return retVal === keep;
-		});
-
-	} else if ( qualifier.nodeType ) {
-		return jQuery.grep(elements, function( elem, i ) {
-			return ( elem === qualifier ) === keep;
-		});
-
-	} else if ( typeof qualifier === "string" ) {
-		var filtered = jQuery.grep(elements, function( elem ) {
-			return elem.nodeType === 1;
-		});
-
-		if ( isSimple.test( qualifier ) ) {
-			return jQuery.filter(qualifier, filtered, !keep);
-		} else {
-			qualifier = jQuery.filter( qualifier, filtered );
-		}
-	}
-
-	return jQuery.grep(elements, function( elem, i ) {
-		return ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;
-	});
-}
+  replaceWith: function( value ) {
+    if ( this[0] && this[0].parentNode ) {
+      // Make sure that the elements are removed from the DOM before they are inserted
+      // this can help fix replacing a parent with child elements
+      if ( jQuery.isFunction( value ) ) {
+        return this.each(function(i) {
+          var self = jQuery(this), old = self.html();
+          self.replaceWith( value.call( this, i, old ) );
+        });
+      }
 
+      if ( typeof value !== "string" ) {
+        value = jQuery( value ).detach();
+      }
 
+      return this.each(function() {
+        var next = this.nextSibling,
+          parent = this.parentNode;
 
+        jQuery( this ).remove();
 
-function createSafeFragment( document ) {
-	var list = nodeNames.split( "|" ),
-	safeFrag = document.createDocumentFragment();
-
-	if ( safeFrag.createElement ) {
-		while ( list.length ) {
-			safeFrag.createElement(
-				list.pop()
-			);
-		}
-	}
-	return safeFrag;
-}
+        if ( next ) {
+          jQuery(next).before( value );
+        } else {
+          jQuery(parent).append( value );
+        }
+      });
+    } else {
+      return this.length ?
+        this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value ) :
+        this;
+    }
+  },
+
+  detach: function( selector ) {
+    return this.remove( selector, true );
+  },
+
+  domManip: function( args, table, callback ) {
+    var results, first, fragment, parent,
+      value = args[0],
+      scripts = [];
+
+    // We can't cloneNode fragments that contain checked, in WebKit
+    if ( !jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test( value ) ) {
+      return this.each(function() {
+        jQuery(this).domManip( args, table, callback, true );
+      });
+    }
 
-var nodeNames = "abbr|article|aside|audio|canvas|datalist|details|figcaption|figure|footer|" +
-		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
-	rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
-	rleadingWhitespace = /^\s+/,
-	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
-	rtagName = /<([\w:]+)/,
-	rtbody = /<tbody/i,
-	rhtml = /<|&#?\w+;/,
-	rnoInnerhtml = /<(?:script|style)/i,
-	rnocache = /<(?:script|object|embed|option|style)/i,
-	rnoshimcache = new RegExp("<(?:" + nodeNames + ")", "i"),
-	// checked="checked" or checked
-	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
-	rscriptType = /\/(java|ecma)script/i,
-	rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)/,
-	wrapMap = {
-		option: [ 1, "<select multiple='multiple'>", "</select>" ],
-		legend: [ 1, "<fieldset>", "</fieldset>" ],
-		thead: [ 1, "<table>", "</table>" ],
-		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
-		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
-		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
-		area: [ 1, "<map>", "</map>" ],
-		_default: [ 0, "", "" ]
-	},
-	safeFragment = createSafeFragment( document );
+    if ( jQuery.isFunction(value) ) {
+      return this.each(function(i) {
+        var self = jQuery(this);
+        args[0] = value.call(this, i, table ? self.html() : undefined);
+        self.domManip( args, table, callback );
+      });
+    }
 
-wrapMap.optgroup = wrapMap.option;
-wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
-wrapMap.th = wrapMap.td;
+    if ( this[0] ) {
+      parent = value && value.parentNode;
+
+      // If we're in a fragment, just use that instead of building a new one
+      if ( jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length ) {
+        results = { fragment: parent };
+
+      } else {
+        results = jQuery.buildFragment( args, this, scripts );
+      }
+
+      fragment = results.fragment;
+
+      if ( fragment.childNodes.length === 1 ) {
+        first = fragment = fragment.firstChild;
+      } else {
+        first = fragment.firstChild;
+      }
+
+      if ( first ) {
+        table = table && jQuery.nodeName( first, "tr" );
+
+        for ( var i = 0, l = this.length, lastIndex = l - 1; i < l; i++ ) {
+          callback.call(
+            table ?
+              root(this[i], first) :
+              this[i],
+            // Make sure that we do not leak memory by inadvertently discarding
+            // the original fragment (which might have attached data) instead of
+            // using it; in addition, use the original fragment object for the last
+            // item instead of first because it can end up being emptied incorrectly
+            // in certain situations (Bug #8070).
+            // Fragments from the fragment cache must always be cloned and never used
+            // in place.
+            results.cacheable || ( l > 1 && i < lastIndex ) ?
+              jQuery.clone( fragment, true, true ) :
+              fragment
+          );
+        }
+      }
 
-// IE can't serialize <link> and <script> tags normally
-if ( !jQuery.support.htmlSerialize ) {
-	wrapMap._default = [ 1, "div<div>", "</div>" ];
-}
+      if ( scripts.length ) {
+        jQuery.each( scripts, evalScript );
+      }
+    }
 
-jQuery.fn.extend({
-	text: function( text ) {
-		if ( jQuery.isFunction(text) ) {
-			return this.each(function(i) {
-				var self = jQuery( this );
-
-				self.text( text.call(this, i, self.text()) );
-			});
-		}
-
-		if ( typeof text !== "object" && text !== undefined ) {
-			return this.empty().append( (this[0] && this[0].ownerDocument || document).createTextNode( text ) );
-		}
-
-		return jQuery.text( this );
-	},
-
-	wrapAll: function( html ) {
-		if ( jQuery.isFunction( html ) ) {
-			return this.each(function(i) {
-				jQuery(this).wrapAll( html.call(this, i) );
-			});
-		}
-
-		if ( this[0] ) {
-			// The elements to wrap the target around
-			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);
-
-			if ( this[0].parentNode ) {
-				wrap.insertBefore( this[0] );
-			}
-
-			wrap.map(function() {
-				var elem = this;
-
-				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
-					elem = elem.firstChild;
-				}
-
-				return elem;
-			}).append( this );
-		}
-
-		return this;
-	},
-
-	wrapInner: function( html ) {
-		if ( jQuery.isFunction( html ) ) {
-			return this.each(function(i) {
-				jQuery(this).wrapInner( html.call(this, i) );
-			});
-		}
-
-		return this.each(function() {
-			var self = jQuery( this ),
-				contents = self.contents();
-
-			if ( contents.length ) {
-				contents.wrapAll( html );
-
-			} else {
-				self.append( html );
-			}
-		});
-	},
-
-	wrap: function( html ) {
-		var isFunction = jQuery.isFunction( html );
-
-		return this.each(function(i) {
-			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
-		});
-	},
-
-	unwrap: function() {
-		return this.parent().each(function() {
-			if ( !jQuery.nodeName( this, "body" ) ) {
-				jQuery( this ).replaceWith( this.childNodes );
-			}
-		}).end();
-	},
-
-	append: function() {
-		return this.domManip(arguments, true, function( elem ) {
-			if ( this.nodeType === 1 ) {
-				this.appendChild( elem );
-			}
-		});
-	},
-
-	prepend: function() {
-		return this.domManip(arguments, true, function( elem ) {
-			if ( this.nodeType === 1 ) {
-				this.insertBefore( elem, this.firstChild );
-			}
-		});
-	},
-
-	before: function() {
-		if ( this[0] && this[0].parentNode ) {
-			return this.domManip(arguments, false, function( elem ) {
-				this.parentNode.insertBefore( elem, this );
-			});
-		} else if ( arguments.length ) {
-			var set = jQuery.clean( arguments );
-			set.push.apply( set, this.toArray() );
-			return this.pushStack( set, "before", arguments );
-		}
-	},
-
-	after: function() {
-		if ( this[0] && this[0].parentNode ) {
-			return this.domManip(arguments, false, function( elem ) {
-				this.parentNode.insertBefore( elem, this.nextSibling );
-			});
-		} else if ( arguments.length ) {
-			var set = this.pushStack( this, "after", arguments );
-			set.push.apply( set, jQuery.clean(arguments) );
-			return set;
-		}
-	},
-
-	// keepData is for internal use only--do not document
-	remove: function( selector, keepData ) {
-		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
-			if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
-				if ( !keepData && elem.nodeType === 1 ) {
-					jQuery.cleanData( elem.getElementsByTagName("*") );
-					jQuery.cleanData( [ elem ] );
-				}
-
-				if ( elem.parentNode ) {
-					elem.parentNode.removeChild( elem );
-				}
-			}
-		}
-
-		return this;
-	},
-
-	empty: function() {
-		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
-			// Remove element nodes and prevent memory leaks
-			if ( elem.nodeType === 1 ) {
-				jQuery.cleanData( elem.getElementsByTagName("*") );
-			}
-
-			// Remove any remaining nodes
-			while ( elem.firstChild ) {
-				elem.removeChild( elem.firstChild );
-			}
-		}
-
-		return this;
-	},
-
-	clone: function( dataAndEvents, deepDataAndEvents ) {
-		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
-		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
-
-		return this.map( function () {
-			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
-		});
-	},
-
-	html: function( value ) {
-		if ( value === undefined ) {
-			return this[0] && this[0].nodeType === 1 ?
-				this[0].innerHTML.replace(rinlinejQuery, "") :
-				null;
-
-		// See if we can take a shortcut and just use innerHTML
-		} else if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
-			(jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value )) &&
-			!wrapMap[ (rtagName.exec( value ) || ["", ""])[1].toLowerCase() ] ) {
-
-			value = value.replace(rxhtmlTag, "<$1></$2>");
-
-			try {
-				for ( var i = 0, l = this.length; i < l; i++ ) {
-					// Remove element nodes and prevent memory leaks
-					if ( this[i].nodeType === 1 ) {
-						jQuery.cleanData( this[i].getElementsByTagName("*") );
-						this[i].innerHTML = value;
-					}
-				}
-
-			// If using innerHTML throws an exception, use the fallback method
-			} catch(e) {
-				this.empty().append( value );
-			}
-
-		} else if ( jQuery.isFunction( value ) ) {
-			this.each(function(i){
-				var self = jQuery( this );
-
-				self.html( value.call(this, i, self.html()) );
-			});
-
-		} else {
-			this.empty().append( value );
-		}
-
-		return this;
-	},
-
-	replaceWith: function( value ) {
-		if ( this[0] && this[0].parentNode ) {
-			// Make sure that the elements are removed from the DOM before they are inserted
-			// this can help fix replacing a parent with child elements
-			if ( jQuery.isFunction( value ) ) {
-				return this.each(function(i) {
-					var self = jQuery(this), old = self.html();
-					self.replaceWith( value.call( this, i, old ) );
-				});
-			}
-
-			if ( typeof value !== "string" ) {
-				value = jQuery( value ).detach();
-			}
-
-			return this.each(function() {
-				var next = this.nextSibling,
-					parent = this.parentNode;
-
-				jQuery( this ).remove();
-
-				if ( next ) {
-					jQuery(next).before( value );
-				} else {
-					jQuery(parent).append( value );
-				}
-			});
-		} else {
-			return this.length ?
-				this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value ) :
-				this;
-		}
-	},
-
-	detach: function( selector ) {
-		return this.remove( selector, true );
-	},
-
-	domManip: function( args, table, callback ) {
-		var results, first, fragment, parent,
-			value = args[0],
-			scripts = [];
-
-		// We can't cloneNode fragments that contain checked, in WebKit
-		if ( !jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test( value ) ) {
-			return this.each(function() {
-				jQuery(this).domManip( args, table, callback, true );
-			});
-		}
-
-		if ( jQuery.isFunction(value) ) {
-			return this.each(function(i) {
-				var self = jQuery(this);
-				args[0] = value.call(this, i, table ? self.html() : undefined);
-				self.domManip( args, table, callback );
-			});
-		}
-
-		if ( this[0] ) {
-			parent = value && value.parentNode;
-
-			// If we're in a fragment, just use that instead of building a new one
-			if ( jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length ) {
-				results = { fragment: parent };
-
-			} else {
-				results = jQuery.buildFragment( args, this, scripts );
-			}
-
-			fragment = results.fragment;
-
-			if ( fragment.childNodes.length === 1 ) {
-				first = fragment = fragment.firstChild;
-			} else {
-				first = fragment.firstChild;
-			}
-
-			if ( first ) {
-				table = table && jQuery.nodeName( first, "tr" );
-
-				for ( var i = 0, l = this.length, lastIndex = l - 1; i < l; i++ ) {
-					callback.call(
-						table ?
-							root(this[i], first) :
-							this[i],
-						// Make sure that we do not leak memory by inadvertently discarding
-						// the original fragment (which might have attached data) instead of
-						// using it; in addition, use the original fragment object for the last
-						// item instead of first because it can end up being emptied incorrectly
-						// in certain situations (Bug #8070).
-						// Fragments from the fragment cache must always be cloned and never used
-						// in place.
-						results.cacheable || ( l > 1 && i < lastIndex ) ?
-							jQuery.clone( fragment, true, true ) :
-							fragment
-					);
-				}
-			}
-
-			if ( scripts.length ) {
-				jQuery.each( scripts, evalScript );
-			}
-		}
-
-		return this;
-	}
+    return this;
+  }
 });
 
 function root( elem, cur ) {
-	return jQuery.nodeName(elem, "table") ?
-		(elem.getElementsByTagName("tbody")[0] ||
-		elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
-		elem;
+  return jQuery.nodeName(elem, "table") ?
+    (elem.getElementsByTagName("tbody")[0] ||
+    elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
+    elem;
 }
 
 function cloneCopyEvent( src, dest ) {
 
-	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
-		return;
-	}
-
-	var type, i, l,
-		oldData = jQuery._data( src ),
-		curData = jQuery._data( dest, oldData ),
-		events = oldData.events;
-
-	if ( events ) {
-		delete curData.handle;
-		curData.events = {};
-
-		for ( type in events ) {
-			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
-				jQuery.event.add( dest, type + ( events[ type ][ i ].namespace ? "." : "" ) + events[ type ][ i ].namespace, events[ type ][ i ], events[ type ][ i ].data );
-			}
-		}
-	}
-
-	// make the cloned public data object a copy from the original
-	if ( curData.data ) {
-		curData.data = jQuery.extend( {}, curData.data );
-	}
+  if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
+    return;
+  }
+
+  var type, i, l,
+    oldData = jQuery._data( src ),
+    curData = jQuery._data( dest, oldData ),
+    events = oldData.events;
+
+  if ( events ) {
+    delete curData.handle;
+    curData.events = {};
+
+    for ( type in events ) {
+      for ( i = 0, l = events[ type ].length; i < l; i++ ) {
+        jQuery.event.add( dest, type + ( events[ type ][ i ].namespace ? "." : "" ) + events[ type ][ i ].namespace, events[ type ][ i ], events[ type ][ i ].data );
+      }
+    }
+  }
+
+  // make the cloned public data object a copy from the original
+  if ( curData.data ) {
+    curData.data = jQuery.extend( {}, curData.data );
+  }
 }
 
 function cloneFixAttributes( src, dest ) {
-	var nodeName;
-
-	// We do not need to do anything for non-Elements
-	if ( dest.nodeType !== 1 ) {
-		return;
-	}
-
-	// clearAttributes removes the attributes, which we don't want,
-	// but also removes the attachEvent events, which we *do* want
-	if ( dest.clearAttributes ) {
-		dest.clearAttributes();
-	}
-
-	// mergeAttributes, in contrast, only merges back on the
-	// original attributes, not the events
-	if ( dest.mergeAttributes ) {
-		dest.mergeAttributes( src );
-	}
-
-	nodeName = dest.nodeName.toLowerCase();
-
-	// IE6-8 fail to clone children inside object elements that use
-	// the proprietary classid attribute value (rather than the type
-	// attribute) to identify the type of content to display
-	if ( nodeName === "object" ) {
-		dest.outerHTML = src.outerHTML;
-
-	} else if ( nodeName === "input" && (src.type === "checkbox" || src.type === "radio") ) {
-		// IE6-8 fails to persist the checked state of a cloned checkbox
-		// or radio button. Worse, IE6-7 fail to give the cloned element
-		// a checked appearance if the defaultChecked value isn't also set
-		if ( src.checked ) {
-			dest.defaultChecked = dest.checked = src.checked;
-		}
-
-		// IE6-7 get confused and end up setting the value of a cloned
-		// checkbox/radio button to an empty string instead of "on"
-		if ( dest.value !== src.value ) {
-			dest.value = src.value;
-		}
-
-	// IE6-8 fails to return the selected option to the default selected
-	// state when cloning options
-	} else if ( nodeName === "option" ) {
-		dest.selected = src.defaultSelected;
-
-	// IE6-8 fails to set the defaultValue to the correct value when
-	// cloning other types of input fields
-	} else if ( nodeName === "input" || nodeName === "textarea" ) {
-		dest.defaultValue = src.defaultValue;
-	}
-
-	// Event data gets referenced instead of copied if the expando
-	// gets copied too
-	dest.removeAttribute( jQuery.expando );
+  var nodeName;
+
+  // We do not need to do anything for non-Elements
+  if ( dest.nodeType !== 1 ) {
+    return;
+  }
+
+  // clearAttributes removes the attributes, which we don't want,
+  // but also removes the attachEvent events, which we *do* want
+  if ( dest.clearAttributes ) {
+    dest.clearAttributes();
+  }
+
+  // mergeAttributes, in contrast, only merges back on the
+  // original attributes, not the events
+  if ( dest.mergeAttributes ) {
+    dest.mergeAttributes( src );
+  }
+
+  nodeName = dest.nodeName.toLowerCase();
+
+  // IE6-8 fail to clone children inside object elements that use
+  // the proprietary classid attribute value (rather than the type
+  // attribute) to identify the type of content to display
+  if ( nodeName === "object" ) {
+    dest.outerHTML = src.outerHTML;
+
+  } else if ( nodeName === "input" && (src.type === "checkbox" || src.type === "radio") ) {
+    // IE6-8 fails to persist the checked state of a cloned checkbox
+    // or radio button. Worse, IE6-7 fail to give the cloned element
+    // a checked appearance if the defaultChecked value isn't also set
+    if ( src.checked ) {
+      dest.defaultChecked = dest.checked = src.checked;
+    }
+
+    // IE6-7 get confused and end up setting the value of a cloned
+    // checkbox/radio button to an empty string instead of "on"
+    if ( dest.value !== src.value ) {
+      dest.value = src.value;
+    }
+
+  // IE6-8 fails to return the selected option to the default selected
+  // state when cloning options
+  } else if ( nodeName === "option" ) {
+    dest.selected = src.defaultSelected;
+
+  // IE6-8 fails to set the defaultValue to the correct value when
+  // cloning other types of input fields
+  } else if ( nodeName === "input" || nodeName === "textarea" ) {
+    dest.defaultValue = src.defaultValue;
+  }
+
+  // Event data gets referenced instead of copied if the expando
+  // gets copied too
+  dest.removeAttribute( jQuery.expando );
 }
 
 jQuery.buildFragment = function( args, nodes, scripts ) {
-	var fragment, cacheable, cacheresults, doc,
-	first = args[ 0 ];
-
-	// nodes may contain either an explicit document object,
-	// a jQuery collection or context object.
-	// If nodes[0] contains a valid object to assign to doc
-	if ( nodes && nodes[0] ) {
-		doc = nodes[0].ownerDocument || nodes[0];
-	}
-
-	// Ensure that an attr object doesn't incorrectly stand in as a document object
-	// Chrome and Firefox seem to allow this to occur and will throw exception
-	// Fixes #8950
-	if ( !doc.createDocumentFragment ) {
-		doc = document;
-	}
-
-	// Only cache "small" (1/2 KB) HTML strings that are associated with the main document
-	// Cloning options loses the selected state, so don't cache them
-	// IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
-	// Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
-	// Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
-	if ( args.length === 1 && typeof first === "string" && first.length < 512 && doc === document &&
-		first.charAt(0) === "<" && !rnocache.test( first ) &&
-		(jQuery.support.checkClone || !rchecked.test( first )) &&
-		(jQuery.support.html5Clone || !rnoshimcache.test( first )) ) {
-
-		cacheable = true;
-
-		cacheresults = jQuery.fragments[ first ];
-		if ( cacheresults && cacheresults !== 1 ) {
-			fragment = cacheresults;
-		}
-	}
-
-	if ( !fragment ) {
-		fragment = doc.createDocumentFragment();
-		jQuery.clean( args, doc, fragment, scripts );
-	}
-
-	if ( cacheable ) {
-		jQuery.fragments[ first ] = cacheresults ? fragment : 1;
-	}
-
-	return { fragment: fragment, cacheable: cacheable };
+  var fragment, cacheable, cacheresults, doc,
+  first = args[ 0 ];
+
+  // nodes may contain either an explicit document object,
+  // a jQuery collection or context object.
+  // If nodes[0] contains a valid object to assign to doc
+  if ( nodes && nodes[0] ) {
+    doc = nodes[0].ownerDocument || nodes[0];
+  }
+
+  // Ensure that an attr object doesn't incorrectly stand in as a document object
+  // Chrome and Firefox seem to allow this to occur and will throw exception
+  // Fixes #8950
+  if ( !doc.createDocumentFragment ) {
+    doc = document;
+  }
+
+  // Only cache "small" (1/2 KB) HTML strings that are associated with the main document
+  // Cloning options loses the selected state, so don't cache them
+  // IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
+  // Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
+  // Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
+  if ( args.length === 1 && typeof first === "string" && first.length < 512 && doc === document &&
+    first.charAt(0) === "<" && !rnocache.test( first ) &&
+    (jQuery.support.checkClone || !rchecked.test( first )) &&
+    (jQuery.support.html5Clone || !rnoshimcache.test( first )) ) {
+
+    cacheable = true;
+
+    cacheresults = jQuery.fragments[ first ];
+    if ( cacheresults && cacheresults !== 1 ) {
+      fragment = cacheresults;
+    }
+  }
+
+  if ( !fragment ) {
+    fragment = doc.createDocumentFragment();
+    jQuery.clean( args, doc, fragment, scripts );
+  }
+
+  if ( cacheable ) {
+    jQuery.fragments[ first ] = cacheresults ? fragment : 1;
+  }
+
+  return { fragment: fragment, cacheable: cacheable };
 };
 
 jQuery.fragments = {};
 
 jQuery.each({
-	appendTo: "append",
-	prependTo: "prepend",
-	insertBefore: "before",
-	insertAfter: "after",
-	replaceAll: "replaceWith"
+  appendTo: "append",
+  prependTo: "prepend",
+  insertBefore: "before",
+  insertAfter: "after",
+  replaceAll: "replaceWith"
 }, function( name, original ) {
-	jQuery.fn[ name ] = function( selector ) {
-		var ret = [],
-			insert = jQuery( selector ),
-			parent = this.length === 1 && this[0].parentNode;
-
-		if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
-			insert[ original ]( this[0] );
-			return this;
-
-		} else {
-			for ( var i = 0, l = insert.length; i < l; i++ ) {
-				var elems = ( i > 0 ? this.clone(true) : this ).get();
-				jQuery( insert[i] )[ original ]( elems );
-				ret = ret.concat( elems );
-			}
-
-			return this.pushStack( ret, name, insert.selector );
-		}
-	};
+  jQuery.fn[ name ] = function( selector ) {
+    var ret = [],
+      insert = jQuery( selector ),
+      parent = this.length === 1 && this[0].parentNode;
+
+    if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
+      insert[ original ]( this[0] );
+      return this;
+
+    } else {
+      for ( var i = 0, l = insert.length; i < l; i++ ) {
+        var elems = ( i > 0 ? this.clone(true) : this ).get();
+        jQuery( insert[i] )[ original ]( elems );
+        ret = ret.concat( elems );
+      }
+
+      return this.pushStack( ret, name, insert.selector );
+    }
+  };
 });
 
 function getAll( elem ) {
-	if ( typeof elem.getElementsByTagName !== "undefined" ) {
-		return elem.getElementsByTagName( "*" );
+  if ( typeof elem.getElementsByTagName !== "undefined" ) {
+    return elem.getElementsByTagName( "*" );
 
-	} else if ( typeof elem.querySelectorAll !== "undefined" ) {
-		return elem.querySelectorAll( "*" );
+  } else if ( typeof elem.querySelectorAll !== "undefined" ) {
+    return elem.querySelectorAll( "*" );
 
-	} else {
-		return [];
-	}
+  } else {
+    return [];
+  }
 }
 
 // Used in clean, fixes the defaultChecked property
 function fixDefaultChecked( elem ) {
-	if ( elem.type === "checkbox" || elem.type === "radio" ) {
-		elem.defaultChecked = elem.checked;
-	}
+  if ( elem.type === "checkbox" || elem.type === "radio" ) {
+    elem.defaultChecked = elem.checked;
+  }
 }
 // Finds all inputs and passes them to fixDefaultChecked
 function findInputs( elem ) {
-	var nodeName = ( elem.nodeName || "" ).toLowerCase();
-	if ( nodeName === "input" ) {
-		fixDefaultChecked( elem );
-	// Skip scripts, get other children
-	} else if ( nodeName !== "script" && typeof elem.getElementsByTagName !== "undefined" ) {
-		jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );
-	}
+  var nodeName = ( elem.nodeName || "" ).toLowerCase();
+  if ( nodeName === "input" ) {
+    fixDefaultChecked( elem );
+  // Skip scripts, get other children
+  } else if ( nodeName !== "script" && typeof elem.getElementsByTagName !== "undefined" ) {
+    jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );
+  }
 }
 
 // Derived From: http://www.iecss.com/shimprove/javascript/shimprove.1-0-1.js
 function shimCloneNode( elem ) {
-	var div = document.createElement( "div" );
-	safeFragment.appendChild( div );
+  var div = document.createElement( "div" );
+  safeFragment.appendChild( div );
 
-	div.innerHTML = elem.outerHTML;
-	return div.firstChild;
+  div.innerHTML = elem.outerHTML;
+  return div.firstChild;
 }
 
 jQuery.extend({
-	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
-		var srcElements,
-			destElements,
-			i,
-			// IE<=8 does not properly clone detached, unknown element nodes
-			clone = jQuery.support.html5Clone || !rnoshimcache.test( "<" + elem.nodeName ) ?
-				elem.cloneNode( true ) :
-				shimCloneNode( elem );
-
-		if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
-				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
-			// IE copies events bound via attachEvent when using cloneNode.
-			// Calling detachEvent on the clone will also remove the events
-			// from the original. In order to get around this, we use some
-			// proprietary methods to clear the events. Thanks to MooTools
-			// guys for this hotness.
-
-			cloneFixAttributes( elem, clone );
-
-			// Using Sizzle here is crazy slow, so we use getElementsByTagName instead
-			srcElements = getAll( elem );
-			destElements = getAll( clone );
-
-			// Weird iteration because IE will replace the length property
-			// with an element if you are cloning the body and one of the
-			// elements on the page has a name or id of "length"
-			for ( i = 0; srcElements[i]; ++i ) {
-				// Ensure that the destination node is not null; Fixes #9587
-				if ( destElements[i] ) {
-					cloneFixAttributes( srcElements[i], destElements[i] );
-				}
-			}
-		}
-
-		// Copy the events from the original to the clone
-		if ( dataAndEvents ) {
-			cloneCopyEvent( elem, clone );
-
-			if ( deepDataAndEvents ) {
-				srcElements = getAll( elem );
-				destElements = getAll( clone );
-
-				for ( i = 0; srcElements[i]; ++i ) {
-					cloneCopyEvent( srcElements[i], destElements[i] );
-				}
-			}
-		}
-
-		srcElements = destElements = null;
-
-		// Return the cloned set
-		return clone;
-	},
-
-	clean: function( elems, context, fragment, scripts ) {
-		var checkScriptType;
-
-		context = context || document;
-
-		// !context.createElement fails in IE with an error but returns typeof 'object'
-		if ( typeof context.createElement === "undefined" ) {
-			context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
-		}
-
-		var ret = [], j;
-
-		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
-			if ( typeof elem === "number" ) {
-				elem += "";
-			}
-
-			if ( !elem ) {
-				continue;
-			}
-
-			// Convert html string into DOM nodes
-			if ( typeof elem === "string" ) {
-				if ( !rhtml.test( elem ) ) {
-					elem = context.createTextNode( elem );
-				} else {
-					// Fix "XHTML"-style tags in all browsers
-					elem = elem.replace(rxhtmlTag, "<$1></$2>");
-
-					// Trim whitespace, otherwise indexOf won't work as expected
-					var tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase(),
-						wrap = wrapMap[ tag ] || wrapMap._default,
-						depth = wrap[0],
-						div = context.createElement("div");
-
-					// Append wrapper element to unknown element safe doc fragment
-					if ( context === document ) {
-						// Use the fragment we've already created for this document
-						safeFragment.appendChild( div );
-					} else {
-						// Use a fragment created with the owner document
-						createSafeFragment( context ).appendChild( div );
-					}
-
-					// Go to html and back, then peel off extra wrappers
-					div.innerHTML = wrap[1] + elem + wrap[2];
-
-					// Move to the right depth
-					while ( depth-- ) {
-						div = div.lastChild;
-					}
-
-					// Remove IE's autoinserted <tbody> from table fragments
-					if ( !jQuery.support.tbody ) {
-
-						// String was a <table>, *may* have spurious <tbody>
-						var hasBody = rtbody.test(elem),
-							tbody = tag === "table" && !hasBody ?
-								div.firstChild && div.firstChild.childNodes :
-
-								// String was a bare <thead> or <tfoot>
-								wrap[1] === "<table>" && !hasBody ?
-									div.childNodes :
-									[];
-
-						for ( j = tbody.length - 1; j >= 0 ; --j ) {
-							if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
-								tbody[ j ].parentNode.removeChild( tbody[ j ] );
-							}
-						}
-					}
-
-					// IE completely kills leading whitespace when innerHTML is used
-					if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
-						div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
-					}
-
-					elem = div.childNodes;
-				}
-			}
-
-			// Resets defaultChecked for any radios and checkboxes
-			// about to be appended to the DOM in IE 6/7 (#8060)
-			var len;
-			if ( !jQuery.support.appendChecked ) {
-				if ( elem[0] && typeof (len = elem.length) === "number" ) {
-					for ( j = 0; j < len; j++ ) {
-						findInputs( elem[j] );
-					}
-				} else {
-					findInputs( elem );
-				}
-			}
-
-			if ( elem.nodeType ) {
-				ret.push( elem );
-			} else {
-				ret = jQuery.merge( ret, elem );
-			}
-		}
-
-		if ( fragment ) {
-			checkScriptType = function( elem ) {
-				return !elem.type || rscriptType.test( elem.type );
-			};
-			for ( i = 0; ret[i]; i++ ) {
-				if ( scripts && jQuery.nodeName( ret[i], "script" ) && (!ret[i].type || ret[i].type.toLowerCase() === "text/javascript") ) {
-					scripts.push( ret[i].parentNode ? ret[i].parentNode.removeChild( ret[i] ) : ret[i] );
-
-				} else {
-					if ( ret[i].nodeType === 1 ) {
-						var jsTags = jQuery.grep( ret[i].getElementsByTagName( "script" ), checkScriptType );
-
-						ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
-					}
-					fragment.appendChild( ret[i] );
-				}
-			}
-		}
-
-		return ret;
-	},
-
-	cleanData: function( elems ) {
-		var data, id,
-			cache = jQuery.cache,
-			special = jQuery.event.special,
-			deleteExpando = jQuery.support.deleteExpando;
-
-		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
-			if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {
-				continue;
-			}
-
-			id = elem[ jQuery.expando ];
-
-			if ( id ) {
-				data = cache[ id ];
-
-				if ( data && data.events ) {
-					for ( var type in data.events ) {
-						if ( special[ type ] ) {
-							jQuery.event.remove( elem, type );
-
-						// This is a shortcut to avoid jQuery.event.remove's overhead
-						} else {
-							jQuery.removeEvent( elem, type, data.handle );
-						}
-					}
-
-					// Null the DOM reference to avoid IE6/7/8 leak (#7054)
-					if ( data.handle ) {
-						data.handle.elem = null;
-					}
-				}
-
-				if ( deleteExpando ) {
-					delete elem[ jQuery.expando ];
-
-				} else if ( elem.removeAttribute ) {
-					elem.removeAttribute( jQuery.expando );
-				}
-
-				delete cache[ id ];
-			}
-		}
-	}
+  clone: function( elem, dataAndEvents, deepDataAndEvents ) {
+    var srcElements,
+      destElements,
+      i,
+      // IE<=8 does not properly clone detached, unknown element nodes
+      clone = jQuery.support.html5Clone || !rnoshimcache.test( "<" + elem.nodeName ) ?
+        elem.cloneNode( true ) :
+        shimCloneNode( elem );
+
+    if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
+        (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
+      // IE copies events bound via attachEvent when using cloneNode.
+      // Calling detachEvent on the clone will also remove the events
+      // from the original. In order to get around this, we use some
+      // proprietary methods to clear the events. Thanks to MooTools
+      // guys for this hotness.
+
+      cloneFixAttributes( elem, clone );
+
+      // Using Sizzle here is crazy slow, so we use getElementsByTagName instead
+      srcElements = getAll( elem );
+      destElements = getAll( clone );
+
+      // Weird iteration because IE will replace the length property
+      // with an element if you are cloning the body and one of the
+      // elements on the page has a name or id of "length"
+      for ( i = 0; srcElements[i]; ++i ) {
+        // Ensure that the destination node is not null; Fixes #9587
+        if ( destElements[i] ) {
+          cloneFixAttributes( srcElements[i], destElements[i] );
+        }
+      }
+    }
+
+    // Copy the events from the original to the clone
+    if ( dataAndEvents ) {
+      cloneCopyEvent( elem, clone );
+
+      if ( deepDataAndEvents ) {
+        srcElements = getAll( elem );
+        destElements = getAll( clone );
+
+        for ( i = 0; srcElements[i]; ++i ) {
+          cloneCopyEvent( srcElements[i], destElements[i] );
+        }
+      }
+    }
+
+    srcElements = destElements = null;
+
+    // Return the cloned set
+    return clone;
+  },
+
+  clean: function( elems, context, fragment, scripts ) {
+    var checkScriptType;
+
+    context = context || document;
+
+    // !context.createElement fails in IE with an error but returns typeof 'object'
+    if ( typeof context.createElement === "undefined" ) {
+      context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
+    }
+
+    var ret = [], j;
+
+    for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
+      if ( typeof elem === "number" ) {
+        elem += "";
+      }
+
+      if ( !elem ) {
+        continue;
+      }
+
+      // Convert html string into DOM nodes
+      if ( typeof elem === "string" ) {
+        if ( !rhtml.test( elem ) ) {
+          elem = context.createTextNode( elem );
+        } else {
+          // Fix "XHTML"-style tags in all browsers
+          elem = elem.replace(rxhtmlTag, "<$1></$2>");
+
+          // Trim whitespace, otherwise indexOf won't work as expected
+          var tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase(),
+            wrap = wrapMap[ tag ] || wrapMap._default,
+            depth = wrap[0],
+            div = context.createElement("div");
+
+          // Append wrapper element to unknown element safe doc fragment
+          if ( context === document ) {
+            // Use the fragment we've already created for this document
+            safeFragment.appendChild( div );
+          } else {
+            // Use a fragment created with the owner document
+            createSafeFragment( context ).appendChild( div );
+          }
+
+          // Go to html and back, then peel off extra wrappers
+          div.innerHTML = wrap[1] + elem + wrap[2];
+
+          // Move to the right depth
+          while ( depth-- ) {
+            div = div.lastChild;
+          }
+
+          // Remove IE's autoinserted <tbody> from table fragments
+          if ( !jQuery.support.tbody ) {
+
+            // String was a <table>, *may* have spurious <tbody>
+            var hasBody = rtbody.test(elem),
+              tbody = tag === "table" && !hasBody ?
+                div.firstChild && div.firstChild.childNodes :
+
+                // String was a bare <thead> or <tfoot>
+                wrap[1] === "<table>" && !hasBody ?
+                  div.childNodes :
+                  [];
+
+            for ( j = tbody.length - 1; j >= 0 ; --j ) {
+              if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
+                tbody[ j ].parentNode.removeChild( tbody[ j ] );
+              }
+            }
+          }
+
+          // IE completely kills leading whitespace when innerHTML is used
+          if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
+            div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
+          }
+
+          elem = div.childNodes;
+        }
+      }
+
+      // Resets defaultChecked for any radios and checkboxes
+      // about to be appended to the DOM in IE 6/7 (#8060)
+      var len;
+      if ( !jQuery.support.appendChecked ) {
+        if ( elem[0] && typeof (len = elem.length) === "number" ) {
+          for ( j = 0; j < len; j++ ) {
+            findInputs( elem[j] );
+          }
+        } else {
+          findInputs( elem );
+        }
+      }
+
+      if ( elem.nodeType ) {
+        ret.push( elem );
+      } else {
+        ret = jQuery.merge( ret, elem );
+      }
+    }
+
+    if ( fragment ) {
+      checkScriptType = function( elem ) {
+        return !elem.type || rscriptType.test( elem.type );
+      };
+      for ( i = 0; ret[i]; i++ ) {
+        if ( scripts && jQuery.nodeName( ret[i], "script" ) && (!ret[i].type || ret[i].type.toLowerCase() === "text/javascript") ) {
+          scripts.push( ret[i].parentNode ? ret[i].parentNode.removeChild( ret[i] ) : ret[i] );
+
+        } else {
+          if ( ret[i].nodeType === 1 ) {
+            var jsTags = jQuery.grep( ret[i].getElementsByTagName( "script" ), checkScriptType );
+
+            ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
+          }
+          fragment.appendChild( ret[i] );
+        }
+      }
+    }
+
+    return ret;
+  },
+
+  cleanData: function( elems ) {
+    var data, id,
+      cache = jQuery.cache,
+      special = jQuery.event.special,
+      deleteExpando = jQuery.support.deleteExpando;
+
+    for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
+      if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {
+        continue;
+      }
+
+      id = elem[ jQuery.expando ];
+
+      if ( id ) {
+        data = cache[ id ];
+
+        if ( data && data.events ) {
+          for ( var type in data.events ) {
+            if ( special[ type ] ) {
+              jQuery.event.remove( elem, type );
+
+            // This is a shortcut to avoid jQuery.event.remove's overhead
+            } else {
+              jQuery.removeEvent( elem, type, data.handle );
+            }
+          }
+
+          // Null the DOM reference to avoid IE6/7/8 leak (#7054)
+          if ( data.handle ) {
+            data.handle.elem = null;
+          }
+        }
+
+        if ( deleteExpando ) {
+          delete elem[ jQuery.expando ];
+
+        } else if ( elem.removeAttribute ) {
+          elem.removeAttribute( jQuery.expando );
+        }
+
+        delete cache[ id ];
+      }
+    }
+  }
 });
 
 function evalScript( i, elem ) {
-	if ( elem.src ) {
-		jQuery.ajax({
-			url: elem.src,
-			async: false,
-			dataType: "script"
-		});
-	} else {
-		jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || "" ).replace( rcleanScript, "/*$0*/" ) );
-	}
-
-	if ( elem.parentNode ) {
-		elem.parentNode.removeChild( elem );
-	}
+  if ( elem.src ) {
+    jQuery.ajax({
+      url: elem.src,
+      async: false,
+      dataType: "script"
+    });
+  } else {
+    jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || "" ).replace( rcleanScript, "/*$0*/" ) );
+  }
+
+  if ( elem.parentNode ) {
+    elem.parentNode.removeChild( elem );
+  }
 }
 
 
 
 
 var ralpha = /alpha\([^)]*\)/i,
-	ropacity = /opacity=([^)]*)/,
-	// fixed for IE9, see #8346
-	rupper = /([A-Z]|^ms)/g,
-	rnumpx = /^-?\d+(?:px)?$/i,
-	rnum = /^-?\d/,
-	rrelNum = /^([\-+])=([\-+.\de]+)/,
+  ropacity = /opacity=([^)]*)/,
+  // fixed for IE9, see #8346
+  rupper = /([A-Z]|^ms)/g,
+  rnumpx = /^-?\d+(?:px)?$/i,
+  rnum = /^-?\d/,
+  rrelNum = /^([\-+])=([\-+.\de]+)/,
 
-	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
-	cssWidth = [ "Left", "Right" ],
-	cssHeight = [ "Top", "Bottom" ],
-	curCSS,
+  cssShow = { position: "absolute", visibility: "hidden", display: "block" },
+  cssWidth = [ "Left", "Right" ],
+  cssHeight = [ "Top", "Bottom" ],
+  curCSS,
 
-	getComputedStyle,
-	currentStyle;
+  getComputedStyle,
+  currentStyle;
 
 jQuery.fn.css = function( name, value ) {
-	// Setting 'undefined' is a no-op
-	if ( arguments.length === 2 && value === undefined ) {
-		return this;
-	}
-
-	return jQuery.access( this, name, value, true, function( elem, name, value ) {
-		return value !== undefined ?
-			jQuery.style( elem, name, value ) :
-			jQuery.css( elem, name );
-	});
+  // Setting 'undefined' is a no-op
+  if ( arguments.length === 2 && value === undefined ) {
+    return this;
+  }
+
+  return jQuery.access( this, name, value, true, function( elem, name, value ) {
+    return value !== undefined ?
+      jQuery.style( elem, name, value ) :
+      jQuery.css( elem, name );
+  });
 };
 
 jQuery.extend({
-	// Add in style property hooks for overriding the default
-	// behavior of getting and setting a style property
-	cssHooks: {
-		opacity: {
-			get: function( elem, computed ) {
-				if ( computed ) {
-					// We should always get a number back from opacity
-					var ret = curCSS( elem, "opacity", "opacity" );
-					return ret === "" ? "1" : ret;
-
-				} else {
-					return elem.style.opacity;
-				}
-			}
-		}
-	},
-
-	// Exclude the following css properties to add px
-	cssNumber: {
-		"fillOpacity": true,
-		"fontWeight": true,
-		"lineHeight": true,
-		"opacity": true,
-		"orphans": true,
-		"widows": true,
-		"zIndex": true,
-		"zoom": true
-	},
-
-	// Add in properties whose names you wish to fix before
-	// setting or getting the value
-	cssProps: {
-		// normalize float css property
-		"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
-	},
-
-	// Get and set the style property on a DOM Node
-	style: function( elem, name, value, extra ) {
-		// Don't set styles on text and comment nodes
-		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
-			return;
-		}
-
-		// Make sure that we're working with the right name
-		var ret, type, origName = jQuery.camelCase( name ),
-			style = elem.style, hooks = jQuery.cssHooks[ origName ];
-
-		name = jQuery.cssProps[ origName ] || origName;
-
-		// Check if we're setting a value
-		if ( value !== undefined ) {
-			type = typeof value;
-
-			// convert relative number strings (+= or -=) to relative numbers. #7345
-			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
-				value = ( +( ret[1] + 1) * +ret[2] ) + parseFloat( jQuery.css( elem, name ) );
-				// Fixes bug #9237
-				type = "number";
-			}
-
-			// Make sure that NaN and null values aren't set. See: #7116
-			if ( value == null || type === "number" && isNaN( value ) ) {
-				return;
-			}
-
-			// If a number was passed in, add 'px' to the (except for certain CSS properties)
-			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
-				value += "px";
-			}
-
-			// If a hook was provided, use that value, otherwise just set the specified value
-			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value )) !== undefined ) {
-				// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
-				// Fixes bug #5509
-				try {
-					style[ name ] = value;
-				} catch(e) {}
-			}
-
-		} else {
-			// If a hook was provided get the non-computed value from there
-			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
-				return ret;
-			}
-
-			// Otherwise just get the value from the style object
-			return style[ name ];
-		}
-	},
-
-	css: function( elem, name, extra ) {
-		var ret, hooks;
-
-		// Make sure that we're working with the right name
-		name = jQuery.camelCase( name );
-		hooks = jQuery.cssHooks[ name ];
-		name = jQuery.cssProps[ name ] || name;
-
-		// cssFloat needs a special treatment
-		if ( name === "cssFloat" ) {
-			name = "float";
-		}
-
-		// If a hook was provided get the computed value from there
-		if ( hooks && "get" in hooks && (ret = hooks.get( elem, true, extra )) !== undefined ) {
-			return ret;
-
-		// Otherwise, if a way to get the computed value exists, use that
-		} else if ( curCSS ) {
-			return curCSS( elem, name );
-		}
-	},
-
-	// A method for quickly swapping in/out CSS properties to get correct calculations
-	swap: function( elem, options, callback ) {
-		var old = {};
-
-		// Remember the old values, and insert the new ones
-		for ( var name in options ) {
-			old[ name ] = elem.style[ name ];
-			elem.style[ name ] = options[ name ];
-		}
-
-		callback.call( elem );
-
-		// Revert the old values
-		for ( name in options ) {
-			elem.style[ name ] = old[ name ];
-		}
-	}
+  // Add in style property hooks for overriding the default
+  // behavior of getting and setting a style property
+  cssHooks: {
+    opacity: {
+      get: function( elem, computed ) {
+        if ( computed ) {
+          // We should always get a number back from opacity
+          var ret = curCSS( elem, "opacity", "opacity" );
+          return ret === "" ? "1" : ret;
+
+        } else {
+          return elem.style.opacity;
+        }
+      }
+    }
+  },
+
+  // Exclude the following css properties to add px
+  cssNumber: {
+    "fillOpacity": true,
+    "fontWeight": true,
+    "lineHeight": true,
+    "opacity": true,
+    "orphans": true,
+    "widows": true,
+    "zIndex": true,
+    "zoom": true
+  },
+
+  // Add in properties whose names you wish to fix before
+  // setting or getting the value
+  cssProps: {
+    // normalize float css property
+    "float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
+  },
+
+  // Get and set the style property on a DOM Node
+  style: function( elem, name, value, extra ) {
+    // Don't set styles on text and comment nodes
+    if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
+      return;
+    }
+
+    // Make sure that we're working with the right name
+    var ret, type, origName = jQuery.camelCase( name ),
+      style = elem.style, hooks = jQuery.cssHooks[ origName ];
+
+    name = jQuery.cssProps[ origName ] || origName;
+
+    // Check if we're setting a value
+    if ( value !== undefined ) {
+      type = typeof value;
+
+      // convert relative number strings (+= or -=) to relative numbers. #7345
+      if ( type === "string" && (ret = rrelNum.exec( value )) ) {
+        value = ( +( ret[1] + 1) * +ret[2] ) + parseFloat( jQuery.css( elem, name ) );
+        // Fixes bug #9237
+        type = "number";
+      }
+
+      // Make sure that NaN and null values aren't set. See: #7116
+      if ( value == null || type === "number" && isNaN( value ) ) {
+        return;
+      }
+
+      // If a number was passed in, add 'px' to the (except for certain CSS properties)
+      if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
+        value += "px";
+      }
+
+      // If a hook was provided, use that value, otherwise just set the specified value
+      if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value )) !== undefined ) {
+        // Wrapped to prevent IE from throwing errors when 'invalid' values are provided
+        // Fixes bug #5509
+        try {
+          style[ name ] = value;
+        } catch(e) {}
+      }
+
+    } else {
+      // If a hook was provided get the non-computed value from there
+      if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
+        return ret;
+      }
+
+      // Otherwise just get the value from the style object
+      return style[ name ];
+    }
+  },
+
+  css: function( elem, name, extra ) {
+    var ret, hooks;
+
+    // Make sure that we're working with the right name
+    name = jQuery.camelCase( name );
+    hooks = jQuery.cssHooks[ name ];
+    name = jQuery.cssProps[ name ] || name;
+
+    // cssFloat needs a special treatment
+    if ( name === "cssFloat" ) {
+      name = "float";
+    }
+
+    // If a hook was provided get the computed value from there
+    if ( hooks && "get" in hooks && (ret = hooks.get( elem, true, extra )) !== undefined ) {
+      return ret;
+
+    // Otherwise, if a way to get the computed value exists, use that
+    } else if ( curCSS ) {
+      return curCSS( elem, name );
+    }
+  },
+
+  // A method for quickly swapping in/out CSS properties to get correct calculations
+  swap: function( elem, options, callback ) {
+    var old = {};
+
+    // Remember the old values, and insert the new ones
+    for ( var name in options ) {
+      old[ name ] = elem.style[ name ];
+      elem.style[ name ] = options[ name ];
+    }
+
+    callback.call( elem );
+
+    // Revert the old values
+    for ( name in options ) {
+      elem.style[ name ] = old[ name ];
+    }
+  }
 });
 
 // DEPRECATED, Use jQuery.css() instead
 jQuery.curCSS = jQuery.css;
 
 jQuery.each(["height", "width"], function( i, name ) {
-	jQuery.cssHooks[ name ] = {
-		get: function( elem, computed, extra ) {
-			var val;
-
-			if ( computed ) {
-				if ( elem.offsetWidth !== 0 ) {
-					return getWH( elem, name, extra );
-				} else {
-					jQuery.swap( elem, cssShow, function() {
-						val = getWH( elem, name, extra );
-					});
-				}
-
-				return val;
-			}
-		},
-
-		set: function( elem, value ) {
-			if ( rnumpx.test( value ) ) {
-				// ignore negative width and height values #1599
-				value = parseFloat( value );
-
-				if ( value >= 0 ) {
-					return value + "px";
-				}
-
-			} else {
-				return value;
-			}
-		}
-	};
+  jQuery.cssHooks[ name ] = {
+    get: function( elem, computed, extra ) {
+      var val;
+
+      if ( computed ) {
+        if ( elem.offsetWidth !== 0 ) {
+          return getWH( elem, name, extra );
+        } else {
+          jQuery.swap( elem, cssShow, function() {
+            val = getWH( elem, name, extra );
+          });
+        }
+
+        return val;
+      }
+    },
+
+    set: function( elem, value ) {
+      if ( rnumpx.test( value ) ) {
+        // ignore negative width and height values #1599
+        value = parseFloat( value );
+
+        if ( value >= 0 ) {
+          return value + "px";
+        }
+
+      } else {
+        return value;
+      }
+    }
+  };
 });
 
 if ( !jQuery.support.opacity ) {
-	jQuery.cssHooks.opacity = {
-		get: function( elem, computed ) {
-			// IE uses filters for opacity
-			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
-				( parseFloat( RegExp.$1 ) / 100 ) + "" :
-				computed ? "1" : "";
-		},
-
-		set: function( elem, value ) {
-			var style = elem.style,
-				currentStyle = elem.currentStyle,
-				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
-				filter = currentStyle && currentStyle.filter || style.filter || "";
-
-			// IE has trouble with opacity if it does not have layout
-			// Force it by setting the zoom level
-			style.zoom = 1;
-
-			// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
-			if ( value >= 1 && jQuery.trim( filter.replace( ralpha, "" ) ) === "" ) {
-
-				// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
-				// if "filter:" is present at all, clearType is disabled, we want to avoid this
-				// style.removeAttribute is IE Only, but so apparently is this code path...
-				style.removeAttribute( "filter" );
-
-				// if there there is no filter style applied in a css rule, we are done
-				if ( currentStyle && !currentStyle.filter ) {
-					return;
-				}
-			}
-
-			// otherwise, set new filter values
-			style.filter = ralpha.test( filter ) ?
-				filter.replace( ralpha, opacity ) :
-				filter + " " + opacity;
-		}
-	};
+  jQuery.cssHooks.opacity = {
+    get: function( elem, computed ) {
+      // IE uses filters for opacity
+      return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
+        ( parseFloat( RegExp.$1 ) / 100 ) + "" :
+        computed ? "1" : "";
+    },
+
+    set: function( elem, value ) {
+      var style = elem.style,
+        currentStyle = elem.currentStyle,
+        opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
+        filter = currentStyle && currentStyle.filter || style.filter || "";
+
+      // IE has trouble with opacity if it does not have layout
+      // Force it by setting the zoom level
+      style.zoom = 1;
+
+      // if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
+      if ( value >= 1 && jQuery.trim( filter.replace( ralpha, "" ) ) === "" ) {
+
+        // Setting style.filter to null, "" & " " still leave "filter:" in the cssText
+        // if "filter:" is present at all, clearType is disabled, we want to avoid this
+        // style.removeAttribute is IE Only, but so apparently is this code path...
+        style.removeAttribute( "filter" );
+
+        // if there there is no filter style applied in a css rule, we are done
+        if ( currentStyle && !currentStyle.filter ) {
+          return;
+        }
+      }
+
+      // otherwise, set new filter values
+      style.filter = ralpha.test( filter ) ?
+        filter.replace( ralpha, opacity ) :
+        filter + " " + opacity;
+    }
+  };
 }
 
 jQuery(function() {
-	// This hook cannot be added until DOM ready because the support test
-	// for it is not run until after DOM ready
-	if ( !jQuery.support.reliableMarginRight ) {
-		jQuery.cssHooks.marginRight = {
-			get: function( elem, computed ) {
-				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
-				// Work around by temporarily setting element display to inline-block
-				var ret;
-				jQuery.swap( elem, { "display": "inline-block" }, function() {
-					if ( computed ) {
-						ret = curCSS( elem, "margin-right", "marginRight" );
-					} else {
-						ret = elem.style.marginRight;
-					}
-				});
-				return ret;
-			}
-		};
-	}
+  // This hook cannot be added until DOM ready because the support test
+  // for it is not run until after DOM ready
+  if ( !jQuery.support.reliableMarginRight ) {
+    jQuery.cssHooks.marginRight = {
+      get: function( elem, computed ) {
+        // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
+        // Work around by temporarily setting element display to inline-block
+        var ret;
+        jQuery.swap( elem, { "display": "inline-block" }, function() {
+          if ( computed ) {
+            ret = curCSS( elem, "margin-right", "marginRight" );
+          } else {
+            ret = elem.style.marginRight;
+          }
+        });
+        return ret;
+      }
+    };
+  }
 });
 
 if ( document.defaultView && document.defaultView.getComputedStyle ) {
-	getComputedStyle = function( elem, name ) {
-		var ret, defaultView, computedStyle;
+  getComputedStyle = function( elem, name ) {
+    var ret, defaultView, computedStyle;
 
-		name = name.replace( rupper, "-$1" ).toLowerCase();
+    name = name.replace( rupper, "-$1" ).toLowerCase();
 
-		if ( (defaultView = elem.ownerDocument.defaultView) &&
-				(computedStyle = defaultView.getComputedStyle( elem, null )) ) {
-			ret = computedStyle.getPropertyValue( name );
-			if ( ret === "" && !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
-				ret = jQuery.style( elem, name );
-			}
-		}
+    if ( (defaultView = elem.ownerDocument.defaultView) &&
+        (computedStyle = defaultView.getComputedStyle( elem, null )) ) {
+      ret = computedStyle.getPropertyValue( name );
+      if ( ret === "" && !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
+        ret = jQuery.style( elem, name );
+      }
+    }
 
-		return ret;
-	};
+    return ret;
+  };
 }
 
 if ( document.documentElement.currentStyle ) {
-	currentStyle = function( elem, name ) {
-		var left, rsLeft, uncomputed,
-			ret = elem.currentStyle && elem.currentStyle[ name ],
-			style = elem.style;
-
-		// Avoid setting ret to empty string here
-		// so we don't default to auto
-		if ( ret === null && style && (uncomputed = style[ name ]) ) {
-			ret = uncomputed;
-		}
-
-		// From the awesome hack by Dean Edwards
-		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
-
-		// If we're not dealing with a regular pixel number
-		// but a number that has a weird ending, we need to convert it to pixels
-		if ( !rnumpx.test( ret ) && rnum.test( ret ) ) {
-
-			// Remember the original values
-			left = style.left;
-			rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;
-
-			// Put in the new values to get a computed value out
-			if ( rsLeft ) {
-				elem.runtimeStyle.left = elem.currentStyle.left;
-			}
-			style.left = name === "fontSize" ? "1em" : ( ret || 0 );
-			ret = style.pixelLeft + "px";
-
-			// Revert the changed values
-			style.left = left;
-			if ( rsLeft ) {
-				elem.runtimeStyle.left = rsLeft;
-			}
-		}
-
-		return ret === "" ? "auto" : ret;
-	};
+  currentStyle = function( elem, name ) {
+    var left, rsLeft, uncomputed,
+      ret = elem.currentStyle && elem.currentStyle[ name ],
+      style = elem.style;
+
+    // Avoid setting ret to empty string here
+    // so we don't default to auto
+    if ( ret === null && style && (uncomputed = style[ name ]) ) {
+      ret = uncomputed;
+    }
+
+    // From the awesome hack by Dean Edwards
+    // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
+
+    // If we're not dealing with a regular pixel number
+    // but a number that has a weird ending, we need to convert it to pixels
+    if ( !rnumpx.test( ret ) && rnum.test( ret ) ) {
+
+      // Remember the original values
+      left = style.left;
+      rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;
+
+      // Put in the new values to get a computed value out
+      if ( rsLeft ) {
+        elem.runtimeStyle.left = elem.currentStyle.left;
+      }
+      style.left = name === "fontSize" ? "1em" : ( ret || 0 );
+      ret = style.pixelLeft + "px";
+
+      // Revert the changed values
+      style.left = left;
+      if ( rsLeft ) {
+        elem.runtimeStyle.left = rsLeft;
+      }
+    }
+
+    return ret === "" ? "auto" : ret;
+  };
 }
 
 curCSS = getComputedStyle || currentStyle;
 
 function getWH( elem, name, extra ) {
 
-	// Start with offset property
-	var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
-		which = name === "width" ? cssWidth : cssHeight,
-		i = 0,
-		len = which.length;
-
-	if ( val > 0 ) {
-		if ( extra !== "border" ) {
-			for ( ; i < len; i++ ) {
-				if ( !extra ) {
-					val -= parseFloat( jQuery.css( elem, "padding" + which[ i ] ) ) || 0;
-				}
-				if ( extra === "margin" ) {
-					val += parseFloat( jQuery.css( elem, extra + which[ i ] ) ) || 0;
-				} else {
-					val -= parseFloat( jQuery.css( elem, "border" + which[ i ] + "Width" ) ) || 0;
-				}
-			}
-		}
-
-		return val + "px";
-	}
-
-	// Fall back to computed then uncomputed css if necessary
-	val = curCSS( elem, name, name );
-	if ( val < 0 || val == null ) {
-		val = elem.style[ name ] || 0;
-	}
-	// Normalize "", auto, and prepare for extra
-	val = parseFloat( val ) || 0;
-
-	// Add padding, border, margin
-	if ( extra ) {
-		for ( ; i < len; i++ ) {
-			val += parseFloat( jQuery.css( elem, "padding" + which[ i ] ) ) || 0;
-			if ( extra !== "padding" ) {
-				val += parseFloat( jQuery.css( elem, "border" + which[ i ] + "Width" ) ) || 0;
-			}
-			if ( extra === "margin" ) {
-				val += parseFloat( jQuery.css( elem, extra + which[ i ] ) ) || 0;
-			}
-		}
-	}
-
-	return val + "px";
+  // Start with offset property
+  var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
+    which = name === "width" ? cssWidth : cssHeight,
+    i = 0,
+    len = which.length;
+
+  if ( val > 0 ) {
+    if ( extra !== "border" ) {
+      for ( ; i < len; i++ ) {
+        if ( !extra ) {
+          val -= parseFloat( jQuery.css( elem, "padding" + which[ i ] ) ) || 0;
+        }
+        if ( extra === "margin" ) {
+          val += parseFloat( jQuery.css( elem, extra + which[ i ] ) ) || 0;
+        } else {
+          val -= parseFloat( jQuery.css( elem, "border" + which[ i ] + "Width" ) ) || 0;
+        }
+      }
+    }
+
+    return val + "px";
+  }
+
+  // Fall back to computed then uncomputed css if necessary
+  val = curCSS( elem, name, name );
+  if ( val < 0 || val == null ) {
+    val = elem.style[ name ] || 0;
+  }
+  // Normalize "", auto, and prepare for extra
+  val = parseFloat( val ) || 0;
+
+  // Add padding, border, margin
+  if ( extra ) {
+    for ( ; i < len; i++ ) {
+      val += parseFloat( jQuery.css( elem, "padding" + which[ i ] ) ) || 0;
+      if ( extra !== "padding" ) {
+        val += parseFloat( jQuery.css( elem, "border" + which[ i ] + "Width" ) ) || 0;
+      }
+      if ( extra === "margin" ) {
+        val += parseFloat( jQuery.css( elem, extra + which[ i ] ) ) || 0;
+      }
+    }
+  }
+
+  return val + "px";
 }
 
 if ( jQuery.expr && jQuery.expr.filters ) {
-	jQuery.expr.filters.hidden = function( elem ) {
-		var width = elem.offsetWidth,
-			height = elem.offsetHeight;
+  jQuery.expr.filters.hidden = function( elem ) {
+    var width = elem.offsetWidth,
+      height = elem.offsetHeight;
 
-		return ( width === 0 && height === 0 ) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
-	};
+    return ( width === 0 && height === 0 ) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
+  };
 
-	jQuery.expr.filters.visible = function( elem ) {
-		return !jQuery.expr.filters.hidden( elem );
-	};
+  jQuery.expr.filters.visible = function( elem ) {
+    return !jQuery.expr.filters.hidden( elem );
+  };
 }
 
 
 
 
 var r20 = /%20/g,
-	rbracket = /\[\]$/,
-	rCRLF = /\r?\n/g,
-	rhash = /#.*$/,
-	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
-	rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
-	// #7653, #8125, #8152: local protocol detection
-	rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
-	rnoContent = /^(?:GET|HEAD)$/,
-	rprotocol = /^\/\//,
-	rquery = /\?/,
-	rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
-	rselectTextarea = /^(?:select|textarea)/i,
-	rspacesAjax = /\s+/,
-	rts = /([?&])_=[^&]*/,
-	rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,
-
-	// Keep a copy of the old load method
-	_load = jQuery.fn.load,
-
-	/* Prefilters
-	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
-	 * 2) These are called:
-	 *    - BEFORE asking for a transport
-	 *    - AFTER param serialization (s.data is a string if s.processData is true)
-	 * 3) key is the dataType
-	 * 4) the catchall symbol "*" can be used
-	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
-	 */
-	prefilters = {},
-
-	/* Transports bindings
-	 * 1) key is the dataType
-	 * 2) the catchall symbol "*" can be used
-	 * 3) selection will start with transport dataType and THEN go to "*" if needed
-	 */
-	transports = {},
-
-	// Document location
-	ajaxLocation,
-
-	// Document location segments
-	ajaxLocParts,
-
-	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
-	allTypes = ["*/"] + ["*"];
+  rbracket = /\[\]$/,
+  rCRLF = /\r?\n/g,
+  rhash = /#.*$/,
+  rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
+  rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
+  // #7653, #8125, #8152: local protocol detection
+  rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
+  rnoContent = /^(?:GET|HEAD)$/,
+  rprotocol = /^\/\//,
+  rquery = /\?/,
+  rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
+  rselectTextarea = /^(?:select|textarea)/i,
+  rspacesAjax = /\s+/,
+  rts = /([?&])_=[^&]*/,
+  rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,
+
+  // Keep a copy of the old load method
+  _load = jQuery.fn.load,
+
+  /* Prefilters
+   * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
+   * 2) These are called:
+   *    - BEFORE asking for a transport
+   *    - AFTER param serialization (s.data is a string if s.processData is true)
+   * 3) key is the dataType
+   * 4) the catchall symbol "*" can be used
+   * 5) execution will start with transport dataType and THEN continue down to "*" if needed
+   */
+  prefilters = {},
+
+  /* Transports bindings
+   * 1) key is the dataType
+   * 2) the catchall symbol "*" can be used
+   * 3) selection will start with transport dataType and THEN go to "*" if needed
+   */
+  transports = {},
+
+  // Document location
+  ajaxLocation,
+
+  // Document location segments
+  ajaxLocParts,
+
+  // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
+  allTypes = ["*/"] + ["*"];
 
 // #8138, IE may throw an exception when accessing
 // a field from window.location if document.domain has been set
 try {
-	ajaxLocation = location.href;
+  ajaxLocation = location.href;
 } catch( e ) {
-	// Use the href attribute of an A element
-	// since IE will modify it given document.location
-	ajaxLocation = document.createElement( "a" );
-	ajaxLocation.href = "";
-	ajaxLocation = ajaxLocation.href;
+  // Use the href attribute of an A element
+  // since IE will modify it given document.location
+  ajaxLocation = document.createElement( "a" );
+  ajaxLocation.href = "";
+  ajaxLocation = ajaxLocation.href;
 }
 
 // Segment location into parts
@@ -8974,784 +8974,784 @@ ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];
 // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
 function addToPrefiltersOrTransports( structure ) {
 
-	// dataTypeExpression is optional and defaults to "*"
-	return function( dataTypeExpression, func ) {
-
-		if ( typeof dataTypeExpression !== "string" ) {
-			func = dataTypeExpression;
-			dataTypeExpression = "*";
-		}
-
-		if ( jQuery.isFunction( func ) ) {
-			var dataTypes = dataTypeExpression.toLowerCase().split( rspacesAjax ),
-				i = 0,
-				length = dataTypes.length,
-				dataType,
-				list,
-				placeBefore;
-
-			// For each dataType in the dataTypeExpression
-			for ( ; i < length; i++ ) {
-				dataType = dataTypes[ i ];
-				// We control if we're asked to add before
-				// any existing element
-				placeBefore = /^\+/.test( dataType );
-				if ( placeBefore ) {
-					dataType = dataType.substr( 1 ) || "*";
-				}
-				list = structure[ dataType ] = structure[ dataType ] || [];
-				// then we add to the structure accordingly
-				list[ placeBefore ? "unshift" : "push" ]( func );
-			}
-		}
-	};
+  // dataTypeExpression is optional and defaults to "*"
+  return function( dataTypeExpression, func ) {
+
+    if ( typeof dataTypeExpression !== "string" ) {
+      func = dataTypeExpression;
+      dataTypeExpression = "*";
+    }
+
+    if ( jQuery.isFunction( func ) ) {
+      var dataTypes = dataTypeExpression.toLowerCase().split( rspacesAjax ),
+        i = 0,
+        length = dataTypes.length,
+        dataType,
+        list,
+        placeBefore;
+
+      // For each dataType in the dataTypeExpression
+      for ( ; i < length; i++ ) {
+        dataType = dataTypes[ i ];
+        // We control if we're asked to add before
+        // any existing element
+        placeBefore = /^\+/.test( dataType );
+        if ( placeBefore ) {
+          dataType = dataType.substr( 1 ) || "*";
+        }
+        list = structure[ dataType ] = structure[ dataType ] || [];
+        // then we add to the structure accordingly
+        list[ placeBefore ? "unshift" : "push" ]( func );
+      }
+    }
+  };
+}
+
+// Base inspection function for prefilters and transports
+function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
+    dataType /* internal */, inspected /* internal */ ) {
+
+  dataType = dataType || options.dataTypes[ 0 ];
+  inspected = inspected || {};
+
+  inspected[ dataType ] = true;
+
+  var list = structure[ dataType ],
+    i = 0,
+    length = list ? list.length : 0,
+    executeOnly = ( structure === prefilters ),
+    selection;
+
+  for ( ; i < length && ( executeOnly || !selection ); i++ ) {
+    selection = list[ i ]( options, originalOptions, jqXHR );
+    // If we got redirected to another dataType
+    // we try there if executing only and not done already
+    if ( typeof selection === "string" ) {
+      if ( !executeOnly || inspected[ selection ] ) {
+        selection = undefined;
+      } else {
+        options.dataTypes.unshift( selection );
+        selection = inspectPrefiltersOrTransports(
+            structure, options, originalOptions, jqXHR, selection, inspected );
+      }
+    }
+  }
+  // If we're only executing or nothing was selected
+  // we try the catchall dataType if not done already
+  if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
+    selection = inspectPrefiltersOrTransports(
+        structure, options, originalOptions, jqXHR, "*", inspected );
+  }
+  // unnecessary when only executing (prefilters)
+  // but it'll be ignored by the caller in that case
+  return selection;
+}
+
+// A special extend for ajax options
+// that takes "flat" options (not to be deep extended)
+// Fixes #9887
+function ajaxExtend( target, src ) {
+  var key, deep,
+    flatOptions = jQuery.ajaxSettings.flatOptions || {};
+  for ( key in src ) {
+    if ( src[ key ] !== undefined ) {
+      ( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
+    }
+  }
+  if ( deep ) {
+    jQuery.extend( true, target, deep );
+  }
 }
 
-// Base inspection function for prefilters and transports
-function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
-		dataType /* internal */, inspected /* internal */ ) {
-
-	dataType = dataType || options.dataTypes[ 0 ];
-	inspected = inspected || {};
-
-	inspected[ dataType ] = true;
-
-	var list = structure[ dataType ],
-		i = 0,
-		length = list ? list.length : 0,
-		executeOnly = ( structure === prefilters ),
-		selection;
-
-	for ( ; i < length && ( executeOnly || !selection ); i++ ) {
-		selection = list[ i ]( options, originalOptions, jqXHR );
-		// If we got redirected to another dataType
-		// we try there if executing only and not done already
-		if ( typeof selection === "string" ) {
-			if ( !executeOnly || inspected[ selection ] ) {
-				selection = undefined;
-			} else {
-				options.dataTypes.unshift( selection );
-				selection = inspectPrefiltersOrTransports(
-						structure, options, originalOptions, jqXHR, selection, inspected );
-			}
-		}
-	}
-	// If we're only executing or nothing was selected
-	// we try the catchall dataType if not done already
-	if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
-		selection = inspectPrefiltersOrTransports(
-				structure, options, originalOptions, jqXHR, "*", inspected );
-	}
-	// unnecessary when only executing (prefilters)
-	// but it'll be ignored by the caller in that case
-	return selection;
-}
+jQuery.fn.extend({
+  load: function( url, params, callback ) {
+    if ( typeof url !== "string" && _load ) {
+      return _load.apply( this, arguments );
+
+    // Don't do a request if no elements are being requested
+    } else if ( !this.length ) {
+      return this;
+    }
+
+    var off = url.indexOf( " " );
+    if ( off >= 0 ) {
+      var selector = url.slice( off, url.length );
+      url = url.slice( 0, off );
+    }
+
+    // Default to a GET request
+    var type = "GET";
+
+    // If the second parameter was provided
+    if ( params ) {
+      // If it's a function
+      if ( jQuery.isFunction( params ) ) {
+        // We assume that it's the callback
+        callback = params;
+        params = undefined;
+
+      // Otherwise, build a param string
+      } else if ( typeof params === "object" ) {
+        params = jQuery.param( params, jQuery.ajaxSettings.traditional );
+        type = "POST";
+      }
+    }
+
+    var self = this;
+
+    // Request the remote document
+    jQuery.ajax({
+      url: url,
+      type: type,
+      dataType: "html",
+      data: params,
+      // Complete callback (responseText is used internally)
+      complete: function( jqXHR, status, responseText ) {
+        // Store the response as specified by the jqXHR object
+        responseText = jqXHR.responseText;
+        // If successful, inject the HTML into all the matched elements
+        if ( jqXHR.isResolved() ) {
+          // #4825: Get the actual response in case
+          // a dataFilter is present in ajaxSettings
+          jqXHR.done(function( r ) {
+            responseText = r;
+          });
+          // See if a selector was specified
+          self.html( selector ?
+            // Create a dummy div to hold the results
+            jQuery("<div>")
+              // inject the contents of the document in, removing the scripts
+              // to avoid any 'Permission Denied' errors in IE
+              .append(responseText.replace(rscript, ""))
+
+              // Locate the specified elements
+              .find(selector) :
+
+            // If not, just inject the full result
+            responseText );
+        }
+
+        if ( callback ) {
+          self.each( callback, [ responseText, status, jqXHR ] );
+        }
+      }
+    });
+
+    return this;
+  },
+
+  serialize: function() {
+    return jQuery.param( this.serializeArray() );
+  },
+
+  serializeArray: function() {
+    return this.map(function(){
+      return this.elements ? jQuery.makeArray( this.elements ) : this;
+    })
+    .filter(function(){
+      return this.name && !this.disabled &&
+        ( this.checked || rselectTextarea.test( this.nodeName ) ||
+          rinput.test( this.type ) );
+    })
+    .map(function( i, elem ){
+      var val = jQuery( this ).val();
+
+      return val == null ?
+        null :
+        jQuery.isArray( val ) ?
+          jQuery.map( val, function( val, i ){
+            return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
+          }) :
+          { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
+    }).get();
+  }
+});
+
+// Attach a bunch of functions for handling common AJAX events
+jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
+  jQuery.fn[ o ] = function( f ){
+    return this.on( o, f );
+  };
+});
+
+jQuery.each( [ "get", "post" ], function( i, method ) {
+  jQuery[ method ] = function( url, data, callback, type ) {
+    // shift arguments if data argument was omitted
+    if ( jQuery.isFunction( data ) ) {
+      type = type || callback;
+      callback = data;
+      data = undefined;
+    }
+
+    return jQuery.ajax({
+      type: method,
+      url: url,
+      data: data,
+      success: callback,
+      dataType: type
+    });
+  };
+});
+
+jQuery.extend({
+
+  getScript: function( url, callback ) {
+    return jQuery.get( url, undefined, callback, "script" );
+  },
+
+  getJSON: function( url, data, callback ) {
+    return jQuery.get( url, data, callback, "json" );
+  },
+
+  // Creates a full fledged settings object into target
+  // with both ajaxSettings and settings fields.
+  // If target is omitted, writes into ajaxSettings.
+  ajaxSetup: function( target, settings ) {
+    if ( settings ) {
+      // Building a settings object
+      ajaxExtend( target, jQuery.ajaxSettings );
+    } else {
+      // Extending ajaxSettings
+      settings = target;
+      target = jQuery.ajaxSettings;
+    }
+    ajaxExtend( target, settings );
+    return target;
+  },
+
+  ajaxSettings: {
+    url: ajaxLocation,
+    isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
+    global: true,
+    type: "GET",
+    contentType: "application/x-www-form-urlencoded",
+    processData: true,
+    async: true,
+    /*
+    timeout: 0,
+    data: null,
+    dataType: null,
+    username: null,
+    password: null,
+    cache: null,
+    traditional: false,
+    headers: {},
+    */
+
+    accepts: {
+      xml: "application/xml, text/xml",
+      html: "text/html",
+      text: "text/plain",
+      json: "application/json, text/javascript",
+      "*": allTypes
+    },
+
+    contents: {
+      xml: /xml/,
+      html: /html/,
+      json: /json/
+    },
+
+    responseFields: {
+      xml: "responseXML",
+      text: "responseText"
+    },
+
+    // List of data converters
+    // 1) key format is "source_type destination_type" (a single space in-between)
+    // 2) the catchall symbol "*" can be used for source_type
+    converters: {
+
+      // Convert anything to text
+      "* text": window.String,
+
+      // Text to html (true = no transformation)
+      "text html": true,
+
+      // Evaluate text as a json expression
+      "text json": jQuery.parseJSON,
+
+      // Parse text as xml
+      "text xml": jQuery.parseXML
+    },
+
+    // For options that shouldn't be deep extended:
+    // you can add your own custom options here if
+    // and when you create one that shouldn't be
+    // deep extended (see ajaxExtend)
+    flatOptions: {
+      context: true,
+      url: true
+    }
+  },
+
+  ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
+  ajaxTransport: addToPrefiltersOrTransports( transports ),
+
+  // Main method
+  ajax: function( url, options ) {
+
+    // If url is an object, simulate pre-1.5 signature
+    if ( typeof url === "object" ) {
+      options = url;
+      url = undefined;
+    }
+
+    // Force options to be an object
+    options = options || {};
+
+    var // Create the final options object
+      s = jQuery.ajaxSetup( {}, options ),
+      // Callbacks context
+      callbackContext = s.context || s,
+      // Context for global events
+      // It's the callbackContext if one was provided in the options
+      // and if it's a DOM node or a jQuery collection
+      globalEventContext = callbackContext !== s &&
+        ( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
+            jQuery( callbackContext ) : jQuery.event,
+      // Deferreds
+      deferred = jQuery.Deferred(),
+      completeDeferred = jQuery.Callbacks( "once memory" ),
+      // Status-dependent callbacks
+      statusCode = s.statusCode || {},
+      // ifModified key
+      ifModifiedKey,
+      // Headers (they are sent all at once)
+      requestHeaders = {},
+      requestHeadersNames = {},
+      // Response headers
+      responseHeadersString,
+      responseHeaders,
+      // transport
+      transport,
+      // timeout handle
+      timeoutTimer,
+      // Cross-domain detection vars
+      parts,
+      // The jqXHR state
+      state = 0,
+      // To know if global events are to be dispatched
+      fireGlobals,
+      // Loop variable
+      i,
+      // Fake xhr
+      jqXHR = {
+
+        readyState: 0,
+
+        // Caches the header
+        setRequestHeader: function( name, value ) {
+          if ( !state ) {
+            var lname = name.toLowerCase();
+            name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
+            requestHeaders[ name ] = value;
+          }
+          return this;
+        },
+
+        // Raw string
+        getAllResponseHeaders: function() {
+          return state === 2 ? responseHeadersString : null;
+        },
+
+        // Builds headers hashtable if needed
+        getResponseHeader: function( key ) {
+          var match;
+          if ( state === 2 ) {
+            if ( !responseHeaders ) {
+              responseHeaders = {};
+              while( ( match = rheaders.exec( responseHeadersString ) ) ) {
+                responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
+              }
+            }
+            match = responseHeaders[ key.toLowerCase() ];
+          }
+          return match === undefined ? null : match;
+        },
+
+        // Overrides response content-type header
+        overrideMimeType: function( type ) {
+          if ( !state ) {
+            s.mimeType = type;
+          }
+          return this;
+        },
+
+        // Cancel the request
+        abort: function( statusText ) {
+          statusText = statusText || "abort";
+          if ( transport ) {
+            transport.abort( statusText );
+          }
+          done( 0, statusText );
+          return this;
+        },
+
+        url : s.url,
+        data : s.data
+      };
+
+    // Callback for when everything is done
+    // It is defined here because jslint complains if it is declared
+    // at the end of the function (which would be more logical and readable)
+    function done( status, nativeStatusText, responses, headers ) {
+
+      // Called once
+      if ( state === 2 ) {
+        return;
+      }
+
+      // State is "done" now
+      state = 2;
+
+      // Clear timeout if it exists
+      if ( timeoutTimer ) {
+        clearTimeout( timeoutTimer );
+      }
+
+      // Dereference transport for early garbage collection
+      // (no matter how long the jqXHR object will be used)
+      transport = undefined;
+
+      // Cache response headers
+      responseHeadersString = headers || "";
+
+      // Set readyState
+      jqXHR.readyState = status > 0 ? 4 : 0;
+
+      var isSuccess,
+        success,
+        error,
+        statusText = nativeStatusText,
+        response = responses ? ajaxHandleResponses( s, jqXHR, responses ) : undefined,
+        lastModified,
+        etag;
+
+      // If successful, handle type chaining
+      if ( status >= 200 && status < 300 || status === 304 ) {
+
+        // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
+        if ( s.ifModified ) {
+
+          if ( ( lastModified = jqXHR.getResponseHeader( "Last-Modified" ) ) ) {
+            jQuery.lastModified[ ifModifiedKey ] = lastModified;
+          }
+          if ( ( etag = jqXHR.getResponseHeader( "Etag" ) ) ) {
+            jQuery.etag[ ifModifiedKey ] = etag;
+          }
+        }
+
+        // If not modified
+        if ( status === 304 ) {
+
+          statusText = "notmodified";
+          isSuccess = true;
+
+        // If we have data
+        } else {
+
+          try {
+            success = ajaxConvert( s, response );
+            statusText = "success";
+            isSuccess = true;
+          } catch(e) {
+            // We have a parsererror
+            statusText = "parsererror";
+            error = e;
+          }
+        }
+      } else {
+        // We extract error from statusText
+        // then normalize statusText and status for non-aborts
+        error = statusText;
+        if ( !statusText || status ) {
+          statusText = "error";
+          if ( status < 0 ) {
+            status = 0;
+          }
+        }
+      }
+
+      // Set data for the fake xhr object
+      jqXHR.status = status;
+      jqXHR.statusText = "" + ( nativeStatusText || statusText );
+
+      // Success/Error
+      if ( isSuccess ) {
+        deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
+      } else {
+        deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
+      }
+
+      // Status-dependent callbacks
+      jqXHR.statusCode( statusCode );
+      statusCode = undefined;
+
+      if ( fireGlobals ) {
+        globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
+            [ jqXHR, s, isSuccess ? success : error ] );
+      }
+
+      // Complete
+      completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );
+
+      if ( fireGlobals ) {
+        globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
+        // Handle the global AJAX counter
+        if ( !( --jQuery.active ) ) {
+          jQuery.event.trigger( "ajaxStop" );
+        }
+      }
+    }
+
+    // Attach deferreds
+    deferred.promise( jqXHR );
+    jqXHR.success = jqXHR.done;
+    jqXHR.error = jqXHR.fail;
+    jqXHR.complete = completeDeferred.add;
+
+    // Status-dependent callbacks
+    jqXHR.statusCode = function( map ) {
+      if ( map ) {
+        var tmp;
+        if ( state < 2 ) {
+          for ( tmp in map ) {
+            statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
+          }
+        } else {
+          tmp = map[ jqXHR.status ];
+          jqXHR.then( tmp, tmp );
+        }
+      }
+      return this;
+    };
+
+    // Remove hash character (#7531: and string promotion)
+    // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
+    // We also use the url parameter if available
+    s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );
+
+    // Extract dataTypes list
+    s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( rspacesAjax );
+
+    // Determine if a cross-domain request is in order
+    if ( s.crossDomain == null ) {
+      parts = rurl.exec( s.url.toLowerCase() );
+      s.crossDomain = !!( parts &&
+        ( parts[ 1 ] != ajaxLocParts[ 1 ] || parts[ 2 ] != ajaxLocParts[ 2 ] ||
+          ( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
+            ( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
+      );
+    }
+
+    // Convert data if not already a string
+    if ( s.data && s.processData && typeof s.data !== "string" ) {
+      s.data = jQuery.param( s.data, s.traditional );
+    }
+
+    // Apply prefilters
+    inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
+
+    // If request was aborted inside a prefiler, stop there
+    if ( state === 2 ) {
+      return false;
+    }
+
+    // We can fire global events as of now if asked to
+    fireGlobals = s.global;
+
+    // Uppercase the type
+    s.type = s.type.toUpperCase();
+
+    // Determine if request has content
+    s.hasContent = !rnoContent.test( s.type );
+
+    // Watch for a new set of requests
+    if ( fireGlobals && jQuery.active++ === 0 ) {
+      jQuery.event.trigger( "ajaxStart" );
+    }
+
+    // More options handling for requests with no content
+    if ( !s.hasContent ) {
+
+      // If data is available, append data to url
+      if ( s.data ) {
+        s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
+        // #9682: remove data so that it's not used in an eventual retry
+        delete s.data;
+      }
+
+      // Get ifModifiedKey before adding the anti-cache parameter
+      ifModifiedKey = s.url;
+
+      // Add anti-cache in url if needed
+      if ( s.cache === false ) {
+
+        var ts = jQuery.now(),
+          // try replacing _= if it is there
+          ret = s.url.replace( rts, "$1_=" + ts );
+
+        // if nothing was replaced, add timestamp to the end
+        s.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
+      }
+    }
+
+    // Set the correct header, if data is being sent
+    if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
+      jqXHR.setRequestHeader( "Content-Type", s.contentType );
+    }
+
+    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
+    if ( s.ifModified ) {
+      ifModifiedKey = ifModifiedKey || s.url;
+      if ( jQuery.lastModified[ ifModifiedKey ] ) {
+        jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
+      }
+      if ( jQuery.etag[ ifModifiedKey ] ) {
+        jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
+      }
+    }
+
+    // Set the Accepts header for the server, depending on the dataType
+    jqXHR.setRequestHeader(
+      "Accept",
+      s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
+        s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
+        s.accepts[ "*" ]
+    );
+
+    // Check for headers option
+    for ( i in s.headers ) {
+      jqXHR.setRequestHeader( i, s.headers[ i ] );
+    }
+
+    // Allow custom headers/mimetypes and early abort
+    if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
+        // Abort if not done already
+        jqXHR.abort();
+        return false;
 
-// A special extend for ajax options
-// that takes "flat" options (not to be deep extended)
-// Fixes #9887
-function ajaxExtend( target, src ) {
-	var key, deep,
-		flatOptions = jQuery.ajaxSettings.flatOptions || {};
-	for ( key in src ) {
-		if ( src[ key ] !== undefined ) {
-			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
-		}
-	}
-	if ( deep ) {
-		jQuery.extend( true, target, deep );
-	}
-}
+    }
 
-jQuery.fn.extend({
-	load: function( url, params, callback ) {
-		if ( typeof url !== "string" && _load ) {
-			return _load.apply( this, arguments );
-
-		// Don't do a request if no elements are being requested
-		} else if ( !this.length ) {
-			return this;
-		}
-
-		var off = url.indexOf( " " );
-		if ( off >= 0 ) {
-			var selector = url.slice( off, url.length );
-			url = url.slice( 0, off );
-		}
-
-		// Default to a GET request
-		var type = "GET";
-
-		// If the second parameter was provided
-		if ( params ) {
-			// If it's a function
-			if ( jQuery.isFunction( params ) ) {
-				// We assume that it's the callback
-				callback = params;
-				params = undefined;
-
-			// Otherwise, build a param string
-			} else if ( typeof params === "object" ) {
-				params = jQuery.param( params, jQuery.ajaxSettings.traditional );
-				type = "POST";
-			}
-		}
-
-		var self = this;
-
-		// Request the remote document
-		jQuery.ajax({
-			url: url,
-			type: type,
-			dataType: "html",
-			data: params,
-			// Complete callback (responseText is used internally)
-			complete: function( jqXHR, status, responseText ) {
-				// Store the response as specified by the jqXHR object
-				responseText = jqXHR.responseText;
-				// If successful, inject the HTML into all the matched elements
-				if ( jqXHR.isResolved() ) {
-					// #4825: Get the actual response in case
-					// a dataFilter is present in ajaxSettings
-					jqXHR.done(function( r ) {
-						responseText = r;
-					});
-					// See if a selector was specified
-					self.html( selector ?
-						// Create a dummy div to hold the results
-						jQuery("<div>")
-							// inject the contents of the document in, removing the scripts
-							// to avoid any 'Permission Denied' errors in IE
-							.append(responseText.replace(rscript, ""))
-
-							// Locate the specified elements
-							.find(selector) :
-
-						// If not, just inject the full result
-						responseText );
-				}
-
-				if ( callback ) {
-					self.each( callback, [ responseText, status, jqXHR ] );
-				}
-			}
-		});
-
-		return this;
-	},
-
-	serialize: function() {
-		return jQuery.param( this.serializeArray() );
-	},
-
-	serializeArray: function() {
-		return this.map(function(){
-			return this.elements ? jQuery.makeArray( this.elements ) : this;
-		})
-		.filter(function(){
-			return this.name && !this.disabled &&
-				( this.checked || rselectTextarea.test( this.nodeName ) ||
-					rinput.test( this.type ) );
-		})
-		.map(function( i, elem ){
-			var val = jQuery( this ).val();
-
-			return val == null ?
-				null :
-				jQuery.isArray( val ) ?
-					jQuery.map( val, function( val, i ){
-						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
-					}) :
-					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
-		}).get();
-	}
-});
+    // Install callbacks on deferreds
+    for ( i in { success: 1, error: 1, complete: 1 } ) {
+      jqXHR[ i ]( s[ i ] );
+    }
 
-// Attach a bunch of functions for handling common AJAX events
-jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
-	jQuery.fn[ o ] = function( f ){
-		return this.on( o, f );
-	};
-});
+    // Get transport
+    transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
+
+    // If no transport, we auto-abort
+    if ( !transport ) {
+      done( -1, "No Transport" );
+    } else {
+      jqXHR.readyState = 1;
+      // Send global event
+      if ( fireGlobals ) {
+        globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
+      }
+      // Timeout
+      if ( s.async && s.timeout > 0 ) {
+        timeoutTimer = setTimeout( function(){
+          jqXHR.abort( "timeout" );
+        }, s.timeout );
+      }
+
+      try {
+        state = 1;
+        transport.send( requestHeaders, done );
+      } catch (e) {
+        // Propagate exception as error if not done
+        if ( state < 2 ) {
+          done( -1, e );
+        // Simply rethrow otherwise
+        } else {
+          throw e;
+        }
+      }
+    }
 
-jQuery.each( [ "get", "post" ], function( i, method ) {
-	jQuery[ method ] = function( url, data, callback, type ) {
-		// shift arguments if data argument was omitted
-		if ( jQuery.isFunction( data ) ) {
-			type = type || callback;
-			callback = data;
-			data = undefined;
-		}
-
-		return jQuery.ajax({
-			type: method,
-			url: url,
-			data: data,
-			success: callback,
-			dataType: type
-		});
-	};
-});
+    return jqXHR;
+  },
+
+  // Serialize an array of form elements or a set of
+  // key/values into a query string
+  param: function( a, traditional ) {
+    var s = [],
+      add = function( key, value ) {
+        // If value is a function, invoke it and return its value
+        value = jQuery.isFunction( value ) ? value() : value;
+        s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
+      };
+
+    // Set traditional to true for jQuery <= 1.3.2 behavior.
+    if ( traditional === undefined ) {
+      traditional = jQuery.ajaxSettings.traditional;
+    }
 
-jQuery.extend({
+    // If an array was passed in, assume that it is an array of form elements.
+    if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
+      // Serialize the form elements
+      jQuery.each( a, function() {
+        add( this.name, this.value );
+      });
+
+    } else {
+      // If traditional, encode the "old" way (the way 1.3.2 or older
+      // did it), otherwise encode params recursively.
+      for ( var prefix in a ) {
+        buildParams( prefix, a[ prefix ], traditional, add );
+      }
+    }
 
-	getScript: function( url, callback ) {
-		return jQuery.get( url, undefined, callback, "script" );
-	},
-
-	getJSON: function( url, data, callback ) {
-		return jQuery.get( url, data, callback, "json" );
-	},
-
-	// Creates a full fledged settings object into target
-	// with both ajaxSettings and settings fields.
-	// If target is omitted, writes into ajaxSettings.
-	ajaxSetup: function( target, settings ) {
-		if ( settings ) {
-			// Building a settings object
-			ajaxExtend( target, jQuery.ajaxSettings );
-		} else {
-			// Extending ajaxSettings
-			settings = target;
-			target = jQuery.ajaxSettings;
-		}
-		ajaxExtend( target, settings );
-		return target;
-	},
-
-	ajaxSettings: {
-		url: ajaxLocation,
-		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
-		global: true,
-		type: "GET",
-		contentType: "application/x-www-form-urlencoded",
-		processData: true,
-		async: true,
-		/*
-		timeout: 0,
-		data: null,
-		dataType: null,
-		username: null,
-		password: null,
-		cache: null,
-		traditional: false,
-		headers: {},
-		*/
-
-		accepts: {
-			xml: "application/xml, text/xml",
-			html: "text/html",
-			text: "text/plain",
-			json: "application/json, text/javascript",
-			"*": allTypes
-		},
-
-		contents: {
-			xml: /xml/,
-			html: /html/,
-			json: /json/
-		},
-
-		responseFields: {
-			xml: "responseXML",
-			text: "responseText"
-		},
-
-		// List of data converters
-		// 1) key format is "source_type destination_type" (a single space in-between)
-		// 2) the catchall symbol "*" can be used for source_type
-		converters: {
-
-			// Convert anything to text
-			"* text": window.String,
-
-			// Text to html (true = no transformation)
-			"text html": true,
-
-			// Evaluate text as a json expression
-			"text json": jQuery.parseJSON,
-
-			// Parse text as xml
-			"text xml": jQuery.parseXML
-		},
-
-		// For options that shouldn't be deep extended:
-		// you can add your own custom options here if
-		// and when you create one that shouldn't be
-		// deep extended (see ajaxExtend)
-		flatOptions: {
-			context: true,
-			url: true
-		}
-	},
-
-	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
-	ajaxTransport: addToPrefiltersOrTransports( transports ),
-
-	// Main method
-	ajax: function( url, options ) {
-
-		// If url is an object, simulate pre-1.5 signature
-		if ( typeof url === "object" ) {
-			options = url;
-			url = undefined;
-		}
-
-		// Force options to be an object
-		options = options || {};
-
-		var // Create the final options object
-			s = jQuery.ajaxSetup( {}, options ),
-			// Callbacks context
-			callbackContext = s.context || s,
-			// Context for global events
-			// It's the callbackContext if one was provided in the options
-			// and if it's a DOM node or a jQuery collection
-			globalEventContext = callbackContext !== s &&
-				( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
-						jQuery( callbackContext ) : jQuery.event,
-			// Deferreds
-			deferred = jQuery.Deferred(),
-			completeDeferred = jQuery.Callbacks( "once memory" ),
-			// Status-dependent callbacks
-			statusCode = s.statusCode || {},
-			// ifModified key
-			ifModifiedKey,
-			// Headers (they are sent all at once)
-			requestHeaders = {},
-			requestHeadersNames = {},
-			// Response headers
-			responseHeadersString,
-			responseHeaders,
-			// transport
-			transport,
-			// timeout handle
-			timeoutTimer,
-			// Cross-domain detection vars
-			parts,
-			// The jqXHR state
-			state = 0,
-			// To know if global events are to be dispatched
-			fireGlobals,
-			// Loop variable
-			i,
-			// Fake xhr
-			jqXHR = {
-
-				readyState: 0,
-
-				// Caches the header
-				setRequestHeader: function( name, value ) {
-					if ( !state ) {
-						var lname = name.toLowerCase();
-						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
-						requestHeaders[ name ] = value;
-					}
-					return this;
-				},
-
-				// Raw string
-				getAllResponseHeaders: function() {
-					return state === 2 ? responseHeadersString : null;
-				},
-
-				// Builds headers hashtable if needed
-				getResponseHeader: function( key ) {
-					var match;
-					if ( state === 2 ) {
-						if ( !responseHeaders ) {
-							responseHeaders = {};
-							while( ( match = rheaders.exec( responseHeadersString ) ) ) {
-								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
-							}
-						}
-						match = responseHeaders[ key.toLowerCase() ];
-					}
-					return match === undefined ? null : match;
-				},
-
-				// Overrides response content-type header
-				overrideMimeType: function( type ) {
-					if ( !state ) {
-						s.mimeType = type;
-					}
-					return this;
-				},
-
-				// Cancel the request
-				abort: function( statusText ) {
-					statusText = statusText || "abort";
-					if ( transport ) {
-						transport.abort( statusText );
-					}
-					done( 0, statusText );
-					return this;
-				},
-
-				url : s.url,
-				data : s.data
-			};
-
-		// Callback for when everything is done
-		// It is defined here because jslint complains if it is declared
-		// at the end of the function (which would be more logical and readable)
-		function done( status, nativeStatusText, responses, headers ) {
-
-			// Called once
-			if ( state === 2 ) {
-				return;
-			}
-
-			// State is "done" now
-			state = 2;
-
-			// Clear timeout if it exists
-			if ( timeoutTimer ) {
-				clearTimeout( timeoutTimer );
-			}
-
-			// Dereference transport for early garbage collection
-			// (no matter how long the jqXHR object will be used)
-			transport = undefined;
-
-			// Cache response headers
-			responseHeadersString = headers || "";
-
-			// Set readyState
-			jqXHR.readyState = status > 0 ? 4 : 0;
-
-			var isSuccess,
-				success,
-				error,
-				statusText = nativeStatusText,
-				response = responses ? ajaxHandleResponses( s, jqXHR, responses ) : undefined,
-				lastModified,
-				etag;
-
-			// If successful, handle type chaining
-			if ( status >= 200 && status < 300 || status === 304 ) {
-
-				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
-				if ( s.ifModified ) {
-
-					if ( ( lastModified = jqXHR.getResponseHeader( "Last-Modified" ) ) ) {
-						jQuery.lastModified[ ifModifiedKey ] = lastModified;
-					}
-					if ( ( etag = jqXHR.getResponseHeader( "Etag" ) ) ) {
-						jQuery.etag[ ifModifiedKey ] = etag;
-					}
-				}
-
-				// If not modified
-				if ( status === 304 ) {
-
-					statusText = "notmodified";
-					isSuccess = true;
-
-				// If we have data
-				} else {
-
-					try {
-						success = ajaxConvert( s, response );
-						statusText = "success";
-						isSuccess = true;
-					} catch(e) {
-						// We have a parsererror
-						statusText = "parsererror";
-						error = e;
-					}
-				}
-			} else {
-				// We extract error from statusText
-				// then normalize statusText and status for non-aborts
-				error = statusText;
-				if ( !statusText || status ) {
-					statusText = "error";
-					if ( status < 0 ) {
-						status = 0;
-					}
-				}
-			}
-
-			// Set data for the fake xhr object
-			jqXHR.status = status;
-			jqXHR.statusText = "" + ( nativeStatusText || statusText );
-
-			// Success/Error
-			if ( isSuccess ) {
-				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
-			} else {
-				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
-			}
-
-			// Status-dependent callbacks
-			jqXHR.statusCode( statusCode );
-			statusCode = undefined;
-
-			if ( fireGlobals ) {
-				globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
-						[ jqXHR, s, isSuccess ? success : error ] );
-			}
-
-			// Complete
-			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );
-
-			if ( fireGlobals ) {
-				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
-				// Handle the global AJAX counter
-				if ( !( --jQuery.active ) ) {
-					jQuery.event.trigger( "ajaxStop" );
-				}
-			}
-		}
-
-		// Attach deferreds
-		deferred.promise( jqXHR );
-		jqXHR.success = jqXHR.done;
-		jqXHR.error = jqXHR.fail;
-		jqXHR.complete = completeDeferred.add;
-
-		// Status-dependent callbacks
-		jqXHR.statusCode = function( map ) {
-			if ( map ) {
-				var tmp;
-				if ( state < 2 ) {
-					for ( tmp in map ) {
-						statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
-					}
-				} else {
-					tmp = map[ jqXHR.status ];
-					jqXHR.then( tmp, tmp );
-				}
-			}
-			return this;
-		};
-
-		// Remove hash character (#7531: and string promotion)
-		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
-		// We also use the url parameter if available
-		s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );
-
-		// Extract dataTypes list
-		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( rspacesAjax );
-
-		// Determine if a cross-domain request is in order
-		if ( s.crossDomain == null ) {
-			parts = rurl.exec( s.url.toLowerCase() );
-			s.crossDomain = !!( parts &&
-				( parts[ 1 ] != ajaxLocParts[ 1 ] || parts[ 2 ] != ajaxLocParts[ 2 ] ||
-					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
-						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
-			);
-		}
-
-		// Convert data if not already a string
-		if ( s.data && s.processData && typeof s.data !== "string" ) {
-			s.data = jQuery.param( s.data, s.traditional );
-		}
-
-		// Apply prefilters
-		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
-
-		// If request was aborted inside a prefiler, stop there
-		if ( state === 2 ) {
-			return false;
-		}
-
-		// We can fire global events as of now if asked to
-		fireGlobals = s.global;
-
-		// Uppercase the type
-		s.type = s.type.toUpperCase();
-
-		// Determine if request has content
-		s.hasContent = !rnoContent.test( s.type );
-
-		// Watch for a new set of requests
-		if ( fireGlobals && jQuery.active++ === 0 ) {
-			jQuery.event.trigger( "ajaxStart" );
-		}
-
-		// More options handling for requests with no content
-		if ( !s.hasContent ) {
-
-			// If data is available, append data to url
-			if ( s.data ) {
-				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
-				// #9682: remove data so that it's not used in an eventual retry
-				delete s.data;
-			}
-
-			// Get ifModifiedKey before adding the anti-cache parameter
-			ifModifiedKey = s.url;
-
-			// Add anti-cache in url if needed
-			if ( s.cache === false ) {
-
-				var ts = jQuery.now(),
-					// try replacing _= if it is there
-					ret = s.url.replace( rts, "$1_=" + ts );
-
-				// if nothing was replaced, add timestamp to the end
-				s.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
-			}
-		}
-
-		// Set the correct header, if data is being sent
-		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
-			jqXHR.setRequestHeader( "Content-Type", s.contentType );
-		}
-
-		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
-		if ( s.ifModified ) {
-			ifModifiedKey = ifModifiedKey || s.url;
-			if ( jQuery.lastModified[ ifModifiedKey ] ) {
-				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
-			}
-			if ( jQuery.etag[ ifModifiedKey ] ) {
-				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
-			}
-		}
-
-		// Set the Accepts header for the server, depending on the dataType
-		jqXHR.setRequestHeader(
-			"Accept",
-			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
-				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
-				s.accepts[ "*" ]
-		);
-
-		// Check for headers option
-		for ( i in s.headers ) {
-			jqXHR.setRequestHeader( i, s.headers[ i ] );
-		}
-
-		// Allow custom headers/mimetypes and early abort
-		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
-				// Abort if not done already
-				jqXHR.abort();
-				return false;
-
-		}
-
-		// Install callbacks on deferreds
-		for ( i in { success: 1, error: 1, complete: 1 } ) {
-			jqXHR[ i ]( s[ i ] );
-		}
-
-		// Get transport
-		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
-
-		// If no transport, we auto-abort
-		if ( !transport ) {
-			done( -1, "No Transport" );
-		} else {
-			jqXHR.readyState = 1;
-			// Send global event
-			if ( fireGlobals ) {
-				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
-			}
-			// Timeout
-			if ( s.async && s.timeout > 0 ) {
-				timeoutTimer = setTimeout( function(){
-					jqXHR.abort( "timeout" );
-				}, s.timeout );
-			}
-
-			try {
-				state = 1;
-				transport.send( requestHeaders, done );
-			} catch (e) {
-				// Propagate exception as error if not done
-				if ( state < 2 ) {
-					done( -1, e );
-				// Simply rethrow otherwise
-				} else {
-					throw e;
-				}
-			}
-		}
-
-		return jqXHR;
-	},
-
-	// Serialize an array of form elements or a set of
-	// key/values into a query string
-	param: function( a, traditional ) {
-		var s = [],
-			add = function( key, value ) {
-				// If value is a function, invoke it and return its value
-				value = jQuery.isFunction( value ) ? value() : value;
-				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
-			};
-
-		// Set traditional to true for jQuery <= 1.3.2 behavior.
-		if ( traditional === undefined ) {
-			traditional = jQuery.ajaxSettings.traditional;
-		}
-
-		// If an array was passed in, assume that it is an array of form elements.
-		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
-			// Serialize the form elements
-			jQuery.each( a, function() {
-				add( this.name, this.value );
-			});
-
-		} else {
-			// If traditional, encode the "old" way (the way 1.3.2 or older
-			// did it), otherwise encode params recursively.
-			for ( var prefix in a ) {
-				buildParams( prefix, a[ prefix ], traditional, add );
-			}
-		}
-
-		// Return the resulting serialization
-		return s.join( "&" ).replace( r20, "+" );
-	}
+    // Return the resulting serialization
+    return s.join( "&" ).replace( r20, "+" );
+  }
 });
 
 function buildParams( prefix, obj, traditional, add ) {
-	if ( jQuery.isArray( obj ) ) {
-		// Serialize array item.
-		jQuery.each( obj, function( i, v ) {
-			if ( traditional || rbracket.test( prefix ) ) {
-				// Treat each array item as a scalar.
-				add( prefix, v );
-
-			} else {
-				// If array item is non-scalar (array or object), encode its
-				// numeric index to resolve deserialization ambiguity issues.
-				// Note that rack (as of 1.0.0) can't currently deserialize
-				// nested arrays properly, and attempting to do so may cause
-				// a server error. Possible fixes are to modify rack's
-				// deserialization algorithm or to provide an option or flag
-				// to force array serialization to be shallow.
-				buildParams( prefix + "[" + ( typeof v === "object" || jQuery.isArray(v) ? i : "" ) + "]", v, traditional, add );
-			}
-		});
-
-	} else if ( !traditional && obj != null && typeof obj === "object" ) {
-		// Serialize object item.
-		for ( var name in obj ) {
-			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
-		}
-
-	} else {
-		// Serialize scalar item.
-		add( prefix, obj );
-	}
+  if ( jQuery.isArray( obj ) ) {
+    // Serialize array item.
+    jQuery.each( obj, function( i, v ) {
+      if ( traditional || rbracket.test( prefix ) ) {
+        // Treat each array item as a scalar.
+        add( prefix, v );
+
+      } else {
+        // If array item is non-scalar (array or object), encode its
+        // numeric index to resolve deserialization ambiguity issues.
+        // Note that rack (as of 1.0.0) can't currently deserialize
+        // nested arrays properly, and attempting to do so may cause
+        // a server error. Possible fixes are to modify rack's
+        // deserialization algorithm or to provide an option or flag
+        // to force array serialization to be shallow.
+        buildParams( prefix + "[" + ( typeof v === "object" || jQuery.isArray(v) ? i : "" ) + "]", v, traditional, add );
+      }
+    });
+
+  } else if ( !traditional && obj != null && typeof obj === "object" ) {
+    // Serialize object item.
+    for ( var name in obj ) {
+      buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
+    }
+
+  } else {
+    // Serialize scalar item.
+    add( prefix, obj );
+  }
 }
 
 // This is still on the jQuery object... for now
 // Want to move this to jQuery.ajax some day
 jQuery.extend({
 
-	// Counter for holding the number of active queries
-	active: 0,
+  // Counter for holding the number of active queries
+  active: 0,
 
-	// Last-Modified header cache for next request
-	lastModified: {},
-	etag: {}
+  // Last-Modified header cache for next request
+  lastModified: {},
+  etag: {}
 
 });
 
@@ -9762,230 +9762,230 @@ jQuery.extend({
  */
 function ajaxHandleResponses( s, jqXHR, responses ) {
 
-	var contents = s.contents,
-		dataTypes = s.dataTypes,
-		responseFields = s.responseFields,
-		ct,
-		type,
-		finalDataType,
-		firstDataType;
-
-	// Fill responseXXX fields
-	for ( type in responseFields ) {
-		if ( type in responses ) {
-			jqXHR[ responseFields[type] ] = responses[ type ];
-		}
-	}
-
-	// Remove auto dataType and get content-type in the process
-	while( dataTypes[ 0 ] === "*" ) {
-		dataTypes.shift();
-		if ( ct === undefined ) {
-			ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
-		}
-	}
-
-	// Check if we're dealing with a known content-type
-	if ( ct ) {
-		for ( type in contents ) {
-			if ( contents[ type ] && contents[ type ].test( ct ) ) {
-				dataTypes.unshift( type );
-				break;
-			}
-		}
-	}
-
-	// Check to see if we have a response for the expected dataType
-	if ( dataTypes[ 0 ] in responses ) {
-		finalDataType = dataTypes[ 0 ];
-	} else {
-		// Try convertible dataTypes
-		for ( type in responses ) {
-			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
-				finalDataType = type;
-				break;
-			}
-			if ( !firstDataType ) {
-				firstDataType = type;
-			}
-		}
-		// Or just use first one
-		finalDataType = finalDataType || firstDataType;
-	}
-
-	// If we found a dataType
-	// We add the dataType to the list if needed
-	// and return the corresponding response
-	if ( finalDataType ) {
-		if ( finalDataType !== dataTypes[ 0 ] ) {
-			dataTypes.unshift( finalDataType );
-		}
-		return responses[ finalDataType ];
-	}
+  var contents = s.contents,
+    dataTypes = s.dataTypes,
+    responseFields = s.responseFields,
+    ct,
+    type,
+    finalDataType,
+    firstDataType;
+
+  // Fill responseXXX fields
+  for ( type in responseFields ) {
+    if ( type in responses ) {
+      jqXHR[ responseFields[type] ] = responses[ type ];
+    }
+  }
+
+  // Remove auto dataType and get content-type in the process
+  while( dataTypes[ 0 ] === "*" ) {
+    dataTypes.shift();
+    if ( ct === undefined ) {
+      ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
+    }
+  }
+
+  // Check if we're dealing with a known content-type
+  if ( ct ) {
+    for ( type in contents ) {
+      if ( contents[ type ] && contents[ type ].test( ct ) ) {
+        dataTypes.unshift( type );
+        break;
+      }
+    }
+  }
+
+  // Check to see if we have a response for the expected dataType
+  if ( dataTypes[ 0 ] in responses ) {
+    finalDataType = dataTypes[ 0 ];
+  } else {
+    // Try convertible dataTypes
+    for ( type in responses ) {
+      if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
+        finalDataType = type;
+        break;
+      }
+      if ( !firstDataType ) {
+        firstDataType = type;
+      }
+    }
+    // Or just use first one
+    finalDataType = finalDataType || firstDataType;
+  }
+
+  // If we found a dataType
+  // We add the dataType to the list if needed
+  // and return the corresponding response
+  if ( finalDataType ) {
+    if ( finalDataType !== dataTypes[ 0 ] ) {
+      dataTypes.unshift( finalDataType );
+    }
+    return responses[ finalDataType ];
+  }
 }
 
 // Chain conversions given the request and the original response
 function ajaxConvert( s, response ) {
 
-	// Apply the dataFilter if provided
-	if ( s.dataFilter ) {
-		response = s.dataFilter( response, s.dataType );
-	}
-
-	var dataTypes = s.dataTypes,
-		converters = {},
-		i,
-		key,
-		length = dataTypes.length,
-		tmp,
-		// Current and previous dataTypes
-		current = dataTypes[ 0 ],
-		prev,
-		// Conversion expression
-		conversion,
-		// Conversion function
-		conv,
-		// Conversion functions (transitive conversion)
-		conv1,
-		conv2;
-
-	// For each dataType in the chain
-	for ( i = 1; i < length; i++ ) {
-
-		// Create converters map
-		// with lowercased keys
-		if ( i === 1 ) {
-			for ( key in s.converters ) {
-				if ( typeof key === "string" ) {
-					converters[ key.toLowerCase() ] = s.converters[ key ];
-				}
-			}
-		}
-
-		// Get the dataTypes
-		prev = current;
-		current = dataTypes[ i ];
-
-		// If current is auto dataType, update it to prev
-		if ( current === "*" ) {
-			current = prev;
-		// If no auto and dataTypes are actually different
-		} else if ( prev !== "*" && prev !== current ) {
-
-			// Get the converter
-			conversion = prev + " " + current;
-			conv = converters[ conversion ] || converters[ "* " + current ];
-
-			// If there is no direct converter, search transitively
-			if ( !conv ) {
-				conv2 = undefined;
-				for ( conv1 in converters ) {
-					tmp = conv1.split( " " );
-					if ( tmp[ 0 ] === prev || tmp[ 0 ] === "*" ) {
-						conv2 = converters[ tmp[1] + " " + current ];
-						if ( conv2 ) {
-							conv1 = converters[ conv1 ];
-							if ( conv1 === true ) {
-								conv = conv2;
-							} else if ( conv2 === true ) {
-								conv = conv1;
-							}
-							break;
-						}
-					}
-				}
-			}
-			// If we found no converter, dispatch an error
-			if ( !( conv || conv2 ) ) {
-				jQuery.error( "No conversion from " + conversion.replace(" "," to ") );
-			}
-			// If found converter is not an equivalence
-			if ( conv !== true ) {
-				// Convert with 1 or 2 converters accordingly
-				response = conv ? conv( response ) : conv2( conv1(response) );
-			}
-		}
-	}
-	return response;
+  // Apply the dataFilter if provided
+  if ( s.dataFilter ) {
+    response = s.dataFilter( response, s.dataType );
+  }
+
+  var dataTypes = s.dataTypes,
+    converters = {},
+    i,
+    key,
+    length = dataTypes.length,
+    tmp,
+    // Current and previous dataTypes
+    current = dataTypes[ 0 ],
+    prev,
+    // Conversion expression
+    conversion,
+    // Conversion function
+    conv,
+    // Conversion functions (transitive conversion)
+    conv1,
+    conv2;
+
+  // For each dataType in the chain
+  for ( i = 1; i < length; i++ ) {
+
+    // Create converters map
+    // with lowercased keys
+    if ( i === 1 ) {
+      for ( key in s.converters ) {
+        if ( typeof key === "string" ) {
+          converters[ key.toLowerCase() ] = s.converters[ key ];
+        }
+      }
+    }
+
+    // Get the dataTypes
+    prev = current;
+    current = dataTypes[ i ];
+
+    // If current is auto dataType, update it to prev
+    if ( current === "*" ) {
+      current = prev;
+    // If no auto and dataTypes are actually different
+    } else if ( prev !== "*" && prev !== current ) {
+
+      // Get the converter
+      conversion = prev + " " + current;
+      conv = converters[ conversion ] || converters[ "* " + current ];
+
+      // If there is no direct converter, search transitively
+      if ( !conv ) {
+        conv2 = undefined;
+        for ( conv1 in converters ) {
+          tmp = conv1.split( " " );
+          if ( tmp[ 0 ] === prev || tmp[ 0 ] === "*" ) {
+            conv2 = converters[ tmp[1] + " " + current ];
+            if ( conv2 ) {
+              conv1 = converters[ conv1 ];
+              if ( conv1 === true ) {
+                conv = conv2;
+              } else if ( conv2 === true ) {
+                conv = conv1;
+              }
+              break;
+            }
+          }
+        }
+      }
+      // If we found no converter, dispatch an error
+      if ( !( conv || conv2 ) ) {
+        jQuery.error( "No conversion from " + conversion.replace(" "," to ") );
+      }
+      // If found converter is not an equivalence
+      if ( conv !== true ) {
+        // Convert with 1 or 2 converters accordingly
+        response = conv ? conv( response ) : conv2( conv1(response) );
+      }
+    }
+  }
+  return response;
 }
 
 
 
 
 var jsc = jQuery.now(),
-	jsre = /(\=)\?(&|$)|\?\?/i;
+  jsre = /(\=)\?(&|$)|\?\?/i;
 
 // Default jsonp settings
 jQuery.ajaxSetup({
-	jsonp: "callback",
-	jsonpCallback: function() {
-		return jQuery.expando + "_" + ( jsc++ );
-	}
+  jsonp: "callback",
+  jsonpCallback: function() {
+    return jQuery.expando + "_" + ( jsc++ );
+  }
 });
 
 // Detect, normalize options and install callbacks for jsonp requests
 jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {
 
-	var inspectData = s.contentType === "application/x-www-form-urlencoded" &&
-		( typeof s.data === "string" );
-
-	if ( s.dataTypes[ 0 ] === "jsonp" ||
-		s.jsonp !== false && ( jsre.test( s.url ) ||
-				inspectData && jsre.test( s.data ) ) ) {
-
-		var responseContainer,
-			jsonpCallback = s.jsonpCallback =
-				jQuery.isFunction( s.jsonpCallback ) ? s.jsonpCallback() : s.jsonpCallback,
-			previous = window[ jsonpCallback ],
-			url = s.url,
-			data = s.data,
-			replace = "$1" + jsonpCallback + "$2";
-
-		if ( s.jsonp !== false ) {
-			url = url.replace( jsre, replace );
-			if ( s.url === url ) {
-				if ( inspectData ) {
-					data = data.replace( jsre, replace );
-				}
-				if ( s.data === data ) {
-					// Add callback manually
-					url += (/\?/.test( url ) ? "&" : "?") + s.jsonp + "=" + jsonpCallback;
-				}
-			}
-		}
-
-		s.url = url;
-		s.data = data;
-
-		// Install callback
-		window[ jsonpCallback ] = function( response ) {
-			responseContainer = [ response ];
-		};
-
-		// Clean-up function
-		jqXHR.always(function() {
-			// Set callback back to previous value
-			window[ jsonpCallback ] = previous;
-			// Call if it was a function and we have a response
-			if ( responseContainer && jQuery.isFunction( previous ) ) {
-				window[ jsonpCallback ]( responseContainer[ 0 ] );
-			}
-		});
-
-		// Use data converter to retrieve json after script execution
-		s.converters["script json"] = function() {
-			if ( !responseContainer ) {
-				jQuery.error( jsonpCallback + " was not called" );
-			}
-			return responseContainer[ 0 ];
-		};
-
-		// force json dataType
-		s.dataTypes[ 0 ] = "json";
-
-		// Delegate to script
-		return "script";
-	}
+  var inspectData = s.contentType === "application/x-www-form-urlencoded" &&
+    ( typeof s.data === "string" );
+
+  if ( s.dataTypes[ 0 ] === "jsonp" ||
+    s.jsonp !== false && ( jsre.test( s.url ) ||
+        inspectData && jsre.test( s.data ) ) ) {
+
+    var responseContainer,
+      jsonpCallback = s.jsonpCallback =
+        jQuery.isFunction( s.jsonpCallback ) ? s.jsonpCallback() : s.jsonpCallback,
+      previous = window[ jsonpCallback ],
+      url = s.url,
+      data = s.data,
+      replace = "$1" + jsonpCallback + "$2";
+
+    if ( s.jsonp !== false ) {
+      url = url.replace( jsre, replace );
+      if ( s.url === url ) {
+        if ( inspectData ) {
+          data = data.replace( jsre, replace );
+        }
+        if ( s.data === data ) {
+          // Add callback manually
+          url += (/\?/.test( url ) ? "&" : "?") + s.jsonp + "=" + jsonpCallback;
+        }
+      }
+    }
+
+    s.url = url;
+    s.data = data;
+
+    // Install callback
+    window[ jsonpCallback ] = function( response ) {
+      responseContainer = [ response ];
+    };
+
+    // Clean-up function
+    jqXHR.always(function() {
+      // Set callback back to previous value
+      window[ jsonpCallback ] = previous;
+      // Call if it was a function and we have a response
+      if ( responseContainer && jQuery.isFunction( previous ) ) {
+        window[ jsonpCallback ]( responseContainer[ 0 ] );
+      }
+    });
+
+    // Use data converter to retrieve json after script execution
+    s.converters["script json"] = function() {
+      if ( !responseContainer ) {
+        jQuery.error( jsonpCallback + " was not called" );
+      }
+      return responseContainer[ 0 ];
+    };
+
+    // force json dataType
+    s.dataTypes[ 0 ] = "json";
+
+    // Delegate to script
+    return "script";
+  }
 });
 
 
@@ -9993,1259 +9993,1259 @@ jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {
 
 // Install script dataType
 jQuery.ajaxSetup({
-	accepts: {
-		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
-	},
-	contents: {
-		script: /javascript|ecmascript/
-	},
-	converters: {
-		"text script": function( text ) {
-			jQuery.globalEval( text );
-			return text;
-		}
-	}
+  accepts: {
+    script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
+  },
+  contents: {
+    script: /javascript|ecmascript/
+  },
+  converters: {
+    "text script": function( text ) {
+      jQuery.globalEval( text );
+      return text;
+    }
+  }
 });
 
 // Handle cache's special case and global
 jQuery.ajaxPrefilter( "script", function( s ) {
-	if ( s.cache === undefined ) {
-		s.cache = false;
-	}
-	if ( s.crossDomain ) {
-		s.type = "GET";
-		s.global = false;
-	}
+  if ( s.cache === undefined ) {
+    s.cache = false;
+  }
+  if ( s.crossDomain ) {
+    s.type = "GET";
+    s.global = false;
+  }
 });
 
 // Bind script tag hack transport
 jQuery.ajaxTransport( "script", function(s) {
 
-	// This transport only deals with cross domain requests
-	if ( s.crossDomain ) {
-
-		var script,
-			head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;
+  // This transport only deals with cross domain requests
+  if ( s.crossDomain ) {
 
-		return {
+    var script,
+      head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;
 
-			send: function( _, callback ) {
+    return {
 
-				script = document.createElement( "script" );
+      send: function( _, callback ) {
 
-				script.async = "async";
+        script = document.createElement( "script" );
 
-				if ( s.scriptCharset ) {
-					script.charset = s.scriptCharset;
-				}
+        script.async = "async";
 
-				script.src = s.url;
+        if ( s.scriptCharset ) {
+          script.charset = s.scriptCharset;
+        }
 
-				// Attach handlers for all browsers
-				script.onload = script.onreadystatechange = function( _, isAbort ) {
+        script.src = s.url;
 
-					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {
+        // Attach handlers for all browsers
+        script.onload = script.onreadystatechange = function( _, isAbort ) {
 
-						// Handle memory leak in IE
-						script.onload = script.onreadystatechange = null;
+          if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {
 
-						// Remove the script
-						if ( head && script.parentNode ) {
-							head.removeChild( script );
-						}
+            // Handle memory leak in IE
+            script.onload = script.onreadystatechange = null;
 
-						// Dereference the script
-						script = undefined;
+            // Remove the script
+            if ( head && script.parentNode ) {
+              head.removeChild( script );
+            }
 
-						// Callback if not abort
-						if ( !isAbort ) {
-							callback( 200, "success" );
-						}
-					}
-				};
-				// Use insertBefore instead of appendChild  to circumvent an IE6 bug.
-				// This arises when a base node is used (#2709 and #4378).
-				head.insertBefore( script, head.firstChild );
-			},
+            // Dereference the script
+            script = undefined;
 
-			abort: function() {
-				if ( script ) {
-					script.onload( 0, 1 );
-				}
-			}
-		};
-	}
+            // Callback if not abort
+            if ( !isAbort ) {
+              callback( 200, "success" );
+            }
+          }
+        };
+        // Use insertBefore instead of appendChild  to circumvent an IE6 bug.
+        // This arises when a base node is used (#2709 and #4378).
+        head.insertBefore( script, head.firstChild );
+      },
+
+      abort: function() {
+        if ( script ) {
+          script.onload( 0, 1 );
+        }
+      }
+    };
+  }
 });
 
 
 
 
 var // #5280: Internet Explorer will keep connections alive if we don't abort on unload
-	xhrOnUnloadAbort = window.ActiveXObject ? function() {
-		// Abort all pending requests
-		for ( var key in xhrCallbacks ) {
-			xhrCallbacks[ key ]( 0, 1 );
-		}
-	} : false,
-	xhrId = 0,
-	xhrCallbacks;
+  xhrOnUnloadAbort = window.ActiveXObject ? function() {
+    // Abort all pending requests
+    for ( var key in xhrCallbacks ) {
+      xhrCallbacks[ key ]( 0, 1 );
+    }
+  } : false,
+  xhrId = 0,
+  xhrCallbacks;
 
 // Functions to create xhrs
 function createStandardXHR() {
-	try {
-		return new window.XMLHttpRequest();
-	} catch( e ) {}
+  try {
+    return new window.XMLHttpRequest();
+  } catch( e ) {}
 }
 
 function createActiveXHR() {
-	try {
-		return new window.ActiveXObject( "Microsoft.XMLHTTP" );
-	} catch( e ) {}
+  try {
+    return new window.ActiveXObject( "Microsoft.XMLHTTP" );
+  } catch( e ) {}
 }
 
 // Create the request object
 // (This is still attached to ajaxSettings for backward compatibility)
 jQuery.ajaxSettings.xhr = window.ActiveXObject ?
-	/* Microsoft failed to properly
-	 * implement the XMLHttpRequest in IE7 (can't request local files),
-	 * so we use the ActiveXObject when it is available
-	 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
-	 * we need a fallback.
-	 */
-	function() {
-		return !this.isLocal && createStandardXHR() || createActiveXHR();
-	} :
-	// For all other browsers, use the standard XMLHttpRequest object
-	createStandardXHR;
+  /* Microsoft failed to properly
+   * implement the XMLHttpRequest in IE7 (can't request local files),
+   * so we use the ActiveXObject when it is available
+   * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
+   * we need a fallback.
+   */
+  function() {
+    return !this.isLocal && createStandardXHR() || createActiveXHR();
+  } :
+  // For all other browsers, use the standard XMLHttpRequest object
+  createStandardXHR;
 
 // Determine support properties
 (function( xhr ) {
-	jQuery.extend( jQuery.support, {
-		ajax: !!xhr,
-		cors: !!xhr && ( "withCredentials" in xhr )
-	});
+  jQuery.extend( jQuery.support, {
+    ajax: !!xhr,
+    cors: !!xhr && ( "withCredentials" in xhr )
+  });
 })( jQuery.ajaxSettings.xhr() );
 
 // Create transport if the browser can provide an xhr
 if ( jQuery.support.ajax ) {
 
-	jQuery.ajaxTransport(function( s ) {
-		// Cross domain only allowed if supported through XMLHttpRequest
-		if ( !s.crossDomain || jQuery.support.cors ) {
-
-			var callback;
-
-			return {
-				send: function( headers, complete ) {
-
-					// Get a new xhr
-					var xhr = s.xhr(),
-						handle,
-						i;
-
-					// Open the socket
-					// Passing null username, generates a login popup on Opera (#2865)
-					if ( s.username ) {
-						xhr.open( s.type, s.url, s.async, s.username, s.password );
-					} else {
-						xhr.open( s.type, s.url, s.async );
-					}
-
-					// Apply custom fields if provided
-					if ( s.xhrFields ) {
-						for ( i in s.xhrFields ) {
-							xhr[ i ] = s.xhrFields[ i ];
-						}
-					}
-
-					// Override mime type if needed
-					if ( s.mimeType && xhr.overrideMimeType ) {
-						xhr.overrideMimeType( s.mimeType );
-					}
-
-					// X-Requested-With header
-					// For cross-domain requests, seeing as conditions for a preflight are
-					// akin to a jigsaw puzzle, we simply never set it to be sure.
-					// (it can always be set on a per-request basis or even using ajaxSetup)
-					// For same-domain requests, won't change header if already provided.
-					if ( !s.crossDomain && !headers["X-Requested-With"] ) {
-						headers[ "X-Requested-With" ] = "XMLHttpRequest";
-					}
-
-					// Need an extra try/catch for cross domain requests in Firefox 3
-					try {
-						for ( i in headers ) {
-							xhr.setRequestHeader( i, headers[ i ] );
-						}
-					} catch( _ ) {}
-
-					// Do send the request
-					// This may raise an exception which is actually
-					// handled in jQuery.ajax (so no try/catch here)
-					xhr.send( ( s.hasContent && s.data ) || null );
-
-					// Listener
-					callback = function( _, isAbort ) {
-
-						var status,
-							statusText,
-							responseHeaders,
-							responses,
-							xml;
-
-						// Firefox throws exceptions when accessing properties
-						// of an xhr when a network error occured
-						// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
-						try {
-
-							// Was never called and is aborted or complete
-							if ( callback && ( isAbort || xhr.readyState === 4 ) ) {
-
-								// Only called once
-								callback = undefined;
-
-								// Do not keep as active anymore
-								if ( handle ) {
-									xhr.onreadystatechange = jQuery.noop;
-									if ( xhrOnUnloadAbort ) {
-										delete xhrCallbacks[ handle ];
-									}
-								}
-
-								// If it's an abort
-								if ( isAbort ) {
-									// Abort it manually if needed
-									if ( xhr.readyState !== 4 ) {
-										xhr.abort();
-									}
-								} else {
-									status = xhr.status;
-									responseHeaders = xhr.getAllResponseHeaders();
-									responses = {};
-									xml = xhr.responseXML;
-
-									// Construct response list
-									if ( xml && xml.documentElement /* #4958 */ ) {
-										responses.xml = xml;
-									}
-									responses.text = xhr.responseText;
-
-									// Firefox throws an exception when accessing
-									// statusText for faulty cross-domain requests
-									try {
-										statusText = xhr.statusText;
-									} catch( e ) {
-										// We normalize with Webkit giving an empty statusText
-										statusText = "";
-									}
-
-									// Filter status for non standard behaviors
-
-									// If the request is local and we have data: assume a success
-									// (success with no data won't get notified, that's the best we
-									// can do given current implementations)
-									if ( !status && s.isLocal && !s.crossDomain ) {
-										status = responses.text ? 200 : 404;
-									// IE - #1450: sometimes returns 1223 when it should be 204
-									} else if ( status === 1223 ) {
-										status = 204;
-									}
-								}
-							}
-						} catch( firefoxAccessException ) {
-							if ( !isAbort ) {
-								complete( -1, firefoxAccessException );
-							}
-						}
-
-						// Call complete if needed
-						if ( responses ) {
-							complete( status, statusText, responses, responseHeaders );
-						}
-					};
-
-					// if we're in sync mode or it's in cache
-					// and has been retrieved directly (IE6 & IE7)
-					// we need to manually fire the callback
-					if ( !s.async || xhr.readyState === 4 ) {
-						callback();
-					} else {
-						handle = ++xhrId;
-						if ( xhrOnUnloadAbort ) {
-							// Create the active xhrs callbacks list if needed
-							// and attach the unload handler
-							if ( !xhrCallbacks ) {
-								xhrCallbacks = {};
-								jQuery( window ).unload( xhrOnUnloadAbort );
-							}
-							// Add to list of active xhrs callbacks
-							xhrCallbacks[ handle ] = callback;
-						}
-						xhr.onreadystatechange = callback;
-					}
-				},
-
-				abort: function() {
-					if ( callback ) {
-						callback(0,1);
-					}
-				}
-			};
-		}
-	});
+  jQuery.ajaxTransport(function( s ) {
+    // Cross domain only allowed if supported through XMLHttpRequest
+    if ( !s.crossDomain || jQuery.support.cors ) {
+
+      var callback;
+
+      return {
+        send: function( headers, complete ) {
+
+          // Get a new xhr
+          var xhr = s.xhr(),
+            handle,
+            i;
+
+          // Open the socket
+          // Passing null username, generates a login popup on Opera (#2865)
+          if ( s.username ) {
+            xhr.open( s.type, s.url, s.async, s.username, s.password );
+          } else {
+            xhr.open( s.type, s.url, s.async );
+          }
+
+          // Apply custom fields if provided
+          if ( s.xhrFields ) {
+            for ( i in s.xhrFields ) {
+              xhr[ i ] = s.xhrFields[ i ];
+            }
+          }
+
+          // Override mime type if needed
+          if ( s.mimeType && xhr.overrideMimeType ) {
+            xhr.overrideMimeType( s.mimeType );
+          }
+
+          // X-Requested-With header
+          // For cross-domain requests, seeing as conditions for a preflight are
+          // akin to a jigsaw puzzle, we simply never set it to be sure.
+          // (it can always be set on a per-request basis or even using ajaxSetup)
+          // For same-domain requests, won't change header if already provided.
+          if ( !s.crossDomain && !headers["X-Requested-With"] ) {
+            headers[ "X-Requested-With" ] = "XMLHttpRequest";
+          }
+
+          // Need an extra try/catch for cross domain requests in Firefox 3
+          try {
+            for ( i in headers ) {
+              xhr.setRequestHeader( i, headers[ i ] );
+            }
+          } catch( _ ) {}
+
+          // Do send the request
+          // This may raise an exception which is actually
+          // handled in jQuery.ajax (so no try/catch here)
+          xhr.send( ( s.hasContent && s.data ) || null );
+
+          // Listener
+          callback = function( _, isAbort ) {
+
+            var status,
+              statusText,
+              responseHeaders,
+              responses,
+              xml;
+
+            // Firefox throws exceptions when accessing properties
+            // of an xhr when a network error occured
+            // http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
+            try {
+
+              // Was never called and is aborted or complete
+              if ( callback && ( isAbort || xhr.readyState === 4 ) ) {
+
+                // Only called once
+                callback = undefined;
+
+                // Do not keep as active anymore
+                if ( handle ) {
+                  xhr.onreadystatechange = jQuery.noop;
+                  if ( xhrOnUnloadAbort ) {
+                    delete xhrCallbacks[ handle ];
+                  }
+                }
+
+                // If it's an abort
+                if ( isAbort ) {
+                  // Abort it manually if needed
+                  if ( xhr.readyState !== 4 ) {
+                    xhr.abort();
+                  }
+                } else {
+                  status = xhr.status;
+                  responseHeaders = xhr.getAllResponseHeaders();
+                  responses = {};
+                  xml = xhr.responseXML;
+
+                  // Construct response list
+                  if ( xml && xml.documentElement /* #4958 */ ) {
+                    responses.xml = xml;
+                  }
+                  responses.text = xhr.responseText;
+
+                  // Firefox throws an exception when accessing
+                  // statusText for faulty cross-domain requests
+                  try {
+                    statusText = xhr.statusText;
+                  } catch( e ) {
+                    // We normalize with Webkit giving an empty statusText
+                    statusText = "";
+                  }
+
+                  // Filter status for non standard behaviors
+
+                  // If the request is local and we have data: assume a success
+                  // (success with no data won't get notified, that's the best we
+                  // can do given current implementations)
+                  if ( !status && s.isLocal && !s.crossDomain ) {
+                    status = responses.text ? 200 : 404;
+                  // IE - #1450: sometimes returns 1223 when it should be 204
+                  } else if ( status === 1223 ) {
+                    status = 204;
+                  }
+                }
+              }
+            } catch( firefoxAccessException ) {
+              if ( !isAbort ) {
+                complete( -1, firefoxAccessException );
+              }
+            }
+
+            // Call complete if needed
+            if ( responses ) {
+              complete( status, statusText, responses, responseHeaders );
+            }
+          };
+
+          // if we're in sync mode or it's in cache
+          // and has been retrieved directly (IE6 & IE7)
+          // we need to manually fire the callback
+          if ( !s.async || xhr.readyState === 4 ) {
+            callback();
+          } else {
+            handle = ++xhrId;
+            if ( xhrOnUnloadAbort ) {
+              // Create the active xhrs callbacks list if needed
+              // and attach the unload handler
+              if ( !xhrCallbacks ) {
+                xhrCallbacks = {};
+                jQuery( window ).unload( xhrOnUnloadAbort );
+              }
+              // Add to list of active xhrs callbacks
+              xhrCallbacks[ handle ] = callback;
+            }
+            xhr.onreadystatechange = callback;
+          }
+        },
+
+        abort: function() {
+          if ( callback ) {
+            callback(0,1);
+          }
+        }
+      };
+    }
+  });
 }
 
 
 
 
 var elemdisplay = {},
-	iframe, iframeDoc,
-	rfxtypes = /^(?:toggle|show|hide)$/,
-	rfxnum = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,
-	timerId,
-	fxAttrs = [
-		// height animations
-		[ "height", "marginTop", "marginBottom", "paddingTop", "paddingBottom" ],
-		// width animations
-		[ "width", "marginLeft", "marginRight", "paddingLeft", "paddingRight" ],
-		// opacity animations
-		[ "opacity" ]
-	],
-	fxNow;
+  iframe, iframeDoc,
+  rfxtypes = /^(?:toggle|show|hide)$/,
+  rfxnum = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,
+  timerId,
+  fxAttrs = [
+    // height animations
+    [ "height", "marginTop", "marginBottom", "paddingTop", "paddingBottom" ],
+    // width animations
+    [ "width", "marginLeft", "marginRight", "paddingLeft", "paddingRight" ],
+    // opacity animations
+    [ "opacity" ]
+  ],
+  fxNow;
 
 jQuery.fn.extend({
-	show: function( speed, easing, callback ) {
-		var elem, display;
-
-		if ( speed || speed === 0 ) {
-			return this.animate( genFx("show", 3), speed, easing, callback );
-
-		} else {
-			for ( var i = 0, j = this.length; i < j; i++ ) {
-				elem = this[ i ];
-
-				if ( elem.style ) {
-					display = elem.style.display;
-
-					// Reset the inline display of this element to learn if it is
-					// being hidden by cascaded rules or not
-					if ( !jQuery._data(elem, "olddisplay") && display === "none" ) {
-						display = elem.style.display = "";
-					}
-
-					// Set elements which have been overridden with display: none
-					// in a stylesheet to whatever the default browser style is
-					// for such an element
-					if ( display === "" && jQuery.css(elem, "display") === "none" ) {
-						jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
-					}
-				}
-			}
-
-			// Set the display of most of the elements in a second loop
-			// to avoid the constant reflow
-			for ( i = 0; i < j; i++ ) {
-				elem = this[ i ];
-
-				if ( elem.style ) {
-					display = elem.style.display;
-
-					if ( display === "" || display === "none" ) {
-						elem.style.display = jQuery._data( elem, "olddisplay" ) || "";
-					}
-				}
-			}
-
-			return this;
-		}
-	},
-
-	hide: function( speed, easing, callback ) {
-		if ( speed || speed === 0 ) {
-			return this.animate( genFx("hide", 3), speed, easing, callback);
-
-		} else {
-			var elem, display,
-				i = 0,
-				j = this.length;
-
-			for ( ; i < j; i++ ) {
-				elem = this[i];
-				if ( elem.style ) {
-					display = jQuery.css( elem, "display" );
-
-					if ( display !== "none" && !jQuery._data( elem, "olddisplay" ) ) {
-						jQuery._data( elem, "olddisplay", display );
-					}
-				}
-			}
-
-			// Set the display of the elements in a second loop
-			// to avoid the constant reflow
-			for ( i = 0; i < j; i++ ) {
-				if ( this[i].style ) {
-					this[i].style.display = "none";
-				}
-			}
-
-			return this;
-		}
-	},
-
-	// Save the old toggle function
-	_toggle: jQuery.fn.toggle,
-
-	toggle: function( fn, fn2, callback ) {
-		var bool = typeof fn === "boolean";
-
-		if ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {
-			this._toggle.apply( this, arguments );
-
-		} else if ( fn == null || bool ) {
-			this.each(function() {
-				var state = bool ? fn : jQuery(this).is(":hidden");
-				jQuery(this)[ state ? "show" : "hide" ]();
-			});
-
-		} else {
-			this.animate(genFx("toggle", 3), fn, fn2, callback);
-		}
-
-		return this;
-	},
-
-	fadeTo: function( speed, to, easing, callback ) {
-		return this.filter(":hidden").css("opacity", 0).show().end()
-					.animate({opacity: to}, speed, easing, callback);
-	},
-
-	animate: function( prop, speed, easing, callback ) {
-		var optall = jQuery.speed( speed, easing, callback );
-
-		if ( jQuery.isEmptyObject( prop ) ) {
-			return this.each( optall.complete, [ false ] );
-		}
-
-		// Do not change referenced properties as per-property easing will be lost
-		prop = jQuery.extend( {}, prop );
-
-		function doAnimation() {
-			// XXX 'this' does not always have a nodeName when running the
-			// test suite
-
-			if ( optall.queue === false ) {
-				jQuery._mark( this );
-			}
-
-			var opt = jQuery.extend( {}, optall ),
-				isElement = this.nodeType === 1,
-				hidden = isElement && jQuery(this).is(":hidden"),
-				name, val, p, e,
-				parts, start, end, unit,
-				method;
-
-			// will store per property easing and be used to determine when an animation is complete
-			opt.animatedProperties = {};
-
-			for ( p in prop ) {
-
-				// property name normalization
-				name = jQuery.camelCase( p );
-				if ( p !== name ) {
-					prop[ name ] = prop[ p ];
-					delete prop[ p ];
-				}
-
-				val = prop[ name ];
-
-				// easing resolution: per property > opt.specialEasing > opt.easing > 'swing' (default)
-				if ( jQuery.isArray( val ) ) {
-					opt.animatedProperties[ name ] = val[ 1 ];
-					val = prop[ name ] = val[ 0 ];
-				} else {
-					opt.animatedProperties[ name ] = opt.specialEasing && opt.specialEasing[ name ] || opt.easing || 'swing';
-				}
-
-				if ( val === "hide" && hidden || val === "show" && !hidden ) {
-					return opt.complete.call( this );
-				}
-
-				if ( isElement && ( name === "height" || name === "width" ) ) {
-					// Make sure that nothing sneaks out
-					// Record all 3 overflow attributes because IE does not
-					// change the overflow attribute when overflowX and
-					// overflowY are set to the same value
-					opt.overflow = [ this.style.overflow, this.style.overflowX, this.style.overflowY ];
-
-					// Set display property to inline-block for height/width
-					// animations on inline elements that are having width/height animated
-					if ( jQuery.css( this, "display" ) === "inline" &&
-							jQuery.css( this, "float" ) === "none" ) {
-
-						// inline-level elements accept inline-block;
-						// block-level elements need to be inline with layout
-						if ( !jQuery.support.inlineBlockNeedsLayout || defaultDisplay( this.nodeName ) === "inline" ) {
-							this.style.display = "inline-block";
-
-						} else {
-							this.style.zoom = 1;
-						}
-					}
-				}
-			}
-
-			if ( opt.overflow != null ) {
-				this.style.overflow = "hidden";
-			}
-
-			for ( p in prop ) {
-				e = new jQuery.fx( this, opt, p );
-				val = prop[ p ];
-
-				if ( rfxtypes.test( val ) ) {
-
-					// Tracks whether to show or hide based on private
-					// data attached to the element
-					method = jQuery._data( this, "toggle" + p ) || ( val === "toggle" ? hidden ? "show" : "hide" : 0 );
-					if ( method ) {
-						jQuery._data( this, "toggle" + p, method === "show" ? "hide" : "show" );
-						e[ method ]();
-					} else {
-						e[ val ]();
-					}
-
-				} else {
-					parts = rfxnum.exec( val );
-					start = e.cur();
-
-					if ( parts ) {
-						end = parseFloat( parts[2] );
-						unit = parts[3] || ( jQuery.cssNumber[ p ] ? "" : "px" );
-
-						// We need to compute starting value
-						if ( unit !== "px" ) {
-							jQuery.style( this, p, (end || 1) + unit);
-							start = ( (end || 1) / e.cur() ) * start;
-							jQuery.style( this, p, start + unit);
-						}
-
-						// If a +=/-= token was provided, we're doing a relative animation
-						if ( parts[1] ) {
-							end = ( (parts[ 1 ] === "-=" ? -1 : 1) * end ) + start;
-						}
-
-						e.custom( start, end, unit );
-
-					} else {
-						e.custom( start, val, "" );
-					}
-				}
-			}
-
-			// For JS strict compliance
-			return true;
-		}
-
-		return optall.queue === false ?
-			this.each( doAnimation ) :
-			this.queue( optall.queue, doAnimation );
-	},
-
-	stop: function( type, clearQueue, gotoEnd ) {
-		if ( typeof type !== "string" ) {
-			gotoEnd = clearQueue;
-			clearQueue = type;
-			type = undefined;
-		}
-		if ( clearQueue && type !== false ) {
-			this.queue( type || "fx", [] );
-		}
-
-		return this.each(function() {
-			var index,
-				hadTimers = false,
-				timers = jQuery.timers,
-				data = jQuery._data( this );
-
-			// clear marker counters if we know they won't be
-			if ( !gotoEnd ) {
-				jQuery._unmark( true, this );
-			}
-
-			function stopQueue( elem, data, index ) {
-				var hooks = data[ index ];
-				jQuery.removeData( elem, index, true );
-				hooks.stop( gotoEnd );
-			}
-
-			if ( type == null ) {
-				for ( index in data ) {
-					if ( data[ index ] && data[ index ].stop && index.indexOf(".run") === index.length - 4 ) {
-						stopQueue( this, data, index );
-					}
-				}
-			} else if ( data[ index = type + ".run" ] && data[ index ].stop ){
-				stopQueue( this, data, index );
-			}
-
-			for ( index = timers.length; index--; ) {
-				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
-					if ( gotoEnd ) {
-
-						// force the next step to be the last
-						timers[ index ]( true );
-					} else {
-						timers[ index ].saveState();
-					}
-					hadTimers = true;
-					timers.splice( index, 1 );
-				}
-			}
-
-			// start the next in the queue if the last step wasn't forced
-			// timers currently will call their complete callbacks, which will dequeue
-			// but only if they were gotoEnd
-			if ( !( gotoEnd && hadTimers ) ) {
-				jQuery.dequeue( this, type );
-			}
-		});
-	}
+  show: function( speed, easing, callback ) {
+    var elem, display;
+
+    if ( speed || speed === 0 ) {
+      return this.animate( genFx("show", 3), speed, easing, callback );
+
+    } else {
+      for ( var i = 0, j = this.length; i < j; i++ ) {
+        elem = this[ i ];
+
+        if ( elem.style ) {
+          display = elem.style.display;
+
+          // Reset the inline display of this element to learn if it is
+          // being hidden by cascaded rules or not
+          if ( !jQuery._data(elem, "olddisplay") && display === "none" ) {
+            display = elem.style.display = "";
+          }
+
+          // Set elements which have been overridden with display: none
+          // in a stylesheet to whatever the default browser style is
+          // for such an element
+          if ( display === "" && jQuery.css(elem, "display") === "none" ) {
+            jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
+          }
+        }
+      }
+
+      // Set the display of most of the elements in a second loop
+      // to avoid the constant reflow
+      for ( i = 0; i < j; i++ ) {
+        elem = this[ i ];
+
+        if ( elem.style ) {
+          display = elem.style.display;
+
+          if ( display === "" || display === "none" ) {
+            elem.style.display = jQuery._data( elem, "olddisplay" ) || "";
+          }
+        }
+      }
+
+      return this;
+    }
+  },
+
+  hide: function( speed, easing, callback ) {
+    if ( speed || speed === 0 ) {
+      return this.animate( genFx("hide", 3), speed, easing, callback);
+
+    } else {
+      var elem, display,
+        i = 0,
+        j = this.length;
+
+      for ( ; i < j; i++ ) {
+        elem = this[i];
+        if ( elem.style ) {
+          display = jQuery.css( elem, "display" );
+
+          if ( display !== "none" && !jQuery._data( elem, "olddisplay" ) ) {
+            jQuery._data( elem, "olddisplay", display );
+          }
+        }
+      }
+
+      // Set the display of the elements in a second loop
+      // to avoid the constant reflow
+      for ( i = 0; i < j; i++ ) {
+        if ( this[i].style ) {
+          this[i].style.display = "none";
+        }
+      }
+
+      return this;
+    }
+  },
+
+  // Save the old toggle function
+  _toggle: jQuery.fn.toggle,
+
+  toggle: function( fn, fn2, callback ) {
+    var bool = typeof fn === "boolean";
+
+    if ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {
+      this._toggle.apply( this, arguments );
+
+    } else if ( fn == null || bool ) {
+      this.each(function() {
+        var state = bool ? fn : jQuery(this).is(":hidden");
+        jQuery(this)[ state ? "show" : "hide" ]();
+      });
+
+    } else {
+      this.animate(genFx("toggle", 3), fn, fn2, callback);
+    }
+
+    return this;
+  },
+
+  fadeTo: function( speed, to, easing, callback ) {
+    return this.filter(":hidden").css("opacity", 0).show().end()
+          .animate({opacity: to}, speed, easing, callback);
+  },
+
+  animate: function( prop, speed, easing, callback ) {
+    var optall = jQuery.speed( speed, easing, callback );
+
+    if ( jQuery.isEmptyObject( prop ) ) {
+      return this.each( optall.complete, [ false ] );
+    }
+
+    // Do not change referenced properties as per-property easing will be lost
+    prop = jQuery.extend( {}, prop );
+
+    function doAnimation() {
+      // XXX 'this' does not always have a nodeName when running the
+      // test suite
+
+      if ( optall.queue === false ) {
+        jQuery._mark( this );
+      }
+
+      var opt = jQuery.extend( {}, optall ),
+        isElement = this.nodeType === 1,
+        hidden = isElement && jQuery(this).is(":hidden"),
+        name, val, p, e,
+        parts, start, end, unit,
+        method;
+
+      // will store per property easing and be used to determine when an animation is complete
+      opt.animatedProperties = {};
+
+      for ( p in prop ) {
+
+        // property name normalization
+        name = jQuery.camelCase( p );
+        if ( p !== name ) {
+          prop[ name ] = prop[ p ];
+          delete prop[ p ];
+        }
+
+        val = prop[ name ];
+
+        // easing resolution: per property > opt.specialEasing > opt.easing > 'swing' (default)
+        if ( jQuery.isArray( val ) ) {
+          opt.animatedProperties[ name ] = val[ 1 ];
+          val = prop[ name ] = val[ 0 ];
+        } else {
+          opt.animatedProperties[ name ] = opt.specialEasing && opt.specialEasing[ name ] || opt.easing || 'swing';
+        }
+
+        if ( val === "hide" && hidden || val === "show" && !hidden ) {
+          return opt.complete.call( this );
+        }
+
+        if ( isElement && ( name === "height" || name === "width" ) ) {
+          // Make sure that nothing sneaks out
+          // Record all 3 overflow attributes because IE does not
+          // change the overflow attribute when overflowX and
+          // overflowY are set to the same value
+          opt.overflow = [ this.style.overflow, this.style.overflowX, this.style.overflowY ];
+
+          // Set display property to inline-block for height/width
+          // animations on inline elements that are having width/height animated
+          if ( jQuery.css( this, "display" ) === "inline" &&
+              jQuery.css( this, "float" ) === "none" ) {
+
+            // inline-level elements accept inline-block;
+            // block-level elements need to be inline with layout
+            if ( !jQuery.support.inlineBlockNeedsLayout || defaultDisplay( this.nodeName ) === "inline" ) {
+              this.style.display = "inline-block";
+
+            } else {
+              this.style.zoom = 1;
+            }
+          }
+        }
+      }
+
+      if ( opt.overflow != null ) {
+        this.style.overflow = "hidden";
+      }
+
+      for ( p in prop ) {
+        e = new jQuery.fx( this, opt, p );
+        val = prop[ p ];
+
+        if ( rfxtypes.test( val ) ) {
+
+          // Tracks whether to show or hide based on private
+          // data attached to the element
+          method = jQuery._data( this, "toggle" + p ) || ( val === "toggle" ? hidden ? "show" : "hide" : 0 );
+          if ( method ) {
+            jQuery._data( this, "toggle" + p, method === "show" ? "hide" : "show" );
+            e[ method ]();
+          } else {
+            e[ val ]();
+          }
+
+        } else {
+          parts = rfxnum.exec( val );
+          start = e.cur();
+
+          if ( parts ) {
+            end = parseFloat( parts[2] );
+            unit = parts[3] || ( jQuery.cssNumber[ p ] ? "" : "px" );
+
+            // We need to compute starting value
+            if ( unit !== "px" ) {
+              jQuery.style( this, p, (end || 1) + unit);
+              start = ( (end || 1) / e.cur() ) * start;
+              jQuery.style( this, p, start + unit);
+            }
+
+            // If a +=/-= token was provided, we're doing a relative animation
+            if ( parts[1] ) {
+              end = ( (parts[ 1 ] === "-=" ? -1 : 1) * end ) + start;
+            }
+
+            e.custom( start, end, unit );
+
+          } else {
+            e.custom( start, val, "" );
+          }
+        }
+      }
+
+      // For JS strict compliance
+      return true;
+    }
+
+    return optall.queue === false ?
+      this.each( doAnimation ) :
+      this.queue( optall.queue, doAnimation );
+  },
+
+  stop: function( type, clearQueue, gotoEnd ) {
+    if ( typeof type !== "string" ) {
+      gotoEnd = clearQueue;
+      clearQueue = type;
+      type = undefined;
+    }
+    if ( clearQueue && type !== false ) {
+      this.queue( type || "fx", [] );
+    }
+
+    return this.each(function() {
+      var index,
+        hadTimers = false,
+        timers = jQuery.timers,
+        data = jQuery._data( this );
+
+      // clear marker counters if we know they won't be
+      if ( !gotoEnd ) {
+        jQuery._unmark( true, this );
+      }
+
+      function stopQueue( elem, data, index ) {
+        var hooks = data[ index ];
+        jQuery.removeData( elem, index, true );
+        hooks.stop( gotoEnd );
+      }
+
+      if ( type == null ) {
+        for ( index in data ) {
+          if ( data[ index ] && data[ index ].stop && index.indexOf(".run") === index.length - 4 ) {
+            stopQueue( this, data, index );
+          }
+        }
+      } else if ( data[ index = type + ".run" ] && data[ index ].stop ){
+        stopQueue( this, data, index );
+      }
+
+      for ( index = timers.length; index--; ) {
+        if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
+          if ( gotoEnd ) {
+
+            // force the next step to be the last
+            timers[ index ]( true );
+          } else {
+            timers[ index ].saveState();
+          }
+          hadTimers = true;
+          timers.splice( index, 1 );
+        }
+      }
+
+      // start the next in the queue if the last step wasn't forced
+      // timers currently will call their complete callbacks, which will dequeue
+      // but only if they were gotoEnd
+      if ( !( gotoEnd && hadTimers ) ) {
+        jQuery.dequeue( this, type );
+      }
+    });
+  }
 
 });
 
 // Animations created synchronously will run synchronously
 function createFxNow() {
-	setTimeout( clearFxNow, 0 );
-	return ( fxNow = jQuery.now() );
+  setTimeout( clearFxNow, 0 );
+  return ( fxNow = jQuery.now() );
 }
 
 function clearFxNow() {
-	fxNow = undefined;
+  fxNow = undefined;
 }
 
 // Generate parameters to create a standard animation
 function genFx( type, num ) {
-	var obj = {};
+  var obj = {};
 
-	jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice( 0, num )), function() {
-		obj[ this ] = type;
-	});
+  jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice( 0, num )), function() {
+    obj[ this ] = type;
+  });
 
-	return obj;
+  return obj;
 }
 
 // Generate shortcuts for custom animations
 jQuery.each({
-	slideDown: genFx( "show", 1 ),
-	slideUp: genFx( "hide", 1 ),
-	slideToggle: genFx( "toggle", 1 ),
-	fadeIn: { opacity: "show" },
-	fadeOut: { opacity: "hide" },
-	fadeToggle: { opacity: "toggle" }
+  slideDown: genFx( "show", 1 ),
+  slideUp: genFx( "hide", 1 ),
+  slideToggle: genFx( "toggle", 1 ),
+  fadeIn: { opacity: "show" },
+  fadeOut: { opacity: "hide" },
+  fadeToggle: { opacity: "toggle" }
 }, function( name, props ) {
-	jQuery.fn[ name ] = function( speed, easing, callback ) {
-		return this.animate( props, speed, easing, callback );
-	};
+  jQuery.fn[ name ] = function( speed, easing, callback ) {
+    return this.animate( props, speed, easing, callback );
+  };
 });
 
 jQuery.extend({
-	speed: function( speed, easing, fn ) {
-		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
-			complete: fn || !fn && easing ||
-				jQuery.isFunction( speed ) && speed,
-			duration: speed,
-			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
-		};
-
-		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
-			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;
-
-		// normalize opt.queue - true/undefined/null -> "fx"
-		if ( opt.queue == null || opt.queue === true ) {
-			opt.queue = "fx";
-		}
-
-		// Queueing
-		opt.old = opt.complete;
-
-		opt.complete = function( noUnmark ) {
-			if ( jQuery.isFunction( opt.old ) ) {
-				opt.old.call( this );
-			}
-
-			if ( opt.queue ) {
-				jQuery.dequeue( this, opt.queue );
-			} else if ( noUnmark !== false ) {
-				jQuery._unmark( this );
-			}
-		};
-
-		return opt;
-	},
-
-	easing: {
-		linear: function( p, n, firstNum, diff ) {
-			return firstNum + diff * p;
-		},
-		swing: function( p, n, firstNum, diff ) {
-			return ( ( -Math.cos( p*Math.PI ) / 2 ) + 0.5 ) * diff + firstNum;
-		}
-	},
-
-	timers: [],
-
-	fx: function( elem, options, prop ) {
-		this.options = options;
-		this.elem = elem;
-		this.prop = prop;
-
-		options.orig = options.orig || {};
-	}
+  speed: function( speed, easing, fn ) {
+    var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
+      complete: fn || !fn && easing ||
+        jQuery.isFunction( speed ) && speed,
+      duration: speed,
+      easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
+    };
+
+    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
+      opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;
+
+    // normalize opt.queue - true/undefined/null -> "fx"
+    if ( opt.queue == null || opt.queue === true ) {
+      opt.queue = "fx";
+    }
+
+    // Queueing
+    opt.old = opt.complete;
+
+    opt.complete = function( noUnmark ) {
+      if ( jQuery.isFunction( opt.old ) ) {
+        opt.old.call( this );
+      }
+
+      if ( opt.queue ) {
+        jQuery.dequeue( this, opt.queue );
+      } else if ( noUnmark !== false ) {
+        jQuery._unmark( this );
+      }
+    };
+
+    return opt;
+  },
+
+  easing: {
+    linear: function( p, n, firstNum, diff ) {
+      return firstNum + diff * p;
+    },
+    swing: function( p, n, firstNum, diff ) {
+      return ( ( -Math.cos( p*Math.PI ) / 2 ) + 0.5 ) * diff + firstNum;
+    }
+  },
+
+  timers: [],
+
+  fx: function( elem, options, prop ) {
+    this.options = options;
+    this.elem = elem;
+    this.prop = prop;
+
+    options.orig = options.orig || {};
+  }
 
 });
 
 jQuery.fx.prototype = {
-	// Simple function for setting a style value
-	update: function() {
-		if ( this.options.step ) {
-			this.options.step.call( this.elem, this.now, this );
-		}
-
-		( jQuery.fx.step[ this.prop ] || jQuery.fx.step._default )( this );
-	},
-
-	// Get the current size
-	cur: function() {
-		if ( this.elem[ this.prop ] != null && (!this.elem.style || this.elem.style[ this.prop ] == null) ) {
-			return this.elem[ this.prop ];
-		}
-
-		var parsed,
-			r = jQuery.css( this.elem, this.prop );
-		// Empty strings, null, undefined and "auto" are converted to 0,
-		// complex values such as "rotate(1rad)" are returned as is,
-		// simple values such as "10px" are parsed to Float.
-		return isNaN( parsed = parseFloat( r ) ) ? !r || r === "auto" ? 0 : r : parsed;
-	},
-
-	// Start an animation from one number to another
-	custom: function( from, to, unit ) {
-		var self = this,
-			fx = jQuery.fx;
-
-		this.startTime = fxNow || createFxNow();
-		this.end = to;
-		this.now = this.start = from;
-		this.pos = this.state = 0;
-		this.unit = unit || this.unit || ( jQuery.cssNumber[ this.prop ] ? "" : "px" );
-
-		function t( gotoEnd ) {
-			return self.step( gotoEnd );
-		}
-
-		t.queue = this.options.queue;
-		t.elem = this.elem;
-		t.saveState = function() {
-			if ( self.options.hide && jQuery._data( self.elem, "fxshow" + self.prop ) === undefined ) {
-				jQuery._data( self.elem, "fxshow" + self.prop, self.start );
-			}
-		};
-
-		if ( t() && jQuery.timers.push(t) && !timerId ) {
-			timerId = setInterval( fx.tick, fx.interval );
-		}
-	},
-
-	// Simple 'show' function
-	show: function() {
-		var dataShow = jQuery._data( this.elem, "fxshow" + this.prop );
-
-		// Remember where we started, so that we can go back to it later
-		this.options.orig[ this.prop ] = dataShow || jQuery.style( this.elem, this.prop );
-		this.options.show = true;
-
-		// Begin the animation
-		// Make sure that we start at a small width/height to avoid any flash of content
-		if ( dataShow !== undefined ) {
-			// This show is picking up where a previous hide or show left off
-			this.custom( this.cur(), dataShow );
-		} else {
-			this.custom( this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur() );
-		}
-
-		// Start by showing the element
-		jQuery( this.elem ).show();
-	},
-
-	// Simple 'hide' function
-	hide: function() {
-		// Remember where we started, so that we can go back to it later
-		this.options.orig[ this.prop ] = jQuery._data( this.elem, "fxshow" + this.prop ) || jQuery.style( this.elem, this.prop );
-		this.options.hide = true;
-
-		// Begin the animation
-		this.custom( this.cur(), 0 );
-	},
-
-	// Each step of an animation
-	step: function( gotoEnd ) {
-		var p, n, complete,
-			t = fxNow || createFxNow(),
-			done = true,
-			elem = this.elem,
-			options = this.options;
-
-		if ( gotoEnd || t >= options.duration + this.startTime ) {
-			this.now = this.end;
-			this.pos = this.state = 1;
-			this.update();
-
-			options.animatedProperties[ this.prop ] = true;
-
-			for ( p in options.animatedProperties ) {
-				if ( options.animatedProperties[ p ] !== true ) {
-					done = false;
-				}
-			}
-
-			if ( done ) {
-				// Reset the overflow
-				if ( options.overflow != null && !jQuery.support.shrinkWrapBlocks ) {
-
-					jQuery.each( [ "", "X", "Y" ], function( index, value ) {
-						elem.style[ "overflow" + value ] = options.overflow[ index ];
-					});
-				}
-
-				// Hide the element if the "hide" operation was done
-				if ( options.hide ) {
-					jQuery( elem ).hide();
-				}
-
-				// Reset the properties, if the item has been hidden or shown
-				if ( options.hide || options.show ) {
-					for ( p in options.animatedProperties ) {
-						jQuery.style( elem, p, options.orig[ p ] );
-						jQuery.removeData( elem, "fxshow" + p, true );
-						// Toggle data is no longer needed
-						jQuery.removeData( elem, "toggle" + p, true );
-					}
-				}
-
-				// Execute the complete function
-				// in the event that the complete function throws an exception
-				// we must ensure it won't be called twice. #5684
-
-				complete = options.complete;
-				if ( complete ) {
-
-					options.complete = false;
-					complete.call( elem );
-				}
-			}
-
-			return false;
-
-		} else {
-			// classical easing cannot be used with an Infinity duration
-			if ( options.duration == Infinity ) {
-				this.now = t;
-			} else {
-				n = t - this.startTime;
-				this.state = n / options.duration;
-
-				// Perform the easing function, defaults to swing
-				this.pos = jQuery.easing[ options.animatedProperties[this.prop] ]( this.state, n, 0, 1, options.duration );
-				this.now = this.start + ( (this.end - this.start) * this.pos );
-			}
-			// Perform the next step of the animation
-			this.update();
-		}
-
-		return true;
-	}
+  // Simple function for setting a style value
+  update: function() {
+    if ( this.options.step ) {
+      this.options.step.call( this.elem, this.now, this );
+    }
+
+    ( jQuery.fx.step[ this.prop ] || jQuery.fx.step._default )( this );
+  },
+
+  // Get the current size
+  cur: function() {
+    if ( this.elem[ this.prop ] != null && (!this.elem.style || this.elem.style[ this.prop ] == null) ) {
+      return this.elem[ this.prop ];
+    }
+
+    var parsed,
+      r = jQuery.css( this.elem, this.prop );
+    // Empty strings, null, undefined and "auto" are converted to 0,
+    // complex values such as "rotate(1rad)" are returned as is,
+    // simple values such as "10px" are parsed to Float.
+    return isNaN( parsed = parseFloat( r ) ) ? !r || r === "auto" ? 0 : r : parsed;
+  },
+
+  // Start an animation from one number to another
+  custom: function( from, to, unit ) {
+    var self = this,
+      fx = jQuery.fx;
+
+    this.startTime = fxNow || createFxNow();
+    this.end = to;
+    this.now = this.start = from;
+    this.pos = this.state = 0;
+    this.unit = unit || this.unit || ( jQuery.cssNumber[ this.prop ] ? "" : "px" );
+
+    function t( gotoEnd ) {
+      return self.step( gotoEnd );
+    }
+
+    t.queue = this.options.queue;
+    t.elem = this.elem;
+    t.saveState = function() {
+      if ( self.options.hide && jQuery._data( self.elem, "fxshow" + self.prop ) === undefined ) {
+        jQuery._data( self.elem, "fxshow" + self.prop, self.start );
+      }
+    };
+
+    if ( t() && jQuery.timers.push(t) && !timerId ) {
+      timerId = setInterval( fx.tick, fx.interval );
+    }
+  },
+
+  // Simple 'show' function
+  show: function() {
+    var dataShow = jQuery._data( this.elem, "fxshow" + this.prop );
+
+    // Remember where we started, so that we can go back to it later
+    this.options.orig[ this.prop ] = dataShow || jQuery.style( this.elem, this.prop );
+    this.options.show = true;
+
+    // Begin the animation
+    // Make sure that we start at a small width/height to avoid any flash of content
+    if ( dataShow !== undefined ) {
+      // This show is picking up where a previous hide or show left off
+      this.custom( this.cur(), dataShow );
+    } else {
+      this.custom( this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur() );
+    }
+
+    // Start by showing the element
+    jQuery( this.elem ).show();
+  },
+
+  // Simple 'hide' function
+  hide: function() {
+    // Remember where we started, so that we can go back to it later
+    this.options.orig[ this.prop ] = jQuery._data( this.elem, "fxshow" + this.prop ) || jQuery.style( this.elem, this.prop );
+    this.options.hide = true;
+
+    // Begin the animation
+    this.custom( this.cur(), 0 );
+  },
+
+  // Each step of an animation
+  step: function( gotoEnd ) {
+    var p, n, complete,
+      t = fxNow || createFxNow(),
+      done = true,
+      elem = this.elem,
+      options = this.options;
+
+    if ( gotoEnd || t >= options.duration + this.startTime ) {
+      this.now = this.end;
+      this.pos = this.state = 1;
+      this.update();
+
+      options.animatedProperties[ this.prop ] = true;
+
+      for ( p in options.animatedProperties ) {
+        if ( options.animatedProperties[ p ] !== true ) {
+          done = false;
+        }
+      }
+
+      if ( done ) {
+        // Reset the overflow
+        if ( options.overflow != null && !jQuery.support.shrinkWrapBlocks ) {
+
+          jQuery.each( [ "", "X", "Y" ], function( index, value ) {
+            elem.style[ "overflow" + value ] = options.overflow[ index ];
+          });
+        }
+
+        // Hide the element if the "hide" operation was done
+        if ( options.hide ) {
+          jQuery( elem ).hide();
+        }
+
+        // Reset the properties, if the item has been hidden or shown
+        if ( options.hide || options.show ) {
+          for ( p in options.animatedProperties ) {
+            jQuery.style( elem, p, options.orig[ p ] );
+            jQuery.removeData( elem, "fxshow" + p, true );
+            // Toggle data is no longer needed
+            jQuery.removeData( elem, "toggle" + p, true );
+          }
+        }
+
+        // Execute the complete function
+        // in the event that the complete function throws an exception
+        // we must ensure it won't be called twice. #5684
+
+        complete = options.complete;
+        if ( complete ) {
+
+          options.complete = false;
+          complete.call( elem );
+        }
+      }
+
+      return false;
+
+    } else {
+      // classical easing cannot be used with an Infinity duration
+      if ( options.duration == Infinity ) {
+        this.now = t;
+      } else {
+        n = t - this.startTime;
+        this.state = n / options.duration;
+
+        // Perform the easing function, defaults to swing
+        this.pos = jQuery.easing[ options.animatedProperties[this.prop] ]( this.state, n, 0, 1, options.duration );
+        this.now = this.start + ( (this.end - this.start) * this.pos );
+      }
+      // Perform the next step of the animation
+      this.update();
+    }
+
+    return true;
+  }
 };
 
 jQuery.extend( jQuery.fx, {
-	tick: function() {
-		var timer,
-			timers = jQuery.timers,
-			i = 0;
-
-		for ( ; i < timers.length; i++ ) {
-			timer = timers[ i ];
-			// Checks the timer has not already been removed
-			if ( !timer() && timers[ i ] === timer ) {
-				timers.splice( i--, 1 );
-			}
-		}
-
-		if ( !timers.length ) {
-			jQuery.fx.stop();
-		}
-	},
-
-	interval: 13,
-
-	stop: function() {
-		clearInterval( timerId );
-		timerId = null;
-	},
-
-	speeds: {
-		slow: 600,
-		fast: 200,
-		// Default speed
-		_default: 400
-	},
-
-	step: {
-		opacity: function( fx ) {
-			jQuery.style( fx.elem, "opacity", fx.now );
-		},
-
-		_default: function( fx ) {
-			if ( fx.elem.style && fx.elem.style[ fx.prop ] != null ) {
-				fx.elem.style[ fx.prop ] = fx.now + fx.unit;
-			} else {
-				fx.elem[ fx.prop ] = fx.now;
-			}
-		}
-	}
+  tick: function() {
+    var timer,
+      timers = jQuery.timers,
+      i = 0;
+
+    for ( ; i < timers.length; i++ ) {
+      timer = timers[ i ];
+      // Checks the timer has not already been removed
+      if ( !timer() && timers[ i ] === timer ) {
+        timers.splice( i--, 1 );
+      }
+    }
+
+    if ( !timers.length ) {
+      jQuery.fx.stop();
+    }
+  },
+
+  interval: 13,
+
+  stop: function() {
+    clearInterval( timerId );
+    timerId = null;
+  },
+
+  speeds: {
+    slow: 600,
+    fast: 200,
+    // Default speed
+    _default: 400
+  },
+
+  step: {
+    opacity: function( fx ) {
+      jQuery.style( fx.elem, "opacity", fx.now );
+    },
+
+    _default: function( fx ) {
+      if ( fx.elem.style && fx.elem.style[ fx.prop ] != null ) {
+        fx.elem.style[ fx.prop ] = fx.now + fx.unit;
+      } else {
+        fx.elem[ fx.prop ] = fx.now;
+      }
+    }
+  }
 });
 
 // Adds width/height step functions
 // Do not set anything below 0
 jQuery.each([ "width", "height" ], function( i, prop ) {
-	jQuery.fx.step[ prop ] = function( fx ) {
-		jQuery.style( fx.elem, prop, Math.max(0, fx.now) + fx.unit );
-	};
+  jQuery.fx.step[ prop ] = function( fx ) {
+    jQuery.style( fx.elem, prop, Math.max(0, fx.now) + fx.unit );
+  };
 });
 
 if ( jQuery.expr && jQuery.expr.filters ) {
-	jQuery.expr.filters.animated = function( elem ) {
-		return jQuery.grep(jQuery.timers, function( fn ) {
-			return elem === fn.elem;
-		}).length;
-	};
+  jQuery.expr.filters.animated = function( elem ) {
+    return jQuery.grep(jQuery.timers, function( fn ) {
+      return elem === fn.elem;
+    }).length;
+  };
 }
 
 // Try to restore the default display value of an element
 function defaultDisplay( nodeName ) {
 
-	if ( !elemdisplay[ nodeName ] ) {
+  if ( !elemdisplay[ nodeName ] ) {
 
-		var body = document.body,
-			elem = jQuery( "<" + nodeName + ">" ).appendTo( body ),
-			display = elem.css( "display" );
-		elem.remove();
+    var body = document.body,
+      elem = jQuery( "<" + nodeName + ">" ).appendTo( body ),
+      display = elem.css( "display" );
+    elem.remove();
 
-		// If the simple way fails,
-		// get element's real default display by attaching it to a temp iframe
-		if ( display === "none" || display === "" ) {
-			// No iframe to use yet, so create it
-			if ( !iframe ) {
-				iframe = document.createElement( "iframe" );
-				iframe.frameBorder = iframe.width = iframe.height = 0;
-			}
+    // If the simple way fails,
+    // get element's real default display by attaching it to a temp iframe
+    if ( display === "none" || display === "" ) {
+      // No iframe to use yet, so create it
+      if ( !iframe ) {
+        iframe = document.createElement( "iframe" );
+        iframe.frameBorder = iframe.width = iframe.height = 0;
+      }
 
-			body.appendChild( iframe );
+      body.appendChild( iframe );
 
-			// Create a cacheable copy of the iframe document on first call.
-			// IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
-			// document to it; WebKit & Firefox won't allow reusing the iframe document.
-			if ( !iframeDoc || !iframe.createElement ) {
-				iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
-				iframeDoc.write( ( document.compatMode === "CSS1Compat" ? "<!doctype html>" : "" ) + "<html><body>" );
-				iframeDoc.close();
-			}
+      // Create a cacheable copy of the iframe document on first call.
+      // IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
+      // document to it; WebKit & Firefox won't allow reusing the iframe document.
+      if ( !iframeDoc || !iframe.createElement ) {
+        iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
+        iframeDoc.write( ( document.compatMode === "CSS1Compat" ? "<!doctype html>" : "" ) + "<html><body>" );
+        iframeDoc.close();
+      }
 
-			elem = iframeDoc.createElement( nodeName );
+      elem = iframeDoc.createElement( nodeName );
 
-			iframeDoc.body.appendChild( elem );
+      iframeDoc.body.appendChild( elem );
 
-			display = jQuery.css( elem, "display" );
-			body.removeChild( iframe );
-		}
+      display = jQuery.css( elem, "display" );
+      body.removeChild( iframe );
+    }
 
-		// Store the correct default display
-		elemdisplay[ nodeName ] = display;
-	}
+    // Store the correct default display
+    elemdisplay[ nodeName ] = display;
+  }
 
-	return elemdisplay[ nodeName ];
+  return elemdisplay[ nodeName ];
 }
 
 
 
 
 var rtable = /^t(?:able|d|h)$/i,
-	rroot = /^(?:body|html)$/i;
+  rroot = /^(?:body|html)$/i;
 
 if ( "getBoundingClientRect" in document.documentElement ) {
-	jQuery.fn.offset = function( options ) {
-		var elem = this[0], box;
-
-		if ( options ) {
-			return this.each(function( i ) {
-				jQuery.offset.setOffset( this, options, i );
-			});
-		}
-
-		if ( !elem || !elem.ownerDocument ) {
-			return null;
-		}
-
-		if ( elem === elem.ownerDocument.body ) {
-			return jQuery.offset.bodyOffset( elem );
-		}
-
-		try {
-			box = elem.getBoundingClientRect();
-		} catch(e) {}
-
-		var doc = elem.ownerDocument,
-			docElem = doc.documentElement;
-
-		// Make sure we're not dealing with a disconnected DOM node
-		if ( !box || !jQuery.contains( docElem, elem ) ) {
-			return box ? { top: box.top, left: box.left } : { top: 0, left: 0 };
-		}
-
-		var body = doc.body,
-			win = getWindow(doc),
-			clientTop  = docElem.clientTop  || body.clientTop  || 0,
-			clientLeft = docElem.clientLeft || body.clientLeft || 0,
-			scrollTop  = win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop  || body.scrollTop,
-			scrollLeft = win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft,
-			top  = box.top  + scrollTop  - clientTop,
-			left = box.left + scrollLeft - clientLeft;
-
-		return { top: top, left: left };
-	};
+  jQuery.fn.offset = function( options ) {
+    var elem = this[0], box;
+
+    if ( options ) {
+      return this.each(function( i ) {
+        jQuery.offset.setOffset( this, options, i );
+      });
+    }
+
+    if ( !elem || !elem.ownerDocument ) {
+      return null;
+    }
+
+    if ( elem === elem.ownerDocument.body ) {
+      return jQuery.offset.bodyOffset( elem );
+    }
+
+    try {
+      box = elem.getBoundingClientRect();
+    } catch(e) {}
+
+    var doc = elem.ownerDocument,
+      docElem = doc.documentElement;
+
+    // Make sure we're not dealing with a disconnected DOM node
+    if ( !box || !jQuery.contains( docElem, elem ) ) {
+      return box ? { top: box.top, left: box.left } : { top: 0, left: 0 };
+    }
+
+    var body = doc.body,
+      win = getWindow(doc),
+      clientTop  = docElem.clientTop  || body.clientTop  || 0,
+      clientLeft = docElem.clientLeft || body.clientLeft || 0,
+      scrollTop  = win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop  || body.scrollTop,
+      scrollLeft = win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft,
+      top  = box.top  + scrollTop  - clientTop,
+      left = box.left + scrollLeft - clientLeft;
+
+    return { top: top, left: left };
+  };
 
 } else {
-	jQuery.fn.offset = function( options ) {
-		var elem = this[0];
-
-		if ( options ) {
-			return this.each(function( i ) {
-				jQuery.offset.setOffset( this, options, i );
-			});
-		}
-
-		if ( !elem || !elem.ownerDocument ) {
-			return null;
-		}
-
-		if ( elem === elem.ownerDocument.body ) {
-			return jQuery.offset.bodyOffset( elem );
-		}
-
-		var computedStyle,
-			offsetParent = elem.offsetParent,
-			prevOffsetParent = elem,
-			doc = elem.ownerDocument,
-			docElem = doc.documentElement,
-			body = doc.body,
-			defaultView = doc.defaultView,
-			prevComputedStyle = defaultView ? defaultView.getComputedStyle( elem, null ) : elem.currentStyle,
-			top = elem.offsetTop,
-			left = elem.offsetLeft;
-
-		while ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) {
-			if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
-				break;
-			}
-
-			computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
-			top  -= elem.scrollTop;
-			left -= elem.scrollLeft;
-
-			if ( elem === offsetParent ) {
-				top  += elem.offsetTop;
-				left += elem.offsetLeft;
-
-				if ( jQuery.support.doesNotAddBorder && !(jQuery.support.doesAddBorderForTableAndCells && rtable.test(elem.nodeName)) ) {
-					top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
-					left += parseFloat( computedStyle.borderLeftWidth ) || 0;
-				}
-
-				prevOffsetParent = offsetParent;
-				offsetParent = elem.offsetParent;
-			}
-
-			if ( jQuery.support.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible" ) {
-				top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
-				left += parseFloat( computedStyle.borderLeftWidth ) || 0;
-			}
-
-			prevComputedStyle = computedStyle;
-		}
-
-		if ( prevComputedStyle.position === "relative" || prevComputedStyle.position === "static" ) {
-			top  += body.offsetTop;
-			left += body.offsetLeft;
-		}
-
-		if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
-			top  += Math.max( docElem.scrollTop, body.scrollTop );
-			left += Math.max( docElem.scrollLeft, body.scrollLeft );
-		}
-
-		return { top: top, left: left };
-	};
+  jQuery.fn.offset = function( options ) {
+    var elem = this[0];
+
+    if ( options ) {
+      return this.each(function( i ) {
+        jQuery.offset.setOffset( this, options, i );
+      });
+    }
+
+    if ( !elem || !elem.ownerDocument ) {
+      return null;
+    }
+
+    if ( elem === elem.ownerDocument.body ) {
+      return jQuery.offset.bodyOffset( elem );
+    }
+
+    var computedStyle,
+      offsetParent = elem.offsetParent,
+      prevOffsetParent = elem,
+      doc = elem.ownerDocument,
+      docElem = doc.documentElement,
+      body = doc.body,
+      defaultView = doc.defaultView,
+      prevComputedStyle = defaultView ? defaultView.getComputedStyle( elem, null ) : elem.currentStyle,
+      top = elem.offsetTop,
+      left = elem.offsetLeft;
+
+    while ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) {
+      if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
+        break;
+      }
+
+      computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
+      top  -= elem.scrollTop;
+      left -= elem.scrollLeft;
+
+      if ( elem === offsetParent ) {
+        top  += elem.offsetTop;
+        left += elem.offsetLeft;
+
+        if ( jQuery.support.doesNotAddBorder && !(jQuery.support.doesAddBorderForTableAndCells && rtable.test(elem.nodeName)) ) {
+          top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
+          left += parseFloat( computedStyle.borderLeftWidth ) || 0;
+        }
+
+        prevOffsetParent = offsetParent;
+        offsetParent = elem.offsetParent;
+      }
+
+      if ( jQuery.support.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible" ) {
+        top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
+        left += parseFloat( computedStyle.borderLeftWidth ) || 0;
+      }
+
+      prevComputedStyle = computedStyle;
+    }
+
+    if ( prevComputedStyle.position === "relative" || prevComputedStyle.position === "static" ) {
+      top  += body.offsetTop;
+      left += body.offsetLeft;
+    }
+
+    if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
+      top  += Math.max( docElem.scrollTop, body.scrollTop );
+      left += Math.max( docElem.scrollLeft, body.scrollLeft );
+    }
+
+    return { top: top, left: left };
+  };
 }
 
 jQuery.offset = {
 
-	bodyOffset: function( body ) {
-		var top = body.offsetTop,
-			left = body.offsetLeft;
-
-		if ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {
-			top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
-			left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
-		}
-
-		return { top: top, left: left };
-	},
-
-	setOffset: function( elem, options, i ) {
-		var position = jQuery.css( elem, "position" );
-
-		// set position first, in-case top/left are set even on static elem
-		if ( position === "static" ) {
-			elem.style.position = "relative";
-		}
-
-		var curElem = jQuery( elem ),
-			curOffset = curElem.offset(),
-			curCSSTop = jQuery.css( elem, "top" ),
-			curCSSLeft = jQuery.css( elem, "left" ),
-			calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
-			props = {}, curPosition = {}, curTop, curLeft;
-
-		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
-		if ( calculatePosition ) {
-			curPosition = curElem.position();
-			curTop = curPosition.top;
-			curLeft = curPosition.left;
-		} else {
-			curTop = parseFloat( curCSSTop ) || 0;
-			curLeft = parseFloat( curCSSLeft ) || 0;
-		}
-
-		if ( jQuery.isFunction( options ) ) {
-			options = options.call( elem, i, curOffset );
-		}
-
-		if ( options.top != null ) {
-			props.top = ( options.top - curOffset.top ) + curTop;
-		}
-		if ( options.left != null ) {
-			props.left = ( options.left - curOffset.left ) + curLeft;
-		}
-
-		if ( "using" in options ) {
-			options.using.call( elem, props );
-		} else {
-			curElem.css( props );
-		}
-	}
+  bodyOffset: function( body ) {
+    var top = body.offsetTop,
+      left = body.offsetLeft;
+
+    if ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {
+      top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
+      left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
+    }
+
+    return { top: top, left: left };
+  },
+
+  setOffset: function( elem, options, i ) {
+    var position = jQuery.css( elem, "position" );
+
+    // set position first, in-case top/left are set even on static elem
+    if ( position === "static" ) {
+      elem.style.position = "relative";
+    }
+
+    var curElem = jQuery( elem ),
+      curOffset = curElem.offset(),
+      curCSSTop = jQuery.css( elem, "top" ),
+      curCSSLeft = jQuery.css( elem, "left" ),
+      calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
+      props = {}, curPosition = {}, curTop, curLeft;
+
+    // need to be able to calculate position if either top or left is auto and position is either absolute or fixed
+    if ( calculatePosition ) {
+      curPosition = curElem.position();
+      curTop = curPosition.top;
+      curLeft = curPosition.left;
+    } else {
+      curTop = parseFloat( curCSSTop ) || 0;
+      curLeft = parseFloat( curCSSLeft ) || 0;
+    }
+
+    if ( jQuery.isFunction( options ) ) {
+      options = options.call( elem, i, curOffset );
+    }
+
+    if ( options.top != null ) {
+      props.top = ( options.top - curOffset.top ) + curTop;
+    }
+    if ( options.left != null ) {
+      props.left = ( options.left - curOffset.left ) + curLeft;
+    }
+
+    if ( "using" in options ) {
+      options.using.call( elem, props );
+    } else {
+      curElem.css( props );
+    }
+  }
 };
 
 
 jQuery.fn.extend({
 
-	position: function() {
-		if ( !this[0] ) {
-			return null;
-		}
-
-		var elem = this[0],
-
-		// Get *real* offsetParent
-		offsetParent = this.offsetParent(),
-
-		// Get correct offsets
-		offset       = this.offset(),
-		parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();
-
-		// Subtract element margins
-		// note: when an element has margin: auto the offsetLeft and marginLeft
-		// are the same in Safari causing offset.left to incorrectly be 0
-		offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
-		offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;
-
-		// Add offsetParent borders
-		parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
-		parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;
-
-		// Subtract the two offsets
-		return {
-			top:  offset.top  - parentOffset.top,
-			left: offset.left - parentOffset.left
-		};
-	},
-
-	offsetParent: function() {
-		return this.map(function() {
-			var offsetParent = this.offsetParent || document.body;
-			while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
-				offsetParent = offsetParent.offsetParent;
-			}
-			return offsetParent;
-		});
-	}
+  position: function() {
+    if ( !this[0] ) {
+      return null;
+    }
+
+    var elem = this[0],
+
+    // Get *real* offsetParent
+    offsetParent = this.offsetParent(),
+
+    // Get correct offsets
+    offset       = this.offset(),
+    parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();
+
+    // Subtract element margins
+    // note: when an element has margin: auto the offsetLeft and marginLeft
+    // are the same in Safari causing offset.left to incorrectly be 0
+    offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
+    offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;
+
+    // Add offsetParent borders
+    parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
+    parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;
+
+    // Subtract the two offsets
+    return {
+      top:  offset.top  - parentOffset.top,
+      left: offset.left - parentOffset.left
+    };
+  },
+
+  offsetParent: function() {
+    return this.map(function() {
+      var offsetParent = this.offsetParent || document.body;
+      while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
+        offsetParent = offsetParent.offsetParent;
+      }
+      return offsetParent;
+    });
+  }
 });
 
 
 // Create scrollLeft and scrollTop methods
 jQuery.each( ["Left", "Top"], function( i, name ) {
-	var method = "scroll" + name;
-
-	jQuery.fn[ method ] = function( val ) {
-		var elem, win;
-
-		if ( val === undefined ) {
-			elem = this[ 0 ];
-
-			if ( !elem ) {
-				return null;
-			}
-
-			win = getWindow( elem );
-
-			// Return the scroll offset
-			return win ? ("pageXOffset" in win) ? win[ i ? "pageYOffset" : "pageXOffset" ] :
-				jQuery.support.boxModel && win.document.documentElement[ method ] ||
-					win.document.body[ method ] :
-				elem[ method ];
-		}
-
-		// Set the scroll offset
-		return this.each(function() {
-			win = getWindow( this );
-
-			if ( win ) {
-				win.scrollTo(
-					!i ? val : jQuery( win ).scrollLeft(),
-					 i ? val : jQuery( win ).scrollTop()
-				);
-
-			} else {
-				this[ method ] = val;
-			}
-		});
-	};
+  var method = "scroll" + name;
+
+  jQuery.fn[ method ] = function( val ) {
+    var elem, win;
+
+    if ( val === undefined ) {
+      elem = this[ 0 ];
+
+      if ( !elem ) {
+        return null;
+      }
+
+      win = getWindow( elem );
+
+      // Return the scroll offset
+      return win ? ("pageXOffset" in win) ? win[ i ? "pageYOffset" : "pageXOffset" ] :
+        jQuery.support.boxModel && win.document.documentElement[ method ] ||
+          win.document.body[ method ] :
+        elem[ method ];
+    }
+
+    // Set the scroll offset
+    return this.each(function() {
+      win = getWindow( this );
+
+      if ( win ) {
+        win.scrollTo(
+          !i ? val : jQuery( win ).scrollLeft(),
+           i ? val : jQuery( win ).scrollTop()
+        );
+
+      } else {
+        this[ method ] = val;
+      }
+    });
+  };
 });
 
 function getWindow( elem ) {
-	return jQuery.isWindow( elem ) ?
-		elem :
-		elem.nodeType === 9 ?
-			elem.defaultView || elem.parentWindow :
-			false;
+  return jQuery.isWindow( elem ) ?
+    elem :
+    elem.nodeType === 9 ?
+      elem.defaultView || elem.parentWindow :
+      false;
 }
 
 
@@ -11254,71 +11254,71 @@ function getWindow( elem ) {
 // Create width, height, innerHeight, innerWidth, outerHeight and outerWidth methods
 jQuery.each([ "Height", "Width" ], function( i, name ) {
 
-	var type = name.toLowerCase();
-
-	// innerHeight and innerWidth
-	jQuery.fn[ "inner" + name ] = function() {
-		var elem = this[0];
-		return elem ?
-			elem.style ?
-			parseFloat( jQuery.css( elem, type, "padding" ) ) :
-			this[ type ]() :
-			null;
-	};
-
-	// outerHeight and outerWidth
-	jQuery.fn[ "outer" + name ] = function( margin ) {
-		var elem = this[0];
-		return elem ?
-			elem.style ?
-			parseFloat( jQuery.css( elem, type, margin ? "margin" : "border" ) ) :
-			this[ type ]() :
-			null;
-	};
-
-	jQuery.fn[ type ] = function( size ) {
-		// Get window width or height
-		var elem = this[0];
-		if ( !elem ) {
-			return size == null ? null : this;
-		}
-
-		if ( jQuery.isFunction( size ) ) {
-			return this.each(function( i ) {
-				var self = jQuery( this );
-				self[ type ]( size.call( this, i, self[ type ]() ) );
-			});
-		}
-
-		if ( jQuery.isWindow( elem ) ) {
-			// Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode
-			// 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat
-			var docElemProp = elem.document.documentElement[ "client" + name ],
-				body = elem.document.body;
-			return elem.document.compatMode === "CSS1Compat" && docElemProp ||
-				body && body[ "client" + name ] || docElemProp;
-
-		// Get document width or height
-		} else if ( elem.nodeType === 9 ) {
-			// Either scroll[Width/Height] or offset[Width/Height], whichever is greater
-			return Math.max(
-				elem.documentElement["client" + name],
-				elem.body["scroll" + name], elem.documentElement["scroll" + name],
-				elem.body["offset" + name], elem.documentElement["offset" + name]
-			);
-
-		// Get or set width or height on the element
-		} else if ( size === undefined ) {
-			var orig = jQuery.css( elem, type ),
-				ret = parseFloat( orig );
-
-			return jQuery.isNumeric( ret ) ? ret : orig;
-
-		// Set the width or height on the element (default to pixels if value is unitless)
-		} else {
-			return this.css( type, typeof size === "string" ? size : size + "px" );
-		}
-	};
+  var type = name.toLowerCase();
+
+  // innerHeight and innerWidth
+  jQuery.fn[ "inner" + name ] = function() {
+    var elem = this[0];
+    return elem ?
+      elem.style ?
+      parseFloat( jQuery.css( elem, type, "padding" ) ) :
+      this[ type ]() :
+      null;
+  };
+
+  // outerHeight and outerWidth
+  jQuery.fn[ "outer" + name ] = function( margin ) {
+    var elem = this[0];
+    return elem ?
+      elem.style ?
+      parseFloat( jQuery.css( elem, type, margin ? "margin" : "border" ) ) :
+      this[ type ]() :
+      null;
+  };
+
+  jQuery.fn[ type ] = function( size ) {
+    // Get window width or height
+    var elem = this[0];
+    if ( !elem ) {
+      return size == null ? null : this;
+    }
+
+    if ( jQuery.isFunction( size ) ) {
+      return this.each(function( i ) {
+        var self = jQuery( this );
+        self[ type ]( size.call( this, i, self[ type ]() ) );
+      });
+    }
+
+    if ( jQuery.isWindow( elem ) ) {
+      // Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode
+      // 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat
+      var docElemProp = elem.document.documentElement[ "client" + name ],
+        body = elem.document.body;
+      return elem.document.compatMode === "CSS1Compat" && docElemProp ||
+        body && body[ "client" + name ] || docElemProp;
+
+    // Get document width or height
+    } else if ( elem.nodeType === 9 ) {
+      // Either scroll[Width/Height] or offset[Width/Height], whichever is greater
+      return Math.max(
+        elem.documentElement["client" + name],
+        elem.body["scroll" + name], elem.documentElement["scroll" + name],
+        elem.body["offset" + name], elem.documentElement["offset" + name]
+      );
+
+    // Get or set width or height on the element
+    } else if ( size === undefined ) {
+      var orig = jQuery.css( elem, type ),
+        ret = parseFloat( orig );
+
+      return jQuery.isNumeric( ret ) ? ret : orig;
+
+    // Set the width or height on the element (default to pixels if value is unitless)
+    } else {
+      return this.css( type, typeof size === "string" ? size : size + "px" );
+    }
+  };
 
 });
 
@@ -11341,7 +11341,7 @@ window.jQuery = window.$ = jQuery;
 // Do this after creating the global so that if an AMD module wants to call
 // noConflict to hide this version of jQuery, it will work.
 if ( typeof define === "function" && define.amd && define.amd.jQuery ) {
-	define( "jquery", [], function () { return jQuery; } );
+  define( "jquery", [], function () { return jQuery; } );
 }
 
 
diff --git a/solr/webapp/web/js/scripts/segments.js b/solr/webapp/web/js/scripts/segments.js
index 9d81afb..eb5c169 100644
--- a/solr/webapp/web/js/scripts/segments.js
+++ b/solr/webapp/web/js/scripts/segments.js
@@ -44,12 +44,12 @@ var get_entry_item = function(name, dims, tooltip, isMergeCandidate) {
     '    <dt><div>' + name + '</div></dt>' + "\n" +
     '    <dd>';
     entry += '<div class="live' + ((isMergeCandidate)?' merge-candidate':'') + 
-    		 '" style="width: ' + dims['alive_doc_size'] + '%;">&nbsp;</div>';
+         '" style="width: ' + dims['alive_doc_size'] + '%;">&nbsp;</div>';
     entry += '<div class="toolitp">' + tooltip +'</div>';
       
     if (dims['deleted_doc_size'] > 0.001) {
      entry += '<div class="deleted" style="width:' + dims['deleted_doc_size']  
-     		+ '%;margin-left:' + dims['alive_doc_size'] + '%;">&nbsp;</div>';
+         + '%;margin-left:' + dims['alive_doc_size'] + '%;">&nbsp;</div>';
     }
     entry += '</dd></dl></li>';
     return entry;
diff --git a/solr/webapp/web/libs/jquery.jstree.js b/solr/webapp/web/libs/jquery.jstree.js
index 20c2f60..50c1767 100644
--- a/solr/webapp/web/libs/jquery.jstree.js
+++ b/solr/webapp/web/libs/jquery.jstree.js
@@ -43,802 +43,802 @@ THE SOFTWARE.
 // Common functions not related to jsTree 
 // decided to move them to a `vakata` "namespace"
 (function ($) {
-	$.vakata = {};
-	// CSS related functions
-	$.vakata.css = {
-		get_css : function(rule_name, delete_flag, sheet) {
-			rule_name = rule_name.toLowerCase();
-			var css_rules = sheet.cssRules || sheet.rules,
-				j = 0;
-			do {
-				if(css_rules.length && j > css_rules.length + 5) { return false; }
-				if(css_rules[j].selectorText && css_rules[j].selectorText.toLowerCase() == rule_name) {
-					if(delete_flag === true) {
-						if(sheet.removeRule) { sheet.removeRule(j); }
-						if(sheet.deleteRule) { sheet.deleteRule(j); }
-						return true;
-					}
-					else { return css_rules[j]; }
-				}
-			}
-			while (css_rules[++j]);
-			return false;
-		},
-		add_css : function(rule_name, sheet) {
-			if($.jstree.css.get_css(rule_name, false, sheet)) { return false; }
-			if(sheet.insertRule) { sheet.insertRule(rule_name + ' { }', 0); } else { sheet.addRule(rule_name, null, 0); }
-			return $.vakata.css.get_css(rule_name);
-		},
-		remove_css : function(rule_name, sheet) { 
-			return $.vakata.css.get_css(rule_name, true, sheet); 
-		},
-		add_sheet : function(opts) {
-			var tmp;
-			if(opts.str) {
-				tmp = document.createElement("style");
-				tmp.setAttribute('type',"text/css");
-				if(tmp.styleSheet) {
-					document.getElementsByTagName("head")[0].appendChild(tmp);
-					tmp.styleSheet.cssText = opts.str;
-				}
-				else {
-					tmp.appendChild(document.createTextNode(opts.str));
-					document.getElementsByTagName("head")[0].appendChild(tmp);
-				}
-				return tmp.sheet || tmp.styleSheet;
-			}
-			if(opts.url) {
-				if(document.createStyleSheet) {
-					try { tmp = document.createStyleSheet(opts.url); } catch (e) { }
-				}
-				else {
-					tmp			= document.createElement('link');
-					tmp.rel		= 'stylesheet';
-					tmp.type	= 'text/css';
-					tmp.media	= "all";
-					tmp.href	= opts.url;
-					document.getElementsByTagName("head")[0].appendChild(tmp);
-					return tmp.styleSheet;
-				}
-			}
-		}
-	};
+  $.vakata = {};
+  // CSS related functions
+  $.vakata.css = {
+    get_css : function(rule_name, delete_flag, sheet) {
+      rule_name = rule_name.toLowerCase();
+      var css_rules = sheet.cssRules || sheet.rules,
+        j = 0;
+      do {
+        if(css_rules.length && j > css_rules.length + 5) { return false; }
+        if(css_rules[j].selectorText && css_rules[j].selectorText.toLowerCase() == rule_name) {
+          if(delete_flag === true) {
+            if(sheet.removeRule) { sheet.removeRule(j); }
+            if(sheet.deleteRule) { sheet.deleteRule(j); }
+            return true;
+          }
+          else { return css_rules[j]; }
+        }
+      }
+      while (css_rules[++j]);
+      return false;
+    },
+    add_css : function(rule_name, sheet) {
+      if($.jstree.css.get_css(rule_name, false, sheet)) { return false; }
+      if(sheet.insertRule) { sheet.insertRule(rule_name + ' { }', 0); } else { sheet.addRule(rule_name, null, 0); }
+      return $.vakata.css.get_css(rule_name);
+    },
+    remove_css : function(rule_name, sheet) { 
+      return $.vakata.css.get_css(rule_name, true, sheet); 
+    },
+    add_sheet : function(opts) {
+      var tmp;
+      if(opts.str) {
+        tmp = document.createElement("style");
+        tmp.setAttribute('type',"text/css");
+        if(tmp.styleSheet) {
+          document.getElementsByTagName("head")[0].appendChild(tmp);
+          tmp.styleSheet.cssText = opts.str;
+        }
+        else {
+          tmp.appendChild(document.createTextNode(opts.str));
+          document.getElementsByTagName("head")[0].appendChild(tmp);
+        }
+        return tmp.sheet || tmp.styleSheet;
+      }
+      if(opts.url) {
+        if(document.createStyleSheet) {
+          try { tmp = document.createStyleSheet(opts.url); } catch (e) { }
+        }
+        else {
+          tmp      = document.createElement('link');
+          tmp.rel    = 'stylesheet';
+          tmp.type  = 'text/css';
+          tmp.media  = "all";
+          tmp.href  = opts.url;
+          document.getElementsByTagName("head")[0].appendChild(tmp);
+          return tmp.styleSheet;
+        }
+      }
+    }
+  };
 })(jQuery);
 
 /* 
  * jsTree core 1.0
  */
 (function ($) {
-	// private variables 
-	var instances = [],			// instance array (used by $.jstree.reference/create/focused)
-		focused_instance = -1,	// the index in the instance array of the currently focused instance
-		plugins = {},			// list of included plugins
-		prepared_move = {},		// for the move plugin
-		is_ie6 = false;
-
-	// jQuery plugin wrapper (thanks to jquery UI widget function)
-	$.fn.jstree = function (settings) {
-		var isMethodCall = (typeof settings == 'string'), // is this a method call like $().jstree("open_node")
-			args = Array.prototype.slice.call(arguments, 1), 
-			returnValue = this;
-
-		// extend settings and allow for multiple hashes and metadata
-		if(!isMethodCall && $.meta) { args.push($.metadata.get(this).jstree); }
-		settings = !isMethodCall && args.length ? $.extend.apply(null, [true, settings].concat(args)) : settings;
-		// block calls to "private" methods
-		if(isMethodCall && settings.substring(0, 1) == '_') { return returnValue; }
-
-		// if a method call execute the method on all selected instances
-		if(isMethodCall) {
-			this.each(function() {
-				var instance = instances[$.data(this, "jstree-instance-id")],
-					methodValue = (instance && $.isFunction(instance[settings])) ? instance[settings].apply(instance, args) : instance;
-					if(typeof methodValue !== "undefined" && (settings.indexOf("is_" === 0) || (methodValue !== true && methodValue !== false))) { returnValue = methodValue; return false; }
-			});
-		}
-		else {
-			this.each(function() {
-				var instance_id = $.data(this, "jstree-instance-id"),
-					s = false;
-				// if an instance already exists, destroy it first
-				if(typeof instance_id !== "undefined" && instances[instance_id]) { instances[instance_id].destroy(); }
-				// push a new empty object to the instances array
-				instance_id = parseInt(instances.push({}),10) - 1;
-				// store the jstree instance id to the container element
-				$.data(this, "jstree-instance-id", instance_id);
-				// clean up all plugins
-				if(!settings) { settings = {}; }
-				settings.plugins = $.isArray(settings.plugins) ? settings.plugins : $.jstree.defaults.plugins;
-				if($.inArray("core", settings.plugins) === -1) { settings.plugins.unshift("core"); }
-				
-				// only unique plugins (NOT WORKING)
-				// settings.plugins = settings.plugins.sort().join(",,").replace(/(,|^)([^,]+)(,,\2)+(,|$)/g,"$1$2$4").replace(/,,+/g,",").replace(/,$/,"").split(",");
-
-				// extend defaults with passed data
-				s = $.extend(true, {}, $.jstree.defaults, settings);
-				s.plugins = settings.plugins;
-				$.each(plugins, function (i, val) { if($.inArray(i, s.plugins) === -1) { s[i] = null; delete s[i]; } });
-				// push the new object to the instances array (at the same time set the default classes to the container) and init
-				instances[instance_id] = new $.jstree._instance(instance_id, $(this).addClass("jstree jstree-" + instance_id), s); 
-				// init all activated plugins for this instance
-				$.each(instances[instance_id]._get_settings().plugins, function (i, val) { instances[instance_id].data[val] = {}; });
-				$.each(instances[instance_id]._get_settings().plugins, function (i, val) { if(plugins[val]) { plugins[val].__init.apply(instances[instance_id]); } });
-				// initialize the instance
-				instances[instance_id].init();
-			});
-		}
-		// return the jquery selection (or if it was a method call that returned a value - the returned value)
-		return returnValue;
-	};
-	// object to store exposed functions and objects
-	$.jstree = {
-		defaults : {
-			plugins : []
-		},
-		_focused : function () { return instances[focused_instance] || null; },
-		_reference : function (needle) { 
-			// get by instance id
-			if(instances[needle]) { return instances[needle]; }
-			// get by DOM (if still no luck - return null
-			var o = $(needle); 
-			if(!o.length && typeof needle === "string") { o = $("#" + needle); }
-			if(!o.length) { return null; }
-			return instances[o.closest(".jstree").data("jstree-instance-id")] || null; 
-		},
-		_instance : function (index, container, settings) { 
-			// for plugins to store data in
-			this.data = { core : {} };
-			this.get_settings	= function () { return $.extend(true, {}, settings); };
-			this._get_settings	= function () { return settings; };
-			this.get_index		= function () { return index; };
-			this.get_container	= function () { return container; };
-			this._set_settings	= function (s) { 
-				settings = $.extend(true, {}, settings, s);
-			};
-		},
-		_fn : { },
-		plugin : function (pname, pdata) {
-			pdata = $.extend({}, {
-				__init		: $.noop, 
-				__destroy	: $.noop,
-				_fn			: {},
-				defaults	: false
-			}, pdata);
-			plugins[pname] = pdata;
-
-			$.jstree.defaults[pname] = pdata.defaults;
-			$.each(pdata._fn, function (i, val) {
-				val.plugin		= pname;
-				val.old			= $.jstree._fn[i];
-				$.jstree._fn[i] = function () {
-					var rslt,
-						func = val,
-						args = Array.prototype.slice.call(arguments),
-						evnt = new $.Event("before.jstree"),
-						rlbk = false;
-
-					// Check if function belongs to the included plugins of this instance
-					do {
-						if(func && func.plugin && $.inArray(func.plugin, this._get_settings().plugins) !== -1) { break; }
-						func = func.old;
-					} while(func);
-					if(!func) { return; }
-
-					// a chance to stop execution (or change arguments): 
-					// * just bind to jstree.before
-					// * check the additional data object (func property)
-					// * call event.stopImmediatePropagation()
-					// * return false (or an array of arguments)
-					rslt = this.get_container().triggerHandler(evnt, { "func" : i, "inst" : this, "args" : args });
-					if(rslt === false) { return; }
-					if(typeof rslt !== "undefined") { args = rslt; }
-
-					// context and function to trigger events, then finally call the function
-					if(i.indexOf("_") === 0) {
-						rslt = func.apply(this, args);
-					}
-					else {
-						rslt = func.apply(
-							$.extend({}, this, { 
-								__callback : function (data) { 
-									this.get_container().triggerHandler( i + '.jstree', { "inst" : this, "args" : args, "rslt" : data, "rlbk" : rlbk });
-								},
-								__rollback : function () { 
-									rlbk = this.get_rollback();
-									return rlbk;
-								},
-								__call_old : function (replace_arguments) {
-									return func.old.apply(this, (replace_arguments ? Array.prototype.slice.call(arguments, 1) : args ) );
-								}
-							}), args);
-					}
-
-					// return the result
-					return rslt;
-				};
-				$.jstree._fn[i].old = val.old;
-				$.jstree._fn[i].plugin = pname;
-			});
-		},
-		rollback : function (rb) {
-			if(rb) {
-				if(!$.isArray(rb)) { rb = [ rb ]; }
-				$.each(rb, function (i, val) {
-					instances[val.i].set_rollback(val.h, val.d);
-				});
-			}
-		}
-	};
-	// set the prototype for all instances
-	$.jstree._fn = $.jstree._instance.prototype = {};
-
-	// css functions - used internally
-
-	// load the css when DOM is ready
-	$(function() {
-		// code is copied form jQuery ($.browser is deprecated + there is a bug in IE)
-		var u = navigator.userAgent.toLowerCase(),
-			v = (u.match( /.+?(?:rv|it|ra|ie)[\/: ]([\d.]+)/ ) || [0,'0'])[1],
-			css_string = '' + 
-				'.jstree ul, .jstree li { display:block; margin:0 0 0 0; padding:0 0 0 0; list-style-type:none; } ' + 
-				'.jstree li { display:block; min-height:18px; line-height:18px; white-space:nowrap; margin-left:18px; } ' + 
-				'.jstree-rtl li { margin-left:0; margin-right:18px; } ' + 
-				'.jstree > ul > li { margin-left:0px; } ' + 
-				'.jstree-rtl > ul > li { margin-right:0px; } ' + 
-				'.jstree ins { display:inline-block; text-decoration:none; width:18px; height:18px; margin:0 0 0 0; padding:0; } ' + 
-				'.jstree a { display:inline-block; line-height:16px; height:16px; color:black; white-space:nowrap; text-decoration:none; padding:1px 2px; margin:0; } ' + 
-				'.jstree a:focus { outline: none; } ' + 
-				'.jstree a > ins { height:16px; width:16px; } ' + 
-				'.jstree a > .jstree-icon { margin-right:3px; } ' + 
-				'.jstree-rtl a > .jstree-icon { margin-left:3px; margin-right:0; } ' + 
-				'li.jstree-open > ul { display:block; } ' + 
-				'li.jstree-closed > ul { display:none; } ';
-		// Correct IE 6 (does not support the > CSS selector)
-		if(/msie/.test(u) && parseInt(v, 10) == 6) { 
-			is_ie6 = true;
-			css_string += '' + 
-				'.jstree li { height:18px; margin-left:0; margin-right:0; } ' + 
-				'.jstree li li { margin-left:18px; } ' + 
-				'.jstree-rtl li li { margin-left:0px; margin-right:18px; } ' + 
-				'li.jstree-open ul { display:block; } ' + 
-				'li.jstree-closed ul { display:none !important; } ' + 
-				'.jstree li a { display:inline; border-width:0 !important; padding:0px 2px !important; } ' + 
-				'.jstree li a ins { height:16px; width:16px; margin-right:3px; } ' + 
-				'.jstree-rtl li a ins { margin-right:0px; margin-left:3px; } ';
-		}
-		// Correct IE 7 (shifts anchor nodes onhover)
-		if(/msie/.test(u) && parseInt(v, 10) == 7) { 
-			css_string += '.jstree li a { border-width:0 !important; padding:0px 2px !important; } ';
-		}
-		$.vakata.css.add_sheet({ str : css_string });
-	});
-
-	// core functions (open, close, create, update, delete)
-	$.jstree.plugin("core", {
-		__init : function () {
-			this.data.core.to_open = $.map($.makeArray(this.get_settings().core.initially_open), function (n) { return "#" + n.toString().replace(/^#/,"").replace('\\/','/').replace('/','\\/'); });
-		},
-		defaults : { 
-			html_titles	: false,
-			animation	: 500,
-			initially_open : [],
-			rtl			: false,
-			strings		: {
-				loading		: "Loading ...",
-				new_node	: "New node"
-			}
-		},
-		_fn : { 
-			init	: function () { 
-				this.set_focus(); 
-				if(this._get_settings().core.rtl) {
-					this.get_container().addClass("jstree-rtl").css("direction", "rtl");
-				}
-				this.get_container().html("<ul><li class='jstree-last jstree-leaf'><ins>&#160;</ins><a class='jstree-loading' href='#'><ins class='jstree-icon'>&#160;</ins>" + this._get_settings().core.strings.loading + "</a></li></ul>");
-				this.data.core.li_height = this.get_container().find("ul li.jstree-closed, ul li.jstree-leaf").eq(0).height() || 18;
-
-				this.get_container()
-					.delegate("li > ins", "click.jstree", $.proxy(function (event) {
-							var trgt = $(event.target);
-							if(trgt.is("ins") && event.pageY - trgt.offset().top < this.data.core.li_height) { this.toggle_node(trgt); }
-						}, this))
-					.bind("mousedown.jstree", $.proxy(function () { 
-							this.set_focus(); // This used to be setTimeout(set_focus,0) - why?
-						}, this))
-					.bind("dblclick.jstree", function (event) { 
-						var sel;
-						if(document.selection && document.selection.empty) { document.selection.empty(); }
-						else {
-							if(window.getSelection) {
-								sel = window.getSelection();
-								try { 
-									sel.removeAllRanges();
-									sel.collapse();
-								} catch (err) { }
-							}
-						}
-					});
-				this.__callback();
-				this.load_node(-1, function () { this.loaded(); this.reopen(); });
-			},
-			destroy	: function () { 
-				var i,
-					n = this.get_index(),
-					s = this._get_settings(),
-					_this = this;
-
-				$.each(s.plugins, function (i, val) {
-					try { plugins[val].__destroy.apply(_this); } catch(err) { }
-				});
-				this.__callback();
-				// set focus to another instance if this one is focused
-				if(this.is_focused()) { 
-					for(i in instances) { 
-						if(instances.hasOwnProperty(i) && i != n) { 
-							instances[i].set_focus(); 
-							break; 
-						} 
-					}
-				}
-				// if no other instance found
-				if(n === focused_instance) { focused_instance = -1; }
-				// remove all traces of jstree in the DOM (only the ones set using jstree*) and cleans all events
-				this.get_container()
-					.unbind(".jstree")
-					.undelegate(".jstree")
-					.removeData("jstree-instance-id")
-					.find("[class^='jstree']")
-						.andSelf()
-						.attr("class", function () { return this.className.replace(/jstree[^ ]*|$/ig,''); });
-				// remove the actual data
-				instances[n] = null;
-				delete instances[n];
-			},
-			save_opened : function () {
-				var _this = this;
-				this.data.core.to_open = [];
-				this.get_container().find(".jstree-open").each(function () { 
-					_this.data.core.to_open.push("#" + this.id.toString().replace(/^#/,"").replace('\\/','/').replace('/','\\/')); 
-				});
-				this.__callback(_this.data.core.to_open);
-			},
-			reopen : function (is_callback) {
-				var _this = this,
-					done = true,
-					current = [],
-					remaining = [];
-				if(!is_callback) { this.data.core.reopen = false; this.data.core.refreshing = true; }
-				if(this.data.core.to_open.length) {
-					$.each(this.data.core.to_open, function (i, val) {
-						if(val == "#") { return true; }
-						if($(val).length && $(val).is(".jstree-closed")) { current.push(val); }
-						else { remaining.push(val); }
-					});
-					if(current.length) {
-						this.data.core.to_open = remaining;
-						$.each(current, function (i, val) { 
-							_this.open_node(val, function () { _this.reopen(true); }, true); 
-						});
-						done = false;
-					}
-				}
-				if(done) { 
-					// TODO: find a more elegant approach to syncronizing returning requests
-					if(this.data.core.reopen) { clearTimeout(this.data.core.reopen); }
-					this.data.core.reopen = setTimeout(function () { _this.__callback({}, _this); }, 50);
-					this.data.core.refreshing = false;
-				}
-			},
-			refresh : function (obj) {
-				var _this = this;
-				this.save_opened();
-				if(!obj) { obj = -1; }
-				obj = this._get_node(obj);
-				if(!obj) { obj = -1; }
-				if(obj !== -1) { obj.children("UL").remove(); }
-				this.load_node(obj, function () { _this.__callback({ "obj" : obj}); _this.reopen(); });
-			},
-			// Dummy function to fire after the first load (so that there is a jstree.loaded event)
-			loaded	: function () { 
-				this.__callback(); 
-			},
-			// deal with focus
-			set_focus	: function () { 
-				var f = $.jstree._focused();
-				if(f && f !== this) {
-					f.get_container().removeClass("jstree-focused"); 
-				}
-				if(f !== this) {
-					this.get_container().addClass("jstree-focused"); 
-					focused_instance = this.get_index(); 
-				}
-				this.__callback();
-			},
-			is_focused	: function () { 
-				return focused_instance == this.get_index(); 
-			},
-
-			// traverse
-			_get_node		: function (obj) { 
-				var $obj = $(obj, this.get_container()); 
-				if($obj.is(".jstree") || obj == -1) { return -1; } 
-				$obj = $obj.closest("li", this.get_container()); 
-				return $obj.length ? $obj : false; 
-			},
-			_get_next		: function (obj, strict) {
-				obj = this._get_node(obj);
-				if(obj === -1) { return this.get_container().find("> ul > li:first-child"); }
-				if(!obj.length) { return false; }
-				if(strict) { return (obj.nextAll("li").size() > 0) ? obj.nextAll("li:eq(0)") : false; }
-
-				if(obj.hasClass("jstree-open")) { return obj.find("li:eq(0)"); }
-				else if(obj.nextAll("li").size() > 0) { return obj.nextAll("li:eq(0)"); }
-				else { return obj.parentsUntil(".jstree","li").next("li").eq(0); }
-			},
-			_get_prev		: function (obj, strict) {
-				obj = this._get_node(obj);
-				if(obj === -1) { return this.get_container().find("> ul > li:last-child"); }
-				if(!obj.length) { return false; }
-				if(strict) { return (obj.prevAll("li").length > 0) ? obj.prevAll("li:eq(0)") : false; }
-
-				if(obj.prev("li").length) {
-					obj = obj.prev("li").eq(0);
-					while(obj.hasClass("jstree-open")) { obj = obj.children("ul:eq(0)").children("li:last"); }
-					return obj;
-				}
-				else { var o = obj.parentsUntil(".jstree","li:eq(0)"); return o.length ? o : false; }
-			},
-			_get_parent		: function (obj) {
-				obj = this._get_node(obj);
-				if(obj == -1 || !obj.length) { return false; }
-				var o = obj.parentsUntil(".jstree", "li:eq(0)");
-				return o.length ? o : -1;
-			},
-			_get_children	: function (obj) {
-				obj = this._get_node(obj);
-				if(obj === -1) { return this.get_container().children("ul:eq(0)").children("li"); }
-				if(!obj.length) { return false; }
-				return obj.children("ul:eq(0)").children("li");
-			},
-			get_path		: function (obj, id_mode) {
-				var p = [],
-					_this = this;
-				obj = this._get_node(obj);
-				if(obj === -1 || !obj || !obj.length) { return false; }
-				obj.parentsUntil(".jstree", "li").each(function () {
-					p.push( id_mode ? this.id : _this.get_text(this) );
-				});
-				p.reverse();
-				p.push( id_mode ? obj.attr("id") : this.get_text(obj) );
-				return p;
-			},
-
-			is_open		: function (obj) { obj = this._get_node(obj); return obj && obj !== -1 && obj.hasClass("jstree-open"); },
-			is_closed	: function (obj) { obj = this._get_node(obj); return obj && obj !== -1 && obj.hasClass("jstree-closed"); },
-			is_leaf		: function (obj) { obj = this._get_node(obj); return obj && obj !== -1 && obj.hasClass("jstree-leaf"); },
-			// open/close
-			open_node	: function (obj, callback, skip_animation) {
-				obj = this._get_node(obj);
-				if(!obj.length) { return false; }
-				if(!obj.hasClass("jstree-closed")) { if(callback) { callback.call(); } return false; }
-				var s = skip_animation || is_ie6 ? 0 : this._get_settings().core.animation,
-					t = this;
-				if(!this._is_loaded(obj)) {
-					obj.children("a").addClass("jstree-loading");
-					this.load_node(obj, function () { t.open_node(obj, callback, skip_animation); }, callback);
-				}
-				else {
-					if(s) { obj.children("ul").css("display","none"); }
-					obj.removeClass("jstree-closed").addClass("jstree-open").children("a").removeClass("jstree-loading");
-					if(s) { obj.children("ul").stop(true).slideDown(s, function () { this.style.display = ""; }); }
-					this.__callback({ "obj" : obj });
-					if(callback) { callback.call(); }
-				}
-			},
-			close_node	: function (obj, skip_animation) {
-				obj = this._get_node(obj);
-				var s = skip_animation || is_ie6 ? 0 : this._get_settings().core.animation;
-				if(!obj.length || !obj.hasClass("jstree-open")) { return false; }
-				if(s) { obj.children("ul").attr("style","display:block !important"); }
-				obj.removeClass("jstree-open").addClass("jstree-closed");
-				if(s) { obj.children("ul").stop(true).slideUp(s, function () { this.style.display = ""; }); }
-				this.__callback({ "obj" : obj });
-			},
-			toggle_node	: function (obj) {
-				obj = this._get_node(obj);
-				if(obj.hasClass("jstree-closed")) { return this.open_node(obj); }
-				if(obj.hasClass("jstree-open")) { return this.close_node(obj); }
-			},
-			open_all	: function (obj, original_obj) {
-				obj = obj ? this._get_node(obj) : this.get_container();
-				if(!obj || obj === -1) { obj = this.get_container(); }
-				if(original_obj) { 
-					obj = obj.find("li.jstree-closed");
-				}
-				else {
-					original_obj = obj;
-					if(obj.is(".jstree-closed")) { obj = obj.find("li.jstree-closed").andSelf(); }
-					else { obj = obj.find("li.jstree-closed"); }
-				}
-				var _this = this;
-				obj.each(function () { 
-					var __this = this; 
-					if(!_this._is_loaded(this)) { _this.open_node(this, function() { _this.open_all(__this, original_obj); }, true); }
-					else { _this.open_node(this, false, true); }
-				});
-				// so that callback is fired AFTER all nodes are open
-				if(original_obj.find('li.jstree-closed').length === 0) { this.__callback({ "obj" : original_obj }); }
-			},
-			close_all	: function (obj) {
-				var _this = this;
-				obj = obj ? this._get_node(obj) : this.get_container();
-				if(!obj || obj === -1) { obj = this.get_container(); }
-				obj.find("li.jstree-open").andSelf().each(function () { _this.close_node(this); });
-				this.__callback({ "obj" : obj });
-			},
-			clean_node	: function (obj) {
-				obj = obj && obj != -1 ? $(obj) : this.get_container();
-				obj = obj.is("li") ? obj.find("li").andSelf() : obj.find("li");
-				obj.removeClass("jstree-last")
-					.filter("li:last-child").addClass("jstree-last").end()
-					.filter(":has(li)")
-						.not(".jstree-open").removeClass("jstree-leaf").addClass("jstree-closed");
-				obj.not(".jstree-open, .jstree-closed").addClass("jstree-leaf").children("ul").remove();
-				this.__callback({ "obj" : obj });
-			},
-			// rollback
-			get_rollback : function () { 
-				this.__callback();
-				return { i : this.get_index(), h : this.get_container().children("ul").clone(true), d : this.data }; 
-			},
-			set_rollback : function (html, data) {
-				this.get_container().empty().append(html);
-				this.data = data;
-				this.__callback();
-			},
-			// Dummy functions to be overwritten by any datastore plugin included
-			load_node	: function (obj, s_call, e_call) { this.__callback({ "obj" : obj }); },
-			_is_loaded	: function (obj) { return true; },
-
-			// Basic operations: create
-			create_node	: function (obj, position, js, callback, is_loaded) {
-				obj = this._get_node(obj);
-				position = typeof position === "undefined" ? "last" : position;
-				var d = $("<li>"),
-					s = this._get_settings().core,
-					tmp;
-
-				if(obj !== -1 && !obj.length) { return false; }
-				if(!is_loaded && !this._is_loaded(obj)) { this.load_node(obj, function () { this.create_node(obj, position, js, callback, true); }); return false; }
-
-				this.__rollback();
-
-				if(typeof js === "string") { js = { "data" : js }; }
-				if(!js) { js = {}; }
-				if(js.attr) { d.attr(js.attr); }
-				if(js.state) { d.addClass("jstree-" + js.state); }
-				if(!js.data) { js.data = s.strings.new_node; }
-				if(!$.isArray(js.data)) { tmp = js.data; js.data = []; js.data.push(tmp); }
-				$.each(js.data, function (i, m) {
-					tmp = $("<a>");
-					if($.isFunction(m)) { m = m.call(this, js); }
-					if(typeof m == "string") { tmp.attr('href','#')[ s.html_titles ? "html" : "text" ](m); }
-					else {
-						if(!m.attr) { m.attr = {}; }
-						if(!m.attr.href) { m.attr.href = '#'; }
-						tmp.attr(m.attr)[ s.html_titles ? "html" : "text" ](m.title);
-						if(m.language) { tmp.addClass(m.language); }
-					}
-					tmp.prepend("<ins class='jstree-icon'>&#160;</ins>");
-					if(m.icon) { 
-						if(m.icon.indexOf("/") === -1) { tmp.children("ins").addClass(m.icon); }
-						else { tmp.children("ins").css("background","url('" + m.icon + "') center center no-repeat"); }
-					}
-					d.append(tmp);
-				});
-				d.prepend("<ins class='jstree-icon'>&#160;</ins>");
-				if(obj === -1) {
-					obj = this.get_container();
-					if(position === "before") { position = "first"; }
-					if(position === "after") { position = "last"; }
-				}
-				switch(position) {
-					case "before": obj.before(d); tmp = this._get_parent(obj); break;
-					case "after" : obj.after(d);  tmp = this._get_parent(obj); break;
-					case "inside":
-					case "first" :
-						if(!obj.children("ul").length) { obj.append("<ul>"); }
-						obj.children("ul").prepend(d);
-						tmp = obj;
-						break;
-					case "last":
-						if(!obj.children("ul").length) { obj.append("<ul>"); }
-						obj.children("ul").append(d);
-						tmp = obj;
-						break;
-					default:
-						if(!obj.children("ul").length) { obj.append("<ul>"); }
-						if(!position) { position = 0; }
-						tmp = obj.children("ul").children("li").eq(position);
-						if(tmp.length) { tmp.before(d); }
-						else { obj.children("ul").append(d); }
-						tmp = obj;
-						break;
-				}
-				if(tmp === -1 || tmp.get(0) === this.get_container().get(0)) { tmp = -1; }
-				this.clean_node(tmp);
-				this.__callback({ "obj" : d, "parent" : tmp });
-				if(callback) { callback.call(this, d); }
-				return d;
-			},
-			// Basic operations: rename (deal with text)
-			get_text	: function (obj) {
-				obj = this._get_node(obj);
-				if(!obj.length) { return false; }
-				var s = this._get_settings().core.html_titles;
-				obj = obj.children("a:eq(0)");
-				if(s) {
-					obj = obj.clone();
-					obj.children("INS").remove();
-					return obj.html();
-				}
-				else {
-					obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];
-					return obj.nodeValue;
-				}
-			},
-			set_text	: function (obj, val) {
-				obj = this._get_node(obj);
-				if(!obj.length) { return false; }
-				obj = obj.children("a:eq(0)");
-				if(this._get_settings().core.html_titles) {
-					var tmp = obj.children("INS").clone();
-					obj.html(val).prepend(tmp);
-					this.__callback({ "obj" : obj, "name" : val });
-					return true;
-				}
-				else {
-					obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];
-					this.__callback({ "obj" : obj, "name" : val });
-					return (obj.nodeValue = val);
-				}
-			},
-			rename_node : function (obj, val) {
-				obj = this._get_node(obj);
-				this.__rollback();
-				if(obj && obj.length && this.set_text.apply(this, Array.prototype.slice.call(arguments))) { this.__callback({ "obj" : obj, "name" : val }); }
-			},
-			// Basic operations: deleting nodes
-			delete_node : function (obj) {
-				obj = this._get_node(obj);
-				if(!obj.length) { return false; }
-				this.__rollback();
-				var p = this._get_parent(obj), prev = this._get_prev(obj);
-				obj = obj.remove();
-				if(p !== -1 && p.find("> ul > li").length === 0) {
-					p.removeClass("jstree-open jstree-closed").addClass("jstree-leaf");
-				}
-				this.clean_node(p);
-				this.__callback({ "obj" : obj, "prev" : prev });
-				return obj;
-			},
-			prepare_move : function (o, r, pos, cb, is_cb) {
-				var p = {};
-
-				p.ot = $.jstree._reference(p.o) || this;
-				p.o = p.ot._get_node(o);
-				p.r = r === - 1 ? -1 : this._get_node(r);
-				p.p = (typeof p === "undefined") ? "last" : pos; // TODO: move to a setting
-				if(!is_cb && prepared_move.o && prepared_move.o[0] === p.o[0] && prepared_move.r[0] === p.r[0] && prepared_move.p === p.p) {
-					this.__callback(prepared_move);
-					if(cb) { cb.call(this, prepared_move); }
-					return;
-				}
-				p.ot = $.jstree._reference(p.o) || this;
-				p.rt = r === -1 ? p.ot : $.jstree._reference(p.r) || this;
-				if(p.r === -1) {
-					p.cr = -1;
-					switch(p.p) {
-						case "first":
-						case "before":
-						case "inside":
-							p.cp = 0; 
-							break;
-						case "after":
-						case "last":
-							p.cp = p.rt.get_container().find(" > ul > li").length; 
-							break;
-						default:
-							p.cp = p.p;
-							break;
-					}
-				}
-				else {
-					if(!/^(before|after)$/.test(p.p) && !this._is_loaded(p.r)) {
-						return this.load_node(p.r, function () { this.prepare_move(o, r, pos, cb, true); });
-					}
-					switch(p.p) {
-						case "before":
-							p.cp = p.r.index();
-							p.cr = p.rt._get_parent(p.r);
-							break;
-						case "after":
-							p.cp = p.r.index() + 1;
-							p.cr = p.rt._get_parent(p.r);
-							break;
-						case "inside":
-						case "first":
-							p.cp = 0;
-							p.cr = p.r;
-							break;
-						case "last":
-							p.cp = p.r.find(" > ul > li").length; 
-							p.cr = p.r;
-							break;
-						default: 
-							p.cp = p.p;
-							p.cr = p.r;
-							break;
-					}
-				}
-				p.np = p.cr == -1 ? p.rt.get_container() : p.cr;
-				p.op = p.ot._get_parent(p.o);
-				p.or = p.np.find(" > ul > li:nth-child(" + (p.cp + 1) + ")");
-
-				prepared_move = p;
-				this.__callback(prepared_move);
-				if(cb) { cb.call(this, prepared_move); }
-			},
-			check_move : function () {
-				var obj = prepared_move, ret = true;
-				if(obj.or[0] === obj.o[0]) { return false; }
-				obj.o.each(function () { 
-					if(obj.r.parentsUntil(".jstree").andSelf().filter("li").index(this) !== -1) { ret = false; return false; }
-				});
-				return ret;
-			},
-			move_node : function (obj, ref, position, is_copy, is_prepared, skip_check) {
-				if(!is_prepared) { 
-					return this.prepare_move(obj, ref, position, function (p) {
-						this.move_node(p, false, false, is_copy, true, skip_check);
-					});
-				}
-				if(!skip_check && !this.check_move()) { return false; }
-
-				this.__rollback();
-				var o = false;
-				if(is_copy) {
-					o = obj.o.clone();
-					o.find("*[id]").andSelf().each(function () {
-						if(this.id) { this.id = "copy_" + this.id; }
-					});
-				}
-				else { o = obj.o; }
-
-				if(obj.or.length) { obj.or.before(o); }
-				else { 
-					if(!obj.np.children("ul").length) { $("<ul>").appendTo(obj.np); }
-					obj.np.children("ul:eq(0)").append(o); 
-				}
-
-				try { 
-					obj.ot.clean_node(obj.op);
-					obj.rt.clean_node(obj.np);
-					if(!obj.op.find("> ul > li").length) {
-						obj.op.removeClass("jstree-open jstree-closed").addClass("jstree-leaf").children("ul").remove();
-					}
-				} catch (e) { }
-
-				if(is_copy) { 
-					prepared_move.cy = true;
-					prepared_move.oc = o; 
-				}
-				this.__callback(prepared_move);
-				return prepared_move;
-			},
-			_get_move : function () { return prepared_move; }
-		}
-	});
+  // private variables 
+  var instances = [],      // instance array (used by $.jstree.reference/create/focused)
+    focused_instance = -1,  // the index in the instance array of the currently focused instance
+    plugins = {},      // list of included plugins
+    prepared_move = {},    // for the move plugin
+    is_ie6 = false;
+
+  // jQuery plugin wrapper (thanks to jquery UI widget function)
+  $.fn.jstree = function (settings) {
+    var isMethodCall = (typeof settings == 'string'), // is this a method call like $().jstree("open_node")
+      args = Array.prototype.slice.call(arguments, 1), 
+      returnValue = this;
+
+    // extend settings and allow for multiple hashes and metadata
+    if(!isMethodCall && $.meta) { args.push($.metadata.get(this).jstree); }
+    settings = !isMethodCall && args.length ? $.extend.apply(null, [true, settings].concat(args)) : settings;
+    // block calls to "private" methods
+    if(isMethodCall && settings.substring(0, 1) == '_') { return returnValue; }
+
+    // if a method call execute the method on all selected instances
+    if(isMethodCall) {
+      this.each(function() {
+        var instance = instances[$.data(this, "jstree-instance-id")],
+          methodValue = (instance && $.isFunction(instance[settings])) ? instance[settings].apply(instance, args) : instance;
+          if(typeof methodValue !== "undefined" && (settings.indexOf("is_" === 0) || (methodValue !== true && methodValue !== false))) { returnValue = methodValue; return false; }
+      });
+    }
+    else {
+      this.each(function() {
+        var instance_id = $.data(this, "jstree-instance-id"),
+          s = false;
+        // if an instance already exists, destroy it first
+        if(typeof instance_id !== "undefined" && instances[instance_id]) { instances[instance_id].destroy(); }
+        // push a new empty object to the instances array
+        instance_id = parseInt(instances.push({}),10) - 1;
+        // store the jstree instance id to the container element
+        $.data(this, "jstree-instance-id", instance_id);
+        // clean up all plugins
+        if(!settings) { settings = {}; }
+        settings.plugins = $.isArray(settings.plugins) ? settings.plugins : $.jstree.defaults.plugins;
+        if($.inArray("core", settings.plugins) === -1) { settings.plugins.unshift("core"); }
+        
+        // only unique plugins (NOT WORKING)
+        // settings.plugins = settings.plugins.sort().join(",,").replace(/(,|^)([^,]+)(,,\2)+(,|$)/g,"$1$2$4").replace(/,,+/g,",").replace(/,$/,"").split(",");
+
+        // extend defaults with passed data
+        s = $.extend(true, {}, $.jstree.defaults, settings);
+        s.plugins = settings.plugins;
+        $.each(plugins, function (i, val) { if($.inArray(i, s.plugins) === -1) { s[i] = null; delete s[i]; } });
+        // push the new object to the instances array (at the same time set the default classes to the container) and init
+        instances[instance_id] = new $.jstree._instance(instance_id, $(this).addClass("jstree jstree-" + instance_id), s); 
+        // init all activated plugins for this instance
+        $.each(instances[instance_id]._get_settings().plugins, function (i, val) { instances[instance_id].data[val] = {}; });
+        $.each(instances[instance_id]._get_settings().plugins, function (i, val) { if(plugins[val]) { plugins[val].__init.apply(instances[instance_id]); } });
+        // initialize the instance
+        instances[instance_id].init();
+      });
+    }
+    // return the jquery selection (or if it was a method call that returned a value - the returned value)
+    return returnValue;
+  };
+  // object to store exposed functions and objects
+  $.jstree = {
+    defaults : {
+      plugins : []
+    },
+    _focused : function () { return instances[focused_instance] || null; },
+    _reference : function (needle) { 
+      // get by instance id
+      if(instances[needle]) { return instances[needle]; }
+      // get by DOM (if still no luck - return null
+      var o = $(needle); 
+      if(!o.length && typeof needle === "string") { o = $("#" + needle); }
+      if(!o.length) { return null; }
+      return instances[o.closest(".jstree").data("jstree-instance-id")] || null; 
+    },
+    _instance : function (index, container, settings) { 
+      // for plugins to store data in
+      this.data = { core : {} };
+      this.get_settings  = function () { return $.extend(true, {}, settings); };
+      this._get_settings  = function () { return settings; };
+      this.get_index    = function () { return index; };
+      this.get_container  = function () { return container; };
+      this._set_settings  = function (s) { 
+        settings = $.extend(true, {}, settings, s);
+      };
+    },
+    _fn : { },
+    plugin : function (pname, pdata) {
+      pdata = $.extend({}, {
+        __init    : $.noop, 
+        __destroy  : $.noop,
+        _fn      : {},
+        defaults  : false
+      }, pdata);
+      plugins[pname] = pdata;
+
+      $.jstree.defaults[pname] = pdata.defaults;
+      $.each(pdata._fn, function (i, val) {
+        val.plugin    = pname;
+        val.old      = $.jstree._fn[i];
+        $.jstree._fn[i] = function () {
+          var rslt,
+            func = val,
+            args = Array.prototype.slice.call(arguments),
+            evnt = new $.Event("before.jstree"),
+            rlbk = false;
+
+          // Check if function belongs to the included plugins of this instance
+          do {
+            if(func && func.plugin && $.inArray(func.plugin, this._get_settings().plugins) !== -1) { break; }
+            func = func.old;
+          } while(func);
+          if(!func) { return; }
+
+          // a chance to stop execution (or change arguments): 
+          // * just bind to jstree.before
+          // * check the additional data object (func property)
+          // * call event.stopImmediatePropagation()
+          // * return false (or an array of arguments)
+          rslt = this.get_container().triggerHandler(evnt, { "func" : i, "inst" : this, "args" : args });
+          if(rslt === false) { return; }
+          if(typeof rslt !== "undefined") { args = rslt; }
+
+          // context and function to trigger events, then finally call the function
+          if(i.indexOf("_") === 0) {
+            rslt = func.apply(this, args);
+          }
+          else {
+            rslt = func.apply(
+              $.extend({}, this, { 
+                __callback : function (data) { 
+                  this.get_container().triggerHandler( i + '.jstree', { "inst" : this, "args" : args, "rslt" : data, "rlbk" : rlbk });
+                },
+                __rollback : function () { 
+                  rlbk = this.get_rollback();
+                  return rlbk;
+                },
+                __call_old : function (replace_arguments) {
+                  return func.old.apply(this, (replace_arguments ? Array.prototype.slice.call(arguments, 1) : args ) );
+                }
+              }), args);
+          }
+
+          // return the result
+          return rslt;
+        };
+        $.jstree._fn[i].old = val.old;
+        $.jstree._fn[i].plugin = pname;
+      });
+    },
+    rollback : function (rb) {
+      if(rb) {
+        if(!$.isArray(rb)) { rb = [ rb ]; }
+        $.each(rb, function (i, val) {
+          instances[val.i].set_rollback(val.h, val.d);
+        });
+      }
+    }
+  };
+  // set the prototype for all instances
+  $.jstree._fn = $.jstree._instance.prototype = {};
+
+  // css functions - used internally
+
+  // load the css when DOM is ready
+  $(function() {
+    // code is copied form jQuery ($.browser is deprecated + there is a bug in IE)
+    var u = navigator.userAgent.toLowerCase(),
+      v = (u.match( /.+?(?:rv|it|ra|ie)[\/: ]([\d.]+)/ ) || [0,'0'])[1],
+      css_string = '' + 
+        '.jstree ul, .jstree li { display:block; margin:0 0 0 0; padding:0 0 0 0; list-style-type:none; } ' + 
+        '.jstree li { display:block; min-height:18px; line-height:18px; white-space:nowrap; margin-left:18px; } ' + 
+        '.jstree-rtl li { margin-left:0; margin-right:18px; } ' + 
+        '.jstree > ul > li { margin-left:0px; } ' + 
+        '.jstree-rtl > ul > li { margin-right:0px; } ' + 
+        '.jstree ins { display:inline-block; text-decoration:none; width:18px; height:18px; margin:0 0 0 0; padding:0; } ' + 
+        '.jstree a { display:inline-block; line-height:16px; height:16px; color:black; white-space:nowrap; text-decoration:none; padding:1px 2px; margin:0; } ' + 
+        '.jstree a:focus { outline: none; } ' + 
+        '.jstree a > ins { height:16px; width:16px; } ' + 
+        '.jstree a > .jstree-icon { margin-right:3px; } ' + 
+        '.jstree-rtl a > .jstree-icon { margin-left:3px; margin-right:0; } ' + 
+        'li.jstree-open > ul { display:block; } ' + 
+        'li.jstree-closed > ul { display:none; } ';
+    // Correct IE 6 (does not support the > CSS selector)
+    if(/msie/.test(u) && parseInt(v, 10) == 6) { 
+      is_ie6 = true;
+      css_string += '' + 
+        '.jstree li { height:18px; margin-left:0; margin-right:0; } ' + 
+        '.jstree li li { margin-left:18px; } ' + 
+        '.jstree-rtl li li { margin-left:0px; margin-right:18px; } ' + 
+        'li.jstree-open ul { display:block; } ' + 
+        'li.jstree-closed ul { display:none !important; } ' + 
+        '.jstree li a { display:inline; border-width:0 !important; padding:0px 2px !important; } ' + 
+        '.jstree li a ins { height:16px; width:16px; margin-right:3px; } ' + 
+        '.jstree-rtl li a ins { margin-right:0px; margin-left:3px; } ';
+    }
+    // Correct IE 7 (shifts anchor nodes onhover)
+    if(/msie/.test(u) && parseInt(v, 10) == 7) { 
+      css_string += '.jstree li a { border-width:0 !important; padding:0px 2px !important; } ';
+    }
+    $.vakata.css.add_sheet({ str : css_string });
+  });
+
+  // core functions (open, close, create, update, delete)
+  $.jstree.plugin("core", {
+    __init : function () {
+      this.data.core.to_open = $.map($.makeArray(this.get_settings().core.initially_open), function (n) { return "#" + n.toString().replace(/^#/,"").replace('\\/','/').replace('/','\\/'); });
+    },
+    defaults : { 
+      html_titles  : false,
+      animation  : 500,
+      initially_open : [],
+      rtl      : false,
+      strings    : {
+        loading    : "Loading ...",
+        new_node  : "New node"
+      }
+    },
+    _fn : { 
+      init  : function () { 
+        this.set_focus(); 
+        if(this._get_settings().core.rtl) {
+          this.get_container().addClass("jstree-rtl").css("direction", "rtl");
+        }
+        this.get_container().html("<ul><li class='jstree-last jstree-leaf'><ins>&#160;</ins><a class='jstree-loading' href='#'><ins class='jstree-icon'>&#160;</ins>" + this._get_settings().core.strings.loading + "</a></li></ul>");
+        this.data.core.li_height = this.get_container().find("ul li.jstree-closed, ul li.jstree-leaf").eq(0).height() || 18;
+
+        this.get_container()
+          .delegate("li > ins", "click.jstree", $.proxy(function (event) {
+              var trgt = $(event.target);
+              if(trgt.is("ins") && event.pageY - trgt.offset().top < this.data.core.li_height) { this.toggle_node(trgt); }
+            }, this))
+          .bind("mousedown.jstree", $.proxy(function () { 
+              this.set_focus(); // This used to be setTimeout(set_focus,0) - why?
+            }, this))
+          .bind("dblclick.jstree", function (event) { 
+            var sel;
+            if(document.selection && document.selection.empty) { document.selection.empty(); }
+            else {
+              if(window.getSelection) {
+                sel = window.getSelection();
+                try { 
+                  sel.removeAllRanges();
+                  sel.collapse();
+                } catch (err) { }
+              }
+            }
+          });
+        this.__callback();
+        this.load_node(-1, function () { this.loaded(); this.reopen(); });
+      },
+      destroy  : function () { 
+        var i,
+          n = this.get_index(),
+          s = this._get_settings(),
+          _this = this;
+
+        $.each(s.plugins, function (i, val) {
+          try { plugins[val].__destroy.apply(_this); } catch(err) { }
+        });
+        this.__callback();
+        // set focus to another instance if this one is focused
+        if(this.is_focused()) { 
+          for(i in instances) { 
+            if(instances.hasOwnProperty(i) && i != n) { 
+              instances[i].set_focus(); 
+              break; 
+            } 
+          }
+        }
+        // if no other instance found
+        if(n === focused_instance) { focused_instance = -1; }
+        // remove all traces of jstree in the DOM (only the ones set using jstree*) and cleans all events
+        this.get_container()
+          .unbind(".jstree")
+          .undelegate(".jstree")
+          .removeData("jstree-instance-id")
+          .find("[class^='jstree']")
+            .andSelf()
+            .attr("class", function () { return this.className.replace(/jstree[^ ]*|$/ig,''); });
+        // remove the actual data
+        instances[n] = null;
+        delete instances[n];
+      },
+      save_opened : function () {
+        var _this = this;
+        this.data.core.to_open = [];
+        this.get_container().find(".jstree-open").each(function () { 
+          _this.data.core.to_open.push("#" + this.id.toString().replace(/^#/,"").replace('\\/','/').replace('/','\\/')); 
+        });
+        this.__callback(_this.data.core.to_open);
+      },
+      reopen : function (is_callback) {
+        var _this = this,
+          done = true,
+          current = [],
+          remaining = [];
+        if(!is_callback) { this.data.core.reopen = false; this.data.core.refreshing = true; }
+        if(this.data.core.to_open.length) {
+          $.each(this.data.core.to_open, function (i, val) {
+            if(val == "#") { return true; }
+            if($(val).length && $(val).is(".jstree-closed")) { current.push(val); }
+            else { remaining.push(val); }
+          });
+          if(current.length) {
+            this.data.core.to_open = remaining;
+            $.each(current, function (i, val) { 
+              _this.open_node(val, function () { _this.reopen(true); }, true); 
+            });
+            done = false;
+          }
+        }
+        if(done) { 
+          // TODO: find a more elegant approach to syncronizing returning requests
+          if(this.data.core.reopen) { clearTimeout(this.data.core.reopen); }
+          this.data.core.reopen = setTimeout(function () { _this.__callback({}, _this); }, 50);
+          this.data.core.refreshing = false;
+        }
+      },
+      refresh : function (obj) {
+        var _this = this;
+        this.save_opened();
+        if(!obj) { obj = -1; }
+        obj = this._get_node(obj);
+        if(!obj) { obj = -1; }
+        if(obj !== -1) { obj.children("UL").remove(); }
+        this.load_node(obj, function () { _this.__callback({ "obj" : obj}); _this.reopen(); });
+      },
+      // Dummy function to fire after the first load (so that there is a jstree.loaded event)
+      loaded  : function () { 
+        this.__callback(); 
+      },
+      // deal with focus
+      set_focus  : function () { 
+        var f = $.jstree._focused();
+        if(f && f !== this) {
+          f.get_container().removeClass("jstree-focused"); 
+        }
+        if(f !== this) {
+          this.get_container().addClass("jstree-focused"); 
+          focused_instance = this.get_index(); 
+        }
+        this.__callback();
+      },
+      is_focused  : function () { 
+        return focused_instance == this.get_index(); 
+      },
+
+      // traverse
+      _get_node    : function (obj) { 
+        var $obj = $(obj, this.get_container()); 
+        if($obj.is(".jstree") || obj == -1) { return -1; } 
+        $obj = $obj.closest("li", this.get_container()); 
+        return $obj.length ? $obj : false; 
+      },
+      _get_next    : function (obj, strict) {
+        obj = this._get_node(obj);
+        if(obj === -1) { return this.get_container().find("> ul > li:first-child"); }
+        if(!obj.length) { return false; }
+        if(strict) { return (obj.nextAll("li").size() > 0) ? obj.nextAll("li:eq(0)") : false; }
+
+        if(obj.hasClass("jstree-open")) { return obj.find("li:eq(0)"); }
+        else if(obj.nextAll("li").size() > 0) { return obj.nextAll("li:eq(0)"); }
+        else { return obj.parentsUntil(".jstree","li").next("li").eq(0); }
+      },
+      _get_prev    : function (obj, strict) {
+        obj = this._get_node(obj);
+        if(obj === -1) { return this.get_container().find("> ul > li:last-child"); }
+        if(!obj.length) { return false; }
+        if(strict) { return (obj.prevAll("li").length > 0) ? obj.prevAll("li:eq(0)") : false; }
+
+        if(obj.prev("li").length) {
+          obj = obj.prev("li").eq(0);
+          while(obj.hasClass("jstree-open")) { obj = obj.children("ul:eq(0)").children("li:last"); }
+          return obj;
+        }
+        else { var o = obj.parentsUntil(".jstree","li:eq(0)"); return o.length ? o : false; }
+      },
+      _get_parent    : function (obj) {
+        obj = this._get_node(obj);
+        if(obj == -1 || !obj.length) { return false; }
+        var o = obj.parentsUntil(".jstree", "li:eq(0)");
+        return o.length ? o : -1;
+      },
+      _get_children  : function (obj) {
+        obj = this._get_node(obj);
+        if(obj === -1) { return this.get_container().children("ul:eq(0)").children("li"); }
+        if(!obj.length) { return false; }
+        return obj.children("ul:eq(0)").children("li");
+      },
+      get_path    : function (obj, id_mode) {
+        var p = [],
+          _this = this;
+        obj = this._get_node(obj);
+        if(obj === -1 || !obj || !obj.length) { return false; }
+        obj.parentsUntil(".jstree", "li").each(function () {
+          p.push( id_mode ? this.id : _this.get_text(this) );
+        });
+        p.reverse();
+        p.push( id_mode ? obj.attr("id") : this.get_text(obj) );
+        return p;
+      },
+
+      is_open    : function (obj) { obj = this._get_node(obj); return obj && obj !== -1 && obj.hasClass("jstree-open"); },
+      is_closed  : function (obj) { obj = this._get_node(obj); return obj && obj !== -1 && obj.hasClass("jstree-closed"); },
+      is_leaf    : function (obj) { obj = this._get_node(obj); return obj && obj !== -1 && obj.hasClass("jstree-leaf"); },
+      // open/close
+      open_node  : function (obj, callback, skip_animation) {
+        obj = this._get_node(obj);
+        if(!obj.length) { return false; }
+        if(!obj.hasClass("jstree-closed")) { if(callback) { callback.call(); } return false; }
+        var s = skip_animation || is_ie6 ? 0 : this._get_settings().core.animation,
+          t = this;
+        if(!this._is_loaded(obj)) {
+          obj.children("a").addClass("jstree-loading");
+          this.load_node(obj, function () { t.open_node(obj, callback, skip_animation); }, callback);
+        }
+        else {
+          if(s) { obj.children("ul").css("display","none"); }
+          obj.removeClass("jstree-closed").addClass("jstree-open").children("a").removeClass("jstree-loading");
+          if(s) { obj.children("ul").stop(true).slideDown(s, function () { this.style.display = ""; }); }
+          this.__callback({ "obj" : obj });
+          if(callback) { callback.call(); }
+        }
+      },
+      close_node  : function (obj, skip_animation) {
+        obj = this._get_node(obj);
+        var s = skip_animation || is_ie6 ? 0 : this._get_settings().core.animation;
+        if(!obj.length || !obj.hasClass("jstree-open")) { return false; }
+        if(s) { obj.children("ul").attr("style","display:block !important"); }
+        obj.removeClass("jstree-open").addClass("jstree-closed");
+        if(s) { obj.children("ul").stop(true).slideUp(s, function () { this.style.display = ""; }); }
+        this.__callback({ "obj" : obj });
+      },
+      toggle_node  : function (obj) {
+        obj = this._get_node(obj);
+        if(obj.hasClass("jstree-closed")) { return this.open_node(obj); }
+        if(obj.hasClass("jstree-open")) { return this.close_node(obj); }
+      },
+      open_all  : function (obj, original_obj) {
+        obj = obj ? this._get_node(obj) : this.get_container();
+        if(!obj || obj === -1) { obj = this.get_container(); }
+        if(original_obj) { 
+          obj = obj.find("li.jstree-closed");
+        }
+        else {
+          original_obj = obj;
+          if(obj.is(".jstree-closed")) { obj = obj.find("li.jstree-closed").andSelf(); }
+          else { obj = obj.find("li.jstree-closed"); }
+        }
+        var _this = this;
+        obj.each(function () { 
+          var __this = this; 
+          if(!_this._is_loaded(this)) { _this.open_node(this, function() { _this.open_all(__this, original_obj); }, true); }
+          else { _this.open_node(this, false, true); }
+        });
+        // so that callback is fired AFTER all nodes are open
+        if(original_obj.find('li.jstree-closed').length === 0) { this.__callback({ "obj" : original_obj }); }
+      },
+      close_all  : function (obj) {
+        var _this = this;
+        obj = obj ? this._get_node(obj) : this.get_container();
+        if(!obj || obj === -1) { obj = this.get_container(); }
+        obj.find("li.jstree-open").andSelf().each(function () { _this.close_node(this); });
+        this.__callback({ "obj" : obj });
+      },
+      clean_node  : function (obj) {
+        obj = obj && obj != -1 ? $(obj) : this.get_container();
+        obj = obj.is("li") ? obj.find("li").andSelf() : obj.find("li");
+        obj.removeClass("jstree-last")
+          .filter("li:last-child").addClass("jstree-last").end()
+          .filter(":has(li)")
+            .not(".jstree-open").removeClass("jstree-leaf").addClass("jstree-closed");
+        obj.not(".jstree-open, .jstree-closed").addClass("jstree-leaf").children("ul").remove();
+        this.__callback({ "obj" : obj });
+      },
+      // rollback
+      get_rollback : function () { 
+        this.__callback();
+        return { i : this.get_index(), h : this.get_container().children("ul").clone(true), d : this.data }; 
+      },
+      set_rollback : function (html, data) {
+        this.get_container().empty().append(html);
+        this.data = data;
+        this.__callback();
+      },
+      // Dummy functions to be overwritten by any datastore plugin included
+      load_node  : function (obj, s_call, e_call) { this.__callback({ "obj" : obj }); },
+      _is_loaded  : function (obj) { return true; },
+
+      // Basic operations: create
+      create_node  : function (obj, position, js, callback, is_loaded) {
+        obj = this._get_node(obj);
+        position = typeof position === "undefined" ? "last" : position;
+        var d = $("<li>"),
+          s = this._get_settings().core,
+          tmp;
+
+        if(obj !== -1 && !obj.length) { return false; }
+        if(!is_loaded && !this._is_loaded(obj)) { this.load_node(obj, function () { this.create_node(obj, position, js, callback, true); }); return false; }
+
+        this.__rollback();
+
+        if(typeof js === "string") { js = { "data" : js }; }
+        if(!js) { js = {}; }
+        if(js.attr) { d.attr(js.attr); }
+        if(js.state) { d.addClass("jstree-" + js.state); }
+        if(!js.data) { js.data = s.strings.new_node; }
+        if(!$.isArray(js.data)) { tmp = js.data; js.data = []; js.data.push(tmp); }
+        $.each(js.data, function (i, m) {
+          tmp = $("<a>");
+          if($.isFunction(m)) { m = m.call(this, js); }
+          if(typeof m == "string") { tmp.attr('href','#')[ s.html_titles ? "html" : "text" ](m); }
+          else {
+            if(!m.attr) { m.attr = {}; }
+            if(!m.attr.href) { m.attr.href = '#'; }
+            tmp.attr(m.attr)[ s.html_titles ? "html" : "text" ](m.title);
+            if(m.language) { tmp.addClass(m.language); }
+          }
+          tmp.prepend("<ins class='jstree-icon'>&#160;</ins>");
+          if(m.icon) { 
+            if(m.icon.indexOf("/") === -1) { tmp.children("ins").addClass(m.icon); }
+            else { tmp.children("ins").css("background","url('" + m.icon + "') center center no-repeat"); }
+          }
+          d.append(tmp);
+        });
+        d.prepend("<ins class='jstree-icon'>&#160;</ins>");
+        if(obj === -1) {
+          obj = this.get_container();
+          if(position === "before") { position = "first"; }
+          if(position === "after") { position = "last"; }
+        }
+        switch(position) {
+          case "before": obj.before(d); tmp = this._get_parent(obj); break;
+          case "after" : obj.after(d);  tmp = this._get_parent(obj); break;
+          case "inside":
+          case "first" :
+            if(!obj.children("ul").length) { obj.append("<ul>"); }
+            obj.children("ul").prepend(d);
+            tmp = obj;
+            break;
+          case "last":
+            if(!obj.children("ul").length) { obj.append("<ul>"); }
+            obj.children("ul").append(d);
+            tmp = obj;
+            break;
+          default:
+            if(!obj.children("ul").length) { obj.append("<ul>"); }
+            if(!position) { position = 0; }
+            tmp = obj.children("ul").children("li").eq(position);
+            if(tmp.length) { tmp.before(d); }
+            else { obj.children("ul").append(d); }
+            tmp = obj;
+            break;
+        }
+        if(tmp === -1 || tmp.get(0) === this.get_container().get(0)) { tmp = -1; }
+        this.clean_node(tmp);
+        this.__callback({ "obj" : d, "parent" : tmp });
+        if(callback) { callback.call(this, d); }
+        return d;
+      },
+      // Basic operations: rename (deal with text)
+      get_text  : function (obj) {
+        obj = this._get_node(obj);
+        if(!obj.length) { return false; }
+        var s = this._get_settings().core.html_titles;
+        obj = obj.children("a:eq(0)");
+        if(s) {
+          obj = obj.clone();
+          obj.children("INS").remove();
+          return obj.html();
+        }
+        else {
+          obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];
+          return obj.nodeValue;
+        }
+      },
+      set_text  : function (obj, val) {
+        obj = this._get_node(obj);
+        if(!obj.length) { return false; }
+        obj = obj.children("a:eq(0)");
+        if(this._get_settings().core.html_titles) {
+          var tmp = obj.children("INS").clone();
+          obj.html(val).prepend(tmp);
+          this.__callback({ "obj" : obj, "name" : val });
+          return true;
+        }
+        else {
+          obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];
+          this.__callback({ "obj" : obj, "name" : val });
+          return (obj.nodeValue = val);
+        }
+      },
+      rename_node : function (obj, val) {
+        obj = this._get_node(obj);
+        this.__rollback();
+        if(obj && obj.length && this.set_text.apply(this, Array.prototype.slice.call(arguments))) { this.__callback({ "obj" : obj, "name" : val }); }
+      },
+      // Basic operations: deleting nodes
+      delete_node : function (obj) {
+        obj = this._get_node(obj);
+        if(!obj.length) { return false; }
+        this.__rollback();
+        var p = this._get_parent(obj), prev = this._get_prev(obj);
+        obj = obj.remove();
+        if(p !== -1 && p.find("> ul > li").length === 0) {
+          p.removeClass("jstree-open jstree-closed").addClass("jstree-leaf");
+        }
+        this.clean_node(p);
+        this.__callback({ "obj" : obj, "prev" : prev });
+        return obj;
+      },
+      prepare_move : function (o, r, pos, cb, is_cb) {
+        var p = {};
+
+        p.ot = $.jstree._reference(p.o) || this;
+        p.o = p.ot._get_node(o);
+        p.r = r === - 1 ? -1 : this._get_node(r);
+        p.p = (typeof p === "undefined") ? "last" : pos; // TODO: move to a setting
+        if(!is_cb && prepared_move.o && prepared_move.o[0] === p.o[0] && prepared_move.r[0] === p.r[0] && prepared_move.p === p.p) {
+          this.__callback(prepared_move);
+          if(cb) { cb.call(this, prepared_move); }
+          return;
+        }
+        p.ot = $.jstree._reference(p.o) || this;
+        p.rt = r === -1 ? p.ot : $.jstree._reference(p.r) || this;
+        if(p.r === -1) {
+          p.cr = -1;
+          switch(p.p) {
+            case "first":
+            case "before":
+            case "inside":
+              p.cp = 0; 
+              break;
+            case "after":
+            case "last":
+              p.cp = p.rt.get_container().find(" > ul > li").length; 
+              break;
+            default:
+              p.cp = p.p;
+              break;
+          }
+        }
+        else {
+          if(!/^(before|after)$/.test(p.p) && !this._is_loaded(p.r)) {
+            return this.load_node(p.r, function () { this.prepare_move(o, r, pos, cb, true); });
+          }
+          switch(p.p) {
+            case "before":
+              p.cp = p.r.index();
+              p.cr = p.rt._get_parent(p.r);
+              break;
+            case "after":
+              p.cp = p.r.index() + 1;
+              p.cr = p.rt._get_parent(p.r);
+              break;
+            case "inside":
+            case "first":
+              p.cp = 0;
+              p.cr = p.r;
+              break;
+            case "last":
+              p.cp = p.r.find(" > ul > li").length; 
+              p.cr = p.r;
+              break;
+            default: 
+              p.cp = p.p;
+              p.cr = p.r;
+              break;
+          }
+        }
+        p.np = p.cr == -1 ? p.rt.get_container() : p.cr;
+        p.op = p.ot._get_parent(p.o);
+        p.or = p.np.find(" > ul > li:nth-child(" + (p.cp + 1) + ")");
+
+        prepared_move = p;
+        this.__callback(prepared_move);
+        if(cb) { cb.call(this, prepared_move); }
+      },
+      check_move : function () {
+        var obj = prepared_move, ret = true;
+        if(obj.or[0] === obj.o[0]) { return false; }
+        obj.o.each(function () { 
+          if(obj.r.parentsUntil(".jstree").andSelf().filter("li").index(this) !== -1) { ret = false; return false; }
+        });
+        return ret;
+      },
+      move_node : function (obj, ref, position, is_copy, is_prepared, skip_check) {
+        if(!is_prepared) { 
+          return this.prepare_move(obj, ref, position, function (p) {
+            this.move_node(p, false, false, is_copy, true, skip_check);
+          });
+        }
+        if(!skip_check && !this.check_move()) { return false; }
+
+        this.__rollback();
+        var o = false;
+        if(is_copy) {
+          o = obj.o.clone();
+          o.find("*[id]").andSelf().each(function () {
+            if(this.id) { this.id = "copy_" + this.id; }
+          });
+        }
+        else { o = obj.o; }
+
+        if(obj.or.length) { obj.or.before(o); }
+        else { 
+          if(!obj.np.children("ul").length) { $("<ul>").appendTo(obj.np); }
+          obj.np.children("ul:eq(0)").append(o); 
+        }
+
+        try { 
+          obj.ot.clean_node(obj.op);
+          obj.rt.clean_node(obj.np);
+          if(!obj.op.find("> ul > li").length) {
+            obj.op.removeClass("jstree-open jstree-closed").addClass("jstree-leaf").children("ul").remove();
+          }
+        } catch (e) { }
+
+        if(is_copy) { 
+          prepared_move.cy = true;
+          prepared_move.oc = o; 
+        }
+        this.__callback(prepared_move);
+        return prepared_move;
+      },
+      _get_move : function () { return prepared_move; }
+    }
+  });
 })(jQuery);
 //*/
 
@@ -847,180 +847,180 @@ THE SOFTWARE.
  * This plugins handles selecting/deselecting/hovering/dehovering nodes
  */
 (function ($) {
-	$.jstree.plugin("ui", {
-		__init : function () { 
-			this.data.ui.selected = $(); 
-			this.data.ui.last_selected = false; 
-			this.data.ui.hovered = null;
-			this.data.ui.to_select = this.get_settings().ui.initially_select;
-
-			this.get_container()
-				.delegate("a", "click.jstree", $.proxy(function (event) {
-						event.preventDefault();
-						this.select_node(event.currentTarget, true, event);
-					}, this))
-				.delegate("a", "mouseenter.jstree", $.proxy(function (event) {
-						this.hover_node(event.target);
-					}, this))
-				.delegate("a", "mouseleave.jstree", $.proxy(function (event) {
-						this.dehover_node(event.target);
-					}, this))
-				.bind("reopen.jstree", $.proxy(function () { 
-						this.reselect();
-					}, this))
-				.bind("get_rollback.jstree", $.proxy(function () { 
-						this.dehover_node();
-						this.save_selected();
-					}, this))
-				.bind("set_rollback.jstree", $.proxy(function () { 
-						this.reselect();
-					}, this))
-				.bind("close_node.jstree", $.proxy(function (event, data) { 
-						var s = this._get_settings().ui,
-							obj = this._get_node(data.rslt.obj),
-							clk = (obj && obj.length) ? obj.children("ul").find(".jstree-clicked") : $(),
-							_this = this;
-						if(s.selected_parent_close === false || !clk.length) { return; }
-						clk.each(function () { 
-							_this.deselect_node(this);
-							if(s.selected_parent_close === "select_parent") { _this.select_node(obj); }
-						});
-					}, this))
-				.bind("delete_node.jstree", $.proxy(function (event, data) { 
-						var s = this._get_settings().ui.select_prev_on_delete,
-							obj = this._get_node(data.rslt.obj),
-							clk = (obj && obj.length) ? obj.find(".jstree-clicked") : [],
-							_this = this;
-						clk.each(function () { _this.deselect_node(this); });
-						if(s && clk.length) { this.select_node(data.rslt.prev); }
-					}, this))
-				.bind("move_node.jstree", $.proxy(function (event, data) { 
-						if(data.rslt.cy) { 
-							data.rslt.oc.find(".jstree-clicked").removeClass("jstree-clicked");
-						}
-					}, this));
-		},
-		defaults : {
-			select_limit : -1, // 0, 1, 2 ... or -1 for unlimited
-			select_multiple_modifier : "ctrl", // on, or ctrl, shift, alt
-			selected_parent_close : "select_parent", // false, "deselect", "select_parent"
-			select_prev_on_delete : true,
-			disable_selecting_children : false,
-			initially_select : []
-		},
-		_fn : { 
-			_get_node : function (obj, allow_multiple) {
-				if(typeof obj === "undefined" || obj === null) { return allow_multiple ? this.data.ui.selected : this.data.ui.last_selected; }
-				var $obj = $(obj, this.get_container()); 
-				if($obj.is(".jstree") || obj == -1) { return -1; } 
-				$obj = $obj.closest("li", this.get_container()); 
-				return $obj.length ? $obj : false; 
-			},
-			save_selected : function () {
-				var _this = this;
-				this.data.ui.to_select = [];
-				this.data.ui.selected.each(function () { _this.data.ui.to_select.push("#" + this.id.toString().replace(/^#/,"").replace('\\/','/').replace('/','\\/')); });
-				this.__callback(this.data.ui.to_select);
-			},
-			reselect : function () {
-				var _this = this,
-					s = this.data.ui.to_select;
-				s = $.map($.makeArray(s), function (n) { return "#" + n.toString().replace(/^#/,"").replace('\\/','/').replace('/','\\/'); });
-				this.deselect_all();
-				$.each(s, function (i, val) { if(val && val !== "#") { _this.select_node(val); } });
-				this.__callback();
-			},
-			refresh : function (obj) {
-				this.save_selected();
-				return this.__call_old();
-			},
-			hover_node : function (obj) {
-				obj = this._get_node(obj);
-				if(!obj.length) { return false; }
-				//if(this.data.ui.hovered && obj.get(0) === this.data.ui.hovered.get(0)) { return; }
-				if(!obj.hasClass("jstree-hovered")) { this.dehover_node(); }
-				this.data.ui.hovered = obj.children("a").addClass("jstree-hovered").parent();
-				this.__callback({ "obj" : obj });
-			},
-			dehover_node : function () {
-				var obj = this.data.ui.hovered, p;
-				if(!obj || !obj.length) { return false; }
-				p = obj.children("a").removeClass("jstree-hovered").parent();
-				if(this.data.ui.hovered[0] === p[0]) { this.data.ui.hovered = null; }
-				this.__callback({ "obj" : obj });
-			},
-			select_node : function (obj, check, e) {
-				obj = this._get_node(obj);
-				if(obj == -1 || !obj || !obj.length) { return false; }
-				var s = this._get_settings().ui,
-					is_multiple = (s.select_multiple_modifier == "on" || (s.select_multiple_modifier !== false && e && e[s.select_multiple_modifier + "Key"])),
-					is_selected = this.is_selected(obj),
-					proceed = true;
-				if(check) {
-					if(s.disable_selecting_children && is_multiple && obj.parents("li", this.get_container()).children(".jstree-clicked").length) {
-						return false;
-					}
-					proceed = false;
-					switch(!0) {
-						case (is_selected && !is_multiple): 
-							this.deselect_all();
-							is_selected = false;
-							proceed = true;
-							break;
-						case (!is_selected && !is_multiple): 
-							if(s.select_limit == -1 || s.select_limit > 0) {
-								this.deselect_all();
-								proceed = true;
-							}
-							break;
-						case (is_selected && is_multiple): 
-							this.deselect_node(obj);
-							break;
-						case (!is_selected && is_multiple): 
-							if(s.select_limit == -1 || this.data.ui.selected.length + 1 <= s.select_limit) { 
-								proceed = true;
-							}
-							break;
-					}
-				}
-				if(proceed && !is_selected) {
-					obj.children("a").addClass("jstree-clicked");
-					this.data.ui.selected = this.data.ui.selected.add(obj);
-					this.data.ui.last_selected = obj;
-					this.__callback({ "obj" : obj });
-				}
-			},
-			deselect_node : function (obj) {
-				obj = this._get_node(obj);
-				if(!obj.length) { return false; }
-				if(this.is_selected(obj)) {
-					obj.children("a").removeClass("jstree-clicked");
-					this.data.ui.selected = this.data.ui.selected.not(obj);
-					if(this.data.ui.last_selected.get(0) === obj.get(0)) { this.data.ui.last_selected = this.data.ui.selected.eq(0); }
-					this.__callback({ "obj" : obj });
-				}
-			},
-			toggle_select : function (obj) {
-				obj = this._get_node(obj);
-				if(!obj.length) { return false; }
-				if(this.is_selected(obj)) { this.deselect_node(obj); }
-				else { this.select_node(obj); }
-			},
-			is_selected : function (obj) { return this.data.ui.selected.index(this._get_node(obj)) >= 0; },
-			get_selected : function (context) { 
-				return context ? $(context).find(".jstree-clicked").parent() : this.data.ui.selected; 
-			},
-			deselect_all : function (context) {
-				if(context) { $(context).find(".jstree-clicked").removeClass("jstree-clicked"); } 
-				else { this.get_container().find(".jstree-clicked").removeClass("jstree-clicked"); }
-				this.data.ui.selected = $([]);
-				this.data.ui.last_selected = false;
-				this.__callback();
-			}
-		}
-	});
-	// include the selection plugin by default
-	$.jstree.defaults.plugins.push("ui");
+  $.jstree.plugin("ui", {
+    __init : function () { 
+      this.data.ui.selected = $(); 
+      this.data.ui.last_selected = false; 
+      this.data.ui.hovered = null;
+      this.data.ui.to_select = this.get_settings().ui.initially_select;
+
+      this.get_container()
+        .delegate("a", "click.jstree", $.proxy(function (event) {
+            event.preventDefault();
+            this.select_node(event.currentTarget, true, event);
+          }, this))
+        .delegate("a", "mouseenter.jstree", $.proxy(function (event) {
+            this.hover_node(event.target);
+          }, this))
+        .delegate("a", "mouseleave.jstree", $.proxy(function (event) {
+            this.dehover_node(event.target);
+          }, this))
+        .bind("reopen.jstree", $.proxy(function () { 
+            this.reselect();
+          }, this))
+        .bind("get_rollback.jstree", $.proxy(function () { 
+            this.dehover_node();
+            this.save_selected();
+          }, this))
+        .bind("set_rollback.jstree", $.proxy(function () { 
+            this.reselect();
+          }, this))
+        .bind("close_node.jstree", $.proxy(function (event, data) { 
+            var s = this._get_settings().ui,
+              obj = this._get_node(data.rslt.obj),
+              clk = (obj && obj.length) ? obj.children("ul").find(".jstree-clicked") : $(),
+              _this = this;
+            if(s.selected_parent_close === false || !clk.length) { return; }
+            clk.each(function () { 
+              _this.deselect_node(this);
+              if(s.selected_parent_close === "select_parent") { _this.select_node(obj); }
+            });
+          }, this))
+        .bind("delete_node.jstree", $.proxy(function (event, data) { 
+            var s = this._get_settings().ui.select_prev_on_delete,
+              obj = this._get_node(data.rslt.obj),
+              clk = (obj && obj.length) ? obj.find(".jstree-clicked") : [],
+              _this = this;
+            clk.each(function () { _this.deselect_node(this); });
+            if(s && clk.length) { this.select_node(data.rslt.prev); }
+          }, this))
+        .bind("move_node.jstree", $.proxy(function (event, data) { 
+            if(data.rslt.cy) { 
+              data.rslt.oc.find(".jstree-clicked").removeClass("jstree-clicked");
+            }
+          }, this));
+    },
+    defaults : {
+      select_limit : -1, // 0, 1, 2 ... or -1 for unlimited
+      select_multiple_modifier : "ctrl", // on, or ctrl, shift, alt
+      selected_parent_close : "select_parent", // false, "deselect", "select_parent"
+      select_prev_on_delete : true,
+      disable_selecting_children : false,
+      initially_select : []
+    },
+    _fn : { 
+      _get_node : function (obj, allow_multiple) {
+        if(typeof obj === "undefined" || obj === null) { return allow_multiple ? this.data.ui.selected : this.data.ui.last_selected; }
+        var $obj = $(obj, this.get_container()); 
+        if($obj.is(".jstree") || obj == -1) { return -1; } 
+        $obj = $obj.closest("li", this.get_container()); 
+        return $obj.length ? $obj : false; 
+      },
+      save_selected : function () {
+        var _this = this;
+        this.data.ui.to_select = [];
+        this.data.ui.selected.each(function () { _this.data.ui.to_select.push("#" + this.id.toString().replace(/^#/,"").replace('\\/','/').replace('/','\\/')); });
+        this.__callback(this.data.ui.to_select);
+      },
+      reselect : function () {
+        var _this = this,
+          s = this.data.ui.to_select;
+        s = $.map($.makeArray(s), function (n) { return "#" + n.toString().replace(/^#/,"").replace('\\/','/').replace('/','\\/'); });
+        this.deselect_all();
+        $.each(s, function (i, val) { if(val && val !== "#") { _this.select_node(val); } });
+        this.__callback();
+      },
+      refresh : function (obj) {
+        this.save_selected();
+        return this.__call_old();
+      },
+      hover_node : function (obj) {
+        obj = this._get_node(obj);
+        if(!obj.length) { return false; }
+        //if(this.data.ui.hovered && obj.get(0) === this.data.ui.hovered.get(0)) { return; }
+        if(!obj.hasClass("jstree-hovered")) { this.dehover_node(); }
+        this.data.ui.hovered = obj.children("a").addClass("jstree-hovered").parent();
+        this.__callback({ "obj" : obj });
+      },
+      dehover_node : function () {
+        var obj = this.data.ui.hovered, p;
+        if(!obj || !obj.length) { return false; }
+        p = obj.children("a").removeClass("jstree-hovered").parent();
+        if(this.data.ui.hovered[0] === p[0]) { this.data.ui.hovered = null; }
+        this.__callback({ "obj" : obj });
+      },
+      select_node : function (obj, check, e) {
+        obj = this._get_node(obj);
+        if(obj == -1 || !obj || !obj.length) { return false; }
+        var s = this._get_settings().ui,
+          is_multiple = (s.select_multiple_modifier == "on" || (s.select_multiple_modifier !== false && e && e[s.select_multiple_modifier + "Key"])),
+          is_selected = this.is_selected(obj),
+          proceed = true;
+        if(check) {
+          if(s.disable_selecting_children && is_multiple && obj.parents("li", this.get_container()).children(".jstree-clicked").length) {
+            return false;
+          }
+          proceed = false;
+          switch(!0) {
+            case (is_selected && !is_multiple): 
+              this.deselect_all();
+              is_selected = false;
+              proceed = true;
+              break;
+            case (!is_selected && !is_multiple): 
+              if(s.select_limit == -1 || s.select_limit > 0) {
+                this.deselect_all();
+                proceed = true;
+              }
+              break;
+            case (is_selected && is_multiple): 
+              this.deselect_node(obj);
+              break;
+            case (!is_selected && is_multiple): 
+              if(s.select_limit == -1 || this.data.ui.selected.length + 1 <= s.select_limit) { 
+                proceed = true;
+              }
+              break;
+          }
+        }
+        if(proceed && !is_selected) {
+          obj.children("a").addClass("jstree-clicked");
+          this.data.ui.selected = this.data.ui.selected.add(obj);
+          this.data.ui.last_selected = obj;
+          this.__callback({ "obj" : obj });
+        }
+      },
+      deselect_node : function (obj) {
+        obj = this._get_node(obj);
+        if(!obj.length) { return false; }
+        if(this.is_selected(obj)) {
+          obj.children("a").removeClass("jstree-clicked");
+          this.data.ui.selected = this.data.ui.selected.not(obj);
+          if(this.data.ui.last_selected.get(0) === obj.get(0)) { this.data.ui.last_selected = this.data.ui.selected.eq(0); }
+          this.__callback({ "obj" : obj });
+        }
+      },
+      toggle_select : function (obj) {
+        obj = this._get_node(obj);
+        if(!obj.length) { return false; }
+        if(this.is_selected(obj)) { this.deselect_node(obj); }
+        else { this.select_node(obj); }
+      },
+      is_selected : function (obj) { return this.data.ui.selected.index(this._get_node(obj)) >= 0; },
+      get_selected : function (context) { 
+        return context ? $(context).find(".jstree-clicked").parent() : this.data.ui.selected; 
+      },
+      deselect_all : function (context) {
+        if(context) { $(context).find(".jstree-clicked").removeClass("jstree-clicked"); } 
+        else { this.get_container().find(".jstree-clicked").removeClass("jstree-clicked"); }
+        this.data.ui.selected = $([]);
+        this.data.ui.last_selected = false;
+        this.__callback();
+      }
+    }
+  });
+  // include the selection plugin by default
+  $.jstree.defaults.plugins.push("ui");
 })(jQuery);
 //*/
 
@@ -1029,164 +1029,164 @@ THE SOFTWARE.
  * Handles creating/renaming/removing/moving nodes by user interaction.
  */
 (function ($) {
-	$.jstree.plugin("crrm", { 
-		__init : function () {
-			this.get_container()
-				.bind("move_node.jstree", $.proxy(function (e, data) {
-					if(this._get_settings().crrm.move.open_onmove) {
-						var t = this;
-						data.rslt.np.parentsUntil(".jstree").andSelf().filter(".jstree-closed").each(function () {
-							t.open_node(this, false, true);
-						});
-					}
-				}, this));
-		},
-		defaults : {
-			input_width_limit : 200,
-			move : {
-				always_copy			: false, // false, true or "multitree"
-				open_onmove			: true,
-				default_position	: "last",
-				check_move			: function (m) { return true; }
-			}
-		},
-		_fn : {
-			_show_input : function (obj, callback) {
-				obj = this._get_node(obj);
-				var rtl = this._get_settings().core.rtl,
-					w = this._get_settings().crrm.input_width_limit,
-					w1 = obj.children("ins").width(),
-					w2 = obj.find("> a:visible > ins").width() * obj.find("> a:visible > ins").length,
-					t = this.get_text(obj),
-					h1 = $("<div>", { css : { "position" : "absolute", "top" : "-200px", "left" : (rtl ? "0px" : "-1000px"), "visibility" : "hidden" } }).appendTo("body"),
-					h2 = obj.css("position","relative").append(
-					$("<input>", { 
-						"value" : t,
-						// "size" : t.length,
-						"css" : {
-							"padding" : "0",
-							"border" : "1px solid silver",
-							"position" : "absolute",
-							"left"  : (rtl ? "auto" : (w1 + w2 + 4) + "px"),
-							"right" : (rtl ? (w1 + w2 + 4) + "px" : "auto"),
-							"top" : "0px",
-							"height" : (this.data.core.li_height - 2) + "px",
-							"lineHeight" : (this.data.core.li_height - 2) + "px",
-							"width" : "150px" // will be set a bit further down
-						},
-						"blur" : $.proxy(function () {
-							var i = obj.children("input"),
-								v = i.val();
-							if(v === "") { v = t; }
-							i.remove(); // rollback purposes
-							this.set_text(obj,t); // rollback purposes
-							this.rename_node(obj, v);
-							callback.call(this, obj, v, t);
-							obj.css("position","");
-						}, this),
-						"keyup" : function (event) {
-							var key = event.keyCode || event.which;
-							if(key == 27) { this.value = t; this.blur(); return; }
-							else if(key == 13) { this.blur(); return; }
-							else {
-								h2.width(Math.min(h1.text("pW" + this.value).width(),w));
-							}
-						}
-					})
-				).children("input"); 
-				this.set_text(obj, "");
-				h1.css({
-						fontFamily		: h2.css('fontFamily')		|| '',
-						fontSize		: h2.css('fontSize')		|| '',
-						fontWeight		: h2.css('fontWeight')		|| '',
-						fontStyle		: h2.css('fontStyle')		|| '',
-						fontStretch		: h2.css('fontStretch')		|| '',
-						fontVariant		: h2.css('fontVariant')		|| '',
-						letterSpacing	: h2.css('letterSpacing')	|| '',
-						wordSpacing		: h2.css('wordSpacing')		|| ''
-				});
-				h2.width(Math.min(h1.text("pW" + h2[0].value).width(),w))[0].select();
-			},
-			rename : function (obj) {
-				obj = this._get_node(obj);
-				this.__rollback();
-				var f = this.__callback;
-				this._show_input(obj, function (obj, new_name, old_name) { 
-					f.call(this, { "obj" : obj, "new_name" : new_name, "old_name" : old_name });
-				});
-			},
-			create : function (obj, position, js, callback, skip_rename) {
-				var t, _this = this;
-				obj = this._get_node(obj);
-				if(!obj) { obj = -1; }
-				this.__rollback();
-				t = this.create_node(obj, position, js, function (t) {
-					var p = this._get_parent(t),
-						pos = $(t).index();
-					if(callback) { callback.call(this, t); }
-					if(p.length && p.hasClass("jstree-closed")) { this.open_node(p, false, true); }
-					if(!skip_rename) { 
-						this._show_input(t, function (obj, new_name, old_name) { 
-							_this.__callback({ "obj" : obj, "name" : new_name, "parent" : p, "position" : pos });
-						});
-					}
-					else { _this.__callback({ "obj" : t, "name" : this.get_text(t), "parent" : p, "position" : pos }); }
-				});
-				return t;
-			},
-			remove : function (obj) {
-				obj = this._get_node(obj, true);
-				this.__rollback();
-				this.delete_node(obj);
-				this.__callback({ "obj" : obj });
-			},
-			check_move : function () {
-				if(!this.__call_old()) { return false; }
-				var s = this._get_settings().crrm.move;
-				if(!s.check_move.call(this, this._get_move())) { return false; }
-				return true;
-			},
-			move_node : function (obj, ref, position, is_copy, is_prepared, skip_check) {
-				var s = this._get_settings().crrm.move;
-				if(!is_prepared) { 
-					if(!position) { position = s.default_position; }
-					if(position === "inside" && !s.default_position.match(/^(before|after)$/)) { position = s.default_position; }
-					return this.__call_old(true, obj, ref, position, is_copy, false, skip_check);
-				}
-				// if the move is already prepared
-				if(s.always_copy === true || (s.always_copy === "multitree" && obj.rt.get_index() !== obj.ot.get_index() )) {
-					is_copy = true;
-				}
-				this.__call_old(true, obj, ref, position, is_copy, true, skip_check);
-			},
-
-			cut : function (obj) {
-				obj = this._get_node(obj);
-				this.data.crrm.cp_nodes = false;
-				this.data.crrm.ct_nodes = false;
-				if(!obj || !obj.length) { return false; }
-				this.data.crrm.ct_nodes = obj;
-			},
-			copy : function (obj) {
-				obj = this._get_node(obj);
-				this.data.crrm.cp_nodes = false;
-				this.data.crrm.ct_nodes = false;
-				if(!obj || !obj.length) { return false; }
-				this.data.crrm.cp_nodes = obj;
-			},
-			paste : function (obj) { 
-				obj = this._get_node(obj);
-				if(!obj || !obj.length) { return false; }
-				if(!this.data.crrm.ct_nodes && !this.data.crrm.cp_nodes) { return false; }
-				if(this.data.crrm.ct_nodes) { this.move_node(this.data.crrm.ct_nodes, obj); }
-				if(this.data.crrm.cp_nodes) { this.move_node(this.data.crrm.cp_nodes, obj, false, true); }
-				this.data.crrm.cp_nodes = false;
-				this.data.crrm.ct_nodes = false;
-			}
-		}
-	});
-	// include the crr plugin by default
-	$.jstree.defaults.plugins.push("crrm");
+  $.jstree.plugin("crrm", { 
+    __init : function () {
+      this.get_container()
+        .bind("move_node.jstree", $.proxy(function (e, data) {
+          if(this._get_settings().crrm.move.open_onmove) {
+            var t = this;
+            data.rslt.np.parentsUntil(".jstree").andSelf().filter(".jstree-closed").each(function () {
+              t.open_node(this, false, true);
+            });
+          }
+        }, this));
+    },
+    defaults : {
+      input_width_limit : 200,
+      move : {
+        always_copy      : false, // false, true or "multitree"
+        open_onmove      : true,
+        default_position  : "last",
+        check_move      : function (m) { return true; }
+      }
+    },
+    _fn : {
+      _show_input : function (obj, callback) {
+        obj = this._get_node(obj);
+        var rtl = this._get_settings().core.rtl,
+          w = this._get_settings().crrm.input_width_limit,
+          w1 = obj.children("ins").width(),
+          w2 = obj.find("> a:visible > ins").width() * obj.find("> a:visible > ins").length,
+          t = this.get_text(obj),
+          h1 = $("<div>", { css : { "position" : "absolute", "top" : "-200px", "left" : (rtl ? "0px" : "-1000px"), "visibility" : "hidden" } }).appendTo("body"),
+          h2 = obj.css("position","relative").append(
+          $("<input>", { 
+            "value" : t,
+            // "size" : t.length,
+            "css" : {
+              "padding" : "0",
+              "border" : "1px solid silver",
+              "position" : "absolute",
+              "left"  : (rtl ? "auto" : (w1 + w2 + 4) + "px"),
+              "right" : (rtl ? (w1 + w2 + 4) + "px" : "auto"),
+              "top" : "0px",
+              "height" : (this.data.core.li_height - 2) + "px",
+              "lineHeight" : (this.data.core.li_height - 2) + "px",
+              "width" : "150px" // will be set a bit further down
+            },
+            "blur" : $.proxy(function () {
+              var i = obj.children("input"),
+                v = i.val();
+              if(v === "") { v = t; }
+              i.remove(); // rollback purposes
+              this.set_text(obj,t); // rollback purposes
+              this.rename_node(obj, v);
+              callback.call(this, obj, v, t);
+              obj.css("position","");
+            }, this),
+            "keyup" : function (event) {
+              var key = event.keyCode || event.which;
+              if(key == 27) { this.value = t; this.blur(); return; }
+              else if(key == 13) { this.blur(); return; }
+              else {
+                h2.width(Math.min(h1.text("pW" + this.value).width(),w));
+              }
+            }
+          })
+        ).children("input"); 
+        this.set_text(obj, "");
+        h1.css({
+            fontFamily    : h2.css('fontFamily')    || '',
+            fontSize    : h2.css('fontSize')    || '',
+            fontWeight    : h2.css('fontWeight')    || '',
+            fontStyle    : h2.css('fontStyle')    || '',
+            fontStretch    : h2.css('fontStretch')    || '',
+            fontVariant    : h2.css('fontVariant')    || '',
+            letterSpacing  : h2.css('letterSpacing')  || '',
+            wordSpacing    : h2.css('wordSpacing')    || ''
+        });
+        h2.width(Math.min(h1.text("pW" + h2[0].value).width(),w))[0].select();
+      },
+      rename : function (obj) {
+        obj = this._get_node(obj);
+        this.__rollback();
+        var f = this.__callback;
+        this._show_input(obj, function (obj, new_name, old_name) { 
+          f.call(this, { "obj" : obj, "new_name" : new_name, "old_name" : old_name });
+        });
+      },
+      create : function (obj, position, js, callback, skip_rename) {
+        var t, _this = this;
+        obj = this._get_node(obj);
+        if(!obj) { obj = -1; }
+        this.__rollback();
+        t = this.create_node(obj, position, js, function (t) {
+          var p = this._get_parent(t),
+            pos = $(t).index();
+          if(callback) { callback.call(this, t); }
+          if(p.length && p.hasClass("jstree-closed")) { this.open_node(p, false, true); }
+          if(!skip_rename) { 
+            this._show_input(t, function (obj, new_name, old_name) { 
+              _this.__callback({ "obj" : obj, "name" : new_name, "parent" : p, "position" : pos });
+            });
+          }
+          else { _this.__callback({ "obj" : t, "name" : this.get_text(t), "parent" : p, "position" : pos }); }
+        });
+        return t;
+      },
+      remove : function (obj) {
+        obj = this._get_node(obj, true);
+        this.__rollback();
+        this.delete_node(obj);
+        this.__callback({ "obj" : obj });
+      },
+      check_move : function () {
+        if(!this.__call_old()) { return false; }
+        var s = this._get_settings().crrm.move;
+        if(!s.check_move.call(this, this._get_move())) { return false; }
+        return true;
+      },
+      move_node : function (obj, ref, position, is_copy, is_prepared, skip_check) {
+        var s = this._get_settings().crrm.move;
+        if(!is_prepared) { 
+          if(!position) { position = s.default_position; }
+          if(position === "inside" && !s.default_position.match(/^(before|after)$/)) { position = s.default_position; }
+          return this.__call_old(true, obj, ref, position, is_copy, false, skip_check);
+        }
+        // if the move is already prepared
+        if(s.always_copy === true || (s.always_copy === "multitree" && obj.rt.get_index() !== obj.ot.get_index() )) {
+          is_copy = true;
+        }
+        this.__call_old(true, obj, ref, position, is_copy, true, skip_check);
+      },
+
+      cut : function (obj) {
+        obj = this._get_node(obj);
+        this.data.crrm.cp_nodes = false;
+        this.data.crrm.ct_nodes = false;
+        if(!obj || !obj.length) { return false; }
+        this.data.crrm.ct_nodes = obj;
+      },
+      copy : function (obj) {
+        obj = this._get_node(obj);
+        this.data.crrm.cp_nodes = false;
+        this.data.crrm.ct_nodes = false;
+        if(!obj || !obj.length) { return false; }
+        this.data.crrm.cp_nodes = obj;
+      },
+      paste : function (obj) { 
+        obj = this._get_node(obj);
+        if(!obj || !obj.length) { return false; }
+        if(!this.data.crrm.ct_nodes && !this.data.crrm.cp_nodes) { return false; }
+        if(this.data.crrm.ct_nodes) { this.move_node(this.data.crrm.ct_nodes, obj); }
+        if(this.data.crrm.cp_nodes) { this.move_node(this.data.crrm.cp_nodes, obj, false, true); }
+        this.data.crrm.cp_nodes = false;
+        this.data.crrm.ct_nodes = false;
+      }
+    }
+  });
+  // include the crr plugin by default
+  $.jstree.defaults.plugins.push("crrm");
 })(jQuery);
 
 /* 
@@ -1194,77 +1194,77 @@ THE SOFTWARE.
  * Handles loading and setting themes, as well as detecting path to themes, etc.
  */
 (function ($) {
-	var themes_loaded = [];
-	// this variable stores the path to the themes folder - if left as false - it will be autodetected
-	$.jstree._themes = false;
-	$.jstree.plugin("themes", {
-		__init : function () { 
-			this.get_container()
-				.bind("init.jstree", $.proxy(function () {
-						var s = this._get_settings().themes;
-						this.data.themes.dots = s.dots; 
-						this.data.themes.icons = s.icons; 
-						//alert(s.dots);
-						this.set_theme(s.theme, s.url);
-					}, this))
-				.bind("loaded.jstree", $.proxy(function () {
-						// bound here too, as simple HTML tree's won't honor dots & icons otherwise
-						if(!this.data.themes.dots) { this.hide_dots(); }
-						else { this.show_dots(); }
-						if(!this.data.themes.icons) { this.hide_icons(); }
-						else { this.show_icons(); }
-					}, this));
-		},
-		defaults : { 
-			theme : "default", 
-			url : false,
-			dots : true,
-			icons : true
-		},
-		_fn : {
-			set_theme : function (theme_name, theme_url) {
-				if(!theme_name) { return false; }
-				if(!theme_url) { theme_url = $.jstree._themes + theme_name + '/style.css'; }
-				if($.inArray(theme_url, themes_loaded) == -1) {
-					$.vakata.css.add_sheet({ "url" : theme_url, "rel" : "jstree" });
-					themes_loaded.push(theme_url);
-				}
-				if(this.data.themes.theme != theme_name) {
-					this.get_container().removeClass('jstree-' + this.data.themes.theme);
-					this.data.themes.theme = theme_name;
-				}
-				this.get_container().addClass('jstree-' + theme_name);
-				if(!this.data.themes.dots) { this.hide_dots(); }
-				else { this.show_dots(); }
-				if(!this.data.themes.icons) { this.hide_icons(); }
-				else { this.show_icons(); }
-				this.__callback();
-			},
-			get_theme	: function () { return this.data.themes.theme; },
-
-			show_dots	: function () { this.data.themes.dots = true; this.get_container().children("ul").removeClass("jstree-no-dots"); },
-			hide_dots	: function () { this.data.themes.dots = false; this.get_container().children("ul").addClass("jstree-no-dots"); },
-			toggle_dots	: function () { if(this.data.themes.dots) { this.hide_dots(); } else { this.show_dots(); } },
-
-			show_icons	: function () { this.data.themes.icons = true; this.get_container().children("ul").removeClass("jstree-no-icons"); },
-			hide_icons	: function () { this.data.themes.icons = false; this.get_container().children("ul").addClass("jstree-no-icons"); },
-			toggle_icons: function () { if(this.data.themes.icons) { this.hide_icons(); } else { this.show_icons(); } }
-		}
-	});
-	// autodetect themes path
-	$(function () {
-		if($.jstree._themes === false) {
-			$("script").each(function () { 
-				if(this.src.toString().match(/jquery\.jstree[^\/]*?\.js(\?.*)?$/)) { 
-					$.jstree._themes = this.src.toString().replace(/jquery\.jstree[^\/]*?\.js(\?.*)?$/, "") + 'themes/'; 
-					return false; 
-				}
-			});
-		}
-		if($.jstree._themes === false) { $.jstree._themes = "themes/"; }
-	});
-	// include the themes plugin by default
-	$.jstree.defaults.plugins.push("themes");
+  var themes_loaded = [];
+  // this variable stores the path to the themes folder - if left as false - it will be autodetected
+  $.jstree._themes = false;
+  $.jstree.plugin("themes", {
+    __init : function () { 
+      this.get_container()
+        .bind("init.jstree", $.proxy(function () {
+            var s = this._get_settings().themes;
+            this.data.themes.dots = s.dots; 
+            this.data.themes.icons = s.icons; 
+            //alert(s.dots);
+            this.set_theme(s.theme, s.url);
+          }, this))
+        .bind("loaded.jstree", $.proxy(function () {
+            // bound here too, as simple HTML tree's won't honor dots & icons otherwise
+            if(!this.data.themes.dots) { this.hide_dots(); }
+            else { this.show_dots(); }
+            if(!this.data.themes.icons) { this.hide_icons(); }
+            else { this.show_icons(); }
+          }, this));
+    },
+    defaults : { 
+      theme : "default", 
+      url : false,
+      dots : true,
+      icons : true
+    },
+    _fn : {
+      set_theme : function (theme_name, theme_url) {
+        if(!theme_name) { return false; }
+        if(!theme_url) { theme_url = $.jstree._themes + theme_name + '/style.css'; }
+        if($.inArray(theme_url, themes_loaded) == -1) {
+          $.vakata.css.add_sheet({ "url" : theme_url, "rel" : "jstree" });
+          themes_loaded.push(theme_url);
+        }
+        if(this.data.themes.theme != theme_name) {
+          this.get_container().removeClass('jstree-' + this.data.themes.theme);
+          this.data.themes.theme = theme_name;
+        }
+        this.get_container().addClass('jstree-' + theme_name);
+        if(!this.data.themes.dots) { this.hide_dots(); }
+        else { this.show_dots(); }
+        if(!this.data.themes.icons) { this.hide_icons(); }
+        else { this.show_icons(); }
+        this.__callback();
+      },
+      get_theme  : function () { return this.data.themes.theme; },
+
+      show_dots  : function () { this.data.themes.dots = true; this.get_container().children("ul").removeClass("jstree-no-dots"); },
+      hide_dots  : function () { this.data.themes.dots = false; this.get_container().children("ul").addClass("jstree-no-dots"); },
+      toggle_dots  : function () { if(this.data.themes.dots) { this.hide_dots(); } else { this.show_dots(); } },
+
+      show_icons  : function () { this.data.themes.icons = true; this.get_container().children("ul").removeClass("jstree-no-icons"); },
+      hide_icons  : function () { this.data.themes.icons = false; this.get_container().children("ul").addClass("jstree-no-icons"); },
+      toggle_icons: function () { if(this.data.themes.icons) { this.hide_icons(); } else { this.show_icons(); } }
+    }
+  });
+  // autodetect themes path
+  $(function () {
+    if($.jstree._themes === false) {
+      $("script").each(function () { 
+        if(this.src.toString().match(/jquery\.jstree[^\/]*?\.js(\?.*)?$/)) { 
+          $.jstree._themes = this.src.toString().replace(/jquery\.jstree[^\/]*?\.js(\?.*)?$/, "") + 'themes/'; 
+          return false; 
+        }
+      });
+    }
+    if($.jstree._themes === false) { $.jstree._themes = "themes/"; }
+  });
+  // include the themes plugin by default
+  $.jstree.defaults.plugins.push("themes");
 })(jQuery);
 //*/
 
@@ -1274,74 +1274,74 @@ THE SOFTWARE.
  * Depends on the jstree ui & jquery hotkeys plugins
  */
 (function ($) {
-	var bound = [];
-	function exec(i, event) {
-		var f = $.jstree._focused(), tmp;
-		if(f && f.data && f.data.hotkeys && f.data.hotkeys.enabled) { 
-			tmp = f._get_settings().hotkeys[i];
-			if(tmp) { return tmp.call(f, event); }
-		}
-	}
-	$.jstree.plugin("hotkeys", {
-		__init : function () {
-			if(typeof $.hotkeys === "undefined") { throw "jsTree hotkeys: jQuery hotkeys plugin not included."; }
-			if(!this.data.ui) { throw "jsTree hotkeys: jsTree UI plugin not included."; }
-			$.each(this._get_settings().hotkeys, function (i, val) {
-				if($.inArray(i, bound) == -1) {
-					$(document).bind("keydown", i, function (event) { return exec(i, event); });
-					bound.push(i);
-				}
-			});
-			this.enable_hotkeys();
-		},
-		defaults : {
-			"up" : function () { 
-				var o = this.data.ui.hovered || this.data.ui.last_selected || -1;
-				this.hover_node(this._get_prev(o));
-				return false; 
-			},
-			"down" : function () { 
-				var o = this.data.ui.hovered || this.data.ui.last_selected || -1;
-				this.hover_node(this._get_next(o));
-				return false;
-			},
-			"left" : function () { 
-				var o = this.data.ui.hovered || this.data.ui.last_selected;
-				if(o) {
-					if(o.hasClass("jstree-open")) { this.close_node(o); }
-					else { this.hover_node(this._get_prev(o)); }
-				}
-				return false;
-			},
-			"right" : function () { 
-				var o = this.data.ui.hovered || this.data.ui.last_selected;
-				if(o && o.length) {
-					if(o.hasClass("jstree-closed")) { this.open_node(o); }
-					else { this.hover_node(this._get_next(o)); }
-				}
-				return false;
-			},
-			"space" : function () { 
-				if(this.data.ui.hovered) { this.data.ui.hovered.children("a:eq(0)").click(); } 
-				return false; 
-			},
-			"ctrl+space" : function (event) { 
-				event.type = "click";
-				if(this.data.ui.hovered) { this.data.ui.hovered.children("a:eq(0)").trigger(event); } 
-				return false; 
-			},
-			"f2" : function () { this.rename(this.data.ui.hovered || this.data.ui.last_selected); },
-			"del" : function () { this.remove(this.data.ui.hovered || this._get_node(null)); }
-		},
-		_fn : {
-			enable_hotkeys : function () {
-				this.data.hotkeys.enabled = true;
-			},
-			disable_hotkeys : function () {
-				this.data.hotkeys.enabled = false;
-			}
-		}
-	});
+  var bound = [];
+  function exec(i, event) {
+    var f = $.jstree._focused(), tmp;
+    if(f && f.data && f.data.hotkeys && f.data.hotkeys.enabled) { 
+      tmp = f._get_settings().hotkeys[i];
+      if(tmp) { return tmp.call(f, event); }
+    }
+  }
+  $.jstree.plugin("hotkeys", {
+    __init : function () {
+      if(typeof $.hotkeys === "undefined") { throw "jsTree hotkeys: jQuery hotkeys plugin not included."; }
+      if(!this.data.ui) { throw "jsTree hotkeys: jsTree UI plugin not included."; }
+      $.each(this._get_settings().hotkeys, function (i, val) {
+        if($.inArray(i, bound) == -1) {
+          $(document).bind("keydown", i, function (event) { return exec(i, event); });
+          bound.push(i);
+        }
+      });
+      this.enable_hotkeys();
+    },
+    defaults : {
+      "up" : function () { 
+        var o = this.data.ui.hovered || this.data.ui.last_selected || -1;
+        this.hover_node(this._get_prev(o));
+        return false; 
+      },
+      "down" : function () { 
+        var o = this.data.ui.hovered || this.data.ui.last_selected || -1;
+        this.hover_node(this._get_next(o));
+        return false;
+      },
+      "left" : function () { 
+        var o = this.data.ui.hovered || this.data.ui.last_selected;
+        if(o) {
+          if(o.hasClass("jstree-open")) { this.close_node(o); }
+          else { this.hover_node(this._get_prev(o)); }
+        }
+        return false;
+      },
+      "right" : function () { 
+        var o = this.data.ui.hovered || this.data.ui.last_selected;
+        if(o && o.length) {
+          if(o.hasClass("jstree-closed")) { this.open_node(o); }
+          else { this.hover_node(this._get_next(o)); }
+        }
+        return false;
+      },
+      "space" : function () { 
+        if(this.data.ui.hovered) { this.data.ui.hovered.children("a:eq(0)").click(); } 
+        return false; 
+      },
+      "ctrl+space" : function (event) { 
+        event.type = "click";
+        if(this.data.ui.hovered) { this.data.ui.hovered.children("a:eq(0)").trigger(event); } 
+        return false; 
+      },
+      "f2" : function () { this.rename(this.data.ui.hovered || this.data.ui.last_selected); },
+      "del" : function () { this.remove(this.data.ui.hovered || this._get_node(null)); }
+    },
+    _fn : {
+      enable_hotkeys : function () {
+        this.data.hotkeys.enabled = true;
+      },
+      disable_hotkeys : function () {
+        this.data.hotkeys.enabled = false;
+      }
+    }
+  });
 })(jQuery);
 //*/
 
@@ -1350,248 +1350,248 @@ THE SOFTWARE.
  * The JSON data store. Datastores are build by overriding the `load_node` and `_is_loaded` functions.
  */
 (function ($) {
-	$.jstree.plugin("json_data", {
-		defaults : { 
-			data : false,
-			ajax : false,
-			correct_state : true,
-			progressive_render : false
-		},
-		_fn : {
-			load_node : function (obj, s_call, e_call) { var _this = this; this.load_node_json(obj, function () { _this.__callback({ "obj" : obj }); s_call.call(this); }, e_call); },
-			_is_loaded : function (obj) { 
-				var s = this._get_settings().json_data, d;
-				obj = this._get_node(obj); 
-				if(obj && obj !== -1 && s.progressive_render && !obj.is(".jstree-open, .jstree-leaf") && obj.children("ul").children("li").length === 0 && obj.data("jstree-children")) {
-					d = this._parse_json(obj.data("jstree-children"));
-					if(d) {
-						obj.append(d);
-						$.removeData(obj, "jstree-children");
-					}
-					this.clean_node(obj);
-					return true;
-				}
-				return obj == -1 || !obj || !s.ajax || obj.is(".jstree-open, .jstree-leaf") || obj.children("ul").children("li").size() > 0;
-			},
-			load_node_json : function (obj, s_call, e_call) {
-				var s = this.get_settings().json_data, d,
-					error_func = function () {},
-					success_func = function () {};
-				obj = this._get_node(obj);
-				if(obj && obj !== -1) {
-					if(obj.data("jstree-is-loading")) { return; }
-					else { obj.data("jstree-is-loading",true); }
-				}
-				switch(!0) {
-					case (!s.data && !s.ajax): throw "Neither data nor ajax settings supplied.";
-					case (!!s.data && !s.ajax) || (!!s.data && !!s.ajax && (!obj || obj === -1)):
-						if(!obj || obj == -1) {
-							d = this._parse_json(s.data);
-							if(d) {
-								this.get_container().children("ul").empty().append(d.children());
-								this.clean_node();
-							}
-							else { 
-								if(s.correct_state) { this.get_container().children("ul").empty(); }
-							}
-						}
-						if(s_call) { s_call.call(this); }
-						break;
-					case (!s.data && !!s.ajax) || (!!s.data && !!s.ajax && obj && obj !== -1):
-						error_func = function (x, t, e) {
-							var ef = this.get_settings().json_data.ajax.error; 
-							if(ef) { ef.call(this, x, t, e); }
-							if(obj != -1 && obj.length) {
-								obj.children(".jstree-loading").removeClass("jstree-loading");
-								obj.data("jstree-is-loading",false);
-								if(t === "success" && s.correct_state) { obj.removeClass("jstree-open jstree-closed").addClass("jstree-leaf"); }
-							}
-							else {
-								if(t === "success" && s.correct_state) { this.get_container().children("ul").empty(); }
-							}
-							if(e_call) { e_call.call(this); }
-						};
-						success_func = function (d, t, x) {
-							var sf = this.get_settings().json_data.ajax.success; 
-							if(sf) { d = sf.call(this,d,t,x) || d; }
-							if(d === "" || (!$.isArray(d) && !$.isPlainObject(d))) {
-								return error_func.call(this, x, t, "");
-							}
-							d = this._parse_json(d);
-							if(d) {
-								if(obj === -1 || !obj) { this.get_container().children("ul").empty().append(d.children()); }
-								else { obj.append(d).children(".jstree-loading").removeClass("jstree-loading"); obj.data("jstree-is-loading",false); }
-								this.clean_node(obj);
-								if(s_call) { s_call.call(this); }
-							}
-							else {
-								if(obj === -1 || !obj) {
-									if(s.correct_state) { 
-										this.get_container().children("ul").empty(); 
-										if(s_call) { s_call.call(this); }
-									}
-								}
-								else {
-									obj.children(".jstree-loading").removeClass("jstree-loading");
-									obj.data("jstree-is-loading",false);
-									if(s.correct_state) { 
-										obj.removeClass("jstree-open jstree-closed").addClass("jstree-leaf"); 
-										if(s_call) { s_call.call(this); } 
-									}
-								}
-							}
-						};
-						s.ajax.context = this;
-						s.ajax.error = error_func;
-						s.ajax.success = success_func;
-						if(!s.ajax.dataType) { s.ajax.dataType = "json"; }
-						if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, obj); }
-						if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, obj); }
-						$.ajax(s.ajax);
-						break;
-				}
-			},
-			_parse_json : function (js, is_callback) {
-				var d = false, 
-					p = this._get_settings(),
-					s = p.json_data,
-					t = p.core.html_titles,
-					tmp, i, j, ul1, ul2;
-
-				if(!js) { return d; }
-				if($.isFunction(js)) { 
-					js = js.call(this);
-				}
-				if($.isArray(js)) {
-					d = $();
-					if(!js.length) { return false; }
-					for(i = 0, j = js.length; i < j; i++) {
-						tmp = this._parse_json(js[i], true);
-						if(tmp.length) { d = d.add(tmp); }
-					}
-				}
-				else {
-					if(typeof js == "string") { js = { data : js }; }
-					if(!js.data && js.data !== "") { return d; }
-					d = $("<li>");
-					if(js.attr) { d.attr(js.attr); }
-					if(js.metadata) { d.data("jstree", js.metadata); }
-					if(js.state) { d.addClass("jstree-" + js.state); }
-					if(!$.isArray(js.data)) { tmp = js.data; js.data = []; js.data.push(tmp); }
-					$.each(js.data, function (i, m) {
-						tmp = $("<a>");
-						if($.isFunction(m)) { m = m.call(this, js); }
-						if(typeof m == "string") { tmp.attr('href','#')[ t ? "html" : "text" ](m); }
-						else {
-							if(!m.attr) { m.attr = {}; }
-							if(!m.attr.href) { m.attr.href = '#'; }
-							tmp.attr(m.attr)[ t ? "html" : "text" ](m.title);
-							if(m.language) { tmp.addClass(m.language); }
-						}
-						tmp.prepend("<ins class='jstree-icon'>&#160;</ins>");
-						if(!m.icon && js.icon) { m.icon = js.icon; }
-						if(m.icon) { 
-							if(m.icon.indexOf("/") === -1) { tmp.children("ins").addClass(m.icon); }
-							else { tmp.children("ins").css("background","url('" + m.icon + "') center center no-repeat"); }
-						}
-						d.append(tmp);
-					});
-					d.prepend("<ins class='jstree-icon'>&#160;</ins>");
-					if(js.children) { 
-						if(s.progressive_render && js.state !== "open") {
-							d.addClass("jstree-closed").data("jstree-children", js.children);
-						}
-						else {
-							if($.isFunction(js.children)) {
-								js.children = js.children.call(this, js);
-							}
-							if($.isArray(js.children) && js.children.length) {
-								tmp = this._parse_json(js.children, true);
-								if(tmp.length) {
-									ul2 = $("<ul>");
-									ul2.append(tmp);
-									d.append(ul2);
-								}
-							}
-						}
-					}
-				}
-				if(!is_callback) {
-					ul1 = $("<ul>");
-					ul1.append(d);
-					d = ul1;
-				}
-				return d;
-			},
-			get_json : function (obj, li_attr, a_attr, is_callback) {
-				var result = [], 
-					s = this._get_settings(), 
-					_this = this,
-					tmp1, tmp2, li, a, t, lang;
-				obj = this._get_node(obj);
-				if(!obj || obj === -1) { obj = this.get_container().find("> ul > li"); }
-				li_attr = $.isArray(li_attr) ? li_attr : [ "id", "class" ];
-				if(!is_callback && this.data.types) { li_attr.push(s.types.type_attr); }
-				a_attr = $.isArray(a_attr) ? a_attr : [ ];
-
-				obj.each(function () {
-					li = $(this);
-					tmp1 = { data : [] };
-					if(li_attr.length) { tmp1.attr = { }; }
-					$.each(li_attr, function (i, v) { 
-						tmp2 = li.attr(v); 
-						if(tmp2 && tmp2.length && tmp2.replace(/jstree[^ ]*|$/ig,'').length) {
-							tmp1.attr[v] = tmp2.replace(/jstree[^ ]*|$/ig,''); 
-						}
-					});
-					if(li.hasClass("jstree-open")) { tmp1.state = "open"; }
-					if(li.hasClass("jstree-closed")) { tmp1.state = "closed"; }
-					a = li.children("a");
-					a.each(function () {
-						t = $(this);
-						if(
-							a_attr.length || 
-							$.inArray("languages", s.plugins) !== -1 || 
-							t.children("ins").get(0).style.backgroundImage.length || 
-							(t.children("ins").get(0).className && t.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').length)
-						) { 
-							lang = false;
-							if($.inArray("languages", s.plugins) !== -1 && $.isArray(s.languages) && s.languages.length) {
-								$.each(s.languages, function (l, lv) {
-									if(t.hasClass(lv)) {
-										lang = lv;
-										return false;
-									}
-								});
-							}
-							tmp2 = { attr : { }, title : _this.get_text(t, lang) }; 
-							$.each(a_attr, function (k, z) {
-								tmp1.attr[z] = (t.attr(z) || "").replace(/jstree[^ ]*|$/ig,'');
-							});
-							$.each(s.languages, function (k, z) {
-								if(t.hasClass(z)) { tmp2.language = z; return true; }
-							});
-							if(t.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').replace(/^\s+$/ig,"").length) {
-								tmp2.icon = t.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').replace(/^\s+$/ig,"");
-							}
-							if(t.children("ins").get(0).style.backgroundImage.length) {
-								tmp2.icon = t.children("ins").get(0).style.backgroundImage.replace("url(","").replace(")","");
-							}
-						}
-						else {
-							tmp2 = _this.get_text(t);
-						}
-						if(a.length > 1) { tmp1.data.push(tmp2); }
-						else { tmp1.data = tmp2; }
-					});
-					li = li.find("> ul > li");
-					if(li.length) { tmp1.children = _this.get_json(li, li_attr, a_attr, true); }
-					result.push(tmp1);
-				});
-				return result;
-			}
-		}
-	});
+  $.jstree.plugin("json_data", {
+    defaults : { 
+      data : false,
+      ajax : false,
+      correct_state : true,
+      progressive_render : false
+    },
+    _fn : {
+      load_node : function (obj, s_call, e_call) { var _this = this; this.load_node_json(obj, function () { _this.__callback({ "obj" : obj }); s_call.call(this); }, e_call); },
+      _is_loaded : function (obj) { 
+        var s = this._get_settings().json_data, d;
+        obj = this._get_node(obj); 
+        if(obj && obj !== -1 && s.progressive_render && !obj.is(".jstree-open, .jstree-leaf") && obj.children("ul").children("li").length === 0 && obj.data("jstree-children")) {
+          d = this._parse_json(obj.data("jstree-children"));
+          if(d) {
+            obj.append(d);
+            $.removeData(obj, "jstree-children");
+          }
+          this.clean_node(obj);
+          return true;
+        }
+        return obj == -1 || !obj || !s.ajax || obj.is(".jstree-open, .jstree-leaf") || obj.children("ul").children("li").size() > 0;
+      },
+      load_node_json : function (obj, s_call, e_call) {
+        var s = this.get_settings().json_data, d,
+          error_func = function () {},
+          success_func = function () {};
+        obj = this._get_node(obj);
+        if(obj && obj !== -1) {
+          if(obj.data("jstree-is-loading")) { return; }
+          else { obj.data("jstree-is-loading",true); }
+        }
+        switch(!0) {
+          case (!s.data && !s.ajax): throw "Neither data nor ajax settings supplied.";
+          case (!!s.data && !s.ajax) || (!!s.data && !!s.ajax && (!obj || obj === -1)):
+            if(!obj || obj == -1) {
+              d = this._parse_json(s.data);
+              if(d) {
+                this.get_container().children("ul").empty().append(d.children());
+                this.clean_node();
+              }
+              else { 
+                if(s.correct_state) { this.get_container().children("ul").empty(); }
+              }
+            }
+            if(s_call) { s_call.call(this); }
+            break;
+          case (!s.data && !!s.ajax) || (!!s.data && !!s.ajax && obj && obj !== -1):
+            error_func = function (x, t, e) {
+              var ef = this.get_settings().json_data.ajax.error; 
+              if(ef) { ef.call(this, x, t, e); }
+              if(obj != -1 && obj.length) {
+                obj.children(".jstree-loading").removeClass("jstree-loading");
+                obj.data("jstree-is-loading",false);
+                if(t === "success" && s.correct_state) { obj.removeClass("jstree-open jstree-closed").addClass("jstree-leaf"); }
+              }
+              else {
+                if(t === "success" && s.correct_state) { this.get_container().children("ul").empty(); }
+              }
+              if(e_call) { e_call.call(this); }
+            };
+            success_func = function (d, t, x) {
+              var sf = this.get_settings().json_data.ajax.success; 
+              if(sf) { d = sf.call(this,d,t,x) || d; }
+              if(d === "" || (!$.isArray(d) && !$.isPlainObject(d))) {
+                return error_func.call(this, x, t, "");
+              }
+              d = this._parse_json(d);
+              if(d) {
+                if(obj === -1 || !obj) { this.get_container().children("ul").empty().append(d.children()); }
+                else { obj.append(d).children(".jstree-loading").removeClass("jstree-loading"); obj.data("jstree-is-loading",false); }
+                this.clean_node(obj);
+                if(s_call) { s_call.call(this); }
+              }
+              else {
+                if(obj === -1 || !obj) {
+                  if(s.correct_state) { 
+                    this.get_container().children("ul").empty(); 
+                    if(s_call) { s_call.call(this); }
+                  }
+                }
+                else {
+                  obj.children(".jstree-loading").removeClass("jstree-loading");
+                  obj.data("jstree-is-loading",false);
+                  if(s.correct_state) { 
+                    obj.removeClass("jstree-open jstree-closed").addClass("jstree-leaf"); 
+                    if(s_call) { s_call.call(this); } 
+                  }
+                }
+              }
+            };
+            s.ajax.context = this;
+            s.ajax.error = error_func;
+            s.ajax.success = success_func;
+            if(!s.ajax.dataType) { s.ajax.dataType = "json"; }
+            if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, obj); }
+            if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, obj); }
+            $.ajax(s.ajax);
+            break;
+        }
+      },
+      _parse_json : function (js, is_callback) {
+        var d = false, 
+          p = this._get_settings(),
+          s = p.json_data,
+          t = p.core.html_titles,
+          tmp, i, j, ul1, ul2;
+
+        if(!js) { return d; }
+        if($.isFunction(js)) { 
+          js = js.call(this);
+        }
+        if($.isArray(js)) {
+          d = $();
+          if(!js.length) { return false; }
+          for(i = 0, j = js.length; i < j; i++) {
+            tmp = this._parse_json(js[i], true);
+            if(tmp.length) { d = d.add(tmp); }
+          }
+        }
+        else {
+          if(typeof js == "string") { js = { data : js }; }
+          if(!js.data && js.data !== "") { return d; }
+          d = $("<li>");
+          if(js.attr) { d.attr(js.attr); }
+          if(js.metadata) { d.data("jstree", js.metadata); }
+          if(js.state) { d.addClass("jstree-" + js.state); }
+          if(!$.isArray(js.data)) { tmp = js.data; js.data = []; js.data.push(tmp); }
+          $.each(js.data, function (i, m) {
+            tmp = $("<a>");
+            if($.isFunction(m)) { m = m.call(this, js); }
+            if(typeof m == "string") { tmp.attr('href','#')[ t ? "html" : "text" ](m); }
+            else {
+              if(!m.attr) { m.attr = {}; }
+              if(!m.attr.href) { m.attr.href = '#'; }
+              tmp.attr(m.attr)[ t ? "html" : "text" ](m.title);
+              if(m.language) { tmp.addClass(m.language); }
+            }
+            tmp.prepend("<ins class='jstree-icon'>&#160;</ins>");
+            if(!m.icon && js.icon) { m.icon = js.icon; }
+            if(m.icon) { 
+              if(m.icon.indexOf("/") === -1) { tmp.children("ins").addClass(m.icon); }
+              else { tmp.children("ins").css("background","url('" + m.icon + "') center center no-repeat"); }
+            }
+            d.append(tmp);
+          });
+          d.prepend("<ins class='jstree-icon'>&#160;</ins>");
+          if(js.children) { 
+            if(s.progressive_render && js.state !== "open") {
+              d.addClass("jstree-closed").data("jstree-children", js.children);
+            }
+            else {
+              if($.isFunction(js.children)) {
+                js.children = js.children.call(this, js);
+              }
+              if($.isArray(js.children) && js.children.length) {
+                tmp = this._parse_json(js.children, true);
+                if(tmp.length) {
+                  ul2 = $("<ul>");
+                  ul2.append(tmp);
+                  d.append(ul2);
+                }
+              }
+            }
+          }
+        }
+        if(!is_callback) {
+          ul1 = $("<ul>");
+          ul1.append(d);
+          d = ul1;
+        }
+        return d;
+      },
+      get_json : function (obj, li_attr, a_attr, is_callback) {
+        var result = [], 
+          s = this._get_settings(), 
+          _this = this,
+          tmp1, tmp2, li, a, t, lang;
+        obj = this._get_node(obj);
+        if(!obj || obj === -1) { obj = this.get_container().find("> ul > li"); }
+        li_attr = $.isArray(li_attr) ? li_attr : [ "id", "class" ];
+        if(!is_callback && this.data.types) { li_attr.push(s.types.type_attr); }
+        a_attr = $.isArray(a_attr) ? a_attr : [ ];
+
+        obj.each(function () {
+          li = $(this);
+          tmp1 = { data : [] };
+          if(li_attr.length) { tmp1.attr = { }; }
+          $.each(li_attr, function (i, v) { 
+            tmp2 = li.attr(v); 
+            if(tmp2 && tmp2.length && tmp2.replace(/jstree[^ ]*|$/ig,'').length) {
+              tmp1.attr[v] = tmp2.replace(/jstree[^ ]*|$/ig,''); 
+            }
+          });
+          if(li.hasClass("jstree-open")) { tmp1.state = "open"; }
+          if(li.hasClass("jstree-closed")) { tmp1.state = "closed"; }
+          a = li.children("a");
+          a.each(function () {
+            t = $(this);
+            if(
+              a_attr.length || 
+              $.inArray("languages", s.plugins) !== -1 || 
+              t.children("ins").get(0).style.backgroundImage.length || 
+              (t.children("ins").get(0).className && t.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').length)
+            ) { 
+              lang = false;
+              if($.inArray("languages", s.plugins) !== -1 && $.isArray(s.languages) && s.languages.length) {
+                $.each(s.languages, function (l, lv) {
+                  if(t.hasClass(lv)) {
+                    lang = lv;
+                    return false;
+                  }
+                });
+              }
+              tmp2 = { attr : { }, title : _this.get_text(t, lang) }; 
+              $.each(a_attr, function (k, z) {
+                tmp1.attr[z] = (t.attr(z) || "").replace(/jstree[^ ]*|$/ig,'');
+              });
+              $.each(s.languages, function (k, z) {
+                if(t.hasClass(z)) { tmp2.language = z; return true; }
+              });
+              if(t.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').replace(/^\s+$/ig,"").length) {
+                tmp2.icon = t.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').replace(/^\s+$/ig,"");
+              }
+              if(t.children("ins").get(0).style.backgroundImage.length) {
+                tmp2.icon = t.children("ins").get(0).style.backgroundImage.replace("url(","").replace(")","");
+              }
+            }
+            else {
+              tmp2 = _this.get_text(t);
+            }
+            if(a.length > 1) { tmp1.data.push(tmp2); }
+            else { tmp1.data = tmp2; }
+          });
+          li = li.find("> ul > li");
+          if(li.length) { tmp1.children = _this.get_json(li, li_attr, a_attr, true); }
+          result.push(tmp1);
+        });
+        return result;
+      }
+    }
+  });
 })(jQuery);
 //*/
 
@@ -1602,108 +1602,108 @@ THE SOFTWARE.
  * This is useful for maintaining the same structure in many languages (hence the name of the plugin)
  */
 (function ($) {
-	$.jstree.plugin("languages", {
-		__init : function () { this._load_css();  },
-		defaults : [],
-		_fn : {
-			set_lang : function (i) { 
-				var langs = this._get_settings().languages,
-					st = false,
-					selector = ".jstree-" + this.get_index() + ' a';
-				if(!$.isArray(langs) || langs.length === 0) { return false; }
-				if($.inArray(i,langs) == -1) {
-					if(!!langs[i]) { i = langs[i]; }
-					else { return false; }
-				}
-				if(i == this.data.languages.current_language) { return true; }
-				st = $.vakata.css.get_css(selector + "." + this.data.languages.current_language, false, this.data.languages.language_css);
-				if(st !== false) { st.style.display = "none"; }
-				st = $.vakata.css.get_css(selector + "." + i, false, this.data.languages.language_css);
-				if(st !== false) { st.style.display = ""; }
-				this.data.languages.current_language = i;
-				this.__callback(i);
-				return true;
-			},
-			get_lang : function () {
-				return this.data.languages.current_language;
-			},
-			get_text : function (obj, lang) {
-				obj = this._get_node(obj) || this.data.ui.last_selected;
-				if(!obj.size()) { return false; }
-				var langs = this._get_settings().languages,
-					s = this._get_settings().core.html_titles;
-				if($.isArray(langs) && langs.length) {
-					lang = (lang && $.inArray(lang,langs) != -1) ? lang : this.data.languages.current_language;
-					obj = obj.children("a." + lang);
-				}
-				else { obj = obj.children("a:eq(0)"); }
-				if(s) {
-					obj = obj.clone();
-					obj.children("INS").remove();
-					return obj.html();
-				}
-				else {
-					obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];
-					return obj.nodeValue;
-				}
-			},
-			set_text : function (obj, val, lang) {
-				obj = this._get_node(obj) || this.data.ui.last_selected;
-				if(!obj.size()) { return false; }
-				var langs = this._get_settings().languages,
-					s = this._get_settings().core.html_titles,
-					tmp;
-				if($.isArray(langs) && langs.length) {
-					lang = (lang && $.inArray(lang,langs) != -1) ? lang : this.data.languages.current_language;
-					obj = obj.children("a." + lang);
-				}
-				else { obj = obj.children("a:eq(0)"); }
-				if(s) {
-					tmp = obj.children("INS").clone();
-					obj.html(val).prepend(tmp);
-					this.__callback({ "obj" : obj, "name" : val, "lang" : lang });
-					return true;
-				}
-				else {
-					obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];
-					this.__callback({ "obj" : obj, "name" : val, "lang" : lang });
-					return (obj.nodeValue = val);
-				}
-			},
-			_load_css : function () {
-				var langs = this._get_settings().languages,
-					str = "/* languages css */",
-					selector = ".jstree-" + this.get_index() + ' a',
-					ln;
-				if($.isArray(langs) && langs.length) {
-					this.data.languages.current_language = langs[0];
-					for(ln = 0; ln < langs.length; ln++) {
-						str += selector + "." + langs[ln] + " {";
-						if(langs[ln] != this.data.languages.current_language) { str += " display:none; "; }
-						str += " } ";
-					}
-					this.data.languages.language_css = $.vakata.css.add_sheet({ 'str' : str });
-				}
-			},
-			create_node : function (obj, position, js, callback) {
-				var t = this.__call_old(true, obj, position, js, function (t) {
-					var langs = this._get_settings().languages,
-						a = t.children("a"),
-						ln;
-					if($.isArray(langs) && langs.length) {
-						for(ln = 0; ln < langs.length; ln++) {
-							if(!a.is("." + langs[ln])) {
-								t.append(a.eq(0).clone().removeClass(langs.join(" ")).addClass(langs[ln]));
-							}
-						}
-						a.not("." + langs.join(", .")).remove();
-					}
-					if(callback) { callback.call(this, t); }
-				});
-				return t;
-			}
-		}
-	});
+  $.jstree.plugin("languages", {
+    __init : function () { this._load_css();  },
+    defaults : [],
+    _fn : {
+      set_lang : function (i) { 
+        var langs = this._get_settings().languages,
+          st = false,
+          selector = ".jstree-" + this.get_index() + ' a';
+        if(!$.isArray(langs) || langs.length === 0) { return false; }
+        if($.inArray(i,langs) == -1) {
+          if(!!langs[i]) { i = langs[i]; }
+          else { return false; }
+        }
+        if(i == this.data.languages.current_language) { return true; }
+        st = $.vakata.css.get_css(selector + "." + this.data.languages.current_language, false, this.data.languages.language_css);
+        if(st !== false) { st.style.display = "none"; }
+        st = $.vakata.css.get_css(selector + "." + i, false, this.data.languages.language_css);
+        if(st !== false) { st.style.display = ""; }
+        this.data.languages.current_language = i;
+        this.__callback(i);
+        return true;
+      },
+      get_lang : function () {
+        return this.data.languages.current_language;
+      },
+      get_text : function (obj, lang) {
+        obj = this._get_node(obj) || this.data.ui.last_selected;
+        if(!obj.size()) { return false; }
+        var langs = this._get_settings().languages,
+          s = this._get_settings().core.html_titles;
+        if($.isArray(langs) && langs.length) {
+          lang = (lang && $.inArray(lang,langs) != -1) ? lang : this.data.languages.current_language;
+          obj = obj.children("a." + lang);
+        }
+        else { obj = obj.children("a:eq(0)"); }
+        if(s) {
+          obj = obj.clone();
+          obj.children("INS").remove();
+          return obj.html();
+        }
+        else {
+          obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];
+          return obj.nodeValue;
+        }
+      },
+      set_text : function (obj, val, lang) {
+        obj = this._get_node(obj) || this.data.ui.last_selected;
+        if(!obj.size()) { return false; }
+        var langs = this._get_settings().languages,
+          s = this._get_settings().core.html_titles,
+          tmp;
+        if($.isArray(langs) && langs.length) {
+          lang = (lang && $.inArray(lang,langs) != -1) ? lang : this.data.languages.current_language;
+          obj = obj.children("a." + lang);
+        }
+        else { obj = obj.children("a:eq(0)"); }
+        if(s) {
+          tmp = obj.children("INS").clone();
+          obj.html(val).prepend(tmp);
+          this.__callback({ "obj" : obj, "name" : val, "lang" : lang });
+          return true;
+        }
+        else {
+          obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];
+          this.__callback({ "obj" : obj, "name" : val, "lang" : lang });
+          return (obj.nodeValue = val);
+        }
+      },
+      _load_css : function () {
+        var langs = this._get_settings().languages,
+          str = "/* languages css */",
+          selector = ".jstree-" + this.get_index() + ' a',
+          ln;
+        if($.isArray(langs) && langs.length) {
+          this.data.languages.current_language = langs[0];
+          for(ln = 0; ln < langs.length; ln++) {
+            str += selector + "." + langs[ln] + " {";
+            if(langs[ln] != this.data.languages.current_language) { str += " display:none; "; }
+            str += " } ";
+          }
+          this.data.languages.language_css = $.vakata.css.add_sheet({ 'str' : str });
+        }
+      },
+      create_node : function (obj, position, js, callback) {
+        var t = this.__call_old(true, obj, position, js, function (t) {
+          var langs = this._get_settings().languages,
+            a = t.children("a"),
+            ln;
+          if($.isArray(langs) && langs.length) {
+            for(ln = 0; ln < langs.length; ln++) {
+              if(!a.is("." + langs[ln])) {
+                t.append(a.eq(0).clone().removeClass(langs.join(" ")).addClass(langs[ln]));
+              }
+            }
+            a.not("." + langs.join(", .")).remove();
+          }
+          if(callback) { callback.call(this, t); }
+        });
+        return t;
+      }
+    }
+  });
 })(jQuery);
 //*/
 
@@ -1713,70 +1713,70 @@ THE SOFTWARE.
  * Depends on the jquery.cookie plugin
  */
 (function ($) {
-	$.jstree.plugin("cookies", {
-		__init : function () {
-			if(typeof $.cookie === "undefined") { throw "jsTree cookie: jQuery cookie plugin not included."; }
-
-			var s = this._get_settings().cookies,
-				tmp;
-			if(!!s.save_opened) {
-				tmp = $.cookie(s.save_opened);
-				if(tmp && tmp.length) { this.data.core.to_open = tmp.split(","); }
-			}
-			if(!!s.save_selected) {
-				tmp = $.cookie(s.save_selected);
-				if(tmp && tmp.length && this.data.ui) { this.data.ui.to_select = tmp.split(","); }
-			}
-			this.get_container()
-				.one( ( this.data.ui ? "reselect" : "reopen" ) + ".jstree", $.proxy(function () {
-					this.get_container()
-						.bind("open_node.jstree close_node.jstree select_node.jstree deselect_node.jstree", $.proxy(function (e) { 
-								if(this._get_settings().cookies.auto_save) { this.save_cookie((e.handleObj.namespace + e.handleObj.type).replace("jstree","")); }
-							}, this));
-				}, this));
-		},
-		defaults : {
-			save_opened		: "jstree_open",
-			save_selected	: "jstree_select",
-			auto_save		: true,
-			cookie_options	: {}
-		},
-		_fn : {
-			save_cookie : function (c) {
-				if(this.data.core.refreshing) { return; }
-				var s = this._get_settings().cookies;
-				if(!c) { // if called manually and not by event
-					if(s.save_opened) {
-						this.save_opened();
-						$.cookie(s.save_opened, this.data.core.to_open.join(","), s.cookie_options);
-					}
-					if(s.save_selected && this.data.ui) {
-						this.save_selected();
-						$.cookie(s.save_selected, this.data.ui.to_select.join(","), s.cookie_options);
-					}
-					return;
-				}
-				switch(c) {
-					case "open_node":
-					case "close_node":
-						if(!!s.save_opened) { 
-							this.save_opened(); 
-							$.cookie(s.save_opened, this.data.core.to_open.join(","), s.cookie_options); 
-						}
-						break;
-					case "select_node":
-					case "deselect_node":
-						if(!!s.save_selected && this.data.ui) { 
-							this.save_selected(); 
-							$.cookie(s.save_selected, this.data.ui.to_select.join(","), s.cookie_options); 
-						}
-						break;
-				}
-			}
-		}
-	});
-	// include cookies by default
-	$.jstree.defaults.plugins.push("cookies");
+  $.jstree.plugin("cookies", {
+    __init : function () {
+      if(typeof $.cookie === "undefined") { throw "jsTree cookie: jQuery cookie plugin not included."; }
+
+      var s = this._get_settings().cookies,
+        tmp;
+      if(!!s.save_opened) {
+        tmp = $.cookie(s.save_opened);
+        if(tmp && tmp.length) { this.data.core.to_open = tmp.split(","); }
+      }
+      if(!!s.save_selected) {
+        tmp = $.cookie(s.save_selected);
+        if(tmp && tmp.length && this.data.ui) { this.data.ui.to_select = tmp.split(","); }
+      }
+      this.get_container()
+        .one( ( this.data.ui ? "reselect" : "reopen" ) + ".jstree", $.proxy(function () {
+          this.get_container()
+            .bind("open_node.jstree close_node.jstree select_node.jstree deselect_node.jstree", $.proxy(function (e) { 
+                if(this._get_settings().cookies.auto_save) { this.save_cookie((e.handleObj.namespace + e.handleObj.type).replace("jstree","")); }
+              }, this));
+        }, this));
+    },
+    defaults : {
+      save_opened    : "jstree_open",
+      save_selected  : "jstree_select",
+      auto_save    : true,
+      cookie_options  : {}
+    },
+    _fn : {
+      save_cookie : function (c) {
+        if(this.data.core.refreshing) { return; }
+        var s = this._get_settings().cookies;
+        if(!c) { // if called manually and not by event
+          if(s.save_opened) {
+            this.save_opened();
+            $.cookie(s.save_opened, this.data.core.to_open.join(","), s.cookie_options);
+          }
+          if(s.save_selected && this.data.ui) {
+            this.save_selected();
+            $.cookie(s.save_selected, this.data.ui.to_select.join(","), s.cookie_options);
+          }
+          return;
+        }
+        switch(c) {
+          case "open_node":
+          case "close_node":
+            if(!!s.save_opened) { 
+              this.save_opened(); 
+              $.cookie(s.save_opened, this.data.core.to_open.join(","), s.cookie_options); 
+            }
+            break;
+          case "select_node":
+          case "deselect_node":
+            if(!!s.save_selected && this.data.ui) { 
+              this.save_selected(); 
+              $.cookie(s.save_selected, this.data.ui.to_select.join(","), s.cookie_options); 
+            }
+            break;
+        }
+      }
+    }
+  });
+  // include cookies by default
+  $.jstree.defaults.plugins.push("cookies");
 })(jQuery);
 //*/
 
@@ -1785,33 +1785,33 @@ THE SOFTWARE.
  * Sorts items alphabetically (or using any other function)
  */
 (function ($) {
-	$.jstree.plugin("sort", {
-		__init : function () {
-			this.get_container()
-				.bind("load_node.jstree", $.proxy(function (e, data) {
-						var obj = this._get_node(data.rslt.obj);
-						obj = obj === -1 ? this.get_container().children("ul") : obj.children("ul");
-						this.sort(obj);
-					}, this))
-				.bind("rename_node.jstree", $.proxy(function (e, data) {
-						this.sort(data.rslt.obj.parent());
-					}, this))
-				.bind("move_node.jstree", $.proxy(function (e, data) {
-						var m = data.rslt.np == -1 ? this.get_container() : data.rslt.np;
-						this.sort(m.children("ul"));
-					}, this));
-		},
-		defaults : function (a, b) { return this.get_text(a) > this.get_text(b) ? 1 : -1; },
-		_fn : {
-			sort : function (obj) {
-				var s = this._get_settings().sort,
-					t = this;
-				obj.append($.makeArray(obj.children("li")).sort($.proxy(s, t)));
-				obj.find("> li > ul").each(function() { t.sort($(this)); });
-				this.clean_node(obj);
-			}
-		}
-	});
+  $.jstree.plugin("sort", {
+    __init : function () {
+      this.get_container()
+        .bind("load_node.jstree", $.proxy(function (e, data) {
+            var obj = this._get_node(data.rslt.obj);
+            obj = obj === -1 ? this.get_container().children("ul") : obj.children("ul");
+            this.sort(obj);
+          }, this))
+        .bind("rename_node.jstree", $.proxy(function (e, data) {
+            this.sort(data.rslt.obj.parent());
+          }, this))
+        .bind("move_node.jstree", $.proxy(function (e, data) {
+            var m = data.rslt.np == -1 ? this.get_container() : data.rslt.np;
+            this.sort(m.children("ul"));
+          }, this));
+    },
+    defaults : function (a, b) { return this.get_text(a) > this.get_text(b) ? 1 : -1; },
+    _fn : {
+      sort : function (obj) {
+        var s = this._get_settings().sort,
+          t = this;
+        obj.append($.makeArray(obj.children("li")).sort($.proxy(s, t)));
+        obj.find("> li > ul").each(function() { t.sort($(this)); });
+        this.clean_node(obj);
+      }
+    }
+  });
 })(jQuery);
 //*/
 
@@ -1820,425 +1820,425 @@ THE SOFTWARE.
  * Drag and drop plugin for moving/copying nodes
  */
 (function ($) {
-	var o = false,
-		r = false,
-		m = false,
-		sli = false,
-		sti = false,
-		dir1 = false,
-		dir2 = false;
-	$.vakata.dnd = {
-		is_down : false,
-		is_drag : false,
-		helper : false,
-		scroll_spd : 10,
-		init_x : 0,
-		init_y : 0,
-		threshold : 5,
-		user_data : {},
-
-		drag_start : function (e, data, html) { 
-			if($.vakata.dnd.is_drag) { $.vakata.drag_stop({}); }
-			try {
-				e.currentTarget.unselectable = "on";
-				e.currentTarget.onselectstart = function() { return false; };
-				if(e.currentTarget.style) { e.currentTarget.style.MozUserSelect = "none"; }
-			} catch(err) { }
-			$.vakata.dnd.init_x = e.pageX;
-			$.vakata.dnd.init_y = e.pageY;
-			$.vakata.dnd.user_data = data;
-			$.vakata.dnd.is_down = true;
-			$.vakata.dnd.helper = $("<div id='vakata-dragged'>").html(html).css("opacity", "0.75");
-			$(document).bind("mousemove", $.vakata.dnd.drag);
-			$(document).bind("mouseup", $.vakata.dnd.drag_stop);
-			return false;
-		},
-		drag : function (e) { 
-			if(!$.vakata.dnd.is_down) { return; }
-			if(!$.vakata.dnd.is_drag) {
-				if(Math.abs(e.pageX - $.vakata.dnd.init_x) > 5 || Math.abs(e.pageY - $.vakata.dnd.init_y) > 5) { 
-					$.vakata.dnd.helper.appendTo("body");
-					$.vakata.dnd.is_drag = true;
-					$(document).triggerHandler("drag_start.vakata", { "event" : e, "data" : $.vakata.dnd.user_data });
-				}
-				else { return; }
-			}
-
-			// maybe use a scrolling parent element instead of document?
-			if(e.type === "mousemove") { // thought of adding scroll in order to move the helper, but mouse poisition is n/a
-				var d = $(document), t = d.scrollTop(), l = d.scrollLeft();
-				if(e.pageY - t < 20) { 
-					if(sti && dir1 === "down") { clearInterval(sti); sti = false; }
-					if(!sti) { dir1 = "up"; sti = setInterval(function () { $(document).scrollTop($(document).scrollTop() - $.vakata.dnd.scroll_spd); }, 150); }
-				}
-				else { 
-					if(sti && dir1 === "up") { clearInterval(sti); sti = false; }
-				}
-				if($(window).height() - (e.pageY - t) < 20) {
-					if(sti && dir1 === "up") { clearInterval(sti); sti = false; }
-					if(!sti) { dir1 = "down"; sti = setInterval(function () { $(document).scrollTop($(document).scrollTop() + $.vakata.dnd.scroll_spd); }, 150); }
-				}
-				else { 
-					if(sti && dir1 === "down") { clearInterval(sti); sti = false; }
-				}
-
-				if(e.pageX - l < 20) {
-					if(sli && dir2 === "right") { clearInterval(sli); sli = false; }
-					if(!sli) { dir2 = "left"; sli = setInterval(function () { $(document).scrollLeft($(document).scrollLeft() - $.vakata.dnd.scroll_spd); }, 150); }
-				}
-				else { 
-					if(sli && dir2 === "left") { clearInterval(sli); sli = false; }
-				}
-				if($(window).width() - (e.pageX - l) < 20) {
-					if(sli && dir2 === "left") { clearInterval(sli); sli = false; }
-					if(!sli) { dir2 = "right"; sli = setInterval(function () { $(document).scrollLeft($(document).scrollLeft() + $.vakata.dnd.scroll_spd); }, 150); }
-				}
-				else { 
-					if(sli && dir2 === "right") { clearInterval(sli); sli = false; }
-				}
-			}
-
-			$.vakata.dnd.helper.css({ left : (e.pageX + 5) + "px", top : (e.pageY + 10) + "px" });
-			$(document).triggerHandler("drag.vakata", { "event" : e, "data" : $.vakata.dnd.user_data });
-		},
-		drag_stop : function (e) {
-			$(document).unbind("mousemove", $.vakata.dnd.drag);
-			$(document).unbind("mouseup", $.vakata.dnd.drag_stop);
-			$(document).triggerHandler("drag_stop.vakata", { "event" : e, "data" : $.vakata.dnd.user_data });
-			$.vakata.dnd.helper.remove();
-			$.vakata.dnd.init_x = 0;
-			$.vakata.dnd.init_y = 0;
-			$.vakata.dnd.user_data = {};
-			$.vakata.dnd.is_down = false;
-			$.vakata.dnd.is_drag = false;
-		}
-	};
-	$(function() {
-		var css_string = '#vakata-dragged { display:block; margin:0 0 0 0; padding:4px 4px 4px 24px; position:absolute; top:-2000px; line-height:16px; z-index:10000; } ';
-		$.vakata.css.add_sheet({ str : css_string });
-	});
-
-	$.jstree.plugin("dnd", {
-		__init : function () {
-			this.data.dnd = {
-				active : false,
-				after : false,
-				inside : false,
-				before : false,
-				off : false,
-				prepared : false,
-				w : 0,
-				to1 : false,
-				to2 : false,
-				cof : false,
-				cw : false,
-				ch : false,
-				i1 : false,
-				i2 : false
-			};
-			this.get_container()
-				.bind("mouseenter.jstree", $.proxy(function () {
-						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree && this.data.themes) {
-							m.attr("class", "jstree-" + this.data.themes.theme); 
-							$.vakata.dnd.helper.attr("class", "jstree-dnd-helper jstree-" + this.data.themes.theme);
-						}
-					}, this))
-				.bind("mouseleave.jstree", $.proxy(function () {
-						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
-							if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
-							if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
-						}
-					}, this))
-				.bind("mousemove.jstree", $.proxy(function (e) {
-						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
-							var cnt = this.get_container()[0];
-
-							// Horizontal scroll
-							if(e.pageX + 24 > this.data.dnd.cof.left + this.data.dnd.cw) {
-								if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
-								this.data.dnd.i1 = setInterval($.proxy(function () { this.scrollLeft += $.vakata.dnd.scroll_spd; }, cnt), 100);
-							}
-							else if(e.pageX - 24 < this.data.dnd.cof.left) {
-								if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
-								this.data.dnd.i1 = setInterval($.proxy(function () { this.scrollLeft -= $.vakata.dnd.scroll_spd; }, cnt), 100);
-							}
-							else {
-								if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
-							}
-
-							// Vertical scroll
-							if(e.pageY + 24 > this.data.dnd.cof.top + this.data.dnd.ch) {
-								if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
-								this.data.dnd.i2 = setInterval($.proxy(function () { this.scrollTop += $.vakata.dnd.scroll_spd; }, cnt), 100);
-							}
-							else if(e.pageY - 24 < this.data.dnd.cof.top) {
-								if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
-								this.data.dnd.i2 = setInterval($.proxy(function () { this.scrollTop -= $.vakata.dnd.scroll_spd; }, cnt), 100);
-							}
-							else {
-								if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
-							}
-
-						}
-					}, this))
-				.delegate("a", "mousedown.jstree", $.proxy(function (e) { 
-						if(e.which === 1) {
-							this.start_drag(e.currentTarget, e);
-							return false;
-						}
-					}, this))
-				.delegate("a", "mouseenter.jstree", $.proxy(function (e) { 
-						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
-							this.dnd_enter(e.currentTarget);
-						}
-					}, this))
-				.delegate("a", "mousemove.jstree", $.proxy(function (e) { 
-						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
-							if(typeof this.data.dnd.off.top === "undefined") { this.data.dnd.off = $(e.target).offset(); }
-							this.data.dnd.w = (e.pageY - (this.data.dnd.off.top || 0)) % this.data.core.li_height;
-							if(this.data.dnd.w < 0) { this.data.dnd.w += this.data.core.li_height; }
-							this.dnd_show();
-						}
-					}, this))
-				.delegate("a", "mouseleave.jstree", $.proxy(function (e) { 
-						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
-							this.data.dnd.after		= false;
-							this.data.dnd.before	= false;
-							this.data.dnd.inside	= false;
-							$.vakata.dnd.helper.children("ins").attr("class","jstree-invalid");
-							m.hide();
-							if(r && r[0] === e.target.parentNode) {
-								if(this.data.dnd.to1) {
-									clearTimeout(this.data.dnd.to1);
-									this.data.dnd.to1 = false;
-								}
-								if(this.data.dnd.to2) {
-									clearTimeout(this.data.dnd.to2);
-									this.data.dnd.to2 = false;
-								}
-							}
-						}
-					}, this))
-				.delegate("a", "mouseup.jstree", $.proxy(function (e) { 
-						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
-							this.dnd_finish(e);
-						}
-					}, this));
-
-			$(document)
-				.bind("drag_stop.vakata", $.proxy(function () {
-						this.data.dnd.after		= false;
-						this.data.dnd.before	= false;
-						this.data.dnd.inside	= false;
-						this.data.dnd.off		= false;
-						this.data.dnd.prepared	= false;
-						this.data.dnd.w			= false;
-						this.data.dnd.to1		= false;
-						this.data.dnd.to2		= false;
-						this.data.dnd.active	= false;
-						this.data.dnd.foreign	= false;
-						if(m) { m.css({ "top" : "-2000px" }); }
-					}, this))
-				.bind("drag_start.vakata", $.proxy(function (e, data) {
-						if(data.data.jstree) { 
-							var et = $(data.event.target);
-							if(et.closest(".jstree").hasClass("jstree-" + this.get_index())) {
-								this.dnd_enter(et);
-							}
-						}
-					}, this));
-
-			var s = this._get_settings().dnd;
-			if(s.drag_target) {
-				$(document)
-					.delegate(s.drag_target, "mousedown.jstree", $.proxy(function (e) {
-						o = e.target;
-						$.vakata.dnd.drag_start(e, { jstree : true, obj : e.target }, "<ins class='jstree-icon'></ins>" + $(e.target).text() );
-						if(this.data.themes) { 
-							m.attr("class", "jstree-" + this.data.themes.theme); 
-							$.vakata.dnd.helper.attr("class", "jstree-dnd-helper jstree-" + this.data.themes.theme); 
-						}
-						$.vakata.dnd.helper.children("ins").attr("class","jstree-invalid");
-						var cnt = this.get_container();
-						this.data.dnd.cof = cnt.offset();
-						this.data.dnd.cw = parseInt(cnt.width(),10);
-						this.data.dnd.ch = parseInt(cnt.height(),10);
-						this.data.dnd.foreign = true;
-						return false;
-					}, this));
-			}
-			if(s.drop_target) {
-				$(document)
-					.delegate(s.drop_target, "mouseenter.jstree", $.proxy(function (e) {
-							if(this.data.dnd.active && this._get_settings().dnd.drop_check.call(this, { "o" : o, "r" : $(e.target) })) {
-								$.vakata.dnd.helper.children("ins").attr("class","jstree-ok");
-							}
-						}, this))
-					.delegate(s.drop_target, "mouseleave.jstree", $.proxy(function (e) {
-							if(this.data.dnd.active) {
-								$.vakata.dnd.helper.children("ins").attr("class","jstree-invalid");
-							}
-						}, this))
-					.delegate(s.drop_target, "mouseup.jstree", $.proxy(function (e) {
-							if(this.data.dnd.active && $.vakata.dnd.helper.children("ins").hasClass("jstree-ok")) {
-								this._get_settings().dnd.drop_finish.call(this, { "o" : o, "r" : $(e.target) });
-							}
-						}, this));
-			}
-		},
-		defaults : {
-			copy_modifier	: "ctrl",
-			check_timeout	: 200,
-			open_timeout	: 500,
-			drop_target		: ".jstree-drop",
-			drop_check		: function (data) { return true; },
-			drop_finish		: $.noop,
-			drag_target		: ".jstree-draggable",
-			drag_finish		: $.noop,
-			drag_check		: function (data) { return { after : false, before : false, inside : true }; }
-		},
-		_fn : {
-			dnd_prepare : function () {
-				if(!r || !r.length) { return; }
-				this.data.dnd.off = r.offset();
-				if(this._get_settings().core.rtl) {
-					this.data.dnd.off.right = this.data.dnd.off.left + r.width();
-				}
-				if(this.data.dnd.foreign) {
-					var a = this._get_settings().dnd.drag_check.call(this, { "o" : o, "r" : r });
-					this.data.dnd.after = a.after;
-					this.data.dnd.before = a.before;
-					this.data.dnd.inside = a.inside;
-					this.data.dnd.prepared = true;
-					return this.dnd_show();
-				}
-				this.prepare_move(o, r, "before");
-				this.data.dnd.before = this.check_move();
-				this.prepare_move(o, r, "after");
-				this.data.dnd.after = this.check_move();
-				if(this._is_loaded(r)) {
-					this.prepare_move(o, r, "inside");
-					this.data.dnd.inside = this.check_move();
-				}
-				else {
-					this.data.dnd.inside = false;
-				}
-				this.data.dnd.prepared = true;
-				return this.dnd_show();
-			},
-			dnd_show : function () {
-				if(!this.data.dnd.prepared) { return; }
-				var o = ["before","inside","after"],
-					r = false,
-					rtl = this._get_settings().core.rtl,
-					pos;
-				if(this.data.dnd.w < this.data.core.li_height/3) { o = ["before","inside","after"]; }
-				else if(this.data.dnd.w <= this.data.core.li_height*2/3) {
-					o = this.data.dnd.w < this.data.core.li_height/2 ? ["inside","before","after"] : ["inside","after","before"];
-				}
-				else { o = ["after","inside","before"]; }
-				$.each(o, $.proxy(function (i, val) { 
-					if(this.data.dnd[val]) {
-						$.vakata.dnd.helper.children("ins").attr("class","jstree-ok");
-						r = val;
-						return false;
-					}
-				}, this));
-				if(r === false) { $.vakata.dnd.helper.children("ins").attr("class","jstree-invalid"); }
-				
-				pos = rtl ? (this.data.dnd.off.right - 18) : (this.data.dnd.off.left + 10);
-				switch(r) {
-					case "before":
-						m.css({ "left" : pos + "px", "top" : (this.data.dnd.off.top - 6) + "px" }).show();
-						break;
-					case "after":
-						m.css({ "left" : pos + "px", "top" : (this.data.dnd.off.top + this.data.core.li_height - 7) + "px" }).show();
-						break;
-					case "inside":
-						m.css({ "left" : pos + ( rtl ? -4 : 4) + "px", "top" : (this.data.dnd.off.top + this.data.core.li_height/2 - 5) + "px" }).show();
-						break;
-					default:
-						m.hide();
-						break;
-				}
-				return r;
-			},
-			dnd_open : function () {
-				this.data.dnd.to2 = false;
-				this.open_node(r, $.proxy(this.dnd_prepare,this), true);
-			},
-			dnd_finish : function (e) {
-				if(this.data.dnd.foreign) {
-					if(this.data.dnd.after || this.data.dnd.before || this.data.dnd.inside) {
-						this._get_settings().dnd.drag_finish.call(this, { "o" : o, "r" : r });
-					}
-				}
-				else {
-					this.dnd_prepare();
-					this.move_node(o, r, this.dnd_show(), e[this._get_settings().dnd.copy_modifier + "Key"]);
-				}
-				o = false;
-				r = false;
-				m.hide();
-			},
-			dnd_enter : function (obj) {
-				var s = this._get_settings().dnd;
-				this.data.dnd.prepared = false;
-				r = this._get_node(obj);
-				if(s.check_timeout) { 
-					// do the calculations after a minimal timeout (users tend to drag quickly to the desired location)
-					if(this.data.dnd.to1) { clearTimeout(this.data.dnd.to1); }
-					this.data.dnd.to1 = setTimeout($.proxy(this.dnd_prepare, this), s.check_timeout); 
-				}
-				else { 
-					this.dnd_prepare(); 
-				}
-				if(s.open_timeout) { 
-					if(this.data.dnd.to2) { clearTimeout(this.data.dnd.to2); }
-					if(r && r.length && r.hasClass("jstree-closed")) { 
-						// if the node is closed - open it, then recalculate
-						this.data.dnd.to2 = setTimeout($.proxy(this.dnd_open, this), s.open_timeout);
-					}
-				}
-				else {
-					if(r && r.length && r.hasClass("jstree-closed")) { 
-						this.dnd_open();
-					}
-				}
-			},
-			start_drag : function (obj, e) {
-				o = this._get_node(obj);
-				if(this.data.ui && this.is_selected(o)) { o = this._get_node(null, true); }
-				$.vakata.dnd.drag_start(e, { jstree : true, obj : o }, "<ins class='jstree-icon'></ins>" + (o.length > 1 ? "Multiple selection" : this.get_text(o)) );
-				if(this.data.themes) { 
-					m.attr("class", "jstree-" + this.data.themes.theme); 
-					$.vakata.dnd.helper.attr("class", "jstree-dnd-helper jstree-" + this.data.themes.theme); 
-				}
-				var cnt = this.get_container();
-				this.data.dnd.cof = cnt.children("ul").offset();
-				this.data.dnd.cw = parseInt(cnt.width(),10);
-				this.data.dnd.ch = parseInt(cnt.height(),10);
-				this.data.dnd.active = true;
-			}
-		}
-	});
-	$(function() {
-		var css_string = '' + 
-			'#vakata-dragged ins { display:block; text-decoration:none; width:16px; height:16px; margin:0 0 0 0; padding:0; position:absolute; top:4px; left:4px; } ' + 
-			'#vakata-dragged .jstree-ok { background:green; } ' + 
-			'#vakata-dragged .jstree-invalid { background:red; } ' + 
-			'#jstree-marker { padding:0; margin:0; line-height:12px; font-size:1px; overflow:hidden; height:12px; width:8px; position:absolute; top:-30px; z-index:10000; background-repeat:no-repeat; display:none; background-color:silver; } ';
-		$.vakata.css.add_sheet({ str : css_string });
-		m = $("<div>").attr({ id : "jstree-marker" }).hide().appendTo("body");
-		$(document).bind("drag_start.vakata", function (e, data) {
-			if(data.data.jstree) { 
-				m.show(); 
-			}
-		});
-		$(document).bind("drag_stop.vakata", function (e, data) {
-			if(data.data.jstree) { m.hide(); }
-		});
-	});
+  var o = false,
+    r = false,
+    m = false,
+    sli = false,
+    sti = false,
+    dir1 = false,
+    dir2 = false;
+  $.vakata.dnd = {
+    is_down : false,
+    is_drag : false,
+    helper : false,
+    scroll_spd : 10,
+    init_x : 0,
+    init_y : 0,
+    threshold : 5,
+    user_data : {},
+
+    drag_start : function (e, data, html) { 
+      if($.vakata.dnd.is_drag) { $.vakata.drag_stop({}); }
+      try {
+        e.currentTarget.unselectable = "on";
+        e.currentTarget.onselectstart = function() { return false; };
+        if(e.currentTarget.style) { e.currentTarget.style.MozUserSelect = "none"; }
+      } catch(err) { }
+      $.vakata.dnd.init_x = e.pageX;
+      $.vakata.dnd.init_y = e.pageY;
+      $.vakata.dnd.user_data = data;
+      $.vakata.dnd.is_down = true;
+      $.vakata.dnd.helper = $("<div id='vakata-dragged'>").html(html).css("opacity", "0.75");
+      $(document).bind("mousemove", $.vakata.dnd.drag);
+      $(document).bind("mouseup", $.vakata.dnd.drag_stop);
+      return false;
+    },
+    drag : function (e) { 
+      if(!$.vakata.dnd.is_down) { return; }
+      if(!$.vakata.dnd.is_drag) {
+        if(Math.abs(e.pageX - $.vakata.dnd.init_x) > 5 || Math.abs(e.pageY - $.vakata.dnd.init_y) > 5) { 
+          $.vakata.dnd.helper.appendTo("body");
+          $.vakata.dnd.is_drag = true;
+          $(document).triggerHandler("drag_start.vakata", { "event" : e, "data" : $.vakata.dnd.user_data });
+        }
+        else { return; }
+      }
+
+      // maybe use a scrolling parent element instead of document?
+      if(e.type === "mousemove") { // thought of adding scroll in order to move the helper, but mouse poisition is n/a
+        var d = $(document), t = d.scrollTop(), l = d.scrollLeft();
+        if(e.pageY - t < 20) { 
+          if(sti && dir1 === "down") { clearInterval(sti); sti = false; }
+          if(!sti) { dir1 = "up"; sti = setInterval(function () { $(document).scrollTop($(document).scrollTop() - $.vakata.dnd.scroll_spd); }, 150); }
+        }
+        else { 
+          if(sti && dir1 === "up") { clearInterval(sti); sti = false; }
+        }
+        if($(window).height() - (e.pageY - t) < 20) {
+          if(sti && dir1 === "up") { clearInterval(sti); sti = false; }
+          if(!sti) { dir1 = "down"; sti = setInterval(function () { $(document).scrollTop($(document).scrollTop() + $.vakata.dnd.scroll_spd); }, 150); }
+        }
+        else { 
+          if(sti && dir1 === "down") { clearInterval(sti); sti = false; }
+        }
+
+        if(e.pageX - l < 20) {
+          if(sli && dir2 === "right") { clearInterval(sli); sli = false; }
+          if(!sli) { dir2 = "left"; sli = setInterval(function () { $(document).scrollLeft($(document).scrollLeft() - $.vakata.dnd.scroll_spd); }, 150); }
+        }
+        else { 
+          if(sli && dir2 === "left") { clearInterval(sli); sli = false; }
+        }
+        if($(window).width() - (e.pageX - l) < 20) {
+          if(sli && dir2 === "left") { clearInterval(sli); sli = false; }
+          if(!sli) { dir2 = "right"; sli = setInterval(function () { $(document).scrollLeft($(document).scrollLeft() + $.vakata.dnd.scroll_spd); }, 150); }
+        }
+        else { 
+          if(sli && dir2 === "right") { clearInterval(sli); sli = false; }
+        }
+      }
+
+      $.vakata.dnd.helper.css({ left : (e.pageX + 5) + "px", top : (e.pageY + 10) + "px" });
+      $(document).triggerHandler("drag.vakata", { "event" : e, "data" : $.vakata.dnd.user_data });
+    },
+    drag_stop : function (e) {
+      $(document).unbind("mousemove", $.vakata.dnd.drag);
+      $(document).unbind("mouseup", $.vakata.dnd.drag_stop);
+      $(document).triggerHandler("drag_stop.vakata", { "event" : e, "data" : $.vakata.dnd.user_data });
+      $.vakata.dnd.helper.remove();
+      $.vakata.dnd.init_x = 0;
+      $.vakata.dnd.init_y = 0;
+      $.vakata.dnd.user_data = {};
+      $.vakata.dnd.is_down = false;
+      $.vakata.dnd.is_drag = false;
+    }
+  };
+  $(function() {
+    var css_string = '#vakata-dragged { display:block; margin:0 0 0 0; padding:4px 4px 4px 24px; position:absolute; top:-2000px; line-height:16px; z-index:10000; } ';
+    $.vakata.css.add_sheet({ str : css_string });
+  });
+
+  $.jstree.plugin("dnd", {
+    __init : function () {
+      this.data.dnd = {
+        active : false,
+        after : false,
+        inside : false,
+        before : false,
+        off : false,
+        prepared : false,
+        w : 0,
+        to1 : false,
+        to2 : false,
+        cof : false,
+        cw : false,
+        ch : false,
+        i1 : false,
+        i2 : false
+      };
+      this.get_container()
+        .bind("mouseenter.jstree", $.proxy(function () {
+            if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree && this.data.themes) {
+              m.attr("class", "jstree-" + this.data.themes.theme); 
+              $.vakata.dnd.helper.attr("class", "jstree-dnd-helper jstree-" + this.data.themes.theme);
+            }
+          }, this))
+        .bind("mouseleave.jstree", $.proxy(function () {
+            if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
+              if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
+              if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
+            }
+          }, this))
+        .bind("mousemove.jstree", $.proxy(function (e) {
+            if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
+              var cnt = this.get_container()[0];
+
+              // Horizontal scroll
+              if(e.pageX + 24 > this.data.dnd.cof.left + this.data.dnd.cw) {
+                if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
+                this.data.dnd.i1 = setInterval($.proxy(function () { this.scrollLeft += $.vakata.dnd.scroll_spd; }, cnt), 100);
+              }
+              else if(e.pageX - 24 < this.data.dnd.cof.left) {
+                if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
+                this.data.dnd.i1 = setInterval($.proxy(function () { this.scrollLeft -= $.vakata.dnd.scroll_spd; }, cnt), 100);
+              }
+              else {
+                if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
+              }
+
+              // Vertical scroll
+              if(e.pageY + 24 > this.data.dnd.cof.top + this.data.dnd.ch) {
+                if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
+                this.data.dnd.i2 = setInterval($.proxy(function () { this.scrollTop += $.vakata.dnd.scroll_spd; }, cnt), 100);
+              }
+              else if(e.pageY - 24 < this.data.dnd.cof.top) {
+                if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
+                this.data.dnd.i2 = setInterval($.proxy(function () { this.scrollTop -= $.vakata.dnd.scroll_spd; }, cnt), 100);
+              }
+              else {
+                if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
+              }
+
+            }
+          }, this))
+        .delegate("a", "mousedown.jstree", $.proxy(function (e) { 
+            if(e.which === 1) {
+              this.start_drag(e.currentTarget, e);
+              return false;
+            }
+          }, this))
+        .delegate("a", "mouseenter.jstree", $.proxy(function (e) { 
+            if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
+              this.dnd_enter(e.currentTarget);
+            }
+          }, this))
+        .delegate("a", "mousemove.jstree", $.proxy(function (e) { 
+            if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
+              if(typeof this.data.dnd.off.top === "undefined") { this.data.dnd.off = $(e.target).offset(); }
+              this.data.dnd.w = (e.pageY - (this.data.dnd.off.top || 0)) % this.data.core.li_height;
+              if(this.data.dnd.w < 0) { this.data.dnd.w += this.data.core.li_height; }
+              this.dnd_show();
+            }
+          }, this))
+        .delegate("a", "mouseleave.jstree", $.proxy(function (e) { 
+            if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
+              this.data.dnd.after    = false;
+              this.data.dnd.before  = false;
+              this.data.dnd.inside  = false;
+              $.vakata.dnd.helper.children("ins").attr("class","jstree-invalid");
+              m.hide();
+              if(r && r[0] === e.target.parentNode) {
+                if(this.data.dnd.to1) {
+                  clearTimeout(this.data.dnd.to1);
+                  this.data.dnd.to1 = false;
+                }
+                if(this.data.dnd.to2) {
+                  clearTimeout(this.data.dnd.to2);
+                  this.data.dnd.to2 = false;
+                }
+              }
+            }
+          }, this))
+        .delegate("a", "mouseup.jstree", $.proxy(function (e) { 
+            if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
+              this.dnd_finish(e);
+            }
+          }, this));
+
+      $(document)
+        .bind("drag_stop.vakata", $.proxy(function () {
+            this.data.dnd.after    = false;
+            this.data.dnd.before  = false;
+            this.data.dnd.inside  = false;
+            this.data.dnd.off    = false;
+            this.data.dnd.prepared  = false;
+            this.data.dnd.w      = false;
+            this.data.dnd.to1    = false;
+            this.data.dnd.to2    = false;
+            this.data.dnd.active  = false;
+            this.data.dnd.foreign  = false;
+            if(m) { m.css({ "top" : "-2000px" }); }
+          }, this))
+        .bind("drag_start.vakata", $.proxy(function (e, data) {
+            if(data.data.jstree) { 
+              var et = $(data.event.target);
+              if(et.closest(".jstree").hasClass("jstree-" + this.get_index())) {
+                this.dnd_enter(et);
+              }
+            }
+          }, this));
+
+      var s = this._get_settings().dnd;
+      if(s.drag_target) {
+        $(document)
+          .delegate(s.drag_target, "mousedown.jstree", $.proxy(function (e) {
+            o = e.target;
+            $.vakata.dnd.drag_start(e, { jstree : true, obj : e.target }, "<ins class='jstree-icon'></ins>" + $(e.target).text() );
+            if(this.data.themes) { 
+              m.attr("class", "jstree-" + this.data.themes.theme); 
+              $.vakata.dnd.helper.attr("class", "jstree-dnd-helper jstree-" + this.data.themes.theme); 
+            }
+            $.vakata.dnd.helper.children("ins").attr("class","jstree-invalid");
+            var cnt = this.get_container();
+            this.data.dnd.cof = cnt.offset();
+            this.data.dnd.cw = parseInt(cnt.width(),10);
+            this.data.dnd.ch = parseInt(cnt.height(),10);
+            this.data.dnd.foreign = true;
+            return false;
+          }, this));
+      }
+      if(s.drop_target) {
+        $(document)
+          .delegate(s.drop_target, "mouseenter.jstree", $.proxy(function (e) {
+              if(this.data.dnd.active && this._get_settings().dnd.drop_check.call(this, { "o" : o, "r" : $(e.target) })) {
+                $.vakata.dnd.helper.children("ins").attr("class","jstree-ok");
+              }
+            }, this))
+          .delegate(s.drop_target, "mouseleave.jstree", $.proxy(function (e) {
+              if(this.data.dnd.active) {
+                $.vakata.dnd.helper.children("ins").attr("class","jstree-invalid");
+              }
+            }, this))
+          .delegate(s.drop_target, "mouseup.jstree", $.proxy(function (e) {
+              if(this.data.dnd.active && $.vakata.dnd.helper.children("ins").hasClass("jstree-ok")) {
+                this._get_settings().dnd.drop_finish.call(this, { "o" : o, "r" : $(e.target) });
+              }
+            }, this));
+      }
+    },
+    defaults : {
+      copy_modifier  : "ctrl",
+      check_timeout  : 200,
+      open_timeout  : 500,
+      drop_target    : ".jstree-drop",
+      drop_check    : function (data) { return true; },
+      drop_finish    : $.noop,
+      drag_target    : ".jstree-draggable",
+      drag_finish    : $.noop,
+      drag_check    : function (data) { return { after : false, before : false, inside : true }; }
+    },
+    _fn : {
+      dnd_prepare : function () {
+        if(!r || !r.length) { return; }
+        this.data.dnd.off = r.offset();
+        if(this._get_settings().core.rtl) {
+          this.data.dnd.off.right = this.data.dnd.off.left + r.width();
+        }
+        if(this.data.dnd.foreign) {
+          var a = this._get_settings().dnd.drag_check.call(this, { "o" : o, "r" : r });
+          this.data.dnd.after = a.after;
+          this.data.dnd.before = a.before;
+          this.data.dnd.inside = a.inside;
+          this.data.dnd.prepared = true;
+          return this.dnd_show();
+        }
+        this.prepare_move(o, r, "before");
+        this.data.dnd.before = this.check_move();
+        this.prepare_move(o, r, "after");
+        this.data.dnd.after = this.check_move();
+        if(this._is_loaded(r)) {
+          this.prepare_move(o, r, "inside");
+          this.data.dnd.inside = this.check_move();
+        }
+        else {
+          this.data.dnd.inside = false;
+        }
+        this.data.dnd.prepared = true;
+        return this.dnd_show();
+      },
+      dnd_show : function () {
+        if(!this.data.dnd.prepared) { return; }
+        var o = ["before","inside","after"],
+          r = false,
+          rtl = this._get_settings().core.rtl,
+          pos;
+        if(this.data.dnd.w < this.data.core.li_height/3) { o = ["before","inside","after"]; }
+        else if(this.data.dnd.w <= this.data.core.li_height*2/3) {
+          o = this.data.dnd.w < this.data.core.li_height/2 ? ["inside","before","after"] : ["inside","after","before"];
+        }
+        else { o = ["after","inside","before"]; }
+        $.each(o, $.proxy(function (i, val) { 
+          if(this.data.dnd[val]) {
+            $.vakata.dnd.helper.children("ins").attr("class","jstree-ok");
+            r = val;
+            return false;
+          }
+        }, this));
+        if(r === false) { $.vakata.dnd.helper.children("ins").attr("class","jstree-invalid"); }
+        
+        pos = rtl ? (this.data.dnd.off.right - 18) : (this.data.dnd.off.left + 10);
+        switch(r) {
+          case "before":
+            m.css({ "left" : pos + "px", "top" : (this.data.dnd.off.top - 6) + "px" }).show();
+            break;
+          case "after":
+            m.css({ "left" : pos + "px", "top" : (this.data.dnd.off.top + this.data.core.li_height - 7) + "px" }).show();
+            break;
+          case "inside":
+            m.css({ "left" : pos + ( rtl ? -4 : 4) + "px", "top" : (this.data.dnd.off.top + this.data.core.li_height/2 - 5) + "px" }).show();
+            break;
+          default:
+            m.hide();
+            break;
+        }
+        return r;
+      },
+      dnd_open : function () {
+        this.data.dnd.to2 = false;
+        this.open_node(r, $.proxy(this.dnd_prepare,this), true);
+      },
+      dnd_finish : function (e) {
+        if(this.data.dnd.foreign) {
+          if(this.data.dnd.after || this.data.dnd.before || this.data.dnd.inside) {
+            this._get_settings().dnd.drag_finish.call(this, { "o" : o, "r" : r });
+          }
+        }
+        else {
+          this.dnd_prepare();
+          this.move_node(o, r, this.dnd_show(), e[this._get_settings().dnd.copy_modifier + "Key"]);
+        }
+        o = false;
+        r = false;
+        m.hide();
+      },
+      dnd_enter : function (obj) {
+        var s = this._get_settings().dnd;
+        this.data.dnd.prepared = false;
+        r = this._get_node(obj);
+        if(s.check_timeout) { 
+          // do the calculations after a minimal timeout (users tend to drag quickly to the desired location)
+          if(this.data.dnd.to1) { clearTimeout(this.data.dnd.to1); }
+          this.data.dnd.to1 = setTimeout($.proxy(this.dnd_prepare, this), s.check_timeout); 
+        }
+        else { 
+          this.dnd_prepare(); 
+        }
+        if(s.open_timeout) { 
+          if(this.data.dnd.to2) { clearTimeout(this.data.dnd.to2); }
+          if(r && r.length && r.hasClass("jstree-closed")) { 
+            // if the node is closed - open it, then recalculate
+            this.data.dnd.to2 = setTimeout($.proxy(this.dnd_open, this), s.open_timeout);
+          }
+        }
+        else {
+          if(r && r.length && r.hasClass("jstree-closed")) { 
+            this.dnd_open();
+          }
+        }
+      },
+      start_drag : function (obj, e) {
+        o = this._get_node(obj);
+        if(this.data.ui && this.is_selected(o)) { o = this._get_node(null, true); }
+        $.vakata.dnd.drag_start(e, { jstree : true, obj : o }, "<ins class='jstree-icon'></ins>" + (o.length > 1 ? "Multiple selection" : this.get_text(o)) );
+        if(this.data.themes) { 
+          m.attr("class", "jstree-" + this.data.themes.theme); 
+          $.vakata.dnd.helper.attr("class", "jstree-dnd-helper jstree-" + this.data.themes.theme); 
+        }
+        var cnt = this.get_container();
+        this.data.dnd.cof = cnt.children("ul").offset();
+        this.data.dnd.cw = parseInt(cnt.width(),10);
+        this.data.dnd.ch = parseInt(cnt.height(),10);
+        this.data.dnd.active = true;
+      }
+    }
+  });
+  $(function() {
+    var css_string = '' + 
+      '#vakata-dragged ins { display:block; text-decoration:none; width:16px; height:16px; margin:0 0 0 0; padding:0; position:absolute; top:4px; left:4px; } ' + 
+      '#vakata-dragged .jstree-ok { background:green; } ' + 
+      '#vakata-dragged .jstree-invalid { background:red; } ' + 
+      '#jstree-marker { padding:0; margin:0; line-height:12px; font-size:1px; overflow:hidden; height:12px; width:8px; position:absolute; top:-30px; z-index:10000; background-repeat:no-repeat; display:none; background-color:silver; } ';
+    $.vakata.css.add_sheet({ str : css_string });
+    m = $("<div>").attr({ id : "jstree-marker" }).hide().appendTo("body");
+    $(document).bind("drag_start.vakata", function (e, data) {
+      if(data.data.jstree) { 
+        m.show(); 
+      }
+    });
+    $(document).bind("drag_stop.vakata", function (e, data) {
+      if(data.data.jstree) { m.hide(); }
+    });
+  });
 })(jQuery);
 //*/
 
@@ -2249,135 +2249,135 @@ THE SOFTWARE.
  * DOES NOT WORK NICELY WITH MULTITREE DRAG'N'DROP
  */
 (function ($) {
-	$.jstree.plugin("checkbox", {
-		__init : function () {
-			this.select_node = this.deselect_node = this.deselect_all = $.noop;
-			this.get_selected = this.get_checked;
-
-			this.get_container()
-				.bind("open_node.jstree create_node.jstree clean_node.jstree", $.proxy(function (e, data) { 
-						this._prepare_checkboxes(data.rslt.obj);
-					}, this))
-				.bind("loaded.jstree", $.proxy(function (e) {
-						this._prepare_checkboxes();
-					}, this))
-				.delegate("a", "click.jstree", $.proxy(function (e) {
-						if(this._get_node(e.target).hasClass("jstree-checked")) { this.uncheck_node(e.target); }
-						else { this.check_node(e.target); }
-						if(this.data.ui) { this.save_selected(); }
-						if(this.data.cookies) { this.save_cookie("select_node"); }
-						e.preventDefault();
-					}, this));
-		},
-		__destroy : function () {
-			this.get_container().find(".jstree-checkbox").remove();
-		},
-		_fn : {
-			_prepare_checkboxes : function (obj) {
-				obj = !obj || obj == -1 ? this.get_container() : this._get_node(obj);
-				var c, _this = this, t;
-				obj.each(function () {
-					t = $(this);
-					c = t.is("li") && t.hasClass("jstree-checked") ? "jstree-checked" : "jstree-unchecked";
-					t.find("a").not(":has(.jstree-checkbox)").prepend("<ins class='jstree-checkbox'>&#160;</ins>").parent().not(".jstree-checked, .jstree-unchecked").addClass(c);
-				});
-				if(obj.is("li")) { this._repair_state(obj); }
-				else { obj.find("> ul > li").each(function () { _this._repair_state(this); }); }
-			},
-			change_state : function (obj, state) {
-				obj = this._get_node(obj);
-				state = (state === false || state === true) ? state : obj.hasClass("jstree-checked");
-				if(state) { obj.find("li").andSelf().removeClass("jstree-checked jstree-undetermined").addClass("jstree-unchecked"); }
-				else { 
-					obj.find("li").andSelf().removeClass("jstree-unchecked jstree-undetermined").addClass("jstree-checked"); 
-					if(this.data.ui) { this.data.ui.last_selected = obj; }
-					this.data.checkbox.last_selected = obj;
-				}
-				obj.parentsUntil(".jstree", "li").each(function () {
-					var $this = $(this);
-					if(state) {
-						if($this.children("ul").children(".jstree-checked, .jstree-undetermined").length) {
-							$this.parentsUntil(".jstree", "li").andSelf().removeClass("jstree-checked jstree-unchecked").addClass("jstree-undetermined");
-							return false;
-						}
-						else {
-							$this.removeClass("jstree-checked jstree-undetermined").addClass("jstree-unchecked");
-						}
-					}
-					else {
-						if($this.children("ul").children(".jstree-unchecked, .jstree-undetermined").length) {
-							$this.parentsUntil(".jstree", "li").andSelf().removeClass("jstree-checked jstree-unchecked").addClass("jstree-undetermined");
-							return false;
-						}
-						else {
-							$this.removeClass("jstree-unchecked jstree-undetermined").addClass("jstree-checked");
-						}
-					}
-				});
-				if(this.data.ui) { this.data.ui.selected = this.get_checked(); }
-				this.__callback(obj);
-			},
-			check_node : function (obj) {
-				this.change_state(obj, false);
-			},
-			uncheck_node : function (obj) {
-				this.change_state(obj, true);
-			},
-			check_all : function () {
-				var _this = this;
-				this.get_container().children("ul").children("li").each(function () {
-					_this.check_node(this, false);
-				});
-			},
-			uncheck_all : function () {
-				var _this = this;
-				this.get_container().children("ul").children("li").each(function () {
-					_this.change_state(this, true);
-				});
-			},
-
-			is_checked : function(obj) {
-				obj = this._get_node(obj);
-				return obj.length ? obj.is(".jstree-checked") : false;
-			},
-			get_checked : function (obj) {
-				obj = !obj || obj === -1 ? this.get_container() : this._get_node(obj);
-				return obj.find("> ul > .jstree-checked, .jstree-undetermined > ul > .jstree-checked");
-			},
-			get_unchecked : function (obj) { 
-				obj = !obj || obj === -1 ? this.get_container() : this._get_node(obj);
-				return obj.find("> ul > .jstree-unchecked, .jstree-undetermined > ul > .jstree-unchecked");
-			},
-
-			show_checkboxes : function () { this.get_container().children("ul").removeClass("jstree-no-checkboxes"); },
-			hide_checkboxes : function () { this.get_container().children("ul").addClass("jstree-no-checkboxes"); },
-
-			_repair_state : function (obj) {
-				obj = this._get_node(obj);
-				if(!obj.length) { return; }
-				var a = obj.find("> ul > .jstree-checked").length,
-					b = obj.find("> ul > .jstree-undetermined").length,
-					c = obj.find("> ul > li").length;
-
-				if(c === 0) { if(obj.hasClass("jstree-undetermined")) { this.check_node(obj); } }
-				else if(a === 0 && b === 0) { this.uncheck_node(obj); }
-				else if(a === c) { this.check_node(obj); }
-				else { 
-					obj.parentsUntil(".jstree","li").removeClass("jstree-checked jstree-unchecked").addClass("jstree-undetermined");
-				}
-			},
-			reselect : function () {
-				if(this.data.ui) { 
-					var _this = this,
-						s = this.data.ui.to_select;
-					s = $.map($.makeArray(s), function (n) { return "#" + n.toString().replace(/^#/,"").replace('\\/','/').replace('/','\\/'); });
-					this.deselect_all();
-					$.each(s, function (i, val) { _this.check_node(val); });
-					this.__callback();
-				}
-			}
-		}
-	});
+  $.jstree.plugin("checkbox", {
+    __init : function () {
+      this.select_node = this.deselect_node = this.deselect_all = $.noop;
+      this.get_selected = this.get_checked;
+
+      this.get_container()
+        .bind("open_node.jstree create_node.jstree clean_node.jstree", $.proxy(function (e, data) { 
+            this._prepare_checkboxes(data.rslt.obj);
+          }, this))
+        .bind("loaded.jstree", $.proxy(function (e) {
+            this._prepare_checkboxes();
+          }, this))
+        .delegate("a", "click.jstree", $.proxy(function (e) {
+            if(this._get_node(e.target).hasClass("jstree-checked")) { this.uncheck_node(e.target); }
+            else { this.check_node(e.target); }
+            if(this.data.ui) { this.save_selected(); }
+            if(this.data.cookies) { this.save_cookie("select_node"); }
+            e.preventDefault();
+          }, this));
+    },
+    __destroy : function () {
+      this.get_container().find(".jstree-checkbox").remove();
+    },
+    _fn : {
+      _prepare_checkboxes : function (obj) {
+        obj = !obj || obj == -1 ? this.get_container() : this._get_node(obj);
+        var c, _this = this, t;
+        obj.each(function () {
+          t = $(this);
+          c = t.is("li") && t.hasClass("jstree-checked") ? "jstree-checked" : "jstree-unchecked";
+          t.find("a").not(":has(.jstree-checkbox)").prepend("<ins class='jstree-checkbox'>&#160;</ins>").parent().not(".jstree-checked, .jstree-unchecked").addClass(c);
+        });
+        if(obj.is("li")) { this._repair_state(obj); }
+        else { obj.find("> ul > li").each(function () { _this._repair_state(this); }); }
+      },
+      change_state : function (obj, state) {
+        obj = this._get_node(obj);
+        state = (state === false || state === true) ? state : obj.hasClass("jstree-checked");
+        if(state) { obj.find("li").andSelf().removeClass("jstree-checked jstree-undetermined").addClass("jstree-unchecked"); }
+        else { 
+          obj.find("li").andSelf().removeClass("jstree-unchecked jstree-undetermined").addClass("jstree-checked"); 
+          if(this.data.ui) { this.data.ui.last_selected = obj; }
+          this.data.checkbox.last_selected = obj;
+        }
+        obj.parentsUntil(".jstree", "li").each(function () {
+          var $this = $(this);
+          if(state) {
+            if($this.children("ul").children(".jstree-checked, .jstree-undetermined").length) {
+              $this.parentsUntil(".jstree", "li").andSelf().removeClass("jstree-checked jstree-unchecked").addClass("jstree-undetermined");
+              return false;
+            }
+            else {
+              $this.removeClass("jstree-checked jstree-undetermined").addClass("jstree-unchecked");
+            }
+          }
+          else {
+            if($this.children("ul").children(".jstree-unchecked, .jstree-undetermined").length) {
+              $this.parentsUntil(".jstree", "li").andSelf().removeClass("jstree-checked jstree-unchecked").addClass("jstree-undetermined");
+              return false;
+            }
+            else {
+              $this.removeClass("jstree-unchecked jstree-undetermined").addClass("jstree-checked");
+            }
+          }
+        });
+        if(this.data.ui) { this.data.ui.selected = this.get_checked(); }
+        this.__callback(obj);
+      },
+      check_node : function (obj) {
+        this.change_state(obj, false);
+      },
+      uncheck_node : function (obj) {
+        this.change_state(obj, true);
+      },
+      check_all : function () {
+        var _this = this;
+        this.get_container().children("ul").children("li").each(function () {
+          _this.check_node(this, false);
+        });
+      },
+      uncheck_all : function () {
+        var _this = this;
+        this.get_container().children("ul").children("li").each(function () {
+          _this.change_state(this, true);
+        });
+      },
+
+      is_checked : function(obj) {
+        obj = this._get_node(obj);
+        return obj.length ? obj.is(".jstree-checked") : false;
+      },
+      get_checked : function (obj) {
+        obj = !obj || obj === -1 ? this.get_container() : this._get_node(obj);
+        return obj.find("> ul > .jstree-checked, .jstree-undetermined > ul > .jstree-checked");
+      },
+      get_unchecked : function (obj) { 
+        obj = !obj || obj === -1 ? this.get_container() : this._get_node(obj);
+        return obj.find("> ul > .jstree-unchecked, .jstree-undetermined > ul > .jstree-unchecked");
+      },
+
+      show_checkboxes : function () { this.get_container().children("ul").removeClass("jstree-no-checkboxes"); },
+      hide_checkboxes : function () { this.get_container().children("ul").addClass("jstree-no-checkboxes"); },
+
+      _repair_state : function (obj) {
+        obj = this._get_node(obj);
+        if(!obj.length) { return; }
+        var a = obj.find("> ul > .jstree-checked").length,
+          b = obj.find("> ul > .jstree-undetermined").length,
+          c = obj.find("> ul > li").length;
+
+        if(c === 0) { if(obj.hasClass("jstree-undetermined")) { this.check_node(obj); } }
+        else if(a === 0 && b === 0) { this.uncheck_node(obj); }
+        else if(a === c) { this.check_node(obj); }
+        else { 
+          obj.parentsUntil(".jstree","li").removeClass("jstree-checked jstree-unchecked").addClass("jstree-undetermined");
+        }
+      },
+      reselect : function () {
+        if(this.data.ui) { 
+          var _this = this,
+            s = this.data.ui.to_select;
+          s = $.map($.makeArray(s), function (n) { return "#" + n.toString().replace(/^#/,"").replace('\\/','/').replace('/','\\/'); });
+          this.deselect_all();
+          $.each(s, function (i, val) { _this.check_node(val); });
+          this.__callback();
+        }
+      }
+    }
+  });
 })(jQuery);
 //*/
 
@@ -2386,352 +2386,352 @@ THE SOFTWARE.
  * The XML data store. Datastores are build by overriding the `load_node` and `_is_loaded` functions.
  */
 (function ($) {
-	$.vakata.xslt = function (xml, xsl, callback) {
-		var rs = "", xm, xs, processor, support;
-		if(document.recalc) {
-			xm = document.createElement('xml');
-			xs = document.createElement('xml');
-			xm.innerHTML = xml;
-			xs.innerHTML = xsl;
-			$("body").append(xm).append(xs);
-			setTimeout( (function (xm, xs, callback) {
-				return function () {
-					callback.call(null, xm.transformNode(xs.XMLDocument));
-					setTimeout( (function (xm, xs) { return function () { jQuery("body").remove(xm).remove(xs); }; })(xm, xs), 200);
-				};
-			}) (xm, xs, callback), 100);
-			return true;
-		}
-		if(typeof window.DOMParser !== "undefined" && typeof window.XMLHttpRequest !== "undefined" && typeof window.XSLTProcessor !== "undefined") {
-			processor = new XSLTProcessor();
-			support = $.isFunction(processor.transformDocument) ? (typeof window.XMLSerializer !== "undefined") : true;
-			if(!support) { return false; }
-			xml = new DOMParser().parseFromString(xml, "text/xml");
-			xsl = new DOMParser().parseFromString(xsl, "text/xml");
-			if($.isFunction(processor.transformDocument)) {
-				rs = document.implementation.createDocument("", "", null);
-				processor.transformDocument(xml, xsl, rs, null);
-				callback.call(null, XMLSerializer().serializeToString(rs));
-				return true;
-			}
-			else {
-				processor.importStylesheet(xsl);
-				rs = processor.transformToFragment(xml, document);
-				callback.call(null, $("<div>").append(rs).html());
-				return true;
-			}
-		}
-		return false;
-	};
-	var xsl = {
-		'nest' : '<?xml version="1.0" encoding="utf-8" ?>' + 
-			'<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" >' + 
-			'<xsl:output method="html" encoding="utf-8" omit-xml-declaration="yes" standalone="no" indent="no" media-type="text/html" />' + 
-			'<xsl:template match="/">' + 
-			'	<xsl:call-template name="nodes">' + 
-			'		<xsl:with-param name="node" select="/root" />' + 
-			'	</xsl:call-template>' + 
-			'</xsl:template>' + 
-			'<xsl:template name="nodes">' + 
-			'	<xsl:param name="node" />' + 
-			'	<ul>' + 
-			'	<xsl:for-each select="$node/item">' + 
-			'		<xsl:variable name="children" select="count(./item) &gt; 0" />' + 
-			'		<li>' + 
-			'			<xsl:attribute name="class">' + 
-			'				<xsl:if test="position() = last()">jstree-last </xsl:if>' + 
-			'				<xsl:choose>' + 
-			'					<xsl:when test="@state = \'open\'">jstree-open </xsl:when>' + 
-			'					<xsl:when test="$children or @hasChildren or @state = \'closed\'">jstree-closed </xsl:when>' + 
-			'					<xsl:otherwise>jstree-leaf </xsl:otherwise>' + 
-			'				</xsl:choose>' + 
-			'				<xsl:value-of select="@class" />' + 
-			'			</xsl:attribute>' + 
-			'			<xsl:for-each select="@*">' + 
-			'				<xsl:if test="name() != \'class\' and name() != \'state\' and name() != \'hasChildren\'">' + 
-			'					<xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>' + 
-			'				</xsl:if>' + 
-			'			</xsl:for-each>' + 
-			'	<ins class="jstree-icon"><xsl:text>&#xa0;</xsl:text></ins>' + 
-			'			<xsl:for-each select="content/name">' + 
-			'				<a>' + 
-			'				<xsl:attribute name="href">' + 
-			'					<xsl:choose>' + 
-			'					<xsl:when test="@href"><xsl:value-of select="@href" /></xsl:when>' + 
-			'					<xsl:otherwise>#</xsl:otherwise>' + 
-			'					</xsl:choose>' + 
-			'				</xsl:attribute>' + 
-			'				<xsl:attribute name="class"><xsl:value-of select="@lang" /> <xsl:value-of select="@class" /></xsl:attribute>' + 
-			'				<xsl:attribute name="style"><xsl:value-of select="@style" /></xsl:attribute>' + 
-			'				<xsl:for-each select="@*">' + 
-			'					<xsl:if test="name() != \'style\' and name() != \'class\' and name() != \'href\'">' + 
-			'						<xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>' + 
-			'					</xsl:if>' + 
-			'				</xsl:for-each>' + 
-			'					<ins>' + 
-			'						<xsl:attribute name="class">jstree-icon ' + 
-			'							<xsl:if test="string-length(attribute::icon) > 0 and not(contains(@icon,\'/\'))"><xsl:value-of select="@icon" /></xsl:if>' + 
-			'						</xsl:attribute>' + 
-			'						<xsl:if test="string-length(attribute::icon) > 0 and contains(@icon,\'/\')"><xsl:attribute name="style">background:url(<xsl:value-of select="@icon" />) center center no-repeat;</xsl:attribute></xsl:if>' + 
-			'						<xsl:text>&#xa0;</xsl:text>' + 
-			'					</ins>' + 
-			'					<xsl:value-of select="current()" />' + 
-			'				</a>' + 
-			'			</xsl:for-each>' + 
-			'			<xsl:if test="$children or @hasChildren"><xsl:call-template name="nodes"><xsl:with-param name="node" select="current()" /></xsl:call-template></xsl:if>' + 
-			'		</li>' + 
-			'	</xsl:for-each>' + 
-			'	</ul>' + 
-			'</xsl:template>' + 
-			'</xsl:stylesheet>',
-
-		'flat' : '<?xml version="1.0" encoding="utf-8" ?>' + 
-			'<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" >' + 
-			'<xsl:output method="html" encoding="utf-8" omit-xml-declaration="yes" standalone="no" indent="no" media-type="text/xml" />' + 
-			'<xsl:template match="/">' + 
-			'	<ul>' + 
-			'	<xsl:for-each select="//item[not(@parent_id) or @parent_id=0 or not(@parent_id = //item/@id)]">' + /* the last `or` may be removed */
-			'		<xsl:call-template name="nodes">' + 
-			'			<xsl:with-param name="node" select="." />' + 
-			'			<xsl:with-param name="is_last" select="number(position() = last())" />' + 
-			'		</xsl:call-template>' + 
-			'	</xsl:for-each>' + 
-			'	</ul>' + 
-			'</xsl:template>' + 
-			'<xsl:template name="nodes">' + 
-			'	<xsl:param name="node" />' + 
-			'	<xsl:param name="is_last" />' + 
-			'	<xsl:variable name="children" select="count(//item[@parent_id=$node/attribute::id]) &gt; 0" />' + 
-			'	<li>' + 
-			'	<xsl:attribute name="class">' + 
-			'		<xsl:if test="$is_last = true()">jstree-last </xsl:if>' + 
-			'		<xsl:choose>' + 
-			'			<xsl:when test="@state = \'open\'">jstree-open </xsl:when>' + 
-			'			<xsl:when test="$children or @hasChildren or @state = \'closed\'">jstree-closed </xsl:when>' + 
-			'			<xsl:otherwise>jstree-leaf </xsl:otherwise>' + 
-			'		</xsl:choose>' + 
-			'		<xsl:value-of select="@class" />' + 
-			'	</xsl:attribute>' + 
-			'	<xsl:for-each select="@*">' + 
-			'		<xsl:if test="name() != \'parent_id\' and name() != \'hasChildren\' and name() != \'class\' and name() != \'state\'">' + 
-			'		<xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>' + 
-			'		</xsl:if>' + 
-			'	</xsl:for-each>' + 
-			'	<ins class="jstree-icon"><xsl:text>&#xa0;</xsl:text></ins>' + 
-			'	<xsl:for-each select="content/name">' + 
-			'		<a>' + 
-			'		<xsl:attribute name="href">' + 
-			'			<xsl:choose>' + 
-			'			<xsl:when test="@href"><xsl:value-of select="@href" /></xsl:when>' + 
-			'			<xsl:otherwise>#</xsl:otherwise>' + 
-			'			</xsl:choose>' + 
-			'		</xsl:attribute>' + 
-			'		<xsl:attribute name="class"><xsl:value-of select="@lang" /> <xsl:value-of select="@class" /></xsl:attribute>' + 
-			'		<xsl:attribute name="style"><xsl:value-of select="@style" /></xsl:attribute>' + 
-			'		<xsl:for-each select="@*">' + 
-			'			<xsl:if test="name() != \'style\' and name() != \'class\' and name() != \'href\'">' + 
-			'				<xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>' + 
-			'			</xsl:if>' + 
-			'		</xsl:for-each>' + 
-			'			<ins>' + 
-			'				<xsl:attribute name="class">jstree-icon ' + 
-			'					<xsl:if test="string-length(attribute::icon) > 0 and not(contains(@icon,\'/\'))"><xsl:value-of select="@icon" /></xsl:if>' + 
-			'				</xsl:attribute>' + 
-			'				<xsl:if test="string-length(attribute::icon) > 0 and contains(@icon,\'/\')"><xsl:attribute name="style">background:url(<xsl:value-of select="@icon" />) center center no-repeat;</xsl:attribute></xsl:if>' + 
-			'				<xsl:text>&#xa0;</xsl:text>' + 
-			'			</ins>' + 
-			'			<xsl:value-of select="current()" />' + 
-			'		</a>' + 
-			'	</xsl:for-each>' + 
-			'	<xsl:if test="$children">' + 
-			'		<ul>' + 
-			'		<xsl:for-each select="//item[@parent_id=$node/attribute::id]">' + 
-			'			<xsl:call-template name="nodes">' + 
-			'				<xsl:with-param name="node" select="." />' + 
-			'				<xsl:with-param name="is_last" select="number(position() = last())" />' + 
-			'			</xsl:call-template>' + 
-			'		</xsl:for-each>' + 
-			'		</ul>' + 
-			'	</xsl:if>' + 
-			'	</li>' + 
-			'</xsl:template>' + 
-			'</xsl:stylesheet>'
-	};
-	$.jstree.plugin("xml_data", {
-		defaults : { 
-			data : false,
-			ajax : false,
-			xsl : "flat",
-			clean_node : false,
-			correct_state : true
-		},
-		_fn : {
-			load_node : function (obj, s_call, e_call) { var _this = this; this.load_node_xml(obj, function () { _this.__callback({ "obj" : obj }); s_call.call(this); }, e_call); },
-			_is_loaded : function (obj) { 
-				var s = this._get_settings().xml_data;
-				obj = this._get_node(obj);
-				return obj == -1 || !obj || !s.ajax || obj.is(".jstree-open, .jstree-leaf") || obj.children("ul").children("li").size() > 0;
-			},
-			load_node_xml : function (obj, s_call, e_call) {
-				var s = this.get_settings().xml_data,
-					error_func = function () {},
-					success_func = function () {};
-
-				obj = this._get_node(obj);
-				if(obj && obj !== -1) {
-					if(obj.data("jstree-is-loading")) { return; }
-					else { obj.data("jstree-is-loading",true); }
-				}
-				switch(!0) {
-					case (!s.data && !s.ajax): throw "Neither data nor ajax settings supplied.";
-					case (!!s.data && !s.ajax) || (!!s.data && !!s.ajax && (!obj || obj === -1)):
-						if(!obj || obj == -1) {
-							this.parse_xml(s.data, $.proxy(function (d) {
-								if(d) {
-									d = d.replace(/ ?xmlns="[^"]*"/ig, "");
-									if(d.length > 10) {
-										d = $(d);
-										this.get_container().children("ul").empty().append(d.children());
-										if(s.clean_node) { this.clean_node(obj); }
-										if(s_call) { s_call.call(this); }
-									}
-								}
-								else { 
-									if(s.correct_state) { 
-										this.get_container().children("ul").empty(); 
-										if(s_call) { s_call.call(this); }
-									}
-								}
-							}, this));
-						}
-						break;
-					case (!s.data && !!s.ajax) || (!!s.data && !!s.ajax && obj && obj !== -1):
-						error_func = function (x, t, e) {
-							var ef = this.get_settings().xml_data.ajax.error; 
-							if(ef) { ef.call(this, x, t, e); }
-							if(obj !== -1 && obj.length) {
-								obj.children(".jstree-loading").removeClass("jstree-loading");
-								obj.data("jstree-is-loading",false);
-								if(t === "success" && s.correct_state) { obj.removeClass("jstree-open jstree-closed").addClass("jstree-leaf"); }
-							}
-							else {
-								if(t === "success" && s.correct_state) { this.get_container().children("ul").empty(); }
-							}
-							if(e_call) { e_call.call(this); }
-						};
-						success_func = function (d, t, x) {
-							d = x.responseText;
-							var sf = this.get_settings().xml_data.ajax.success; 
-							if(sf) { d = sf.call(this,d,t,x) || d; }
-							if(d == "") {
-								return error_func.call(this, x, t, "");
-							}
-							this.parse_xml(d, $.proxy(function (d) {
-								if(d) {
-									d = d.replace(/ ?xmlns="[^"]*"/ig, "");
-									if(d.length > 10) {
-										d = $(d);
-										if(obj === -1 || !obj) { this.get_container().children("ul").empty().append(d.children()); }
-										else { obj.children(".jstree-loading").removeClass("jstree-loading"); obj.append(d); obj.data("jstree-is-loading",false); }
-										if(s.clean_node) { this.clean_node(obj); }
-										if(s_call) { s_call.call(this); }
-									}
-									else {
-										if(obj && obj !== -1) { 
-											obj.children(".jstree-loading").removeClass("jstree-loading");
-											obj.data("jstree-is-loading",false);
-											if(s.correct_state) { 
-												obj.removeClass("jstree-open jstree-closed").addClass("jstree-leaf"); 
-												if(s_call) { s_call.call(this); } 
-											}
-										}
-										else {
-											if(s.correct_state) { 
-												this.get_container().children("ul").empty();
-												if(s_call) { s_call.call(this); } 
-											}
-										}
-									}
-								}
-							}, this));
-						};
-						s.ajax.context = this;
-						s.ajax.error = error_func;
-						s.ajax.success = success_func;
-						if(!s.ajax.dataType) { s.ajax.dataType = "xml"; }
-						if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, obj); }
-						if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, obj); }
-						$.ajax(s.ajax);
-						break;
-				}
-			},
-			parse_xml : function (xml, callback) {
-				var s = this._get_settings().xml_data;
-				$.vakata.xslt(xml, xsl[s.xsl], callback);
-			},
-			get_xml : function (tp, obj, li_attr, a_attr, is_callback) {
-				var result = "", 
-					s = this._get_settings(), 
-					_this = this,
-					tmp1, tmp2, li, a, lang;
-				if(!tp) { tp = "flat"; }
-				if(!is_callback) { is_callback = 0; }
-				obj = this._get_node(obj);
-				if(!obj || obj === -1) { obj = this.get_container().find("> ul > li"); }
-				li_attr = $.isArray(li_attr) ? li_attr : [ "id", "class" ];
-				if(!is_callback && this.data.types && $.inArray(s.types.type_attr, li_attr) === -1) { li_attr.push(s.types.type_attr); }
-
-				a_attr = $.isArray(a_attr) ? a_attr : [ ];
-
-				if(!is_callback) { result += "<root>"; }
-				obj.each(function () {
-					result += "<item";
-					li = $(this);
-					$.each(li_attr, function (i, v) { result += " " + v + "=\"" + (li.attr(v) || "").replace(/jstree[^ ]*|$/ig,'').replace(/^\s+$/ig,"") + "\""; });
-					if(li.hasClass("jstree-open")) { result += " state=\"open\""; }
-					if(li.hasClass("jstree-closed")) { result += " state=\"closed\""; }
-					if(tp === "flat") { result += " parent_id=\"" + is_callback + "\""; }
-					result += ">";
-					result += "<content>";
-					a = li.children("a");
-					a.each(function () {
-						tmp1 = $(this);
-						lang = false;
-						result += "<name";
-						if($.inArray("languages", s.plugins) !== -1) {
-							$.each(s.languages, function (k, z) {
-								if(tmp1.hasClass(z)) { result += " lang=\"" + z + "\""; lang = z; return false; }
-							});
-						}
-						if(a_attr.length) { 
-							$.each(a_attr, function (k, z) {
-								result += " " + z + "=\"" + (tmp1.attr(z) || "").replace(/jstree[^ ]*|$/ig,'') + "\"";
-							});
-						}
-						if(tmp1.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').replace(/^\s+$/ig,"").length) {
-							result += ' icon="' + tmp1.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').replace(/^\s+$/ig,"") + '"';
-						}
-						if(tmp1.children("ins").get(0).style.backgroundImage.length) {
-							result += ' icon="' + tmp1.children("ins").get(0).style.backgroundImage.replace("url(","").replace(")","") + '"';
-						}
-						result += ">";
-						result += "<![CDATA[" + _this.get_text(tmp1, lang) + "]]>";
-						result += "</name>";
-					});
-					result += "</content>";
-					tmp2 = li[0].id;
-					li = li.find("> ul > li");
-					if(li.length) { tmp2 = _this.get_xml(tp, li, li_attr, a_attr, tmp2); }
-					else { tmp2 = ""; }
-					if(tp == "nest") { result += tmp2; }
-					result += "</item>";
-					if(tp == "flat") { result += tmp2; }
-				});
-				if(!is_callback) { result += "</root>"; }
-				return result;
-			}
-		}
-	});
+  $.vakata.xslt = function (xml, xsl, callback) {
+    var rs = "", xm, xs, processor, support;
+    if(document.recalc) {
+      xm = document.createElement('xml');
+      xs = document.createElement('xml');
+      xm.innerHTML = xml;
+      xs.innerHTML = xsl;
+      $("body").append(xm).append(xs);
+      setTimeout( (function (xm, xs, callback) {
+        return function () {
+          callback.call(null, xm.transformNode(xs.XMLDocument));
+          setTimeout( (function (xm, xs) { return function () { jQuery("body").remove(xm).remove(xs); }; })(xm, xs), 200);
+        };
+      }) (xm, xs, callback), 100);
+      return true;
+    }
+    if(typeof window.DOMParser !== "undefined" && typeof window.XMLHttpRequest !== "undefined" && typeof window.XSLTProcessor !== "undefined") {
+      processor = new XSLTProcessor();
+      support = $.isFunction(processor.transformDocument) ? (typeof window.XMLSerializer !== "undefined") : true;
+      if(!support) { return false; }
+      xml = new DOMParser().parseFromString(xml, "text/xml");
+      xsl = new DOMParser().parseFromString(xsl, "text/xml");
+      if($.isFunction(processor.transformDocument)) {
+        rs = document.implementation.createDocument("", "", null);
+        processor.transformDocument(xml, xsl, rs, null);
+        callback.call(null, XMLSerializer().serializeToString(rs));
+        return true;
+      }
+      else {
+        processor.importStylesheet(xsl);
+        rs = processor.transformToFragment(xml, document);
+        callback.call(null, $("<div>").append(rs).html());
+        return true;
+      }
+    }
+    return false;
+  };
+  var xsl = {
+    'nest' : '<?xml version="1.0" encoding="utf-8" ?>' + 
+      '<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" >' + 
+      '<xsl:output method="html" encoding="utf-8" omit-xml-declaration="yes" standalone="no" indent="no" media-type="text/html" />' + 
+      '<xsl:template match="/">' + 
+      '  <xsl:call-template name="nodes">' + 
+      '    <xsl:with-param name="node" select="/root" />' + 
+      '  </xsl:call-template>' + 
+      '</xsl:template>' + 
+      '<xsl:template name="nodes">' + 
+      '  <xsl:param name="node" />' + 
+      '  <ul>' + 
+      '  <xsl:for-each select="$node/item">' + 
+      '    <xsl:variable name="children" select="count(./item) &gt; 0" />' + 
+      '    <li>' + 
+      '      <xsl:attribute name="class">' + 
+      '        <xsl:if test="position() = last()">jstree-last </xsl:if>' + 
+      '        <xsl:choose>' + 
+      '          <xsl:when test="@state = \'open\'">jstree-open </xsl:when>' + 
+      '          <xsl:when test="$children or @hasChildren or @state = \'closed\'">jstree-closed </xsl:when>' + 
+      '          <xsl:otherwise>jstree-leaf </xsl:otherwise>' + 
+      '        </xsl:choose>' + 
+      '        <xsl:value-of select="@class" />' + 
+      '      </xsl:attribute>' + 
+      '      <xsl:for-each select="@*">' + 
+      '        <xsl:if test="name() != \'class\' and name() != \'state\' and name() != \'hasChildren\'">' + 
+      '          <xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>' + 
+      '        </xsl:if>' + 
+      '      </xsl:for-each>' + 
+      '  <ins class="jstree-icon"><xsl:text>&#xa0;</xsl:text></ins>' + 
+      '      <xsl:for-each select="content/name">' + 
+      '        <a>' + 
+      '        <xsl:attribute name="href">' + 
+      '          <xsl:choose>' + 
+      '          <xsl:when test="@href"><xsl:value-of select="@href" /></xsl:when>' + 
+      '          <xsl:otherwise>#</xsl:otherwise>' + 
+      '          </xsl:choose>' + 
+      '        </xsl:attribute>' + 
+      '        <xsl:attribute name="class"><xsl:value-of select="@lang" /> <xsl:value-of select="@class" /></xsl:attribute>' + 
+      '        <xsl:attribute name="style"><xsl:value-of select="@style" /></xsl:attribute>' + 
+      '        <xsl:for-each select="@*">' + 
+      '          <xsl:if test="name() != \'style\' and name() != \'class\' and name() != \'href\'">' + 
+      '            <xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>' + 
+      '          </xsl:if>' + 
+      '        </xsl:for-each>' + 
+      '          <ins>' + 
+      '            <xsl:attribute name="class">jstree-icon ' + 
+      '              <xsl:if test="string-length(attribute::icon) > 0 and not(contains(@icon,\'/\'))"><xsl:value-of select="@icon" /></xsl:if>' + 
+      '            </xsl:attribute>' + 
+      '            <xsl:if test="string-length(attribute::icon) > 0 and contains(@icon,\'/\')"><xsl:attribute name="style">background:url(<xsl:value-of select="@icon" />) center center no-repeat;</xsl:attribute></xsl:if>' + 
+      '            <xsl:text>&#xa0;</xsl:text>' + 
+      '          </ins>' + 
+      '          <xsl:value-of select="current()" />' + 
+      '        </a>' + 
+      '      </xsl:for-each>' + 
+      '      <xsl:if test="$children or @hasChildren"><xsl:call-template name="nodes"><xsl:with-param name="node" select="current()" /></xsl:call-template></xsl:if>' + 
+      '    </li>' + 
+      '  </xsl:for-each>' + 
+      '  </ul>' + 
+      '</xsl:template>' + 
+      '</xsl:stylesheet>',
+
+    'flat' : '<?xml version="1.0" encoding="utf-8" ?>' + 
+      '<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" >' + 
+      '<xsl:output method="html" encoding="utf-8" omit-xml-declaration="yes" standalone="no" indent="no" media-type="text/xml" />' + 
+      '<xsl:template match="/">' + 
+      '  <ul>' + 
+      '  <xsl:for-each select="//item[not(@parent_id) or @parent_id=0 or not(@parent_id = //item/@id)]">' + /* the last `or` may be removed */
+      '    <xsl:call-template name="nodes">' + 
+      '      <xsl:with-param name="node" select="." />' + 
+      '      <xsl:with-param name="is_last" select="number(position() = last())" />' + 
+      '    </xsl:call-template>' + 
+      '  </xsl:for-each>' + 
+      '  </ul>' + 
+      '</xsl:template>' + 
+      '<xsl:template name="nodes">' + 
+      '  <xsl:param name="node" />' + 
+      '  <xsl:param name="is_last" />' + 
+      '  <xsl:variable name="children" select="count(//item[@parent_id=$node/attribute::id]) &gt; 0" />' + 
+      '  <li>' + 
+      '  <xsl:attribute name="class">' + 
+      '    <xsl:if test="$is_last = true()">jstree-last </xsl:if>' + 
+      '    <xsl:choose>' + 
+      '      <xsl:when test="@state = \'open\'">jstree-open </xsl:when>' + 
+      '      <xsl:when test="$children or @hasChildren or @state = \'closed\'">jstree-closed </xsl:when>' + 
+      '      <xsl:otherwise>jstree-leaf </xsl:otherwise>' + 
+      '    </xsl:choose>' + 
+      '    <xsl:value-of select="@class" />' + 
+      '  </xsl:attribute>' + 
+      '  <xsl:for-each select="@*">' + 
+      '    <xsl:if test="name() != \'parent_id\' and name() != \'hasChildren\' and name() != \'class\' and name() != \'state\'">' + 
+      '    <xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>' + 
+      '    </xsl:if>' + 
+      '  </xsl:for-each>' + 
+      '  <ins class="jstree-icon"><xsl:text>&#xa0;</xsl:text></ins>' + 
+      '  <xsl:for-each select="content/name">' + 
+      '    <a>' + 
+      '    <xsl:attribute name="href">' + 
+      '      <xsl:choose>' + 
+      '      <xsl:when test="@href"><xsl:value-of select="@href" /></xsl:when>' + 
+      '      <xsl:otherwise>#</xsl:otherwise>' + 
+      '      </xsl:choose>' + 
+      '    </xsl:attribute>' + 
+      '    <xsl:attribute name="class"><xsl:value-of select="@lang" /> <xsl:value-of select="@class" /></xsl:attribute>' + 
+      '    <xsl:attribute name="style"><xsl:value-of select="@style" /></xsl:attribute>' + 
+      '    <xsl:for-each select="@*">' + 
+      '      <xsl:if test="name() != \'style\' and name() != \'class\' and name() != \'href\'">' + 
+      '        <xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>' + 
+      '      </xsl:if>' + 
+      '    </xsl:for-each>' + 
+      '      <ins>' + 
+      '        <xsl:attribute name="class">jstree-icon ' + 
+      '          <xsl:if test="string-length(attribute::icon) > 0 and not(contains(@icon,\'/\'))"><xsl:value-of select="@icon" /></xsl:if>' + 
+      '        </xsl:attribute>' + 
+      '        <xsl:if test="string-length(attribute::icon) > 0 and contains(@icon,\'/\')"><xsl:attribute name="style">background:url(<xsl:value-of select="@icon" />) center center no-repeat;</xsl:attribute></xsl:if>' + 
+      '        <xsl:text>&#xa0;</xsl:text>' + 
+      '      </ins>' + 
+      '      <xsl:value-of select="current()" />' + 
+      '    </a>' + 
+      '  </xsl:for-each>' + 
+      '  <xsl:if test="$children">' + 
+      '    <ul>' + 
+      '    <xsl:for-each select="//item[@parent_id=$node/attribute::id]">' + 
+      '      <xsl:call-template name="nodes">' + 
+      '        <xsl:with-param name="node" select="." />' + 
+      '        <xsl:with-param name="is_last" select="number(position() = last())" />' + 
+      '      </xsl:call-template>' + 
+      '    </xsl:for-each>' + 
+      '    </ul>' + 
+      '  </xsl:if>' + 
+      '  </li>' + 
+      '</xsl:template>' + 
+      '</xsl:stylesheet>'
+  };
+  $.jstree.plugin("xml_data", {
+    defaults : { 
+      data : false,
+      ajax : false,
+      xsl : "flat",
+      clean_node : false,
+      correct_state : true
+    },
+    _fn : {
+      load_node : function (obj, s_call, e_call) { var _this = this; this.load_node_xml(obj, function () { _this.__callback({ "obj" : obj }); s_call.call(this); }, e_call); },
+      _is_loaded : function (obj) { 
+        var s = this._get_settings().xml_data;
+        obj = this._get_node(obj);
+        return obj == -1 || !obj || !s.ajax || obj.is(".jstree-open, .jstree-leaf") || obj.children("ul").children("li").size() > 0;
+      },
+      load_node_xml : function (obj, s_call, e_call) {
+        var s = this.get_settings().xml_data,
+          error_func = function () {},
+          success_func = function () {};
+
+        obj = this._get_node(obj);
+        if(obj && obj !== -1) {
+          if(obj.data("jstree-is-loading")) { return; }
+          else { obj.data("jstree-is-loading",true); }
+        }
+        switch(!0) {
+          case (!s.data && !s.ajax): throw "Neither data nor ajax settings supplied.";
+          case (!!s.data && !s.ajax) || (!!s.data && !!s.ajax && (!obj || obj === -1)):
+            if(!obj || obj == -1) {
+              this.parse_xml(s.data, $.proxy(function (d) {
+                if(d) {
+                  d = d.replace(/ ?xmlns="[^"]*"/ig, "");
+                  if(d.length > 10) {
+                    d = $(d);
+                    this.get_container().children("ul").empty().append(d.children());
+                    if(s.clean_node) { this.clean_node(obj); }
+                    if(s_call) { s_call.call(this); }
+                  }
+                }
+                else { 
+                  if(s.correct_state) { 
+                    this.get_container().children("ul").empty(); 
+                    if(s_call) { s_call.call(this); }
+                  }
+                }
+              }, this));
+            }
+            break;
+          case (!s.data && !!s.ajax) || (!!s.data && !!s.ajax && obj && obj !== -1):
+            error_func = function (x, t, e) {
+              var ef = this.get_settings().xml_data.ajax.error; 
+              if(ef) { ef.call(this, x, t, e); }
+              if(obj !== -1 && obj.length) {
+                obj.children(".jstree-loading").removeClass("jstree-loading");
+                obj.data("jstree-is-loading",false);
+                if(t === "success" && s.correct_state) { obj.removeClass("jstree-open jstree-closed").addClass("jstree-leaf"); }
+              }
+              else {
+                if(t === "success" && s.correct_state) { this.get_container().children("ul").empty(); }
+              }
+              if(e_call) { e_call.call(this); }
+            };
+            success_func = function (d, t, x) {
+              d = x.responseText;
+              var sf = this.get_settings().xml_data.ajax.success; 
+              if(sf) { d = sf.call(this,d,t,x) || d; }
+              if(d == "") {
+                return error_func.call(this, x, t, "");
+              }
+              this.parse_xml(d, $.proxy(function (d) {
+                if(d) {
+                  d = d.replace(/ ?xmlns="[^"]*"/ig, "");
+                  if(d.length > 10) {
+                    d = $(d);
+                    if(obj === -1 || !obj) { this.get_container().children("ul").empty().append(d.children()); }
+                    else { obj.children(".jstree-loading").removeClass("jstree-loading"); obj.append(d); obj.data("jstree-is-loading",false); }
+                    if(s.clean_node) { this.clean_node(obj); }
+                    if(s_call) { s_call.call(this); }
+                  }
+                  else {
+                    if(obj && obj !== -1) { 
+                      obj.children(".jstree-loading").removeClass("jstree-loading");
+                      obj.data("jstree-is-loading",false);
+                      if(s.correct_state) { 
+                        obj.removeClass("jstree-open jstree-closed").addClass("jstree-leaf"); 
+                        if(s_call) { s_call.call(this); } 
+                      }
+                    }
+                    else {
+                      if(s.correct_state) { 
+                        this.get_container().children("ul").empty();
+                        if(s_call) { s_call.call(this); } 
+                      }
+                    }
+                  }
+                }
+              }, this));
+            };
+            s.ajax.context = this;
+            s.ajax.error = error_func;
+            s.ajax.success = success_func;
+            if(!s.ajax.dataType) { s.ajax.dataType = "xml"; }
+            if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, obj); }
+            if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, obj); }
+            $.ajax(s.ajax);
+            break;
+        }
+      },
+      parse_xml : function (xml, callback) {
+        var s = this._get_settings().xml_data;
+        $.vakata.xslt(xml, xsl[s.xsl], callback);
+      },
+      get_xml : function (tp, obj, li_attr, a_attr, is_callback) {
+        var result = "", 
+          s = this._get_settings(), 
+          _this = this,
+          tmp1, tmp2, li, a, lang;
+        if(!tp) { tp = "flat"; }
+        if(!is_callback) { is_callback = 0; }
+        obj = this._get_node(obj);
+        if(!obj || obj === -1) { obj = this.get_container().find("> ul > li"); }
+        li_attr = $.isArray(li_attr) ? li_attr : [ "id", "class" ];
+        if(!is_callback && this.data.types && $.inArray(s.types.type_attr, li_attr) === -1) { li_attr.push(s.types.type_attr); }
+
+        a_attr = $.isArray(a_attr) ? a_attr : [ ];
+
+        if(!is_callback) { result += "<root>"; }
+        obj.each(function () {
+          result += "<item";
+          li = $(this);
+          $.each(li_attr, function (i, v) { result += " " + v + "=\"" + (li.attr(v) || "").replace(/jstree[^ ]*|$/ig,'').replace(/^\s+$/ig,"") + "\""; });
+          if(li.hasClass("jstree-open")) { result += " state=\"open\""; }
+          if(li.hasClass("jstree-closed")) { result += " state=\"closed\""; }
+          if(tp === "flat") { result += " parent_id=\"" + is_callback + "\""; }
+          result += ">";
+          result += "<content>";
+          a = li.children("a");
+          a.each(function () {
+            tmp1 = $(this);
+            lang = false;
+            result += "<name";
+            if($.inArray("languages", s.plugins) !== -1) {
+              $.each(s.languages, function (k, z) {
+                if(tmp1.hasClass(z)) { result += " lang=\"" + z + "\""; lang = z; return false; }
+              });
+            }
+            if(a_attr.length) { 
+              $.each(a_attr, function (k, z) {
+                result += " " + z + "=\"" + (tmp1.attr(z) || "").replace(/jstree[^ ]*|$/ig,'') + "\"";
+              });
+            }
+            if(tmp1.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').replace(/^\s+$/ig,"").length) {
+              result += ' icon="' + tmp1.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').replace(/^\s+$/ig,"") + '"';
+            }
+            if(tmp1.children("ins").get(0).style.backgroundImage.length) {
+              result += ' icon="' + tmp1.children("ins").get(0).style.backgroundImage.replace("url(","").replace(")","") + '"';
+            }
+            result += ">";
+            result += "<![CDATA[" + _this.get_text(tmp1, lang) + "]]>";
+            result += "</name>";
+          });
+          result += "</content>";
+          tmp2 = li[0].id;
+          li = li.find("> ul > li");
+          if(li.length) { tmp2 = _this.get_xml(tp, li, li_attr, a_attr, tmp2); }
+          else { tmp2 = ""; }
+          if(tp == "nest") { result += tmp2; }
+          result += "</item>";
+          if(tp == "flat") { result += tmp2; }
+        });
+        if(!is_callback) { result += "</root>"; }
+        return result;
+      }
+    }
+  });
 })(jQuery);
 //*/
 
@@ -2741,81 +2741,81 @@ THE SOFTWARE.
  * DOES NOT WORK WITH JSON PROGRESSIVE RENDER
  */
 (function ($) {
-	$.expr[':'].jstree_contains = function(a,i,m){
-		return (a.textContent || a.innerText || "").toLowerCase().indexOf(m[3].toLowerCase())>=0;
-	};
-	$.jstree.plugin("search", {
-		__init : function () {
-			this.data.search.str = "";
-			this.data.search.result = $();
-		},
-		defaults : {
-			ajax : false, // OR ajax object
-			case_insensitive : false
-		},
-		_fn : {
-			search : function (str, skip_async) {
-				if(str === "") { return; }
-				var s = this.get_settings().search, 
-					t = this,
-					error_func = function () { },
-					success_func = function () { };
-				this.data.search.str = str;
-
-				if(!skip_async && s.ajax !== false && this.get_container().find(".jstree-closed:eq(0)").length > 0) {
-					this.search.supress_callback = true;
-					error_func = function () { };
-					success_func = function (d, t, x) {
-						var sf = this.get_settings().search.ajax.success; 
-						if(sf) { d = sf.call(this,d,t,x) || d; }
-						this.data.search.to_open = d;
-						this._search_open();
-					};
-					s.ajax.context = this;
-					s.ajax.error = error_func;
-					s.ajax.success = success_func;
-					if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, str); }
-					if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, str); }
-					if(!s.ajax.data) { s.ajax.data = { "search_string" : str }; }
-					if(!s.ajax.dataType || /^json/.exec(s.ajax.dataType)) { s.ajax.dataType = "json"; }
-					$.ajax(s.ajax);
-					return;
-				}
-				if(this.data.search.result.length) { this.clear_search(); }
-				this.data.search.result = this.get_container().find("a" + (this.data.languages ? "." + this.get_lang() : "" ) + ":" + (s.case_insensitive ? "jstree_contains" : "contains") + "(" + this.data.search.str + ")");
-				this.data.search.result.addClass("jstree-search").parents(".jstree-closed").each(function () {
-					t.open_node(this, false, true);
-				});
-				this.__callback({ nodes : this.data.search.result, str : str });
-			},
-			clear_search : function (str) {
-				this.data.search.result.removeClass("jstree-search");
-				this.__callback(this.data.search.result);
-				this.data.search.result = $();
-			},
-			_search_open : function (is_callback) {
-				var _this = this,
-					done = true,
-					current = [],
-					remaining = [];
-				if(this.data.search.to_open.length) {
-					$.each(this.data.search.to_open, function (i, val) {
-						if(val == "#") { return true; }
-						if($(val).length && $(val).is(".jstree-closed")) { current.push(val); }
-						else { remaining.push(val); }
-					});
-					if(current.length) {
-						this.data.search.to_open = remaining;
-						$.each(current, function (i, val) { 
-							_this.open_node(val, function () { _this._search_open(true); }); 
-						});
-						done = false;
-					}
-				}
-				if(done) { this.search(this.data.search.str, true); }
-			}
-		}
-	});
+  $.expr[':'].jstree_contains = function(a,i,m){
+    return (a.textContent || a.innerText || "").toLowerCase().indexOf(m[3].toLowerCase())>=0;
+  };
+  $.jstree.plugin("search", {
+    __init : function () {
+      this.data.search.str = "";
+      this.data.search.result = $();
+    },
+    defaults : {
+      ajax : false, // OR ajax object
+      case_insensitive : false
+    },
+    _fn : {
+      search : function (str, skip_async) {
+        if(str === "") { return; }
+        var s = this.get_settings().search, 
+          t = this,
+          error_func = function () { },
+          success_func = function () { };
+        this.data.search.str = str;
+
+        if(!skip_async && s.ajax !== false && this.get_container().find(".jstree-closed:eq(0)").length > 0) {
+          this.search.supress_callback = true;
+          error_func = function () { };
+          success_func = function (d, t, x) {
+            var sf = this.get_settings().search.ajax.success; 
+            if(sf) { d = sf.call(this,d,t,x) || d; }
+            this.data.search.to_open = d;
+            this._search_open();
+          };
+          s.ajax.context = this;
+          s.ajax.error = error_func;
+          s.ajax.success = success_func;
+          if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, str); }
+          if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, str); }
+          if(!s.ajax.data) { s.ajax.data = { "search_string" : str }; }
+          if(!s.ajax.dataType || /^json/.exec(s.ajax.dataType)) { s.ajax.dataType = "json"; }
+          $.ajax(s.ajax);
+          return;
+        }
+        if(this.data.search.result.length) { this.clear_search(); }
+        this.data.search.result = this.get_container().find("a" + (this.data.languages ? "." + this.get_lang() : "" ) + ":" + (s.case_insensitive ? "jstree_contains" : "contains") + "(" + this.data.search.str + ")");
+        this.data.search.result.addClass("jstree-search").parents(".jstree-closed").each(function () {
+          t.open_node(this, false, true);
+        });
+        this.__callback({ nodes : this.data.search.result, str : str });
+      },
+      clear_search : function (str) {
+        this.data.search.result.removeClass("jstree-search");
+        this.__callback(this.data.search.result);
+        this.data.search.result = $();
+      },
+      _search_open : function (is_callback) {
+        var _this = this,
+          done = true,
+          current = [],
+          remaining = [];
+        if(this.data.search.to_open.length) {
+          $.each(this.data.search.to_open, function (i, val) {
+            if(val == "#") { return true; }
+            if($(val).length && $(val).is(".jstree-closed")) { current.push(val); }
+            else { remaining.push(val); }
+          });
+          if(current.length) {
+            this.data.search.to_open = remaining;
+            $.each(current, function (i, val) { 
+              _this.open_node(val, function () { _this._search_open(true); }); 
+            });
+            done = false;
+          }
+        }
+        if(done) { this.search(this.data.search.str, true); }
+      }
+    }
+  });
 })(jQuery);
 //*/
 
@@ -2823,263 +2823,263 @@ THE SOFTWARE.
  * jsTree contextmenu plugin 1.0
  */
 (function ($) {
-	$.vakata.context = {
-		cnt		: $("<div id='vakata-contextmenu'>"),
-		vis		: false,
-		tgt		: false,
-		par		: false,
-		func	: false,
-		data	: false,
-		show	: function (s, t, x, y, d, p) {
-			var html = $.vakata.context.parse(s), h, w;
-			if(!html) { return; }
-			$.vakata.context.vis = true;
-			$.vakata.context.tgt = t;
-			$.vakata.context.par = p || t || null;
-			$.vakata.context.data = d || null;
-			$.vakata.context.cnt
-				.html(html)
-				.css({ "visibility" : "hidden", "display" : "block", "left" : 0, "top" : 0 });
-			h = $.vakata.context.cnt.height();
-			w = $.vakata.context.cnt.width();
-			if(x + w > $(document).width()) { 
-				x = $(document).width() - (w + 5); 
-				$.vakata.context.cnt.find("li > ul").addClass("right"); 
-			}
-			if(y + h > $(document).height()) { 
-				y = y - (h + t[0].offsetHeight); 
-				$.vakata.context.cnt.find("li > ul").addClass("bottom"); 
-			}
-
-			$.vakata.context.cnt
-				.css({ "left" : x, "top" : y })
-				.find("li:has(ul)")
-					.bind("mouseenter", function (e) { 
-						var w = $(document).width(),
-							h = $(document).height(),
-							ul = $(this).children("ul").show(); 
-						if(w !== $(document).width()) { ul.toggleClass("right"); }
-						if(h !== $(document).height()) { ul.toggleClass("bottom"); }
-					})
-					.bind("mouseleave", function (e) { 
-						$(this).children("ul").hide(); 
-					})
-					.end()
-				.css({ "visibility" : "visible" })
-				.show();
-			$(document).triggerHandler("context_show.vakata");
-		},
-		hide	: function () {
-			$.vakata.context.vis = false;
-			$.vakata.context.cnt.attr("class","").hide();
-			$(document).triggerHandler("context_hide.vakata");
-		},
-		parse	: function (s, is_callback) {
-			if(!s) { return false; }
-			var str = "",
-				tmp = false,
-				was_sep = true;
-			if(!is_callback) { $.vakata.context.func = {}; }
-			str += "<ul>";
-			$.each(s, function (i, val) {
-				if(!val) { return true; }
-				$.vakata.context.func[i] = val.action;
-				if(!was_sep && val.separator_before) {
-					str += "<li class='vakata-separator vakata-separator-before'></li>";
-				}
-				was_sep = false;
-				str += "<li class='" + (val._class || "") + (val._disabled ? " jstree-contextmenu-disabled " : "") + "'><ins ";
-				if(val.icon && val.icon.indexOf("/") === -1) { str += " class='" + val.icon + "' "; }
-				if(val.icon && val.icon.indexOf("/") !== -1) { str += " style='background:url(" + val.icon + ") center center no-repeat;' "; }
-				str += ">&#160;</ins><a href='#' rel='" + i + "'>";
-				if(val.submenu) {
-					str += "<span style='float:right;'>&raquo;</span>";
-				}
-				str += val.label + "</a>";
-				if(val.submenu) {
-					tmp = $.vakata.context.parse(val.submenu, true);
-					if(tmp) { str += tmp; }
-				}
-				str += "</li>";
-				if(val.separator_after) {
-					str += "<li class='vakata-separator vakata-separator-after'></li>";
-					was_sep = true;
-				}
-			});
-			str = str.replace(/<li class\='vakata-separator vakata-separator-after'\><\/li\>$/,"");
-			str += "</ul>";
-			return str.length > 10 ? str : false;
-		},
-		exec	: function (i) {
-			if($.isFunction($.vakata.context.func[i])) {
-				$.vakata.context.func[i].call($.vakata.context.data, $.vakata.context.par);
-				return true;
-			}
-			else { return false; }
-		}
-	};
-	$(function () {
-		var css_string = '' + 
-			'#vakata-contextmenu { display:none; position:absolute; margin:0; padding:0; min-width:180px; background:#ebebeb; border:1px solid silver; z-index:10000; *width:180px; } ' + 
-			'#vakata-contextmenu ul { min-width:180px; *width:180px; } ' + 
-			'#vakata-contextmenu ul, #vakata-contextmenu li { margin:0; padding:0; list-style-type:none; display:block; } ' + 
-			'#vakata-contextmenu li { line-height:20px; min-height:20px; position:relative; padding:0px; } ' + 
-			'#vakata-contextmenu li a { padding:1px 6px; line-height:17px; display:block; text-decoration:none; margin:1px 1px 0 1px; } ' + 
-			'#vakata-contextmenu li ins { float:left; width:16px; height:16px; text-decoration:none; margin-right:2px; } ' + 
-			'#vakata-contextmenu li a:hover, #vakata-contextmenu li.vakata-hover > a { background:gray; color:white; } ' + 
-			'#vakata-contextmenu li ul { display:none; position:absolute; top:-2px; left:100%; background:#ebebeb; border:1px solid gray; } ' + 
-			'#vakata-contextmenu .right { right:100%; left:auto; } ' + 
-			'#vakata-contextmenu .bottom { bottom:-1px; top:auto; } ' + 
-			'#vakata-contextmenu li.vakata-separator { min-height:0; height:1px; line-height:1px; font-size:1px; overflow:hidden; margin:0 2px; background:silver; /* border-top:1px solid #fefefe; */ padding:0; } ';
-		$.vakata.css.add_sheet({ str : css_string });
-		$.vakata.context.cnt
-			.delegate("a","click", function (e) { e.preventDefault(); })
-			.delegate("a","mouseup", function (e) {
-				if(!$(this).parent().hasClass("jstree-contextmenu-disabled") && $.vakata.context.exec($(this).attr("rel"))) {
-					$.vakata.context.hide();
-				}
-				else { $(this).blur(); }
-			})
-			.delegate("a","mouseover", function () {
-				$.vakata.context.cnt.find(".vakata-hover").removeClass("vakata-hover");
-			})
-			.appendTo("body");
-		$(document).bind("mousedown", function (e) { if($.vakata.context.vis && !$.contains($.vakata.context.cnt[0], e.target)) { $.vakata.context.hide(); } });
-		if(typeof $.hotkeys !== "undefined") {
-			$(document)
-				.bind("keydown", "up", function (e) { 
-					if($.vakata.context.vis) { 
-						var o = $.vakata.context.cnt.find("ul:visible").last().children(".vakata-hover").removeClass("vakata-hover").prevAll("li:not(.vakata-separator)").first();
-						if(!o.length) { o = $.vakata.context.cnt.find("ul:visible").last().children("li:not(.vakata-separator)").last(); }
-						o.addClass("vakata-hover");
-						e.stopImmediatePropagation(); 
-						e.preventDefault();
-					} 
-				})
-				.bind("keydown", "down", function (e) { 
-					if($.vakata.context.vis) { 
-						var o = $.vakata.context.cnt.find("ul:visible").last().children(".vakata-hover").removeClass("vakata-hover").nextAll("li:not(.vakata-separator)").first();
-						if(!o.length) { o = $.vakata.context.cnt.find("ul:visible").last().children("li:not(.vakata-separator)").first(); }
-						o.addClass("vakata-hover");
-						e.stopImmediatePropagation(); 
-						e.preventDefault();
-					} 
-				})
-				.bind("keydown", "right", function (e) { 
-					if($.vakata.context.vis) { 
-						$.vakata.context.cnt.find(".vakata-hover").children("ul").show().children("li:not(.vakata-separator)").removeClass("vakata-hover").first().addClass("vakata-hover");
-						e.stopImmediatePropagation(); 
-						e.preventDefault();
-					} 
-				})
-				.bind("keydown", "left", function (e) { 
-					if($.vakata.context.vis) { 
-						$.vakata.context.cnt.find(".vakata-hover").children("ul").hide().children(".vakata-separator").removeClass("vakata-hover");
-						e.stopImmediatePropagation(); 
-						e.preventDefault();
-					} 
-				})
-				.bind("keydown", "esc", function (e) { 
-					$.vakata.context.hide(); 
-					e.preventDefault();
-				})
-				.bind("keydown", "space", function (e) { 
-					$.vakata.context.cnt.find(".vakata-hover").last().children("a").click();
-					e.preventDefault();
-				});
-		}
-	});
-
-	$.jstree.plugin("contextmenu", {
-		__init : function () {
-			this.get_container()
-				.delegate("a", "contextmenu.jstree", $.proxy(function (e) {
-						e.preventDefault();
-						this.show_contextmenu(e.currentTarget, e.pageX, e.pageY);
-					}, this))
-				.bind("destroy.jstree", $.proxy(function () {
-						if(this.data.contextmenu) {
-							$.vakata.context.hide();
-						}
-					}, this));
-			$(document).bind("context_hide.vakata", $.proxy(function () { this.data.contextmenu = false; }, this));
-		},
-		defaults : { 
-			select_node : false, // requires UI plugin
-			show_at_node : true,
-			items : { // Could be a function that should return an object like this one
-				"create" : {
-					"separator_before"	: false,
-					"separator_after"	: true,
-					"label"				: "Create",
-					"action"			: function (obj) { this.create(obj); }
-				},
-				"rename" : {
-					"separator_before"	: false,
-					"separator_after"	: false,
-					"label"				: "Rename",
-					"action"			: function (obj) { this.rename(obj); }
-				},
-				"remove" : {
-					"separator_before"	: false,
-					"icon"				: false,
-					"separator_after"	: false,
-					"label"				: "Delete",
-					"action"			: function (obj) { this.remove(obj); }
-				},
-				"ccp" : {
-					"separator_before"	: true,
-					"icon"				: false,
-					"separator_after"	: false,
-					"label"				: "Edit",
-					"action"			: false,
-					"submenu" : { 
-						"cut" : {
-							"separator_before"	: false,
-							"separator_after"	: false,
-							"label"				: "Cut",
-							"action"			: function (obj) { this.cut(obj); }
-						},
-						"copy" : {
-							"separator_before"	: false,
-							"icon"				: false,
-							"separator_after"	: false,
-							"label"				: "Copy",
-							"action"			: function (obj) { this.copy(obj); }
-						},
-						"paste" : {
-							"separator_before"	: false,
-							"icon"				: false,
-							"separator_after"	: false,
-							"label"				: "Paste",
-							"action"			: function (obj) { this.paste(obj); }
-						}
-					}
-				}
-			}
-		},
-		_fn : {
-			show_contextmenu : function (obj, x, y) {
-				obj = this._get_node(obj);
-				var s = this.get_settings().contextmenu,
-					a = obj.children("a:visible:eq(0)"),
-					o = false;
-				if(s.select_node && this.data.ui && !this.is_selected(obj)) {
-					this.deselect_all();
-					this.select_node(obj, true);
-				}
-				if(s.show_at_node || typeof x === "undefined" || typeof y === "undefined") {
-					o = a.offset();
-					x = o.left;
-					y = o.top + this.data.core.li_height;
-				}
-				if($.isFunction(s.items)) { s.items = s.items.call(this, obj); }
-				this.data.contextmenu = true;
-				$.vakata.context.show(s.items, a, x, y, this, obj);
-				if(this.data.themes) { $.vakata.context.cnt.attr("class", "jstree-" + this.data.themes.theme + "-context"); }
-			}
-		}
-	});
+  $.vakata.context = {
+    cnt    : $("<div id='vakata-contextmenu'>"),
+    vis    : false,
+    tgt    : false,
+    par    : false,
+    func  : false,
+    data  : false,
+    show  : function (s, t, x, y, d, p) {
+      var html = $.vakata.context.parse(s), h, w;
+      if(!html) { return; }
+      $.vakata.context.vis = true;
+      $.vakata.context.tgt = t;
+      $.vakata.context.par = p || t || null;
+      $.vakata.context.data = d || null;
+      $.vakata.context.cnt
+        .html(html)
+        .css({ "visibility" : "hidden", "display" : "block", "left" : 0, "top" : 0 });
+      h = $.vakata.context.cnt.height();
+      w = $.vakata.context.cnt.width();
+      if(x + w > $(document).width()) { 
+        x = $(document).width() - (w + 5); 
+        $.vakata.context.cnt.find("li > ul").addClass("right"); 
+      }
+      if(y + h > $(document).height()) { 
+        y = y - (h + t[0].offsetHeight); 
+        $.vakata.context.cnt.find("li > ul").addClass("bottom"); 
+      }
+
+      $.vakata.context.cnt
+        .css({ "left" : x, "top" : y })
+        .find("li:has(ul)")
+          .bind("mouseenter", function (e) { 
+            var w = $(document).width(),
+              h = $(document).height(),
+              ul = $(this).children("ul").show(); 
+            if(w !== $(document).width()) { ul.toggleClass("right"); }
+            if(h !== $(document).height()) { ul.toggleClass("bottom"); }
+          })
+          .bind("mouseleave", function (e) { 
+            $(this).children("ul").hide(); 
+          })
+          .end()
+        .css({ "visibility" : "visible" })
+        .show();
+      $(document).triggerHandler("context_show.vakata");
+    },
+    hide  : function () {
+      $.vakata.context.vis = false;
+      $.vakata.context.cnt.attr("class","").hide();
+      $(document).triggerHandler("context_hide.vakata");
+    },
+    parse  : function (s, is_callback) {
+      if(!s) { return false; }
+      var str = "",
+        tmp = false,
+        was_sep = true;
+      if(!is_callback) { $.vakata.context.func = {}; }
+      str += "<ul>";
+      $.each(s, function (i, val) {
+        if(!val) { return true; }
+        $.vakata.context.func[i] = val.action;
+        if(!was_sep && val.separator_before) {
+          str += "<li class='vakata-separator vakata-separator-before'></li>";
+        }
+        was_sep = false;
+        str += "<li class='" + (val._class || "") + (val._disabled ? " jstree-contextmenu-disabled " : "") + "'><ins ";
+        if(val.icon && val.icon.indexOf("/") === -1) { str += " class='" + val.icon + "' "; }
+        if(val.icon && val.icon.indexOf("/") !== -1) { str += " style='background:url(" + val.icon + ") center center no-repeat;' "; }
+        str += ">&#160;</ins><a href='#' rel='" + i + "'>";
+        if(val.submenu) {
+          str += "<span style='float:right;'>&raquo;</span>";
+        }
+        str += val.label + "</a>";
+        if(val.submenu) {
+          tmp = $.vakata.context.parse(val.submenu, true);
+          if(tmp) { str += tmp; }
+        }
+        str += "</li>";
+        if(val.separator_after) {
+          str += "<li class='vakata-separator vakata-separator-after'></li>";
+          was_sep = true;
+        }
+      });
+      str = str.replace(/<li class\='vakata-separator vakata-separator-after'\><\/li\>$/,"");
+      str += "</ul>";
+      return str.length > 10 ? str : false;
+    },
+    exec  : function (i) {
+      if($.isFunction($.vakata.context.func[i])) {
+        $.vakata.context.func[i].call($.vakata.context.data, $.vakata.context.par);
+        return true;
+      }
+      else { return false; }
+    }
+  };
+  $(function () {
+    var css_string = '' + 
+      '#vakata-contextmenu { display:none; position:absolute; margin:0; padding:0; min-width:180px; background:#ebebeb; border:1px solid silver; z-index:10000; *width:180px; } ' + 
+      '#vakata-contextmenu ul { min-width:180px; *width:180px; } ' + 
+      '#vakata-contextmenu ul, #vakata-contextmenu li { margin:0; padding:0; list-style-type:none; display:block; } ' + 
+      '#vakata-contextmenu li { line-height:20px; min-height:20px; position:relative; padding:0px; } ' + 
+      '#vakata-contextmenu li a { padding:1px 6px; line-height:17px; display:block; text-decoration:none; margin:1px 1px 0 1px; } ' + 
+      '#vakata-contextmenu li ins { float:left; width:16px; height:16px; text-decoration:none; margin-right:2px; } ' + 
+      '#vakata-contextmenu li a:hover, #vakata-contextmenu li.vakata-hover > a { background:gray; color:white; } ' + 
+      '#vakata-contextmenu li ul { display:none; position:absolute; top:-2px; left:100%; background:#ebebeb; border:1px solid gray; } ' + 
+      '#vakata-contextmenu .right { right:100%; left:auto; } ' + 
+      '#vakata-contextmenu .bottom { bottom:-1px; top:auto; } ' + 
+      '#vakata-contextmenu li.vakata-separator { min-height:0; height:1px; line-height:1px; font-size:1px; overflow:hidden; margin:0 2px; background:silver; /* border-top:1px solid #fefefe; */ padding:0; } ';
+    $.vakata.css.add_sheet({ str : css_string });
+    $.vakata.context.cnt
+      .delegate("a","click", function (e) { e.preventDefault(); })
+      .delegate("a","mouseup", function (e) {
+        if(!$(this).parent().hasClass("jstree-contextmenu-disabled") && $.vakata.context.exec($(this).attr("rel"))) {
+          $.vakata.context.hide();
+        }
+        else { $(this).blur(); }
+      })
+      .delegate("a","mouseover", function () {
+        $.vakata.context.cnt.find(".vakata-hover").removeClass("vakata-hover");
+      })
+      .appendTo("body");
+    $(document).bind("mousedown", function (e) { if($.vakata.context.vis && !$.contains($.vakata.context.cnt[0], e.target)) { $.vakata.context.hide(); } });
+    if(typeof $.hotkeys !== "undefined") {
+      $(document)
+        .bind("keydown", "up", function (e) { 
+          if($.vakata.context.vis) { 
+            var o = $.vakata.context.cnt.find("ul:visible").last().children(".vakata-hover").removeClass("vakata-hover").prevAll("li:not(.vakata-separator)").first();
+            if(!o.length) { o = $.vakata.context.cnt.find("ul:visible").last().children("li:not(.vakata-separator)").last(); }
+            o.addClass("vakata-hover");
+            e.stopImmediatePropagation(); 
+            e.preventDefault();
+          } 
+        })
+        .bind("keydown", "down", function (e) { 
+          if($.vakata.context.vis) { 
+            var o = $.vakata.context.cnt.find("ul:visible").last().children(".vakata-hover").removeClass("vakata-hover").nextAll("li:not(.vakata-separator)").first();
+            if(!o.length) { o = $.vakata.context.cnt.find("ul:visible").last().children("li:not(.vakata-separator)").first(); }
+            o.addClass("vakata-hover");
+            e.stopImmediatePropagation(); 
+            e.preventDefault();
+          } 
+        })
+        .bind("keydown", "right", function (e) { 
+          if($.vakata.context.vis) { 
+            $.vakata.context.cnt.find(".vakata-hover").children("ul").show().children("li:not(.vakata-separator)").removeClass("vakata-hover").first().addClass("vakata-hover");
+            e.stopImmediatePropagation(); 
+            e.preventDefault();
+          } 
+        })
+        .bind("keydown", "left", function (e) { 
+          if($.vakata.context.vis) { 
+            $.vakata.context.cnt.find(".vakata-hover").children("ul").hide().children(".vakata-separator").removeClass("vakata-hover");
+            e.stopImmediatePropagation(); 
+            e.preventDefault();
+          } 
+        })
+        .bind("keydown", "esc", function (e) { 
+          $.vakata.context.hide(); 
+          e.preventDefault();
+        })
+        .bind("keydown", "space", function (e) { 
+          $.vakata.context.cnt.find(".vakata-hover").last().children("a").click();
+          e.preventDefault();
+        });
+    }
+  });
+
+  $.jstree.plugin("contextmenu", {
+    __init : function () {
+      this.get_container()
+        .delegate("a", "contextmenu.jstree", $.proxy(function (e) {
+            e.preventDefault();
+            this.show_contextmenu(e.currentTarget, e.pageX, e.pageY);
+          }, this))
+        .bind("destroy.jstree", $.proxy(function () {
+            if(this.data.contextmenu) {
+              $.vakata.context.hide();
+            }
+          }, this));
+      $(document).bind("context_hide.vakata", $.proxy(function () { this.data.contextmenu = false; }, this));
+    },
+    defaults : { 
+      select_node : false, // requires UI plugin
+      show_at_node : true,
+      items : { // Could be a function that should return an object like this one
+        "create" : {
+          "separator_before"  : false,
+          "separator_after"  : true,
+          "label"        : "Create",
+          "action"      : function (obj) { this.create(obj); }
+        },
+        "rename" : {
+          "separator_before"  : false,
+          "separator_after"  : false,
+          "label"        : "Rename",
+          "action"      : function (obj) { this.rename(obj); }
+        },
+        "remove" : {
+          "separator_before"  : false,
+          "icon"        : false,
+          "separator_after"  : false,
+          "label"        : "Delete",
+          "action"      : function (obj) { this.remove(obj); }
+        },
+        "ccp" : {
+          "separator_before"  : true,
+          "icon"        : false,
+          "separator_after"  : false,
+          "label"        : "Edit",
+          "action"      : false,
+          "submenu" : { 
+            "cut" : {
+              "separator_before"  : false,
+              "separator_after"  : false,
+              "label"        : "Cut",
+              "action"      : function (obj) { this.cut(obj); }
+            },
+            "copy" : {
+              "separator_before"  : false,
+              "icon"        : false,
+              "separator_after"  : false,
+              "label"        : "Copy",
+              "action"      : function (obj) { this.copy(obj); }
+            },
+            "paste" : {
+              "separator_before"  : false,
+              "icon"        : false,
+              "separator_after"  : false,
+              "label"        : "Paste",
+              "action"      : function (obj) { this.paste(obj); }
+            }
+          }
+        }
+      }
+    },
+    _fn : {
+      show_contextmenu : function (obj, x, y) {
+        obj = this._get_node(obj);
+        var s = this.get_settings().contextmenu,
+          a = obj.children("a:visible:eq(0)"),
+          o = false;
+        if(s.select_node && this.data.ui && !this.is_selected(obj)) {
+          this.deselect_all();
+          this.select_node(obj, true);
+        }
+        if(s.show_at_node || typeof x === "undefined" || typeof y === "undefined") {
+          o = a.offset();
+          x = o.left;
+          y = o.top + this.data.core.li_height;
+        }
+        if($.isFunction(s.items)) { s.items = s.items.call(this, obj); }
+        this.data.contextmenu = true;
+        $.vakata.context.show(s.items, a, x, y, this, obj);
+        if(this.data.themes) { $.vakata.context.cnt.attr("class", "jstree-" + this.data.themes.theme + "-context"); }
+      }
+    }
+  });
 })(jQuery);
 //*/
 
@@ -3090,178 +3090,178 @@ THE SOFTWARE.
  * According to the type setting the node may get custom icon/validation rules
  */
 (function ($) {
-	$.jstree.plugin("types", {
-		__init : function () {
-			var s = this._get_settings().types;
-			this.data.types.attach_to = [];
-			this.get_container()
-				.bind("init.jstree", $.proxy(function () { 
-						var types = s.types, 
-							attr  = s.type_attr, 
-							icons_css = "", 
-							_this = this;
-
-						$.each(types, function (i, tp) {
-							$.each(tp, function (k, v) { 
-								if(!/^(max_depth|max_children|icon|valid_children)$/.test(k)) { _this.data.types.attach_to.push(k); }
-							});
-							if(!tp.icon) { return true; }
-							if( tp.icon.image || tp.icon.position) {
-								if(i == "default")	{ icons_css += '.jstree-' + _this.get_index() + ' a > .jstree-icon { '; }
-								else				{ icons_css += '.jstree-' + _this.get_index() + ' li[' + attr + '=' + i + '] > a > .jstree-icon { '; }
-								if(tp.icon.image)	{ icons_css += ' background-image:url(' + tp.icon.image + '); '; }
-								if(tp.icon.position){ icons_css += ' background-position:' + tp.icon.position + '; '; }
-								else				{ icons_css += ' background-position:0 0; '; }
-								icons_css += '} ';
-							}
-						});
-						if(icons_css != "") { $.vakata.css.add_sheet({ 'str' : icons_css }); }
-					}, this))
-				.bind("before.jstree", $.proxy(function (e, data) { 
-						if($.inArray(data.func, this.data.types.attach_to) !== -1) {
-							var s = this._get_settings().types.types,
-								t = this._get_type(data.args[0]);
-							if(
-								( 
-									(s[t] && typeof s[t][data.func] !== "undefined") || 
-									(s["default"] && typeof s["default"][data.func] !== "undefined")
-								) && !this._check(data.func, data.args[0])
-							) {
-								e.stopImmediatePropagation();
-								return false;
-							}
-						}
-					}, this));
-		},
-		defaults : {
-			// defines maximum number of root nodes (-1 means unlimited, -2 means disable max_children checking)
-			max_children		: -1,
-			// defines the maximum depth of the tree (-1 means unlimited, -2 means disable max_depth checking)
-			max_depth			: -1,
-			// defines valid node types for the root nodes
-			valid_children		: "all",
-
-			// where is the type stores (the rel attribute of the LI element)
-			type_attr : "rel",
-			// a list of types
-			types : {
-				// the default type
-				"default" : {
-					"max_children"	: -1,
-					"max_depth"		: -1,
-					"valid_children": "all"
-
-					// Bound functions - you can bind any other function here (using boolean or function)
-					//"select_node"	: true,
-					//"open_node"	: true,
-					//"close_node"	: true,
-					//"create_node"	: true,
-					//"delete_node"	: true
-				}
-			}
-		},
-		_fn : {
-			_get_type : function (obj) {
-				obj = this._get_node(obj);
-				return (!obj || !obj.length) ? false : obj.attr(this._get_settings().types.type_attr) || "default";
-			},
-			set_type : function (str, obj) {
-				obj = this._get_node(obj);
-				return (!obj.length || !str) ? false : obj.attr(this._get_settings().types.type_attr, str);
-			},
-			_check : function (rule, obj, opts) {
-				var v = false, t = this._get_type(obj), d = 0, _this = this, s = this._get_settings().types;
-				if(obj === -1) { 
-					if(!!s[rule]) { v = s[rule]; }
-					else { return; }
-				}
-				else {
-					if(t === false) { return; }
-					if(!!s.types[t] && !!s.types[t][rule]) { v = s.types[t][rule]; }
-					else if(!!s.types["default"] && !!s.types["default"][rule]) { v = s.types["default"][rule]; }
-				}
-				if($.isFunction(v)) { v = v.call(this, obj); }
-				if(rule === "max_depth" && obj !== -1 && opts !== false && s.max_depth !== -2 && v !== 0) {
-					// also include the node itself - otherwise if root node it is not checked
-					this._get_node(obj).children("a:eq(0)").parentsUntil(".jstree","li").each(function (i) {
-						// check if current depth already exceeds global tree depth
-						if(s.max_depth !== -1 && s.max_depth - (i + 1) <= 0) { v = 0; return false; }
-						d = (i === 0) ? v : _this._check(rule, this, false);
-						// check if current node max depth is already matched or exceeded
-						if(d !== -1 && d - (i + 1) <= 0) { v = 0; return false; }
-						// otherwise - set the max depth to the current value minus current depth
-						if(d >= 0 && (d - (i + 1) < v || v < 0) ) { v = d - (i + 1); }
-						// if the global tree depth exists and it minus the nodes calculated so far is less than `v` or `v` is unlimited
-						if(s.max_depth >= 0 && (s.max_depth - (i + 1) < v || v < 0) ) { v = s.max_depth - (i + 1); }
-					});
-				}
-				return v;
-			},
-			check_move : function () {
-				if(!this.__call_old()) { return false; }
-				var m  = this._get_move(),
-					s  = m.rt._get_settings().types,
-					mc = m.rt._check("max_children", m.cr),
-					md = m.rt._check("max_depth", m.cr),
-					vc = m.rt._check("valid_children", m.cr),
-					ch = 0, d = 1, t;
-
-				if(vc === "none") { return false; } 
-				if($.isArray(vc) && m.ot && m.ot._get_type) {
-					m.o.each(function () {
-						if($.inArray(m.ot._get_type(this), vc) === -1) { d = false; return false; }
-					});
-					if(d === false) { return false; }
-				}
-				if(s.max_children !== -2 && mc !== -1) {
-					ch = m.cr === -1 ? this.get_container().children("> ul > li").not(m.o).length : m.cr.children("> ul > li").not(m.o).length;
-					if(ch + m.o.length > mc) { return false; }
-				}
-				if(s.max_depth !== -2 && md !== -1) {
-					d = 0;
-					if(md === 0) { return false; }
-					if(typeof m.o.d === "undefined") {
-						// TODO: deal with progressive rendering and async when checking max_depth (how to know the depth of the moved node)
-						t = m.o;
-						while(t.length > 0) {
-							t = t.find("> ul > li");
-							d ++;
-						}
-						m.o.d = d;
-					}
-					if(md - m.o.d < 0) { return false; }
-				}
-				return true;
-			},
-			create_node : function (obj, position, js, callback, is_loaded, skip_check) {
-				if(!skip_check && (is_loaded || this._is_loaded(obj))) {
-					var p  = (position && position.match(/^before|after$/i) && obj !== -1) ? this._get_parent(obj) : this._get_node(obj),
-						s  = this._get_settings().types,
-						mc = this._check("max_children", p),
-						md = this._check("max_depth", p),
-						vc = this._check("valid_children", p),
-						ch;
-					if(!js) { js = {}; }
-					if(vc === "none") { return false; } 
-					if($.isArray(vc)) {
-						if(!js.attr || !js.attr[s.type_attr]) { 
-							if(!js.attr) { js.attr = {}; }
-							js.attr[s.type_attr] = vc[0]; 
-						}
-						else {
-							if($.inArray(js.attr[s.type_attr], vc) === -1) { return false; }
-						}
-					}
-					if(s.max_children !== -2 && mc !== -1) {
-						ch = p === -1 ? this.get_container().children("> ul > li").length : p.children("> ul > li").length;
-						if(ch + 1 > mc) { return false; }
-					}
-					if(s.max_depth !== -2 && md !== -1 && (md - 1) < 0) { return false; }
-				}
-				return this.__call_old(true, obj, position, js, callback, is_loaded, skip_check);
-			}
-		}
-	});
+  $.jstree.plugin("types", {
+    __init : function () {
+      var s = this._get_settings().types;
+      this.data.types.attach_to = [];
+      this.get_container()
+        .bind("init.jstree", $.proxy(function () { 
+            var types = s.types, 
+              attr  = s.type_attr, 
+              icons_css = "", 
+              _this = this;
+
+            $.each(types, function (i, tp) {
+              $.each(tp, function (k, v) { 
+                if(!/^(max_depth|max_children|icon|valid_children)$/.test(k)) { _this.data.types.attach_to.push(k); }
+              });
+              if(!tp.icon) { return true; }
+              if( tp.icon.image || tp.icon.position) {
+                if(i == "default")  { icons_css += '.jstree-' + _this.get_index() + ' a > .jstree-icon { '; }
+                else        { icons_css += '.jstree-' + _this.get_index() + ' li[' + attr + '=' + i + '] > a > .jstree-icon { '; }
+                if(tp.icon.image)  { icons_css += ' background-image:url(' + tp.icon.image + '); '; }
+                if(tp.icon.position){ icons_css += ' background-position:' + tp.icon.position + '; '; }
+                else        { icons_css += ' background-position:0 0; '; }
+                icons_css += '} ';
+              }
+            });
+            if(icons_css != "") { $.vakata.css.add_sheet({ 'str' : icons_css }); }
+          }, this))
+        .bind("before.jstree", $.proxy(function (e, data) { 
+            if($.inArray(data.func, this.data.types.attach_to) !== -1) {
+              var s = this._get_settings().types.types,
+                t = this._get_type(data.args[0]);
+              if(
+                ( 
+                  (s[t] && typeof s[t][data.func] !== "undefined") || 
+                  (s["default"] && typeof s["default"][data.func] !== "undefined")
+                ) && !this._check(data.func, data.args[0])
+              ) {
+                e.stopImmediatePropagation();
+                return false;
+              }
+            }
+          }, this));
+    },
+    defaults : {
+      // defines maximum number of root nodes (-1 means unlimited, -2 means disable max_children checking)
+      max_children    : -1,
+      // defines the maximum depth of the tree (-1 means unlimited, -2 means disable max_depth checking)
+      max_depth      : -1,
+      // defines valid node types for the root nodes
+      valid_children    : "all",
+
+      // where is the type stores (the rel attribute of the LI element)
+      type_attr : "rel",
+      // a list of types
+      types : {
+        // the default type
+        "default" : {
+          "max_children"  : -1,
+          "max_depth"    : -1,
+          "valid_children": "all"
+
+          // Bound functions - you can bind any other function here (using boolean or function)
+          //"select_node"  : true,
+          //"open_node"  : true,
+          //"close_node"  : true,
+          //"create_node"  : true,
+          //"delete_node"  : true
+        }
+      }
+    },
+    _fn : {
+      _get_type : function (obj) {
+        obj = this._get_node(obj);
+        return (!obj || !obj.length) ? false : obj.attr(this._get_settings().types.type_attr) || "default";
+      },
+      set_type : function (str, obj) {
+        obj = this._get_node(obj);
+        return (!obj.length || !str) ? false : obj.attr(this._get_settings().types.type_attr, str);
+      },
+      _check : function (rule, obj, opts) {
+        var v = false, t = this._get_type(obj), d = 0, _this = this, s = this._get_settings().types;
+        if(obj === -1) { 
+          if(!!s[rule]) { v = s[rule]; }
+          else { return; }
+        }
+        else {
+          if(t === false) { return; }
+          if(!!s.types[t] && !!s.types[t][rule]) { v = s.types[t][rule]; }
+          else if(!!s.types["default"] && !!s.types["default"][rule]) { v = s.types["default"][rule]; }
+        }
+        if($.isFunction(v)) { v = v.call(this, obj); }
+        if(rule === "max_depth" && obj !== -1 && opts !== false && s.max_depth !== -2 && v !== 0) {
+          // also include the node itself - otherwise if root node it is not checked
+          this._get_node(obj).children("a:eq(0)").parentsUntil(".jstree","li").each(function (i) {
+            // check if current depth already exceeds global tree depth
+            if(s.max_depth !== -1 && s.max_depth - (i + 1) <= 0) { v = 0; return false; }
+            d = (i === 0) ? v : _this._check(rule, this, false);
+            // check if current node max depth is already matched or exceeded
+            if(d !== -1 && d - (i + 1) <= 0) { v = 0; return false; }
+            // otherwise - set the max depth to the current value minus current depth
+            if(d >= 0 && (d - (i + 1) < v || v < 0) ) { v = d - (i + 1); }
+            // if the global tree depth exists and it minus the nodes calculated so far is less than `v` or `v` is unlimited
+            if(s.max_depth >= 0 && (s.max_depth - (i + 1) < v || v < 0) ) { v = s.max_depth - (i + 1); }
+          });
+        }
+        return v;
+      },
+      check_move : function () {
+        if(!this.__call_old()) { return false; }
+        var m  = this._get_move(),
+          s  = m.rt._get_settings().types,
+          mc = m.rt._check("max_children", m.cr),
+          md = m.rt._check("max_depth", m.cr),
+          vc = m.rt._check("valid_children", m.cr),
+          ch = 0, d = 1, t;
+
+        if(vc === "none") { return false; } 
+        if($.isArray(vc) && m.ot && m.ot._get_type) {
+          m.o.each(function () {
+            if($.inArray(m.ot._get_type(this), vc) === -1) { d = false; return false; }
+          });
+          if(d === false) { return false; }
+        }
+        if(s.max_children !== -2 && mc !== -1) {
+          ch = m.cr === -1 ? this.get_container().children("> ul > li").not(m.o).length : m.cr.children("> ul > li").not(m.o).length;
+          if(ch + m.o.length > mc) { return false; }
+        }
+        if(s.max_depth !== -2 && md !== -1) {
+          d = 0;
+          if(md === 0) { return false; }
+          if(typeof m.o.d === "undefined") {
+            // TODO: deal with progressive rendering and async when checking max_depth (how to know the depth of the moved node)
+            t = m.o;
+            while(t.length > 0) {
+              t = t.find("> ul > li");
+              d ++;
+            }
+            m.o.d = d;
+          }
+          if(md - m.o.d < 0) { return false; }
+        }
+        return true;
+      },
+      create_node : function (obj, position, js, callback, is_loaded, skip_check) {
+        if(!skip_check && (is_loaded || this._is_loaded(obj))) {
+          var p  = (position && position.match(/^before|after$/i) && obj !== -1) ? this._get_parent(obj) : this._get_node(obj),
+            s  = this._get_settings().types,
+            mc = this._check("max_children", p),
+            md = this._check("max_depth", p),
+            vc = this._check("valid_children", p),
+            ch;
+          if(!js) { js = {}; }
+          if(vc === "none") { return false; } 
+          if($.isArray(vc)) {
+            if(!js.attr || !js.attr[s.type_attr]) { 
+              if(!js.attr) { js.attr = {}; }
+              js.attr[s.type_attr] = vc[0]; 
+            }
+            else {
+              if($.inArray(js.attr[s.type_attr], vc) === -1) { return false; }
+            }
+          }
+          if(s.max_children !== -2 && mc !== -1) {
+            ch = p === -1 ? this.get_container().children("> ul > li").length : p.children("> ul > li").length;
+            if(ch + 1 > mc) { return false; }
+          }
+          if(s.max_depth !== -2 && md !== -1 && (md - 1) < 0) { return false; }
+        }
+        return this.__call_old(true, obj, position, js, callback, is_loaded, skip_check);
+      }
+    }
+  });
 })(jQuery);
 //*/
 
@@ -3270,118 +3270,118 @@ THE SOFTWARE.
  * The HTML data store. Datastores are build by replacing the `load_node` and `_is_loaded` functions.
  */
 (function ($) {
-	$.jstree.plugin("html_data", {
-		__init : function () { 
-			// this used to use html() and clean the whitespace, but this way any attached data was lost
-			this.data.html_data.original_container_html = this.get_container().find(" > ul > li").clone(true);
-			// remove white space from LI node - otherwise nodes appear a bit to the right
-			this.data.html_data.original_container_html.find("li").andSelf().contents().filter(function() { return this.nodeType == 3; }).remove();
-		},
-		defaults : { 
-			data : false,
-			ajax : false,
-			correct_state : true
-		},
-		_fn : {
-			load_node : function (obj, s_call, e_call) { var _this = this; this.load_node_html(obj, function () { _this.__callback({ "obj" : obj }); s_call.call(this); }, e_call); },
-			_is_loaded : function (obj) { 
-				obj = this._get_node(obj); 
-				return obj == -1 || !obj || !this._get_settings().html_data.ajax || obj.is(".jstree-open, .jstree-leaf") || obj.children("ul").children("li").size() > 0;
-			},
-			load_node_html : function (obj, s_call, e_call) {
-				var d,
-					s = this.get_settings().html_data,
-					error_func = function () {},
-					success_func = function () {};
-				obj = this._get_node(obj);
-				if(obj && obj !== -1) {
-					if(obj.data("jstree-is-loading")) { return; }
-					else { obj.data("jstree-is-loading",true); }
-				}
-				switch(!0) {
-					case (!s.data && !s.ajax):
-						if(!obj || obj == -1) {
-							this.get_container()
-								.children("ul").empty()
-								.append(this.data.html_data.original_container_html)
-								.find("li, a").filter(function () { return this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end()
-								.filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon");
-							this.clean_node();
-						}
-						if(s_call) { s_call.call(this); }
-						break;
-					case (!!s.data && !s.ajax) || (!!s.data && !!s.ajax && (!obj || obj === -1)):
-						if(!obj || obj == -1) {
-							d = $(s.data);
-							if(!d.is("ul")) { d = $("<ul>").append(d); }
-							this.get_container()
-								.children("ul").empty().append(d.children())
-								.find("li, a").filter(function () { return this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end()
-								.filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon");
-							this.clean_node();
-						}
-						if(s_call) { s_call.call(this); }
-						break;
-					case (!s.data && !!s.ajax) || (!!s.data && !!s.ajax && obj && obj !== -1):
-						obj = this._get_node(obj);
-						error_func = function (x, t, e) {
-							var ef = this.get_settings().html_data.ajax.error; 
-							if(ef) { ef.call(this, x, t, e); }
-							if(obj != -1 && obj.length) {
-								obj.children(".jstree-loading").removeClass("jstree-loading");
-								obj.data("jstree-is-loading",false);
-								if(t === "success" && s.correct_state) { obj.removeClass("jstree-open jstree-closed").addClass("jstree-leaf"); }
-							}
-							else {
-								if(t === "success" && s.correct_state) { this.get_container().children("ul").empty(); }
-							}
-							if(e_call) { e_call.call(this); }
-						};
-						success_func = function (d, t, x) {
-							var sf = this.get_settings().html_data.ajax.success; 
-							if(sf) { d = sf.call(this,d,t,x) || d; }
-							if(d == "") {
-								return error_func.call(this, x, t, "");
-							}
-							if(d) {
-								d = $(d);
-								if(!d.is("ul")) { d = $("<ul>").append(d); }
-								if(obj == -1 || !obj) { this.get_container().children("ul").empty().append(d.children()).find("li, a").filter(function () { return this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end().filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon"); }
-								else { obj.children(".jstree-loading").removeClass("jstree-loading"); obj.append(d).find("li, a").filter(function () { return this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end().filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon"); obj.data("jstree-is-loading",false); }
-								this.clean_node(obj);
-								if(s_call) { s_call.call(this); }
-							}
-							else {
-								if(obj && obj !== -1) {
-									obj.children(".jstree-loading").removeClass("jstree-loading");
-									obj.data("jstree-is-loading",false);
-									if(s.correct_state) { 
-										obj.removeClass("jstree-open jstree-closed").addClass("jstree-leaf"); 
-										if(s_call) { s_call.call(this); } 
-									}
-								}
-								else {
-									if(s.correct_state) { 
-										this.get_container().children("ul").empty();
-										if(s_call) { s_call.call(this); } 
-									}
-								}
-							}
-						};
-						s.ajax.context = this;
-						s.ajax.error = error_func;
-						s.ajax.success = success_func;
-						if(!s.ajax.dataType) { s.ajax.dataType = "html"; }
-						if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, obj); }
-						if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, obj); }
-						$.ajax(s.ajax);
-						break;
-				}
-			}
-		}
-	});
-	// include the HTML data plugin by default
-	$.jstree.defaults.plugins.push("html_data");
+  $.jstree.plugin("html_data", {
+    __init : function () { 
+      // this used to use html() and clean the whitespace, but this way any attached data was lost
+      this.data.html_data.original_container_html = this.get_container().find(" > ul > li").clone(true);
+      // remove white space from LI node - otherwise nodes appear a bit to the right
+      this.data.html_data.original_container_html.find("li").andSelf().contents().filter(function() { return this.nodeType == 3; }).remove();
+    },
+    defaults : { 
+      data : false,
+      ajax : false,
+      correct_state : true
+    },
+    _fn : {
+      load_node : function (obj, s_call, e_call) { var _this = this; this.load_node_html(obj, function () { _this.__callback({ "obj" : obj }); s_call.call(this); }, e_call); },
+      _is_loaded : function (obj) { 
+        obj = this._get_node(obj); 
+        return obj == -1 || !obj || !this._get_settings().html_data.ajax || obj.is(".jstree-open, .jstree-leaf") || obj.children("ul").children("li").size() > 0;
+      },
+      load_node_html : function (obj, s_call, e_call) {
+        var d,
+          s = this.get_settings().html_data,
+          error_func = function () {},
+          success_func = function () {};
+        obj = this._get_node(obj);
+        if(obj && obj !== -1) {
+          if(obj.data("jstree-is-loading")) { return; }
+          else { obj.data("jstree-is-loading",true); }
+        }
+        switch(!0) {
+          case (!s.data && !s.ajax):
+            if(!obj || obj == -1) {
+              this.get_container()
+                .children("ul").empty()
+                .append(this.data.html_data.original_container_html)
+                .find("li, a").filter(function () { return this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end()
+                .filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon");
+              this.clean_node();
+            }
+            if(s_call) { s_call.call(this); }
+            break;
+          case (!!s.data && !s.ajax) || (!!s.data && !!s.ajax && (!obj || obj === -1)):
+            if(!obj || obj == -1) {
+              d = $(s.data);
+              if(!d.is("ul")) { d = $("<ul>").append(d); }
+              this.get_container()
+                .children("ul").empty().append(d.children())
+                .find("li, a").filter(function () { return this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end()
+                .filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon");
+              this.clean_node();
+            }
+            if(s_call) { s_call.call(this); }
+            break;
+          case (!s.data && !!s.ajax) || (!!s.data && !!s.ajax && obj && obj !== -1):
+            obj = this._get_node(obj);
+            error_func = function (x, t, e) {
+              var ef = this.get_settings().html_data.ajax.error; 
+              if(ef) { ef.call(this, x, t, e); }
+              if(obj != -1 && obj.length) {
+                obj.children(".jstree-loading").removeClass("jstree-loading");
+                obj.data("jstree-is-loading",false);
+                if(t === "success" && s.correct_state) { obj.removeClass("jstree-open jstree-closed").addClass("jstree-leaf"); }
+              }
+              else {
+                if(t === "success" && s.correct_state) { this.get_container().children("ul").empty(); }
+              }
+              if(e_call) { e_call.call(this); }
+            };
+            success_func = function (d, t, x) {
+              var sf = this.get_settings().html_data.ajax.success; 
+              if(sf) { d = sf.call(this,d,t,x) || d; }
+              if(d == "") {
+                return error_func.call(this, x, t, "");
+              }
+              if(d) {
+                d = $(d);
+                if(!d.is("ul")) { d = $("<ul>").append(d); }
+                if(obj == -1 || !obj) { this.get_container().children("ul").empty().append(d.children()).find("li, a").filter(function () { return this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end().filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon"); }
+                else { obj.children(".jstree-loading").removeClass("jstree-loading"); obj.append(d).find("li, a").filter(function () { return this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end().filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon"); obj.data("jstree-is-loading",false); }
+                this.clean_node(obj);
+                if(s_call) { s_call.call(this); }
+              }
+              else {
+                if(obj && obj !== -1) {
+                  obj.children(".jstree-loading").removeClass("jstree-loading");
+                  obj.data("jstree-is-loading",false);
+                  if(s.correct_state) { 
+                    obj.removeClass("jstree-open jstree-closed").addClass("jstree-leaf"); 
+                    if(s_call) { s_call.call(this); } 
+                  }
+                }
+                else {
+                  if(s.correct_state) { 
+                    this.get_container().children("ul").empty();
+                    if(s_call) { s_call.call(this); } 
+                  }
+                }
+              }
+            };
+            s.ajax.context = this;
+            s.ajax.error = error_func;
+            s.ajax.success = success_func;
+            if(!s.ajax.dataType) { s.ajax.dataType = "html"; }
+            if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, obj); }
+            if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, obj); }
+            $.ajax(s.ajax);
+            break;
+        }
+      }
+    }
+  });
+  // include the HTML data plugin by default
+  $.jstree.defaults.plugins.push("html_data");
 })(jQuery);
 //*/
 
@@ -3390,73 +3390,73 @@ THE SOFTWARE.
  * Adds support for jQuery UI themes. Include this at the end of your plugins list, also make sure "themes" is not included.
  */
 (function ($) {
-	$.jstree.plugin("themeroller", {
-		__init : function () {
-			var s = this._get_settings().themeroller;
-			this.get_container()
-				.addClass("ui-widget-content")
-				.delegate("a","mouseenter.jstree", function () {
-					$(this).addClass(s.item_h);
-				})
-				.delegate("a","mouseleave.jstree", function () {
-					$(this).removeClass(s.item_h);
-				})
-				.bind("open_node.jstree create_node.jstree", $.proxy(function (e, data) { 
-						this._themeroller(data.rslt.obj);
-					}, this))
-				.bind("loaded.jstree refresh.jstree", $.proxy(function (e) {
-						this._themeroller();
-					}, this))
-				.bind("close_node.jstree", $.proxy(function (e, data) {
-						data.rslt.obj.children("ins").removeClass(s.opened).addClass(s.closed);
-					}, this))
-				.bind("select_node.jstree", $.proxy(function (e, data) {
-						data.rslt.obj.children("a").addClass(s.item_a);
-					}, this))
-				.bind("deselect_node.jstree deselect_all.jstree", $.proxy(function (e, data) {
-						this.get_container()
-							.find("." + s.item_a).removeClass(s.item_a).end()
-							.find(".jstree-clicked").addClass(s.item_a);
-					}, this))
-				.bind("move_node.jstree", $.proxy(function (e, data) {
-						this._themeroller(data.rslt.o);
-					}, this));
-		},
-		__destroy : function () {
-			var s = this._get_settings().themeroller,
-				c = [ "ui-icon" ];
-			$.each(s, function (i, v) {
-				v = v.split(" ");
-				if(v.length) { c = c.concat(v); }
-			});
-			this.get_container()
-				.removeClass("ui-widget-content")
-				.find("." + c.join(", .")).removeClass(c.join(" "));
-		},
-		_fn : {
-			_themeroller : function (obj) {
-				var s = this._get_settings().themeroller;
-				obj = !obj || obj == -1 ? this.get_container() : this._get_node(obj).parent();
-				obj
-					.find("li.jstree-closed > ins.jstree-icon").removeClass(s.opened).addClass("ui-icon " + s.closed).end()
-					.find("li.jstree-open > ins.jstree-icon").removeClass(s.closed).addClass("ui-icon " + s.opened).end()
-					.find("a").addClass(s.item)
-						.children("ins.jstree-icon").addClass("ui-icon " + s.item_icon);
-			}
-		},
-		defaults : {
-			"opened" : "ui-icon-triangle-1-se",
-			"closed" : "ui-icon-triangle-1-e",
-			"item" : "ui-state-default",
-			"item_h" : "ui-state-hover",
-			"item_a" : "ui-state-active",
-			"item_icon" : "ui-icon-folder-collapsed"
-		}
-	});
-	$(function() {
-		var css_string = '.jstree .ui-icon { overflow:visible; } .jstree a { padding:0 2px; }';
-		$.vakata.css.add_sheet({ str : css_string });
-	});
+  $.jstree.plugin("themeroller", {
+    __init : function () {
+      var s = this._get_settings().themeroller;
+      this.get_container()
+        .addClass("ui-widget-content")
+        .delegate("a","mouseenter.jstree", function () {
+          $(this).addClass(s.item_h);
+        })
+        .delegate("a","mouseleave.jstree", function () {
+          $(this).removeClass(s.item_h);
+        })
+        .bind("open_node.jstree create_node.jstree", $.proxy(function (e, data) { 
+            this._themeroller(data.rslt.obj);
+          }, this))
+        .bind("loaded.jstree refresh.jstree", $.proxy(function (e) {
+            this._themeroller();
+          }, this))
+        .bind("close_node.jstree", $.proxy(function (e, data) {
+            data.rslt.obj.children("ins").removeClass(s.opened).addClass(s.closed);
+          }, this))
+        .bind("select_node.jstree", $.proxy(function (e, data) {
+            data.rslt.obj.children("a").addClass(s.item_a);
+          }, this))
+        .bind("deselect_node.jstree deselect_all.jstree", $.proxy(function (e, data) {
+            this.get_container()
+              .find("." + s.item_a).removeClass(s.item_a).end()
+              .find(".jstree-clicked").addClass(s.item_a);
+          }, this))
+        .bind("move_node.jstree", $.proxy(function (e, data) {
+            this._themeroller(data.rslt.o);
+          }, this));
+    },
+    __destroy : function () {
+      var s = this._get_settings().themeroller,
+        c = [ "ui-icon" ];
+      $.each(s, function (i, v) {
+        v = v.split(" ");
+        if(v.length) { c = c.concat(v); }
+      });
+      this.get_container()
+        .removeClass("ui-widget-content")
+        .find("." + c.join(", .")).removeClass(c.join(" "));
+    },
+    _fn : {
+      _themeroller : function (obj) {
+        var s = this._get_settings().themeroller;
+        obj = !obj || obj == -1 ? this.get_container() : this._get_node(obj).parent();
+        obj
+          .find("li.jstree-closed > ins.jstree-icon").removeClass(s.opened).addClass("ui-icon " + s.closed).end()
+          .find("li.jstree-open > ins.jstree-icon").removeClass(s.closed).addClass("ui-icon " + s.opened).end()
+          .find("a").addClass(s.item)
+            .children("ins.jstree-icon").addClass("ui-icon " + s.item_icon);
+      }
+    },
+    defaults : {
+      "opened" : "ui-icon-triangle-1-se",
+      "closed" : "ui-icon-triangle-1-e",
+      "item" : "ui-state-default",
+      "item_h" : "ui-state-hover",
+      "item_a" : "ui-state-active",
+      "item_icon" : "ui-icon-folder-collapsed"
+    }
+  });
+  $(function() {
+    var css_string = '.jstree .ui-icon { overflow:visible; } .jstree a { padding:0 2px; }';
+    $.vakata.css.add_sheet({ str : css_string });
+  });
 })(jQuery);
 //*/
 
@@ -3466,69 +3466,69 @@ THE SOFTWARE.
  * NOTE: does not check language versions (it will not be possible to have nodes with the same title, even in different languages)
  */
 (function ($) {
-	$.jstree.plugin("unique", {
-		__init : function () {
-			this.get_container()
-				.bind("before.jstree", $.proxy(function (e, data) { 
-						var nms = [], res = true, p, t;
-						if(data.func == "move_node") {
-							// obj, ref, position, is_copy, is_prepared, skip_check
-							if(data.args[4] === true) {
-								if(data.args[0].o && data.args[0].o.length) {
-									data.args[0].o.children("a").each(function () { nms.push($(this).text().replace(/^\s+/g,"")); });
-									res = this._check_unique(nms, data.args[0].np.find("> ul > li").not(data.args[0].o));
-								}
-							}
-						}
-						if(data.func == "create_node") {
-							// obj, position, js, callback, is_loaded
-							if(data.args[4] || this._is_loaded(data.args[0])) {
-								p = this._get_node(data.args[0]);
-								if(data.args[1] && (data.args[1] === "before" || data.args[1] === "after")) {
-									p = this._get_parent(data.args[0]);
-									if(!p || p === -1) { p = this.get_container(); }
-								}
-								if(typeof data.args[2] === "string") { nms.push(data.args[2]); }
-								else if(!data.args[2] || !data.args[2].data) { nms.push(this._get_settings().core.strings.new_node); }
-								else { nms.push(data.args[2].data); }
-								res = this._check_unique(nms, p.find("> ul > li"));
-							}
-						}
-						if(data.func == "rename_node") {
-							// obj, val
-							nms.push(data.args[1]);
-							t = this._get_node(data.args[0]);
-							p = this._get_parent(t);
-							if(!p || p === -1) { p = this.get_container(); }
-							res = this._check_unique(nms, p.find("> ul > li").not(t));
-						}
-						if(!res) {
-							e.stopPropagation();
-							return false;
-						}
-					}, this));
-		},
-		_fn : { 
-			_check_unique : function (nms, p) {
-				var cnms = [];
-				p.children("a").each(function () { cnms.push($(this).text().replace(/^\s+/g,"")); });
-				if(!cnms.length || !nms.length) { return true; }
-				cnms = cnms.sort().join(",,").replace(/(,|^)([^,]+)(,,\2)+(,|$)/g,"$1$2$4").replace(/,,+/g,",").replace(/,$/,"").split(",");
-				if((cnms.length + nms.length) != cnms.concat(nms).sort().join(",,").replace(/(,|^)([^,]+)(,,\2)+(,|$)/g,"$1$2$4").replace(/,,+/g,",").replace(/,$/,"").split(",").length) {
-					return false;
-				}
-				return true;
-			},
-			check_move : function () {
-				if(!this.__call_old()) { return false; }
-				var p = this._get_move(), nms = [];
-				if(p.o && p.o.length) {
-					p.o.children("a").each(function () { nms.push($(this).text().replace(/^\s+/g,"")); });
-					return this._check_unique(nms, p.np.find("> ul > li").not(p.o));
-				}
-				return true;
-			}
-		}
-	});
+  $.jstree.plugin("unique", {
+    __init : function () {
+      this.get_container()
+        .bind("before.jstree", $.proxy(function (e, data) { 
+            var nms = [], res = true, p, t;
+            if(data.func == "move_node") {
+              // obj, ref, position, is_copy, is_prepared, skip_check
+              if(data.args[4] === true) {
+                if(data.args[0].o && data.args[0].o.length) {
+                  data.args[0].o.children("a").each(function () { nms.push($(this).text().replace(/^\s+/g,"")); });
+                  res = this._check_unique(nms, data.args[0].np.find("> ul > li").not(data.args[0].o));
+                }
+              }
+            }
+            if(data.func == "create_node") {
+              // obj, position, js, callback, is_loaded
+              if(data.args[4] || this._is_loaded(data.args[0])) {
+                p = this._get_node(data.args[0]);
+                if(data.args[1] && (data.args[1] === "before" || data.args[1] === "after")) {
+                  p = this._get_parent(data.args[0]);
+                  if(!p || p === -1) { p = this.get_container(); }
+                }
+                if(typeof data.args[2] === "string") { nms.push(data.args[2]); }
+                else if(!data.args[2] || !data.args[2].data) { nms.push(this._get_settings().core.strings.new_node); }
+                else { nms.push(data.args[2].data); }
+                res = this._check_unique(nms, p.find("> ul > li"));
+              }
+            }
+            if(data.func == "rename_node") {
+              // obj, val
+              nms.push(data.args[1]);
+              t = this._get_node(data.args[0]);
+              p = this._get_parent(t);
+              if(!p || p === -1) { p = this.get_container(); }
+              res = this._check_unique(nms, p.find("> ul > li").not(t));
+            }
+            if(!res) {
+              e.stopPropagation();
+              return false;
+            }
+          }, this));
+    },
+    _fn : { 
+      _check_unique : function (nms, p) {
+        var cnms = [];
+        p.children("a").each(function () { cnms.push($(this).text().replace(/^\s+/g,"")); });
+        if(!cnms.length || !nms.length) { return true; }
+        cnms = cnms.sort().join(",,").replace(/(,|^)([^,]+)(,,\2)+(,|$)/g,"$1$2$4").replace(/,,+/g,",").replace(/,$/,"").split(",");
+        if((cnms.length + nms.length) != cnms.concat(nms).sort().join(",,").replace(/(,|^)([^,]+)(,,\2)+(,|$)/g,"$1$2$4").replace(/,,+/g,",").replace(/,$/,"").split(",").length) {
+          return false;
+        }
+        return true;
+      },
+      check_move : function () {
+        if(!this.__call_old()) { return false; }
+        var p = this._get_move(), nms = [];
+        if(p.o && p.o.length) {
+          p.o.children("a").each(function () { nms.push($(this).text().replace(/^\s+/g,"")); });
+          return this._check_unique(nms, p.np.find("> ul > li").not(p.o));
+        }
+        return true;
+      }
+    }
+  });
 })(jQuery);
 //*/
diff --git a/solr/webapp/web/libs/ngtimeago.js b/solr/webapp/web/libs/ngtimeago.js
index dc29b18..f98b216 100644
--- a/solr/webapp/web/libs/ngtimeago.js
+++ b/solr/webapp/web/libs/ngtimeago.js
@@ -31,7 +31,7 @@ catalyst.filter('timeago', function() {
             if (input === undefined) {
               return "-";
             }
-		
+    
             var substitute = function (stringOrFunction, number, strings) {
                     var string = angular.isFunction(stringOrFunction) ? stringOrFunction(number, dateDifference) : stringOrFunction;
                     var value = (strings.numbers && strings.numbers[number]) || number;
@@ -89,11 +89,11 @@ catalyst.filter('timeago', function() {
             days < 365 && substitute(strings.months, Math.round(days / 30), strings) ||
             years < 1.5 && substitute(strings.year, 1, strings) ||
             substitute(strings.years, Math.round(years), strings);
-			console.log(prefix+words+suffix+separator);
-			prefix.replace(/ /g, '')
-			words.replace(/ /g, '')
-			suffix.replace(/ /g, '')
-			return (prefix+' '+words+' '+suffix+' '+separator);
+            console.log(prefix+words+suffix+separator);
+            prefix.replace(/ /g, '')
+            words.replace(/ /g, '')
+            suffix.replace(/ /g, '')
+            return (prefix+' '+words+' '+suffix+' '+separator);
             
         };
     });

